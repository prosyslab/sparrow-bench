/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 26 "./unitypes.h"
typedef unsigned int ucs4_t;
#line 41 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
enum bitset_type {
    BITSET_ARRAY = 0,
    BITSET_LIST = 1,
    BITSET_TABLE = 2,
    BITSET_VARRAY = 3,
    BITSET_TYPE_NUM = 4,
    BITSET_STATS = 5
} ;
#line 50 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
typedef unsigned long bitset_word;
#line 59 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
typedef size_t bitset_bindex;
#line 62 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
typedef size_t bitset_windex;
#line 84
struct bitset_vtable;
#line 84 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
struct bbitset_struct {
   struct bitset_vtable  const  *vtable ;
   bitset_windex cindex ;
   bitset_windex csize ;
   bitset_word *cdata ;
   bitset_bindex n_bits ;
};
#line 99
union bitset_union;
#line 99 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
typedef union bitset_union *bitset;
#line 111 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
struct bitset_vtable {
   void (*set)(bitset  , bitset_bindex  ) ;
   void (*reset)(bitset  , bitset_bindex  ) ;
   _Bool (*toggle)(bitset  , bitset_bindex  ) ;
   _Bool (*test)(bitset  , bitset_bindex  ) ;
   bitset_bindex (*resize)(bitset  , bitset_bindex  ) ;
   bitset_bindex (*size)(bitset  ) ;
   bitset_bindex (*count)(bitset  ) ;
   _Bool (*empty_p)(bitset  ) ;
   void (*ones)(bitset  ) ;
   void (*zero)(bitset  ) ;
   void (*copy)(bitset  , bitset  ) ;
   _Bool (*disjoint_p)(bitset  , bitset  ) ;
   _Bool (*equal_p)(bitset  , bitset  ) ;
   void (*not_)(bitset  , bitset  ) ;
   _Bool (*subset_p)(bitset  , bitset  ) ;
   void (*and_)(bitset  , bitset  , bitset  ) ;
   _Bool (*and_cmp)(bitset  , bitset  , bitset  ) ;
   void (*andn)(bitset  , bitset  , bitset  ) ;
   _Bool (*andn_cmp)(bitset  , bitset  , bitset  ) ;
   void (*or_)(bitset  , bitset  , bitset  ) ;
   _Bool (*or_cmp)(bitset  , bitset  , bitset  ) ;
   void (*xor_)(bitset  , bitset  , bitset  ) ;
   _Bool (*xor_cmp)(bitset  , bitset  , bitset  ) ;
   void (*and_or)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*and_or_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   void (*andn_or)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*andn_or_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   void (*or_and)(bitset  , bitset  , bitset  , bitset  ) ;
   _Bool (*or_and_cmp)(bitset  , bitset  , bitset  , bitset  ) ;
   bitset_bindex (*list)(bitset  , bitset_bindex * , bitset_bindex  , bitset_bindex * ) ;
   bitset_bindex (*list_reverse)(bitset  , bitset_bindex * , bitset_bindex  , bitset_bindex * ) ;
   void (*free)(bitset  ) ;
   enum bitset_type type ;
};
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct abitset_struct {
   struct bbitset_struct b ;
   bitset_word words[1] ;
};
#line 46
struct ebitset_elt_struct;
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct ebitset_struct {
   struct bbitset_struct b ;
   bitset_windex size ;
   struct ebitset_elt_struct **elts ;
};
#line 46
struct lbitset_elt_struct;
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct lbitset_struct {
   struct bbitset_struct b ;
   struct lbitset_elt_struct *head ;
   struct lbitset_elt_struct *tail ;
};
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct bitset_stats_struct {
   struct bbitset_struct b ;
   bitset bset ;
};
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct vbitset_struct {
   struct bbitset_struct b ;
   bitset_windex size ;
};
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
union bitset_union {
   struct bbitset_struct b ;
   struct abitset_struct a ;
   struct ebitset_struct e ;
   struct lbitset_struct l ;
   struct bitset_stats_struct s ;
   struct vbitset_struct v ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 147 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 35 "/usr/include/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 49 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.h"
struct timevar_time_def {
   float user ;
   float sys ;
   float wall ;
};
#line 67
enum __anonenum_timevar_id_t_33 {
    TV_TOTAL = 0,
    TV_READER = 1,
    TV_SCANNING = 2,
    TV_PARSING = 3,
    TV_REDUCE = 4,
    TV_SETS = 5,
    TV_LR0 = 6,
    TV_LALR = 7,
    TV_CONFLICTS = 8,
    TV_REPORT = 9,
    TV_GRAPH = 10,
    TV_XML = 11,
    TV_ACTIONS = 12,
    TV_PARSER = 13,
    TV_M4 = 14,
    TV_FREE = 15,
    TIMEVAR_LAST = 16
} ;
#line 67 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.h"
typedef enum __anonenum_timevar_id_t_33 timevar_id_t;
#line 138 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
struct timevar_def {
   struct timevar_time_def elapsed ;
   struct timevar_time_def start_time ;
   char const   *name ;
   unsigned int standalone : 1 ;
   unsigned int used : 1 ;
};
#line 162 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
struct timevar_stack_def {
   struct timevar_def *timevar ;
   struct timevar_stack_def *next ;
};
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 157 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
union __anonunion___u_43 {
   int __in ;
   int __i ;
};
#line 157 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
union __anonunion___u_44 {
   int __in ;
   int __i ;
};
#line 157 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
union __anonunion___u_45 {
   int __in ;
   int __i ;
};
#line 152 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef int ptrdiff_t;
#line 326 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef int wchar_t;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7
} ;
#line 192
struct quoting_options;
#line 355 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int wint_t;
#line 76 "/usr/include/wchar.h"
union __anonunion___value_20 {
   wint_t __wch ;
   char __wchb[4] ;
};
#line 76 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_19 {
   int __count ;
   union __anonunion___value_20 __value ;
};
#line 76 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_19 __mbstate_t;
#line 95 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 63 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
};
#line 642 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 34 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.h"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 40 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 52 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 54
struct hash_table;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.h"
typedef struct hash_table Hash_table;
#line 49 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 77 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
enum bitset_ops {
    BITSET_OP_ZERO = 0,
    BITSET_OP_ONES = 1,
    BITSET_OP_COPY = 2,
    BITSET_OP_NOT = 3,
    BITSET_OP_EMPTY_P = 4,
    BITSET_OP_EQUAL_P = 5,
    BITSET_OP_SUBSET_P = 6,
    BITSET_OP_DISJOINT_P = 7,
    BITSET_OP_AND = 8,
    BITSET_OP_OR = 9,
    BITSET_OP_XOR = 10,
    BITSET_OP_ANDN = 11,
    BITSET_OP_OR_AND = 12,
    BITSET_OP_AND_OR = 13,
    BITSET_OP_ANDN_OR = 14
} ;
#line 142 "/home/pronto/abs/test-suite/bison-2.4/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/home/pronto/abs/test-suite/bison-2.4/lib/obstack.h"
union __anonunion_temp_2 {
   int tempint ;
   void *tempptr ;
};
#line 149 "/home/pronto/abs/test-suite/bison-2.4/lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_2 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 55 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
union __anonunion_u_29 {
   bitset_word words[2] ;
   struct ebitset_elt_struct *next ;
};
#line 55 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
struct ebitset_elt_struct {
   union __anonunion_u_29 u ;
};
#line 55 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
typedef struct ebitset_elt_struct ebitset_elt;
#line 67 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
typedef ebitset_elt *ebitset_elts;
#line 77
enum ebitset_find_mode {
    EBITSET_FIND = 0,
    EBITSET_CREATE = 1,
    EBITSET_SUBST = 2
} ;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 93 "/usr/include/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   unsigned int __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned int __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 40 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
typedef unsigned int bitset_attrs;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.h"
typedef bitset *bitsetv;
#line 75 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
struct bitset_type_info_struct {
   unsigned int allocs ;
   unsigned int frees ;
   unsigned int lists ;
   unsigned int sets ;
   unsigned int cache_sets ;
   unsigned int resets ;
   unsigned int cache_resets ;
   unsigned int tests ;
   unsigned int cache_tests ;
   unsigned int list_counts[10] ;
   unsigned int list_sizes[16] ;
   unsigned int list_density[20] ;
};
#line 91 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
struct bitset_stats_info_struct {
   unsigned int runs ;
   struct bitset_type_info_struct types[4] ;
};
#line 89 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
struct __anonstruct_bitset_iterator_13 {
   bitset_bindex list[1024] ;
   bitset_bindex next ;
   bitset_bindex num ;
   bitset_bindex i ;
};
#line 89 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
typedef struct __anonstruct_bitset_iterator_13 bitset_iterator;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.h"
typedef char const   *uniqstr;
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
struct __anonstruct_boundary_33 {
   uniqstr file ;
   int line ;
   int column ;
};
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
typedef struct __anonstruct_boundary_33 boundary;
#line 60 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
struct __anonstruct_location_34 {
   boundary start ;
   boundary end ;
};
#line 60 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
typedef struct __anonstruct_location_34 location;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/src/assoc.h"
enum __anonenum_assoc_35 {
    undef_assoc = 0,
    right_assoc = 1,
    left_assoc = 2,
    non_assoc = 3
} ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/src/assoc.h"
typedef enum __anonenum_assoc_35 assoc;
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
struct symbol_list;
#line 40
enum __anonenum_kind_36 {
    CODE_PROPS_NONE = 0,
    CODE_PROPS_PLAIN = 1,
    CODE_PROPS_SYMBOL_ACTION = 2,
    CODE_PROPS_RULE_ACTION = 3
} ;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
struct code_props {
   enum __anonenum_kind_36 kind ;
   char const   *code ;
   location location ;
   _Bool is_value_used ;
   struct symbol_list *rule ;
};
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
typedef struct code_props code_props;
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
enum __anonenum_symbol_class_37 {
    unknown_sym = 0,
    token_sym = 1,
    nterm_sym = 2
} ;
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
typedef enum __anonenum_symbol_class_37 symbol_class;
#line 48 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
typedef int symbol_number;
#line 52
struct symbol;
#line 52 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
typedef struct symbol symbol;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
struct symbol {
   uniqstr tag ;
   location location ;
   uniqstr type_name ;
   location type_location ;
   code_props destructor ;
   code_props printer ;
   symbol_number number ;
   location prec_location ;
   int prec ;
   assoc assoc ;
   int user_token_number ;
   symbol *alias ;
   symbol_class class ;
   _Bool declared ;
};
#line 189 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
struct __anonstruct_semantic_type_38 {
   uniqstr tag ;
   code_props destructor ;
   code_props printer ;
};
#line 189 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
typedef struct __anonstruct_semantic_type_38 semantic_type;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.h"
enum __anonenum_content_type_39 {
    SYMLIST_SYMBOL = 0,
    SYMLIST_TYPE = 1,
    SYMLIST_DEFAULT_TAGGED = 2,
    SYMLIST_DEFAULT_TAGLESS = 3
} ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.h"
union __anonunion_content_40 {
   symbol *sym ;
   uniqstr type_name ;
};
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.h"
struct symbol_list {
   enum __anonenum_content_type_39 content_type ;
   union __anonunion_content_40 content ;
   location location ;
   struct symbol_list *midrule ;
   struct symbol_list *midrule_parent_rule ;
   int midrule_parent_rhs_index ;
   code_props action_props ;
   symbol *ruleprec ;
   int dprec ;
   int merger ;
   location merger_declaration_location ;
   struct symbol_list *next ;
};
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.h"
typedef struct symbol_list symbol_list;
#line 89 "scan-skel.c"
typedef short flex_int16_t;
#line 91 "scan-skel.c"
typedef int flex_int32_t;
#line 214
struct yy_buffer_state;
#line 214 "scan-skel.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 251 "scan-skel.c"
typedef size_t yy_size_t;
#line 256 "scan-skel.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 432 "scan-skel.c"
typedef unsigned char YY_CHAR;
#line 436 "scan-skel.c"
typedef int yy_state_type;
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/relation.h"
typedef size_t relation_node;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/src/relation.h"
typedef relation_node *relation_nodes;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/src/relation.h"
typedef relation_nodes *relation;
#line 115 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
typedef int item_number;
#line 147 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
typedef int rule_number;
#line 173 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
struct __anonstruct_rule_40 {
   rule_number user_number ;
   rule_number number ;
   symbol *lhs ;
   item_number *rhs ;
   symbol *prec ;
   int dprec ;
   int merger ;
   symbol *precsym ;
   location location ;
   _Bool useful ;
   char const   *action ;
   location action_location ;
};
#line 173 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
typedef struct __anonstruct_rule_40 rule;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
struct merger_list {
   struct merger_list *next ;
   uniqstr name ;
   uniqstr type ;
   location type_declaration_location ;
};
#line 29 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
typedef struct merger_list merger_list;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 94 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
typedef int state_number;
#line 105
struct state;
#line 105 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
typedef struct state state;
#line 111 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
struct __anonstruct_transitions_41 {
   int num ;
   state *states[1] ;
};
#line 111 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
typedef struct __anonstruct_transitions_41 transitions;
#line 169 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
struct __anonstruct_errs_42 {
   int num ;
   symbol *symbols[1] ;
};
#line 169 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
typedef struct __anonstruct_errs_42 errs;
#line 182 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
struct __anonstruct_reductions_43 {
   int num ;
   bitset *lookahead_tokens ;
   rule *rules[1] ;
};
#line 182 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
typedef struct __anonstruct_reductions_43 reductions;
#line 196 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
struct state {
   state_number number ;
   symbol_number accessing_symbol ;
   transitions *transitions ;
   reductions *reductions ;
   errs *errs ;
   char consistent ;
   char const   *solved_conflicts ;
   char const   *solved_conflicts_xml ;
   size_t nitems ;
   item_number items[1] ;
};
#line 46 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
struct escape_buf {
   char *ptr ;
   size_t size ;
};
#line 160 "/home/pronto/abs/test-suite/bison-2.4/src/parse-gram.h"
union YYSTYPE {
   symbol *symbol ;
   symbol_list *list ;
   int integer ;
   char const   *chars ;
   char *code ;
   assoc assoc ;
   uniqstr uniqstr ;
   unsigned char character ;
};
#line 160 "/home/pronto/abs/test-suite/bison-2.4/src/parse-gram.h"
typedef union YYSTYPE YYSTYPE;
#line 349 "parse-gram.c"
typedef unsigned long yytype_uint8;
#line 355 "parse-gram.c"
typedef long yytype_int8;
#line 364 "parse-gram.c"
typedef unsigned long yytype_uint16;
#line 370 "parse-gram.c"
typedef long yytype_int16;
#line 504 "parse-gram.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
   location yyls_alloc ;
};
#line 62 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
struct bison_language {
   char language[sizeof("Java")] ;
   char skeleton[sizeof("java-skel.m4")] ;
   char src_extension[sizeof(".java")] ;
   char header_extension[sizeof(".java")] ;
   _Bool add_tab ;
};
#line 93 "/home/pronto/abs/test-suite/bison-2.4/src/tables.h"
typedef int base_number;
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
struct rule_list {
   struct rule_list *next ;
   rule *value ;
};
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
typedef struct rule_list rule_list;
#line 34 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
struct __anonstruct_muscle_entry_35 {
   char const   *key ;
   char const   *value ;
   char *storage ;
};
#line 34 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
typedef struct __anonstruct_muscle_entry_35 muscle_entry;
#line 66 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.h"
typedef size_t goto_number;
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
struct goto_list {
   struct goto_list *next ;
   goto_number value ;
};
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
typedef struct goto_list goto_list;
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
enum conflict_resolution {
    shift_resolution = 0,
    reduce_resolution = 1,
    left_resolution = 2,
    right_resolution = 3,
    nonassoc_resolution = 4
} ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
struct state_list {
   struct state_list *next ;
   state *state ;
};
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
typedef struct state_list state_list;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 138 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 53 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 55 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 56
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 57
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 58
void *xrealloc(void *p , size_t n ) ;
#line 59
void *x2realloc(void *p , size_t *pn ) ;
#line 60
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 61
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 194 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 197
  n = *pn;
#line 199
  if (! p) {
#line 201
    if (! n) {
#line 209
      n = 64U / s;
#line 210
      n += (size_t )(! n);
    }
  } else {
#line 219
    if (2863311530U / s <= n) {
      {
#line 220
      xalloc_die();
      }
    }
#line 221
    n += (n + 1U) / 2U;
  }
  {
#line 224
  *pn = n;
#line 225
  tmp = xrealloc(p, n * s);
  }
#line 225
  return (tmp);
}
}
#line 30 "/usr/include/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 33
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 41
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 41 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 


  {
#line 44
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 47
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 47 "/usr/include/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 


  {
#line 50
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 53
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53 "/usr/include/sys/sysmacros.h"
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 


  {
#line 56
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 586
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 595
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 59
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 242
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 46 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 49
  tmp = malloc(n);
#line 49
  p = tmp;
  }
#line 50
  if (! p) {
#line 50
    if (n != 0U) {
      {
#line 51
      xalloc_die();
      }
    }
  }
#line 52
  return (p);
}
}
#line 58 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n != 0U) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 83 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 92 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 110 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/pronto/abs/test-suite/bison-2.4/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1U);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 622 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.4/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/pronto/abs/test-suite/bison-2.4/lib/exitfail.h"
int volatile   exit_failure ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 99 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 22 "/home/pronto/abs/test-suite/bison-2.4/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 25
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 25
  if (tmp == 0) {
#line 37
    return (1);
  } else {
    {
#line 25
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 25
    if (tmp___0 == 0) {
#line 37
      return (1);
    } else {
      {
#line 25
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 25
      if (tmp___1 == 0) {
#line 37
        return (1);
      } else {
        {
#line 25
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 25
        if (tmp___2 == 0) {
#line 37
          return (1);
        } else {
          {
#line 25
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 25
          if (tmp___3 == 0) {
#line 37
            return (1);
          } else {
            {
#line 25
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 25
            if (tmp___4 == 0) {
#line 37
              return (1);
            } else {
              {
#line 25
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 25
              if (tmp___5 == 0) {
#line 37
                return (1);
              } else {
                {
#line 25
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 25
                if (tmp___6 == 0) {
#line 37
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 38
  return (0);
}
}
#line 37 "/home/pronto/abs/test-suite/bison-2.4/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1408]  = 
#line 37 "/home/pronto/abs/test-suite/bison-2.4/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )120,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )255, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )14,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )14,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )197,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )15,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 237 "/home/pronto/abs/test-suite/bison-2.4/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 237
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )15,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )17,      (signed char const   )-1,      (signed char const   )18, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )20,      (signed char const   )21,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 271 "/home/pronto/abs/test-suite/bison-2.4/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 275
  if (uc >> 9 < 240U) {
#line 277
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 278
    if (ind >= 0) {
#line 279
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 281
        if (uc > 0U) {
#line 281
          if (uc < 160U) {
#line 282
            return (-1);
          } else {
#line 284
            return (0);
          }
        } else {
#line 284
          return (0);
        }
      }
    }
  } else
#line 287
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 289
    if (uc >= 917760U) {
#line 291
      if (uc <= 917999U) {
#line 292
        return (0);
      }
    } else {
#line 296
      if (uc >= 917536U) {
#line 296
        tmp = uc <= 917631U;
      } else {
#line 296
        tmp = uc == 917505U;
      }
#line 296
      if (tmp) {
#line 297
        return (0);
      }
    }
  }
#line 304
  if (uc >= 4352U) {
#line 304
    if (uc < 4448U) {
#line 318
      return (2);
    } else
#line 304
    if (uc >= 9001U) {
#line 304
      if (uc < 9003U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 304
    if (uc >= 11904U) {
#line 304
      if (uc < 42192U) {
#line 304
        if (! (uc == 12351U)) {
#line 304
          if (uc >= 19904U) {
#line 304
            if (uc < 19968U) {
#line 304
              goto _L___8;
            } else {
#line 318
              return (2);
            }
          } else {
#line 318
            return (2);
          }
        } else {
#line 304
          goto _L___8;
        }
      } else {
#line 304
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 304
    if (uc >= 44032U) {
#line 304
      if (uc < 55204U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 304
    if (uc >= 63744U) {
#line 304
      if (uc < 64256U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 304
    if (uc >= 65040U) {
#line 304
      if (uc < 65056U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 304
    if (uc >= 65072U) {
#line 304
      if (uc < 65136U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 304
    if (uc >= 65280U) {
#line 304
      if (uc < 65377U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 304
    if (uc >= 65504U) {
#line 304
      if (uc < 65511U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 304
    if (uc >= 131072U) {
#line 304
      if (uc <= 173782U) {
#line 318
        return (2);
      } else {
#line 304
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 304
    if (uc >= 194560U) {
#line 304
      if (uc <= 195101U) {
#line 318
        return (2);
      }
    }
  }
#line 321
  if (uc >= 161U) {
#line 321
    if (uc < 65377U) {
#line 321
      if (uc != 8361U) {
        {
#line 321
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 321
        if (tmp___0) {
#line 323
          return (2);
        }
      }
    }
  }
#line 324
  return (1);
}
}
#line 281 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
_Bool bitset_toggle_(bitset bset , bitset_bindex bitno ) ;
#line 283
bitset_bindex bitset_count_(bitset src ) ;
#line 285
bitset_bindex bitset_size_(bitset src ) ;
#line 287
_Bool bitset_copy_(bitset dst , bitset src ) ;
#line 289
void bitset_and_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 291
_Bool bitset_and_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 293
void bitset_andn_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 295
_Bool bitset_andn_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 297
void bitset_or_and_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 299
_Bool bitset_or_and_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.h"
size_t vbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 25
bitset vbitset_init(bitset bset , bitset_bindex n_bits ) ;
#line 33 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
__inline static void vbitset_unused_clear(bitset dst ) ;
#line 35
static void vbitset_set(bitset dst , bitset_bindex bitno ) ;
#line 36
static void vbitset_reset(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) ;
#line 37
static _Bool vbitset_test(bitset src  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) ;
#line 38
static bitset_bindex vbitset_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) ;
#line 40
static bitset_bindex vbitset_list_reverse(bitset src , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) ;
#line 53 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static bitset_bindex vbitset_resize(bitset src , bitset_bindex n_bits ) 
{ 
  bitset_windex oldsize ;
  bitset_windex newsize ;
  bitset_windex size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 59
  if (n_bits == src->b.n_bits) {
#line 60
    return (n_bits);
  }
#line 62
  oldsize = src->b.csize;
#line 63
  newsize = ((n_bits + (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (unsigned int )(8UL * sizeof(bitset_word ));
#line 65
  if (oldsize < newsize) {
#line 71
    if (newsize > src->v.size) {
#line 78
      if (oldsize == 0U) {
#line 79
        size = newsize;
      } else {
#line 81
        size = newsize + newsize / 4U;
      }
      {
#line 83
      tmp = realloc((void *)src->b.cdata, (size_t )((unsigned long )size * sizeof(bitset_word )));
#line 83
      src->b.cdata = (bitset_word *)tmp;
#line 85
      src->v.size = size;
      }
    }
    {
#line 88
    memset((void *)(src->b.cdata + oldsize), 0, (size_t )((unsigned long )(newsize - oldsize) * sizeof(bitset_word )));
#line 90
    src->b.csize = newsize;
    }
  } else {
#line 96
    if (oldsize - newsize >= oldsize / 2U) {
      {
#line 98
      tmp___0 = realloc((void *)src->b.cdata, (size_t )((unsigned long )newsize * sizeof(bitset_word )));
#line 98
      src->b.cdata = (bitset_word *)tmp___0;
#line 100
      src->v.size = newsize;
      }
    }
#line 105
    src->b.csize = newsize;
  }
#line 108
  src->b.n_bits = n_bits;
#line 109
  return (n_bits);
}
}
#line 114 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;

  {
  {
#line 119
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 125
  vbitset_resize(dst, bitno);
#line 127
  *(dst->b.cdata + (windex - dst->b.cindex)) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 129
  return;
}
}
#line 133 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_reset(bitset dst  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 140
  return;
}
}
#line 144 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_test(bitset src  __attribute__((__unused__)) , bitset_bindex bitno  __attribute__((__unused__)) ) 
{ 


  {
#line 151
  return ((_Bool)0);
}
}
#line 159 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static bitset_bindex vbitset_list_reverse(bitset src , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex rbitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  unsigned int bitcnt ;
  bitset_bindex bitoff ;
  bitset_word *srcp ;
  bitset_bindex n_bits ;
  bitset_bindex tmp ;
  bitset_word word ;
  bitset_bindex tmp___0 ;
  bitset_windex tmp___1 ;

  {
  {
#line 172
  srcp = src->b.cdata;
#line 173
  tmp = (*((src->b.vtable)->size))(src);
#line 173
  n_bits = tmp;
#line 175
  rbitno = *next;
  }
#line 180
  if (rbitno >= n_bits) {
#line 181
    return ((bitset_bindex )0);
  }
#line 183
  count = (bitset_bindex )0;
#line 185
  bitno = n_bits - (rbitno + 1U);
#line 187
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 188
  bitcnt = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 189
  bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    word = *(srcp + windex) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bitcnt);
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 196
      if (! word) {
#line 196
        goto while_break___0;
      }
#line 198
      if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 200
        tmp___0 = count;
#line 200
        count ++;
#line 200
        *(list + tmp___0) = bitoff + bitcnt;
#line 201
        if (count >= num) {
#line 203
          *next = n_bits - (bitoff + bitcnt);
#line 204
          return (count);
        }
      }
#line 207
      word <<= 1;
#line 196
      bitcnt --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    bitoff -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 210
    bitcnt = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 191
    tmp___1 = windex;
#line 191
    windex --;
#line 191
    if (! tmp___1) {
#line 191
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  *next = n_bits - (bitoff + 1U);
#line 215
  return (count);
}
}
#line 222 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static bitset_bindex vbitset_list(bitset src , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_bindex count ;
  bitset_windex windex ;
  bitset_bindex bitoff ;
  bitset_windex size ;
  bitset_word *srcp ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 233
  size = src->b.csize;
#line 234
  srcp = src->b.cdata;
#line 237
  bitno = *next;
#line 239
  count = (bitset_bindex )0;
#line 240
  if (! bitno) {
#line 243
    windex = (bitset_windex )0;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (windex < size) {
#line 243
        if (! (! *(srcp + windex))) {
#line 243
          goto while_break;
        }
      } else {
#line 243
        goto while_break;
      }
#line 244
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 243
      windex ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 245
    if (windex >= size) {
#line 246
      return ((bitset_bindex )0);
    }
#line 251
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
    {
#line 255
    tmp = (*((src->b.vtable)->size))(src);
    }
#line 255
    if (bitno >= tmp) {
#line 256
      return ((bitset_bindex )0);
    }
#line 258
    windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 259
    bitno %= (unsigned int )(8UL * sizeof(bitset_word ));
#line 261
    if (bitno) {
#line 268
      bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 269
      word = *(srcp + windex) >> bitno;
#line 270
      bitno = bitoff + bitno;
      {
#line 270
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 270
        if (! word) {
#line 270
          goto while_break___0;
        }
#line 272
        if (word & 1UL) {
#line 274
          tmp___0 = count;
#line 274
          count ++;
#line 274
          *(list + tmp___0) = bitno;
#line 275
          if (count >= num) {
#line 277
            *next = bitno + 1U;
#line 278
            return (count);
          }
        }
#line 281
        word >>= 1;
#line 270
        bitno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 283
      windex ++;
    }
#line 285
    bitoff = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  }
  {
#line 288
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 288
    if (! (windex < size)) {
#line 288
      goto while_break___1;
    }
#line 290
    word = *(srcp + windex);
#line 290
    if (! word) {
#line 291
      goto __Cont___0;
    }
#line 293
    if (count + (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 295
      bitno = bitoff;
      {
#line 295
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 295
        if (! word) {
#line 295
          goto while_break___2;
        }
#line 297
        if (word & 1UL) {
#line 298
          tmp___1 = count;
#line 298
          count ++;
#line 298
          *(list + tmp___1) = bitno;
        }
#line 299
        word >>= 1;
#line 295
        bitno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 304
      bitno = bitoff;
      {
#line 304
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 304
        if (! word) {
#line 304
          goto while_break___3;
        }
#line 306
        if (word & 1UL) {
#line 308
          tmp___2 = count;
#line 308
          count ++;
#line 308
          *(list + tmp___2) = bitno;
#line 309
          if (count >= num) {
#line 311
            *next = bitno + 1U;
#line 312
            return (count);
          }
        }
#line 315
        word >>= 1;
#line 304
        bitno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 288
    windex ++;
#line 288
    bitoff += (unsigned int )(8UL * sizeof(bitset_word ));
  }
  while_break___1: /* CIL Label */ ;
  }
#line 320
  *next = bitoff;
#line 321
  return (count);
}
}
#line 326 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
__inline static void vbitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex tmp ;

  {
  {
#line 332
  tmp = (*((dst->b.vtable)->size))(dst);
#line 332
  last_bit = tmp % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 333
  if (last_bit) {
#line 334
    *(dst->b.cdata + (dst->b.csize - 1U)) &= (1UL << last_bit) - 1UL;
  }
#line 336
  return;
}
}
#line 339 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_ones(bitset dst ) 
{ 
  bitset_word *dstp ;
  unsigned int bytes ;

  {
  {
#line 342
  dstp = dst->b.cdata;
#line 345
  bytes = (unsigned int )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 347
  memset((void *)dstp, -1, bytes);
#line 348
  vbitset_unused_clear(dst);
  }
#line 349
  return;
}
}
#line 352 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_zero(bitset dst ) 
{ 
  bitset_word *dstp ;
  unsigned int bytes ;

  {
  {
#line 355
  dstp = dst->b.cdata;
#line 358
  bytes = (unsigned int )(sizeof(bitset_word ) * (unsigned long )dst->b.csize);
#line 360
  memset((void *)dstp, 0, bytes);
  }
#line 361
  return;
}
}
#line 364 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_empty_p(bitset dst ) 
{ 
  unsigned int i ;
  bitset_word *dstp ;

  {
#line 368
  dstp = dst->b.cdata;
#line 370
  i = 0U;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < dst->b.csize)) {
#line 370
      goto while_break;
    }
#line 371
    if (*(dstp + i)) {
#line 372
      return ((_Bool)0);
    }
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((_Bool)1);
}
}
#line 378 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_copy1(bitset dst , bitset src ) 
{ 
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_bindex tmp ;

  {
#line 386
  if ((unsigned long )src == (unsigned long )dst) {
#line 387
    return;
  }
  {
#line 389
  tmp = (*((src->b.vtable)->size))(src);
#line 389
  vbitset_resize(dst, tmp);
#line 391
  srcp = src->b.cdata;
#line 392
  dstp = dst->b.cdata;
#line 393
  ssize = src->b.csize;
#line 394
  dsize = dst->b.csize;
#line 396
  memcpy((void */* __restrict  */)dstp, (void const   */* __restrict  */)srcp, (size_t )(sizeof(bitset_word ) * (unsigned long )ssize));
#line 398
  memset((void *)(dstp + sizeof(bitset_word ) * (unsigned long )ssize), 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize)));
  }
#line 400
  return;
}
}
#line 403 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_not(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_bindex tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;

  {
  {
#line 412
  tmp = (*((src->b.vtable)->size))(src);
#line 412
  vbitset_resize(dst, tmp);
#line 414
  srcp = src->b.cdata;
#line 415
  dstp = dst->b.cdata;
#line 416
  ssize = src->b.csize;
#line 417
  dsize = dst->b.csize;
#line 419
  i = 0U;
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i < ssize)) {
#line 419
      goto while_break;
    }
#line 420
    tmp___0 = dstp;
#line 420
    dstp ++;
#line 420
    tmp___1 = srcp;
#line 420
    srcp ++;
#line 420
    *tmp___0 = ~ *tmp___1;
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  vbitset_unused_clear(dst);
#line 423
  memset((void *)(dstp + sizeof(bitset_word ) * (unsigned long )ssize), 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize)));
  }
#line 425
  return;
}
}
#line 428 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_equal_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_windex tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 432
  srcp = src->b.cdata;
#line 433
  dstp = dst->b.cdata;
#line 434
  ssize = src->b.csize;
#line 435
  dsize = dst->b.csize;
#line 437
  i = 0U;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (ssize > dsize) {
#line 437
      tmp___1 = dsize;
    } else {
#line 437
      tmp___1 = ssize;
    }
#line 437
    if (! (i < tmp___1)) {
#line 437
      goto while_break;
    }
#line 438
    tmp = srcp;
#line 438
    srcp ++;
#line 438
    tmp___0 = dstp;
#line 438
    dstp ++;
#line 438
    if (*tmp != *tmp___0) {
#line 439
      return ((_Bool)0);
    }
#line 437
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (ssize > dsize) {
    {
#line 443
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 443
      if (! (i < ssize)) {
#line 443
        goto while_break___0;
      }
#line 444
      tmp___2 = srcp;
#line 444
      srcp ++;
#line 444
      if (*tmp___2) {
#line 445
        return ((_Bool)0);
      }
#line 443
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 449
      if (! (i < dsize)) {
#line 449
        goto while_break___1;
      }
#line 450
      tmp___3 = dstp;
#line 450
      dstp ++;
#line 450
      if (*tmp___3) {
#line 451
        return ((_Bool)0);
      }
#line 449
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 454
  return ((_Bool)1);
}
}
#line 458 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_subset_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_windex tmp ;
  bitset_word *tmp___0 ;

  {
#line 462
  srcp = src->b.cdata;
#line 463
  dstp = dst->b.cdata;
#line 464
  ssize = src->b.csize;
#line 465
  dsize = dst->b.csize;
#line 467
  i = 0U;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (ssize > dsize) {
#line 467
      tmp = dsize;
    } else {
#line 467
      tmp = ssize;
    }
#line 467
    if (! (i < tmp)) {
#line 467
      goto while_break;
    }
#line 468
    if (*dstp != (*srcp | *dstp)) {
#line 469
      return ((_Bool)0);
    }
#line 467
    i ++;
#line 467
    dstp ++;
#line 467
    srcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (ssize > dsize) {
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (i < ssize)) {
#line 473
        goto while_break___0;
      }
#line 474
      tmp___0 = srcp;
#line 474
      srcp ++;
#line 474
      if (*tmp___0) {
#line 475
        return ((_Bool)0);
      }
#line 473
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 478
  return ((_Bool)1);
}
}
#line 482 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_disjoint_p(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  bitset_word *srcp ;
  bitset_word *dstp ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_windex tmp___1 ;

  {
#line 486
  srcp = src->b.cdata;
#line 487
  dstp = dst->b.cdata;
#line 488
  ssize = src->b.csize;
#line 489
  dsize = dst->b.csize;
#line 491
  i = 0U;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (ssize > dsize) {
#line 491
      tmp___1 = dsize;
    } else {
#line 491
      tmp___1 = ssize;
    }
#line 491
    if (! (i < tmp___1)) {
#line 491
      goto while_break;
    }
#line 492
    tmp = srcp;
#line 492
    srcp ++;
#line 492
    tmp___0 = dstp;
#line 492
    dstp ++;
#line 492
    if (*tmp & *tmp___0) {
#line 493
      return ((_Bool)0);
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return ((_Bool)1);
}
}
#line 499 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_windex tmp___10 ;

  {
  {
#line 510
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 510
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 510
  if (tmp___4 > tmp___5) {
    {
#line 510
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 510
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 510
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 510
    tmp___3 = tmp___2;
    }
  }
  {
#line 510
  vbitset_resize(dst, tmp___3);
#line 512
  dsize = dst->b.csize;
#line 513
  ssize1 = src1->b.csize;
#line 514
  ssize2 = src2->b.csize;
#line 515
  dstp = dst->b.cdata;
#line 516
  src1p = src1->b.cdata;
#line 517
  src2p = src2->b.cdata;
#line 519
  i = 0U;
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (ssize1 > ssize2) {
#line 519
      tmp___9 = ssize2;
    } else {
#line 519
      tmp___9 = ssize1;
    }
#line 519
    if (! (i < tmp___9)) {
#line 519
      goto while_break;
    }
#line 520
    tmp___6 = dstp;
#line 520
    dstp ++;
#line 520
    tmp___7 = src1p;
#line 520
    src1p ++;
#line 520
    tmp___8 = src2p;
#line 520
    src2p ++;
#line 520
    *tmp___6 = *tmp___7 & *tmp___8;
#line 519
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if (ssize1 > ssize2) {
#line 522
    tmp___10 = ssize2;
  } else {
#line 522
    tmp___10 = ssize1;
  }
  {
#line 522
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - tmp___10)));
  }
#line 523
  return;
}
}
#line 526 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;

  {
  {
#line 530
  changed = 0;
#line 538
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 538
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 538
  if (tmp___4 > tmp___5) {
    {
#line 538
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 538
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 538
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 538
    tmp___3 = tmp___2;
    }
  }
  {
#line 538
  vbitset_resize(dst, tmp___3);
#line 540
  dsize = dst->b.csize;
#line 541
  ssize1 = src1->b.csize;
#line 542
  ssize2 = src2->b.csize;
#line 543
  dstp = dst->b.cdata;
#line 544
  src1p = src1->b.cdata;
#line 545
  src2p = src2->b.cdata;
#line 547
  i = 0U;
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (ssize1 > ssize2) {
#line 547
      tmp___9 = ssize2;
    } else {
#line 547
      tmp___9 = ssize1;
    }
#line 547
    if (! (i < tmp___9)) {
#line 547
      goto while_break;
    }
#line 549
    tmp___7 = src1p;
#line 549
    src1p ++;
#line 549
    tmp___8 = src2p;
#line 549
    src2p ++;
#line 549
    tmp___6 = *tmp___7 & *tmp___8;
#line 551
    if (*dstp != tmp___6) {
#line 553
      changed = 1;
#line 554
      *dstp = tmp___6;
    }
#line 547
    i ++;
#line 547
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  if (ssize2 > ssize1) {
#line 560
    src1p = src2p;
#line 561
    ssize1 = ssize2;
  }
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    if (! (i < ssize1)) {
#line 564
      goto while_break___0;
    }
#line 566
    if (*dstp != 0UL) {
#line 568
      changed = 1;
#line 569
      *dstp = (bitset_word )0;
    }
#line 564
    i ++;
#line 564
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 573
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 575
  return ((_Bool )changed);
}
}
#line 579 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;
  bitset_word *tmp___12 ;

  {
  {
#line 590
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 590
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 590
  if (tmp___4 > tmp___5) {
    {
#line 590
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 590
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 590
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 590
    tmp___3 = tmp___2;
    }
  }
  {
#line 590
  vbitset_resize(dst, tmp___3);
#line 592
  dsize = dst->b.csize;
#line 593
  ssize1 = src1->b.csize;
#line 594
  ssize2 = src2->b.csize;
#line 595
  dstp = dst->b.cdata;
#line 596
  src1p = src1->b.cdata;
#line 597
  src2p = src2->b.cdata;
#line 599
  i = 0U;
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    if (ssize1 > ssize2) {
#line 599
      tmp___9 = ssize2;
    } else {
#line 599
      tmp___9 = ssize1;
    }
#line 599
    if (! (i < tmp___9)) {
#line 599
      goto while_break;
    }
#line 600
    tmp___6 = dstp;
#line 600
    dstp ++;
#line 600
    tmp___7 = src1p;
#line 600
    src1p ++;
#line 600
    tmp___8 = src2p;
#line 600
    src2p ++;
#line 600
    *tmp___6 = *tmp___7 & ~ *tmp___8;
#line 599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if (ssize2 > ssize1) {
    {
#line 604
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 604
      if (! (i < ssize2)) {
#line 604
        goto while_break___0;
      }
#line 605
      tmp___10 = dstp;
#line 605
      dstp ++;
#line 605
      *tmp___10 = (bitset_word )0;
#line 604
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 607
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize2)));
    }
  } else {
    {
#line 611
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 611
      if (! (i < ssize1)) {
#line 611
        goto while_break___1;
      }
#line 612
      tmp___11 = dstp;
#line 612
      dstp ++;
#line 612
      tmp___12 = src1p;
#line 612
      src1p ++;
#line 612
      *tmp___11 = *tmp___12;
#line 611
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 614
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
    }
  }
#line 616
  return;
}
}
#line 619 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 623
  changed = 0;
#line 631
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 631
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 631
  if (tmp___4 > tmp___5) {
    {
#line 631
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 631
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 631
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 631
    tmp___3 = tmp___2;
    }
  }
  {
#line 631
  vbitset_resize(dst, tmp___3);
#line 633
  dsize = dst->b.csize;
#line 634
  ssize1 = src1->b.csize;
#line 635
  ssize2 = src2->b.csize;
#line 636
  dstp = dst->b.cdata;
#line 637
  src1p = src1->b.cdata;
#line 638
  src2p = src2->b.cdata;
#line 640
  i = 0U;
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (ssize1 > ssize2) {
#line 640
      tmp___9 = ssize2;
    } else {
#line 640
      tmp___9 = ssize1;
    }
#line 640
    if (! (i < tmp___9)) {
#line 640
      goto while_break;
    }
#line 642
    tmp___7 = src1p;
#line 642
    src1p ++;
#line 642
    tmp___8 = src2p;
#line 642
    src2p ++;
#line 642
    tmp___6 = *tmp___7 & ~ *tmp___8;
#line 644
    if (*dstp != tmp___6) {
#line 646
      changed = 1;
#line 647
      *dstp = tmp___6;
    }
#line 640
    i ++;
#line 640
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if (ssize2 > ssize1) {
    {
#line 653
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 653
      if (! (i < ssize2)) {
#line 653
        goto while_break___0;
      }
#line 655
      if (*dstp != 0UL) {
#line 657
        changed = 1;
#line 658
        *dstp = (bitset_word )0;
      }
#line 653
      i ++;
#line 653
      dstp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 662
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize2)));
    }
  } else {
    {
#line 666
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 666
      if (! (i < ssize1)) {
#line 666
        goto while_break___1;
      }
#line 668
      tmp___11 = src1p;
#line 668
      src1p ++;
#line 668
      tmp___10 = *tmp___11;
#line 670
      if (*dstp != tmp___10) {
#line 672
        changed = 1;
#line 673
        *dstp = tmp___10;
      }
#line 666
      i ++;
#line 666
      dstp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 677
    memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
    }
  }
#line 680
  return ((_Bool )changed);
}
}
#line 684 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 695
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 695
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 695
  if (tmp___4 > tmp___5) {
    {
#line 695
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 695
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 695
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 695
    tmp___3 = tmp___2;
    }
  }
  {
#line 695
  vbitset_resize(dst, tmp___3);
#line 697
  dsize = dst->b.csize;
#line 698
  ssize1 = src1->b.csize;
#line 699
  ssize2 = src2->b.csize;
#line 700
  dstp = dst->b.cdata;
#line 701
  src1p = src1->b.cdata;
#line 702
  src2p = src2->b.cdata;
#line 704
  i = 0U;
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (ssize1 > ssize2) {
#line 704
      tmp___9 = ssize2;
    } else {
#line 704
      tmp___9 = ssize1;
    }
#line 704
    if (! (i < tmp___9)) {
#line 704
      goto while_break;
    }
#line 705
    tmp___6 = dstp;
#line 705
    dstp ++;
#line 705
    tmp___7 = src1p;
#line 705
    src1p ++;
#line 705
    tmp___8 = src2p;
#line 705
    src2p ++;
#line 705
    *tmp___6 = *tmp___7 | *tmp___8;
#line 704
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  if (ssize2 > ssize1) {
#line 709
    src1p = src2p;
#line 710
    ssize1 = ssize2;
  }
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 713
    if (! (i < ssize1)) {
#line 713
      goto while_break___0;
    }
#line 714
    tmp___10 = dstp;
#line 714
    dstp ++;
#line 714
    tmp___11 = src1p;
#line 714
    src1p ++;
#line 714
    *tmp___10 = *tmp___11;
#line 713
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 716
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 717
  return;
}
}
#line 720 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 724
  changed = 0;
#line 732
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 732
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 732
  if (tmp___4 > tmp___5) {
    {
#line 732
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 732
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 732
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 732
    tmp___3 = tmp___2;
    }
  }
  {
#line 732
  vbitset_resize(dst, tmp___3);
#line 734
  dsize = dst->b.csize;
#line 735
  ssize1 = src1->b.csize;
#line 736
  ssize2 = src2->b.csize;
#line 737
  dstp = dst->b.cdata;
#line 738
  src1p = src1->b.cdata;
#line 739
  src2p = src2->b.cdata;
#line 741
  i = 0U;
  }
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (ssize1 > ssize2) {
#line 741
      tmp___9 = ssize2;
    } else {
#line 741
      tmp___9 = ssize1;
    }
#line 741
    if (! (i < tmp___9)) {
#line 741
      goto while_break;
    }
#line 743
    tmp___7 = src1p;
#line 743
    src1p ++;
#line 743
    tmp___8 = src2p;
#line 743
    src2p ++;
#line 743
    tmp___6 = *tmp___7 | *tmp___8;
#line 745
    if (*dstp != tmp___6) {
#line 747
      changed = 1;
#line 748
      *dstp = tmp___6;
    }
#line 741
    i ++;
#line 741
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  if (ssize2 > ssize1) {
#line 754
    src1p = src2p;
#line 755
    ssize1 = ssize2;
  }
  {
#line 758
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 758
    if (! (i < ssize1)) {
#line 758
      goto while_break___0;
    }
#line 760
    tmp___11 = src1p;
#line 760
    src1p ++;
#line 760
    tmp___10 = *tmp___11;
#line 762
    if (*dstp != tmp___10) {
#line 764
      changed = 1;
#line 765
      *dstp = tmp___10;
    }
#line 758
    i ++;
#line 758
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 769
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 771
  return ((_Bool )changed);
}
}
#line 775 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word *tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 786
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 786
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 786
  if (tmp___4 > tmp___5) {
    {
#line 786
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 786
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 786
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 786
    tmp___3 = tmp___2;
    }
  }
  {
#line 786
  vbitset_resize(dst, tmp___3);
#line 788
  dsize = dst->b.csize;
#line 789
  ssize1 = src1->b.csize;
#line 790
  ssize2 = src2->b.csize;
#line 791
  dstp = dst->b.cdata;
#line 792
  src1p = src1->b.cdata;
#line 793
  src2p = src2->b.cdata;
#line 795
  i = 0U;
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (ssize1 > ssize2) {
#line 795
      tmp___9 = ssize2;
    } else {
#line 795
      tmp___9 = ssize1;
    }
#line 795
    if (! (i < tmp___9)) {
#line 795
      goto while_break;
    }
#line 796
    tmp___6 = dstp;
#line 796
    dstp ++;
#line 796
    tmp___7 = src1p;
#line 796
    src1p ++;
#line 796
    tmp___8 = src2p;
#line 796
    src2p ++;
#line 796
    *tmp___6 = *tmp___7 ^ *tmp___8;
#line 795
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  if (ssize2 > ssize1) {
#line 800
    src1p = src2p;
#line 801
    ssize1 = ssize2;
  }
  {
#line 804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 804
    if (! (i < ssize1)) {
#line 804
      goto while_break___0;
    }
#line 805
    tmp___10 = dstp;
#line 805
    dstp ++;
#line 805
    tmp___11 = src1p;
#line 805
    src1p ++;
#line 805
    *tmp___10 = *tmp___11;
#line 804
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 807
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 808
  return;
}
}
#line 811 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *dstp ;
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;
  bitset_bindex tmp___3 ;
  bitset_bindex tmp___4 ;
  bitset_bindex tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_windex tmp___9 ;
  bitset_word tmp___10 ;
  bitset_word *tmp___11 ;

  {
  {
#line 815
  changed = 0;
#line 823
  tmp___4 = (*((src1->b.vtable)->size))(src1);
#line 823
  tmp___5 = (*((src2->b.vtable)->size))(src2);
  }
#line 823
  if (tmp___4 > tmp___5) {
    {
#line 823
    tmp___1 = (*((src1->b.vtable)->size))(src1);
#line 823
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 823
    tmp___2 = (*((src2->b.vtable)->size))(src2);
#line 823
    tmp___3 = tmp___2;
    }
  }
  {
#line 823
  vbitset_resize(dst, tmp___3);
#line 825
  dsize = dst->b.csize;
#line 826
  ssize1 = src1->b.csize;
#line 827
  ssize2 = src2->b.csize;
#line 828
  dstp = dst->b.cdata;
#line 829
  src1p = src1->b.cdata;
#line 830
  src2p = src2->b.cdata;
#line 832
  i = 0U;
  }
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (ssize1 > ssize2) {
#line 832
      tmp___9 = ssize2;
    } else {
#line 832
      tmp___9 = ssize1;
    }
#line 832
    if (! (i < tmp___9)) {
#line 832
      goto while_break;
    }
#line 834
    tmp___7 = src1p;
#line 834
    src1p ++;
#line 834
    tmp___8 = src2p;
#line 834
    src2p ++;
#line 834
    tmp___6 = *tmp___7 ^ *tmp___8;
#line 836
    if (*dstp != tmp___6) {
#line 838
      changed = 1;
#line 839
      *dstp = tmp___6;
    }
#line 832
    i ++;
#line 832
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  if (ssize2 > ssize1) {
#line 845
    src1p = src2p;
#line 846
    ssize1 = ssize2;
  }
  {
#line 849
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 849
    if (! (i < ssize1)) {
#line 849
      goto while_break___0;
    }
#line 851
    tmp___11 = src1p;
#line 851
    src1p ++;
#line 851
    tmp___10 = *tmp___11;
#line 853
    if (*dstp != tmp___10) {
#line 855
      changed = 1;
#line 856
      *dstp = tmp___10;
    }
#line 849
    i ++;
#line 849
    dstp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 860
  memset((void *)dstp, 0, (size_t )(sizeof(bitset_word ) * (unsigned long )(dsize - ssize1)));
  }
#line 862
  return ((_Bool )changed);
}
}
#line 869 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_and_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 879
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 882
    bitset_and_or_(dst, src1, src2, src3);
    }
#line 883
    return;
  } else
#line 879
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 882
    bitset_and_or_(dst, src1, src2, src3);
    }
#line 883
    return;
  }
  {
#line 886
  vbitset_resize(dst, src1->b.n_bits);
#line 888
  src1p = src1->b.cdata;
#line 889
  src2p = src2->b.cdata;
#line 890
  src3p = src3->b.cdata;
#line 891
  dstp = dst->b.cdata;
#line 892
  size = dst->b.csize;
#line 894
  i = 0U;
  }
  {
#line 894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 894
    if (! (i < size)) {
#line 894
      goto while_break;
    }
#line 895
    tmp = dstp;
#line 895
    dstp ++;
#line 895
    tmp___0 = src1p;
#line 895
    src1p ++;
#line 895
    tmp___1 = src2p;
#line 895
    src2p ++;
#line 895
    tmp___2 = src3p;
#line 895
    src3p ++;
#line 895
    *tmp = (*tmp___0 & *tmp___1) | *tmp___2;
#line 894
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  return;
}
}
#line 899 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_and_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 903
  changed = 0;
#line 910
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 912
    tmp = bitset_and_or_cmp_(dst, src1, src2, src3);
    }
#line 912
    return (tmp);
  } else
#line 910
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 912
    tmp = bitset_and_or_cmp_(dst, src1, src2, src3);
    }
#line 912
    return (tmp);
  }
  {
#line 914
  vbitset_resize(dst, src1->b.n_bits);
#line 916
  src1p = src1->b.cdata;
#line 917
  src2p = src2->b.cdata;
#line 918
  src3p = src3->b.cdata;
#line 919
  dstp = dst->b.cdata;
#line 920
  size = dst->b.csize;
#line 922
  i = 0U;
  }
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! (i < size)) {
#line 922
      goto while_break;
    }
#line 924
    tmp___1 = src1p;
#line 924
    src1p ++;
#line 924
    tmp___2 = src2p;
#line 924
    src2p ++;
#line 924
    tmp___3 = src3p;
#line 924
    src3p ++;
#line 924
    tmp___0 = (*tmp___1 & *tmp___2) | *tmp___3;
#line 926
    if (*dstp != tmp___0) {
#line 928
      changed = 1;
#line 929
      *dstp = tmp___0;
    }
#line 922
    i ++;
#line 922
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return ((_Bool )changed);
}
}
#line 936 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_andn_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 946
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 949
    bitset_andn_or_(dst, src1, src2, src3);
    }
#line 950
    return;
  } else
#line 946
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 949
    bitset_andn_or_(dst, src1, src2, src3);
    }
#line 950
    return;
  }
  {
#line 953
  vbitset_resize(dst, src1->b.n_bits);
#line 955
  src1p = src1->b.cdata;
#line 956
  src2p = src2->b.cdata;
#line 957
  src3p = src3->b.cdata;
#line 958
  dstp = dst->b.cdata;
#line 959
  size = dst->b.csize;
#line 961
  i = 0U;
  }
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (i < size)) {
#line 961
      goto while_break;
    }
#line 962
    tmp = dstp;
#line 962
    dstp ++;
#line 962
    tmp___0 = src1p;
#line 962
    src1p ++;
#line 962
    tmp___1 = src2p;
#line 962
    src2p ++;
#line 962
    tmp___2 = src3p;
#line 962
    src3p ++;
#line 962
    *tmp = (*tmp___0 & ~ *tmp___1) | *tmp___2;
#line 961
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 963
  return;
}
}
#line 966 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_andn_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 970
  changed = 0;
#line 977
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 979
    tmp = bitset_andn_or_cmp_(dst, src1, src2, src3);
    }
#line 979
    return (tmp);
  } else
#line 977
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 979
    tmp = bitset_andn_or_cmp_(dst, src1, src2, src3);
    }
#line 979
    return (tmp);
  }
  {
#line 981
  vbitset_resize(dst, src1->b.n_bits);
#line 983
  src1p = src1->b.cdata;
#line 984
  src2p = src2->b.cdata;
#line 985
  src3p = src3->b.cdata;
#line 986
  dstp = dst->b.cdata;
#line 987
  size = dst->b.csize;
#line 989
  i = 0U;
  }
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (! (i < size)) {
#line 989
      goto while_break;
    }
#line 991
    tmp___1 = src1p;
#line 991
    src1p ++;
#line 991
    tmp___2 = src2p;
#line 991
    src2p ++;
#line 991
    tmp___3 = src3p;
#line 991
    src3p ++;
#line 991
    tmp___0 = (*tmp___1 & ~ *tmp___2) | *tmp___3;
#line 993
    if (*dstp != tmp___0) {
#line 995
      changed = 1;
#line 996
      *dstp = tmp___0;
    }
#line 989
    i ++;
#line 989
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return ((_Bool )changed);
}
}
#line 1003 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_or_and(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  bitset_word *tmp ;
  bitset_word *tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;

  {
#line 1013
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 1016
    bitset_or_and_(dst, src1, src2, src3);
    }
#line 1017
    return;
  } else
#line 1013
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 1016
    bitset_or_and_(dst, src1, src2, src3);
    }
#line 1017
    return;
  }
  {
#line 1020
  vbitset_resize(dst, src1->b.n_bits);
#line 1022
  src1p = src1->b.cdata;
#line 1023
  src2p = src2->b.cdata;
#line 1024
  src3p = src3->b.cdata;
#line 1025
  dstp = dst->b.cdata;
#line 1026
  size = dst->b.csize;
#line 1028
  i = 0U;
  }
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (i < size)) {
#line 1028
      goto while_break;
    }
#line 1029
    tmp = dstp;
#line 1029
    dstp ++;
#line 1029
    tmp___0 = src1p;
#line 1029
    src1p ++;
#line 1029
    tmp___1 = src2p;
#line 1029
    src2p ++;
#line 1029
    tmp___2 = src3p;
#line 1029
    src3p ++;
#line 1029
    *tmp = (*tmp___0 | *tmp___1) & *tmp___2;
#line 1028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1030
  return;
}
}
#line 1033 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static _Bool vbitset_or_and_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  unsigned int i ;
  int changed ;
  bitset_word *src1p ;
  bitset_word *src2p ;
  bitset_word *src3p ;
  bitset_word *dstp ;
  bitset_windex size ;
  _Bool tmp ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word *tmp___3 ;

  {
#line 1037
  changed = 0;
#line 1044
  if (src1->b.n_bits != src2->b.n_bits) {
    {
#line 1046
    tmp = bitset_or_and_cmp_(dst, src1, src2, src3);
    }
#line 1046
    return (tmp);
  } else
#line 1044
  if (src1->b.n_bits != src3->b.n_bits) {
    {
#line 1046
    tmp = bitset_or_and_cmp_(dst, src1, src2, src3);
    }
#line 1046
    return (tmp);
  }
  {
#line 1048
  vbitset_resize(dst, src1->b.n_bits);
#line 1050
  src1p = src1->b.cdata;
#line 1051
  src2p = src2->b.cdata;
#line 1052
  src3p = src3->b.cdata;
#line 1053
  dstp = dst->b.cdata;
#line 1054
  size = dst->b.csize;
#line 1056
  i = 0U;
  }
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (i < size)) {
#line 1056
      goto while_break;
    }
#line 1058
    tmp___1 = src1p;
#line 1058
    src1p ++;
#line 1058
    tmp___2 = src2p;
#line 1058
    src2p ++;
#line 1058
    tmp___3 = src3p;
#line 1058
    src3p ++;
#line 1058
    tmp___0 = (*tmp___1 | *tmp___2) & *tmp___3;
#line 1060
    if (*dstp != tmp___0) {
#line 1062
      changed = 1;
#line 1063
      *dstp = tmp___0;
    }
#line 1056
    i ++;
#line 1056
    dstp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  return ((_Bool )changed);
}
}
#line 1070 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
static void vbitset_copy(bitset dst , bitset src ) 
{ 


  {
#line 1073
  if ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable) {
    {
#line 1074
    vbitset_copy1(dst, src);
    }
  } else {
    {
#line 1076
    bitset_copy_(dst, src);
    }
  }
#line 1077
  return;
}
}
#line 1081 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
struct bitset_vtable vbitset_vtable  = 
#line 1081
     {& vbitset_set, & vbitset_reset, & bitset_toggle_, & vbitset_test, & vbitset_resize,
    & bitset_size_, & bitset_count_, & vbitset_empty_p, & vbitset_ones, & vbitset_zero,
    & vbitset_copy, & vbitset_disjoint_p, & vbitset_equal_p, & vbitset_not, & vbitset_subset_p,
    & vbitset_and, & vbitset_and_cmp, & vbitset_andn, & vbitset_andn_cmp, & vbitset_or,
    & vbitset_or_cmp, & vbitset_xor, & vbitset_xor_cmp, & vbitset_and_or, & vbitset_and_or_cmp,
    & vbitset_andn_or, & vbitset_andn_or_cmp, & vbitset_or_and, & vbitset_or_and_cmp,
    & vbitset_list, & vbitset_list_reverse, (void (*)(bitset  ))((void *)0), (enum bitset_type )3};
#line 1118 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
size_t vbitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1122
  return ((size_t )sizeof(struct vbitset_struct ));
}
}
#line 1126 "/home/pronto/abs/test-suite/bison-2.4/lib/vbitset.c"
bitset vbitset_init(bitset bset , bitset_bindex n_bits ) 
{ 


  {
  {
#line 1131
  bset->b.vtable = (struct bitset_vtable  const  *)(& vbitset_vtable);
#line 1133
  bset->b.cindex = (bitset_windex )0;
#line 1135
  bset->b.csize = (bitset_windex )0;
#line 1136
  vbitset_resize(bset, n_bits);
  }
#line 1137
  return (bset);
}
}
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 506
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 620
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 36 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
int timevar_report  =    0;
#line 49 "/usr/include/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 117 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static float ticks_to_msec  ;
#line 75 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.h"
void init_timevar(void) ;
#line 76
void timevar_push(timevar_id_t timevar ) ;
#line 77
void timevar_pop(timevar_id_t timevar ) ;
#line 78
void timevar_start(timevar_id_t timevar ) ;
#line 79
void timevar_stop(timevar_id_t timevar ) ;
#line 80
void timevar_get(timevar_id_t timevar , struct timevar_time_def *elapsed ) ;
#line 81
void timevar_print(FILE *fp ) ;
#line 84
long get_run_time(void) ;
#line 85
void print_time(char const   *str , long total ) ;
#line 173 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static struct timevar_def timevars[16]  ;
#line 176 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static struct timevar_stack_def *stack  ;
#line 180 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static struct timevar_stack_def *unused_stack_instances  ;
#line 185 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static struct timevar_time_def start_time  ;
#line 187
static void get_time(struct timevar_time_def *now ) ;
#line 188
static void timevar_accumulate(struct timevar_time_def *timer , struct timevar_time_def *start ,
                               struct timevar_time_def *stop ) ;
#line 196 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static void get_time(struct timevar_time_def *now ) 
{ 
  struct tms tms ;
  clock_t tmp ;

  {
#line 200
  now->user = (float )0;
#line 201
  now->sys = (float )0;
#line 202
  now->wall = (float )0;
#line 204
  if (! timevar_report) {
#line 205
    return;
  }
  {
#line 210
  tmp = times(& tms);
#line 210
  now->wall = (float )tmp * ticks_to_msec;
#line 215
  now->user = (float )(tms.tms_utime + tms.tms_cutime) * ticks_to_msec;
#line 216
  now->sys = (float )(tms.tms_stime + tms.tms_cstime) * ticks_to_msec;
  }
#line 233
  return;
}
}
#line 237 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
static void timevar_accumulate(struct timevar_time_def *timer , struct timevar_time_def *start ,
                               struct timevar_time_def *stop ) 
{ 


  {
#line 243
  timer->user += stop->user - start->user;
#line 244
  timer->sys += stop->sys - start->sys;
#line 245
  timer->wall += stop->wall - start->wall;
#line 246
  return;
}
}
#line 250 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void init_timevar(void) 
{ 


  {
#line 253
  if (! timevar_report) {
#line 254
    return;
  }
  {
#line 257
  memset((void *)(timevars), 0, (size_t )sizeof(timevars));
#line 32 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.def"
  timevars[0].name = "total time";
#line 35
  timevars[1].name = "reader";
#line 36
  timevars[2].name = "scanner";
#line 37
  timevars[3].name = "parser";
#line 40
  timevars[4].name = "reducing the grammar";
#line 41
  timevars[5].name = "computing the sets";
#line 42
  timevars[6].name = "LR(0)";
#line 43
  timevars[7].name = "LALR(1)";
#line 44
  timevars[8].name = "conflicts";
#line 47
  timevars[9].name = "outputing report";
#line 48
  timevars[10].name = "outputing graph";
#line 49
  timevars[11].name = "outputing xml";
#line 50
  timevars[12].name = "parser action tables";
#line 51
  timevars[13].name = "outputing parser";
#line 52
  timevars[14].name = "running m4";
#line 55
  timevars[15].name = "freeing";
#line 266 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
  ticks_to_msec = (float )(1.0 / (double )100);
  }
#line 271
  return;
}
}
#line 280 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_push(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;
  struct timevar_stack_def *context ;
  struct timevar_time_def now ;
  void *tmp ;

  {
#line 284
  tv = & timevars[timevar];
#line 288
  if (! timevar_report) {
#line 289
    return;
  }
#line 292
  tv->used = 1U;
#line 295
  if (tv->standalone) {
    {
#line 296
    abort();
    }
  }
  {
#line 299
  get_time(& now);
  }
#line 303
  if (stack) {
    {
#line 304
    timevar_accumulate(& (stack->timevar)->elapsed, & start_time, & now);
    }
  }
#line 308
  start_time = now;
#line 312
  if ((unsigned long )unused_stack_instances != (unsigned long )((void *)0)) {
#line 314
    context = unused_stack_instances;
#line 315
    unused_stack_instances = unused_stack_instances->next;
  } else {
    {
#line 318
    tmp = xmalloc((size_t )sizeof(struct timevar_stack_def ));
#line 318
    context = (struct timevar_stack_def *)tmp;
    }
  }
#line 322
  context->timevar = tv;
#line 323
  context->next = stack;
#line 324
  stack = context;
#line 325
  return;
}
}
#line 333 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_pop(timevar_id_t timevar ) 
{ 
  struct timevar_time_def now ;
  struct timevar_stack_def *popped ;

  {
#line 338
  popped = stack;
#line 340
  if (! timevar_report) {
#line 341
    return;
  }
#line 343
  if ((unsigned long )(& timevars[timevar]) != (unsigned long )stack->timevar) {
    {
#line 344
    abort();
    }
  }
  {
#line 347
  get_time(& now);
#line 350
  timevar_accumulate(& (popped->timevar)->elapsed, & start_time, & now);
#line 354
  start_time = now;
#line 357
  stack = stack->next;
#line 361
  popped->next = unused_stack_instances;
#line 362
  unused_stack_instances = popped;
  }
#line 363
  return;
}
}
#line 369 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_start(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;

  {
#line 373
  tv = & timevars[timevar];
#line 375
  if (! timevar_report) {
#line 376
    return;
  }
#line 379
  tv->used = 1U;
#line 383
  if (tv->standalone) {
    {
#line 384
    abort();
    }
  }
  {
#line 385
  tv->standalone = 1U;
#line 387
  get_time(& tv->start_time);
  }
#line 388
  return;
}
}
#line 393 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_stop(timevar_id_t timevar ) 
{ 
  struct timevar_def *tv ;
  struct timevar_time_def now ;

  {
#line 397
  tv = & timevars[timevar];
#line 400
  if (! timevar_report) {
#line 401
    return;
  }
#line 404
  if (! tv->standalone) {
    {
#line 405
    abort();
    }
  }
  {
#line 407
  get_time(& now);
#line 408
  timevar_accumulate(& tv->elapsed, & tv->start_time, & now);
  }
#line 409
  return;
}
}
#line 414 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_get(timevar_id_t timevar , struct timevar_time_def *elapsed ) 
{ 
  struct timevar_def *tv ;
  struct timevar_time_def now ;

  {
#line 419
  tv = & timevars[timevar];
#line 422
  *elapsed = tv->elapsed;
#line 425
  if (tv->standalone) {
    {
#line 427
    get_time(& now);
#line 428
    timevar_accumulate(elapsed, & tv->start_time, & now);
    }
  } else
#line 431
  if ((unsigned long )stack->timevar == (unsigned long )tv) {
    {
#line 433
    get_time(& now);
#line 434
    timevar_accumulate(elapsed, & start_time, & now);
    }
  }
#line 436
  return;
}
}
#line 442 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void timevar_print(FILE *fp ) 
{ 
  unsigned int id ;
  struct timevar_time_def *total ;
  struct timevar_time_def now ;
  char *tmp ;
  struct timevar_def *tv ;
  float tiny ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  char *tmp___3 ;

  {
#line 449
  total = & timevars[0].elapsed;
#line 452
  if (! timevar_report) {
#line 453
    return;
  }
#line 457
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
#line 458
    fp = stderr;
  }
  {
#line 461
  get_time(& now);
  }
#line 465
  if (stack) {
    {
#line 466
    timevar_accumulate(& (stack->timevar)->elapsed, & start_time, & now);
    }
  }
  {
#line 470
  start_time = now;
#line 472
  tmp = gettext("\nExecution times (seconds)\n");
#line 472
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)fp);
#line 473
  id = 0U;
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (id < 16U)) {
#line 473
      goto while_break;
    }
#line 475
    tv = & timevars[(timevar_id_t )id];
#line 476
    tiny = (float )5e-3;
#line 480
    if ((unsigned int )((timevar_id_t )id) == 0U) {
#line 481
      goto __Cont;
    }
#line 484
    if (! tv->used) {
#line 485
      goto __Cont;
    }
#line 489
    if (tv->elapsed.user < tiny) {
#line 489
      if (tv->elapsed.sys < tiny) {
#line 489
        if (tv->elapsed.wall < tiny) {
#line 492
          goto __Cont;
        }
      }
    }
    {
#line 495
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-22s:",
            tv->name);
    }
#line 499
    if (total->user == (float )0) {
#line 499
      tmp___0 = (float )0;
    } else {
#line 499
      tmp___0 = tv->elapsed.user / total->user;
    }
    {
#line 499
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f (%2.0f%%) usr",
            (double )tv->elapsed.user, (double )(tmp___0 * (float )100));
    }
#line 506
    if (total->sys == (float )0) {
#line 506
      tmp___1 = (float )0;
    } else {
#line 506
      tmp___1 = tv->elapsed.sys / total->sys;
    }
    {
#line 506
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f (%2.0f%%) sys",
            (double )tv->elapsed.sys, (double )(tmp___1 * (float )100));
    }
#line 513
    if (total->wall == (float )0) {
#line 513
      tmp___2 = (float )0;
    } else {
#line 513
      tmp___2 = tv->elapsed.wall / total->wall;
    }
    {
#line 513
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f (%2.0f%%) wall",
            (double )tv->elapsed.wall, (double )(tmp___2 * (float )100));
#line 518
    putc_unlocked('\n', fp);
    }
    __Cont: /* CIL Label */ 
#line 473
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 522
  tmp___3 = gettext(" TOTAL                 :");
#line 522
  fputs_unlocked((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)fp);
#line 524
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f          ",
          (double )total->user);
#line 527
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f          ",
          (double )total->sys);
#line 530
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%7.2f\n",
          (double )total->wall);
  }
#line 535
  return;
}
}
#line 540 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
long get_run_time(void) 
{ 
  struct timevar_time_def total_elapsed ;

  {
  {
#line 544
  timevar_get((timevar_id_t )0, & total_elapsed);
  }
#line 545
  return ((long )(total_elapsed.user + total_elapsed.sys));
}
}
#line 551 "/home/pronto/abs/test-suite/bison-2.4/lib/timevar.c"
void print_time(char const   *str , long total ) 
{ 
  long all_time ;
  long tmp ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 556
  tmp = get_run_time();
#line 556
  all_time = tmp;
  }
#line 557
  if (all_time == 0L) {
#line 557
    tmp___0 = 0L;
  } else {
#line 557
    tmp___0 = (long )((100.0 * (double )total) / (double )all_time + .5);
  }
  {
#line 557
  tmp___1 = gettext("time in %s: %ld.%06ld (%ld%%)\n");
#line 557
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          str, total / 1000000L, total % 1000000L, tmp___0);
  }
#line 562
  return;
}
}
#line 24 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.h"
void init_subpipe(void) ;
#line 25
pid_t create_subpipe(char const   * const  *argv , int *fd ) ;
#line 26
void end_of_output_subpipe(pid_t pid  __attribute__((__unused__)) , int *fd  __attribute__((__unused__)) ) ;
#line 27
void reap_subpipe(pid_t pid , char const   *program ) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 469
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 507
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 524
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 702
extern  __attribute__((__nothrow__)) __pid_t vfork(void) ;
#line 138 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 22 "/home/pronto/abs/test-suite/bison-2.4/lib/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 84 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
void init_subpipe(void) 
{ 


  {
  {
#line 89
  signal(17, (void (*)(int  ))0);
  }
#line 91
  return;
}
}
#line 104 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
pid_t create_subpipe(char const   * const  *argv , int *fd ) 
{ 
  int pipe_fd[2] ;
  int child_fd[2] ;
  pid_t pid ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 111
  tmp___0 = pipe_safer((int *)(child_fd));
  }
#line 111
  if (tmp___0 != 0) {
    {
#line 112
    tmp = __errno_location();
#line 112
    error(1, *tmp, "pipe");
    }
  } else {
    {
#line 111
    tmp___1 = pipe_safer((int *)(pipe_fd));
    }
#line 111
    if (tmp___1 != 0) {
      {
#line 112
      tmp = __errno_location();
#line 112
      error(1, *tmp, "pipe");
      }
    }
  }
  {
#line 113
  *(fd + 0) = child_fd[1];
#line 114
  *(fd + 1) = pipe_fd[0];
#line 115
  child_fd[1] = pipe_fd[1];
#line 117
  pid = vfork();
  }
#line 118
  if (pid < 0) {
    {
#line 119
    tmp___2 = __errno_location();
#line 119
    error(1, *tmp___2, "fork");
    }
  }
#line 121
  if (! pid) {
    {
#line 124
    close(*(fd + 0));
#line 125
    close(*(fd + 1));
#line 126
    dup2(child_fd[0], 0);
#line 127
    close(child_fd[0]);
#line 128
    dup2(child_fd[1], 1);
#line 129
    close(child_fd[1]);
#line 134
    execvp((char const   *)*(argv + 0), (char * const  *)((char **)argv));
#line 136
    tmp___5 = __errno_location();
    }
#line 136
    if (*tmp___5 == 2) {
#line 136
      tmp___4 = 127;
    } else {
#line 136
      tmp___4 = 126;
    }
    {
#line 136
    _exit(tmp___4);
    }
  }
  {
#line 140
  close(child_fd[0]);
#line 141
  close(child_fd[1]);
  }
#line 142
  return (pid);
}
}
#line 148 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
void reap_subpipe(pid_t pid , char const   *program ) 
{ 
  int wstatus ;
  int *tmp ;
  int status ;
  union __anonunion___u_44 __u___0 ;
  int tmp___0 ;
  union __anonunion___u_45 __u___1 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;

  {
  {
#line 153
  tmp___5 = waitpid(pid, & wstatus, 0);
  }
#line 153
  if (tmp___5 < 0) {
    {
#line 154
    tmp = __errno_location();
#line 154
    error(1, *tmp, "waitpid");
    }
  } else {
#line 157
    __u___1.__in = wstatus;
#line 157
    if ((__u___1.__i & 127) == 0) {
#line 157
      __u___0.__in = wstatus;
#line 157
      tmp___0 = (__u___0.__i & 65280) >> 8;
    } else {
#line 157
      tmp___0 = -1;
    }
#line 157
    status = tmp___0;
#line 158
    if (status) {
#line 159
      if (status == 126) {
#line 159
        tmp___3 = "subsidiary program `%s\' could not be invoked";
      } else {
#line 159
        if (status == 127) {
#line 159
          tmp___2 = "subsidiary program `%s\' not found";
        } else {
#line 159
          if (status < 0) {
#line 159
            tmp___1 = "subsidiary program `%s\' failed";
          } else {
#line 159
            tmp___1 = "subsidiary program `%s\' failed (exit status %d)";
          }
#line 159
          tmp___2 = tmp___1;
        }
#line 159
        tmp___3 = tmp___2;
      }
      {
#line 159
      tmp___4 = gettext(tmp___3);
#line 159
      error(1, 0, (char const   *)tmp___4, program, status);
      }
    }
  }
#line 170
  return;
}
}
#line 172 "/home/pronto/abs/test-suite/bison-2.4/lib/subpipe.c"
void end_of_output_subpipe(pid_t pid  __attribute__((__unused__)) , int *fd  __attribute__((__unused__)) ) 
{ 


  {
#line 176
  return;
}
}
#line 63 "/home/pronto/abs/test-suite/bison-2.4/lib/dirname.h"
size_t base_len(char const   *name ) ;
#line 65
char *last_component(char const   *name ) ;
#line 67
_Bool strip_trailing_slashes(char *file ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base___0 ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 32
  tmp = last_component((char const   *)file);
#line 32
  base___0 = tmp;
  }
#line 38
  if (! *base___0) {
#line 39
    base___0 = file;
  }
  {
#line 40
  tmp___0 = base_len((char const   *)base___0);
#line 40
  base_lim = base___0 + tmp___0;
#line 41
  had_slash = (_Bool )((int )*base_lim != 0);
#line 42
  *base_lim = (char )'\000';
  }
#line 43
  return (had_slash);
}
}
#line 189 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 190
enum quoting_style  const  quoting_style_vals[8] ;
#line 200
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 203
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 207
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 214
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 220
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 233
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 240
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 249
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 259
char *quotearg_n(int n , char const   *arg ) ;
#line 262
char *quotearg(char const   *arg ) ;
#line 267
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 270
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 275
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 280
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 284
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 287
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 291
char *quotearg_char(char const   *arg , char ch ) ;
#line 294
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 297
char *quotearg_colon(char const   *arg ) ;
#line 300
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 303
void quotearg_free(void) ;
#line 119 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 123
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 123
    tmp = -1;
  } else {
#line 123
    tmp = -2;
  }
#line 123
  if ((size_t )tmp / s < n) {
    {
#line 124
    xalloc_die();
    }
  }
  {
#line 125
  tmp___0 = xmalloc(n * s);
  }
#line 125
  return (tmp___0);
}
}
#line 231
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232 "/home/pronto/abs/test-suite/bison-2.4/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 235
  if (sizeof(char ) == 1UL) {
    {
#line 235
    tmp = xmalloc(n);
#line 235
    tmp___1 = tmp;
    }
  } else {
    {
#line 235
    tmp___0 = xnmalloc(n, (size_t )sizeof(char ));
#line 235
    tmp___1 = tmp___0;
    }
  }
#line 235
  return ((char *)tmp___1);
}
}
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 597
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 302 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 306
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 151 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 77 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 77 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 91 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 91
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 104 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 109 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 112
  tmp = __errno_location();
#line 112
  e = *tmp;
  }
#line 113
  if (o) {
#line 113
    tmp___0 = o;
  } else {
#line 113
    tmp___0 = & default_quoting_options;
  }
  {
#line 113
  tmp___1 = xmemdup((void const   *)tmp___0, (size_t )sizeof(*o));
#line 113
  p = (struct quoting_options *)tmp___1;
#line 115
  tmp___2 = __errno_location();
#line 115
  *tmp___2 = e;
  }
#line 116
  return (p);
}
}
#line 120 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 123
  if (o) {
#line 123
    tmp = o;
  } else {
#line 123
    tmp = & default_quoting_options;
  }
#line 123
  return (tmp->style);
}
}
#line 128 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 131
  if (o) {
#line 131
    tmp = o;
  } else {
#line 131
    tmp = & default_quoting_options;
  }
#line 131
  tmp->style = s;
#line 132
  return;
}
}
#line 139 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 142
  uc = (unsigned char )c;
#line 143
  if (o) {
#line 143
    tmp = o;
  } else {
#line 143
    tmp = & default_quoting_options;
  }
#line 143
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 145
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 146
  r = (int )((*p >> shift) & 1U);
#line 147
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 148
  return (r);
}
}
#line 155 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 159
  if (! o) {
#line 160
    o = & default_quoting_options;
  }
#line 161
  r = o->flags;
#line 162
  o->flags = i;
#line 163
  return (r);
}
}
#line 167 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
  {
#line 171
  o.style = style;
#line 172
  o.flags = 0;
#line 173
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
  }
#line 174
  return (o);
}
}
#line 179 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;

  {
  {
#line 182
  tmp = gettext(msgid);
#line 182
  translation = (char const   *)tmp;
  }
#line 183
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 183
    if ((unsigned int )s == 7U) {
#line 184
      translation = "\"";
    }
  }
#line 185
  return (translation);
}
}
#line 201 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  int tmp___3 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___4 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___5 ;
  size_t j ;
  int tmp___6 ;
  int tmp___7 ;
  size_t ilim ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 208
  len = (size_t )0;
#line 209
  quote_string = (char const   *)0;
#line 210
  quote_string_len = (size_t )0;
#line 211
  backslash_escapes = (_Bool)0;
#line 212
  tmp = __ctype_get_mb_cur_max();
#line 212
  unibyte_locale = (_Bool )(tmp == 1U);
#line 213
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 226
  if ((unsigned int )quoting_style == 4U) {
#line 226
    goto case_4;
  }
#line 230
  if ((unsigned int )quoting_style == 3U) {
#line 230
    goto case_3;
  }
#line 238
  if ((unsigned int )quoting_style == 5U) {
#line 238
    goto case_5;
  }
#line 244
  if ((unsigned int )quoting_style == 7U) {
#line 244
    goto case_7;
  }
#line 244
  if ((unsigned int )quoting_style == 6U) {
#line 244
    goto case_7;
  }
#line 277
  if ((unsigned int )quoting_style == 1U) {
#line 277
    goto case_1;
  }
#line 281
  if ((unsigned int )quoting_style == 2U) {
#line 281
    goto case_2;
  }
#line 288
  if ((unsigned int )quoting_style == 0U) {
#line 288
    goto case_0;
  }
#line 292
  goto switch_default;
  case_4: /* CIL Label */ 
#line 227
  quoting_style = (enum quoting_style )3;
#line 228
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 231
  if (! elide_outer_quotes) {
    {
#line 232
    while (1) {
      while_continue: /* CIL Label */ ;
#line 232
      if (len < buffersize) {
#line 232
        *(buffer + len) = (char )'\"';
      }
#line 232
      len ++;
#line 232
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 233
  backslash_escapes = (_Bool)1;
#line 234
  quote_string = "\"";
#line 235
  quote_string_len = (size_t )1;
#line 236
  goto switch_break;
  case_5: /* CIL Label */ 
#line 239
  backslash_escapes = (_Bool)1;
#line 240
  elide_outer_quotes = (_Bool)0;
#line 241
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 266
  tmp___0 = gettext_quote("`", quoting_style);
#line 266
  left = tmp___0;
#line 267
  tmp___1 = gettext_quote("\'", quoting_style);
#line 267
  right = tmp___1;
  }
#line 268
  if (! elide_outer_quotes) {
#line 269
    quote_string = left;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! *quote_string) {
#line 269
        goto while_break___0;
      }
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        if (len < buffersize) {
#line 270
          *(buffer + len) = (char )*quote_string;
        }
#line 270
        len ++;
#line 270
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 269
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 271
  backslash_escapes = (_Bool)1;
#line 272
  quote_string = right;
#line 273
  quote_string_len = strlen(quote_string);
  }
#line 275
  goto switch_break;
  case_1: /* CIL Label */ 
#line 278
  quoting_style = (enum quoting_style )2;
#line 279
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 282
  if (! elide_outer_quotes) {
    {
#line 283
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 283
      if (len < buffersize) {
#line 283
        *(buffer + len) = (char )'\'';
      }
#line 283
      len ++;
#line 283
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 284
  quote_string = "\'";
#line 285
  quote_string_len = (size_t )1;
#line 286
  goto switch_break;
  case_0: /* CIL Label */ 
#line 289
  elide_outer_quotes = (_Bool)0;
#line 290
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 293
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 296
  i = (size_t )0;
  {
#line 296
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 296
    if (argsize == 4294967295U) {
#line 296
      tmp___8 = (int const   )*(arg + i) == 0;
    } else {
#line 296
      tmp___8 = i == argsize;
    }
#line 296
    if (tmp___8) {
#line 296
      goto while_break___3;
    }
#line 301
    if (backslash_escapes) {
#line 301
      if (quote_string_len) {
#line 301
        if (i + quote_string_len <= argsize) {
          {
#line 301
          tmp___2 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 301
          if (tmp___2 == 0) {
#line 306
            if (elide_outer_quotes) {
#line 307
              goto force_outer_quoting_style;
            }
            {
#line 308
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 308
              if (len < buffersize) {
#line 308
                *(buffer + len) = (char )'\\';
              }
#line 308
              len ++;
#line 308
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 311
    c = (unsigned char )*(arg + i);
    {
#line 314
    if ((int )c == 0) {
#line 314
      goto case_0___0;
    }
#line 331
    if ((int )c == 63) {
#line 331
      goto case_63;
    }
#line 369
    if ((int )c == 7) {
#line 369
      goto case_7___0;
    }
#line 370
    if ((int )c == 8) {
#line 370
      goto case_8;
    }
#line 371
    if ((int )c == 12) {
#line 371
      goto case_12;
    }
#line 372
    if ((int )c == 10) {
#line 372
      goto case_10;
    }
#line 373
    if ((int )c == 13) {
#line 373
      goto case_13;
    }
#line 374
    if ((int )c == 9) {
#line 374
      goto case_9;
    }
#line 375
    if ((int )c == 11) {
#line 375
      goto case_11;
    }
#line 376
    if ((int )c == 92) {
#line 376
      goto case_92;
    }
#line 395
    if ((int )c == 125) {
#line 395
      goto case_125;
    }
#line 395
    if ((int )c == 123) {
#line 395
      goto case_125;
    }
#line 399
    if ((int )c == 126) {
#line 399
      goto case_126;
    }
#line 399
    if ((int )c == 35) {
#line 399
      goto case_126;
    }
#line 411
    if ((int )c == 124) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 96) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 94) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 91) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 62) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 61) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 60) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 59) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 42) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 41) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 40) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 38) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 36) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 34) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 33) {
#line 411
      goto case_124;
    }
#line 411
    if ((int )c == 32) {
#line 411
      goto case_124;
    }
#line 421
    if ((int )c == 39) {
#line 421
      goto case_39___0;
    }
#line 443
    if ((int )c == 122) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 121) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 120) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 119) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 118) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 117) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 116) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 115) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 114) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 113) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 112) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 111) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 110) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 109) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 108) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 107) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 106) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 105) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 104) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 103) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 102) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 101) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 100) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 99) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 98) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 97) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 95) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 93) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 90) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 89) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 88) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 87) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 86) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 85) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 84) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 83) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 82) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 81) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 80) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 79) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 78) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 77) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 76) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 75) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 74) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 73) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 72) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 71) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 70) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 69) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 68) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 67) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 66) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 65) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 58) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 57) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 56) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 55) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 54) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 53) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 52) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 51) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 50) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 49) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 48) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 47) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 46) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 45) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 44) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 43) {
#line 443
      goto case_122;
    }
#line 443
    if ((int )c == 37) {
#line 443
      goto case_122;
    }
#line 448
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 315
    if (backslash_escapes) {
#line 317
      if (elide_outer_quotes) {
#line 318
        goto force_outer_quoting_style;
      }
      {
#line 319
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 319
        if (len < buffersize) {
#line 319
          *(buffer + len) = (char )'\\';
        }
#line 319
        len ++;
#line 319
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 320
      if (i + 1U < argsize) {
#line 320
        if (48 <= (int )*(arg + (i + 1U))) {
#line 320
          if ((int const   )*(arg + (i + 1U)) <= 57) {
            {
#line 322
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 322
              if (len < buffersize) {
#line 322
                *(buffer + len) = (char )'0';
              }
#line 322
              len ++;
#line 322
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 323
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 323
              if (len < buffersize) {
#line 323
                *(buffer + len) = (char )'0';
              }
#line 323
              len ++;
#line 323
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 325
      c = (unsigned char )'0';
    } else
#line 327
    if (flags & 1) {
#line 328
      goto __Cont;
    }
#line 329
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 334
    if ((unsigned int )quoting_style == 2U) {
#line 334
      goto case_2___0;
    }
#line 339
    if ((unsigned int )quoting_style == 3U) {
#line 339
      goto case_3___0;
    }
#line 364
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 335
    if (elide_outer_quotes) {
#line 336
      goto force_outer_quoting_style;
    }
#line 337
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 340
    if (flags & 4) {
#line 340
      if (i + 2U < argsize) {
#line 340
        if ((int const   )*(arg + (i + 1U)) == 63) {
          {
#line 346
          if ((int const   )*(arg + (i + 2U)) == 62) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 61) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 60) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 47) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 45) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 41) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 40) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 39) {
#line 346
            goto case_62;
          }
#line 346
          if ((int const   )*(arg + (i + 2U)) == 33) {
#line 346
            goto case_62;
          }
#line 359
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 349
          if (elide_outer_quotes) {
#line 350
            goto force_outer_quoting_style;
          }
#line 351
          c = (unsigned char )*(arg + (i + 2U));
#line 352
          i += 2U;
          {
#line 353
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 353
            if (len < buffersize) {
#line 353
              *(buffer + len) = (char )'?';
            }
#line 353
            len ++;
#line 353
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 354
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 354
            if (len < buffersize) {
#line 354
              *(buffer + len) = (char )'\"';
            }
#line 354
            len ++;
#line 354
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 355
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 355
            if (len < buffersize) {
#line 355
              *(buffer + len) = (char )'\"';
            }
#line 355
            len ++;
#line 355
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 356
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 356
            if (len < buffersize) {
#line 356
              *(buffer + len) = (char )'?';
            }
#line 356
            len ++;
#line 356
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 357
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 360
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 362
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 365
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 367
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 369
    esc = (unsigned char )'a';
#line 369
    goto c_escape;
    case_8: /* CIL Label */ 
#line 370
    esc = (unsigned char )'b';
#line 370
    goto c_escape;
    case_12: /* CIL Label */ 
#line 371
    esc = (unsigned char )'f';
#line 371
    goto c_escape;
    case_10: /* CIL Label */ 
#line 372
    esc = (unsigned char )'n';
#line 372
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 373
    esc = (unsigned char )'r';
#line 373
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 374
    esc = (unsigned char )'t';
#line 374
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 375
    esc = (unsigned char )'v';
#line 375
    goto c_escape;
    case_92: /* CIL Label */ 
#line 376
    esc = c;
#line 379
    if (backslash_escapes) {
#line 379
      if (elide_outer_quotes) {
#line 379
        if (quote_string_len) {
#line 380
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 383
    if ((unsigned int )quoting_style == 2U) {
#line 383
      if (elide_outer_quotes) {
#line 385
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 388
    if (backslash_escapes) {
#line 390
      c = esc;
#line 391
      goto store_escape;
    }
#line 393
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 396
    if (argsize == 4294967295U) {
#line 396
      tmp___3 = (int const   )*(arg + 1) == 0;
    } else {
#line 396
      tmp___3 = argsize == 1U;
    }
#line 396
    if (! tmp___3) {
#line 397
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 400
    if (i != 0U) {
#line 401
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 416
    if ((unsigned int )quoting_style == 2U) {
#line 416
      if (elide_outer_quotes) {
#line 418
        goto force_outer_quoting_style;
      }
    }
#line 419
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 422
    if ((unsigned int )quoting_style == 2U) {
#line 424
      if (elide_outer_quotes) {
#line 425
        goto force_outer_quoting_style;
      }
      {
#line 426
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 426
        if (len < buffersize) {
#line 426
          *(buffer + len) = (char )'\'';
        }
#line 426
        len ++;
#line 426
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 427
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 427
        if (len < buffersize) {
#line 427
          *(buffer + len) = (char )'\\';
        }
#line 427
        len ++;
#line 427
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 428
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 428
        if (len < buffersize) {
#line 428
          *(buffer + len) = (char )'\'';
        }
#line 428
        len ++;
#line 428
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 430
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 446
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 460
    if (unibyte_locale) {
      {
#line 462
      m = (size_t )1;
#line 463
      tmp___4 = __ctype_b_loc();
#line 463
      printable = (_Bool )(((int const   )*(*tmp___4 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 468
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
#line 470
      m = (size_t )0;
#line 471
      printable = (_Bool)1;
      }
#line 472
      if (argsize == 4294967295U) {
        {
#line 473
        argsize = strlen(arg);
        }
      }
      {
#line 475
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 478
        tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 478
        bytes = tmp___5;
        }
#line 480
        if (bytes == 0U) {
#line 481
          goto while_break___15;
        } else
#line 482
        if (bytes == 4294967295U) {
#line 484
          printable = (_Bool)0;
#line 485
          goto while_break___15;
        } else
#line 487
        if (bytes == 4294967294U) {
#line 489
          printable = (_Bool)0;
          {
#line 490
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 490
            if (i + m < argsize) {
#line 490
              if (! *(arg + (i + m))) {
#line 490
                goto while_break___16;
              }
            } else {
#line 490
              goto while_break___16;
            }
#line 491
            m ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 492
          goto while_break___15;
        } else {
#line 500
          if (elide_outer_quotes) {
#line 500
            if ((unsigned int )quoting_style == 2U) {
#line 504
              j = (size_t )1;
              {
#line 504
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 504
                if (! (j < bytes)) {
#line 504
                  goto while_break___17;
                }
                {
#line 508
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 508
                  goto case_124___0;
                }
#line 508
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 508
                  goto case_124___0;
                }
#line 508
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 508
                  goto case_124___0;
                }
#line 508
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 508
                  goto case_124___0;
                }
#line 508
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 508
                  goto case_124___0;
                }
#line 511
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 509
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 512
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 504
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            }
          }
          {
#line 516
          tmp___6 = iswprint((wint_t )w);
          }
#line 516
          if (! tmp___6) {
#line 517
            printable = (_Bool)0;
          }
#line 518
          m += bytes;
        }
        {
#line 475
        tmp___7 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 475
        if (tmp___7) {
#line 475
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 524
    if (1U < m) {
#line 524
      goto _L;
    } else
#line 524
    if (backslash_escapes) {
#line 524
      if (! printable) {
        _L: /* CIL Label */ 
#line 528
        ilim = i + m;
        {
#line 530
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 532
          if (backslash_escapes) {
#line 532
            if (! printable) {
#line 534
              if (elide_outer_quotes) {
#line 535
                goto force_outer_quoting_style;
              }
              {
#line 536
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 536
                if (len < buffersize) {
#line 536
                  *(buffer + len) = (char )'\\';
                }
#line 536
                len ++;
#line 536
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 537
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 537
                if (len < buffersize) {
#line 537
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 537
                len ++;
#line 537
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 538
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 538
                if (len < buffersize) {
#line 538
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 538
                len ++;
#line 538
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 539
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 541
          if (ilim <= i + 1U) {
#line 542
            goto while_break___18;
          }
          {
#line 543
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 543
            if (len < buffersize) {
#line 543
              *(buffer + len) = (char )c;
            }
#line 543
            len ++;
#line 543
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 544
          i ++;
#line 544
          c = (unsigned char )*(arg + i);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 547
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 552
    if (backslash_escapes) {
#line 552
      goto _L___0;
    } else
#line 552
    if (elide_outer_quotes) {
      _L___0: /* CIL Label */ 
#line 552
      if (quote_these_too) {
#line 552
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 555
          goto store_c;
        }
      } else {
#line 555
        goto store_c;
      }
    } else {
#line 555
      goto store_c;
    }
    store_escape: 
#line 558
    if (elide_outer_quotes) {
#line 559
      goto force_outer_quoting_style;
    }
    {
#line 560
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 560
      if (len < buffersize) {
#line 560
        *(buffer + len) = (char )'\\';
      }
#line 560
      len ++;
#line 560
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 563
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 563
      if (len < buffersize) {
#line 563
        *(buffer + len) = (char )c;
      }
#line 563
      len ++;
#line 563
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 296
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 566
  if (len == 0U) {
#line 566
    if ((unsigned int )quoting_style == 2U) {
#line 566
      if (elide_outer_quotes) {
#line 568
        goto force_outer_quoting_style;
      }
    }
  }
#line 570
  if (quote_string) {
#line 570
    if (! elide_outer_quotes) {
      {
#line 571
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 571
        if (! *quote_string) {
#line 571
          goto while_break___25;
        }
        {
#line 572
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 572
          if (len < buffersize) {
#line 572
            *(buffer + len) = (char )*quote_string;
          }
#line 572
          len ++;
#line 572
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 571
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 574
  if (len < buffersize) {
#line 575
    *(buffer + len) = (char )'\000';
  }
#line 576
  return (len);
  force_outer_quoting_style: 
  {
#line 581
  tmp___9 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0));
  }
#line 581
  return (tmp___9);
}
}
#line 595 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 600
  if (o) {
#line 600
    tmp = o;
  } else {
#line 600
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 600
  p = tmp;
#line 601
  tmp___0 = __errno_location();
#line 601
  e = *tmp___0;
#line 602
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too));
#line 602
  r = tmp___1;
#line 604
  tmp___2 = __errno_location();
#line 604
  *tmp___2 = e;
  }
#line 605
  return (r);
}
}
#line 609 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 613
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 613
  return (tmp);
}
}
#line 622 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf___0 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 626
  if (o) {
#line 626
    tmp = o;
  } else {
#line 626
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 626
  p = tmp;
#line 627
  tmp___0 = __errno_location();
#line 627
  e = *tmp___0;
  }
#line 629
  if (size) {
#line 629
    tmp___1 = 0;
  } else {
#line 629
    tmp___1 = 1;
  }
  {
#line 629
  flags = (int )(p->flags | (int const   )tmp___1);
#line 630
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too));
#line 630
  bufsize = tmp___2 + 1U;
#line 632
  tmp___3 = xcharalloc(bufsize);
#line 632
  buf___0 = tmp___3;
#line 633
  quotearg_buffer_restyled(buf___0, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too));
#line 635
  tmp___4 = __errno_location();
#line 635
  *tmp___4 = e;
  }
#line 636
  if (size) {
#line 637
    *size = bufsize - 1U;
  }
#line 638
  return (buf___0);
}
}
#line 650 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static char slot0[256]  ;
#line 651 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 652 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 653 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 655 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 658
  sv = slotvec;
#line 660
  i = 1U;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! (i < nslots)) {
#line 660
      goto while_break;
    }
    {
#line 661
    free((void *)(sv + i)->val);
#line 660
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 664
    free((void *)(sv + 0)->val);
#line 665
    slotvec0.size = (size_t )sizeof(slot0);
#line 666
    slotvec0.val = slot0;
    }
  }
#line 668
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 670
    free((void *)sv);
#line 671
    slotvec = & slotvec0;
    }
  }
#line 673
  nslots = 1U;
#line 674
  return;
}
}
#line 684 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 688
  tmp = __errno_location();
#line 688
  e = *tmp;
#line 690
  n0 = (unsigned int )n;
#line 691
  sv = slotvec;
  }
#line 693
  if (n < 0) {
    {
#line 694
    abort();
    }
  }
#line 696
  if (nslots <= n0) {
#line 703
    n1 = n0 + 1U;
#line 704
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 706
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 706
      tmp___0 = -1;
    } else {
#line 706
      tmp___0 = -2;
    }
#line 706
    if ((unsigned long )((size_t )tmp___0) / sizeof(*sv) < (unsigned long )n1) {
      {
#line 707
      xalloc_die();
      }
    }
#line 709
    if (preallocated) {
#line 709
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 709
      tmp___1 = sv;
    }
    {
#line 709
    tmp___2 = xrealloc((void *)tmp___1, (size_t )((unsigned long )n1 * sizeof(*sv)));
#line 709
    sv = (struct slotvec *)tmp___2;
#line 709
    slotvec = sv;
    }
#line 710
    if (preallocated) {
#line 711
      *sv = slotvec0;
    }
    {
#line 712
    memset((void *)(sv + nslots), 0, (size_t )((unsigned long )(n1 - nslots) * sizeof(*sv)));
#line 713
    nslots = n1;
    }
  }
  {
#line 717
  size = (sv + n)->size;
#line 718
  val = (sv + n)->val;
#line 720
  flags = (int )(options->flags | 1);
#line 721
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too));
#line 721
  qsize = tmp___3;
  }
#line 725
  if (size <= qsize) {
#line 727
    size = qsize + 1U;
#line 727
    (sv + n)->size = size;
#line 728
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 729
      free((void *)val);
      }
    }
    {
#line 730
    val = xcharalloc(size);
#line 730
    (sv + n)->val = val;
#line 731
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too));
    }
  }
  {
#line 735
  tmp___4 = __errno_location();
#line 735
  *tmp___4 = e;
  }
#line 736
  return (val);
}
}
#line 740 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 743
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 743
  return (tmp);
}
}
#line 746 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 749
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 749
  return (tmp);
}
}
#line 752 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 755
  tmp = quotearg_n(0, arg);
  }
#line 755
  return (tmp);
}
}
#line 758 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 761
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 761
  return (tmp);
}
}
#line 764 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 767
  tmp = quoting_options_from_style(s);
#line 767
  o = tmp;
#line 768
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 768
  return (tmp___0);
}
}
#line 771 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 775
  tmp = quoting_options_from_style(s);
#line 775
  o = tmp;
#line 776
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 776
  return (tmp___0);
}
}
#line 779 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 782
  tmp = quotearg_n_style(0, s, arg);
  }
#line 782
  return (tmp);
}
}
#line 785 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 788
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 788
  return (tmp);
}
}
#line 791 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 795
  options = default_quoting_options;
#line 796
  set_char_quoting(& options, ch, 1);
#line 797
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 797
  return (tmp);
}
}
#line 800 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 803
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 803
  return (tmp);
}
}
#line 806 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 809
  tmp = quotearg_char(arg, (char )':');
  }
#line 809
  return (tmp);
}
}
#line 812 "/home/pronto/abs/test-suite/bison-2.4/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 815
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 815
  return (tmp);
}
}
#line 20 "/home/pronto/abs/test-suite/bison-2.4/lib/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 21
char const   *quote(char const   *name ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/lib/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "/home/pronto/abs/test-suite/bison-2.4/lib/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 39
  tmp = quote_n(0, name);
  }
#line 39
  return (tmp);
}
}
#line 21 "/home/pronto/abs/test-suite/bison-2.4/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 369 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.4/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 51 "/home/pronto/abs/test-suite/bison-2.4/lib/mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 364 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 135 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
#line 50 "/home/pronto/abs/test-suite/bison-2.4/lib/mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 53
  tmp = strlen(string);
#line 53
  tmp___0 = mbsnwidth(string, tmp, flags);
  }
#line 53
  return (tmp___0);
}
}
#line 61 "/home/pronto/abs/test-suite/bison-2.4/lib/mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ 
  char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned char c ;
  char const   *tmp___4 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  {
#line 64
  p = string;
#line 65
  plimit = p + nbytes;
#line 68
  width = 0;
#line 70
  tmp___3 = __ctype_get_mb_cur_max();
  }
#line 70
  if (tmp___3 > 1U) {
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 72
        goto while_break;
      }
      {
#line 94
      if ((int const   )*p == 126) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 125) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 124) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 123) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 122) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 121) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 120) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 119) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 118) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 117) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 116) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 115) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 114) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 113) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 112) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 111) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 110) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 109) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 108) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 107) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 106) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 105) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 104) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 103) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 102) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 101) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 100) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 99) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 98) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 97) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 95) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 94) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 93) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 92) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 91) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 90) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 89) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 88) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 87) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 86) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 85) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 84) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 83) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 82) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 81) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 80) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 79) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 78) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 77) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 76) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 75) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 74) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 73) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 72) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 71) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 70) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 69) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 68) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 67) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 66) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 65) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 63) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 62) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 61) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 60) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 59) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 58) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 57) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 56) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 55) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 54) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 53) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 52) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 51) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 50) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 49) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 48) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 47) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 46) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 45) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 44) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 43) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 42) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 41) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 40) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 39) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 38) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 37) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 35) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 34) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 33) {
#line 94
        goto case_126;
      }
#line 94
      if ((int const   )*p == 32) {
#line 94
        goto case_126;
      }
#line 99
      goto switch_default;
      case_126: /* CIL Label */ 
      case_125: /* CIL Label */ 
      case_124: /* CIL Label */ 
      case_123: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_121: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_119: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_115: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_112: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_109: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_107: /* CIL Label */ 
      case_106: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_104: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_93: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_90: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_87: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_85: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_83: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_80: /* CIL Label */ 
      case_79: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_77: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_74: /* CIL Label */ 
      case_73: /* CIL Label */ 
      case_72: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_63: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_47: /* CIL Label */ 
      case_46: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_42: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_40: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_38: /* CIL Label */ 
      case_37: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_34: /* CIL Label */ 
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 96
      p ++;
#line 97
      width ++;
#line 98
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 103
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
      }
      {
#line 104
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 110
        bytes = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                        (size_t )(plimit - p), & mbstate);
        }
#line 112
        if (bytes == 4294967295U) {
#line 115
          if (! (flags & 1)) {
#line 117
            p ++;
#line 118
            width ++;
#line 119
            goto while_break___0;
          } else {
#line 122
            return (-1);
          }
        }
#line 125
        if (bytes == 4294967294U) {
#line 128
          if (! (flags & 1)) {
#line 130
            p = plimit;
#line 131
            width ++;
#line 132
            goto while_break___0;
          } else {
#line 135
            return (-1);
          }
        }
#line 138
        if (bytes == 0U) {
#line 140
          bytes = (size_t )1;
        }
        {
#line 142
        w = wcwidth(wc);
        }
#line 143
        if (w >= 0) {
#line 145
          width += w;
        } else
#line 148
        if (! (flags & 2)) {
          {
#line 149
          tmp___1 = iswcntrl((wint_t )wc);
          }
#line 149
          if (tmp___1) {
#line 149
            tmp___0 = 0;
          } else {
#line 149
            tmp___0 = 1;
          }
#line 149
          width += tmp___0;
        } else {
#line 151
          return (-1);
        }
        {
#line 153
        p += bytes;
#line 104
        tmp___2 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 104
        if (tmp___2) {
#line 104
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 159
    return (width);
  }
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    if (! ((unsigned long )p < (unsigned long )plimit)) {
#line 163
      goto while_break___1;
    }
    {
#line 165
    tmp___4 = p;
#line 165
    p ++;
#line 165
    c = (unsigned char )*tmp___4;
#line 167
    tmp___8 = __ctype_b_loc();
    }
#line 167
    if ((int const   )*(*tmp___8 + (int )c) & 16384) {
#line 168
      width ++;
    } else
#line 169
    if (! (flags & 2)) {
      {
#line 170
      tmp___7 = __ctype_b_loc();
      }
#line 170
      if ((int const   )*(*tmp___7 + (int )c) & 2) {
#line 170
        tmp___6 = 0;
      } else {
#line 170
        tmp___6 = 1;
      }
#line 170
      width += tmp___6;
    } else {
#line 172
      return (-1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 174
  return (width);
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.4/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 393
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 454
extern int getc_unlocked(FILE *__stream ) ;
#line 596
extern int ungetc(int __c , FILE *__stream ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 654 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 576 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 106 "/home/pronto/abs/test-suite/bison-2.4/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 109 "/home/pronto/abs/test-suite/bison-2.4/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base___0 ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 114
  cp = (char const   *)charset_aliases;
#line 115
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 120
    base___0 = "charset.alias";
#line 125
    tmp = getenv("CHARSETALIASDIR");
#line 125
    dir = (char const   *)tmp;
    }
#line 126
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 127
      dir = "/usr/local/lib";
    } else
#line 126
    if ((int const   )*(dir + 0) == 0) {
#line 127
      dir = "/usr/local/lib";
    }
    {
#line 131
    tmp___0 = strlen(dir);
#line 131
    dir_len___0 = tmp___0;
#line 132
    tmp___1 = strlen(base___0);
#line 132
    base_len___0 = tmp___1;
    }
#line 133
    if (dir_len___0 > 0U) {
#line 133
      if (! ((int const   )*(dir + (dir_len___0 - 1U)) == 47)) {
#line 133
        tmp___2 = 1;
      } else {
#line 133
        tmp___2 = 0;
      }
    } else {
#line 133
      tmp___2 = 0;
    }
    {
#line 133
    add_slash = tmp___2;
#line 134
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1U);
#line 134
    file_name = (char *)tmp___3;
    }
#line 135
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 137
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 138
      if (add_slash) {
#line 139
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 140
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base___0,
             base_len___0 + 1U);
      }
    }
#line 144
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 146
      cp = "";
    } else {
      {
#line 144
      fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
      }
#line 144
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 146
        cp = "";
      } else {
#line 150
        res_ptr = (char *)((void *)0);
#line 151
        res_size = (size_t )0;
        {
#line 153
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 161
          c = getc_unlocked(fp);
          }
#line 162
          if (c == -1) {
#line 163
            goto while_break;
          }
#line 164
          if (c == 10) {
#line 165
            goto __Cont;
          } else
#line 164
          if (c == 32) {
#line 165
            goto __Cont;
          } else
#line 164
          if (c == 9) {
#line 165
            goto __Cont;
          }
#line 166
          if (c == 35) {
            {
#line 169
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 170
              c = getc_unlocked(fp);
              }
#line 169
              if (c == -1) {
#line 169
                goto while_break___0;
              } else
#line 169
              if (c == 10) {
#line 169
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 172
            if (c == -1) {
#line 173
              goto while_break;
            }
#line 174
            goto __Cont;
          }
          {
#line 176
          ungetc(c, fp);
#line 177
          tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                           buf1, buf2);
          }
#line 177
          if (tmp___4 < 2) {
#line 178
            goto while_break;
          }
          {
#line 179
          l1 = strlen((char const   *)(buf1));
#line 180
          l2 = strlen((char const   *)(buf2));
#line 181
          old_res_ptr = res_ptr;
          }
#line 182
          if (res_size == 0U) {
            {
#line 184
            res_size = ((l1 + 1U) + l2) + 1U;
#line 185
            tmp___5 = malloc(res_size + 1U);
#line 185
            res_ptr = (char *)tmp___5;
            }
          } else {
            {
#line 189
            res_size += ((l1 + 1U) + l2) + 1U;
#line 190
            tmp___6 = realloc((void *)res_ptr, res_size + 1U);
#line 190
            res_ptr = (char *)tmp___6;
            }
          }
#line 192
          if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 195
            res_size = (size_t )0;
#line 196
            if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
              {
#line 197
              free((void *)old_res_ptr);
              }
            }
#line 198
            goto while_break;
          }
          {
#line 200
          strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U)),
                 (char const   */* __restrict  */)(buf1));
#line 201
          strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1U)), (char const   */* __restrict  */)(buf2));
          }
          __Cont: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 203
        fclose(fp);
        }
#line 204
        if (res_size == 0U) {
#line 205
          cp = "";
        } else {
#line 208
          *(res_ptr + res_size) = (char )'\000';
#line 209
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 213
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 214
      free((void *)file_name);
      }
    }
#line 274
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 277
  return (cp);
}
}
#line 289 "/home/pronto/abs/test-suite/bison-2.4/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 300
  tmp = nl_langinfo(14);
#line 300
  codeset = (char const   *)tmp;
  }
#line 442
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 444
    codeset = "";
  }
  {
#line 447
  aliases = get_charset_aliases();
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! ((int const   )*aliases != 0)) {
#line 447
      goto while_break;
    }
    {
#line 450
    tmp___3 = strcmp(codeset, aliases);
    }
#line 450
    if (tmp___3 == 0) {
      {
#line 453
      tmp___2 = strlen(aliases);
#line 453
      codeset = (aliases + tmp___2) + 1;
      }
#line 454
      goto while_break;
    } else
#line 450
    if ((int const   )*(aliases + 0) == 42) {
#line 450
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 453
        tmp___2 = strlen(aliases);
#line 453
        codeset = (aliases + tmp___2) + 1;
        }
#line 454
        goto while_break;
      }
    }
    {
#line 447
    tmp___0 = strlen(aliases);
#line 447
    aliases += tmp___0 + 1U;
#line 447
    tmp___1 = strlen(aliases);
#line 447
    aliases += tmp___1 + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if ((int const   )*(codeset + 0) == 0) {
#line 461
    codeset = "ASCII";
  }
#line 463
  return (codeset);
}
}
#line 59 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) ;
#line 60
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) ;
#line 61
size_t hash_get_n_entries(Hash_table const   *table___0 ) ;
#line 62
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) ;
#line 63
_Bool hash_table_ok(Hash_table const   *table___0 ) ;
#line 64
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) ;
#line 65
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) ;
#line 68
void *hash_get_first(Hash_table const   *table___0 ) ;
#line 69
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) ;
#line 70
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) ;
#line 71
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
#line 74
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 75
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 76
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) ;
#line 79
void hash_clear(Hash_table *table___0 ) ;
#line 80
void hash_free(Hash_table *table___0 ) ;
#line 83
_Bool hash_rehash(Hash_table *table___0 , size_t candidate ) ;
#line 84
void *hash_insert(Hash_table *table___0 , void const   *entry ) ;
#line 85
void *hash_delete(Hash_table *table___0 , void const   *entry ) ;
#line 127 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 146 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) 
{ 


  {
#line 149
  return ((size_t )table___0->n_buckets);
}
}
#line 154 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) 
{ 


  {
#line 157
  return ((size_t )table___0->n_buckets_used);
}
}
#line 162 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table___0 ) 
{ 


  {
#line 165
  return ((size_t )table___0->n_entries);
}
}
#line 170 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 174
  max_bucket_length = (size_t )0;
#line 176
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 176
      goto while_break;
    }
#line 178
    if (bucket->data) {
#line 180
      cursor = bucket;
#line 181
      bucket_length = (size_t )1;
      {
#line 183
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        cursor = (struct hash_entry  const  *)cursor->next;
#line 183
        if (! cursor) {
#line 183
          goto while_break___0;
        }
#line 184
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 186
      if (bucket_length > max_bucket_length) {
#line 187
        max_bucket_length = bucket_length;
      }
    }
#line 176
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (max_bucket_length);
}
}
#line 197 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 201
  n_buckets_used = (size_t )0;
#line 202
  n_entries = (size_t )0;
#line 204
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 204
      goto while_break;
    }
#line 206
    if (bucket->data) {
#line 208
      cursor = bucket;
#line 211
      n_buckets_used ++;
#line 212
      n_entries ++;
      {
#line 215
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 215
        cursor = (struct hash_entry  const  *)cursor->next;
#line 215
        if (! cursor) {
#line 215
          goto while_break___0;
        }
#line 216
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 204
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (n_buckets_used == (size_t )table___0->n_buckets_used) {
#line 220
    if (n_entries == (size_t )table___0->n_entries) {
#line 221
      return ((_Bool)1);
    }
  }
#line 223
  return ((_Bool)0);
}
}
#line 226 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 229
  tmp = hash_get_n_entries(table___0);
#line 229
  n_entries = tmp;
#line 230
  tmp___0 = hash_get_n_buckets(table___0);
#line 230
  n_buckets = tmp___0;
#line 231
  tmp___1 = hash_get_n_buckets_used(table___0);
#line 231
  n_buckets_used = tmp___1;
#line 232
  tmp___2 = hash_get_max_bucket_length(table___0);
#line 232
  max_bucket_length = tmp___2;
#line 234
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          (unsigned long )n_entries);
#line 235
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          (unsigned long )n_buckets);
#line 236
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          (unsigned long )n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          (unsigned long )max_bucket_length);
  }
#line 241
  return;
}
}
#line 246 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 249
  tmp = (*(table___0->hasher))(entry, (size_t )table___0->n_buckets);
#line 249
  bucket = (struct hash_entry  const  *)(table___0->bucket + tmp);
  }
#line 253
  if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
    {
#line 254
    abort();
    }
  }
#line 256
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 257
    return ((void *)0);
  }
#line 259
  cursor = bucket;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! cursor) {
#line 259
      goto while_break;
    }
    {
#line 260
    tmp___0 = (*(table___0->comparator))(entry, (void const   *)cursor->data);
    }
#line 260
    if (tmp___0) {
#line 261
      return ((void *)cursor->data);
    }
#line 259
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return ((void *)0);
}
}
#line 275 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void *hash_get_first(Hash_table const   *table___0 ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 280
  if (table___0->n_entries == 0U) {
#line 281
    return ((void *)0);
  }
#line 283
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
      {
#line 285
      abort();
      }
    } else
#line 286
    if (bucket->data) {
#line 287
      return ((void *)bucket->data);
    }
#line 283
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 294 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 297
  tmp = (*(table___0->hasher))(entry, (size_t )table___0->n_buckets);
#line 297
  bucket = (struct hash_entry  const  *)(table___0->bucket + tmp);
  }
#line 301
  if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
    {
#line 302
    abort();
    }
  }
#line 305
  cursor = bucket;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! cursor) {
#line 305
      goto while_break;
    }
#line 306
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 306
      if (cursor->next) {
#line 307
        return ((cursor->next)->data);
      }
    }
#line 305
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 310
    bucket ++;
#line 310
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 310
      goto while_break___0;
    }
#line 311
    if (bucket->data) {
#line 312
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  return ((void *)0);
}
}
#line 322 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 326
  counter = (size_t )0;
#line 330
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 330
      goto while_break;
    }
#line 332
    if (bucket->data) {
#line 334
      cursor = bucket;
      {
#line 334
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 334
        if (! cursor) {
#line 334
          goto while_break___0;
        }
#line 336
        if (counter >= buffer_size) {
#line 337
          return (counter);
        }
#line 338
        tmp = counter;
#line 338
        counter ++;
#line 338
        *(buffer + tmp) = (void *)cursor->data;
#line 334
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 330
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (counter);
}
}
#line 354 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 358
  counter = (size_t )0;
#line 362
  bucket = (struct hash_entry  const  *)table___0->bucket;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 362
      goto while_break;
    }
#line 364
    if (bucket->data) {
#line 366
      cursor = bucket;
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if (! cursor) {
#line 366
          goto while_break___0;
        }
        {
#line 368
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 368
        if (! tmp) {
#line 369
          return (counter);
        }
#line 370
        counter ++;
#line 366
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 362
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (counter);
}
}
#line 417 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 420
  value = (size_t )0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    ch = (unsigned char )*string;
#line 423
    if (! ch) {
#line 423
      goto while_break;
    }
#line 424
    value = (value * 31U + (size_t )ch) % n_buckets;
#line 423
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return (value);
}
}
#line 433 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 436
  divisor = (size_t )3;
#line 437
  square = divisor * divisor;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (square < candidate) {
#line 439
      if (! (candidate % divisor)) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
#line 441
    divisor ++;
#line 442
    square += 4U * divisor;
#line 443
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  if (candidate % divisor) {
#line 446
    tmp = 1;
  } else {
#line 446
    tmp = 0;
  }
#line 446
  return ((_Bool )tmp);
}
}
#line 452 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 456
  if (candidate < 10U) {
#line 457
    candidate = (size_t )10;
  }
#line 460
  candidate |= 1U;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 462
    tmp = is_prime(candidate);
    }
#line 462
    if (tmp) {
#line 462
      goto while_break;
    }
#line 463
    candidate += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (candidate);
}
}
#line 468 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 471
  *tuning = (Hash_tuning )default_tuning;
#line 472
  return;
}
}
#line 480 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static _Bool check_tuning(Hash_table *table___0 ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 483
  tuning = table___0->tuning;
#line 490
  epsilon = 0.1f;
#line 492
  if (epsilon < (float )tuning->growth_threshold) {
#line 492
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 492
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 492
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 492
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 492
            if (tuning->shrink_factor <= (float const   )1) {
#line 492
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 499
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 501
  table___0->tuning = & default_tuning;
#line 502
  return ((_Bool)0);
}
}
#line 536 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ 
  Hash_table *table___0 ;
  void *tmp ;
  _Bool tmp___0 ;
  float new_candidate ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 543
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 544
    return ((Hash_table *)((void *)0));
  } else
#line 543
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 544
    return ((Hash_table *)((void *)0));
  }
  {
#line 546
  tmp = malloc((size_t )sizeof(*table___0));
#line 546
  table___0 = (Hash_table *)tmp;
  }
#line 547
  if ((unsigned long )table___0 == (unsigned long )((void *)0)) {
#line 548
    return ((Hash_table *)((void *)0));
  }
#line 550
  if (! tuning) {
#line 551
    tuning = & default_tuning;
  }
  {
#line 552
  table___0->tuning = tuning;
#line 553
  tmp___0 = check_tuning(table___0);
  }
#line 553
  if (! tmp___0) {
#line 560
    goto fail;
  }
#line 563
  if (! tuning->is_n_buckets) {
#line 565
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 566
    if ((float )4294967295U <= new_candidate) {
#line 567
      goto fail;
    }
#line 568
    candidate = (size_t )new_candidate;
  }
#line 571
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 571
    tmp___1 = -1;
  } else {
#line 571
    tmp___1 = -2;
  }
#line 571
  if ((unsigned long )((size_t )tmp___1) / sizeof(*(table___0->bucket)) < (unsigned long )candidate) {
#line 572
    goto fail;
  }
  {
#line 573
  table___0->n_buckets = next_prime(candidate);
  }
#line 574
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 574
    tmp___2 = -1;
  } else {
#line 574
    tmp___2 = -2;
  }
#line 574
  if ((unsigned long )((size_t )tmp___2) / sizeof(*(table___0->bucket)) < (unsigned long )table___0->n_buckets) {
#line 575
    goto fail;
  }
  {
#line 577
  tmp___3 = calloc(table___0->n_buckets, (size_t )sizeof(*(table___0->bucket)));
#line 577
  table___0->bucket = (struct hash_entry *)tmp___3;
  }
#line 578
  if ((unsigned long )table___0->bucket == (unsigned long )((void *)0)) {
#line 579
    goto fail;
  }
#line 580
  table___0->bucket_limit = (struct hash_entry  const  *)(table___0->bucket + table___0->n_buckets);
#line 581
  table___0->n_buckets_used = (size_t )0;
#line 582
  table___0->n_entries = (size_t )0;
#line 584
  table___0->hasher = hasher;
#line 585
  table___0->comparator = comparator;
#line 586
  table___0->data_freer = data_freer;
#line 588
  table___0->free_entry_list = (struct hash_entry *)((void *)0);
#line 592
  return (table___0);
  fail: 
  {
#line 595
  free((void *)table___0);
  }
#line 596
  return ((Hash_table *)((void *)0));
}
}
#line 603 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void hash_clear(Hash_table *table___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 608
  bucket = table___0->bucket;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 608
      goto while_break;
    }
#line 610
    if (bucket->data) {
#line 616
      cursor = bucket->next;
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 616
        if (! cursor) {
#line 616
          goto while_break___0;
        }
#line 618
        if (table___0->data_freer) {
          {
#line 619
          (*(table___0->data_freer))(cursor->data);
          }
        }
#line 620
        cursor->data = (void *)0;
#line 622
        next = cursor->next;
#line 625
        cursor->next = table___0->free_entry_list;
#line 626
        table___0->free_entry_list = cursor;
#line 616
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 630
      if (table___0->data_freer) {
        {
#line 631
        (*(table___0->data_freer))(bucket->data);
        }
      }
#line 632
      bucket->data = (void *)0;
#line 633
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 608
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  table___0->n_buckets_used = (size_t )0;
#line 638
  table___0->n_entries = (size_t )0;
#line 639
  return;
}
}
#line 646 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void hash_free(Hash_table *table___0 ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 654
  if (table___0->data_freer) {
#line 654
    if (table___0->n_entries) {
#line 656
      bucket = table___0->bucket;
      {
#line 656
      while (1) {
        while_continue: /* CIL Label */ ;
#line 656
        if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 656
          goto while_break;
        }
#line 658
        if (bucket->data) {
#line 660
          cursor = bucket;
          {
#line 660
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 660
            if (! cursor) {
#line 660
              goto while_break___0;
            }
            {
#line 662
            (*(table___0->data_freer))(cursor->data);
#line 660
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 656
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 675
  bucket = table___0->bucket;
  {
#line 675
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 675
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 675
      goto while_break___1;
    }
#line 677
    cursor = bucket->next;
    {
#line 677
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 677
      if (! cursor) {
#line 677
        goto while_break___2;
      }
      {
#line 679
      next = cursor->next;
#line 680
      free((void *)cursor);
#line 677
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 675
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 685
  cursor = table___0->free_entry_list;
  {
#line 685
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 685
    if (! cursor) {
#line 685
      goto while_break___3;
    }
    {
#line 687
    next = cursor->next;
#line 688
    free((void *)cursor);
#line 685
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 694
  free((void *)table___0->bucket);
#line 695
  free((void *)table___0);
  }
#line 696
  return;
}
}
#line 703 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table___0 ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 708
  if (table___0->free_entry_list) {
#line 710
    new = table___0->free_entry_list;
#line 711
    table___0->free_entry_list = new->next;
  } else {
    {
#line 718
    tmp = malloc((size_t )sizeof(*new));
#line 718
    new = (struct hash_entry *)tmp;
    }
  }
#line 722
  return (new);
}
}
#line 728 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static void free_entry(Hash_table *table___0 , struct hash_entry *entry ) 
{ 


  {
#line 731
  entry->data = (void *)0;
#line 732
  entry->next = table___0->free_entry_list;
#line 733
  table___0->free_entry_list = entry;
#line 734
  return;
}
}
#line 742 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
static void *hash_find_entry(Hash_table *table___0 , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 746
  tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
#line 746
  bucket = table___0->bucket + tmp;
  }
#line 750
  if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
    {
#line 751
    abort();
    }
  }
#line 753
  *bucket_head = bucket;
#line 756
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 757
    return ((void *)0);
  }
  {
#line 760
  tmp___0 = (*(table___0->comparator))(entry, (void const   *)bucket->data);
  }
#line 760
  if (tmp___0) {
#line 762
    data = bucket->data;
#line 764
    if (delete) {
#line 766
      if (bucket->next) {
        {
#line 768
        next = bucket->next;
#line 772
        *bucket = *next;
#line 773
        free_entry(table___0, next);
        }
      } else {
#line 777
        bucket->data = (void *)0;
      }
    }
#line 781
    return (data);
  }
#line 785
  cursor = bucket;
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! cursor->next) {
#line 785
      goto while_break;
    }
    {
#line 787
    tmp___1 = (*(table___0->comparator))(entry, (void const   *)(cursor->next)->data);
    }
#line 787
    if (tmp___1) {
#line 789
      data___0 = (cursor->next)->data;
#line 791
      if (delete) {
        {
#line 793
        next___0 = cursor->next;
#line 797
        cursor->next = next___0->next;
#line 798
        free_entry(table___0, next___0);
        }
      }
#line 801
      return (data___0);
    }
#line 785
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  return ((void *)0);
}
}
#line 817 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
_Bool hash_rehash(Hash_table *table___0 , size_t candidate ) 
{ 
  Hash_table *new_table ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___0 ;

  {
  {
#line 825
  new_table = hash_initialize(candidate, table___0->tuning, table___0->hasher, table___0->comparator,
                              table___0->data_freer);
  }
#line 827
  if ((unsigned long )new_table == (unsigned long )((void *)0)) {
#line 828
    return ((_Bool)0);
  }
#line 835
  new_table->free_entry_list = table___0->free_entry_list;
#line 837
  bucket = table___0->bucket;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )bucket < (unsigned long )table___0->bucket_limit)) {
#line 837
      goto while_break;
    }
#line 838
    if (bucket->data) {
#line 839
      cursor = bucket;
      {
#line 839
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 839
        if (! cursor) {
#line 839
          goto while_break___0;
        }
        {
#line 841
        data = cursor->data;
#line 842
        tmp = (*(new_table->hasher))((void const   *)data, new_table->n_buckets);
#line 842
        new_bucket = new_table->bucket + tmp;
        }
#line 846
        if (! ((unsigned long )new_bucket < (unsigned long )new_table->bucket_limit)) {
          {
#line 847
          abort();
          }
        }
#line 849
        next = cursor->next;
#line 851
        if (new_bucket->data) {
#line 853
          if ((unsigned long )cursor == (unsigned long )bucket) {
            {
#line 857
            tmp___0 = allocate_entry(new_table);
#line 857
            new_entry = tmp___0;
            }
#line 859
            if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 860
              return ((_Bool)0);
            }
#line 862
            new_entry->data = data;
#line 863
            new_entry->next = new_bucket->next;
#line 864
            new_bucket->next = new_entry;
          } else {
#line 870
            cursor->next = new_bucket->next;
#line 871
            new_bucket->next = cursor;
          }
        } else {
#line 880
          new_bucket->data = data;
#line 881
          (new_table->n_buckets_used) ++;
#line 882
          if ((unsigned long )cursor != (unsigned long )bucket) {
            {
#line 883
            free_entry(new_table, cursor);
            }
          }
        }
#line 839
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 837
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 887
  free((void *)table___0->bucket);
#line 888
  table___0->bucket = new_table->bucket;
#line 889
  table___0->bucket_limit = new_table->bucket_limit;
#line 890
  table___0->n_buckets = new_table->n_buckets;
#line 891
  table___0->n_buckets_used = new_table->n_buckets_used;
#line 892
  table___0->free_entry_list = new_table->free_entry_list;
#line 897
  free((void *)new_table);
  }
#line 899
  return ((_Bool)1);
}
}
#line 906 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void *hash_insert(Hash_table *table___0 , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp___0 ;
  _Bool tmp___1 ;

  {
#line 913
  if (! entry) {
    {
#line 914
    abort();
    }
  }
  {
#line 917
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
  }
#line 917
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 918
    return (data);
  }
#line 922
  if (bucket->data) {
    {
#line 924
    tmp = allocate_entry(table___0);
#line 924
    new_entry = tmp;
    }
#line 926
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 927
      return ((void *)0);
    }
#line 931
    new_entry->data = (void *)entry;
#line 932
    new_entry->next = bucket->next;
#line 933
    bucket->next = new_entry;
#line 934
    (table___0->n_entries) ++;
#line 935
    return ((void *)entry);
  }
#line 940
  bucket->data = (void *)entry;
#line 941
  (table___0->n_entries) ++;
#line 942
  (table___0->n_buckets_used) ++;
#line 949
  if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
    {
#line 954
    check_tuning(table___0);
    }
#line 955
    if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 958
      tuning = table___0->tuning;
#line 959
      if (tuning->is_n_buckets) {
#line 959
        tmp___0 = (float const   )table___0->n_buckets * tuning->growth_factor;
      } else {
#line 959
        tmp___0 = ((float const   )table___0->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 959
      candidate = (float )tmp___0;
#line 965
      if ((float )4294967295U <= candidate) {
#line 966
        return ((void *)0);
      }
      {
#line 969
      tmp___1 = hash_rehash(table___0, (size_t )candidate);
      }
#line 969
      if (! tmp___1) {
#line 970
        entry = (void const   *)((void *)0);
      }
    }
  }
#line 974
  return ((void *)entry);
}
}
#line 981 "/home/pronto/abs/test-suite/bison-2.4/lib/hash.c"
void *hash_delete(Hash_table *table___0 , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;

  {
  {
#line 987
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)1);
  }
#line 988
  if (! data) {
#line 989
    return ((void *)0);
  }
#line 991
  (table___0->n_entries) --;
#line 992
  if (! bucket->data) {
#line 994
    (table___0->n_buckets_used) --;
#line 999
    if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
      {
#line 1004
      check_tuning(table___0);
      }
#line 1005
      if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1008
        tuning = table___0->tuning;
#line 1009
        if (tuning->is_n_buckets) {
#line 1009
          tmp = (float const   )table___0->n_buckets * tuning->shrink_factor;
        } else {
#line 1009
          tmp = ((float const   )table___0->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1009
        candidate = (size_t )tmp;
#line 1015
        hash_rehash(table___0, candidate);
        }
      }
    }
  }
#line 1020
  return (data);
}
}
#line 18 "/home/pronto/abs/test-suite/bison-2.4/lib/get-errno.h"
int get_errno(void) ;
#line 19
void set_errno(int e ) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/lib/get-errno.c"
int get_errno(void) 
{ 
  int *tmp ;

  {
  {
#line 35
  tmp = __errno_location();
  }
#line 35
  return (*tmp);
}
}
#line 38 "/home/pronto/abs/test-suite/bison-2.4/lib/get-errno.c"
void set_errno(int e ) 
{ 
  int *tmp ;

  {
  {
#line 41
  tmp = __errno_location();
#line 41
  *tmp = e;
  }
#line 42
  return;
}
}
#line 273 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 752
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 22 "/home/pronto/abs/test-suite/bison-2.4/lib/stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 20 "/home/pronto/abs/test-suite/bison-2.4/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 34 "/home/pronto/abs/test-suite/bison-2.4/lib/fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 37
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
#line 37
  fp = tmp;
  }
#line 39
  if (fp) {
    {
#line 41
    tmp___0 = fileno(fp);
#line 41
    fd = tmp___0;
    }
#line 43
    if (0 <= fd) {
#line 43
      if (fd <= 2) {
        {
#line 45
        tmp___1 = dup_safer(fd);
#line 45
        f = tmp___1;
        }
#line 47
        if (f < 0) {
          {
#line 49
          tmp___2 = __errno_location();
#line 49
          e = *tmp___2;
#line 50
          fclose(fp);
#line 51
          tmp___3 = __errno_location();
#line 51
          *tmp___3 = e;
          }
#line 52
          return ((FILE *)((void *)0));
        }
        {
#line 55
        tmp___6 = fclose(fp);
        }
#line 55
        if (tmp___6 != 0) {
#line 55
          goto _L;
        } else {
          {
#line 55
          fp = fdopen(f, mode);
          }
#line 55
          if (! fp) {
            _L: /* CIL Label */ 
            {
#line 58
            tmp___4 = __errno_location();
#line 58
            e___0 = *tmp___4;
#line 59
            close(f);
#line 60
            tmp___5 = __errno_location();
#line 60
            *tmp___5 = e___0;
            }
#line 61
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
#line 66
  return (fp);
}
}
#line 43 "/home/pronto/abs/test-suite/bison-2.4/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 46
  if (0 <= fd) {
#line 46
    if (fd <= 2) {
      {
#line 48
      tmp = dup_safer(fd);
#line 48
      f = tmp;
#line 49
      tmp___0 = __errno_location();
#line 49
      e = *tmp___0;
#line 50
      close(fd);
#line 51
      tmp___1 = __errno_location();
#line 51
      *tmp___1 = e;
#line 52
      fd = f;
      }
    }
  }
#line 55
  return (fd);
}
}
#line 24 "/home/pronto/abs/test-suite/bison-2.4/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 180 "/home/pronto/abs/test-suite/bison-2.4/lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.h"
size_t ebitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) ;
#line 25
bitset ebitset_init(bitset bset , bitset_bindex n_bits ) ;
#line 27
void ebitset_release_memory(void) ;
#line 80 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static ebitset_elt ebitset_zero_elts[1]  ;
#line 83 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static struct obstack ebitset_obstack  ;
#line 84 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_obstack_init  =    (_Bool)0;
#line 85 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static ebitset_elt *ebitset_free_list  ;
#line 120 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static bitset_bindex ebitset_resize(bitset src , bitset_bindex n_bits ) 
{ 
  bitset_windex oldsize ;
  bitset_windex newsize ;
  bitset_windex size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 126
  if (n_bits == src->b.n_bits) {
#line 127
    return (n_bits);
  }
#line 129
  oldsize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 130
  newsize = ((n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 132
  if (oldsize < newsize) {
#line 138
    if (newsize > src->e.size) {
#line 145
      if (oldsize == 0U) {
#line 146
        size = newsize;
      } else {
#line 148
        size = newsize + newsize / 4U;
      }
      {
#line 150
      tmp = realloc((void *)src->e.elts, (size_t )((unsigned long )size * sizeof(ebitset_elt *)));
#line 150
      src->e.elts = (struct ebitset_elt_struct **)tmp;
#line 152
      src->e.size = size;
      }
    }
    {
#line 155
    memset((void *)(src->e.elts + oldsize), 0, (size_t )((unsigned long )(newsize - oldsize) * sizeof(ebitset_elt *)));
    }
  } else
#line 162
  if (oldsize - newsize >= oldsize / 2U) {
    {
#line 164
    tmp___0 = realloc((void *)src->e.elts, (size_t )((unsigned long )newsize * sizeof(ebitset_elt *)));
#line 164
    src->e.elts = (struct ebitset_elt_struct **)tmp___0;
#line 166
    src->e.size = newsize;
    }
  }
#line 172
  src->b.n_bits = n_bits;
#line 173
  return (n_bits);
}
}
#line 178 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static ebitset_elt *ebitset_elt_alloc(void) 
{ 
  ebitset_elt *elt ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 183
  if ((unsigned long )ebitset_free_list != (unsigned long )((ebitset_elt *)0)) {
#line 185
    elt = ebitset_free_list;
#line 186
    ebitset_free_list = elt->u.next;
  } else {
#line 190
    if (! ebitset_obstack_init) {
      {
#line 192
      ebitset_obstack_init = (_Bool)1;
#line 214
      _obstack_begin(& ebitset_obstack, 0, (int )__alignof__(ebitset_elt ), (void *(*)(long  ))(& xmalloc),
                     & free);
      }
    }
#line 222
    __h = & ebitset_obstack;
#line 222
    __o = __h;
#line 222
    __len = (int )sizeof(ebitset_elt );
#line 222
    if (__o->chunk_limit - __o->next_free < (long )__len) {
      {
#line 222
      _obstack_newchunk(__o, __len);
      }
    }
#line 222
    __o->next_free += __len;
#line 222
    __o1 = __h;
#line 222
    __value = (void *)__o1->object_base;
#line 222
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 222
      __o1->maybe_empty_object = 1U;
    }
#line 222
    if (sizeof(int ) < sizeof(void *)) {
#line 222
      tmp = __o1->object_base;
    } else {
#line 222
      tmp = (char *)0;
    }
#line 222
    if (sizeof(int ) < sizeof(void *)) {
#line 222
      tmp___0 = __o1->object_base;
    } else {
#line 222
      tmp___0 = (char *)0;
    }
#line 222
    __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 222
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 222
      __o1->next_free = __o1->chunk_limit;
    }
#line 222
    __o1->object_base = __o1->next_free;
#line 222
    elt = (ebitset_elt *)__value;
  }
#line 226
  return (elt);
}
}
#line 231 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static ebitset_elt *ebitset_elt_calloc(void) 
{ 
  ebitset_elt *elt ;

  {
  {
#line 236
  elt = ebitset_elt_alloc();
#line 237
  memset((void *)(elt->u.words), 0, (size_t )sizeof(elt->u.words));
  }
#line 238
  return (elt);
}
}
#line 242 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_elt_free(ebitset_elt *elt ) 
{ 


  {
#line 245
  elt->u.next = ebitset_free_list;
#line 246
  ebitset_free_list = elt;
#line 247
  return;
}
}
#line 251 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_elt_remove(bitset bset , bitset_windex eindex ) 
{ 
  ebitset_elts *elts ;
  ebitset_elt *elt ;

  {
  {
#line 257
  elts = bset->e.elts;
#line 259
  elt = *(elts + eindex);
#line 261
  *(elts + eindex) = (ebitset_elts )0;
#line 262
  ebitset_elt_free(elt);
  }
#line 263
  return;
}
}
#line 267 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_elt_add(bitset bset , ebitset_elt *elt , bitset_windex eindex ) 
{ 
  ebitset_elts *elts ;

  {
#line 272
  elts = bset->e.elts;
#line 274
  *(elts + eindex) = elt;
#line 275
  return;
}
}
#line 279 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static _Bool ebitset_elt_zero_p(ebitset_elt *elt ) 
{ 
  int i ;

  {
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (i < 2)) {
#line 284
      goto while_break;
    }
#line 285
    if (elt->u.words[i]) {
#line 286
      return ((_Bool)0);
    }
#line 284
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return ((_Bool)1);
}
}
#line 292 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static ebitset_elt *ebitset_elt_find(bitset bset , bitset_bindex bindex , enum ebitset_find_mode mode ) 
{ 
  ebitset_elt *elt ;
  bitset_windex size ;
  bitset_windex eindex ;
  ebitset_elts *elts ;

  {
#line 301
  eindex = bindex / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 303
  elts = bset->e.elts;
#line 304
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 306
  if (eindex < size) {
#line 308
    elt = *(elts + eindex);
#line 308
    if (elt) {
#line 310
      if ((unsigned long )(elt->u.words) == (unsigned long )bset->b.cdata) {
#line 311
        return (elt);
      }
#line 313
      bset->b.cindex = eindex * 2U;
#line 313
      bset->b.cdata = (*(bset->e.elts + eindex))->u.words;
#line 314
      return (elt);
    }
  }
  {
#line 325
  if ((unsigned int )mode == 0U) {
#line 325
    goto case_0;
  }
#line 328
  if ((unsigned int )mode == 1U) {
#line 328
    goto case_1;
  }
#line 338
  if ((unsigned int )mode == 2U) {
#line 338
    goto case_2;
  }
#line 322
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 323
  abort();
  }
  case_0: /* CIL Label */ 
#line 326
  return ((ebitset_elt *)0);
  case_1: /* CIL Label */ 
#line 329
  if (eindex >= size) {
    {
#line 330
    ebitset_resize(bset, bindex);
    }
  }
  {
#line 333
  elt = ebitset_elt_calloc();
#line 334
  ebitset_elt_add(bset, elt, eindex);
#line 335
  bset->b.cindex = eindex * 2U;
#line 335
  bset->b.cdata = (*(bset->e.elts + eindex))->u.words;
  }
#line 336
  return (elt);
  case_2: /* CIL Label */ 
#line 339
  return (& ebitset_zero_elts[0]);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 345 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static bitset_windex ebitset_weed(bitset bset ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  bitset_windex count ;
  ebitset_elt *elt ;
  _Bool tmp ;

  {
#line 352
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 353
    return ((bitset_windex )0);
  }
#line 355
  elts = bset->e.elts;
#line 356
  count = (bitset_windex )0;
#line 357
  j = (bitset_windex )0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (j < ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 357
      goto while_break;
    }
#line 359
    elt = *(elts + j);
#line 361
    if (elt) {
      {
#line 363
      tmp = ebitset_elt_zero_p(elt);
      }
#line 363
      if (tmp) {
        {
#line 365
        ebitset_elt_remove(bset, j);
#line 366
        count ++;
        }
      }
    } else {
#line 370
      count ++;
    }
#line 357
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  count = j - count;
#line 374
  if (! count) {
#line 378
    bset->b.cindex = 4294967295U >> 1;
#line 378
    bset->b.cdata = (bitset_word *)0;
  } else {
#line 381
    bset->b.cindex = 4294967295U >> 1;
#line 381
    bset->b.cdata = (bitset_word *)(~ 0);
  }
#line 383
  return (count);
}
}
#line 388 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_zero(bitset bset ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  ebitset_elt *elt ;

  {
#line 394
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 395
    return;
  }
#line 397
  elts = bset->e.elts;
#line 398
  j = (bitset_windex )0;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (j < ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 398
      goto while_break;
    }
#line 400
    elt = *(elts + j);
#line 402
    if (elt) {
      {
#line 403
      ebitset_elt_remove(bset, j);
      }
    }
#line 398
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  bset->b.cindex = 4294967295U >> 1;
#line 408
  bset->b.cdata = (bitset_word *)0;
#line 409
  return;
}
}
#line 412 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static _Bool ebitset_equal_p(bitset dst , bitset src ) 
{ 
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex j ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 419
  if ((unsigned long )src == (unsigned long )dst) {
#line 420
    return ((_Bool)1);
  }
  {
#line 422
  ebitset_weed(dst);
#line 423
  ebitset_weed(src);
  }
#line 425
  if (((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))) != ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )))) {
#line 426
    return ((_Bool)0);
  }
#line 428
  selts = src->e.elts;
#line 429
  delts = dst->e.elts;
#line 431
  j = (bitset_windex )0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 431
      goto while_break;
    }
#line 434
    selt = *(selts + j);
#line 435
    delt = *(delts + j);
#line 437
    if (! selt) {
#line 437
      if (! delt) {
#line 438
        goto __Cont;
      }
    }
#line 439
    if (selt) {
#line 439
      if (! delt) {
#line 440
        return ((_Bool)0);
      } else {
#line 439
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 439
    if (! selt) {
#line 439
      if (delt) {
#line 440
        return ((_Bool)0);
      }
    }
#line 442
    i = 0U;
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 442
      if (! (i < 2U)) {
#line 442
        goto while_break___0;
      }
#line 443
      if (selt->u.words[i] != delt->u.words[i]) {
#line 444
        return ((_Bool)0);
      }
#line 442
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 431
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return ((_Bool)1);
}
}
#line 451 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_copy_(bitset dst , bitset src ) 
{ 
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex j ;
  ebitset_elt *selt ;
  ebitset_elt *tmp ;

  {
#line 458
  if ((unsigned long )src == (unsigned long )dst) {
#line 459
    return;
  }
  {
#line 461
  ebitset_zero(dst);
  }
#line 463
  if (dst->b.n_bits != src->b.n_bits) {
    {
#line 464
    ebitset_resize(dst, src->b.n_bits);
    }
  }
#line 466
  selts = src->e.elts;
#line 467
  delts = dst->e.elts;
#line 468
  j = (bitset_windex )0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 468
      goto while_break;
    }
#line 470
    selt = *(selts + j);
#line 472
    if (selt) {
      {
#line 476
      tmp = ebitset_elt_alloc();
#line 477
      *(delts + j) = tmp;
#line 478
      memcpy((void */* __restrict  */)(tmp->u.words), (void const   */* __restrict  */)(selt->u.words),
             (size_t )sizeof(selt->u.words));
      }
    }
#line 468
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  dst->b.cindex = 4294967295U >> 1;
#line 482
  dst->b.cdata = (bitset_word *)(~ 0);
#line 483
  return;
}
}
#line 488 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static _Bool ebitset_copy_cmp(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 491
  if ((unsigned long )src == (unsigned long )dst) {
#line 492
    return ((_Bool)0);
  }
#line 494
  if ((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 496
    ebitset_copy_(dst, src);
    }
#line 497
    return ((_Bool )(! ((unsigned long )src->b.cdata == (unsigned long )((bitset_word *)0))));
  }
  {
#line 500
  tmp = ebitset_equal_p(dst, src);
  }
#line 500
  if (tmp) {
#line 501
    return ((_Bool)0);
  }
  {
#line 503
  ebitset_copy_(dst, src);
  }
#line 504
  return ((_Bool)1);
}
}
#line 509 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;

  {
  {
#line 512
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 514
  ebitset_elt_find(dst, bitno, (enum ebitset_find_mode )1);
#line 516
  *(dst->b.cdata + (windex - dst->b.cindex)) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  }
#line 518
  return;
}
}
#line 522 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_reset(bitset dst , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  ebitset_elt *tmp ;

  {
  {
#line 525
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 527
  tmp = ebitset_elt_find(dst, bitno, (enum ebitset_find_mode )0);
  }
#line 527
  if (! tmp) {
#line 528
    return;
  }
#line 530
  *(dst->b.cdata + (windex - dst->b.cindex)) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
#line 536
  return;
}
}
#line 540 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_test(bitset src , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  ebitset_elt *tmp ;
  int tmp___0 ;

  {
  {
#line 543
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 545
  tmp = ebitset_elt_find(src, bitno, (enum ebitset_find_mode )0);
  }
#line 545
  if (tmp) {
#line 545
    if ((*(src->b.cdata + (windex - src->b.cindex)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL) {
#line 545
      tmp___0 = 1;
    } else {
#line 545
      tmp___0 = 0;
    }
  } else {
#line 545
    tmp___0 = 0;
  }
#line 545
  return ((_Bool )tmp___0);
}
}
#line 552 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_free(bitset bset ) 
{ 


  {
  {
#line 555
  ebitset_zero(bset);
#line 556
  free((void *)bset->e.elts);
  }
#line 557
  return;
}
}
#line 563 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static bitset_bindex ebitset_list_reverse(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                          bitset_bindex *next ) 
{ 
  bitset_bindex n_bits ;
  bitset_bindex bitno ;
  bitset_bindex rbitno ;
  unsigned int bcount ;
  bitset_bindex boffset ;
  bitset_windex windex ;
  bitset_windex eindex ;
  bitset_windex woffset ;
  bitset_bindex count ;
  bitset_windex size ;
  ebitset_elts *elts ;
  ebitset_elt *elt ;
  bitset_word *srcp ;
  bitset_word word ;
  bitset_bindex tmp ;
  bitset_windex tmp___0 ;
  bitset_windex tmp___1 ;

  {
#line 579
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 580
    return ((bitset_bindex )0);
  }
#line 582
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 583
  n_bits = size * (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 584
  rbitno = *next;
#line 586
  if (rbitno >= n_bits) {
#line 587
    return ((bitset_bindex )0);
  }
#line 589
  elts = bset->e.elts;
#line 591
  bitno = n_bits - (rbitno + 1U);
#line 593
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 594
  eindex = bitno / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 595
  woffset = windex - eindex * 2U;
#line 600
  count = (bitset_bindex )0;
#line 601
  bcount = bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 602
  boffset = windex * (unsigned int )(8UL * sizeof(bitset_word ));
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    elt = *(elts + eindex);
#line 610
    if (elt) {
#line 612
      srcp = elt->u.words;
      {
#line 614
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 618
        word = *(srcp + woffset) << (((unsigned int )(8UL * sizeof(bitset_word )) - 1U) - bcount);
        {
#line 620
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 620
          if (! word) {
#line 620
            goto while_break___1;
          }
#line 622
          if (word & (1UL << ((unsigned int )(8UL * sizeof(bitset_word )) - 1U))) {
#line 624
            tmp = count;
#line 624
            count ++;
#line 624
            *(list + tmp) = boffset + bcount;
#line 625
            if (count >= num) {
#line 627
              *next = n_bits - (boffset + bcount);
#line 628
              return (count);
            }
          }
#line 631
          word <<= 1;
#line 620
          bcount --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 633
        boffset -= (unsigned int )(8UL * sizeof(bitset_word ));
#line 634
        bcount = (unsigned int )(8UL * sizeof(bitset_word )) - 1U;
#line 614
        tmp___0 = woffset;
#line 614
        woffset --;
#line 614
        if (! tmp___0) {
#line 614
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 639
    woffset = (bitset_windex )1;
#line 640
    boffset = eindex * (2U * (unsigned int )(8UL * sizeof(bitset_word ))) - (unsigned int )(8UL * sizeof(bitset_word ));
#line 604
    tmp___1 = eindex;
#line 604
    eindex --;
#line 604
    if (! tmp___1) {
#line 604
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  *next = n_bits - (boffset + 1U);
#line 645
  return (count);
}
}
#line 652 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static bitset_bindex ebitset_list(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                  bitset_bindex *next ) 
{ 
  bitset_bindex bitno ;
  bitset_windex windex ;
  bitset_windex eindex ;
  bitset_bindex count ;
  bitset_windex size ;
  ebitset_elt *elt ;
  bitset_word word ;
  ebitset_elts *elts ;
  bitset_windex woffset ;
  bitset_word *srcp ;
  bitset_bindex tmp ;
  int i ;
  bitset_word *srcp___0 ;
  bitset_bindex tmp___0 ;
  bitset_bindex tmp___1 ;
  bitset_bindex tmp___2 ;

  {
#line 665
  if ((unsigned long )bset->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 666
    return ((bitset_bindex )0);
  }
#line 668
  bitno = *next;
#line 669
  count = (bitset_bindex )0;
#line 671
  elts = bset->e.elts;
#line 672
  size = ((bset->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 673
  eindex = bitno / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 675
  if (bitno % (2U * (unsigned int )(8UL * sizeof(bitset_word )))) {
#line 679
    elt = *(elts + eindex);
#line 680
    if (elt) {
#line 683
      srcp = elt->u.words;
#line 685
      windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 686
      woffset = eindex * 2U;
      {
#line 688
      while (1) {
        while_continue: /* CIL Label */ ;
#line 688
        if (! (windex - woffset < 2U)) {
#line 688
          goto while_break;
        }
#line 690
        word = *(srcp + (windex - woffset)) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ));
        {
#line 692
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 692
          if (! word) {
#line 692
            goto while_break___0;
          }
#line 694
          if (word & 1UL) {
#line 696
            tmp = count;
#line 696
            count ++;
#line 696
            *(list + tmp) = bitno;
#line 697
            if (count >= num) {
#line 699
              *next = bitno + 1U;
#line 700
              return (count);
            }
          }
#line 703
          word >>= 1;
#line 692
          bitno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 705
        bitno = (windex + 1U) * (unsigned int )(8UL * sizeof(bitset_word ));
#line 688
        windex ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 710
    eindex ++;
  }
  {
#line 716
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 716
    if (! (eindex < size)) {
#line 716
      goto while_break___1;
    }
#line 721
    elt = *(elts + eindex);
#line 722
    if (! elt) {
#line 723
      goto __Cont;
    }
#line 725
    srcp___0 = elt->u.words;
#line 726
    windex = eindex * 2U;
#line 728
    if (count + 2U * (unsigned int )(8UL * sizeof(bitset_word )) < num) {
#line 733
      word = *(srcp___0 + 0);
#line 734
      if (word) {
#line 736
        if (! (word & 65535UL)) {
#line 738
          word >>= 16;
#line 739
          bitno += 16U;
        }
#line 741
        if (! (word & 255UL)) {
#line 743
          word >>= 8;
#line 744
          bitno += 8U;
        }
        {
#line 746
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 746
          if (! word) {
#line 746
            goto while_break___2;
          }
#line 748
          if (word & 1UL) {
#line 749
            tmp___0 = count;
#line 749
            count ++;
#line 749
            *(list + tmp___0) = bitno;
          }
#line 750
          word >>= 1;
#line 746
          bitno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 753
      windex ++;
#line 754
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 756
      word = *(srcp___0 + 1);
#line 757
      if (word) {
#line 759
        if (! (word & 65535UL)) {
#line 761
          word >>= 16;
#line 762
          bitno += 16U;
        }
        {
#line 764
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 764
          if (! word) {
#line 764
            goto while_break___3;
          }
#line 766
          if (word & 1UL) {
#line 767
            tmp___1 = count;
#line 767
            count ++;
#line 767
            *(list + tmp___1) = bitno;
          }
#line 768
          word >>= 1;
#line 764
          bitno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 771
      windex ++;
#line 772
      bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
    } else {
#line 806
      i = 0;
      {
#line 806
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 806
        if (! (i < 2)) {
#line 806
          goto while_break___4;
        }
#line 808
        bitno = windex * (unsigned int )(8UL * sizeof(bitset_word ));
#line 810
        word = *(srcp___0 + i);
        {
#line 810
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 810
          if (! word) {
#line 810
            goto while_break___5;
          }
#line 812
          if (word & 1UL) {
#line 814
            tmp___2 = count;
#line 814
            count ++;
#line 814
            *(list + tmp___2) = bitno;
#line 815
            if (count >= num) {
#line 817
              *next = bitno + 1U;
#line 818
              return (count);
            }
          }
#line 821
          word >>= 1;
#line 810
          bitno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 806
        i ++;
#line 806
        windex ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 716
    eindex ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 827
  *next = bitno;
#line 828
  return (count);
}
}
#line 833 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
__inline static void ebitset_unused_clear(bitset dst ) 
{ 
  unsigned int last_bit ;
  bitset_bindex n_bits ;
  bitset_windex eindex ;
  ebitset_elts *elts ;
  ebitset_elt *elt ;
  bitset_windex windex ;
  bitset_windex woffset ;
  bitset_word *srcp ;

  {
#line 839
  n_bits = dst->b.n_bits;
#line 840
  last_bit = n_bits % (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 842
  if (last_bit) {
#line 848
    elts = dst->e.elts;
#line 850
    eindex = n_bits / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 852
    elt = *(elts + eindex);
#line 853
    if (elt) {
#line 857
      srcp = elt->u.words;
#line 859
      windex = n_bits / (unsigned int )(8UL * sizeof(bitset_word ));
#line 860
      woffset = eindex * 2U;
#line 862
      *(srcp + (windex - woffset)) &= (1UL << last_bit) - 1UL;
#line 863
      windex ++;
      {
#line 864
      while (1) {
        while_continue: /* CIL Label */ ;
#line 864
        if (! (windex - woffset < 2U)) {
#line 864
          goto while_break;
        }
#line 865
        *(srcp + (windex - woffset)) = (bitset_word )0;
#line 864
        windex ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 868
  return;
}
}
#line 871 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_ones(bitset dst ) 
{ 
  bitset_windex j ;
  ebitset_elt *elt ;

  {
#line 877
  j = (bitset_windex )0;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! (j < ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 877
      goto while_break;
    }
    {
#line 881
    elt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                           (enum ebitset_find_mode )1);
#line 883
    memset((void *)(elt->u.words), -1, (size_t )sizeof(elt->u.words));
#line 877
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  dst->b.cindex = 4294967295U >> 1;
#line 885
  dst->b.cdata = (bitset_word *)(~ 0);
#line 886
  ebitset_unused_clear(dst);
  }
#line 887
  return;
}
}
#line 890 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_empty_p(bitset dst ) 
{ 
  ebitset_elts *elts ;
  bitset_windex j ;
  ebitset_elt *elt ;
  _Bool tmp ;

  {
#line 896
  if ((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0)) {
#line 897
    return ((_Bool)1);
  }
#line 899
  elts = dst->e.elts;
#line 900
  j = (bitset_windex )0;
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (! (j < ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 900
      goto while_break;
    }
#line 902
    elt = *(elts + j);
#line 904
    if (elt) {
      {
#line 906
      tmp = ebitset_elt_zero_p(elt);
      }
#line 906
      if (! tmp) {
#line 907
        return ((_Bool)0);
      }
      {
#line 909
      ebitset_elt_remove(dst, j);
      }
    }
#line 900
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  dst->b.cindex = 4294967295U >> 1;
#line 915
  dst->b.cdata = (bitset_word *)0;
#line 916
  return ((_Bool)1);
}
}
#line 920 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_not(bitset dst , bitset src ) 
{ 
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;
  bitset_windex j ;

  {
  {
#line 928
  ebitset_resize(dst, src->b.n_bits);
#line 930
  j = (bitset_windex )0;
  }
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (j < ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word ))))) {
#line 930
      goto while_break;
    }
    {
#line 934
    selt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                            (enum ebitset_find_mode )2);
#line 936
    delt = ebitset_elt_find(dst, j * (2U * (unsigned int )(8UL * sizeof(bitset_word ))),
                            (enum ebitset_find_mode )1);
#line 939
    i = 0U;
    }
    {
#line 939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 939
      if (! (i < 2U)) {
#line 939
        goto while_break___0;
      }
#line 940
      delt->u.words[i] = ~ selt->u.words[i];
#line 939
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 930
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 942
  dst->b.cindex = 4294967295U >> 1;
#line 942
  dst->b.cdata = (bitset_word *)(~ 0);
#line 943
  ebitset_unused_clear(dst);
  }
#line 944
  return;
}
}
#line 948 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_subset_p(bitset dst , bitset src ) 
{ 
  bitset_windex j ;
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 957
  selts = src->e.elts;
#line 958
  delts = dst->e.elts;
#line 960
  ssize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 961
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 963
  j = (bitset_windex )0;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    if (! (j < ssize)) {
#line 963
      goto while_break;
    }
#line 969
    if (j < ssize) {
#line 969
      selt = *(selts + j);
    } else {
#line 969
      selt = (ebitset_elt *)0;
    }
#line 970
    if (j < dsize) {
#line 970
      delt = *(delts + j);
    } else {
#line 970
      delt = (ebitset_elt *)0;
    }
#line 972
    if (! selt) {
#line 972
      if (! delt) {
#line 973
        goto __Cont;
      }
    }
#line 975
    if (! selt) {
#line 976
      selt = & ebitset_zero_elts[0];
    }
#line 977
    if (! delt) {
#line 978
      delt = & ebitset_zero_elts[0];
    }
#line 980
    i = 0U;
    {
#line 980
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 980
      if (! (i < 2U)) {
#line 980
        goto while_break___0;
      }
#line 981
      if (delt->u.words[i] != (selt->u.words[i] | delt->u.words[i])) {
#line 983
        return ((_Bool)0);
      }
#line 980
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 963
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 985
  return ((_Bool)1);
}
}
#line 990 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_disjoint_p(bitset dst , bitset src ) 
{ 
  bitset_windex j ;
  ebitset_elts *selts ;
  ebitset_elts *delts ;
  bitset_windex ssize ;
  bitset_windex dsize ;
  unsigned int i ;
  ebitset_elt *selt ;
  ebitset_elt *delt ;

  {
#line 999
  selts = src->e.elts;
#line 1000
  delts = dst->e.elts;
#line 1002
  ssize = ((src->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1003
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1005
  j = (bitset_windex )0;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! (j < ssize)) {
#line 1005
      goto while_break;
    }
#line 1011
    if (j < ssize) {
#line 1011
      selt = *(selts + j);
    } else {
#line 1011
      selt = (ebitset_elt *)0;
    }
#line 1012
    if (j < dsize) {
#line 1012
      delt = *(delts + j);
    } else {
#line 1012
      delt = (ebitset_elt *)0;
    }
#line 1014
    if (! selt) {
#line 1015
      goto __Cont;
    } else
#line 1014
    if (! delt) {
#line 1015
      goto __Cont;
    }
#line 1017
    i = 0U;
    {
#line 1017
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1017
      if (! (i < 2U)) {
#line 1017
        goto while_break___0;
      }
#line 1018
      if (selt->u.words[i] & delt->u.words[i]) {
#line 1019
        return ((_Bool)0);
      }
#line 1017
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1005
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1021
  return ((_Bool)1);
}
}
#line 1026 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_op3_cmp(bitset dst , bitset src1 , bitset src2 , enum bitset_ops op ) 
{ 
  bitset_windex ssize1 ;
  bitset_windex ssize2 ;
  bitset_windex dsize ;
  bitset_windex size ;
  ebitset_elts *selts1 ;
  ebitset_elts *selts2 ;
  ebitset_elts *delts ;
  bitset_word *srcp1 ;
  bitset_word *srcp2 ;
  bitset_word *dstp ;
  _Bool changed ;
  unsigned int i ;
  bitset_windex j ;
  bitset_bindex tmp ;
  ebitset_elt *selt1 ;
  ebitset_elt *selt2 ;
  ebitset_elt *delt ;
  bitset_word tmp___0 ;
  bitset_word *tmp___1 ;
  bitset_word *tmp___2 ;
  bitset_word tmp___3 ;
  bitset_word *tmp___4 ;
  bitset_word *tmp___5 ;
  bitset_word tmp___6 ;
  bitset_word *tmp___7 ;
  bitset_word *tmp___8 ;
  bitset_word tmp___9 ;
  bitset_word *tmp___10 ;
  bitset_word *tmp___11 ;
  _Bool tmp___12 ;
  ebitset_elt *delt___0 ;

  {
#line 1039
  changed = (_Bool)0;
#line 1043
  if (src1->b.n_bits > src2->b.n_bits) {
#line 1043
    tmp = src1->b.n_bits;
  } else {
#line 1043
    tmp = src2->b.n_bits;
  }
  {
#line 1043
  ebitset_resize(dst, tmp);
#line 1045
  ssize1 = ((src1->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1046
  ssize2 = ((src2->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1047
  dsize = ((dst->b.n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
#line 1048
  size = ssize1;
  }
#line 1049
  if (size < ssize2) {
#line 1050
    size = ssize2;
  }
#line 1052
  selts1 = src1->e.elts;
#line 1053
  selts2 = src2->e.elts;
#line 1054
  delts = dst->e.elts;
#line 1056
  j = (bitset_windex )0;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (j < size)) {
#line 1056
      goto while_break;
    }
#line 1062
    if (j < ssize1) {
#line 1062
      selt1 = *(selts1 + j);
    } else {
#line 1062
      selt1 = (ebitset_elt *)0;
    }
#line 1063
    if (j < ssize2) {
#line 1063
      selt2 = *(selts2 + j);
    } else {
#line 1063
      selt2 = (ebitset_elt *)0;
    }
#line 1064
    if (j < dsize) {
#line 1064
      delt = *(delts + j);
    } else {
#line 1064
      delt = (ebitset_elt *)0;
    }
#line 1066
    if (! selt1) {
#line 1066
      if (! selt2) {
#line 1068
        if (delt) {
          {
#line 1070
          changed = (_Bool)1;
#line 1071
          ebitset_elt_remove(dst, j);
          }
        }
#line 1073
        goto __Cont;
      }
    }
#line 1076
    if (! selt1) {
#line 1077
      selt1 = & ebitset_zero_elts[0];
    }
#line 1078
    if (! selt2) {
#line 1079
      selt2 = & ebitset_zero_elts[0];
    }
#line 1080
    if (! delt) {
      {
#line 1081
      delt = ebitset_elt_calloc();
      }
    } else {
#line 1083
      *(delts + j) = (ebitset_elts )0;
    }
#line 1085
    srcp1 = selt1->u.words;
#line 1086
    srcp2 = selt2->u.words;
#line 1087
    dstp = delt->u.words;
    {
#line 1093
    if ((unsigned int )op == 9U) {
#line 1093
      goto case_9;
    }
#line 1106
    if ((unsigned int )op == 8U) {
#line 1106
      goto case_8;
    }
#line 1119
    if ((unsigned int )op == 10U) {
#line 1119
      goto case_10;
    }
#line 1132
    if ((unsigned int )op == 11U) {
#line 1132
      goto case_11;
    }
#line 1090
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1091
    abort();
    }
    case_9: /* CIL Label */ 
#line 1094
    i = 0U;
    {
#line 1094
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1094
      if (! (i < 2U)) {
#line 1094
        goto while_break___0;
      }
#line 1096
      tmp___1 = srcp1;
#line 1096
      srcp1 ++;
#line 1096
      tmp___2 = srcp2;
#line 1096
      srcp2 ++;
#line 1096
      tmp___0 = *tmp___1 | *tmp___2;
#line 1098
      if (*dstp != tmp___0) {
#line 1100
        changed = (_Bool)1;
#line 1101
        *dstp = tmp___0;
      }
#line 1094
      i ++;
#line 1094
      dstp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1104
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1107
    i = 0U;
    {
#line 1107
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1107
      if (! (i < 2U)) {
#line 1107
        goto while_break___1;
      }
#line 1109
      tmp___4 = srcp1;
#line 1109
      srcp1 ++;
#line 1109
      tmp___5 = srcp2;
#line 1109
      srcp2 ++;
#line 1109
      tmp___3 = *tmp___4 & *tmp___5;
#line 1111
      if (*dstp != tmp___3) {
#line 1113
        changed = (_Bool)1;
#line 1114
        *dstp = tmp___3;
      }
#line 1107
      i ++;
#line 1107
      dstp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1117
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1120
    i = 0U;
    {
#line 1120
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1120
      if (! (i < 2U)) {
#line 1120
        goto while_break___2;
      }
#line 1122
      tmp___7 = srcp1;
#line 1122
      srcp1 ++;
#line 1122
      tmp___8 = srcp2;
#line 1122
      srcp2 ++;
#line 1122
      tmp___6 = *tmp___7 ^ *tmp___8;
#line 1124
      if (*dstp != tmp___6) {
#line 1126
        changed = (_Bool)1;
#line 1127
        *dstp = tmp___6;
      }
#line 1120
      i ++;
#line 1120
      dstp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1130
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1133
    i = 0U;
    {
#line 1133
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1133
      if (! (i < 2U)) {
#line 1133
        goto while_break___3;
      }
#line 1135
      tmp___10 = srcp1;
#line 1135
      srcp1 ++;
#line 1135
      tmp___11 = srcp2;
#line 1135
      srcp2 ++;
#line 1135
      tmp___9 = *tmp___10 & ~ *tmp___11;
#line 1137
      if (*dstp != tmp___9) {
#line 1139
        changed = (_Bool)1;
#line 1140
        *dstp = tmp___9;
      }
#line 1133
      i ++;
#line 1133
      dstp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1143
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1146
    tmp___12 = ebitset_elt_zero_p(delt);
    }
#line 1146
    if (tmp___12) {
      {
#line 1152
      ebitset_elt_free(delt);
      }
    } else {
      {
#line 1148
      ebitset_elt_add(dst, delt, j);
      }
    }
    __Cont: /* CIL Label */ 
#line 1056
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1157
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1157
    if (! (j < dsize)) {
#line 1157
      goto while_break___4;
    }
#line 1161
    changed = (_Bool)1;
#line 1163
    delt___0 = *(delts + j);
#line 1165
    if (delt___0) {
      {
#line 1166
      ebitset_elt_remove(dst, j);
      }
    }
#line 1157
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1169
  dst->b.cindex = 4294967295U >> 1;
#line 1169
  dst->b.cdata = (bitset_word *)(~ 0);
#line 1170
  return (changed);
}
}
#line 1174 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool changed ;
  _Bool tmp ;

  {
#line 1179
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1181
    ebitset_weed(dst);
#line 1182
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1183
    ebitset_zero(dst);
    }
#line 1184
    return (changed);
  } else
#line 1186
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1188
    ebitset_weed(dst);
#line 1189
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1190
    ebitset_zero(dst);
    }
#line 1191
    return (changed);
  }
  {
#line 1193
  tmp = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )8);
  }
#line 1193
  return (tmp);
}
}
#line 1197 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_and(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1200
  ebitset_and_cmp(dst, src1, src2);
  }
#line 1201
  return;
}
}
#line 1204 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool changed ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 1209
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1211
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1211
    return (tmp);
  } else
#line 1213
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1215
    ebitset_weed(dst);
#line 1216
    changed = (_Bool )((unsigned long )dst->b.cdata == (unsigned long )((bitset_word *)0));
#line 1217
    ebitset_zero(dst);
    }
#line 1218
    return (changed);
  }
  {
#line 1220
  tmp___0 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )11);
  }
#line 1220
  return (tmp___0);
}
}
#line 1224 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1227
  ebitset_andn_cmp(dst, src1, src2);
  }
#line 1228
  return;
}
}
#line 1231 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1234
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1236
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1236
    return (tmp);
  } else
#line 1238
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1240
    tmp___0 = ebitset_copy_cmp(dst, src2);
    }
#line 1240
    return (tmp___0);
  }
  {
#line 1242
  tmp___1 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )9);
  }
#line 1242
  return (tmp___1);
}
}
#line 1246 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_or(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1249
  ebitset_or_cmp(dst, src1, src2);
  }
#line 1250
  return;
}
}
#line 1253 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static _Bool ebitset_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1256
  if ((unsigned long )src2->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1258
    tmp = ebitset_copy_cmp(dst, src1);
    }
#line 1258
    return (tmp);
  } else
#line 1260
  if ((unsigned long )src1->b.cdata == (unsigned long )((bitset_word *)0)) {
    {
#line 1262
    tmp___0 = ebitset_copy_cmp(dst, src2);
    }
#line 1262
    return (tmp___0);
  }
  {
#line 1264
  tmp___1 = ebitset_op3_cmp(dst, src1, src2, (enum bitset_ops )10);
  }
#line 1264
  return (tmp___1);
}
}
#line 1268 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
  {
#line 1271
  ebitset_xor_cmp(dst, src1, src2);
  }
#line 1272
  return;
}
}
#line 1275 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
static void ebitset_copy(bitset dst , bitset src ) 
{ 


  {
#line 1278
  if ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable) {
    {
#line 1279
    ebitset_copy_(dst, src);
    }
  } else {
    {
#line 1281
    bitset_copy_(dst, src);
    }
  }
#line 1282
  return;
}
}
#line 1286 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
struct bitset_vtable ebitset_vtable  = 
#line 1286
     {& ebitset_set, & ebitset_reset, & bitset_toggle_, & ebitset_test, & ebitset_resize,
    & bitset_size_, & bitset_count_, & ebitset_empty_p, & ebitset_ones, & ebitset_zero,
    & ebitset_copy, & ebitset_disjoint_p, & ebitset_equal_p, & ebitset_not, & ebitset_subset_p,
    & ebitset_and, & ebitset_and_cmp, & ebitset_andn, & ebitset_andn_cmp, & ebitset_or,
    & ebitset_or_cmp, & ebitset_xor, & ebitset_xor_cmp, & bitset_and_or_, & bitset_and_or_cmp_,
    & bitset_andn_or_, & bitset_andn_or_cmp_, & bitset_or_and_, & bitset_or_and_cmp_,
    & ebitset_list, & ebitset_list_reverse, & ebitset_free, (enum bitset_type )2};
#line 1324 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
size_t ebitset_bytes(bitset_bindex n_bits  __attribute__((__unused__)) ) 
{ 


  {
#line 1327
  return ((size_t )sizeof(struct ebitset_struct ));
}
}
#line 1333 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
bitset ebitset_init(bitset bset , bitset_bindex n_bits ) 
{ 
  bitset_windex size ;

  {
#line 1338
  bset->b.vtable = (struct bitset_vtable  const  *)(& ebitset_vtable);
#line 1340
  bset->b.csize = (bitset_windex )2;
#line 1342
  bset->b.cindex = 4294967295U >> 1;
#line 1342
  bset->b.cdata = (bitset_word *)0;
#line 1344
  if (n_bits) {
#line 1344
    size = ((n_bits + 2U * (unsigned int )(8UL * sizeof(bitset_word ))) - 1U) / (2U * (unsigned int )(8UL * sizeof(bitset_word )));
  } else {
#line 1344
    size = (bitset_windex )2;
  }
  {
#line 1347
  bset->e.size = (bitset_windex )0;
#line 1348
  bset->e.elts = (struct ebitset_elt_struct **)0;
#line 1349
  ebitset_resize(bset, n_bits);
  }
#line 1351
  return (bset);
}
}
#line 1355 "/home/pronto/abs/test-suite/bison-2.4/lib/ebitset.c"
void ebitset_release_memory(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 1358
  ebitset_free_list = (ebitset_elt *)0;
#line 1359
  if (ebitset_obstack_init) {
#line 1361
    ebitset_obstack_init = (_Bool)0;
#line 1362
    __o = & ebitset_obstack;
#line 1362
    __obj = (void *)0;
#line 1362
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1362
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1362
        tmp = (char *)__obj;
#line 1362
        __o->object_base = tmp;
#line 1362
        __o->next_free = tmp;
      } else {
        {
#line 1362
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1362
      obstack_free(__o, __obj);
      }
    }
  }
#line 1364
  return;
}
}
#line 207 "/usr/include/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                                              struct stat64 * __restrict  __statbuf ) ;
#line 228
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 235
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 248
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                                               struct stat64 * __restrict  __statbuf ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 326
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 328
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 350
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
#line 354
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 363
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 373
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 373
  return (tmp);
}
}
#line 377
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 377 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 380
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 380
  return (tmp);
}
}
#line 384
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 384 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 387
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 387
  return (tmp);
}
}
#line 394
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                                              struct stat64 * __restrict  __statbuf ) ;
#line 394 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 397
  tmp = __xstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 397
  return (tmp);
}
}
#line 401
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                                               struct stat64 * __restrict  __statbuf ) ;
#line 401 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 404
  tmp = __lxstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 404
  return (tmp);
}
}
#line 408
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 408 "/usr/include/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 411
  tmp = __fxstat64(3, __fd, __statbuf);
  }
#line 411
  return (tmp);
}
}
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 34 "/home/pronto/abs/test-suite/bison-2.4/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = fcntl(fd, 0, 3);
  }
#line 38
  return (tmp);
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.4/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 64
size_t dir_len(char const   *file ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/lib/dirname.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0U) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1U)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.4/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0U) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = xmalloc((length + (size_t )append_dot) + 1U);
#line 78
  dir = (char *)tmp___1;
#line 79
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 80
  if (append_dot) {
#line 81
    tmp___2 = length;
#line 81
    length ++;
#line 81
    *(dir + tmp___2) = (char )'.';
  }
#line 82
  *(dir + length) = (char )'\000';
#line 83
  return (dir);
}
}
#line 49 "/home/pronto/abs/test-suite/bison-2.4/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0U) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0U) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 44 "/home/pronto/abs/test-suite/bison-2.4/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 123 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/pronto/abs/test-suite/bison-2.4/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 99 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
size_t bitset_bytes(enum bitset_type type , bitset_bindex n_bits ) ;
#line 102
bitset bitset_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) ;
#line 106
enum bitset_type bitset_type_choose(bitset_bindex n_bits  __attribute__((__unused__)) ,
                                    unsigned int attr ) ;
#line 133 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
__inline static void bitset_set(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;

  {
#line 136
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 137
  offset = windex - bset->b.cindex;
#line 139
  if (offset < bset->b.csize) {
#line 140
    *(bset->b.cdata + offset) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
  } else {
    {
#line 142
    (*((bset->b.vtable)->set))(bset, bitno);
    }
  }
#line 143
  return;
}
}
#line 161 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
__inline static _Bool bitset_test(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;
  _Bool tmp ;

  {
#line 164
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 165
  offset = windex - bset->b.cindex;
#line 167
  if (offset < bset->b.csize) {
#line 168
    return ((_Bool )((*(bset->b.cdata + offset) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL));
  } else {
    {
#line 170
    tmp = (*((bset->b.vtable)->test))(bset, bitno);
    }
#line 170
    return (tmp);
  }
}
}
#line 299
void bitset_dump(FILE *file , bitset bset ) ;
#line 386
void debug_bitset(bitset bset ) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.h"
bitset *bitsetv_alloc(bitset_bindex n_vecs , bitset_bindex n_bits , enum bitset_type type ) ;
#line 31
bitset *bitsetv_create(bitset_bindex n_vecs , bitset_bindex n_bits , unsigned int attr ) ;
#line 34
void bitsetv_free(bitsetv bsetv ) ;
#line 37
void bitsetv_zero(bitsetv bsetv ) ;
#line 40
void bitsetv_ones(bitsetv bsetv ) ;
#line 44
void bitsetv_transitive_closure(bitsetv bsetv ) ;
#line 50
void bitsetv_reflexive_transitive_closure(bitsetv bsetv ) ;
#line 53
void bitsetv_dump(FILE *file , char const   *title , char const   *subtitle , bitsetv bsetv ) ;
#line 56
void debug_bitsetv(bitsetv bsetv ) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
bitset *bitsetv_alloc(bitset_bindex n_vecs , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t vector_bytes ;
  size_t bytes ;
  bitset *bsetv ;
  bitset_bindex i ;
  void *tmp ;

  {
  {
#line 36
  bytes = bitset_bytes(type, n_bits);
  }
#line 39
  if (4294967295UL / (sizeof(bitset ) + (unsigned long )bytes) <= (unsigned long )n_vecs) {
    {
#line 40
    xalloc_die();
    }
  }
  {
#line 43
  vector_bytes = (size_t )(((unsigned long )(n_vecs + 1U) * sizeof(bitset ) + (unsigned long )bytes) - 1UL);
#line 44
  vector_bytes -= vector_bytes % bytes;
#line 45
  tmp = xcalloc((size_t )1, vector_bytes + bytes * n_vecs);
#line 45
  bsetv = (bitset *)tmp;
#line 47
  i = (bitset_bindex )0;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < n_vecs)) {
#line 47
      goto while_break;
    }
    {
#line 49
    *(bsetv + i) = (bitset )((void *)(((char *)bsetv + vector_bytes) + i * bytes));
#line 51
    bitset_init(*(bsetv + i), n_bits, type);
#line 47
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  *(bsetv + i) = (bitset )0;
#line 56
  return (bsetv);
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
bitset *bitsetv_create(bitset_bindex n_vecs , bitset_bindex n_bits , unsigned int attr ) 
{ 
  enum bitset_type type ;
  bitset *tmp ;

  {
  {
#line 67
  type = bitset_type_choose(n_bits, attr);
#line 68
  tmp = bitsetv_alloc(n_vecs, n_bits, type);
  }
#line 68
  return (tmp);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_free(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 78
  i = (bitset_bindex )0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! *(bsetv + i)) {
#line 78
      goto while_break;
    }
#line 79
    if (((*(bsetv + i))->b.vtable)->free) {
      {
#line 79
      (*(((*(bsetv + i))->b.vtable)->free))(*(bsetv + i));
      }
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  free((void *)bsetv);
  }
#line 81
  return;
}
}
#line 85 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_zero(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 90
  i = (bitset_bindex )0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! *(bsetv + i)) {
#line 90
      goto while_break;
    }
    {
#line 91
    (*(((*(bsetv + i))->b.vtable)->zero))(*(bsetv + i));
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_ones(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
#line 101
  i = (bitset_bindex )0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! *(bsetv + i)) {
#line 101
      goto while_break;
    }
    {
#line 102
    (*(((*(bsetv + i))->b.vtable)->ones))(*(bsetv + i));
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_transitive_closure(bitsetv bsetv ) 
{ 
  bitset_bindex i ;
  bitset_bindex j ;
  _Bool tmp ;

  {
#line 114
  i = (bitset_bindex )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! *(bsetv + i)) {
#line 114
      goto while_break;
    }
#line 115
    j = (bitset_bindex )0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! *(bsetv + j)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      tmp = bitset_test(*(bsetv + j), i);
      }
#line 116
      if (tmp) {
        {
#line 117
        (*(((*(bsetv + j))->b.vtable)->or_))(*(bsetv + j), *(bsetv + j), *(bsetv + i));
        }
      }
#line 115
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 125 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_reflexive_transitive_closure(bitsetv bsetv ) 
{ 
  bitset_bindex i ;

  {
  {
#line 130
  bitsetv_transitive_closure(bsetv);
#line 131
  i = (bitset_bindex )0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! *(bsetv + i)) {
#line 131
      goto while_break;
    }
    {
#line 132
    bitset_set(*(bsetv + i), i);
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void bitsetv_dump(FILE *file , char const   *title , char const   *subtitle , bitsetv bsetv ) 
{ 
  bitset_windex i ;

  {
  {
#line 144
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s\n",
          title);
#line 145
  i = (bitset_windex )0;
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! *(bsetv + i)) {
#line 145
      goto while_break;
    }
    {
#line 147
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s %lu\n",
            subtitle, (unsigned long )i);
#line 148
    bitset_dump(file, *(bsetv + i));
#line 145
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
  }
#line 152
  return;
}
}
#line 155 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv.c"
void debug_bitsetv(bitsetv bsetv ) 
{ 
  bitset_windex i ;

  {
#line 160
  i = (bitset_windex )0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! *(bsetv + i)) {
#line 160
      goto while_break;
    }
    {
#line 162
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lu: ",
            (unsigned long )i);
#line 163
    debug_bitset(*(bsetv + i));
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 167
  return;
}
}
#line 24 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv-print.h"
void bitsetv_matrix_dump(FILE *out , char const   *title , bitsetv bset ) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/lib/bitsetv-print.c"
void bitsetv_matrix_dump(FILE *out , char const   *title , bitsetv bset ) 
{ 
  bitset_bindex i ;
  bitset_bindex j ;
  bitset_bindex hsize ;
  bitset_bindex tmp ;
  bitset_bindex tmp___0 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 31
  tmp = (*(((*(bset + 0))->b.vtable)->size))(*(bset + 0));
#line 31
  hsize = tmp;
#line 34
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s BEGIN\n",
          title);
#line 37
  fputs_unlocked((char const   */* __restrict  */)"   ", (FILE */* __restrict  */)out);
#line 38
  i = (bitset_bindex )0;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (i < hsize)) {
#line 38
      goto while_break;
    }
#line 39
    if (i / 10U) {
#line 39
      tmp___0 = 48U + i / 10U;
    } else {
#line 39
      tmp___0 = (bitset_bindex )' ';
    }
    {
#line 39
    putc_unlocked((int )tmp___0, out);
#line 38
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  putc_unlocked('\n', out);
#line 41
  fputs_unlocked((char const   */* __restrict  */)"   ", (FILE */* __restrict  */)out);
#line 42
  i = (bitset_bindex )0;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (i < hsize)) {
#line 42
      goto while_break___0;
    }
    {
#line 43
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%d", (int )(i % 10U));
#line 42
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 44
  putc_unlocked('\n', out);
#line 47
  fputs_unlocked((char const   */* __restrict  */)"  .", (FILE */* __restrict  */)out);
#line 48
  i = (bitset_bindex )0;
  }
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! (i < hsize)) {
#line 48
      goto while_break___1;
    }
    {
#line 49
    putc_unlocked('-', out);
#line 48
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 50
  fputs_unlocked((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)out);
#line 53
  i = (bitset_bindex )0;
  }
  {
#line 53
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 53
    if (! *(bset + i)) {
#line 53
      goto while_break___2;
    }
    {
#line 55
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%2lu|",
            (unsigned long )i);
#line 56
    j = (bitset_bindex )0;
    }
    {
#line 56
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 56
      if (! (j < hsize)) {
#line 56
        goto while_break___3;
      }
      {
#line 57
      tmp___3 = bitset_test(*(bset + i), j);
      }
#line 57
      if (tmp___3) {
#line 57
        tmp___2 = "1";
      } else {
#line 57
        tmp___2 = " ";
      }
      {
#line 57
      fputs_unlocked((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)out);
#line 56
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 58
    fputs_unlocked((char const   */* __restrict  */)"|\n", (FILE */* __restrict  */)out);
#line 53
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 62
  fputs_unlocked((char const   */* __restrict  */)"  `", (FILE */* __restrict  */)out);
#line 63
  i = (bitset_bindex )0;
  }
  {
#line 63
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 63
    if (! (i < hsize)) {
#line 63
      goto while_break___4;
    }
    {
#line 64
    putc_unlocked('-', out);
#line 63
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 65
  fputs_unlocked((char const   */* __restrict  */)"\'\n", (FILE */* __restrict  */)out);
#line 68
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s END\n\n",
          title);
  }
#line 69
  return;
}
}
#line 45 "/home/pronto/abs/test-suite/bison-2.4/lib/bbitset.h"
char const   * const  bitset_type_names[4] ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.h"
_Bool bitset_stats_enabled ;
#line 25
enum bitset_type bitset_stats_type_get(bitset bset ) ;
#line 27
size_t bitset_stats_bytes(void) ;
#line 29
bitset bitset_stats_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) ;
#line 631 "/usr/include/stdio.h"
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 633
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 731
extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 740
extern void perror(char const   *__s ) ;
#line 371 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
void bitset_stats_enable(void) ;
#line 374
void bitset_stats_disable(void) ;
#line 377
void bitset_stats_read(char const   *file_name ) ;
#line 380
void bitset_stats_write(char const   *file_name ) ;
#line 383
void bitset_stats_dump(FILE *file ) ;
#line 389
void debug_bitset_stats(void) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/abitset.h"
extern size_t abitset_bytes(bitset_bindex  ) ;
#line 25
extern bitset abitset_init(bitset  , bitset_bindex  ) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/lib/lbitset.h"
extern size_t lbitset_bytes(bitset_bindex  ) ;
#line 25
extern bitset lbitset_init(bitset  , bitset_bindex  ) ;
#line 98 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
struct bitset_stats_info_struct bitset_stats_info_data  ;
#line 99 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
struct bitset_stats_info_struct *bitset_stats_info  ;
#line 100 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
_Bool bitset_stats_enabled  =    (_Bool)0;
#line 104 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_percent_histogram_print(FILE *file , char const   *name , char const   *msg ,
                                           unsigned int n_bins , unsigned int *bins ) 
{ 
  unsigned int i ;
  unsigned int total ;

  {
#line 111
  total = 0U;
#line 112
  i = 0U;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < n_bins)) {
#line 112
      goto while_break;
    }
#line 113
    total += *(bins + i);
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (! total) {
#line 116
    return;
  }
  {
#line 118
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s %s",
          name, msg);
#line 119
  i = 0U;
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (i < n_bins)) {
#line 119
      goto while_break___0;
    }
    {
#line 120
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%.0f-%.0f%%\t%8u (%5.1f%%)\n",
            ((double )i * 100.0) / (double )n_bins, ((double )(i + 1U) * 100.0) / (double )n_bins,
            *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 119
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_log_histogram_print(FILE *file , char const   *name , char const   *msg ,
                                       unsigned int n_bins , unsigned int *bins ) 
{ 
  unsigned int i ;
  unsigned int total ;
  unsigned int max_width ;

  {
#line 136
  total = 0U;
#line 137
  i = 0U;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < n_bins)) {
#line 137
      goto while_break;
    }
#line 138
    total += *(bins + i);
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (! total) {
#line 141
    return;
  }
#line 144
  i = n_bins;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (i > 3U) {
#line 144
      if (! (! *(bins + (i - 1U)))) {
#line 144
        goto while_break___0;
      }
    } else {
#line 144
      goto while_break___0;
    }
#line 145
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 144
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 146
  n_bins = i;
#line 149
  max_width = 2U * (unsigned int )(0.30103 * (double )(n_bins - 1U) + 0.9999) + 1U;
#line 151
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s %s",
          name, msg);
#line 152
  i = 0U;
  }
  {
#line 152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 152
    if (! (i < 2U)) {
#line 152
      goto while_break___1;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%*d\t%8u (%5.1f%%)\n",
            max_width, i, *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 152
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 156
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 156
    if (! (i < n_bins)) {
#line 156
      goto while_break___2;
    }
    {
#line 157
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%*lu-%lu\t%8u (%5.1f%%)\n",
            max_width - ((unsigned int )(0.30103 * (double )i + 0.9999) + 1U), 1UL << (i - 1U),
            (1UL << i) - 1UL, *(bins + i), (100.0 * (double )*(bins + i)) / (double )total);
#line 156
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 167 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_print_1(FILE *file , char const   *name , struct bitset_type_info_struct *stats ) 
{ 
  double tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 171
  if (! stats) {
#line 172
    return;
  }
  {
#line 174
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s:\n",
          name);
  }
#line 175
  if (stats->allocs) {
#line 175
    tmp = (100.0 * (double )stats->frees) / (double )stats->allocs;
  } else {
#line 175
    tmp = (double )0;
  }
  {
#line 175
  tmp___0 = gettext("%u bitset_allocs, %u freed (%.2f%%).\n");
#line 175
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___0,
          stats->allocs, stats->frees, tmp);
  }
#line 178
  if (stats->sets) {
#line 178
    tmp___1 = (100.0 * (double )stats->cache_sets) / (double )stats->sets;
  } else {
#line 178
    tmp___1 = (double )0;
  }
  {
#line 178
  tmp___2 = gettext("%u bitset_sets, %u cached (%.2f%%)\n");
#line 178
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___2,
          stats->sets, stats->cache_sets, tmp___1);
  }
#line 181
  if (stats->resets) {
#line 181
    tmp___3 = (100.0 * (double )stats->cache_resets) / (double )stats->resets;
  } else {
#line 181
    tmp___3 = (double )0;
  }
  {
#line 181
  tmp___4 = gettext("%u bitset_resets, %u cached (%.2f%%)\n");
#line 181
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___4,
          stats->resets, stats->cache_resets, tmp___3);
  }
#line 184
  if (stats->tests) {
#line 184
    tmp___5 = (100.0 * (double )stats->cache_tests) / (double )stats->tests;
  } else {
#line 184
    tmp___5 = (double )0;
  }
  {
#line 184
  tmp___6 = gettext("%u bitset_tests, %u cached (%.2f%%)\n");
#line 184
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___6,
          stats->tests, stats->cache_tests, tmp___5);
#line 188
  tmp___7 = gettext("%u bitset_lists\n");
#line 188
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___7,
          stats->lists);
#line 190
  tmp___8 = gettext("count log histogram\n");
#line 190
  bitset_log_histogram_print(file, name, (char const   *)tmp___8, 10U, stats->list_counts);
#line 193
  tmp___9 = gettext("size log histogram\n");
#line 193
  bitset_log_histogram_print(file, name, (char const   *)tmp___9, 16U, stats->list_sizes);
#line 196
  tmp___10 = gettext("density histogram\n");
#line 196
  bitset_percent_histogram_print(file, name, (char const   *)tmp___10, 20U, stats->list_density);
  }
#line 198
  return;
}
}
#line 202 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_print(FILE *file , _Bool verbose  __attribute__((__unused__)) ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 207
  if (! bitset_stats_info) {
#line 208
    return;
  }
  {
#line 210
  tmp = gettext("Bitset statistics:\n\n");
#line 210
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp);
  }
#line 212
  if (bitset_stats_info->runs > 1U) {
    {
#line 213
    tmp___0 = gettext("Accumulated runs = %u\n");
#line 213
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp___0,
            bitset_stats_info->runs);
    }
  }
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 4)) {
#line 215
      goto while_break;
    }
    {
#line 216
    bitset_stats_print_1(file, (char const   *)bitset_type_names[i], & bitset_stats_info->types[i]);
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 222 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void bitset_stats_enable(void) 
{ 


  {
#line 225
  if (! bitset_stats_info) {
#line 226
    bitset_stats_info = & bitset_stats_info_data;
  }
#line 227
  bitset_stats_enabled = (_Bool)1;
#line 228
  return;
}
}
#line 231 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void bitset_stats_disable(void) 
{ 


  {
#line 234
  bitset_stats_enabled = (_Bool)0;
#line 235
  return;
}
}
#line 239 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void bitset_stats_read(char const   *file_name ) 
{ 
  FILE *file ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 244
  if (! bitset_stats_info) {
#line 245
    return;
  }
#line 247
  if (! file_name) {
#line 248
    file_name = "bitset.dat";
  }
  {
#line 250
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
  }
#line 251
  if (file) {
    {
#line 253
    tmp___2 = fread_unlocked((void */* __restrict  */)(& bitset_stats_info_data),
                             (size_t )sizeof(bitset_stats_info_data), (size_t )1,
                             (FILE */* __restrict  */)file);
    }
#line 253
    if (tmp___2 != 1U) {
      {
#line 256
      tmp___1 = ferror_unlocked(file);
      }
#line 256
      if (tmp___1) {
        {
#line 257
        tmp = gettext("Could not read stats file.");
#line 257
        perror((char const   *)tmp);
        }
      } else {
        {
#line 259
        tmp___0 = gettext("Bad stats file size.\n");
#line 259
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
        }
      }
    }
    {
#line 261
    tmp___4 = fclose(file);
    }
#line 261
    if (tmp___4 != 0) {
      {
#line 262
      tmp___3 = gettext("Could not read stats file.");
#line 262
      perror((char const   *)tmp___3);
      }
    }
  }
#line 264
  (bitset_stats_info_data.runs) ++;
#line 265
  return;
}
}
#line 269 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void bitset_stats_write(char const   *file_name ) 
{ 
  FILE *file ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 274
  if (! bitset_stats_info) {
#line 275
    return;
  }
#line 277
  if (! file_name) {
#line 278
    file_name = "bitset.dat";
  }
  {
#line 280
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"w");
  }
#line 281
  if (file) {
    {
#line 283
    tmp___0 = fwrite_unlocked((void const   */* __restrict  */)(& bitset_stats_info_data),
                              (size_t )sizeof(bitset_stats_info_data), (size_t )1,
                              (FILE */* __restrict  */)file);
    }
#line 283
    if (tmp___0 != 1U) {
      {
#line 285
      tmp = gettext("Could not write stats file.");
#line 285
      perror((char const   *)tmp);
      }
    }
    {
#line 286
    tmp___2 = fclose(file);
    }
#line 286
    if (tmp___2 != 0) {
      {
#line 287
      tmp___1 = gettext("Could not write stats file.");
#line 287
      perror((char const   *)tmp___1);
      }
    }
  } else {
    {
#line 290
    tmp___3 = gettext("Could not open stats file for writing.");
#line 290
    perror((char const   *)tmp___3);
    }
  }
#line 291
  return;
}
}
#line 295 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void bitset_stats_dump(FILE *file ) 
{ 


  {
  {
#line 298
  bitset_stats_print(file, (_Bool)0);
  }
#line 299
  return;
}
}
#line 303 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
void debug_bitset_stats(void) 
{ 


  {
  {
#line 306
  bitset_stats_print(stderr, (_Bool)1);
  }
#line 307
  return;
}
}
#line 310 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_set(bitset dst , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;

  {
#line 313
  bset = dst->s.bset;
#line 314
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 315
  offset = wordno - bset->b.cindex;
#line 317
  (bitset_stats_info->types[(bset->b.vtable)->type].sets) ++;
#line 319
  if (offset < bset->b.csize) {
#line 321
    *(bset->b.cdata + offset) |= 1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word ));
#line 322
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_sets) ++;
  } else {
    {
#line 325
    (*((bset->b.vtable)->set))(bset, bitno);
    }
  }
#line 326
  return;
}
}
#line 329 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_reset(bitset dst , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;

  {
#line 332
  bset = dst->s.bset;
#line 333
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 334
  offset = wordno - bset->b.cindex;
#line 336
  (bitset_stats_info->types[(bset->b.vtable)->type].resets) ++;
#line 338
  if (offset < bset->b.csize) {
#line 340
    *(bset->b.cdata + offset) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
#line 342
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_resets) ++;
  } else {
    {
#line 345
    (*((bset->b.vtable)->reset))(bset, bitno);
    }
  }
#line 346
  return;
}
}
#line 349 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_toggle(bitset src , bitset_bindex bitno ) 
{ 
  _Bool tmp ;

  {
  {
#line 352
  tmp = (*(((src->s.bset)->b.vtable)->toggle))(src->s.bset, bitno);
  }
#line 352
  return (tmp);
}
}
#line 356 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_test(bitset src , bitset_bindex bitno ) 
{ 
  bitset bset ;
  bitset_windex wordno ;
  bitset_windex offset ;
  _Bool tmp ;

  {
#line 359
  bset = src->s.bset;
#line 360
  wordno = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 361
  offset = wordno - bset->b.cindex;
#line 363
  (bitset_stats_info->types[(bset->b.vtable)->type].tests) ++;
#line 365
  if (offset < bset->b.csize) {
#line 367
    (bitset_stats_info->types[(bset->b.vtable)->type].cache_tests) ++;
#line 368
    return ((_Bool )((*(bset->b.cdata + offset) >> bitno % (unsigned int )(8UL * sizeof(bitset_word ))) & 1UL));
  } else {
    {
#line 371
    tmp = (*((bset->b.vtable)->test))(bset, bitno);
    }
#line 371
    return (tmp);
  }
}
}
#line 375 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static bitset_bindex bitset_stats_resize(bitset src , bitset_bindex size ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 378
  tmp = (*(((src->s.bset)->b.vtable)->resize))(src->s.bset, size);
  }
#line 378
  return (tmp);
}
}
#line 382 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static bitset_bindex bitset_stats_size(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 385
  tmp = (*(((src->s.bset)->b.vtable)->size))(src->s.bset);
  }
#line 385
  return (tmp);
}
}
#line 389 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static bitset_bindex bitset_stats_count(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 392
  tmp = (*(((src->s.bset)->b.vtable)->count))(src->s.bset);
  }
#line 392
  return (tmp);
}
}
#line 396 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_empty_p(bitset dst ) 
{ 
  _Bool tmp ;

  {
  {
#line 399
  tmp = (*(((dst->s.bset)->b.vtable)->empty_p))(dst->s.bset);
  }
#line 399
  return (tmp);
}
}
#line 403 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_ones(bitset dst ) 
{ 


  {
  {
#line 406
  (*(((dst->s.bset)->b.vtable)->ones))(dst->s.bset);
  }
#line 407
  return;
}
}
#line 410 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_zero(bitset dst ) 
{ 


  {
  {
#line 413
  (*(((dst->s.bset)->b.vtable)->zero))(dst->s.bset);
  }
#line 414
  return;
}
}
#line 417 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_copy(bitset dst , bitset src ) 
{ 


  {
#line 420
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 420
    abort();
    }
  }
  {
#line 421
  (*(((src->s.bset)->b.vtable)->copy))(dst->s.bset, src->s.bset);
  }
#line 422
  return;
}
}
#line 425 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_disjoint_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 428
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 428
    abort();
    }
  }
  {
#line 429
  tmp = (*(((src->s.bset)->b.vtable)->disjoint_p))(dst->s.bset, src->s.bset);
  }
#line 429
  return (tmp);
}
}
#line 433 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_equal_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 436
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 436
    abort();
    }
  }
  {
#line 437
  tmp = (*(((src->s.bset)->b.vtable)->equal_p))(dst->s.bset, src->s.bset);
  }
#line 437
  return (tmp);
}
}
#line 441 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_not(bitset dst , bitset src ) 
{ 


  {
#line 444
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 444
    abort();
    }
  }
  {
#line 445
  (*(((src->s.bset)->b.vtable)->not_))(dst->s.bset, src->s.bset);
  }
#line 446
  return;
}
}
#line 449 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_subset_p(bitset dst , bitset src ) 
{ 
  _Bool tmp ;

  {
#line 452
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src->b.vtable)) {
    {
#line 452
    abort();
    }
  }
  {
#line 453
  tmp = (*(((src->s.bset)->b.vtable)->subset_p))(dst->s.bset, src->s.bset);
  }
#line 453
  return (tmp);
}
}
#line 457 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_and(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 460
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 460
    abort();
    }
  } else
#line 460
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 460
    abort();
    }
  }
  {
#line 461
  (*(((src1->s.bset)->b.vtable)->and_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 462
  return;
}
}
#line 465 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_and_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 468
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 468
    abort();
    }
  } else
#line 468
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 468
    abort();
    }
  }
  {
#line 469
  tmp = (*(((src1->s.bset)->b.vtable)->and_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 469
  return (tmp);
}
}
#line 473 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_andn(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 476
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 476
    abort();
    }
  } else
#line 476
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 476
    abort();
    }
  }
  {
#line 477
  (*(((src1->s.bset)->b.vtable)->andn))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 478
  return;
}
}
#line 481 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_andn_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 484
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 484
    abort();
    }
  } else
#line 484
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 484
    abort();
    }
  }
  {
#line 485
  tmp = (*(((src1->s.bset)->b.vtable)->andn_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 485
  return (tmp);
}
}
#line 489 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_or(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 492
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 492
    abort();
    }
  } else
#line 492
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 492
    abort();
    }
  }
  {
#line 493
  (*(((src1->s.bset)->b.vtable)->or_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 494
  return;
}
}
#line 497 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_or_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 500
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 500
    abort();
    }
  } else
#line 500
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 500
    abort();
    }
  }
  {
#line 501
  tmp = (*(((src1->s.bset)->b.vtable)->or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 501
  return (tmp);
}
}
#line 505 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_xor(bitset dst , bitset src1 , bitset src2 ) 
{ 


  {
#line 508
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 508
    abort();
    }
  } else
#line 508
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 508
    abort();
    }
  }
  {
#line 509
  (*(((src1->s.bset)->b.vtable)->xor_))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 510
  return;
}
}
#line 513 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_xor_cmp(bitset dst , bitset src1 , bitset src2 ) 
{ 
  _Bool tmp ;

  {
#line 516
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 516
    abort();
    }
  } else
#line 516
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 516
    abort();
    }
  }
  {
#line 517
  tmp = (*(((src1->s.bset)->b.vtable)->xor_cmp))(dst->s.bset, src1->s.bset, src2->s.bset);
  }
#line 517
  return (tmp);
}
}
#line 521 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_and_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 524
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 524
    abort();
    }
  } else
#line 524
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 524
    abort();
    }
  } else
#line 524
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 524
    abort();
    }
  }
  {
#line 525
  (*(((src1->s.bset)->b.vtable)->and_or))(dst->s.bset, src1->s.bset, src2->s.bset,
                                          src3->s.bset);
  }
#line 526
  return;
}
}
#line 529 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_and_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 532
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 532
    abort();
    }
  } else
#line 532
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 532
    abort();
    }
  } else
#line 532
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 532
    abort();
    }
  }
  {
#line 533
  tmp = (*(((src1->s.bset)->b.vtable)->and_or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                    src3->s.bset);
  }
#line 533
  return (tmp);
}
}
#line 537 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_andn_or(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 540
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 540
    abort();
    }
  } else
#line 540
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 540
    abort();
    }
  } else
#line 540
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 540
    abort();
    }
  }
  {
#line 541
  (*(((src1->s.bset)->b.vtable)->andn_or))(dst->s.bset, src1->s.bset, src2->s.bset,
                                           src3->s.bset);
  }
#line 542
  return;
}
}
#line 545 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_andn_or_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 548
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 548
    abort();
    }
  } else
#line 548
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 548
    abort();
    }
  } else
#line 548
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 548
    abort();
    }
  }
  {
#line 549
  tmp = (*(((src1->s.bset)->b.vtable)->andn_or_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                     src3->s.bset);
  }
#line 549
  return (tmp);
}
}
#line 553 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_or_and(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
#line 556
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 556
    abort();
    }
  } else
#line 556
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 556
    abort();
    }
  } else
#line 556
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 556
    abort();
    }
  }
  {
#line 557
  (*(((src1->s.bset)->b.vtable)->or_and))(dst->s.bset, src1->s.bset, src2->s.bset,
                                          src3->s.bset);
  }
#line 558
  return;
}
}
#line 561 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static _Bool bitset_stats_or_and_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
#line 564
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src1->b.vtable)) {
    {
#line 564
    abort();
    }
  } else
#line 564
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src2->b.vtable)) {
    {
#line 564
    abort();
    }
  } else
#line 564
  if (! ((unsigned long )dst->b.vtable == (unsigned long )src3->b.vtable)) {
    {
#line 564
    abort();
    }
  }
  {
#line 565
  tmp = (*(((src1->s.bset)->b.vtable)->or_and_cmp))(dst->s.bset, src1->s.bset, src2->s.bset,
                                                    src3->s.bset);
  }
#line 565
  return (tmp);
}
}
#line 569 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static bitset_bindex bitset_stats_list(bitset bset , bitset_bindex *list , bitset_bindex num ,
                                       bitset_bindex *next ) 
{ 
  bitset_bindex count ;
  bitset_bindex tmp ;
  bitset_bindex size ;
  bitset_bindex i ;
  enum bitset_type type ;

  {
  {
#line 579
  count = (*(((bset->s.bset)->b.vtable)->list))(bset->s.bset, list, num, next);
#line 581
  type = (enum bitset_type )((bset->s.bset)->b.vtable)->type;
#line 582
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].lists) ++;
#line 585
  i = (bitset_bindex )0;
#line 585
  tmp = count;
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! tmp) {
#line 585
      goto while_break;
    }
#line 586
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 585
    tmp >>= 1;
#line 585
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  if (i >= 10U) {
#line 588
    i = (bitset_bindex )9;
  }
  {
#line 589
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_counts[i]) ++;
#line 592
  size = (*(((bset->s.bset)->b.vtable)->size))(bset->s.bset);
#line 593
  i = (bitset_bindex )0;
#line 593
  tmp = size;
  }
  {
#line 593
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 593
    if (! tmp) {
#line 593
      goto while_break___0;
    }
#line 594
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 593
    tmp >>= 1;
#line 593
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 595
  if (i >= 16U) {
#line 596
    i = (bitset_bindex )15;
  }
#line 597
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_sizes[i]) ++;
#line 600
  if (size) {
#line 600
    i = (count * 20U) / size;
  } else {
#line 600
    i = (bitset_bindex )0;
  }
#line 601
  if (i >= 20U) {
#line 602
    i = (bitset_bindex )19;
  }
#line 603
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].list_density[i]) ++;
#line 604
  return (count);
}
}
#line 608 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static bitset_bindex bitset_stats_list_reverse(bitset bset , bitset_bindex *list ,
                                               bitset_bindex num , bitset_bindex *next ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 612
  tmp = (*(((bset->s.bset)->b.vtable)->list_reverse))(bset->s.bset, list, num, next);
  }
#line 612
  return (tmp);
}
}
#line 616 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
static void bitset_stats_free(bitset bset ) 
{ 


  {
#line 619
  (bitset_stats_info->types[((bset->s.bset)->b.vtable)->type].frees) ++;
#line 620
  if (((bset->s.bset)->b.vtable)->free) {
    {
#line 620
    (*(((bset->s.bset)->b.vtable)->free))(bset->s.bset);
    }
  }
#line 621
  return;
}
}
#line 624 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
struct bitset_vtable bitset_stats_vtable  = 
#line 624
     {& bitset_stats_set, & bitset_stats_reset, & bitset_stats_toggle, & bitset_stats_test,
    & bitset_stats_resize, & bitset_stats_size, & bitset_stats_count, & bitset_stats_empty_p,
    & bitset_stats_ones, & bitset_stats_zero, & bitset_stats_copy, & bitset_stats_disjoint_p,
    & bitset_stats_equal_p, & bitset_stats_not, & bitset_stats_subset_p, & bitset_stats_and,
    & bitset_stats_and_cmp, & bitset_stats_andn, & bitset_stats_andn_cmp, & bitset_stats_or,
    & bitset_stats_or_cmp, & bitset_stats_xor, & bitset_stats_xor_cmp, & bitset_stats_and_or,
    & bitset_stats_and_or_cmp, & bitset_stats_andn_or, & bitset_stats_andn_or_cmp,
    & bitset_stats_or_and, & bitset_stats_or_and_cmp, & bitset_stats_list, & bitset_stats_list_reverse,
    & bitset_stats_free, (enum bitset_type )5};
#line 662 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
enum bitset_type bitset_stats_type_get(bitset bset ) 
{ 


  {
#line 665
  return ((enum bitset_type )((bset->s.bset)->b.vtable)->type);
}
}
#line 669 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
size_t bitset_stats_bytes(void) 
{ 


  {
#line 672
  return ((size_t )sizeof(struct bitset_stats_struct ));
}
}
#line 676 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset_stats.c"
bitset bitset_stats_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset sbset ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 682
  bset->b.vtable = (struct bitset_vtable  const  *)(& bitset_stats_vtable);
#line 685
  bset->b.cindex = (bitset_windex )0;
#line 686
  bset->b.csize = (bitset_windex )0;
#line 687
  bset->b.cdata = (bitset_word *)0;
#line 689
  bset->b.n_bits = n_bits;
  {
#line 698
  if ((unsigned int )type == 0U) {
#line 698
    goto case_0;
  }
#line 704
  if ((unsigned int )type == 1U) {
#line 704
    goto case_1;
  }
#line 710
  if ((unsigned int )type == 2U) {
#line 710
    goto case_2;
  }
#line 716
  if ((unsigned int )type == 3U) {
#line 716
    goto case_3;
  }
#line 695
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 696
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 699
  bytes = abitset_bytes(n_bits);
#line 700
  tmp = xcalloc((size_t )1, bytes);
#line 700
  sbset = (bitset )tmp;
#line 701
  abitset_init(sbset, n_bits);
  }
#line 702
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 705
  bytes = lbitset_bytes(n_bits);
#line 706
  tmp___0 = xcalloc((size_t )1, bytes);
#line 706
  sbset = (bitset )tmp___0;
#line 707
  lbitset_init(sbset, n_bits);
  }
#line 708
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 711
  bytes = ebitset_bytes(n_bits);
#line 712
  tmp___1 = xcalloc((size_t )1, bytes);
#line 712
  sbset = (bitset )tmp___1;
#line 713
  ebitset_init(sbset, n_bits);
  }
#line 714
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 717
  bytes = vbitset_bytes(n_bits);
#line 718
  tmp___2 = xcalloc((size_t )1, bytes);
#line 718
  sbset = (bitset )tmp___2;
#line 719
  vbitset_init(sbset, n_bits);
  }
#line 720
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 723
  bset->s.bset = sbset;
#line 725
  (bitset_stats_info->types[type].allocs) ++;
#line 727
  return (bset);
}
}
#line 109 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
bitset bitset_alloc(bitset_bindex n_bits , enum bitset_type type ) ;
#line 112
void bitset_free(bitset bset ) ;
#line 116
bitset bitset_obstack_alloc(struct obstack *bobstack , bitset_bindex n_bits , enum bitset_type type ) ;
#line 120
void bitset_obstack_free(bitset bset ) ;
#line 123
bitset bitset_create(bitset_bindex n_bits , unsigned int attr ) ;
#line 126
enum bitset_type bitset_type_get(bitset bset ) ;
#line 129
char const   *bitset_type_name_get(bitset bset ) ;
#line 147 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.h"
__inline static void bitset_reset(bitset bset , bitset_bindex bitno ) 
{ 
  bitset_windex windex ;
  bitset_windex offset ;

  {
#line 150
  windex = bitno / (unsigned int )(8UL * sizeof(bitset_word ));
#line 151
  offset = windex - bset->b.cindex;
#line 153
  if (offset < bset->b.csize) {
#line 154
    *(bset->b.cdata + offset) &= ~ (1UL << bitno % (unsigned int )(8UL * sizeof(bitset_word )));
  } else {
    {
#line 156
    (*((bset->b.vtable)->reset))(bset, bitno);
    }
  }
#line 157
  return;
}
}
#line 281
extern _Bool bitset_compatible_p(bitset bset1 , bitset bset2 ) ;
#line 284
bitset_bindex bitset_next(bitset src , bitset_bindex bitno ) ;
#line 287
bitset_bindex bitset_prev(bitset src , bitset_bindex bitno ) ;
#line 290
bitset_bindex bitset_first(bitset src ) ;
#line 293
bitset_bindex bitset_last(bitset src ) ;
#line 296
_Bool bitset_only_set_p(bitset src , bitset_bindex bitno ) ;
#line 368
void bitset_release_memory(void) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/lib/lbitset.h"
extern void lbitset_release_memory(void) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
char const   * const  bitset_type_names[4]  = {      (char const   */* const  */)"abitset",      (char const   */* const  */)"lbitset",      (char const   */* const  */)"ebitset",      (char const   */* const  */)"vbitset"};
#line 36 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
size_t bitset_bytes(enum bitset_type type , bitset_bindex n_bits ) 
{ 
  size_t bytes ;
  size_t tmp ;

  {
#line 41
  if (bitset_stats_enabled) {
    {
#line 42
    tmp = bitset_stats_bytes();
    }
#line 42
    return (tmp);
  }
  {
#line 49
  if ((unsigned int )type == 0U) {
#line 49
    goto case_0;
  }
#line 53
  if ((unsigned int )type == 1U) {
#line 53
    goto case_1;
  }
#line 57
  if ((unsigned int )type == 2U) {
#line 57
    goto case_2;
  }
#line 61
  if ((unsigned int )type == 3U) {
#line 61
    goto case_3;
  }
#line 46
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 47
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 50
  bytes = abitset_bytes(n_bits);
  }
#line 51
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 54
  bytes = lbitset_bytes(n_bits);
  }
#line 55
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 58
  bytes = ebitset_bytes(n_bits);
  }
#line 59
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 62
  bytes = vbitset_bytes(n_bits);
  }
#line 63
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return (bytes);
}
}
#line 71 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset bitset_init(bitset bset , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  bitset tmp ;
  bitset tmp___0 ;
  bitset tmp___1 ;
  bitset tmp___2 ;
  bitset tmp___3 ;

  {
#line 74
  if (bitset_stats_enabled) {
    {
#line 75
    tmp = bitset_stats_init(bset, n_bits, type);
    }
#line 75
    return (tmp);
  }
  {
#line 82
  if ((unsigned int )type == 0U) {
#line 82
    goto case_0;
  }
#line 85
  if ((unsigned int )type == 1U) {
#line 85
    goto case_1;
  }
#line 88
  if ((unsigned int )type == 2U) {
#line 88
    goto case_2;
  }
#line 91
  if ((unsigned int )type == 3U) {
#line 91
    goto case_3;
  }
#line 79
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 80
  abort();
  }
  case_0: /* CIL Label */ 
  {
#line 83
  tmp___0 = abitset_init(bset, n_bits);
  }
#line 83
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 86
  tmp___1 = lbitset_init(bset, n_bits);
  }
#line 86
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 89
  tmp___2 = ebitset_init(bset, n_bits);
  }
#line 89
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 92
  tmp___3 = vbitset_init(bset, n_bits);
  }
#line 92
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
enum bitset_type bitset_type_choose(bitset_bindex n_bits  __attribute__((__unused__)) ,
                                    unsigned int attr ) 
{ 


  {
#line 104
  if (attr & 1U) {
#line 104
    if (attr & 2U) {
      {
#line 105
      abort();
      }
    }
  }
#line 106
  if (attr & 8U) {
#line 106
    if (attr & 4U) {
      {
#line 107
      abort();
      }
    }
  }
#line 114
  if (! attr) {
#line 115
    return ((enum bitset_type )3);
  }
#line 117
  if (attr & 8U) {
#line 118
    return ((enum bitset_type )1);
  }
#line 120
  if (attr & 1U) {
#line 121
    return ((enum bitset_type )0);
  }
#line 123
  if (attr & 32U) {
#line 124
    return ((enum bitset_type )2);
  }
#line 126
  return ((enum bitset_type )3);
}
}
#line 131 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset bitset_alloc(bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset bset ;
  void *tmp ;
  bitset tmp___0 ;

  {
  {
#line 137
  bytes = bitset_bytes(type, n_bits);
#line 139
  tmp = xcalloc((size_t )1, bytes);
#line 139
  bset = (bitset )tmp;
#line 145
  tmp___0 = bitset_init(bset, n_bits, type);
  }
#line 145
  return (tmp___0);
}
}
#line 150 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset bitset_obstack_alloc(struct obstack *bobstack , bitset_bindex n_bits , enum bitset_type type ) 
{ 
  size_t bytes ;
  bitset bset ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  bitset tmp___1 ;

  {
  {
#line 157
  bytes = bitset_bytes(type, n_bits);
#line 159
  __h = bobstack;
#line 159
  __o = __h;
#line 159
  __len = (int )bytes;
  }
#line 159
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 159
    _obstack_newchunk(__o, __len);
    }
  }
#line 159
  __o->next_free += __len;
#line 159
  __o1 = __h;
#line 159
  __value = (void *)__o1->object_base;
#line 159
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 159
    __o1->maybe_empty_object = 1U;
  }
#line 159
  if (sizeof(int ) < sizeof(void *)) {
#line 159
    tmp = __o1->object_base;
  } else {
#line 159
    tmp = (char *)0;
  }
#line 159
  if (sizeof(int ) < sizeof(void *)) {
#line 159
    tmp___0 = __o1->object_base;
  } else {
#line 159
    tmp___0 = (char *)0;
  }
#line 159
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 159
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 159
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 159
  __o1->object_base = __o1->next_free;
#line 159
  bset = (bitset )__value;
#line 160
  memset((void *)bset, 0, bytes);
#line 162
  tmp___1 = bitset_init(bset, n_bits, type);
  }
#line 162
  return (tmp___1);
}
}
#line 168 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset bitset_create(bitset_bindex n_bits , unsigned int attr ) 
{ 
  enum bitset_type type ;
  bitset tmp ;

  {
  {
#line 173
  type = bitset_type_choose(n_bits, attr);
#line 175
  tmp = bitset_alloc(n_bits, type);
  }
#line 175
  return (tmp);
}
}
#line 180 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_free(bitset bset ) 
{ 


  {
#line 183
  if ((bset->b.vtable)->free) {
    {
#line 183
    (*((bset->b.vtable)->free))(bset);
    }
  }
  {
#line 184
  free((void *)bset);
  }
#line 185
  return;
}
}
#line 189 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_obstack_free(bitset bset ) 
{ 


  {
#line 192
  if ((bset->b.vtable)->free) {
    {
#line 192
    (*((bset->b.vtable)->free))(bset);
    }
  }
#line 193
  return;
}
}
#line 197 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
enum bitset_type bitset_type_get(bitset bset ) 
{ 
  enum bitset_type type ;
  enum bitset_type tmp ;

  {
#line 202
  type = (enum bitset_type )(bset->b.vtable)->type;
#line 203
  if ((unsigned int )type != 5U) {
#line 204
    return (type);
  }
  {
#line 206
  tmp = bitset_stats_type_get(bset);
  }
#line 206
  return (tmp);
}
}
#line 211 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
char const   *bitset_type_name_get(bitset bset ) 
{ 
  enum bitset_type type ;

  {
  {
#line 216
  type = bitset_type_get(bset);
  }
#line 218
  return ((char const   *)bitset_type_names[type]);
}
}
#line 224 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_next(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val ;
  bitset_bindex next ;
  bitset_bindex tmp ;

  {
  {
#line 228
  next = bitno;
#line 230
  tmp = (*((src->b.vtable)->list))(src, & val, (bitset_bindex )1, & next);
  }
#line 230
  if (! tmp) {
#line 231
    return ((bitset_bindex )-1);
  }
#line 232
  return (val);
}
}
#line 237 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
extern _Bool bitset_compatible_p(bitset bset1 , bitset bset2 ) 
{ 


  {
#line 240
  return ((_Bool )((unsigned long )bset1->b.vtable == (unsigned long )bset2->b.vtable));
}
}
#line 246 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_prev(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val ;
  bitset_bindex next ;
  bitset_bindex tmp ;

  {
  {
#line 250
  next = bitno;
#line 252
  tmp = (*((src->b.vtable)->list_reverse))(src, & val, (bitset_bindex )1, & next);
  }
#line 252
  if (! tmp) {
#line 253
    return ((bitset_bindex )-1);
  }
#line 254
  return (val);
}
}
#line 259 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_first(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 262
  tmp = bitset_next(src, (bitset_bindex )0);
  }
#line 262
  return (tmp);
}
}
#line 267 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_last(bitset src ) 
{ 
  bitset_bindex tmp ;

  {
  {
#line 270
  tmp = bitset_prev(src, (bitset_bindex )0);
  }
#line 270
  return (tmp);
}
}
#line 275 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_only_set_p(bitset src , bitset_bindex bitno ) 
{ 
  bitset_bindex val[2] ;
  bitset_bindex next ;
  bitset_bindex tmp ;

  {
  {
#line 279
  next = (bitset_bindex )0;
#line 281
  tmp = (*((src->b.vtable)->list))(src, val, (bitset_bindex )2, & next);
  }
#line 281
  if (tmp != 1U) {
#line 282
    return ((_Bool)0);
  }
#line 283
  return ((_Bool )(val[0] == bitno));
}
}
#line 288 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
static void bitset_print(FILE *file , bitset bset , _Bool verbose ) 
{ 
  unsigned int pos ;
  bitset_bindex i ;
  bitset_iterator iter ;
  bitset_bindex tmp ;

  {
#line 295
  if (verbose) {
    {
#line 296
    tmp = (*((bset->b.vtable)->size))(bset);
#line 296
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"n_bits = %lu, set = {",
            (unsigned long )tmp);
    }
  }
#line 299
  pos = 30U;
#line 300
  iter.next = (bitset_bindex )0;
#line 300
  iter.num = (bitset_bindex )1024;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (iter.num == 1024U) {
      {
#line 300
      iter.num = (*((bset->b.vtable)->list))(bset, iter.list, (bitset_bindex )1024,
                                             & iter.next);
      }
#line 300
      if (! iter.num) {
#line 300
        goto while_break;
      }
    } else {
#line 300
      goto while_break;
    }
#line 300
    iter.i = (bitset_bindex )0;
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      if (iter.i < iter.num) {
#line 300
        i = iter.list[iter.i];
      } else {
#line 300
        goto while_break___0;
      }
#line 302
      if (pos > 70U) {
        {
#line 304
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
#line 305
        pos = 0U;
        }
      }
      {
#line 308
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%lu ",
              (unsigned long )i);
#line 309
      pos += (unsigned int )((1 + (i >= 10U)) + (i >= 100U));
#line 300
      (iter.i) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  if (verbose) {
    {
#line 313
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"}\n");
    }
  }
#line 314
  return;
}
}
#line 318 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_dump(FILE *file , bitset bset ) 
{ 


  {
  {
#line 321
  bitset_print(file, bset, (_Bool)0);
  }
#line 322
  return;
}
}
#line 326 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_release_memory(void) 
{ 


  {
  {
#line 329
  lbitset_release_memory();
#line 330
  ebitset_release_memory();
  }
#line 331
  return;
}
}
#line 335 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_toggle_(bitset bset , bitset_bindex bitno ) 
{ 
  _Bool tmp ;

  {
  {
#line 340
  tmp = bitset_test(bset, bitno);
  }
#line 340
  if (tmp) {
    {
#line 342
    bitset_reset(bset, bitno);
    }
#line 343
    return ((_Bool)0);
  } else {
    {
#line 347
    bitset_set(bset, bitno);
    }
#line 348
    return ((_Bool)1);
  }
}
}
#line 354 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_size_(bitset src ) 
{ 


  {
#line 357
  return (src->b.n_bits);
}
}
#line 362 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
bitset_bindex bitset_count_(bitset src ) 
{ 
  bitset_bindex list[1024] ;
  bitset_bindex next ;
  bitset_bindex num ;
  bitset_bindex count ;

  {
#line 374
  next = (bitset_bindex )0;
#line 375
  count = (bitset_bindex )0;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 375
    num = (*((src->b.vtable)->list))(src, list, (bitset_bindex )1024, & next);
    }
#line 375
    if (! num) {
#line 375
      goto while_break;
    }
#line 377
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 375
    count += num;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (count);
}
}
#line 386 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_copy_(bitset dst , bitset src ) 
{ 
  bitset_bindex i ;
  bitset_iterator iter ;

  {
  {
#line 394
  (*((dst->b.vtable)->zero))(dst);
#line 395
  iter.next = (bitset_bindex )0;
#line 395
  iter.num = (bitset_bindex )1024;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (iter.num == 1024U) {
      {
#line 395
      iter.num = (*((src->b.vtable)->list))(src, iter.list, (bitset_bindex )1024,
                                            & iter.next);
      }
#line 395
      if (! iter.num) {
#line 395
        goto while_break;
      }
    } else {
#line 395
      goto while_break;
    }
#line 395
    iter.i = (bitset_bindex )0;
    {
#line 395
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 395
      if (iter.i < iter.num) {
#line 395
        i = iter.list[iter.i];
      } else {
#line 395
        goto while_break___0;
      }
      {
#line 397
      bitset_set(dst, i);
#line 395
      (iter.i) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((_Bool)1);
}
}
#line 406 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
__inline static _Bool bitset_op4_cmp(bitset dst , bitset src1 , bitset src2 , bitset src3 ,
                                     enum bitset_ops op ) 
{ 
  _Bool changed ;
  _Bool stats_enabled_save ;
  bitset tmp ;
  enum bitset_type tmp___0 ;

  {
  {
#line 410
  changed = (_Bool)0;
#line 415
  stats_enabled_save = bitset_stats_enabled;
#line 416
  bitset_stats_enabled = (_Bool)0;
#line 417
  tmp___0 = bitset_type_get(dst);
#line 417
  tmp = bitset_alloc((bitset_bindex )0, tmp___0);
#line 418
  bitset_stats_enabled = stats_enabled_save;
  }
  {
#line 425
  if ((unsigned int )op == 12U) {
#line 425
    goto case_12;
  }
#line 430
  if ((unsigned int )op == 13U) {
#line 430
    goto case_13;
  }
#line 435
  if ((unsigned int )op == 14U) {
#line 435
    goto case_14;
  }
#line 422
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 423
  abort();
  }
  case_12: /* CIL Label */ 
  {
#line 426
  (*((src1->b.vtable)->or_))(tmp, src1, src2);
#line 427
  changed = (*((src3->b.vtable)->and_cmp))(dst, src3, tmp);
  }
#line 428
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 431
  (*((src1->b.vtable)->and_))(tmp, src1, src2);
#line 432
  changed = (*((src3->b.vtable)->or_cmp))(dst, src3, tmp);
  }
#line 433
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 436
  (*((src1->b.vtable)->andn))(tmp, src1, src2);
#line 437
  changed = (*((src3->b.vtable)->or_cmp))(dst, src3, tmp);
  }
#line 438
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 441
  bitset_free(tmp);
  }
#line 442
  return (changed);
}
}
#line 447 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_and_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 450
  bitset_and_or_cmp_(dst, src1, src2, src3);
  }
#line 451
  return;
}
}
#line 456 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_and_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 459
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )13);
  }
#line 459
  return (tmp);
}
}
#line 464 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_andn_or_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 467
  bitset_andn_or_cmp_(dst, src1, src2, src3);
  }
#line 468
  return;
}
}
#line 473 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_andn_or_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 476
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )14);
  }
#line 476
  return (tmp);
}
}
#line 481 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void bitset_or_and_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 


  {
  {
#line 484
  bitset_or_and_cmp_(dst, src1, src2, src3);
  }
#line 485
  return;
}
}
#line 490 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
_Bool bitset_or_and_cmp_(bitset dst , bitset src1 , bitset src2 , bitset src3 ) 
{ 
  _Bool tmp ;

  {
  {
#line 493
  tmp = bitset_op4_cmp(dst, src1, src2, src3, (enum bitset_ops )12);
  }
#line 493
  return (tmp);
}
}
#line 498 "/home/pronto/abs/test-suite/bison-2.4/lib/bitset.c"
void debug_bitset(bitset bset ) 
{ 


  {
#line 501
  if (bset) {
    {
#line 502
    bitset_print(stderr, bset, (_Bool)1);
    }
  }
#line 503
  return;
}
}
#line 61 "/home/pronto/abs/test-suite/bison-2.4/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/lib/basename.c"
char *last_component(char const   *name ) 
{ 
  char const   *base___0 ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 34
  base___0 = name + 0;
#line 36
  saw_slash = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((int const   )*base___0 == 47)) {
#line 38
      goto while_break;
    }
#line 39
    base___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  p = base___0;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! *p) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int const   )*p == 47) {
#line 44
      saw_slash = (_Bool)1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base___0 = p;
#line 48
      saw_slash = (_Bool)0;
    }
#line 41
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  return ((char *)base___0);
}
}
#line 73 "/home/pronto/abs/test-suite/bison-2.4/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base___0 ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 76
  tmp = last_component(name);
#line 76
  base___0 = (char const   *)tmp;
  }
#line 81
  if (! *base___0) {
    {
#line 82
    tmp___0 = base_len(name);
#line 82
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 82
    return (tmp___1);
  }
  {
#line 85
  length = base_len(base___0);
  }
#line 86
  if ((int const   )*(base___0 + length) == 47) {
#line 87
    length ++;
  }
  {
#line 103
  tmp___3 = xstrndup(base___0, length);
  }
#line 103
  return (tmp___3);
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.4/lib/basename.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 114
  prefix_len = (size_t )0;
#line 116
  len = strlen(name);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (1U < len) {
#line 116
      if (! ((int const   )*(name + (len - 1U)) == 47)) {
#line 116
        goto while_break;
      }
    } else {
#line 116
      goto while_break;
    }
#line 117
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 116
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (len);
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 52
void (*argmatch_die)(void) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 640 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 60 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  exit((int )exit_failure);
  }
}
}
#line 68 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = -1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return (-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0U) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
              *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___0) {
        {
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
                *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", `%s\'",
                *(arglist + i));
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  putc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return (-1);
}
}
#line 195 "/home/pronto/abs/test-suite/bison-2.4/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 3 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.h"
void start_graph(FILE *fout ) ;
#line 4
void output_node(int id , char const   *label , FILE *fout ) ;
#line 5
void output_edge(int source , int destination , char const   *label , char const   *style ,
                 FILE *fout ) ;
#line 7
void finish_graph(FILE *fout ) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.c"
static char const   *quote___0(char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 35
  tmp = quotearg_n_style(2, (enum quoting_style )3, name);
  }
#line 35
  return ((char const   *)tmp);
}
}
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.c"
void start_graph(FILE *fout ) 
{ 


  {
  {
#line 41
  fputs_unlocked((char const   */* __restrict  */)"digraph Automaton {\n", (FILE */* __restrict  */)fout);
  }
#line 42
  return;
}
}
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.c"
void output_node(int id , char const   *label , FILE *fout ) 
{ 
  char const   *tmp ;

  {
  {
#line 47
  tmp = quote___0(label);
#line 47
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"  %d [label=%s]\n",
          id, tmp);
  }
#line 48
  return;
}
}
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.c"
void output_edge(int source , int destination , char const   *label , char const   *style ,
                 FILE *fout ) 
{ 
  char const   *tmp ;

  {
  {
#line 54
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"  %d -> %d [style=%s",
          source, destination, style);
  }
#line 55
  if (label) {
    {
#line 56
    tmp = quote___0(label);
#line 56
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" label=%s",
            tmp);
    }
  }
  {
#line 57
  fputs_unlocked((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)fout);
  }
#line 58
  return;
}
}
#line 60 "/home/pronto/abs/test-suite/bison-2.4/src/graphviz.c"
void finish_graph(FILE *fout ) 
{ 


  {
  {
#line 63
  fputs_unlocked((char const   */* __restrict  */)"}\n", (FILE */* __restrict  */)fout);
  }
#line 64
  return;
}
}
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.h"
uniqstr uniqstr_new(char const   *str ) ;
#line 40
void uniqstrs_new(void) ;
#line 43
void uniqstr_assert(char const   *str ) ;
#line 46
void uniqstrs_free(void) ;
#line 49
void uniqstrs_print(void) ;
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
static struct hash_table *uniqstrs_table  =    (struct hash_table *)((void *)0);
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
uniqstr uniqstr_new(char const   *str ) 
{ 
  uniqstr res ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 45
  tmp = hash_lookup((Hash_table const   *)uniqstrs_table, (void const   *)str);
#line 45
  res = (uniqstr )tmp;
  }
#line 46
  if (! res) {
    {
#line 49
    tmp___0 = xstrdup(str);
#line 49
    res = (uniqstr )tmp___0;
#line 50
    hash_insert(uniqstrs_table, (void const   *)res);
    }
  }
#line 52
  return (res);
}
}
#line 60 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
void uniqstr_assert(char const   *str ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 63
  tmp___0 = hash_lookup((Hash_table const   *)uniqstrs_table, (void const   *)str);
  }
#line 63
  if (! tmp___0) {
    {
#line 65
    tmp = quotearg(str);
#line 65
    error(0, 0, "not a uniqstr: %s", tmp);
#line 67
    abort();
    }
  }
#line 69
  return;
}
}
#line 76 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
__inline static _Bool uniqstr_print(uniqstr ustr ) 
{ 


  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          ustr);
  }
#line 80
  return ((_Bool)1);
}
}
#line 83 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
static _Bool uniqstr_print_processor(void *ustr , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 86
  tmp = uniqstr_print((uniqstr )ustr);
  }
#line 86
  return (tmp);
}
}
#line 94 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
static _Bool hash_compare_uniqstr(void const   *m1 , void const   *m2 ) 
{ 
  int tmp ;

  {
  {
#line 97
  tmp = strcmp((char const   *)m1, (char const   *)m2);
  }
#line 97
  return ((_Bool )(tmp == 0));
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
static size_t hash_uniqstr(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 103
  tmp = hash_string((char const   *)m, tablesize);
  }
#line 103
  return (tmp);
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
void uniqstrs_new(void) 
{ 


  {
  {
#line 113
  uniqstrs_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                   & hash_uniqstr, & hash_compare_uniqstr, & free);
  }
#line 118
  return;
}
}
#line 125 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
static void uniqstrs_do(_Bool (*processor)(void * , void * ) , void *processor_data ) 
{ 


  {
  {
#line 128
  hash_do_for_each((Hash_table const   *)uniqstrs_table, processor, processor_data);
  }
#line 129
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
void uniqstrs_print(void) 
{ 


  {
  {
#line 139
  uniqstrs_do(& uniqstr_print_processor, (void *)0);
  }
#line 140
  return;
}
}
#line 147 "/home/pronto/abs/test-suite/bison-2.4/src/uniqstr.c"
void uniqstrs_free(void) 
{ 


  {
  {
#line 150
  hash_free(uniqstrs_table);
  }
#line 151
  return;
}
}
#line 329 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 131 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 134
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 134
    tmp = -1;
  } else {
#line 134
    tmp = -2;
  }
#line 134
  if ((size_t )tmp / s < n) {
    {
#line 135
    xalloc_die();
    }
  }
  {
#line 136
  tmp___0 = xrealloc(p, n * s);
  }
#line 136
  return (tmp___0);
}
}
#line 128 "/home/pronto/abs/test-suite/bison-2.4/src/system.h"
__inline static void aver(_Bool assertion ) 
{ 


  {
#line 131
  if (! assertion) {
    {
#line 132
    abort();
    }
  }
#line 133
  return;
}
}
#line 31 "/home/pronto/abs/test-suite/bison-2.4/src/complain.h"
void ( /* format attribute */  warn_at)(location loc___0 , char const   *message 
                                        , ...) ;
#line 39
void ( /* format attribute */  complain_at)(location loc___0 , char const   *message 
                                            , ...) ;
#line 44
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *message 
                                                                     , ...) ;
#line 47
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal_at)(location loc___0 ,
                                                                        char const   *message 
                                                                        , ...) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/src/assoc.h"
char const   *assoc_to_string(assoc a ) ;
#line 75 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
void code_props_none_init(code_props *self ) ;
#line 82
struct code_props  const  code_props_none ;
#line 109 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
void symbol_print(symbol *s , FILE *f ) ;
#line 112
symbol *symbol_from_uniqstr(uniqstr const   key , location loc___0 ) ;
#line 115
symbol *symbol_get(char const   *key , location loc___0 ) ;
#line 120
symbol *dummy_symbol_get(location loc___0 ) ;
#line 123
_Bool symbol_is_dummy(symbol const   *sym ) ;
#line 126
void symbol_make_alias(symbol *sym , symbol *symval , location loc___0 ) ;
#line 131
void symbol_type_set(symbol *sym , uniqstr type_name , location loc___0 ) ;
#line 134
char const   *symbol_class_get_string(symbol *sym ) ;
#line 137
void symbol_destructor_set(symbol *sym , code_props const   *destructor ) ;
#line 141
code_props const   *symbol_destructor_get(symbol const   *sym ) ;
#line 144
void symbol_printer_set(symbol *sym , code_props const   *printer ) ;
#line 148
code_props const   *symbol_printer_get(symbol const   *sym ) ;
#line 154
void symbol_precedence_set(symbol *sym , int prec , assoc a , location loc___0 ) ;
#line 157
void symbol_class_set(symbol *sym , symbol_class class , location loc___0 , _Bool declaring ) ;
#line 161
void symbol_user_token_number_set(symbol *sym , int user_token_number , location loc___0 ) ;
#line 165
symbol *errtoken ;
#line 167
symbol *undeftoken ;
#line 169
symbol *endtoken ;
#line 173
symbol *accept ;
#line 176
symbol *startsymbol ;
#line 178 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.h"
location startsymbol_location  ;
#line 200
semantic_type *semantic_type_from_uniqstr(uniqstr const   key ) ;
#line 203
semantic_type *semantic_type_get(char const   *key ) ;
#line 206
void semantic_type_destructor_set(semantic_type *type , code_props const   *destructor ) ;
#line 210
void semantic_type_printer_set(semantic_type *type , code_props const   *printer ) ;
#line 218
void symbols_new(void) ;
#line 221
void symbols_free(void) ;
#line 226
void symbols_check_defined(void) ;
#line 232
void symbols_pack(void) ;
#line 240
void default_tagged_destructor_set(code_props const   *destructor ) ;
#line 242
void default_tagless_destructor_set(code_props const   *destructor ) ;
#line 245
void default_tagged_printer_set(code_props const   *printer ) ;
#line 247
void default_tagless_printer_set(code_props const   *printer ) ;
#line 111 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
int nsyms ;
#line 112
int ntokens ;
#line 113
int nvars ;
#line 238
symbol **symbols ;
#line 243
symbol_number *token_translations ;
#line 244
int max_user_token_number ;
#line 35 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *errtoken  =    (symbol *)((void *)0);
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *undeftoken  =    (symbol *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *endtoken  =    (symbol *)((void *)0);
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *accept  =    (symbol *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *startsymbol  =    (symbol *)((void *)0);
#line 46 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static code_props default_tagged_destructor  =    {(enum __anonenum_kind_36 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0)};
#line 47 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static code_props default_tagless_destructor  =    {(enum __anonenum_kind_36 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0)};
#line 48 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static code_props default_tagged_printer  =    {(enum __anonenum_kind_36 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0)};
#line 49 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static code_props default_tagless_printer  =    {(enum __anonenum_kind_36 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0)};
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static symbol *symbol_new(uniqstr tag , location loc___0 ) 
{ 
  symbol *res ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 58
  tmp = xmalloc((size_t )sizeof(*res));
#line 58
  res = (symbol *)tmp;
#line 60
  uniqstr_assert(tag);
#line 61
  res->tag = tag;
#line 62
  res->location = loc___0;
#line 64
  res->type_name = (uniqstr )((void *)0);
#line 65
  code_props_none_init(& res->destructor);
#line 66
  code_props_none_init(& res->printer);
#line 68
  res->number = -1;
#line 69
  res->prec = 0;
#line 70
  res->assoc = (assoc )0;
#line 71
  res->user_token_number = -1;
#line 73
  res->alias = (symbol *)((void *)0);
#line 74
  res->class = (symbol_class )0;
#line 75
  res->declared = (_Bool)0;
  }
#line 77
  if (nsyms == 2147483647) {
    {
#line 78
    tmp___0 = gettext("too many symbols in input grammar (limit is %d)");
#line 78
    fatal((char const   *)tmp___0, 2147483647);
    }
  }
#line 80
  nsyms ++;
#line 81
  return (res);
}
}
#line 88 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static semantic_type *semantic_type_new(uniqstr tag ) 
{ 
  semantic_type *res ;
  void *tmp ;

  {
  {
#line 91
  tmp = xmalloc((size_t )sizeof(*res));
#line 91
  res = (semantic_type *)tmp;
#line 93
  uniqstr_assert(tag);
#line 94
  res->tag = tag;
#line 95
  code_props_none_init(& res->destructor);
#line 96
  code_props_none_init(& res->printer);
  }
#line 98
  return (res);
}
}
#line 114 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_print(symbol *s , FILE *f ) 
{ 


  {
#line 117
  if (s) {
    {
#line 119
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\"%s\"",
            s->tag);
    }
#line 120
    if (s->type_name) {
      {
#line 120
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s { %s }",
              "type_name", s->type_name);
      }
    }
#line 121
    if (s->destructor.code) {
      {
#line 121
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s { %s }",
              "destructor", s->destructor.code);
      }
    }
#line 122
    if (s->printer.code) {
      {
#line 122
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s { %s }",
              "printer", s->printer.code);
      }
    }
  } else {
    {
#line 125
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"<NULL>");
    }
  }
#line 126
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static void symbol_redeclaration(symbol *s , char const   *what , location first ,
                                 location second ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 140
  tmp = gettext("%s redeclaration for %s");
#line 140
  complain_at(second, (char const   *)tmp, what, s->tag);
#line 141
  tmp___0 = gettext("previous declaration");
#line 141
  complain_at(first, (char const   *)tmp___0);
  }
#line 142
  return;
}
}
#line 144 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static void semantic_type_redeclaration(semantic_type *s , char const   *what , location first ,
                                        location second ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 148
  tmp = gettext("%s redeclaration for <%s>");
#line 148
  complain_at(second, (char const   *)tmp, what, s->tag);
#line 149
  tmp___0 = gettext("previous declaration");
#line 149
  complain_at(first, (char const   *)tmp___0);
  }
#line 150
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_type_set(symbol *sym , uniqstr type_name , location loc___0 ) 
{ 


  {
#line 161
  if (type_name) {
#line 163
    if (sym->type_name) {
      {
#line 164
      symbol_redeclaration(sym, "%type", sym->type_location, loc___0);
      }
    }
    {
#line 165
    uniqstr_assert(type_name);
#line 166
    sym->type_name = type_name;
#line 167
    sym->type_location = loc___0;
    }
  }
#line 169
  return;
}
}
#line 175 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
char const   *symbol_class_get_string(symbol *sym ) 
{ 


  {
#line 178
  if (sym->class) {
#line 180
    if ((unsigned int )sym->class == 1U) {
#line 181
      return ("terminal");
    } else
#line 182
    if ((unsigned int )sym->class == 2U) {
#line 183
      return ("nonterminal");
    }
  }
#line 185
  return ("unknown");
}
}
#line 193 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_destructor_set(symbol *sym , code_props const   *destructor ) 
{ 


  {
#line 196
  if (sym->destructor.code) {
    {
#line 197
    symbol_redeclaration(sym, "%destructor", sym->destructor.location, (location )destructor->location);
    }
  }
#line 199
  sym->destructor = (code_props )*destructor;
#line 200
  return;
}
}
#line 206 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void semantic_type_destructor_set(semantic_type *type , code_props const   *destructor ) 
{ 


  {
#line 210
  if (type->destructor.code) {
    {
#line 211
    semantic_type_redeclaration(type, "%destructor", type->destructor.location, (location )destructor->location);
    }
  }
#line 214
  type->destructor = (code_props )*destructor;
#line 215
  return;
}
}
#line 221 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
code_props const   *symbol_destructor_get(symbol const   *sym ) 
{ 
  code_props const   *destructor ;
  semantic_type *tmp ;

  {
#line 225
  if (sym->destructor.code) {
#line 226
    return (& sym->destructor);
  }
#line 229
  if (sym->type_name) {
    {
#line 231
    tmp = semantic_type_get((char const   *)sym->type_name);
#line 231
    destructor = (code_props const   *)(& tmp->destructor);
    }
#line 233
    if (destructor->code) {
#line 234
      return (destructor);
    }
  }
#line 238
  if ((int const   )*(sym->tag + 0) == 36) {
#line 239
    return (& code_props_none);
  } else
#line 238
  if ((unsigned long )sym == (unsigned long )errtoken) {
#line 239
    return (& code_props_none);
  }
#line 241
  if (sym->type_name) {
#line 242
    return ((code_props const   *)(& default_tagged_destructor));
  }
#line 243
  return ((code_props const   *)(& default_tagless_destructor));
}
}
#line 250 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_printer_set(symbol *sym , code_props const   *printer ) 
{ 


  {
#line 253
  if (sym->printer.code) {
    {
#line 254
    symbol_redeclaration(sym, "%printer", sym->printer.location, (location )printer->location);
    }
  }
#line 256
  sym->printer = (code_props )*printer;
#line 257
  return;
}
}
#line 263 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void semantic_type_printer_set(semantic_type *type , code_props const   *printer ) 
{ 


  {
#line 266
  if (type->printer.code) {
    {
#line 267
    semantic_type_redeclaration(type, "%printer", type->printer.location, (location )printer->location);
    }
  }
#line 269
  type->printer = (code_props )*printer;
#line 270
  return;
}
}
#line 276 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
code_props const   *symbol_printer_get(symbol const   *sym ) 
{ 
  code_props const   *printer ;
  semantic_type *tmp ;

  {
#line 280
  if (sym->printer.code) {
#line 281
    return (& sym->printer);
  }
#line 284
  if (sym->type_name) {
    {
#line 286
    tmp = semantic_type_get((char const   *)sym->type_name);
#line 286
    printer = (code_props const   *)(& tmp->printer);
    }
#line 287
    if (printer->code) {
#line 288
      return (printer);
    }
  }
#line 292
  if ((int const   )*(sym->tag + 0) == 36) {
#line 293
    return (& code_props_none);
  } else
#line 292
  if ((unsigned long )sym == (unsigned long )errtoken) {
#line 293
    return (& code_props_none);
  }
#line 295
  if (sym->type_name) {
#line 296
    return ((code_props const   *)(& default_tagged_printer));
  }
#line 297
  return ((code_props const   *)(& default_tagless_printer));
}
}
#line 305 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_precedence_set(symbol *sym , int prec , assoc a , location loc___0 ) 
{ 
  char const   *tmp ;

  {
#line 308
  if ((unsigned int )a != 0U) {
#line 310
    if (sym->prec != 0) {
      {
#line 311
      tmp = assoc_to_string(a);
#line 311
      symbol_redeclaration(sym, tmp, sym->prec_location, loc___0);
      }
    }
#line 313
    sym->prec = prec;
#line 314
    sym->assoc = a;
#line 315
    sym->prec_location = loc___0;
  }
  {
#line 319
  symbol_class_set(sym, (symbol_class )1, loc___0, (_Bool)0);
  }
#line 320
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_class_set(symbol *sym , symbol_class class , location loc___0 , _Bool declaring ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 330
  if ((unsigned int )sym->class != 0U) {
#line 330
    if ((unsigned int )sym->class != (unsigned int )class) {
      {
#line 332
      tmp = gettext("symbol %s redefined");
#line 332
      complain_at(loc___0, (char const   *)tmp, sym->tag);
#line 333
      sym->declared = (_Bool)0;
      }
    }
  }
#line 336
  if ((unsigned int )class == 2U) {
#line 336
    if ((unsigned int )sym->class != 2U) {
#line 337
      tmp___0 = nvars;
#line 337
      nvars ++;
#line 337
      sym->number = tmp___0;
    } else {
#line 336
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 338
  if ((unsigned int )class == 1U) {
#line 338
    if (sym->number == -1) {
#line 339
      tmp___1 = ntokens;
#line 339
      ntokens ++;
#line 339
      sym->number = tmp___1;
    }
  }
#line 341
  sym->class = class;
#line 343
  if (declaring) {
#line 345
    if (sym->declared) {
      {
#line 346
      tmp___2 = gettext("symbol %s redeclared");
#line 346
      warn_at(loc___0, (char const   *)tmp___2, sym->tag);
      }
    }
#line 347
    sym->declared = (_Bool)1;
  }
#line 349
  return;
}
}
#line 356 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_user_token_number_set(symbol *sym , int user_token_number , location loc___0 ) 
{ 
  int *user_token_numberp ;
  char *tmp ;

  {
#line 361
  if (sym->user_token_number != -9991) {
#line 362
    user_token_numberp = & sym->user_token_number;
  } else {
#line 364
    user_token_numberp = & (sym->alias)->user_token_number;
  }
#line 365
  if (*user_token_numberp != -1) {
#line 365
    if (*user_token_numberp != user_token_number) {
      {
#line 367
      tmp = gettext("redefining user token number of %s");
#line 367
      complain_at(loc___0, (char const   *)tmp, sym->tag);
      }
    }
  }
#line 369
  *user_token_numberp = user_token_number;
#line 371
  if (user_token_number == 0) {
#line 373
    endtoken = sym;
#line 374
    endtoken->number = 0;
#line 377
    ntokens --;
  }
#line 379
  return;
}
}
#line 387 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static _Bool symbol_check_defined(symbol *sym ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 390
  if ((unsigned int )sym->class == 0U) {
    {
#line 392
    tmp = gettext("symbol %s is used, but is not defined as a token and has no rules");
#line 392
    complain_at(sym->location, (char const   *)tmp, sym->tag);
#line 396
    sym->class = (symbol_class )2;
#line 397
    tmp___0 = nvars;
#line 397
    nvars ++;
#line 397
    sym->number = tmp___0;
    }
  }
#line 400
  return ((_Bool)1);
}
}
#line 403 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool symbol_check_defined_processor(void *sym , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 406
  tmp = symbol_check_defined((symbol *)sym);
  }
#line 406
  return (tmp);
}
}
#line 415 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbol_make_alias(symbol *sym , symbol *symval , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 418
  if (symval->alias) {
    {
#line 419
    tmp = gettext("symbol `%s\' used more than once as a literal string");
#line 419
    warn_at(loc___0, (char const   *)tmp, symval->tag);
    }
  } else
#line 421
  if (sym->alias) {
    {
#line 422
    tmp___0 = gettext("symbol `%s\' given more than one literal string");
#line 422
    warn_at(loc___0, (char const   *)tmp___0, sym->tag);
    }
  } else {
    {
#line 426
    symval->class = (symbol_class )1;
#line 427
    symval->user_token_number = sym->user_token_number;
#line 428
    sym->user_token_number = -9991;
#line 429
    symval->alias = sym;
#line 430
    sym->alias = symval;
#line 431
    symval->number = sym->number;
#line 432
    symbol_type_set(symval, sym->type_name, loc___0);
    }
  }
#line 434
  return;
}
}
#line 442 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static void symbol_check_alias_consistency(symbol *this ) 
{ 
  symbol *alias ;
  symbol *orig ;

  {
#line 445
  alias = this;
#line 446
  orig = this->alias;
#line 449
  if (this->alias) {
#line 449
    if (! (this->user_token_number == -9991)) {
#line 450
      return;
    }
  } else {
#line 450
    return;
  }
#line 452
  if ((unsigned long )orig->type_name != (unsigned long )alias->type_name) {
#line 454
    if (orig->type_name) {
      {
#line 455
      symbol_type_set(alias, orig->type_name, orig->type_location);
      }
    } else {
      {
#line 457
      symbol_type_set(orig, alias->type_name, alias->type_location);
      }
    }
  }
#line 461
  if (orig->destructor.code) {
#line 461
    goto _L;
  } else
#line 461
  if (alias->destructor.code) {
    _L: /* CIL Label */ 
#line 463
    if (orig->destructor.code) {
      {
#line 464
      symbol_destructor_set(alias, (code_props const   *)(& orig->destructor));
      }
    } else {
      {
#line 466
      symbol_destructor_set(orig, (code_props const   *)(& alias->destructor));
      }
    }
  }
#line 469
  if (orig->printer.code) {
#line 469
    goto _L___0;
  } else
#line 469
  if (alias->printer.code) {
    _L___0: /* CIL Label */ 
#line 471
    if (orig->printer.code) {
      {
#line 472
      symbol_printer_set(alias, (code_props const   *)(& orig->printer));
      }
    } else {
      {
#line 474
      symbol_printer_set(orig, (code_props const   *)(& alias->printer));
      }
    }
  }
#line 477
  if (alias->prec) {
#line 477
    goto _L___1;
  } else
#line 477
  if (orig->prec) {
    _L___1: /* CIL Label */ 
#line 479
    if (orig->prec) {
      {
#line 480
      symbol_precedence_set(alias, orig->prec, orig->assoc, orig->prec_location);
      }
    } else {
      {
#line 483
      symbol_precedence_set(orig, alias->prec, alias->assoc, alias->prec_location);
      }
    }
  }
#line 486
  return;
}
}
#line 488 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool symbol_check_alias_consistency_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 492
  symbol_check_alias_consistency((symbol *)this);
  }
#line 493
  return ((_Bool)1);
}
}
#line 502 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static _Bool symbol_pack(symbol *this ) 
{ 
  symbol_number tmp ;

  {
#line 505
  if ((unsigned int )this->class == 2U) {
#line 507
    this->number += ntokens;
  } else
#line 509
  if (this->alias) {
#line 514
    if (this->number == -1) {
#line 516
      if ((unsigned long )this == (unsigned long )endtoken) {
#line 517
        tmp = 0;
#line 517
        (this->alias)->number = tmp;
#line 517
        this->number = tmp;
      } else
#line 516
      if ((unsigned long )this->alias == (unsigned long )endtoken) {
#line 517
        tmp = 0;
#line 517
        (this->alias)->number = tmp;
#line 517
        this->number = tmp;
      } else {
        {
#line 520
        aver((_Bool )((this->alias)->number != -1));
#line 521
        this->number = (this->alias)->number;
        }
      }
    }
#line 525
    if (this->user_token_number == -9991) {
#line 526
      return ((_Bool)1);
    }
  } else {
    {
#line 529
    aver((_Bool )(this->number != -1));
    }
  }
#line 531
  *(symbols + this->number) = this;
#line 532
  return ((_Bool)1);
}
}
#line 535 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool symbol_pack_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 538
  tmp = symbol_pack((symbol *)this);
  }
#line 538
  return (tmp);
}
}
#line 548 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static _Bool symbol_translation(symbol *this ) 
{ 
  char *tmp ;

  {
#line 552
  if ((unsigned int )this->class == 1U) {
#line 552
    if (this->user_token_number != -9991) {
#line 556
      if (*(token_translations + this->user_token_number) != undeftoken->number) {
        {
#line 557
        tmp = gettext("tokens %s and %s both assigned number %d");
#line 557
        complain_at(this->location, (char const   *)tmp, (*(symbols + *(token_translations + this->user_token_number)))->tag,
                    this->tag, this->user_token_number);
        }
      }
#line 562
      *(token_translations + this->user_token_number) = this->number;
    }
  }
#line 565
  return ((_Bool)1);
}
}
#line 568 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool symbol_translation_processor(void *this , void *null  __attribute__((__unused__)) ) 
{ 
  _Bool tmp ;

  {
  {
#line 571
  tmp = symbol_translation((symbol *)this);
  }
#line 571
  return (tmp);
}
}
#line 582 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static struct hash_table *symbol_table  =    (struct hash_table *)((void *)0);
#line 583 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static struct hash_table *semantic_type_table  =    (struct hash_table *)((void *)0);
#line 585 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static _Bool hash_compare_symbol(symbol const   *m1 , symbol const   *m2 ) 
{ 


  {
#line 589
  return ((_Bool )((unsigned long )m1->tag == (unsigned long )m2->tag));
}
}
#line 592 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static _Bool hash_compare_semantic_type(semantic_type const   *m1 , semantic_type const   *m2 ) 
{ 


  {
#line 596
  return ((_Bool )((unsigned long )m1->tag == (unsigned long )m2->tag));
}
}
#line 599 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool hash_symbol_comparator(void const   *m1 , void const   *m2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 602
  tmp = hash_compare_symbol((symbol const   *)m1, (symbol const   *)m2);
  }
#line 602
  return (tmp);
}
}
#line 605 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static _Bool hash_semantic_type_comparator(void const   *m1 , void const   *m2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 608
  tmp = hash_compare_semantic_type((semantic_type const   *)m1, (semantic_type const   *)m2);
  }
#line 608
  return (tmp);
}
}
#line 611 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static size_t hash_symbol(symbol const   *m , size_t tablesize ) 
{ 


  {
#line 615
  return ((size_t )((unsigned long )m->tag % (unsigned long )tablesize));
}
}
#line 618 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
__inline static size_t hash_semantic_type(semantic_type const   *m , size_t tablesize ) 
{ 


  {
#line 622
  return ((size_t )((unsigned long )m->tag % (unsigned long )tablesize));
}
}
#line 625 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static size_t hash_symbol_hasher(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 628
  tmp = hash_symbol((symbol const   *)m, tablesize);
  }
#line 628
  return (tmp);
}
}
#line 631 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static size_t hash_semantic_type_hasher(void const   *m , size_t tablesize ) 
{ 
  size_t tmp ;

  {
  {
#line 634
  tmp = hash_semantic_type((semantic_type const   *)m, tablesize);
  }
#line 634
  return (tmp);
}
}
#line 641 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbols_new(void) 
{ 


  {
  {
#line 644
  symbol_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                 & hash_symbol_hasher, & hash_symbol_comparator, & free);
#line 649
  semantic_type_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                        & hash_semantic_type_hasher, & hash_semantic_type_comparator,
                                        & free);
  }
#line 654
  return;
}
}
#line 662 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *symbol_from_uniqstr(uniqstr const   key , location loc___0 ) 
{ 
  symbol probe ;
  symbol *entry ;
  void *tmp ;

  {
  {
#line 668
  probe.tag = (uniqstr )key;
#line 669
  tmp = hash_lookup((Hash_table const   *)symbol_table, (void const   *)(& probe));
#line 669
  entry = (symbol *)tmp;
  }
#line 671
  if (! entry) {
    {
#line 674
    entry = symbol_new((uniqstr )key, loc___0);
#line 675
    hash_insert(symbol_table, (void const   *)entry);
    }
  }
#line 677
  return (entry);
}
}
#line 686 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
semantic_type *semantic_type_from_uniqstr(uniqstr const   key ) 
{ 
  semantic_type probe ;
  semantic_type *entry ;
  void *tmp ;

  {
  {
#line 692
  probe.tag = (uniqstr )key;
#line 693
  tmp = hash_lookup((Hash_table const   *)semantic_type_table, (void const   *)(& probe));
#line 693
  entry = (semantic_type *)tmp;
  }
#line 695
  if (! entry) {
    {
#line 698
    entry = semantic_type_new((uniqstr )key);
#line 699
    hash_insert(semantic_type_table, (void const   *)entry);
    }
  }
#line 701
  return (entry);
}
}
#line 710 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *symbol_get(char const   *key , location loc___0 ) 
{ 
  uniqstr tmp ;
  symbol *tmp___0 ;

  {
  {
#line 713
  tmp = uniqstr_new(key);
#line 713
  tmp___0 = symbol_from_uniqstr((uniqstr const   )tmp, loc___0);
  }
#line 713
  return (tmp___0);
}
}
#line 722 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
semantic_type *semantic_type_get(char const   *key ) 
{ 
  uniqstr tmp ;
  semantic_type *tmp___0 ;

  {
  {
#line 725
  tmp = uniqstr_new(key);
#line 725
  tmp___0 = semantic_type_from_uniqstr((uniqstr const   )tmp);
  }
#line 725
  return (tmp___0);
}
}
#line 738 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static int dummy_count  =    0;
#line 739 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static char buf[256]  ;
#line 734 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
symbol *dummy_symbol_get(location loc___0 ) 
{ 
  symbol *sym ;
  int tmp ;

  {
  {
#line 743
  dummy_count ++;
#line 743
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"$@%d",
          dummy_count);
#line 744
  sym = symbol_get((char const   *)(buf), loc___0);
#line 745
  sym->class = (symbol_class )2;
#line 746
  tmp = nvars;
#line 746
  nvars ++;
#line 746
  sym->number = tmp;
  }
#line 747
  return (sym);
}
}
#line 750 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
_Bool symbol_is_dummy(symbol const   *sym ) 
{ 
  int tmp ;

  {
#line 753
  if ((int const   )*(sym->tag + 0) == 64) {
#line 753
    tmp = 1;
  } else
#line 753
  if ((int const   )*(sym->tag + 0) == 36) {
#line 753
    if ((int const   )*(sym->tag + 1) == 64) {
#line 753
      tmp = 1;
    } else {
#line 753
      tmp = 0;
    }
  } else {
#line 753
    tmp = 0;
  }
#line 753
  return ((_Bool )tmp);
}
}
#line 760 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbols_free(void) 
{ 


  {
  {
#line 763
  hash_free(symbol_table);
#line 764
  hash_free(semantic_type_table);
#line 765
  free((void *)symbols);
  }
#line 766
  return;
}
}
#line 774 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static void symbols_do(_Bool (*processor)(void * , void * ) , void *processor_data ) 
{ 


  {
  {
#line 777
  hash_do_for_each((Hash_table const   *)symbol_table, processor, processor_data);
  }
#line 778
  return;
}
}
#line 786 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbols_check_defined(void) 
{ 


  {
  {
#line 789
  symbols_do(& symbol_check_defined_processor, (void *)0);
  }
#line 790
  return;
}
}
#line 797 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
static void symbols_token_translations_init(void) 
{ 
  _Bool num_256_available_p ;
  int i ;
  symbol *this ;
  symbol *this___0 ;
  void *tmp ;

  {
#line 800
  num_256_available_p = (_Bool)1;
#line 805
  max_user_token_number = 0;
#line 806
  i = 0;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (i < ntokens)) {
#line 806
      goto while_break;
    }
#line 808
    this = *(symbols + i);
#line 809
    if (this->user_token_number != -1) {
#line 811
      if (this->user_token_number > max_user_token_number) {
#line 812
        max_user_token_number = this->user_token_number;
      }
#line 813
      if (this->user_token_number == 256) {
#line 814
        num_256_available_p = (_Bool)0;
      }
    }
#line 806
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  if (num_256_available_p) {
#line 819
    if (errtoken->user_token_number == -1) {
#line 821
      errtoken->user_token_number = 256;
    }
  }
#line 824
  if (max_user_token_number < 256) {
#line 825
    max_user_token_number = 256;
  }
#line 827
  i = 0;
  {
#line 827
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 827
    if (! (i < ntokens)) {
#line 827
      goto while_break___0;
    }
#line 829
    this___0 = *(symbols + i);
#line 830
    if (this___0->user_token_number == -1) {
#line 831
      max_user_token_number ++;
#line 831
      this___0->user_token_number = max_user_token_number;
    }
#line 832
    if (this___0->user_token_number > max_user_token_number) {
#line 833
      max_user_token_number = this___0->user_token_number;
    }
#line 827
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 836
  tmp = xnmalloc((size_t )(max_user_token_number + 1), (size_t )sizeof(*token_translations));
#line 836
  token_translations = (symbol_number *)tmp;
#line 842
  i = 0;
  }
  {
#line 842
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 842
    if (! (i < max_user_token_number + 1)) {
#line 842
      goto while_break___1;
    }
#line 843
    *(token_translations + i) = undeftoken->number;
#line 842
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 844
  symbols_do(& symbol_translation_processor, (void *)0);
  }
#line 845
  return;
}
}
#line 853 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void symbols_pack(void) 
{ 
  void *tmp ;
  int writei ;
  int readi ;
  int nsyms_old ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 856
  symbols_do(& symbol_check_alias_consistency_processor, (void *)0);
#line 858
  tmp = xcalloc((size_t )nsyms, (size_t )sizeof(*symbols));
#line 858
  symbols = (symbol **)tmp;
#line 859
  symbols_do(& symbol_pack_processor, (void *)0);
#line 865
  nsyms_old = nsyms;
#line 866
  writei = 0;
#line 866
  readi = 0;
  }
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (readi < nsyms_old)) {
#line 866
      goto while_break;
    }
#line 868
    if ((unsigned long )*(symbols + readi) == (unsigned long )((void *)0)) {
#line 870
      nsyms --;
#line 871
      ntokens --;
    } else {
#line 875
      *(symbols + writei) = *(symbols + readi);
#line 876
      (*(symbols + writei))->number = writei;
#line 877
      if ((*(symbols + writei))->alias) {
#line 878
        ((*(symbols + writei))->alias)->number = writei;
      }
#line 879
      writei ++;
    }
#line 866
    readi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 883
  tmp___0 = xnrealloc((void *)symbols, (size_t )nsyms, (size_t )sizeof(*symbols));
#line 883
  symbols = (symbol **)tmp___0;
#line 885
  symbols_token_translations_init();
  }
#line 887
  if ((unsigned int )startsymbol->class == 0U) {
    {
#line 888
    tmp___1 = gettext("the start symbol %s is undefined");
#line 888
    fatal_at(startsymbol_location, (char const   *)tmp___1, startsymbol->tag);
    }
  } else
#line 891
  if ((unsigned int )startsymbol->class == 1U) {
    {
#line 892
    tmp___2 = gettext("the start symbol %s is a token");
#line 892
    fatal_at(startsymbol_location, (char const   *)tmp___2, startsymbol->tag);
    }
  }
#line 895
  return;
}
}
#line 902 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void default_tagged_destructor_set(code_props const   *destructor ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 905
  if (default_tagged_destructor.code) {
    {
#line 907
    tmp = gettext("redeclaration for default tagged %%destructor");
#line 907
    complain_at((location )destructor->location, (char const   *)tmp);
#line 909
    tmp___0 = gettext("previous declaration");
#line 909
    complain_at(default_tagged_destructor.location, (char const   *)tmp___0);
    }
  }
#line 912
  default_tagged_destructor = (code_props )*destructor;
#line 913
  return;
}
}
#line 915 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void default_tagless_destructor_set(code_props const   *destructor ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 918
  if (default_tagless_destructor.code) {
    {
#line 920
    tmp = gettext("redeclaration for default tagless %%destructor");
#line 920
    complain_at((location )destructor->location, (char const   *)tmp);
#line 922
    tmp___0 = gettext("previous declaration");
#line 922
    complain_at(default_tagless_destructor.location, (char const   *)tmp___0);
    }
  }
#line 925
  default_tagless_destructor = (code_props )*destructor;
#line 926
  return;
}
}
#line 928 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void default_tagged_printer_set(code_props const   *printer ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 931
  if (default_tagged_printer.code) {
    {
#line 933
    tmp = gettext("redeclaration for default tagged %%printer");
#line 933
    complain_at((location )printer->location, (char const   *)tmp);
#line 935
    tmp___0 = gettext("previous declaration");
#line 935
    complain_at(default_tagged_printer.location, (char const   *)tmp___0);
    }
  }
#line 938
  default_tagged_printer = (code_props )*printer;
#line 939
  return;
}
}
#line 941 "/home/pronto/abs/test-suite/bison-2.4/src/symtab.c"
void default_tagless_printer_set(code_props const   *printer ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 944
  if (default_tagless_printer.code) {
    {
#line 946
    tmp = gettext("redeclaration for default tagless %%printer");
#line 946
    complain_at((location )printer->location, (char const   *)tmp);
#line 948
    tmp___0 = gettext("previous declaration");
#line 948
    complain_at(default_tagless_printer.location, (char const   *)tmp___0);
    }
  }
#line 951
  default_tagless_printer = (code_props )*printer;
#line 952
  return;
}
}
#line 111 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
void code_props_symbol_action_init(code_props *self , char const   *code , location code_loc ) ;
#line 145
void code_props_translate_code(code_props *self ) ;
#line 78 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.h"
symbol_list *symbol_list_sym_new(symbol *sym , location loc___0 ) ;
#line 81
symbol_list *symbol_list_type_new(uniqstr type_name , location loc___0 ) ;
#line 84
symbol_list *symbol_list_default_tagged_new(location loc___0 ) ;
#line 86
symbol_list *symbol_list_default_tagless_new(location loc___0 ) ;
#line 92
void symbol_list_syms_print(symbol_list const   *l , FILE *f ) ;
#line 95
symbol_list *symbol_list_prepend(symbol_list *list , symbol_list *node ) ;
#line 98
void symbol_list_free(symbol_list *list ) ;
#line 101
int symbol_list_length(symbol_list const   *l ) ;
#line 104
symbol_list *symbol_list_n_get(symbol_list *l , int n ) ;
#line 108
uniqstr symbol_list_n_type_name_get(symbol_list *l , location loc___0 , int n ) ;
#line 111
void symbol_list_destructor_set(symbol_list *node , char const   *code , location loc___0 ) ;
#line 115
void symbol_list_printer_set(symbol_list *node , char const   *code , location loc___0 ) ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_sym_new(symbol *sym , location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;

  {
  {
#line 34
  tmp = xmalloc((size_t )sizeof(*res));
#line 34
  res = (symbol_list *)tmp;
#line 36
  res->content_type = (enum __anonenum_content_type_39 )0;
#line 37
  res->content.sym = sym;
#line 38
  res->location = loc___0;
#line 40
  res->midrule = (struct symbol_list *)((void *)0);
#line 41
  res->midrule_parent_rule = (struct symbol_list *)((void *)0);
#line 42
  res->midrule_parent_rhs_index = 0;
#line 44
  code_props_none_init(& res->action_props);
#line 46
  res->ruleprec = (symbol *)((void *)0);
#line 47
  res->dprec = 0;
#line 48
  res->merger = 0;
#line 50
  res->next = (struct symbol_list *)((void *)0);
  }
#line 52
  return (res);
}
}
#line 60 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_type_new(uniqstr type_name , location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;

  {
  {
#line 63
  tmp = xmalloc((size_t )sizeof(*res));
#line 63
  res = (symbol_list *)tmp;
#line 65
  res->content_type = (enum __anonenum_content_type_39 )1;
#line 66
  res->content.type_name = type_name;
#line 67
  res->location = loc___0;
#line 68
  res->next = (struct symbol_list *)((void *)0);
  }
#line 70
  return (res);
}
}
#line 78 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_default_tagged_new(location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;

  {
  {
#line 81
  tmp = xmalloc((size_t )sizeof(*res));
#line 81
  res = (symbol_list *)tmp;
#line 83
  res->content_type = (enum __anonenum_content_type_39 )2;
#line 84
  res->location = loc___0;
#line 85
  res->next = (struct symbol_list *)((void *)0);
  }
#line 87
  return (res);
}
}
#line 95 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_default_tagless_new(location loc___0 ) 
{ 
  symbol_list *res ;
  void *tmp ;

  {
  {
#line 98
  tmp = xmalloc((size_t )sizeof(*res));
#line 98
  res = (symbol_list *)tmp;
#line 100
  res->content_type = (enum __anonenum_content_type_39 )3;
#line 101
  res->location = loc___0;
#line 102
  res->next = (struct symbol_list *)((void *)0);
  }
#line 104
  return (res);
}
}
#line 112 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
void symbol_list_syms_print(symbol_list const   *l , FILE *f ) 
{ 
  char const   *tmp ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (l) {
#line 115
      if (! l->content.sym) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
    {
#line 117
    symbol_print((symbol *)l->content.sym, f);
    }
#line 118
    if (l->action_props.is_value_used) {
#line 118
      tmp = " used";
    } else {
#line 118
      tmp = " unused";
    }
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 119
    if (l) {
#line 119
      if (l->content.sym) {
        {
#line 120
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)", ");
        }
      }
    }
#line 115
    l = (symbol_list const   *)l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 129 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_prepend(symbol_list *list , symbol_list *node ) 
{ 


  {
#line 132
  node->next = list;
#line 133
  return (node);
}
}
#line 141 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
void symbol_list_free(symbol_list *list ) 
{ 
  symbol_list *_node ;
  symbol_list *_next ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    _node = list;
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 144
      if (! _node) {
#line 144
        goto while_break___0;
      }
      {
#line 144
      _next = _node->next;
#line 144
      free((void *)_node);
#line 144
      _node = _next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 152 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
int symbol_list_length(symbol_list const   *l ) 
{ 
  int res ;

  {
#line 155
  res = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (l) {
#line 156
      if ((unsigned int const   )l->content_type == 0U) {
#line 156
        if ((unsigned long )l->content.sym == (unsigned long )((void *)0)) {
#line 156
          goto while_break;
        }
      }
    } else {
#line 156
      goto while_break;
    }
#line 159
    res ++;
#line 156
    l = (symbol_list const   *)l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return (res);
}
}
#line 168 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
symbol_list *symbol_list_n_get(symbol_list *l , int n ) 
{ 
  int i ;

  {
#line 173
  if (n < 0) {
#line 174
    return ((symbol_list *)((void *)0));
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < n)) {
#line 176
      goto while_break;
    }
#line 178
    l = l->next;
#line 179
    if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 181
      return ((symbol_list *)((void *)0));
    } else
#line 179
    if ((unsigned int )l->content_type == 0U) {
#line 179
      if ((unsigned long )l->content.sym == (unsigned long )((void *)0)) {
#line 181
        return ((symbol_list *)((void *)0));
      }
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (l);
}
}
#line 193 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
uniqstr symbol_list_n_type_name_get(symbol_list *l , location loc___0 , int n ) 
{ 
  char *tmp ;

  {
  {
#line 196
  l = symbol_list_n_get(l, n);
  }
#line 197
  if (! l) {
    {
#line 199
    tmp = gettext("invalid $ value: $%d");
#line 199
    complain_at(loc___0, (char const   *)tmp, n);
    }
#line 200
    return ((uniqstr )((void *)0));
  }
  {
#line 202
  aver((_Bool )((unsigned int )l->content_type == 0U));
  }
#line 203
  return ((l->content.sym)->type_name);
}
}
#line 207 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
void symbol_list_destructor_set(symbol_list *node , char const   *code , location loc___0 ) 
{ 
  code_props destructor ;
  semantic_type *tmp ;

  {
  {
#line 211
  code_props_symbol_action_init(& destructor, code, loc___0);
#line 212
  code_props_translate_code(& destructor);
  }
  {
#line 215
  if ((unsigned int )node->content_type == 0U) {
#line 215
    goto case_0;
  }
#line 218
  if ((unsigned int )node->content_type == 1U) {
#line 218
    goto case_1;
  }
#line 222
  if ((unsigned int )node->content_type == 2U) {
#line 222
    goto case_2;
  }
#line 225
  if ((unsigned int )node->content_type == 3U) {
#line 225
    goto case_3;
  }
#line 213
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 216
  symbol_destructor_set(node->content.sym, (code_props const   *)(& destructor));
  }
#line 217
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 219
  tmp = semantic_type_get(node->content.type_name);
#line 219
  semantic_type_destructor_set(tmp, (code_props const   *)(& destructor));
  }
#line 221
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 223
  default_tagged_destructor_set((code_props const   *)(& destructor));
  }
#line 224
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 226
  default_tagless_destructor_set((code_props const   *)(& destructor));
  }
#line 227
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 231 "/home/pronto/abs/test-suite/bison-2.4/src/symlist.c"
void symbol_list_printer_set(symbol_list *node , char const   *code , location loc___0 ) 
{ 
  code_props printer ;
  semantic_type *tmp ;

  {
  {
#line 235
  code_props_symbol_action_init(& printer, code, loc___0);
#line 236
  code_props_translate_code(& printer);
  }
  {
#line 239
  if ((unsigned int )node->content_type == 0U) {
#line 239
    goto case_0;
  }
#line 242
  if ((unsigned int )node->content_type == 1U) {
#line 242
    goto case_1;
  }
#line 246
  if ((unsigned int )node->content_type == 2U) {
#line 246
    goto case_2;
  }
#line 249
  if ((unsigned int )node->content_type == 3U) {
#line 249
    goto case_3;
  }
#line 237
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 240
  symbol_printer_set(node->content.sym, (code_props const   *)(& printer));
  }
#line 241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 243
  tmp = semantic_type_get(node->content.type_name);
#line 243
  semantic_type_printer_set(tmp, (code_props const   *)(& printer));
  }
#line 245
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 247
  default_tagged_printer_set((code_props const   *)(& printer));
  }
#line 248
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 250
  default_tagless_printer_set((code_props const   *)(& printer));
  }
#line 251
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 498
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 218 "scan-skel.c"
int skel_leng  ;
#line 223
FILE *skel_in ;
#line 223
FILE *skel_out ;
#line 330 "scan-skel.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 331 "scan-skel.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 332 "scan-skel.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 359 "scan-skel.c"
static char yy_hold_char  ;
#line 360 "scan-skel.c"
static int yy_n_chars  ;
#line 364 "scan-skel.c"
static char *yy_c_buf_p  =    (char *)0;
#line 365 "scan-skel.c"
static int yy_init  =    0;
#line 366 "scan-skel.c"
static int yy_start  =    0;
#line 371 "scan-skel.c"
static int yy_did_buffer_switch_on_eof  ;
#line 376
void skel_restart(FILE *input_file ) ;
#line 377
void skel__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 378
YY_BUFFER_STATE skel__create_buffer(FILE *file , int size ) ;
#line 379
void skel__delete_buffer(YY_BUFFER_STATE b ) ;
#line 380
void skel__flush_buffer(YY_BUFFER_STATE b ) ;
#line 381
void skel_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 382
void skel_pop_buffer_state(void) ;
#line 384
static void skel_ensure_buffer_stack(void) ;
#line 385
static void skel__load_buffer_state(void) ;
#line 386
static void skel__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 390
YY_BUFFER_STATE skel__scan_buffer(char *base___0 , yy_size_t size ) ;
#line 391
YY_BUFFER_STATE skel__scan_string(char const   *yystr ) ;
#line 392
YY_BUFFER_STATE skel__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 396
void *skel_alloc(yy_size_t size ) ;
#line 397
void *skel_realloc(void *ptr , yy_size_t size ) ;
#line 398
void skel_free(void *ptr ) ;
#line 434 "scan-skel.c"
FILE *skel_in  =    (FILE *)0;
#line 434 "scan-skel.c"
FILE *skel_out  =    (FILE *)0;
#line 438
int skel_lineno ;
#line 440 "scan-skel.c"
int skel_lineno  =    1;
#line 442 "scan-skel.c"
char *skel_text  ;
#line 447
static yy_state_type yy_get_previous_state(void) ;
#line 448
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 449
static int yy_get_next_buffer(void) ;
#line 450
static void yy_fatal_error(char const   *msg ) ;
#line 476 "scan-skel.c"
static flex_int16_t const   yy_accept[56]  = 
#line 476
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )12,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5,      (flex_int16_t const   )1, 
        (flex_int16_t const   )10,      (flex_int16_t const   )4,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )13,      (flex_int16_t const   )20, 
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )14,      (flex_int16_t const   )17, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )7,      (flex_int16_t const   )6,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )8,      (flex_int16_t const   )0};
#line 486 "scan-skel.c"
static flex_int32_t const   yy_ec[256]  = 
#line 486
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )9, 
        (flex_int32_t const   )9,      (flex_int32_t const   )13,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )14,      (flex_int32_t const   )9,      (flex_int32_t const   )15,      (flex_int32_t const   )16, 
        (flex_int32_t const   )17,      (flex_int32_t const   )9,      (flex_int32_t const   )18,      (flex_int32_t const   )9, 
        (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )19,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )20, 
        (flex_int32_t const   )1,      (flex_int32_t const   )21,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 518 "scan-skel.c"
static flex_int32_t const   yy_meta[22]  = 
#line 518
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3};
#line 525 "scan-skel.c"
static flex_int16_t const   yy_base[63]  = 
#line 525
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )60, 
        (flex_int16_t const   )58,      (flex_int16_t const   )6,      (flex_int16_t const   )8,      (flex_int16_t const   )63, 
        (flex_int16_t const   )0,      (flex_int16_t const   )93,      (flex_int16_t const   )11,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )49,      (flex_int16_t const   )93,      (flex_int16_t const   )49,      (flex_int16_t const   )25, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )43, 
        (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )49,      (flex_int16_t const   )40, 
        (flex_int16_t const   )34,      (flex_int16_t const   )31,      (flex_int16_t const   )36,      (flex_int16_t const   )35, 
        (flex_int16_t const   )27,      (flex_int16_t const   )38,      (flex_int16_t const   )37,      (flex_int16_t const   )31, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )29,      (flex_int16_t const   )27, 
        (flex_int16_t const   )15,      (flex_int16_t const   )9,      (flex_int16_t const   )93,      (flex_int16_t const   )93, 
        (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )78,      (flex_int16_t const   )82, 
        (flex_int16_t const   )85,      (flex_int16_t const   )88,      (flex_int16_t const   )0};
#line 536 "scan-skel.c"
static flex_int16_t const   yy_def[63]  = 
#line 536
  {      (flex_int16_t const   )0,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )55, 
        (flex_int16_t const   )59,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )60, 
        (flex_int16_t const   )61,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )59,      (flex_int16_t const   )62,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )10,      (flex_int16_t const   )55,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )60,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )55,      (flex_int16_t const   )0, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 547 "scan-skel.c"
static flex_int16_t const   yy_nxt[115]  = 
#line 547
  {      (flex_int16_t const   )0,      (flex_int16_t const   )17,      (flex_int16_t const   )55,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )55,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )54, 
        (flex_int16_t const   )17,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )23, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )28,      (flex_int16_t const   )53,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )36,      (flex_int16_t const   )31,      (flex_int16_t const   )37, 
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )49, 
        (flex_int16_t const   )48,      (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )45, 
        (flex_int16_t const   )44,      (flex_int16_t const   )43,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )55,      (flex_int16_t const   )34,      (flex_int16_t const   )42,      (flex_int16_t const   )55, 
        (flex_int16_t const   )41,      (flex_int16_t const   )55,      (flex_int16_t const   )40,      (flex_int16_t const   )20, 
        (flex_int16_t const   )39,      (flex_int16_t const   )38,      (flex_int16_t const   )35,      (flex_int16_t const   )55, 
        (flex_int16_t const   )12,      (flex_int16_t const   )20,      (flex_int16_t const   )12,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )16, 
        (flex_int16_t const   )55,      (flex_int16_t const   )16,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )7,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 564 "scan-skel.c"
static flex_int16_t const   yy_chk[115]  = 
#line 564
  {      (flex_int16_t const   )0,      (flex_int16_t const   )62,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )53, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )12,      (flex_int16_t const   )52,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )23,      (flex_int16_t const   )12,      (flex_int16_t const   )23, 
        (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )47,      (flex_int16_t const   )46, 
        (flex_int16_t const   )45,      (flex_int16_t const   )44,      (flex_int16_t const   )43,      (flex_int16_t const   )42, 
        (flex_int16_t const   )41,      (flex_int16_t const   )40,      (flex_int16_t const   )12,      (flex_int16_t const   )12, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )39,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )20,      (flex_int16_t const   )37,      (flex_int16_t const   )20, 
        (flex_int16_t const   )36,      (flex_int16_t const   )35,      (flex_int16_t const   )22,      (flex_int16_t const   )7, 
        (flex_int16_t const   )4,      (flex_int16_t const   )20,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55};
#line 581 "scan-skel.c"
static yy_state_type yy_last_accepting_state  ;
#line 582 "scan-skel.c"
static char *yy_last_accepting_cpos  ;
#line 584
int skel__flex_debug ;
#line 585 "scan-skel.c"
int skel__flex_debug  =    1;
#line 587 "scan-skel.c"
static flex_int16_t const   yy_rule_linenum[23]  = 
#line 587
  {      (flex_int16_t const   )0,      (flex_int16_t const   )73,      (flex_int16_t const   )74,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )79,      (flex_int16_t const   )80, 
        (flex_int16_t const   )81,      (flex_int16_t const   )83,      (flex_int16_t const   )92,      (flex_int16_t const   )93, 
        (flex_int16_t const   )94,      (flex_int16_t const   )106,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )115, 
        (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )141};
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/flex-scanner.h"
int skel_get_lineno(void) ;
#line 26
FILE *skel_get_in(void) ;
#line 27
FILE *skel_get_out(void) ;
#line 28
int skel_get_leng(void) ;
#line 29
char *skel_get_text(void) ;
#line 30
void skel_set_lineno(int line_number ) ;
#line 31
void skel_set_in(FILE *in_str ) ;
#line 32
void skel_set_out(FILE *out_str ) ;
#line 33
int skel_get_debug(void) ;
#line 34
void skel_set_debug(int bdebug ) ;
#line 35
int skel_lex_destroy(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.4/src/flex-scanner.h"
static struct obstack obstack_for_string  ;
#line 83 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
void boundary_set_from_string(boundary *bound , char *loc_str ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/complain.h"
void ( /* format attribute */  warn)(char const   *message  , ...) ;
#line 36
void ( /* format attribute */  complain)(char const   *message  , ...) ;
#line 109 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern int trace_flag ;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *dir_prefix ;
#line 66
void output_file_name_check(char const   *file_name ) ;
#line 68
FILE *xfopen(char const   *name , char const   *mode ) ;
#line 69
void xfclose(FILE *ptr ) ;
#line 20 "/home/pronto/abs/test-suite/bison-2.4/src/scan-skel.h"
void scan_skel(FILE *in ) ;
#line 27
void skel_scanner_free(void) ;
#line 43 "scan-skel.l"
static int skel_lex(void) ;
#line 48
static void at_directive_perform(int at_directive_argc , char **at_directive_argv ,
                                 char **outnamep , int *out_linenop ) ;
#line 51
static void fail_for_at_directive_too_many_args(char const   *at_directive_name ) ;
#line 52
static void fail_for_at_directive_too_few_args(char const   *at_directive_name ) ;
#line 53
static void fail_for_invalid_at(char const   *at ) ;
#line 680 "scan-skel.c"
static int yy_init_globals(void) ;
#line 889 "scan-skel.c"
static int skel_lex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int out_lineno ;
  char *outname ;
  int at_directive_argc ;
  char *at_directive_argv[8] ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o ;
  int __len ;
  int tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  char *tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o___3 ;
  char *tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  int tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o___5 ;
  void *__obj ;
  char *tmp___12 ;
  int yyless_macro_arg ;
  char *tmp___13 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___14 ;

  {
#line 63 "scan-skel.l"
  outname = (char *)((void *)0);
#line 69
  at_directive_argc = 0;
#line 913
  if (! yy_init) {
#line 915 "scan-skel.c"
    yy_init = 1;
#line 921
    if (! yy_start) {
#line 922
      yy_start = 1;
    }
#line 924
    if (! skel_in) {
#line 926
      skel_in = stdin;
    }
#line 931
    if (! skel_out) {
#line 933
      skel_out = stdout;
    }
#line 938
    if (yy_buffer_stack) {
#line 938
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 938
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 938
    if (! tmp) {
      {
#line 939
      skel_ensure_buffer_stack();
#line 940
      *(yy_buffer_stack + yy_buffer_stack_top) = skel__create_buffer(skel_in, 16384);
      }
    }
    {
#line 944
    skel__load_buffer_state();
    }
  }
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    yy_cp = yy_c_buf_p;
#line 953
    *yy_cp = yy_hold_char;
#line 958
    yy_bp = yy_cp;
#line 961
    yy_current_state = yy_start;
    yy_match: 
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 965
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 966
      if (yy_accept[yy_current_state]) {
#line 968
        yy_last_accepting_state = yy_current_state;
#line 969
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 971
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 971
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 971
          goto while_break___1;
        }
#line 973
        yy_current_state = (int )yy_def[yy_current_state];
#line 974
        if (yy_current_state >= 56) {
#line 975
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 977
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 978
      yy_cp ++;
#line 963
      if (! (yy_current_state != 55)) {
#line 963
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 981
    yy_cp = yy_last_accepting_cpos;
#line 982
    yy_current_state = yy_last_accepting_state;
    yy_find_action: 
#line 986
    yy_act = (int )yy_accept[yy_current_state];
#line 988
    skel_text = yy_bp;
#line 988
    skel_leng = (int )((size_t )(yy_cp - yy_bp));
#line 988
    yy_hold_char = *yy_cp;
#line 988
    *yy_cp = (char )'\000';
#line 988
    yy_c_buf_p = yy_cp;
    do_action: 
#line 995
    if (skel__flex_debug) {
#line 997
      if (yy_act == 0) {
        {
#line 998
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 999
      if (yy_act < 23) {
        {
#line 1000
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_rule_linenum[yy_act], skel_text);
        }
      } else
#line 1002
      if (yy_act == 23) {
        {
#line 1003
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                skel_text);
        }
      } else
#line 1005
      if (yy_act == 24) {
        {
#line 1006
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1008
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_start - 1) / 2);
        }
      }
    }
    {
#line 1014
    if (yy_act == 0) {
#line 1014
      goto case_0;
    }
#line 1021
    if (yy_act == 1) {
#line 1021
      goto case_1;
    }
#line 75
    if (yy_act == 2) {
#line 75 "scan-skel.l"
      goto case_2;
    }
#line 76
    if (yy_act == 3) {
#line 76
      goto case_3;
    }
#line 77
    if (yy_act == 4) {
#line 77
      goto case_4;
    }
#line 78
    if (yy_act == 5) {
#line 78
      goto case_5;
    }
#line 79
    if (yy_act == 6) {
#line 79
      goto case_6;
    }
#line 81
    if (yy_act == 7) {
#line 81
      goto case_7;
    }
#line 82
    if (yy_act == 8) {
#line 82
      goto case_8;
    }
#line 83
    if (yy_act == 9) {
#line 83
      goto case_9;
    }
#line 92
    if (yy_act == 10) {
#line 92
      goto case_10;
    }
#line 94
    if (yy_act == 11) {
#line 94
      goto case_11;
    }
#line 95
    if (yy_act == 12) {
#line 95
      goto case_12;
    }
#line 96
    if (yy_act == 25) {
#line 96
      goto case_25;
    }
#line 106
    if (yy_act == 13) {
#line 106
      goto case_13;
    }
#line 108
    if (yy_act == 14) {
#line 108
      goto case_14;
    }
#line 110
    if (yy_act == 15) {
#line 110
      goto case_15;
    }
#line 111
    if (yy_act == 16) {
#line 111
      goto case_16;
    }
#line 112
    if (yy_act == 17) {
#line 112
      goto case_17;
    }
#line 114
    if (yy_act == 18) {
#line 114
      goto case_18;
    }
#line 115
    if (yy_act == 19) {
#line 115
      goto case_19;
    }
#line 136
    if (yy_act == 20) {
#line 136
      goto case_20;
    }
#line 140
    if (yy_act == 21) {
#line 140
      goto case_21;
    }
#line 142
    if (yy_act == 22) {
#line 142
      goto case_22;
    }
#line 146
    if (yy_act == 27) {
#line 146
      goto case_27;
    }
#line 146
    if (yy_act == 26) {
#line 146
      goto case_27;
    }
#line 150
    if (yy_act == 23) {
#line 150
      goto case_23;
    }
#line 1194
    if (yy_act == 24) {
#line 1194 "scan-skel.c"
      goto case_24;
    }
#line 1318
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1016
    *yy_cp = yy_hold_char;
#line 1017
    yy_cp = yy_last_accepting_cpos;
#line 1018
    yy_current_state = yy_last_accepting_state;
#line 1019
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 73 "scan-skel.l"
    fputc_unlocked('@', skel_out);
    }
#line 74
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 74
    fputc_unlocked('[', skel_out);
    }
#line 75
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 75
    fputc_unlocked(']', skel_out);
    }
#line 76
    goto switch_break;
    case_4: /* CIL Label */ 
#line 77
    goto switch_break;
    case_5: /* CIL Label */ 
#line 78
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 79
    fprintf((FILE */* __restrict  */)skel_out, (char const   */* __restrict  */)"%d",
            out_lineno + 1);
    }
#line 80
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 80
    tmp___0 = quotearg_style((enum quoting_style )3, (char const   *)outname);
#line 80
    fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)skel_out);
    }
#line 81
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 81
    tmp___1 = quotearg_style((enum quoting_style )3, (char const   *)dir_prefix);
#line 81
    fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)skel_out);
    }
#line 82
    goto switch_break;
    case_9: /* CIL Label */ 
#line 84
    *(skel_text + (skel_leng - 1)) = (char )'\000';
#line 85
    __o = & obstack_for_string;
#line 85
    __len = skel_leng;
#line 85
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 85
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 85
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)skel_text,
           (size_t )__len);
#line 85
    __o->next_free += __len;
#line 86
    tmp___2 = at_directive_argc;
#line 86
    at_directive_argc ++;
#line 87
    __o1 = & obstack_for_string;
#line 87
    __value = (void *)__o1->object_base;
    }
#line 87
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 87
      __o1->maybe_empty_object = 1U;
    }
#line 87
    if (sizeof(int ) < sizeof(void *)) {
#line 87
      tmp___3 = __o1->object_base;
    } else {
#line 87
      tmp___3 = (char *)0;
    }
#line 87
    if (sizeof(int ) < sizeof(void *)) {
#line 87
      tmp___4 = __o1->object_base;
    } else {
#line 87
      tmp___4 = (char *)0;
    }
#line 87
    __o1->next_free = tmp___3 + (((__o1->next_free - tmp___4) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 87
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 87
      __o1->next_free = __o1->chunk_limit;
    }
#line 87
    __o1->object_base = __o1->next_free;
#line 87
    at_directive_argv[tmp___2] = (char *)__value;
#line 88
    yy_start = 3;
#line 90
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 92
    fail_for_invalid_at((char const   *)skel_text);
    }
#line 93
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 93
    out_lineno ++;
#line 93
    fwrite_unlocked((void const   */* __restrict  */)skel_text, (size_t )skel_leng,
                    (size_t )1, (FILE */* __restrict  */)skel_out);
    }
#line 94
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 94
    fwrite_unlocked((void const   */* __restrict  */)skel_text, (size_t )skel_leng,
                    (size_t )1, (FILE */* __restrict  */)skel_out);
    }
#line 95
    goto switch_break;
    case_25: /* CIL Label */ 
#line 97
    if (outname) {
      {
#line 99
      free((void *)outname);
#line 100
      xfclose(skel_out);
      }
    }
#line 102
    return (-1);
#line 104
    goto switch_break;
    case_13: /* CIL Label */ 
#line 106
    __o___0 = & obstack_for_string;
#line 106
    __len___0 = skel_leng;
#line 106
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)skel_text,
           (size_t )__len___0);
#line 106
    __o___0->next_free += __len___0;
    }
#line 107
    goto switch_break;
    case_14: /* CIL Label */ 
#line 108
    __o___1 = & obstack_for_string;
#line 108
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 108
    tmp___5 = __o___1->next_free;
#line 108
    (__o___1->next_free) ++;
#line 108
    *tmp___5 = (char )'@';
#line 109
    goto switch_break;
    case_15: /* CIL Label */ 
#line 109
    __o___2 = & obstack_for_string;
#line 109
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 109
    tmp___6 = __o___2->next_free;
#line 109
    (__o___2->next_free) ++;
#line 109
    *tmp___6 = (char )'[';
#line 110
    goto switch_break;
    case_16: /* CIL Label */ 
#line 110
    __o___3 = & obstack_for_string;
#line 110
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 110
    tmp___7 = __o___3->next_free;
#line 110
    (__o___3->next_free) ++;
#line 110
    *tmp___7 = (char )']';
#line 111
    goto switch_break;
    case_17: /* CIL Label */ 
#line 113
    goto switch_break;
    case_18: /* CIL Label */ 
#line 114
    goto switch_break;
    case_19: /* CIL Label */ 
#line 116
    if (at_directive_argc >= 8) {
      {
#line 117
      fail_for_at_directive_too_many_args((char const   *)at_directive_argv[0]);
      }
    }
#line 119
    __o___4 = & obstack_for_string;
#line 119
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 119
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 119
    tmp___8 = __o___4->next_free;
#line 119
    (__o___4->next_free) ++;
#line 119
    *tmp___8 = (char )'\000';
#line 120
    tmp___9 = at_directive_argc;
#line 120
    at_directive_argc ++;
#line 121
    __o1___0 = & obstack_for_string;
#line 121
    __value___0 = (void *)__o1___0->object_base;
#line 121
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 121
      __o1___0->maybe_empty_object = 1U;
    }
#line 121
    if (sizeof(int ) < sizeof(void *)) {
#line 121
      tmp___10 = __o1___0->object_base;
    } else {
#line 121
      tmp___10 = (char *)0;
    }
#line 121
    if (sizeof(int ) < sizeof(void *)) {
#line 121
      tmp___11 = __o1___0->object_base;
    } else {
#line 121
      tmp___11 = (char *)0;
    }
#line 121
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 121
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 121
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 121
    __o1___0->object_base = __o1___0->next_free;
#line 121
    at_directive_argv[tmp___9] = (char *)__value___0;
#line 124
    if ((int )*(skel_text + 1) == 44) {
#line 125
      yy_start = 5;
    } else {
      {
#line 128
      at_directive_perform(at_directive_argc, at_directive_argv, & outname, & out_lineno);
#line 130
      __o___5 = & obstack_for_string;
#line 130
      __obj = (void *)at_directive_argv[0];
      }
#line 130
      if ((unsigned long )__obj > (unsigned long )((void *)__o___5->chunk)) {
#line 130
        if ((unsigned long )__obj < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 130
          tmp___12 = (char *)__obj;
#line 130
          __o___5->object_base = tmp___12;
#line 130
          __o___5->next_free = tmp___12;
        } else {
          {
#line 130
          obstack_free(__o___5, __obj);
          }
        }
      } else {
        {
#line 130
        obstack_free(__o___5, __obj);
        }
      }
#line 131
      at_directive_argc = 0;
#line 132
      yy_start = 1;
    }
#line 135
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 136
    fail_for_invalid_at((char const   *)skel_text);
    }
#line 137
    goto switch_break;
    case_21: /* CIL Label */ 
#line 141
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 141
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 141
      yyless_macro_arg = 0;
#line 141
      *yy_cp = yy_hold_char;
#line 141
      yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 141
      yy_c_buf_p = yy_cp;
#line 141
      skel_text = yy_bp;
#line 141
      skel_leng = (int )((size_t )(yy_cp - yy_bp));
#line 141
      yy_hold_char = *yy_cp;
#line 141
      *yy_cp = (char )'\000';
#line 141
      yy_c_buf_p = yy_cp;
#line 141
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 141
    yy_start = 3;
#line 142
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    {
#line 146
    tmp___13 = gettext("unclosed %s directive in skeleton");
#line 146
    fatal((char const   *)tmp___13, at_directive_argv[0]);
    }
#line 148
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 150
    yy_fatal_error("flex scanner jammed");
    }
#line 151
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1197 "scan-skel.c"
    yy_amount_of_matched_text = (int )(yy_cp - skel_text) - 1;
#line 1200
    *yy_cp = yy_hold_char;
#line 1203
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1214
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1215
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = skel_in;
#line 1216
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1226
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1230
      yy_c_buf_p = skel_text + yy_amount_of_matched_text;
#line 1232
      yy_current_state = yy_get_previous_state();
#line 1243
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1245
      yy_bp = skel_text + 0;
      }
#line 1247
      if (yy_next_state) {
#line 1250
        yy_c_buf_p ++;
#line 1250
        yy_cp = yy_c_buf_p;
#line 1251
        yy_current_state = yy_next_state;
#line 1252
        goto yy_match;
      } else {
#line 1258
        yy_cp = yy_last_accepting_cpos;
#line 1259
        yy_current_state = yy_last_accepting_state;
#line 1260
        goto yy_find_action;
      }
    } else {
      {
#line 1264
      tmp___14 = yy_get_next_buffer();
      }
      {
#line 1266
      if (tmp___14 == 1) {
#line 1266
        goto case_1___0;
      }
#line 1295
      if (tmp___14 == 0) {
#line 1295
        goto case_0___0;
      }
#line 1305
      if (tmp___14 == 2) {
#line 1305
        goto case_2___0;
      }
#line 1264
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1268
      yy_did_buffer_switch_on_eof = 0;
#line 1281
      yy_c_buf_p = skel_text + 0;
#line 1283
      yy_act = (24 + (yy_start - 1) / 2) + 1;
#line 1284
      goto do_action;
#line 1292
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1296
      yy_c_buf_p = skel_text + yy_amount_of_matched_text;
#line 1299
      yy_current_state = yy_get_previous_state();
#line 1301
      yy_cp = yy_c_buf_p;
#line 1302
      yy_bp = skel_text + 0;
      }
#line 1303
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1306
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1309
      yy_current_state = yy_get_previous_state();
#line 1311
      yy_cp = yy_c_buf_p;
#line 1312
      yy_bp = skel_text + 0;
      }
#line 1313
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1315
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1319
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1341 "scan-skel.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1346
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1347
  source = skel_text;
#line 1351
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1352
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1355
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1357
    if (yy_c_buf_p - skel_text == 1L) {
#line 1362
      return (1);
    } else {
#line 1370
      return (2);
    }
  }
#line 1377
  number_to_move = (int )(yy_c_buf_p - skel_text) - 1;
#line 1379
  i = 0;
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1379
    if (! (i < number_to_move)) {
#line 1379
      goto while_break;
    }
#line 1380
    tmp = dest;
#line 1380
    dest ++;
#line 1380
    tmp___0 = source;
#line 1380
    source ++;
#line 1380
    *tmp = *tmp___0;
#line 1379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1386
    yy_n_chars = 0;
#line 1386
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1390
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1393
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1393
      if (! (num_to_read <= 0)) {
#line 1393
        goto while_break___0;
      }
#line 1397
      if (yy_buffer_stack) {
#line 1397
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1397
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1397
      b = tmp___1;
#line 1399
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1402
      if (b->yy_is_our_buffer) {
#line 1404
        new_size = (int )(b->yy_buf_size * 2U);
#line 1406
        if (new_size <= 0) {
#line 1407
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1409
          b->yy_buf_size *= 2U;
        }
        {
#line 1411
        tmp___2 = skel_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1411
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1417
        b->yy_ch_buf = (char *)0;
      }
#line 1419
      if (! b->yy_ch_buf) {
        {
#line 1420
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1423
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1425
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1430
    if (num_to_read > 8192) {
#line 1431
      num_to_read = 8192;
    }
#line 1434
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1434
      c = '*';
#line 1434
      n = 0;
      {
#line 1434
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1434
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1434
          c = getc_unlocked(skel_in);
          }
#line 1434
          if (c != -1) {
#line 1434
            if (! (c != 10)) {
#line 1434
              goto while_break___1;
            }
          } else {
#line 1434
            goto while_break___1;
          }
        } else {
#line 1434
          goto while_break___1;
        }
#line 1434
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1434
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1434
      if (c == 10) {
#line 1434
        tmp___3 = n;
#line 1434
        n ++;
#line 1434
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1434
      if (c == -1) {
        {
#line 1434
        tmp___4 = ferror_unlocked(skel_in);
        }
#line 1434
        if (tmp___4) {
          {
#line 1434
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1434
      yy_n_chars = n;
    } else {
      {
#line 1434
      tmp___5 = __errno_location();
#line 1434
      *tmp___5 = 0;
      }
      {
#line 1434
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1434
        tmp___8 = fread_unlocked((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                                 (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)skel_in);
#line 1434
        yy_n_chars = (int )tmp___8;
        }
#line 1434
        if (yy_n_chars == 0) {
          {
#line 1434
          tmp___9 = ferror_unlocked(skel_in);
          }
#line 1434
          if (! tmp___9) {
#line 1434
            goto while_break___2;
          }
        } else {
#line 1434
          goto while_break___2;
        }
        {
#line 1434
        tmp___6 = __errno_location();
        }
#line 1434
        if (*tmp___6 != 4) {
          {
#line 1434
          yy_fatal_error("input in flex scanner failed");
          }
#line 1434
          goto while_break___2;
        }
        {
#line 1434
        tmp___7 = __errno_location();
#line 1434
        *tmp___7 = 0;
#line 1434
        clearerr_unlocked(skel_in);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1437
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1440
  if (yy_n_chars == 0) {
#line 1442
    if (number_to_move == 0) {
      {
#line 1444
      ret_val = 1;
#line 1445
      skel_restart(skel_in);
      }
    } else {
#line 1450
      ret_val = 2;
#line 1451
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1457
    ret_val = 0;
  }
#line 1459
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1461
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1462
    tmp___10 = skel_realloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                            new_size___0);
#line 1462
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1463
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1464
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1467
  yy_n_chars += number_to_move;
#line 1468
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1469
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1471
  skel_text = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1473
  return (ret_val);
}
}
#line 1481 "scan-skel.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1490
  yy_current_state = yy_start;
#line 1492
  yy_cp = skel_text + 0;
  {
#line 1492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1492
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1492
      goto while_break;
    }
#line 1495
    if (*yy_cp) {
#line 1495
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1495
      tmp = (flex_int32_t const   )1;
    }
#line 1495
    yy_c = (YY_CHAR )tmp;
#line 1496
    if (yy_accept[yy_current_state]) {
#line 1498
      yy_last_accepting_state = yy_current_state;
#line 1499
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1501
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1501
        goto while_break___0;
      }
#line 1503
      yy_current_state = (int )yy_def[yy_current_state];
#line 1504
      if (yy_current_state >= 56) {
#line 1505
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1507
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1492
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1510
  return (yy_current_state);
}
}
#line 1519 "scan-skel.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1526
  yy_cp = yy_c_buf_p;
#line 1528
  yy_c = (YY_CHAR )1;
#line 1529
  if (yy_accept[yy_current_state]) {
#line 1531
    yy_last_accepting_state = yy_current_state;
#line 1532
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1534
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1534
      goto while_break;
    }
#line 1536
    yy_current_state = (int )yy_def[yy_current_state];
#line 1537
    if (yy_current_state >= 56) {
#line 1538
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1540
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1541
  yy_is_jam = yy_current_state == 55;
#line 1543
  if (yy_is_jam) {
#line 1543
    tmp = 0;
  } else {
#line 1543
    tmp = yy_current_state;
  }
#line 1543
  return (tmp);
}
}
#line 1638 "scan-skel.c"
void skel_restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1644
  if (yy_buffer_stack) {
#line 1644
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1644
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1644
  if (! tmp) {
    {
#line 1645
    skel_ensure_buffer_stack();
#line 1646
    *(yy_buffer_stack + yy_buffer_stack_top) = skel__create_buffer(skel_in, 16384);
    }
  }
#line 1650
  if (yy_buffer_stack) {
#line 1650
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1650
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1650
  skel__init_buffer(tmp___0, input_file);
#line 1651
  skel__load_buffer_state();
  }
#line 1652
  return;
}
}
#line 1659 "scan-skel.c"
void skel__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1670
  skel_ensure_buffer_stack();
  }
#line 1671
  if (yy_buffer_stack) {
#line 1671
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1671
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1671
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1672
    return;
  }
#line 1674
  if (yy_buffer_stack) {
#line 1674
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1674
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1674
  if (tmp___0) {
#line 1677
    *yy_c_buf_p = yy_hold_char;
#line 1678
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1679
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1682
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1683
  skel__load_buffer_state();
#line 1690
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1691
  return;
}
}
#line 1694 "scan-skel.c"
static void skel__load_buffer_state(void) 
{ 


  {
#line 1699
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1700
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1700
  skel_text = yy_c_buf_p;
#line 1701
  skel_in = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1702
  yy_hold_char = *yy_c_buf_p;
#line 1703
  return;
}
}
#line 1712 "scan-skel.c"
YY_BUFFER_STATE skel__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1719
  tmp = skel_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1719
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1720
  if (! b) {
    {
#line 1721
    yy_fatal_error("out of dynamic memory in skel__create_buffer()");
    }
  }
  {
#line 1723
  b->yy_buf_size = (yy_size_t )size;
#line 1728
  tmp___0 = skel_alloc(b->yy_buf_size + 2U);
#line 1728
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1729
  if (! b->yy_ch_buf) {
    {
#line 1730
    yy_fatal_error("out of dynamic memory in skel__create_buffer()");
    }
  }
  {
#line 1732
  b->yy_is_our_buffer = 1;
#line 1734
  skel__init_buffer(b, file);
  }
#line 1736
  return (b);
}
}
#line 1744 "scan-skel.c"
void skel__delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1750
  if (! b) {
#line 1751
    return;
  }
#line 1753
  if (yy_buffer_stack) {
#line 1753
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1753
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1753
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1754
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1756
  if (b->yy_is_our_buffer) {
    {
#line 1757
    skel_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1759
  skel_free((void *)b);
  }
#line 1760
  return;
}
}
#line 1774 "scan-skel.c"
static void skel__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1780
  tmp = __errno_location();
#line 1780
  oerrno = *tmp;
#line 1782
  skel__flush_buffer(b);
#line 1784
  b->yy_input_file = file;
#line 1785
  b->yy_fill_buffer = 1;
  }
#line 1791
  if (yy_buffer_stack) {
#line 1791
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1791
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1791
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1792
    b->yy_bs_lineno = 1;
#line 1793
    b->yy_bs_column = 0;
  }
  {
#line 1798
  b->yy_is_interactive = 0;
#line 1803
  tmp___1 = __errno_location();
#line 1803
  *tmp___1 = oerrno;
  }
#line 1804
  return;
}
}
#line 1811 "scan-skel.c"
void skel__flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1816
  if (! b) {
#line 1817
    return;
  }
#line 1819
  b->yy_n_chars = 0;
#line 1825
  *(b->yy_ch_buf + 0) = (char)0;
#line 1826
  *(b->yy_ch_buf + 1) = (char)0;
#line 1828
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1830
  b->yy_at_bol = 1;
#line 1831
  b->yy_buffer_status = 0;
#line 1833
  if (yy_buffer_stack) {
#line 1833
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1833
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1833
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1834
    skel__load_buffer_state();
    }
  }
#line 1835
  return;
}
}
#line 1845 "scan-skel.c"
void skel_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1850
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1851
    return;
  }
  {
#line 1853
  skel_ensure_buffer_stack();
  }
#line 1856
  if (yy_buffer_stack) {
#line 1856
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1856
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1856
  if (tmp) {
#line 1859
    *yy_c_buf_p = yy_hold_char;
#line 1860
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1861
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1865
  if (yy_buffer_stack) {
#line 1865
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1865
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1865
  if (tmp___0) {
#line 1866
    yy_buffer_stack_top ++;
  }
  {
#line 1867
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1870
  skel__load_buffer_state();
#line 1871
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1872
  return;
}
}
#line 1881 "scan-skel.c"
void skel_pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1886
  if (yy_buffer_stack) {
#line 1886
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1886
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1886
  if (! tmp) {
#line 1887
    return;
  }
#line 1889
  if (yy_buffer_stack) {
#line 1889
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1889
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1889
  skel__delete_buffer(tmp___0);
#line 1890
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1891
  if (yy_buffer_stack_top > 0U) {
#line 1892
    yy_buffer_stack_top --;
  }
#line 1894
  if (yy_buffer_stack) {
#line 1894
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1894
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1894
  if (tmp___1) {
    {
#line 1895
    skel__load_buffer_state();
#line 1896
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1898
  return;
}
}
#line 1906 "scan-skel.c"
static void skel_ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1913
  if (! yy_buffer_stack) {
    {
#line 1919
    num_to_alloc = 1;
#line 1920
    tmp = skel_alloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1920
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1923
    if (! yy_buffer_stack) {
      {
#line 1924
      yy_fatal_error("out of dynamic memory in skel_ensure_buffer_stack()");
      }
    }
    {
#line 1926
    memset((void *)yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1928
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1929
    yy_buffer_stack_top = (size_t )0;
    }
#line 1930
    return;
  }
#line 1933
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
    {
#line 1936
    grow_size = 8;
#line 1938
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1939
    tmp___0 = skel_realloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1939
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1943
    if (! yy_buffer_stack) {
      {
#line 1944
      yy_fatal_error("out of dynamic memory in skel_ensure_buffer_stack()");
      }
    }
    {
#line 1947
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1948
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1950
  return;
}
}
#line 1960 "scan-skel.c"
YY_BUFFER_STATE skel__scan_buffer(char *base___0 , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1964
  if (size < 2U) {
#line 1968
    return ((YY_BUFFER_STATE )0);
  } else
#line 1964
  if ((int )*(base___0 + (size - 2U)) != 0) {
#line 1968
    return ((YY_BUFFER_STATE )0);
  } else
#line 1964
  if ((int )*(base___0 + (size - 1U)) != 0) {
#line 1968
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1970
  tmp = skel_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1970
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1971
  if (! b) {
    {
#line 1972
    yy_fatal_error("out of dynamic memory in skel__scan_buffer()");
    }
  }
  {
#line 1974
  b->yy_buf_size = size - 2U;
#line 1975
  tmp___0 = base___0;
#line 1975
  b->yy_ch_buf = tmp___0;
#line 1975
  b->yy_buf_pos = tmp___0;
#line 1976
  b->yy_is_our_buffer = 0;
#line 1977
  b->yy_input_file = (FILE *)0;
#line 1978
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1979
  b->yy_is_interactive = 0;
#line 1980
  b->yy_at_bol = 1;
#line 1981
  b->yy_fill_buffer = 0;
#line 1982
  b->yy_buffer_status = 0;
#line 1984
  skel__switch_to_buffer(b);
  }
#line 1986
  return (b);
}
}
#line 1999 "scan-skel.c"
YY_BUFFER_STATE skel__scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2002
  tmp = strlen(yystr);
#line 2002
  tmp___0 = skel__scan_bytes(yystr, (int )tmp);
  }
#line 2002
  return (tmp___0);
}
}
#line 2014 "scan-skel.c"
YY_BUFFER_STATE skel__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2022
  n = (yy_size_t )(_yybytes_len + 2);
#line 2023
  tmp = skel_alloc(n);
#line 2023
  buf___0 = (char *)tmp;
  }
#line 2024
  if (! buf___0) {
    {
#line 2025
    yy_fatal_error("out of dynamic memory in skel__scan_bytes()");
    }
  }
#line 2027
  i = 0;
  {
#line 2027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2027
    if (! (i < _yybytes_len)) {
#line 2027
      goto while_break;
    }
#line 2028
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2027
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2030
  tmp___0 = (char)0;
#line 2030
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 2030
  *(buf___0 + _yybytes_len) = tmp___0;
#line 2032
  b = skel__scan_buffer(buf___0, n);
  }
#line 2033
  if (! b) {
    {
#line 2034
    yy_fatal_error("bad buffer in skel__scan_bytes()");
    }
  }
#line 2039
  b->yy_is_our_buffer = 1;
#line 2041
  return (b);
}
}
#line 2050 "scan-skel.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2052
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2053
  exit(2);
  }
}
}
#line 2085 "scan-skel.c"
int skel_get_lineno(void) 
{ 


  {
#line 2088
  return (skel_lineno);
}
}
#line 2094 "scan-skel.c"
FILE *skel_get_in(void) 
{ 


  {
#line 2096
  return (skel_in);
}
}
#line 2102 "scan-skel.c"
FILE *skel_get_out(void) 
{ 


  {
#line 2104
  return (skel_out);
}
}
#line 2110 "scan-skel.c"
int skel_get_leng(void) 
{ 


  {
#line 2112
  return (skel_leng);
}
}
#line 2119 "scan-skel.c"
char *skel_get_text(void) 
{ 


  {
#line 2121
  return (skel_text);
}
}
#line 2131 "scan-skel.c"
void skel_set_lineno(int line_number ) 
{ 


  {
#line 2134
  skel_lineno = line_number;
#line 2135
  return;
}
}
#line 2143 "scan-skel.c"
void skel_set_in(FILE *in_str ) 
{ 


  {
#line 2145
  skel_in = in_str;
#line 2146
  return;
}
}
#line 2148 "scan-skel.c"
void skel_set_out(FILE *out_str ) 
{ 


  {
#line 2150
  skel_out = out_str;
#line 2151
  return;
}
}
#line 2153 "scan-skel.c"
int skel_get_debug(void) 
{ 


  {
#line 2155
  return (skel__flex_debug);
}
}
#line 2158 "scan-skel.c"
void skel_set_debug(int bdebug ) 
{ 


  {
#line 2160
  skel__flex_debug = bdebug;
#line 2161
  return;
}
}
#line 2171 "scan-skel.c"
static int yy_init_globals(void) 
{ 


  {
#line 2177
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2178
  yy_buffer_stack_top = (size_t )0;
#line 2179
  yy_buffer_stack_max = (size_t )0;
#line 2180
  yy_c_buf_p = (char *)0;
#line 2181
  yy_init = 0;
#line 2182
  yy_start = 0;
#line 2189
  skel_in = (FILE *)0;
#line 2190
  skel_out = (FILE *)0;
#line 2196
  return (0);
}
}
#line 2202 "scan-skel.c"
int skel_lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2206
    if (yy_buffer_stack) {
#line 2206
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2206
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2206
    if (! tmp___0) {
#line 2206
      goto while_break;
    }
#line 2207
    if (yy_buffer_stack) {
#line 2207
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2207
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2207
    skel__delete_buffer(tmp);
#line 2208
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2209
    skel_pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2213
  skel_free((void *)yy_buffer_stack);
#line 2214
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2218
  yy_init_globals();
  }
#line 2222
  return (0);
}
}
#line 2250 "scan-skel.c"
void *skel_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2252
  tmp = malloc(size);
  }
#line 2252
  return (tmp);
}
}
#line 2255 "scan-skel.c"
void *skel_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2264
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2264
  return (tmp);
}
}
#line 2267 "scan-skel.c"
void skel_free(void *ptr ) 
{ 


  {
  {
#line 2269
  free((void *)((char *)ptr));
  }
#line 2270
  return;
}
}
#line 160 "scan-skel.l"
static _Bool initialized  =    (_Bool)0;
#line 157 "scan-skel.l"
void scan_skel(FILE *in ) 
{ 


  {
#line 161
  if (! initialized) {
    {
#line 163
    initialized = (_Bool)1;
#line 164
    _obstack_begin(& obstack_for_string, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
  {
#line 166
  skel_in = in;
#line 167
  skel__flex_debug = trace_flag & 512;
#line 168
  skel_lex();
  }
#line 169
  return;
}
}
#line 171 "scan-skel.l"
void skel_scanner_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 174
  __o = & obstack_for_string;
#line 174
  __obj = (void *)0;
#line 174
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 174
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 174
      tmp = (char *)__obj;
#line 174
      __o->object_base = tmp;
#line 174
      __o->next_free = tmp;
    } else {
      {
#line 174
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 174
    obstack_free(__o, __obj);
    }
  }
  {
#line 176
  skel_lex_destroy();
  }
#line 177
  return;
}
}
#line 179 "scan-skel.l"
static void at_directive_perform(int at_directive_argc , char **at_directive_argv ,
                                 char **outnamep , int *out_linenop ) 
{ 
  char *tmp ;
  void (*func)(char const   *  , ...) ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void (*func___0)(location  , char const   *  , ...) ;
  location loc___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 184
  tmp___17 = strcmp((char const   *)*(at_directive_argv + 0), "@basename");
  }
#line 184
  if (0 == tmp___17) {
#line 186
    if (at_directive_argc > 2) {
      {
#line 187
      fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
      }
    }
    {
#line 188
    tmp = last_component((char const   *)*(at_directive_argv + 1));
#line 188
    fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)skel_out);
    }
  } else {
    {
#line 190
    tmp___14 = strcmp((char const   *)*(at_directive_argv + 0), "@warn");
    }
#line 190
    if (0 == tmp___14) {
#line 190
      goto _L___0;
    } else {
      {
#line 190
      tmp___15 = strcmp((char const   *)*(at_directive_argv + 0), "@complain");
      }
#line 190
      if (0 == tmp___15) {
#line 190
        goto _L___0;
      } else {
        {
#line 190
        tmp___16 = strcmp((char const   *)*(at_directive_argv + 0), "@fatal");
        }
#line 190
        if (0 == tmp___16) {
          _L___0: /* CIL Label */ 
          {
#line 197
          if ((int )*(*(at_directive_argv + 0) + 1) == 119) {
#line 197
            goto case_119;
          }
#line 198
          if ((int )*(*(at_directive_argv + 0) + 1) == 99) {
#line 198
            goto case_99;
          }
#line 199
          if ((int )*(*(at_directive_argv + 0) + 1) == 102) {
#line 199
            goto case_102;
          }
#line 200
          goto switch_default;
          case_119: /* CIL Label */ 
#line 197
          func = (void (*)(char const   *  , ...))(& warn);
#line 197
          goto switch_break;
          case_99: /* CIL Label */ 
#line 198
          func = (void (*)(char const   *  , ...))(& complain);
#line 198
          goto switch_break;
          case_102: /* CIL Label */ 
#line 199
          func = (void (*)(char const   *  , ...))(& fatal);
#line 199
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 200
          aver((_Bool)0);
          }
#line 200
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          {
#line 204
          if (at_directive_argc == 2) {
#line 204
            goto case_2;
          }
#line 207
          if (at_directive_argc == 3) {
#line 207
            goto case_3;
          }
#line 210
          if (at_directive_argc == 4) {
#line 210
            goto case_4;
          }
#line 214
          if (at_directive_argc == 5) {
#line 214
            goto case_5;
          }
#line 218
          if (at_directive_argc == 6) {
#line 218
            goto case_6;
          }
#line 223
          goto switch_default___0;
          case_2: /* CIL Label */ 
          {
#line 205
          tmp___0 = gettext((char const   *)*(at_directive_argv + 1));
#line 205
          (*func)((char const   *)tmp___0);
          }
#line 206
          goto switch_break___0;
          case_3: /* CIL Label */ 
          {
#line 208
          tmp___1 = gettext((char const   *)*(at_directive_argv + 1));
#line 208
          (*func)((char const   *)tmp___1, *(at_directive_argv + 2));
          }
#line 209
          goto switch_break___0;
          case_4: /* CIL Label */ 
          {
#line 211
          tmp___2 = gettext((char const   *)*(at_directive_argv + 1));
#line 211
          (*func)((char const   *)tmp___2, *(at_directive_argv + 2), *(at_directive_argv + 3));
          }
#line 213
          goto switch_break___0;
          case_5: /* CIL Label */ 
          {
#line 215
          tmp___3 = gettext((char const   *)*(at_directive_argv + 1));
#line 215
          (*func)((char const   *)tmp___3, *(at_directive_argv + 2), *(at_directive_argv + 3),
                  *(at_directive_argv + 4));
          }
#line 217
          goto switch_break___0;
          case_6: /* CIL Label */ 
          {
#line 219
          tmp___4 = gettext((char const   *)*(at_directive_argv + 1));
#line 219
          (*func)((char const   *)tmp___4, *(at_directive_argv + 2), *(at_directive_argv + 3),
                  *(at_directive_argv + 4), *(at_directive_argv + 5));
          }
#line 222
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 224
          fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
          }
#line 225
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 228
          tmp___11 = strcmp((char const   *)*(at_directive_argv + 0), "@warn_at");
          }
#line 228
          if (0 == tmp___11) {
#line 228
            goto _L;
          } else {
            {
#line 228
            tmp___12 = strcmp((char const   *)*(at_directive_argv + 0), "@complain_at");
            }
#line 228
            if (0 == tmp___12) {
#line 228
              goto _L;
            } else {
              {
#line 228
              tmp___13 = strcmp((char const   *)*(at_directive_argv + 0), "@fatal_at");
              }
#line 228
              if (0 == tmp___13) {
                _L: /* CIL Label */ 
#line 234
                if (at_directive_argc < 4) {
                  {
#line 235
                  fail_for_at_directive_too_few_args((char const   *)*(at_directive_argv + 0));
                  }
                }
                {
#line 238
                if ((int )*(*(at_directive_argv + 0) + 1) == 119) {
#line 238
                  goto case_119___0;
                }
#line 239
                if ((int )*(*(at_directive_argv + 0) + 1) == 99) {
#line 239
                  goto case_99___0;
                }
#line 240
                if ((int )*(*(at_directive_argv + 0) + 1) == 102) {
#line 240
                  goto case_102___0;
                }
#line 241
                goto switch_default___1;
                case_119___0: /* CIL Label */ 
#line 238
                func___0 = (void (*)(location  , char const   *  , ...))(& warn_at);
#line 238
                goto switch_break___1;
                case_99___0: /* CIL Label */ 
#line 239
                func___0 = (void (*)(location  , char const   *  , ...))(& complain_at);
#line 239
                goto switch_break___1;
                case_102___0: /* CIL Label */ 
#line 240
                func___0 = (void (*)(location  , char const   *  , ...))(& fatal_at);
#line 240
                goto switch_break___1;
                switch_default___1: /* CIL Label */ 
                {
#line 241
                aver((_Bool)0);
                }
#line 241
                goto switch_break___1;
                switch_break___1: /* CIL Label */ ;
                }
                {
#line 243
                boundary_set_from_string(& loc___0.start, *(at_directive_argv + 1));
#line 244
                boundary_set_from_string(& loc___0.end, *(at_directive_argv + 2));
                }
                {
#line 247
                if (at_directive_argc == 4) {
#line 247
                  goto case_4___0;
                }
#line 250
                if (at_directive_argc == 5) {
#line 250
                  goto case_5___0;
                }
#line 253
                if (at_directive_argc == 6) {
#line 253
                  goto case_6___0;
                }
#line 257
                if (at_directive_argc == 7) {
#line 257
                  goto case_7;
                }
#line 261
                if (at_directive_argc == 8) {
#line 261
                  goto case_8;
                }
#line 266
                goto switch_default___2;
                case_4___0: /* CIL Label */ 
                {
#line 248
                tmp___5 = gettext((char const   *)*(at_directive_argv + 3));
#line 248
                (*func___0)(loc___0, (char const   *)tmp___5);
                }
#line 249
                goto switch_break___2;
                case_5___0: /* CIL Label */ 
                {
#line 251
                tmp___6 = gettext((char const   *)*(at_directive_argv + 3));
#line 251
                (*func___0)(loc___0, (char const   *)tmp___6, *(at_directive_argv + 4));
                }
#line 252
                goto switch_break___2;
                case_6___0: /* CIL Label */ 
                {
#line 254
                tmp___7 = gettext((char const   *)*(at_directive_argv + 3));
#line 254
                (*func___0)(loc___0, (char const   *)tmp___7, *(at_directive_argv + 4),
                            *(at_directive_argv + 5));
                }
#line 256
                goto switch_break___2;
                case_7: /* CIL Label */ 
                {
#line 258
                tmp___8 = gettext((char const   *)*(at_directive_argv + 3));
#line 258
                (*func___0)(loc___0, (char const   *)tmp___8, *(at_directive_argv + 4),
                            *(at_directive_argv + 5), *(at_directive_argv + 6));
                }
#line 260
                goto switch_break___2;
                case_8: /* CIL Label */ 
                {
#line 262
                tmp___9 = gettext((char const   *)*(at_directive_argv + 3));
#line 262
                (*func___0)(loc___0, (char const   *)tmp___9, *(at_directive_argv + 4),
                            *(at_directive_argv + 5), *(at_directive_argv + 6), *(at_directive_argv + 7));
                }
#line 265
                goto switch_break___2;
                switch_default___2: /* CIL Label */ 
                {
#line 267
                fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
                }
#line 268
                goto switch_break___2;
                switch_break___2: /* CIL Label */ ;
                }
              } else {
                {
#line 271
                tmp___10 = strcmp((char const   *)*(at_directive_argv + 0), "@output");
                }
#line 271
                if (0 == tmp___10) {
#line 273
                  if (at_directive_argc > 2) {
                    {
#line 274
                    fail_for_at_directive_too_many_args((char const   *)*(at_directive_argv + 0));
                    }
                  }
#line 275
                  if (*outnamep) {
                    {
#line 277
                    free((void *)*outnamep);
#line 278
                    xfclose(skel_out);
                    }
                  }
                  {
#line 280
                  *outnamep = xstrdup((char const   *)*(at_directive_argv + 1));
#line 281
                  output_file_name_check((char const   *)*outnamep);
#line 282
                  skel_out = xfopen((char const   *)*outnamep, "w");
#line 283
                  *out_linenop = 1;
                  }
                } else {
                  {
#line 286
                  fail_for_invalid_at((char const   *)*(at_directive_argv + 0));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 287
  return;
}
}
#line 289 "scan-skel.l"
static void fail_for_at_directive_too_few_args(char const   *at_directive_name ) 
{ 
  char *tmp ;

  {
  {
#line 292
  tmp = gettext("too few arguments for %s directive in skeleton");
#line 292
  fatal((char const   *)tmp, at_directive_name);
  }
}
}
#line 296 "scan-skel.l"
static void fail_for_at_directive_too_many_args(char const   *at_directive_name ) 
{ 
  char *tmp ;

  {
  {
#line 299
  tmp = gettext("too many arguments for %s directive in skeleton");
#line 299
  fatal((char const   *)tmp, at_directive_name);
  }
}
}
#line 303 "scan-skel.l"
static void fail_for_invalid_at(char const   *at ) 
{ 


  {
  {
#line 306
  fatal("invalid @ in skeleton: %s", at);
  }
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 218 "scan-code.c"
int code_leng  ;
#line 223
FILE *code_in ;
#line 223
FILE *code_out ;
#line 330 "scan-code.c"
static size_t yy_buffer_stack_top___0  =    (size_t )0;
#line 331 "scan-code.c"
static size_t yy_buffer_stack_max___0  =    (size_t )0;
#line 332 "scan-code.c"
static YY_BUFFER_STATE *yy_buffer_stack___0  =    (YY_BUFFER_STATE *)0;
#line 359 "scan-code.c"
static char yy_hold_char___0  ;
#line 360 "scan-code.c"
static int yy_n_chars___0  ;
#line 364 "scan-code.c"
static char *yy_c_buf_p___0  =    (char *)0;
#line 365 "scan-code.c"
static int yy_init___0  =    0;
#line 366 "scan-code.c"
static int yy_start___0  =    0;
#line 371 "scan-code.c"
static int yy_did_buffer_switch_on_eof___0  ;
#line 376
void code_restart(FILE *input_file ) ;
#line 377
void code__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 378
YY_BUFFER_STATE code__create_buffer(FILE *file , int size ) ;
#line 379
void code__delete_buffer(YY_BUFFER_STATE b ) ;
#line 380
void code__flush_buffer(YY_BUFFER_STATE b ) ;
#line 381
void code_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 382
void code_pop_buffer_state(void) ;
#line 384
static void code_ensure_buffer_stack(void) ;
#line 385
static void code__load_buffer_state(void) ;
#line 386
static void code__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 390
YY_BUFFER_STATE code__scan_buffer(char *base___0 , yy_size_t size ) ;
#line 391
YY_BUFFER_STATE code__scan_string(char const   *yystr ) ;
#line 392
YY_BUFFER_STATE code__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 396
void *code_alloc(yy_size_t size ) ;
#line 397
void *code_realloc(void *ptr , yy_size_t size ) ;
#line 398
void code_free(void *ptr ) ;
#line 434 "scan-code.c"
FILE *code_in  =    (FILE *)0;
#line 434 "scan-code.c"
FILE *code_out  =    (FILE *)0;
#line 438
int code_lineno ;
#line 440 "scan-code.c"
int code_lineno  =    1;
#line 442 "scan-code.c"
char *code_text  ;
#line 447
static yy_state_type yy_get_previous_state___0(void) ;
#line 448
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 449
static int yy_get_next_buffer___0(void) ;
#line 450
static void yy_fatal_error___0(char const   *msg ) ;
#line 476 "scan-code.c"
static flex_int16_t const   yy_accept___0[68]  = 
#line 476
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )2,      (flex_int16_t const   )23, 
        (flex_int16_t const   )6,      (flex_int16_t const   )23,      (flex_int16_t const   )5,      (flex_int16_t const   )8, 
        (flex_int16_t const   )13,      (flex_int16_t const   )7,      (flex_int16_t const   )23,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )19,      (flex_int16_t const   )20, 
        (flex_int16_t const   )1,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )4, 
        (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )11,      (flex_int16_t const   )0, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0};
#line 487 "scan-code.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 487
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )11,      (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )1, 
        (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )17, 
        (flex_int32_t const   )1,      (flex_int32_t const   )18,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 519 "scan-code.c"
static flex_int32_t const   yy_meta___0[20]  = 
#line 519
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2};
#line 525 "scan-code.c"
static flex_int16_t const   yy_base___0[71]  = 
#line 525
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )84, 
        (flex_int16_t const   )82,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )4, 
        (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )16,      (flex_int16_t const   )28, 
        (flex_int16_t const   )0,      (flex_int16_t const   )43,      (flex_int16_t const   )0,      (flex_int16_t const   )88, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )14,      (flex_int16_t const   )97,      (flex_int16_t const   )8, 
        (flex_int16_t const   )97,      (flex_int16_t const   )55,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )66,      (flex_int16_t const   )97,      (flex_int16_t const   )71,      (flex_int16_t const   )82, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )80,      (flex_int16_t const   )79, 
        (flex_int16_t const   )97,      (flex_int16_t const   )33,      (flex_int16_t const   )36,      (flex_int16_t const   )68, 
        (flex_int16_t const   )97,      (flex_int16_t const   )40,      (flex_int16_t const   )67,      (flex_int16_t const   )48, 
        (flex_int16_t const   )97,      (flex_int16_t const   )69,      (flex_int16_t const   )65,      (flex_int16_t const   )0, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )51,      (flex_int16_t const   )97, 
        (flex_int16_t const   )45,      (flex_int16_t const   )34,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )57,      (flex_int16_t const   )15,      (flex_int16_t const   )59,      (flex_int16_t const   )61, 
        (flex_int16_t const   )63,      (flex_int16_t const   )65,      (flex_int16_t const   )66,      (flex_int16_t const   )28, 
        (flex_int16_t const   )70,      (flex_int16_t const   )0,      (flex_int16_t const   )16,      (flex_int16_t const   )97, 
        (flex_int16_t const   )92,      (flex_int16_t const   )94,      (flex_int16_t const   )0};
#line 536 "scan-code.c"
static flex_int16_t const   yy_def___0[71]  = 
#line 536
  {      (flex_int16_t const   )0,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )11,      (flex_int16_t const   )2,      (flex_int16_t const   )13,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )69,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )70, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )69,      (flex_int16_t const   )70, 
        (flex_int16_t const   )67,      (flex_int16_t const   )30,      (flex_int16_t const   )28,      (flex_int16_t const   )0, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67};
#line 547 "scan-code.c"
static flex_int16_t const   yy_nxt___0[117]  = 
#line 547
  {      (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )67,      (flex_int16_t const   )22, 
        (flex_int16_t const   )67,      (flex_int16_t const   )17,      (flex_int16_t const   )22,      (flex_int16_t const   )67, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )38,      (flex_int16_t const   )39, 
        (flex_int16_t const   )26,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )23, 
        (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )23,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )67, 
        (flex_int16_t const   )20,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )25, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )30,      (flex_int16_t const   )38,      (flex_int16_t const   )39, 
        (flex_int16_t const   )66,      (flex_int16_t const   )31,      (flex_int16_t const   )59,      (flex_int16_t const   )42, 
        (flex_int16_t const   )53,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )27, 
        (flex_int16_t const   )34,      (flex_int16_t const   )29,      (flex_int16_t const   )61,      (flex_int16_t const   )62, 
        (flex_int16_t const   )30,      (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )53, 
        (flex_int16_t const   )35,      (flex_int16_t const   )41,      (flex_int16_t const   )42,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )59, 
        (flex_int16_t const   )42,      (flex_int16_t const   )59,      (flex_int16_t const   )42,      (flex_int16_t const   )61, 
        (flex_int16_t const   )62,      (flex_int16_t const   )67,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )45,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )46, 
        (flex_int16_t const   )49,      (flex_int16_t const   )43,      (flex_int16_t const   )60,      (flex_int16_t const   )58, 
        (flex_int16_t const   )55,      (flex_int16_t const   )54,      (flex_int16_t const   )50,      (flex_int16_t const   )51, 
        (flex_int16_t const   )67,      (flex_int16_t const   )21,      (flex_int16_t const   )52,      (flex_int16_t const   )21, 
        (flex_int16_t const   )53,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )15,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67};
#line 564 "scan-code.c"
static flex_int16_t const   yy_chk___0[117]  = 
#line 564
  {      (flex_int16_t const   )0,      (flex_int16_t const   )70,      (flex_int16_t const   )0,      (flex_int16_t const   )5, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )6,      (flex_int16_t const   )0, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )9,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )5, 
        (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )21, 
        (flex_int16_t const   )57,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )66, 
        (flex_int16_t const   )2,      (flex_int16_t const   )21,      (flex_int16_t const   )57,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )11,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )63,      (flex_int16_t const   )11,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )53,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )13,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )52, 
        (flex_int16_t const   )13,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )25,      (flex_int16_t const   )28, 
        (flex_int16_t const   )64,      (flex_int16_t const   )64,      (flex_int16_t const   )28,      (flex_int16_t const   )46, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )45, 
        (flex_int16_t const   )30,      (flex_int16_t const   )62,      (flex_int16_t const   )42,      (flex_int16_t const   )39, 
        (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )15,      (flex_int16_t const   )4,      (flex_int16_t const   )31,      (flex_int16_t const   )3, 
        (flex_int16_t const   )31,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67};
#line 581 "scan-code.c"
static yy_state_type yy_last_accepting_state___0  ;
#line 582 "scan-code.c"
static char *yy_last_accepting_cpos___0  ;
#line 584
int code__flex_debug ;
#line 585 "scan-code.c"
int code__flex_debug  =    1;
#line 587 "scan-code.c"
static flex_int16_t const   yy_rule_linenum___0[24]  = 
#line 587
  {      (flex_int16_t const   )0,      (flex_int16_t const   )99,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )120,      (flex_int16_t const   )125,      (flex_int16_t const   )130,      (flex_int16_t const   )135, 
        (flex_int16_t const   )139,      (flex_int16_t const   )143,      (flex_int16_t const   )147,      (flex_int16_t const   )155, 
        (flex_int16_t const   )158,      (flex_int16_t const   )162,      (flex_int16_t const   )166,      (flex_int16_t const   )171, 
        (flex_int16_t const   )172,      (flex_int16_t const   )198,      (flex_int16_t const   )202,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )225};
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/flex-scanner.h"
int code_get_lineno(void) ;
#line 26
FILE *code_get_in(void) ;
#line 27
FILE *code_get_out(void) ;
#line 28
int code_get_leng(void) ;
#line 29
char *code_get_text(void) ;
#line 30
void code_set_lineno(int line_number ) ;
#line 31
void code_set_in(FILE *in_str ) ;
#line 32
void code_set_out(FILE *out_str ) ;
#line 33
int code_get_debug(void) ;
#line 34
void code_set_debug(int bdebug ) ;
#line 35
int code_lex_destroy(void) ;
#line 74 "/home/pronto/abs/test-suite/bison-2.4/src/flex-scanner.h"
static struct obstack obstack_for_string___0  ;
#line 77 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
void location_compute(location *loc___0 , boundary *cur , char const   *token , size_t size ) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/src/scan-code.h"
int max_left_semantic_context ;
#line 96
void code_props_plain_init(code_props *self , char const   *code , location code_loc ) ;
#line 131
void code_props_rule_action_init(code_props *self , char const   *code , location code_loc ,
                                 struct symbol_list *rule ) ;
#line 156
void code_scanner_last_string_free(void) ;
#line 166
void code_scanner_free(void) ;
#line 59 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
_Bool union_seen ;
#line 62
_Bool tag_seen ;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern _Bool locations_flag ;
#line 43
extern _Bool yacc_flag ;
#line 44 "scan-code.l"
static char *code_lex(code_props *self , int sc_context ) ;
#line 48
static void handle_action_dollar(symbol_list *rule , char *text , location dollar_loc ) ;
#line 50
static void handle_action_at(symbol_list *rule , char *text , location at_loc ) ;
#line 51 "scan-code.l"
static location the_location  ;
#line 52 "scan-code.l"
static location *loc  =    & the_location;
#line 55 "scan-code.l"
static char *code_last_string  ;
#line 58 "scan-code.l"
static _Bool untyped_var_seen  ;
#line 699 "scan-code.c"
static int yy_init_globals___0(void) ;
#line 908 "scan-code.c"
static char *code_lex(code_props *self , int sc_context ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int braces_level ;
  int tmp ;
  YY_BUFFER_STATE tmp___0 ;
  register YY_CHAR yy_c ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  struct obstack *__o___4 ;
  int __len___4 ;
  struct obstack *__o___5 ;
  int __len___5 ;
  struct obstack *__o___6 ;
  int __len___6 ;
  struct obstack *__o___7 ;
  int __len___7 ;
  struct obstack *__o___8 ;
  int __len___8 ;
  char *tmp___1 ;
  struct obstack *__o___9 ;
  int __len___9 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o___10 ;
  int __len___10 ;
  size_t tmp___4 ;
  struct obstack *__o___11 ;
  int __len___11 ;
  _Bool outer_brace ;
  struct obstack *__o___12 ;
  char *tmp___5 ;
  struct obstack *__o___13 ;
  int __len___12 ;
  struct obstack *__o___14 ;
  int __len___13 ;
  size_t tmp___6 ;
  struct obstack *__o___15 ;
  int __len___14 ;
  size_t tmp___7 ;
  struct obstack *__o___16 ;
  int __len___15 ;
  size_t tmp___8 ;
  struct obstack *__o___17 ;
  int __len___16 ;
  size_t tmp___9 ;
  struct obstack *__o___18 ;
  int __len___17 ;
  size_t tmp___10 ;
  struct obstack *__o___19 ;
  int __len___18 ;
  size_t tmp___11 ;
  struct obstack *__o___20 ;
  int __len___19 ;
  struct obstack *__o___21 ;
  char *tmp___12 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___13 ;
  char *tmp___14 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___15 ;

  {
#line 82 "scan-code.l"
  braces_level = 0;
#line 87
  if (sc_context == 6) {
#line 87
    tmp = 1;
  } else
#line 87
  if (sc_context == 5) {
#line 87
    tmp = 1;
  } else
#line 87
  if (sc_context == 0) {
#line 87
    tmp = 1;
  } else {
#line 87
    tmp = 0;
  }
  {
#line 87
  aver((_Bool )tmp);
#line 90
  yy_start___0 = 1 + 2 * sc_context;
  }
#line 937
  if (! yy_init___0) {
#line 939 "scan-code.c"
    yy_init___0 = 1;
#line 945
    if (! yy_start___0) {
#line 946
      yy_start___0 = 1;
    }
#line 948
    if (! code_in) {
#line 950
      code_in = stdin;
    }
#line 955
    if (! code_out) {
#line 957
      code_out = stdout;
    }
#line 962
    if (yy_buffer_stack___0) {
#line 962
      tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 962
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 962
    if (! tmp___0) {
      {
#line 963
      code_ensure_buffer_stack();
#line 964
      *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = code__create_buffer(code_in,
                                                                             16384);
      }
    }
    {
#line 968
    code__load_buffer_state();
    }
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    yy_cp = yy_c_buf_p___0;
#line 977
    *yy_cp = yy_hold_char___0;
#line 982
    yy_bp = yy_cp;
#line 985
    yy_current_state = yy_start___0;
    yy_match: 
    {
#line 987
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 989
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
#line 990
      if (yy_accept___0[yy_current_state]) {
#line 992
        yy_last_accepting_state___0 = yy_current_state;
#line 993
        yy_last_accepting_cpos___0 = yy_cp;
      }
      {
#line 995
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 995
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 995
          goto while_break___1;
        }
#line 997
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 998
        if (yy_current_state >= 68) {
#line 999
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1001
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1002
      yy_cp ++;
#line 987
      if (! (yy_current_state != 67)) {
#line 987
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1005
    yy_cp = yy_last_accepting_cpos___0;
#line 1006
    yy_current_state = yy_last_accepting_state___0;
    yy_find_action: 
#line 1010
    yy_act = (int )yy_accept___0[yy_current_state];
#line 1012
    code_text = yy_bp;
#line 1012
    code_leng = (int )((size_t )(yy_cp - yy_bp));
#line 1012
    yy_hold_char___0 = *yy_cp;
#line 1012
    *yy_cp = (char )'\000';
#line 1012
    yy_c_buf_p___0 = yy_cp;
    do_action: 
#line 1019
    if (code__flex_debug) {
#line 1021
      if (yy_act == 0) {
        {
#line 1022
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 1023
      if (yy_act < 24) {
        {
#line 1024
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_rule_linenum___0[yy_act], code_text);
        }
      } else
#line 1026
      if (yy_act == 24) {
        {
#line 1027
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                code_text);
        }
      } else
#line 1029
      if (yy_act == 25) {
        {
#line 1030
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1032
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_start___0 - 1) / 2);
        }
      }
    }
    {
#line 1038
    if (yy_act == 0) {
#line 1038
      goto case_0;
    }
#line 1045
    if (yy_act == 1) {
#line 1045
      goto case_1;
    }
#line 107
    if (yy_act == 2) {
#line 107 "scan-code.l"
      goto case_2;
    }
#line 111
    if (yy_act == 3) {
#line 111
      goto case_3;
    }
#line 118
    if (yy_act == 4) {
#line 118
      goto case_4;
    }
#line 125
    if (yy_act == 5) {
#line 125
      goto case_5;
    }
#line 130
    if (yy_act == 6) {
#line 130
      goto case_6;
    }
#line 134
    if (yy_act == 7) {
#line 134
      goto case_7;
    }
#line 140
    if (yy_act == 8) {
#line 140
      goto case_8;
    }
#line 144
    if (yy_act == 9) {
#line 144
      goto case_9;
    }
#line 148
    if (yy_act == 10) {
#line 148
      goto case_10;
    }
#line 155
    if (yy_act == 11) {
#line 155
      goto case_11;
    }
#line 159
    if (yy_act == 12) {
#line 159
      goto case_12;
    }
#line 162
    if (yy_act == 13) {
#line 162
      goto case_13;
    }
#line 167
    if (yy_act == 14) {
#line 167
      goto case_14;
    }
#line 171
    if (yy_act == 15) {
#line 171
      goto case_15;
    }
#line 173
    if (yy_act == 16) {
#line 173
      goto case_16;
    }
#line 198
    if (yy_act == 17) {
#line 198
      goto case_17;
    }
#line 203
    if (yy_act == 18) {
#line 203
      goto case_18;
    }
#line 213
    if (yy_act == 19) {
#line 213
      goto case_19;
    }
#line 217
    if (yy_act == 20) {
#line 217
      goto case_20;
    }
#line 218
    if (yy_act == 21) {
#line 218
      goto case_21;
    }
#line 219
    if (yy_act == 22) {
#line 219
      goto case_22;
    }
#line 224
    if (yy_act == 23) {
#line 224
      goto case_23;
    }
#line 234
    if (yy_act == 32) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 31) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 30) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 29) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 28) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 27) {
#line 234
      goto case_32;
    }
#line 234
    if (yy_act == 26) {
#line 234
      goto case_32;
    }
#line 233
    if (yy_act == 24) {
#line 233
      goto case_24;
    }
#line 1273
    if (yy_act == 25) {
#line 1273 "scan-code.c"
      goto case_25;
    }
#line 1397
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1040
    *yy_cp = yy_hold_char___0;
#line 1041
    yy_cp = yy_last_accepting_cpos___0;
#line 1042
    yy_current_state = yy_last_accepting_state___0;
#line 1043
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 1047
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 99 "scan-code.l"
    __o = & obstack_for_string___0;
#line 99
    __len = code_leng;
    }
#line 99
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 99
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 99
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len);
#line 99
    __o->next_free += __len;
#line 99
    yy_start___0 = 1 + 2 * sc_context;
    }
#line 100
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 109
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 109
    __o___0 = & obstack_for_string___0;
#line 109
    __len___0 = code_leng;
    }
#line 109
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 109
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 109
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___0);
#line 109
    __o___0->next_free += __len___0;
#line 109
    yy_start___0 = 1 + 2 * sc_context;
    }
#line 110
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 113
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 110
    __o___1 = & obstack_for_string___0;
#line 110
    __len___1 = code_leng;
    }
#line 110
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 110
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 110
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___1);
#line 110
    __o___1->next_free += __len___1;
    }
#line 111
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 120
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 120
    __o___2 = & obstack_for_string___0;
#line 120
    __len___2 = code_leng;
    }
#line 120
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 120
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 120
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___2);
#line 120
    __o___2->next_free += __len___2;
    }
#line 121
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 126
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 125
    __o___3 = & obstack_for_string___0;
#line 125
    __len___3 = code_leng;
    }
#line 125
    if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
      {
#line 125
      _obstack_newchunk(__o___3, __len___3);
      }
    }
    {
#line 125
    memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___3);
#line 125
    __o___3->next_free += __len___3;
#line 125
    yy_start___0 = 1 + 2 * sc_context;
    }
#line 126
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 131
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 130
    __o___4 = & obstack_for_string___0;
#line 130
    __len___4 = code_leng;
    }
#line 130
    if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
      {
#line 130
      _obstack_newchunk(__o___4, __len___4);
      }
    }
    {
#line 130
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___4);
#line 130
    __o___4->next_free += __len___4;
#line 130
    yy_start___0 = 1 + 2 * sc_context;
    }
#line 131
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 135
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 136
    __o___5 = & obstack_for_string___0;
#line 136
    __len___5 = code_leng;
    }
#line 136
    if ((unsigned long )(__o___5->next_free + __len___5) > (unsigned long )__o___5->chunk_limit) {
      {
#line 136
      _obstack_newchunk(__o___5, __len___5);
      }
    }
    {
#line 136
    memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___5);
#line 136
    __o___5->next_free += __len___5;
#line 137
    yy_start___0 = 9;
    }
#line 139
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 141
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 140
    __o___6 = & obstack_for_string___0;
#line 140
    __len___6 = code_leng;
    }
#line 140
    if ((unsigned long )(__o___6->next_free + __len___6) > (unsigned long )__o___6->chunk_limit) {
      {
#line 140
      _obstack_newchunk(__o___6, __len___6);
      }
    }
    {
#line 140
    memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___6);
#line 140
    __o___6->next_free += __len___6;
#line 141
    yy_start___0 = 7;
    }
#line 143
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 146
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 144
    __o___7 = & obstack_for_string___0;
#line 144
    __len___7 = code_leng;
    }
#line 144
    if ((unsigned long )(__o___7->next_free + __len___7) > (unsigned long )__o___7->chunk_limit) {
      {
#line 144
      _obstack_newchunk(__o___7, __len___7);
      }
    }
    {
#line 144
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___7);
#line 144
    __o___7->next_free += __len___7;
#line 145
    yy_start___0 = 3;
    }
#line 147
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 150
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 148
    __o___8 = & obstack_for_string___0;
#line 148
    __len___8 = code_leng;
    }
#line 148
    if ((unsigned long )(__o___8->next_free + __len___8) > (unsigned long )__o___8->chunk_limit) {
      {
#line 148
      _obstack_newchunk(__o___8, __len___8);
      }
    }
    {
#line 148
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___8);
#line 148
    __o___8->next_free += __len___8;
#line 149
    yy_start___0 = 5;
    }
#line 151
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 156
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 156
    handle_action_dollar(self->rule, code_text, *loc);
    }
#line 158
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 160
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 159
    handle_action_at(self->rule, code_text, *loc);
    }
#line 161
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 163
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 163
    tmp___1 = gettext("stray `$\'");
#line 163
    warn_at(*loc, (char const   *)tmp___1);
#line 164
    __o___9 = & obstack_for_string___0;
#line 164
    tmp___2 = strlen("$][");
#line 164
    __len___9 = (int )tmp___2;
    }
#line 164
    if ((unsigned long )(__o___9->next_free + __len___9) > (unsigned long )__o___9->chunk_limit) {
      {
#line 164
      _obstack_newchunk(__o___9, __len___9);
      }
    }
    {
#line 164
    memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)"$][",
           (size_t )__len___9);
#line 164
    __o___9->next_free += __len___9;
    }
#line 166
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 168
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 167
    tmp___3 = gettext("stray `@\'");
#line 167
    warn_at(*loc, (char const   *)tmp___3);
#line 168
    __o___10 = & obstack_for_string___0;
#line 168
    tmp___4 = strlen("@@");
#line 168
    __len___10 = (int )tmp___4;
    }
#line 168
    if ((unsigned long )(__o___10->next_free + __len___10) > (unsigned long )__o___10->chunk_limit) {
      {
#line 168
      _obstack_newchunk(__o___10, __len___10);
      }
    }
    {
#line 168
    memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)"@@",
           (size_t )__len___10);
#line 168
    __o___10->next_free += __len___10;
    }
#line 170
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 172
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 171
    __o___11 = & obstack_for_string___0;
#line 171
    __len___11 = code_leng;
    }
#line 171
    if ((unsigned long )(__o___11->next_free + __len___11) > (unsigned long )__o___11->chunk_limit) {
      {
#line 171
      _obstack_newchunk(__o___11, __len___11);
      }
    }
    {
#line 171
    memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___11);
#line 171
    __o___11->next_free += __len___11;
#line 171
    braces_level ++;
    }
#line 172
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 174
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 173
    braces_level --;
#line 173
    outer_brace = (_Bool )(braces_level < 0);
    }
#line 189
    if (outer_brace) {
#line 189
      if (! yacc_flag) {
#line 190
        __o___12 = & obstack_for_string___0;
#line 190
        if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
          {
#line 190
          _obstack_newchunk(__o___12, 1);
          }
        }
#line 190
        tmp___5 = __o___12->next_free;
#line 190
        (__o___12->next_free) ++;
#line 190
        *tmp___5 = (char )';';
      }
    }
#line 192
    __o___13 = & obstack_for_string___0;
#line 192
    __len___12 = code_leng;
#line 192
    if ((unsigned long )(__o___13->next_free + __len___12) > (unsigned long )__o___13->chunk_limit) {
      {
#line 192
      _obstack_newchunk(__o___13, __len___12);
      }
    }
    {
#line 192
    memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___12);
#line 192
    __o___13->next_free += __len___12;
    }
#line 194
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 199
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 199
    __o___14 = & obstack_for_string___0;
#line 199
    tmp___6 = strlen("]b4_dollar_dollar[");
#line 199
    __len___13 = (int )tmp___6;
    }
#line 199
    if ((unsigned long )(__o___14->next_free + __len___13) > (unsigned long )__o___14->chunk_limit) {
      {
#line 199
      _obstack_newchunk(__o___14, __len___13);
      }
    }
    {
#line 199
    memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)"]b4_dollar_dollar[",
           (size_t )__len___13);
#line 199
    __o___14->next_free += __len___13;
#line 200
    self->is_value_used = (_Bool)1;
    }
#line 202
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 204
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 203
    __o___15 = & obstack_for_string___0;
#line 203
    tmp___7 = strlen("]b4_at_dollar[");
#line 203
    __len___14 = (int )tmp___7;
    }
#line 203
    if ((unsigned long )(__o___15->next_free + __len___14) > (unsigned long )__o___15->chunk_limit) {
      {
#line 203
      _obstack_newchunk(__o___15, __len___14);
      }
    }
    {
#line 203
    memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)"]b4_at_dollar[",
           (size_t )__len___14);
#line 203
    __o___15->next_free += __len___14;
#line 204
    locations_flag = (_Bool)1;
    }
#line 206
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 214
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 215
    __o___16 = & obstack_for_string___0;
#line 215
    tmp___8 = strlen("$][");
#line 215
    __len___15 = (int )tmp___8;
    }
#line 215
    if ((unsigned long )(__o___16->next_free + __len___15) > (unsigned long )__o___16->chunk_limit) {
      {
#line 215
      _obstack_newchunk(__o___16, __len___15);
      }
    }
    {
#line 215
    memcpy((void */* __restrict  */)__o___16->next_free, (void const   */* __restrict  */)"$][",
           (size_t )__len___15);
#line 215
    __o___16->next_free += __len___15;
    }
#line 216
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 218
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 216
    __o___17 = & obstack_for_string___0;
#line 216
    tmp___9 = strlen("@@");
#line 216
    __len___16 = (int )tmp___9;
    }
#line 216
    if ((unsigned long )(__o___17->next_free + __len___16) > (unsigned long )__o___17->chunk_limit) {
      {
#line 216
      _obstack_newchunk(__o___17, __len___16);
      }
    }
    {
#line 216
    memcpy((void */* __restrict  */)__o___17->next_free, (void const   */* __restrict  */)"@@",
           (size_t )__len___16);
#line 216
    __o___17->next_free += __len___16;
    }
#line 217
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 219
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 217
    __o___18 = & obstack_for_string___0;
#line 217
    tmp___10 = strlen("@{");
#line 217
    __len___17 = (int )tmp___10;
    }
#line 217
    if ((unsigned long )(__o___18->next_free + __len___17) > (unsigned long )__o___18->chunk_limit) {
      {
#line 217
      _obstack_newchunk(__o___18, __len___17);
      }
    }
    {
#line 217
    memcpy((void */* __restrict  */)__o___18->next_free, (void const   */* __restrict  */)"@{",
           (size_t )__len___17);
#line 217
    __o___18->next_free += __len___17;
    }
#line 218
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 220
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 218
    __o___19 = & obstack_for_string___0;
#line 218
    tmp___11 = strlen("@}");
#line 218
    __len___18 = (int )tmp___11;
    }
#line 218
    if ((unsigned long )(__o___19->next_free + __len___18) > (unsigned long )__o___19->chunk_limit) {
      {
#line 218
      _obstack_newchunk(__o___19, __len___18);
      }
    }
    {
#line 218
    memcpy((void */* __restrict  */)__o___19->next_free, (void const   */* __restrict  */)"@}",
           (size_t )__len___18);
#line 218
    __o___19->next_free += __len___18;
    }
#line 219
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 226
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 225
    __o___20 = & obstack_for_string___0;
#line 225
    __len___19 = code_leng;
    }
#line 225
    if ((unsigned long )(__o___20->next_free + __len___19) > (unsigned long )__o___20->chunk_limit) {
      {
#line 225
      _obstack_newchunk(__o___20, __len___19);
      }
    }
    {
#line 225
    memcpy((void */* __restrict  */)__o___20->next_free, (void const   */* __restrict  */)code_text,
           (size_t )__len___19);
#line 225
    __o___20->next_free += __len___19;
    }
#line 226
    goto switch_break;
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    {
#line 229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 229
      __o___21 = & obstack_for_string___0;
#line 229
      if ((unsigned long )(__o___21->next_free + 1) > (unsigned long )__o___21->chunk_limit) {
        {
#line 229
        _obstack_newchunk(__o___21, 1);
        }
      }
#line 229
      tmp___12 = __o___21->next_free;
#line 229
      (__o___21->next_free) ++;
#line 229
      *tmp___12 = (char )'\000';
#line 229
      __o1 = & obstack_for_string___0;
#line 229
      __value = (void *)__o1->object_base;
#line 229
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 229
        __o1->maybe_empty_object = 1U;
      }
#line 229
      if (sizeof(int ) < sizeof(void *)) {
#line 229
        tmp___13 = __o1->object_base;
      } else {
#line 229
        tmp___13 = (char *)0;
      }
#line 229
      if (sizeof(int ) < sizeof(void *)) {
#line 229
        tmp___14 = __o1->object_base;
      } else {
#line 229
        tmp___14 = (char *)0;
      }
#line 229
      __o1->next_free = tmp___13 + (((__o1->next_free - tmp___14) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 229
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 229
        __o1->next_free = __o1->chunk_limit;
      }
#line 229
      __o1->object_base = __o1->next_free;
#line 229
      code_last_string = (char *)__value;
#line 229
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 230
    return (code_last_string);
#line 232
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 234
    location_compute(loc, & loc->end, (char const   *)code_text, (size_t )code_leng);
#line 233
    yy_fatal_error___0("flex scanner jammed");
    }
#line 234
    goto switch_break;
    case_25: /* CIL Label */ 
#line 1276 "scan-code.c"
    yy_amount_of_matched_text = (int )(yy_cp - code_text) - 1;
#line 1279
    *yy_cp = yy_hold_char___0;
#line 1282
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 0) {
#line 1293
      yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 1294
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file = code_in;
#line 1295
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 1;
    }
#line 1305
    if ((unsigned long )yy_c_buf_p___0 <= (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0)) {
      {
#line 1309
      yy_c_buf_p___0 = code_text + yy_amount_of_matched_text;
#line 1311
      yy_current_state = yy_get_previous_state___0();
#line 1322
      yy_next_state = yy_try_NUL_trans___0(yy_current_state);
#line 1324
      yy_bp = code_text + 0;
      }
#line 1326
      if (yy_next_state) {
#line 1329
        yy_c_buf_p___0 ++;
#line 1329
        yy_cp = yy_c_buf_p___0;
#line 1330
        yy_current_state = yy_next_state;
#line 1331
        goto yy_match;
      } else {
#line 1337
        yy_cp = yy_last_accepting_cpos___0;
#line 1338
        yy_current_state = yy_last_accepting_state___0;
#line 1339
        goto yy_find_action;
      }
    } else {
      {
#line 1343
      tmp___15 = yy_get_next_buffer___0();
      }
      {
#line 1345
      if (tmp___15 == 1) {
#line 1345
        goto case_1___0;
      }
#line 1374
      if (tmp___15 == 0) {
#line 1374
        goto case_0___0;
      }
#line 1384
      if (tmp___15 == 2) {
#line 1384
        goto case_2___0;
      }
#line 1343
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1347
      yy_did_buffer_switch_on_eof___0 = 0;
#line 1360
      yy_c_buf_p___0 = code_text + 0;
#line 1362
      yy_act = (25 + (yy_start___0 - 1) / 2) + 1;
#line 1363
      goto do_action;
#line 1371
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1375
      yy_c_buf_p___0 = code_text + yy_amount_of_matched_text;
#line 1378
      yy_current_state = yy_get_previous_state___0();
#line 1380
      yy_cp = yy_c_buf_p___0;
#line 1381
      yy_bp = code_text + 0;
      }
#line 1382
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1385
      yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0;
#line 1388
      yy_current_state = yy_get_previous_state___0();
#line 1390
      yy_cp = yy_c_buf_p___0;
#line 1391
      yy_bp = code_text + 0;
      }
#line 1392
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1394
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1398
    yy_fatal_error___0("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1420 "scan-code.c"
static int yy_get_next_buffer___0(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1425
  dest = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf;
#line 1426
  source = code_text;
#line 1430
  if ((unsigned long )yy_c_buf_p___0 > (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1))) {
    {
#line 1431
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1434
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_fill_buffer == 0) {
#line 1436
    if (yy_c_buf_p___0 - code_text == 1L) {
#line 1441
      return (1);
    } else {
#line 1449
      return (2);
    }
  }
#line 1456
  number_to_move = (int )(yy_c_buf_p___0 - code_text) - 1;
#line 1458
  i = 0;
  {
#line 1458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1458
    if (! (i < number_to_move)) {
#line 1458
      goto while_break;
    }
#line 1459
    tmp = dest;
#line 1459
    dest ++;
#line 1459
    tmp___0 = source;
#line 1459
    source ++;
#line 1459
    *tmp = *tmp___0;
#line 1458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1461
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 2) {
#line 1465
    yy_n_chars___0 = 0;
#line 1465
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  } else {
#line 1469
    num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1472
      if (! (num_to_read <= 0)) {
#line 1472
        goto while_break___0;
      }
#line 1476
      if (yy_buffer_stack___0) {
#line 1476
        tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
      } else {
#line 1476
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1476
      b = tmp___1;
#line 1478
      yy_c_buf_p_offset = (int )(yy_c_buf_p___0 - b->yy_ch_buf);
#line 1481
      if (b->yy_is_our_buffer) {
#line 1483
        new_size = (int )(b->yy_buf_size * 2U);
#line 1485
        if (new_size <= 0) {
#line 1486
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1488
          b->yy_buf_size *= 2U;
        }
        {
#line 1490
        tmp___2 = code_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1490
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1496
        b->yy_ch_buf = (char *)0;
      }
#line 1498
      if (! b->yy_ch_buf) {
        {
#line 1499
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
        }
      }
#line 1502
      yy_c_buf_p___0 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1504
      num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1509
    if (num_to_read > 8192) {
#line 1510
      num_to_read = 8192;
    }
#line 1513
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_is_interactive) {
#line 1513
      c = '*';
#line 1513
      n = 0;
      {
#line 1513
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1513
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1513
          c = getc_unlocked(code_in);
          }
#line 1513
          if (c != -1) {
#line 1513
            if (! (c != 10)) {
#line 1513
              goto while_break___1;
            }
          } else {
#line 1513
            goto while_break___1;
          }
        } else {
#line 1513
          goto while_break___1;
        }
#line 1513
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1513
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1513
      if (c == 10) {
#line 1513
        tmp___3 = n;
#line 1513
        n ++;
#line 1513
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1513
      if (c == -1) {
        {
#line 1513
        tmp___4 = ferror_unlocked(code_in);
        }
#line 1513
        if (tmp___4) {
          {
#line 1513
          yy_fatal_error___0("input in flex scanner failed");
          }
        }
      }
#line 1513
      yy_n_chars___0 = n;
    } else {
      {
#line 1513
      tmp___5 = __errno_location();
#line 1513
      *tmp___5 = 0;
      }
      {
#line 1513
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1513
        tmp___8 = fread_unlocked((void */* __restrict  */)((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move),
                                 (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)code_in);
#line 1513
        yy_n_chars___0 = (int )tmp___8;
        }
#line 1513
        if (yy_n_chars___0 == 0) {
          {
#line 1513
          tmp___9 = ferror_unlocked(code_in);
          }
#line 1513
          if (! tmp___9) {
#line 1513
            goto while_break___2;
          }
        } else {
#line 1513
          goto while_break___2;
        }
        {
#line 1513
        tmp___6 = __errno_location();
        }
#line 1513
        if (*tmp___6 != 4) {
          {
#line 1513
          yy_fatal_error___0("input in flex scanner failed");
          }
#line 1513
          goto while_break___2;
        }
        {
#line 1513
        tmp___7 = __errno_location();
#line 1513
        *tmp___7 = 0;
#line 1513
        clearerr_unlocked(code_in);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1516
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 1519
  if (yy_n_chars___0 == 0) {
#line 1521
    if (number_to_move == 0) {
      {
#line 1523
      ret_val = 1;
#line 1524
      code_restart(code_in);
      }
    } else {
#line 1529
      ret_val = 2;
#line 1530
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 2;
    }
  } else {
#line 1536
    ret_val = 0;
  }
#line 1538
  if ((yy_size_t )(yy_n_chars___0 + number_to_move) > (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size) {
    {
#line 1540
    new_size___0 = (yy_size_t )((yy_n_chars___0 + number_to_move) + (yy_n_chars___0 >> 1));
#line 1541
    tmp___10 = code_realloc((void *)(*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf,
                            new_size___0);
#line 1541
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf = (char *)tmp___10;
    }
#line 1542
    if (! (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf) {
      {
#line 1543
      yy_fatal_error___0("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1546
  yy_n_chars___0 += number_to_move;
#line 1547
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0) = (char)0;
#line 1548
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1)) = (char)0;
#line 1550
  code_text = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 0;
#line 1552
  return (ret_val);
}
}
#line 1560 "scan-code.c"
static yy_state_type yy_get_previous_state___0(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1569
  yy_current_state = yy_start___0;
#line 1571
  yy_cp = code_text + 0;
  {
#line 1571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1571
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___0)) {
#line 1571
      goto while_break;
    }
#line 1574
    if (*yy_cp) {
#line 1574
      tmp = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1574
      tmp = (flex_int32_t const   )19;
    }
#line 1574
    yy_c = (YY_CHAR )tmp;
#line 1575
    if (yy_accept___0[yy_current_state]) {
#line 1577
      yy_last_accepting_state___0 = yy_current_state;
#line 1578
      yy_last_accepting_cpos___0 = yy_cp;
    }
    {
#line 1580
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1580
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1580
        goto while_break___0;
      }
#line 1582
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 1583
      if (yy_current_state >= 68) {
#line 1584
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1586
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1571
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1589
  return (yy_current_state);
}
}
#line 1598 "scan-code.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1605
  yy_cp = yy_c_buf_p___0;
#line 1607
  yy_c = (YY_CHAR )19;
#line 1608
  if (yy_accept___0[yy_current_state]) {
#line 1610
    yy_last_accepting_state___0 = yy_current_state;
#line 1611
    yy_last_accepting_cpos___0 = yy_cp;
  }
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1613
      goto while_break;
    }
#line 1615
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 1616
    if (yy_current_state >= 68) {
#line 1617
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1619
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1620
  yy_is_jam = yy_current_state == 67;
#line 1622
  if (yy_is_jam) {
#line 1622
    tmp = 0;
  } else {
#line 1622
    tmp = yy_current_state;
  }
#line 1622
  return (tmp);
}
}
#line 1717 "scan-code.c"
void code_restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1723
  if (yy_buffer_stack___0) {
#line 1723
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1723
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1723
  if (! tmp) {
    {
#line 1724
    code_ensure_buffer_stack();
#line 1725
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = code__create_buffer(code_in,
                                                                           16384);
    }
  }
#line 1729
  if (yy_buffer_stack___0) {
#line 1729
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1729
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1729
  code__init_buffer(tmp___0, input_file);
#line 1730
  code__load_buffer_state();
  }
#line 1731
  return;
}
}
#line 1738 "scan-code.c"
void code__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1749
  code_ensure_buffer_stack();
  }
#line 1750
  if (yy_buffer_stack___0) {
#line 1750
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1750
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1750
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1751
    return;
  }
#line 1753
  if (yy_buffer_stack___0) {
#line 1753
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1753
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1753
  if (tmp___0) {
#line 1756
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 1757
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 1758
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
  {
#line 1761
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 1762
  code__load_buffer_state();
#line 1769
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 1770
  return;
}
}
#line 1773 "scan-code.c"
static void code__load_buffer_state(void) 
{ 


  {
#line 1778
  yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 1779
  yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos;
#line 1779
  code_text = yy_c_buf_p___0;
#line 1780
  code_in = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file;
#line 1781
  yy_hold_char___0 = *yy_c_buf_p___0;
#line 1782
  return;
}
}
#line 1791 "scan-code.c"
YY_BUFFER_STATE code__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1798
  tmp = code_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1798
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1799
  if (! b) {
    {
#line 1800
    yy_fatal_error___0("out of dynamic memory in code__create_buffer()");
    }
  }
  {
#line 1802
  b->yy_buf_size = (yy_size_t )size;
#line 1807
  tmp___0 = code_alloc(b->yy_buf_size + 2U);
#line 1807
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1808
  if (! b->yy_ch_buf) {
    {
#line 1809
    yy_fatal_error___0("out of dynamic memory in code__create_buffer()");
    }
  }
  {
#line 1811
  b->yy_is_our_buffer = 1;
#line 1813
  code__init_buffer(b, file);
  }
#line 1815
  return (b);
}
}
#line 1823 "scan-code.c"
void code__delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1829
  if (! b) {
#line 1830
    return;
  }
#line 1832
  if (yy_buffer_stack___0) {
#line 1832
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1832
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1832
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1833
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )0;
  }
#line 1835
  if (b->yy_is_our_buffer) {
    {
#line 1836
    code_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1838
  code_free((void *)b);
  }
#line 1839
  return;
}
}
#line 1853 "scan-code.c"
static void code__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1859
  tmp = __errno_location();
#line 1859
  oerrno = *tmp;
#line 1861
  code__flush_buffer(b);
#line 1863
  b->yy_input_file = file;
#line 1864
  b->yy_fill_buffer = 1;
  }
#line 1870
  if (yy_buffer_stack___0) {
#line 1870
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1870
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1870
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1871
    b->yy_bs_lineno = 1;
#line 1872
    b->yy_bs_column = 0;
  }
  {
#line 1877
  b->yy_is_interactive = 0;
#line 1882
  tmp___1 = __errno_location();
#line 1882
  *tmp___1 = oerrno;
  }
#line 1883
  return;
}
}
#line 1890 "scan-code.c"
void code__flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1895
  if (! b) {
#line 1896
    return;
  }
#line 1898
  b->yy_n_chars = 0;
#line 1904
  *(b->yy_ch_buf + 0) = (char)0;
#line 1905
  *(b->yy_ch_buf + 1) = (char)0;
#line 1907
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1909
  b->yy_at_bol = 1;
#line 1910
  b->yy_buffer_status = 0;
#line 1912
  if (yy_buffer_stack___0) {
#line 1912
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1912
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1912
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1913
    code__load_buffer_state();
    }
  }
#line 1914
  return;
}
}
#line 1924 "scan-code.c"
void code_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1929
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1930
    return;
  }
  {
#line 1932
  code_ensure_buffer_stack();
  }
#line 1935
  if (yy_buffer_stack___0) {
#line 1935
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1935
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1935
  if (tmp) {
#line 1938
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 1939
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 1940
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 1944
  if (yy_buffer_stack___0) {
#line 1944
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1944
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1944
  if (tmp___0) {
#line 1945
    yy_buffer_stack_top___0 ++;
  }
  {
#line 1946
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 1949
  code__load_buffer_state();
#line 1950
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 1951
  return;
}
}
#line 1960 "scan-code.c"
void code_pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1965
  if (yy_buffer_stack___0) {
#line 1965
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1965
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1965
  if (! tmp) {
#line 1966
    return;
  }
#line 1968
  if (yy_buffer_stack___0) {
#line 1968
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1968
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1968
  code__delete_buffer(tmp___0);
#line 1969
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1970
  if (yy_buffer_stack_top___0 > 0U) {
#line 1971
    yy_buffer_stack_top___0 --;
  }
#line 1973
  if (yy_buffer_stack___0) {
#line 1973
    tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1973
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1973
  if (tmp___1) {
    {
#line 1974
    code__load_buffer_state();
#line 1975
    yy_did_buffer_switch_on_eof___0 = 1;
    }
  }
#line 1977
  return;
}
}
#line 1985 "scan-code.c"
static void code_ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1992
  if (! yy_buffer_stack___0) {
    {
#line 1998
    num_to_alloc = 1;
#line 1999
    tmp = code_alloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1999
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp;
    }
#line 2002
    if (! yy_buffer_stack___0) {
      {
#line 2003
      yy_fatal_error___0("out of dynamic memory in code_ensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)yy_buffer_stack___0, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2007
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
#line 2008
    yy_buffer_stack_top___0 = (size_t )0;
    }
#line 2009
    return;
  }
#line 2012
  if (yy_buffer_stack_top___0 >= yy_buffer_stack_max___0 - 1U) {
    {
#line 2015
    grow_size = 8;
#line 2017
    num_to_alloc = (int )(yy_buffer_stack_max___0 + (size_t )grow_size);
#line 2018
    tmp___0 = code_realloc((void *)yy_buffer_stack___0, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2018
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp___0;
    }
#line 2022
    if (! yy_buffer_stack___0) {
      {
#line 2023
      yy_fatal_error___0("out of dynamic memory in code_ensure_buffer_stack()");
      }
    }
    {
#line 2026
    memset((void *)(yy_buffer_stack___0 + yy_buffer_stack_max___0), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 2027
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
    }
  }
#line 2029
  return;
}
}
#line 2039 "scan-code.c"
YY_BUFFER_STATE code__scan_buffer(char *base___0 , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2043
  if (size < 2U) {
#line 2047
    return ((YY_BUFFER_STATE )0);
  } else
#line 2043
  if ((int )*(base___0 + (size - 2U)) != 0) {
#line 2047
    return ((YY_BUFFER_STATE )0);
  } else
#line 2043
  if ((int )*(base___0 + (size - 1U)) != 0) {
#line 2047
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2049
  tmp = code_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 2049
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2050
  if (! b) {
    {
#line 2051
    yy_fatal_error___0("out of dynamic memory in code__scan_buffer()");
    }
  }
  {
#line 2053
  b->yy_buf_size = size - 2U;
#line 2054
  tmp___0 = base___0;
#line 2054
  b->yy_ch_buf = tmp___0;
#line 2054
  b->yy_buf_pos = tmp___0;
#line 2055
  b->yy_is_our_buffer = 0;
#line 2056
  b->yy_input_file = (FILE *)0;
#line 2057
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2058
  b->yy_is_interactive = 0;
#line 2059
  b->yy_at_bol = 1;
#line 2060
  b->yy_fill_buffer = 0;
#line 2061
  b->yy_buffer_status = 0;
#line 2063
  code__switch_to_buffer(b);
  }
#line 2065
  return (b);
}
}
#line 2078 "scan-code.c"
YY_BUFFER_STATE code__scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2081
  tmp = strlen(yystr);
#line 2081
  tmp___0 = code__scan_bytes(yystr, (int )tmp);
  }
#line 2081
  return (tmp___0);
}
}
#line 2093 "scan-code.c"
YY_BUFFER_STATE code__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2101
  n = (yy_size_t )(_yybytes_len + 2);
#line 2102
  tmp = code_alloc(n);
#line 2102
  buf___0 = (char *)tmp;
  }
#line 2103
  if (! buf___0) {
    {
#line 2104
    yy_fatal_error___0("out of dynamic memory in code__scan_bytes()");
    }
  }
#line 2106
  i = 0;
  {
#line 2106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2106
    if (! (i < _yybytes_len)) {
#line 2106
      goto while_break;
    }
#line 2107
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2109
  tmp___0 = (char)0;
#line 2109
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 2109
  *(buf___0 + _yybytes_len) = tmp___0;
#line 2111
  b = code__scan_buffer(buf___0, n);
  }
#line 2112
  if (! b) {
    {
#line 2113
    yy_fatal_error___0("bad buffer in code__scan_bytes()");
    }
  }
#line 2118
  b->yy_is_our_buffer = 1;
#line 2120
  return (b);
}
}
#line 2129 "scan-code.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 


  {
  {
#line 2131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2132
  exit(2);
  }
}
}
#line 2164 "scan-code.c"
int code_get_lineno(void) 
{ 


  {
#line 2167
  return (code_lineno);
}
}
#line 2173 "scan-code.c"
FILE *code_get_in(void) 
{ 


  {
#line 2175
  return (code_in);
}
}
#line 2181 "scan-code.c"
FILE *code_get_out(void) 
{ 


  {
#line 2183
  return (code_out);
}
}
#line 2189 "scan-code.c"
int code_get_leng(void) 
{ 


  {
#line 2191
  return (code_leng);
}
}
#line 2198 "scan-code.c"
char *code_get_text(void) 
{ 


  {
#line 2200
  return (code_text);
}
}
#line 2210 "scan-code.c"
void code_set_lineno(int line_number ) 
{ 


  {
#line 2213
  code_lineno = line_number;
#line 2214
  return;
}
}
#line 2222 "scan-code.c"
void code_set_in(FILE *in_str ) 
{ 


  {
#line 2224
  code_in = in_str;
#line 2225
  return;
}
}
#line 2227 "scan-code.c"
void code_set_out(FILE *out_str ) 
{ 


  {
#line 2229
  code_out = out_str;
#line 2230
  return;
}
}
#line 2232 "scan-code.c"
int code_get_debug(void) 
{ 


  {
#line 2234
  return (code__flex_debug);
}
}
#line 2237 "scan-code.c"
void code_set_debug(int bdebug ) 
{ 


  {
#line 2239
  code__flex_debug = bdebug;
#line 2240
  return;
}
}
#line 2250 "scan-code.c"
static int yy_init_globals___0(void) 
{ 


  {
#line 2256
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)0;
#line 2257
  yy_buffer_stack_top___0 = (size_t )0;
#line 2258
  yy_buffer_stack_max___0 = (size_t )0;
#line 2259
  yy_c_buf_p___0 = (char *)0;
#line 2260
  yy_init___0 = 0;
#line 2261
  yy_start___0 = 0;
#line 2268
  code_in = (FILE *)0;
#line 2269
  code_out = (FILE *)0;
#line 2275
  return (0);
}
}
#line 2281 "scan-code.c"
int code_lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2285
    if (yy_buffer_stack___0) {
#line 2285
      tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 2285
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2285
    if (! tmp___0) {
#line 2285
      goto while_break;
    }
#line 2286
    if (yy_buffer_stack___0) {
#line 2286
      tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 2286
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2286
    code__delete_buffer(tmp);
#line 2287
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
#line 2288
    code_pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2292
  code_free((void *)yy_buffer_stack___0);
#line 2293
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)((void *)0);
#line 2297
  yy_init_globals___0();
  }
#line 2301
  return (0);
}
}
#line 2329 "scan-code.c"
void *code_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2331
  tmp = malloc(size);
  }
#line 2331
  return (tmp);
}
}
#line 2334 "scan-code.c"
void *code_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2343
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2343
  return (tmp);
}
}
#line 2346 "scan-code.c"
void code_free(void *ptr ) 
{ 


  {
  {
#line 2348
  free((void *)((char *)ptr));
  }
#line 2349
  return;
}
}
#line 239 "scan-code.l"
int max_left_semantic_context  =    0;
#line 250 "scan-code.l"
static void handle_action_dollar(symbol_list *rule , char *text , location dollar_loc ) 
{ 
  char const   *type_name ;
  char *cp ;
  symbol_list *effective_rule ;
  int effective_rule_length ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___2 ;
  long num ;
  long tmp___3 ;
  int n ;
  char *tmp___4 ;
  char buf___1[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___5 ;
  symbol_list *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;

  {
#line 253
  type_name = (char const   *)((void *)0);
#line 254
  cp = text + 1;
#line 258
  if (rule->midrule_parent_rule) {
#line 260
    effective_rule = rule->midrule_parent_rule;
#line 261
    effective_rule_length = rule->midrule_parent_rhs_index - 1;
  } else {
    {
#line 265
    effective_rule = rule;
#line 266
    effective_rule_length = symbol_list_length((symbol_list const   *)rule->next);
    }
  }
#line 270
  if ((int )*cp == 60) {
#line 272
    cp ++;
#line 272
    type_name = (char const   *)cp;
    {
#line 273
    while (1) {
      while_continue: /* CIL Label */ ;
#line 273
      if (! ((int )*cp != 62)) {
#line 273
        goto while_break;
      }
#line 274
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    *cp = (char )'\000';
#line 276
    cp ++;
#line 277
    if (untyped_var_seen) {
      {
#line 278
      tmp = gettext("explicit type given in untyped grammar");
#line 278
      complain_at(dollar_loc, (char const   *)tmp);
      }
    }
#line 279
    tag_seen = (_Bool)1;
  }
#line 282
  if ((int )*cp == 36) {
#line 284
    if (! type_name) {
      {
#line 285
      type_name = symbol_list_n_type_name_get(rule, dollar_loc, 0);
      }
    }
#line 287
    if (! type_name) {
#line 289
      if ((int )union_seen | (int )tag_seen) {
#line 291
        if (rule->midrule_parent_rule) {
          {
#line 292
          tmp___0 = gettext("$$ for the midrule at $%d of `%s\' has no declared type");
#line 292
          complain_at(dollar_loc, (char const   *)tmp___0, rule->midrule_parent_rhs_index,
                      (effective_rule->content.sym)->tag);
          }
        } else {
          {
#line 298
          tmp___1 = gettext("$$ of `%s\' has no declared type");
#line 298
          complain_at(dollar_loc, (char const   *)tmp___1, (rule->content.sym)->tag);
          }
        }
      } else {
#line 302
        untyped_var_seen = (_Bool)1;
      }
#line 303
      type_name = "";
    }
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 306
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"]b4_lhs_value([%s])[",
              type_name);
#line 306
      __o = & obstack_for_string___0;
#line 306
      tmp___2 = strlen((char const   *)(buf___0));
#line 306
      __len = (int )tmp___2;
      }
#line 306
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 306
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 306
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 306
      __o->next_free += __len;
      }
#line 306
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 308
    rule->action_props.is_value_used = (_Bool)1;
  } else {
    {
#line 312
    tmp___3 = strtol((char const   */* __restrict  */)cp, (char **/* __restrict  */)((void *)0),
                     10);
#line 312
    num = tmp___3;
    }
#line 314
    if ((long )(-2147483646 + effective_rule_length) <= num) {
#line 314
      if (num <= (long )effective_rule_length) {
#line 317
        n = (int )num;
#line 318
        if (max_left_semantic_context < 1 - n) {
#line 319
          max_left_semantic_context = 1 - n;
        }
#line 320
        if (! type_name) {
#line 320
          if (0 < n) {
            {
#line 321
            type_name = symbol_list_n_type_name_get(effective_rule, dollar_loc, n);
            }
          }
        }
#line 323
        if (! type_name) {
#line 325
          if ((int )union_seen | (int )tag_seen) {
            {
#line 326
            tmp___4 = gettext("$%d of `%s\' has no declared type");
#line 326
            complain_at(dollar_loc, (char const   *)tmp___4, n, (effective_rule->content.sym)->tag);
            }
          } else {
#line 329
            untyped_var_seen = (_Bool)1;
          }
#line 330
          type_name = "";
        }
        {
#line 333
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 333
          sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"]b4_rhs_value(%d, %d, [%s])[",
                  effective_rule_length, n, type_name);
#line 333
          __o___0 = & obstack_for_string___0;
#line 333
          tmp___5 = strlen((char const   *)(buf___1));
#line 333
          __len___0 = (int )tmp___5;
          }
#line 333
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 333
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 333
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
                 (size_t )__len___0);
#line 333
          __o___0->next_free += __len___0;
          }
#line 333
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 336
        if (n > 0) {
          {
#line 337
          tmp___6 = symbol_list_n_get(effective_rule, n);
#line 337
          tmp___6->action_props.is_value_used = (_Bool)1;
          }
        }
      } else {
        {
#line 341
        tmp___7 = quote((char const   *)text);
#line 341
        tmp___8 = gettext("integer out of range: %s");
#line 341
        complain_at(dollar_loc, (char const   *)tmp___8, tmp___7);
        }
      }
    } else {
      {
#line 341
      tmp___7 = quote((char const   *)text);
#line 341
      tmp___8 = gettext("integer out of range: %s");
#line 341
      complain_at(dollar_loc, (char const   *)tmp___8, tmp___7);
      }
    }
  }
#line 343
  return;
}
}
#line 351 "scan-code.l"
static void handle_action_at(symbol_list *rule , char *text , location at_loc ) 
{ 
  char *cp ;
  int effective_rule_length ;
  int tmp ;
  int tmp___0 ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___1 ;
  long num ;
  long tmp___2 ;
  int n ;
  char buf___0[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
#line 354
  cp = text + 1;
#line 355
  if (rule->midrule_parent_rule) {
#line 355
    tmp___0 = rule->midrule_parent_rhs_index - 1;
  } else {
    {
#line 355
    tmp = symbol_list_length((symbol_list const   *)rule->next);
#line 355
    tmp___0 = tmp;
    }
  }
#line 355
  effective_rule_length = tmp___0;
#line 360
  locations_flag = (_Bool)1;
#line 362
  if ((int )*cp == 36) {
    {
#line 363
    __o = & obstack_for_string___0;
#line 363
    tmp___1 = strlen("]b4_lhs_location[");
#line 363
    __len = (int )tmp___1;
    }
#line 363
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 363
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 363
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"]b4_lhs_location[",
           (size_t )__len);
#line 363
    __o->next_free += __len;
    }
  } else {
    {
#line 366
    tmp___2 = strtol((char const   */* __restrict  */)cp, (char **/* __restrict  */)((void *)0),
                     10);
#line 366
    num = tmp___2;
    }
#line 368
    if ((long )(-2147483646 + effective_rule_length) <= num) {
#line 368
      if (num <= (long )effective_rule_length) {
#line 371
        n = (int )num;
        {
#line 372
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 372
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"]b4_rhs_location(%d, %d)[",
                  effective_rule_length, n);
#line 372
          __o___0 = & obstack_for_string___0;
#line 372
          tmp___3 = strlen((char const   *)(buf___0));
#line 372
          __len___0 = (int )tmp___3;
          }
#line 372
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 372
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 372
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___0),
                 (size_t )__len___0);
#line 372
          __o___0->next_free += __len___0;
          }
#line 372
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 376
        tmp___4 = quote((char const   *)text);
#line 376
        tmp___5 = gettext("integer out of range: %s");
#line 376
        complain_at(at_loc, (char const   *)tmp___5, tmp___4);
        }
      }
    } else {
      {
#line 376
      tmp___4 = quote((char const   *)text);
#line 376
      tmp___5 = gettext("integer out of range: %s");
#line 376
      complain_at(at_loc, (char const   *)tmp___5, tmp___4);
      }
    }
  }
#line 378
  return;
}
}
#line 392
static char const   *translate_action(code_props *self , int sc_context ) ;
#line 392 "scan-code.l"
static _Bool initialized___0  =    (_Bool)0;
#line 388 "scan-code.l"
static char const   *translate_action(code_props *self , int sc_context ) 
{ 
  char *res ;
  boundary tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 393
  if (! initialized___0) {
    {
#line 395
    _obstack_begin(& obstack_for_string___0, 0, 0, (void *(*)(long  ))(& xmalloc),
                   & free);
#line 396
    code__flex_debug = 0;
#line 397
    initialized___0 = (_Bool)1;
    }
  }
  {
#line 400
  tmp = self->location.start;
#line 400
  loc->end = tmp;
#line 400
  loc->start = tmp;
#line 401
  tmp___0 = code__scan_string(self->code);
#line 401
  code__switch_to_buffer(tmp___0);
#line 402
  res = code_lex(self, sc_context);
  }
#line 403
  if (yy_buffer_stack___0) {
#line 403
    tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 403
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 403
  code__delete_buffer(tmp___1);
  }
#line 405
  return ((char const   *)res);
}
}
#line 412 "scan-code.l"
void code_props_none_init(code_props *self ) 
{ 


  {
#line 415
  *self = (code_props )code_props_none;
#line 416
  return;
}
}
#line 418 "scan-code.l"
struct code_props  const  code_props_none  =    {(enum __anonenum_kind_35 )0, (char const   *)((void *)0), {{(uniqstr )((void *)0),
                                                                0, 0}, {(uniqstr )((void *)0),
                                                                        0, 0}}, (_Bool)0,
    (struct symbol_list *)((void *)0)};
#line 420 "scan-code.l"
void code_props_plain_init(code_props *self , char const   *code , location code_loc ) 
{ 


  {
#line 423
  self->kind = (enum __anonenum_kind_36 )1;
#line 424
  self->code = code;
#line 425
  self->location = code_loc;
#line 426
  self->is_value_used = (_Bool)0;
#line 427
  self->rule = (struct symbol_list *)((void *)0);
#line 428
  return;
}
}
#line 430 "scan-code.l"
void code_props_symbol_action_init(code_props *self , char const   *code , location code_loc ) 
{ 


  {
#line 434
  self->kind = (enum __anonenum_kind_36 )2;
#line 435
  self->code = code;
#line 436
  self->location = code_loc;
#line 437
  self->is_value_used = (_Bool)0;
#line 438
  self->rule = (struct symbol_list *)((void *)0);
#line 439
  return;
}
}
#line 441 "scan-code.l"
void code_props_rule_action_init(code_props *self , char const   *code , location code_loc ,
                                 struct symbol_list *rule ) 
{ 


  {
#line 445
  self->kind = (enum __anonenum_kind_36 )3;
#line 446
  self->code = code;
#line 447
  self->location = code_loc;
#line 448
  self->is_value_used = (_Bool)0;
#line 449
  self->rule = rule;
#line 450
  return;
}
}
#line 452 "scan-code.l"
void code_props_translate_code(code_props *self ) 
{ 


  {
  {
#line 457
  if ((unsigned int )self->kind == 0U) {
#line 457
    goto case_0;
  }
#line 459
  if ((unsigned int )self->kind == 1U) {
#line 459
    goto case_1;
  }
#line 462
  if ((unsigned int )self->kind == 2U) {
#line 462
    goto case_2;
  }
#line 465
  if ((unsigned int )self->kind == 3U) {
#line 465
    goto case_3;
  }
#line 455
  goto switch_break;
  case_0: /* CIL Label */ 
#line 458
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 460
  self->code = translate_action(self, 0);
  }
#line 461
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 463
  self->code = translate_action(self, 6);
  }
#line 464
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 466
  self->code = translate_action(self, 5);
  }
#line 467
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 469
  return;
}
}
#line 471 "scan-code.l"
void code_scanner_last_string_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 474
  __o = & obstack_for_string___0;
#line 474
  __obj = (void *)code_last_string;
#line 474
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 474
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 474
      tmp = (char *)__obj;
#line 474
      __o->object_base = tmp;
#line 474
      __o->next_free = tmp;
    } else {
      {
#line 474
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 474
    obstack_free(__o, __obj);
    }
  }
#line 475
  return;
}
}
#line 477 "scan-code.l"
void code_scanner_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 480
  __o = & obstack_for_string___0;
#line 480
  __obj = (void *)0;
#line 480
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 480
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 480
      tmp = (char *)__obj;
#line 480
      __o->object_base = tmp;
#line 480
      __o->next_free = tmp;
    } else {
      {
#line 480
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 480
    obstack_free(__o, __obj);
    }
  }
  {
#line 482
  code_lex_destroy();
  }
#line 483
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/relation.h"
void relation_print(relation r , relation_node size , FILE *out ) ;
#line 43
void relation_digraph(relation r , relation_node size , bitsetv *function ) ;
#line 46
void relation_transpose(relation *R_arg , relation_node n ) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
void relation_print(relation r , relation_node size , FILE *out ) 
{ 
  relation_node i ;
  relation_node j ;

  {
#line 33
  i = (relation_node )0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (i < size)) {
#line 33
      goto while_break;
    }
    {
#line 35
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%3lu: ",
            (unsigned long )i);
    }
#line 36
    if (*(r + i)) {
#line 37
      j = (relation_node )0;
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 37
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 37
          goto while_break___0;
        }
        {
#line 38
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%3lu ",
                (unsigned long )*(*(r + i) + j));
#line 37
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 39
    fputc_unlocked('\n', out);
#line 33
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 41
  fputc_unlocked('\n', out);
  }
#line 42
  return;
}
}
#line 52 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static relation R  ;
#line 53 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static relation_nodes INDEX  ;
#line 54 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static relation_nodes VERTICES  ;
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static relation_node top  ;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static relation_node infinity  ;
#line 57 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static bitsetv F  ;
#line 59 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
static void traverse(relation_node i ) 
{ 
  relation_node j ;
  relation_node height ;
  relation_node tmp ;

  {
#line 65
  top ++;
#line 65
  *(VERTICES + top) = i;
#line 66
  height = top;
#line 66
  *(INDEX + i) = height;
#line 68
  if (*(R + i)) {
#line 69
    j = (relation_node )0;
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      if (! (*(*(R + i) + j) != 4294967295U)) {
#line 69
        goto while_break;
      }
#line 71
      if (*(INDEX + *(*(R + i) + j)) == 0U) {
        {
#line 72
        traverse(*(*(R + i) + j));
        }
      }
#line 74
      if (*(INDEX + i) > *(INDEX + *(*(R + i) + j))) {
#line 75
        *(INDEX + i) = *(INDEX + *(*(R + i) + j));
      }
      {
#line 77
      (*(((*(F + i))->b.vtable)->or_))(*(F + i), *(F + i), *(F + *(*(R + i) + j)));
#line 69
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 80
  if (*(INDEX + i) == height) {
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      tmp = top;
#line 83
      top --;
#line 83
      j = *(VERTICES + tmp);
#line 84
      *(INDEX + j) = infinity;
#line 86
      if (i == j) {
#line 87
        goto while_break___0;
      }
      {
#line 89
      (*(((*(F + i))->b.vtable)->copy))(*(F + j), *(F + i));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 91
  return;
}
}
#line 94 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
void relation_digraph(relation r , relation_node size , bitsetv *function ) 
{ 
  relation_node i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 99
  infinity = size + 2U;
#line 100
  tmp = xcalloc(size + 1U, (size_t )sizeof(*INDEX));
#line 100
  INDEX = (relation_nodes )tmp;
#line 101
  tmp___0 = xnmalloc(size + 1U, (size_t )sizeof(*VERTICES));
#line 101
  VERTICES = (relation_nodes )tmp___0;
#line 102
  top = (relation_node )0;
#line 104
  R = r;
#line 105
  F = *function;
#line 107
  i = (relation_node )0;
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < size)) {
#line 107
      goto while_break;
    }
#line 108
    if (*(INDEX + i) == 0U) {
#line 108
      if (*(R + i)) {
        {
#line 109
        traverse(i);
        }
      }
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  free((void *)INDEX);
#line 112
  free((void *)VERTICES);
#line 114
  *function = F;
  }
#line 115
  return;
}
}
#line 122 "/home/pronto/abs/test-suite/bison-2.4/src/relation.c"
void relation_transpose(relation *R_arg , relation_node n ) 
{ 
  relation r ;
  relation new_R ;
  void *tmp ;
  relation end_R ;
  void *tmp___0 ;
  size_t *nedges ;
  void *tmp___1 ;
  relation_node i ;
  relation_node j ;
  relation_node *sp ;
  void *tmp___2 ;
  relation_nodes tmp___3 ;

  {
  {
#line 125
  r = *R_arg;
#line 127
  tmp = xnmalloc(n, (size_t )sizeof(*new_R));
#line 127
  new_R = (relation )tmp;
#line 129
  tmp___0 = xnmalloc(n, (size_t )sizeof(*end_R));
#line 129
  end_R = (relation )tmp___0;
#line 131
  tmp___1 = xcalloc(n, (size_t )sizeof(*nedges));
#line 131
  nedges = (size_t *)tmp___1;
  }
#line 135
  if (trace_flag & 8) {
    {
#line 137
    fputs_unlocked((char const   */* __restrict  */)"relation_transpose: input\n",
                   (FILE */* __restrict  */)stderr);
#line 138
    relation_print(r, n, stderr);
    }
  }
#line 142
  i = (relation_node )0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < n)) {
#line 142
      goto while_break;
    }
#line 143
    if (*(r + i)) {
#line 144
      j = (relation_node )0;
      {
#line 144
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 144
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 144
          goto while_break___0;
        }
#line 145
        (*(nedges + *(*(r + i) + j))) ++;
#line 144
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  i = (relation_node )0;
  {
#line 148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 148
    if (! (i < n)) {
#line 148
      goto while_break___1;
    }
#line 150
    sp = (relation_node *)((void *)0);
#line 151
    if (*(nedges + i) > 0U) {
      {
#line 153
      tmp___2 = xnmalloc(*(nedges + i) + 1U, (size_t )sizeof(*sp));
#line 153
      sp = (relation_node *)tmp___2;
#line 154
      *(sp + *(nedges + i)) = (relation_node )-1;
      }
    }
#line 156
    *(new_R + i) = sp;
#line 157
    *(end_R + i) = sp;
#line 148
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 161
  i = (relation_node )0;
  {
#line 161
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 161
    if (! (i < n)) {
#line 161
      goto while_break___2;
    }
#line 162
    if (*(r + i)) {
#line 163
      j = (relation_node )0;
      {
#line 163
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 163
        if (! (*(*(r + i) + j) != 4294967295U)) {
#line 163
          goto while_break___3;
        }
#line 164
        tmp___3 = *(end_R + *(*(r + i) + j));
#line 164
        (*(end_R + *(*(r + i) + j))) ++;
#line 164
        *tmp___3 = i;
#line 163
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 161
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 166
  free((void *)nedges);
#line 167
  free((void *)end_R);
#line 170
  i = (relation_node )0;
  }
  {
#line 170
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 170
    if (! (i < n)) {
#line 170
      goto while_break___4;
    }
    {
#line 171
    free((void *)*(r + i));
#line 170
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 172
  free((void *)r);
  }
#line 174
  if (trace_flag & 8) {
    {
#line 176
    fputs_unlocked((char const   */* __restrict  */)"relation_transpose: output\n",
                   (FILE */* __restrict  */)stderr);
#line 177
    relation_print(new_R, n, stderr);
    }
  }
#line 180
  *R_arg = new_R;
#line 181
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 60 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
uniqstr grammar_file ;
#line 118 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
unsigned int nritems ;
#line 128 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static item_number symbol_number_as_item_number(symbol_number sym ) 
{ 


  {
#line 131
  return (sym);
}
}
#line 149
rule_number nrules ;
#line 151 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static item_number rule_number_as_item_number(rule_number r ) 
{ 


  {
#line 154
  return (-1 - r);
}
}
#line 202
rule *rules ;
#line 213
_Bool rule_useless_in_grammar_p(rule *r ) ;
#line 226
int rule_rhs_length(rule *r ) ;
#line 255
void grammar_rules_partial_print(FILE *out , char const   *title , _Bool (*filter)(rule * ) ) ;
#line 264
void grammar_dump(FILE *out , char const   *title ) ;
#line 270
void grammar_rules_useless_report(char const   *message ) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.h"
void reduce_grammar(void) ;
#line 24
void reduce_output(FILE *out ) ;
#line 25
_Bool reduce_token_unused_in_grammar(symbol_number i ) ;
#line 26
_Bool reduce_nonterminal_useless_in_grammar(symbol_number i ) ;
#line 27
void reduce_free(void) ;
#line 29 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.h"
symbol_number nuseless_nonterminals  ;
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.h"
rule_number nuseless_productions  ;
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static bitset N  ;
#line 47 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static bitset P  ;
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static bitset V  ;
#line 54 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static bitset V1  ;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static rule_number nuseful_productions  ;
#line 58 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static int nuseful_nonterminals  ;
#line 67 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static _Bool useful_production(rule_number r , bitset N0 ) 
{ 
  item_number *rhsp ;
  _Bool tmp ;

  {
#line 75
  rhsp = (rules + r)->rhs;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (*rhsp >= 0)) {
#line 75
      goto while_break;
    }
#line 76
    if (*rhsp >= ntokens) {
      {
#line 76
      tmp = bitset_test(N0, (bitset_bindex )(*rhsp - ntokens));
      }
#line 76
      if (! tmp) {
#line 77
        return ((_Bool)0);
      }
    }
#line 75
    rhsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((_Bool)1);
}
}
#line 86 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static void useless_nonterminals(void) 
{ 
  bitset Np ;
  bitset Ns ;
  rule_number r ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 95
  Np = bitset_create((bitset_bindex )nvars, (bitset_attrs )1);
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    (*((N->b.vtable)->copy))(Np, N);
#line 117
    r = 0;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (r < nrules)) {
#line 117
        goto while_break___0;
      }
      {
#line 118
      tmp = bitset_test(P, (bitset_bindex )r);
      }
#line 118
      if (! tmp) {
        {
#line 118
        tmp___0 = useful_production(r, N);
        }
#line 118
        if (tmp___0) {
          {
#line 121
          bitset_set(Np, (bitset_bindex )(((rules + r)->lhs)->number - ntokens));
#line 122
          bitset_set(P, (bitset_bindex )r);
          }
        }
      }
#line 117
      r ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 124
    tmp___1 = (*((Np->b.vtable)->equal_p))(N, Np);
    }
#line 124
    if (tmp___1) {
#line 125
      goto while_break;
    }
#line 126
    Ns = Np;
#line 127
    Np = N;
#line 128
    N = Ns;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  bitset_free(N);
#line 131
  N = Np;
  }
#line 132
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static void inaccessable_symbols(void) 
{ 
  bitset Vp ;
  bitset Vs ;
  bitset Pp ;
  rule_number r ;
  item_number *rhsp ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  bitset_bindex tmp___5 ;
  symbol_number i ;
  _Bool tmp___6 ;
  rule_number r___0 ;

  {
  {
#line 163
  Vp = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 164
  Pp = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 167
  tmp___4 = bitset_test(N, (bitset_bindex )(accept->number - ntokens));
  }
#line 167
  if (tmp___4) {
    {
#line 169
    bitset_set(V, (bitset_bindex )accept->number);
    }
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 174
      (*((V->b.vtable)->copy))(Vp, V);
#line 175
      r = 0;
      }
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (r < nrules)) {
#line 175
          goto while_break___0;
        }
        {
#line 177
        tmp___0 = bitset_test(Pp, (bitset_bindex )r);
        }
#line 177
        if (! tmp___0) {
          {
#line 177
          tmp___1 = bitset_test(P, (bitset_bindex )r);
          }
#line 177
          if (tmp___1) {
            {
#line 177
            tmp___2 = bitset_test(V, (bitset_bindex )((rules + r)->lhs)->number);
            }
#line 177
            if (tmp___2) {
#line 182
              rhsp = (rules + r)->rhs;
              {
#line 182
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 182
                if (! (*rhsp >= 0)) {
#line 182
                  goto while_break___1;
                }
#line 183
                if (*rhsp < ntokens) {
                  {
#line 184
                  bitset_set(Vp, (bitset_bindex )*rhsp);
                  }
                } else {
                  {
#line 183
                  tmp = bitset_test(N, (bitset_bindex )(*rhsp - ntokens));
                  }
#line 183
                  if (tmp) {
                    {
#line 184
                    bitset_set(Vp, (bitset_bindex )*rhsp);
                    }
                  }
                }
#line 182
                rhsp ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 185
              bitset_set(Pp, (bitset_bindex )r);
              }
            }
          }
        }
#line 175
        r ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 188
      tmp___3 = (*((Vp->b.vtable)->equal_p))(V, Vp);
      }
#line 188
      if (tmp___3) {
#line 189
        goto while_break;
      }
#line 190
      Vs = Vp;
#line 191
      Vp = V;
#line 192
      V = Vs;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 196
  bitset_free(V);
#line 197
  V = Vp;
#line 200
  bitset_set(V, (bitset_bindex )endtoken->number);
#line 201
  bitset_set(V, (bitset_bindex )errtoken->number);
#line 202
  bitset_set(V, (bitset_bindex )undeftoken->number);
#line 204
  bitset_free(P);
#line 205
  P = Pp;
#line 207
  tmp___5 = (*((P->b.vtable)->count))(P);
#line 207
  nuseful_productions = (rule_number )tmp___5;
#line 208
  nuseless_productions = nrules - nuseful_productions;
#line 210
  nuseful_nonterminals = 0;
#line 213
  i = ntokens;
  }
  {
#line 213
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 213
    if (! (i < nsyms)) {
#line 213
      goto while_break___2;
    }
    {
#line 214
    tmp___6 = bitset_test(V, (bitset_bindex )i);
    }
#line 214
    if (tmp___6) {
#line 215
      nuseful_nonterminals ++;
    }
#line 213
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 217
  nuseless_nonterminals = nvars - nuseful_nonterminals;
#line 222
  r___0 = 0;
  {
#line 222
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 222
    if (! (r___0 < nrules)) {
#line 222
      goto while_break___3;
    }
#line 223
    if ((unsigned long )(rules + r___0)->precsym != (unsigned long )((symbol *)0)) {
      {
#line 224
      bitset_set(V1, (bitset_bindex )((rules + r___0)->precsym)->number);
      }
    }
#line 222
    r___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 234 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static void reduce_grammar_tables(void) 
{ 
  rule_number r ;
  char *tmp ;
  int useful ;
  int useless ;
  rule *rules_sorted ;
  void *tmp___0 ;
  rule_number r___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  item_number *rhsp ;
  rule_number r___1 ;
  int length ;

  {
#line 240
  r = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (r < nrules)) {
#line 240
      goto while_break;
    }
    {
#line 241
    (rules + r)->useful = bitset_test(P, (bitset_bindex )r);
#line 240
    r ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp = gettext("rule useless in grammar");
#line 242
  grammar_rules_useless_report((char const   *)tmp);
#line 248
  useful = 0;
#line 249
  useless = nrules - nuseless_productions;
#line 250
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*rules_sorted));
#line 250
  rules_sorted = (rule *)tmp___0;
#line 252
  r___0 = 0;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! (r___0 < nrules)) {
#line 252
      goto while_break___0;
    }
#line 253
    if ((rules + r___0)->useful) {
#line 253
      tmp___1 = useful;
#line 253
      useful ++;
#line 253
      tmp___3 = tmp___1;
    } else {
#line 253
      tmp___2 = useless;
#line 253
      useless ++;
#line 253
      tmp___3 = tmp___2;
    }
#line 253
    *(rules_sorted + tmp___3) = *(rules + r___0);
#line 252
    r___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 254
  free((void *)rules);
#line 255
  rules = rules_sorted;
#line 258
  r___0 = 0;
  }
  {
#line 258
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 258
    if (! (r___0 < nrules)) {
#line 258
      goto while_break___1;
    }
#line 260
    rhsp = (rules + r___0)->rhs;
    {
#line 261
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 261
      if (! (*rhsp >= 0)) {
#line 261
        goto while_break___2;
      }
#line 261
      rhsp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 263
    *rhsp = rule_number_as_item_number(r___0);
#line 264
    (rules + r___0)->number = r___0;
#line 258
    r___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 266
  nrules -= nuseless_productions;
#line 273
  r___1 = nrules;
  {
#line 273
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 273
    if (! (r___1 < nrules + nuseless_productions)) {
#line 273
      goto while_break___3;
    }
    {
#line 275
    length = rule_rhs_length(rules + r___1);
#line 276
    nritems -= (unsigned int )(length + 1);
#line 273
    r___1 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 286 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static void nonterminals_reduce(void) 
{ 
  symbol_number i ;
  symbol_number n ;
  symbol_number *nontermmap ;
  void *tmp ;
  symbol_number tmp___0 ;
  _Bool tmp___1 ;
  symbol_number tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  symbol **symbols_sorted ;
  void *tmp___5 ;
  rule_number r ;
  item_number *rhsp ;

  {
  {
#line 294
  tmp = xnmalloc((size_t )nvars, (size_t )sizeof(*nontermmap));
#line 294
  nontermmap = (symbol_number *)tmp;
#line 295
  n = ntokens;
#line 296
  i = ntokens;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < nsyms)) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp___1 = bitset_test(V, (bitset_bindex )i);
    }
#line 297
    if (tmp___1) {
#line 298
      tmp___0 = n;
#line 298
      n ++;
#line 298
      *(nontermmap + (i - ntokens)) = tmp___0;
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  i = ntokens;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < nsyms)) {
#line 299
      goto while_break___0;
    }
    {
#line 300
    tmp___4 = bitset_test(V, (bitset_bindex )i);
    }
#line 300
    if (! tmp___4) {
      {
#line 302
      tmp___2 = n;
#line 302
      n ++;
#line 302
      *(nontermmap + (i - ntokens)) = tmp___2;
#line 303
      tmp___3 = gettext("nonterminal useless in grammar: %s");
#line 303
      warn_at((*(symbols + i))->location, (char const   *)tmp___3, (*(symbols + i))->tag);
      }
    }
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  tmp___5 = xnmalloc((size_t )nvars, (size_t )sizeof(*symbols_sorted));
#line 310
  symbols_sorted = (symbol **)tmp___5;
#line 312
  i = ntokens;
  }
  {
#line 312
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 312
    if (! (i < nsyms)) {
#line 312
      goto while_break___1;
    }
#line 313
    (*(symbols + i))->number = *(nontermmap + (i - ntokens));
#line 312
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 314
  i = ntokens;
  {
#line 314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 314
    if (! (i < nsyms)) {
#line 314
      goto while_break___2;
    }
#line 315
    *(symbols_sorted + (*(nontermmap + (i - ntokens)) - ntokens)) = *(symbols + i);
#line 314
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 316
  i = ntokens;
  {
#line 316
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 316
    if (! (i < nsyms)) {
#line 316
      goto while_break___3;
    }
#line 317
    *(symbols + i) = *(symbols_sorted + (i - ntokens));
#line 316
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)symbols_sorted);
#line 323
  r = 0;
  }
  {
#line 323
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 323
    if (! (r < nrules)) {
#line 323
      goto while_break___4;
    }
#line 326
    rhsp = (rules + r)->rhs;
    {
#line 326
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 326
      if (! (*rhsp >= 0)) {
#line 326
        goto while_break___5;
      }
#line 327
      if (*rhsp >= ntokens) {
        {
#line 328
        *rhsp = symbol_number_as_item_number(*(nontermmap + (*rhsp - ntokens)));
        }
      }
#line 326
      rhsp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 323
    r ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 331
  accept->number = *(nontermmap + (accept->number - ntokens));
#line 334
  nsyms -= nuseless_nonterminals;
#line 335
  nvars -= nuseless_nonterminals;
#line 337
  free((void *)nontermmap);
  }
#line 338
  return;
}
}
#line 345 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
void reduce_output(FILE *out ) 
{ 
  int i ;
  char *tmp ;
  _Bool b ;
  int i___0 ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
#line 348
  if (nuseless_nonterminals > 0) {
    {
#line 351
    tmp = gettext("Nonterminals useless in grammar");
#line 351
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
            tmp);
#line 352
    i = 0;
    }
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (i < nuseless_nonterminals)) {
#line 352
        goto while_break;
      }
      {
#line 353
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   %s\n",
              (*(symbols + (nsyms + i)))->tag);
#line 352
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 354
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 358
  b = (_Bool)0;
#line 360
  i___0 = 0;
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (i___0 < ntokens)) {
#line 360
      goto while_break___0;
    }
    {
#line 361
    tmp___1 = reduce_token_unused_in_grammar(i___0);
    }
#line 361
    if (tmp___1) {
#line 363
      if (! b) {
        {
#line 364
        tmp___0 = gettext("Terminals unused in grammar");
#line 364
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
                tmp___0);
        }
      }
      {
#line 365
      b = (_Bool)1;
#line 366
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   %s\n",
              (*(symbols + i___0))->tag);
      }
    }
#line 360
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 368
  if (b) {
    {
#line 369
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 372
  if (nuseless_productions > 0) {
    {
#line 373
    tmp___2 = gettext("Rules useless in grammar");
#line 373
    grammar_rules_partial_print(out, (char const   *)tmp___2, & rule_useless_in_grammar_p);
    }
  }
#line 375
  return;
}
}
#line 382 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
static void reduce_print(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 385
  if (nuseless_nonterminals > 0) {
    {
#line 387
    tmp = gettext("warning");
#line 387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            grammar_file, tmp);
#line 388
    tmp___0 = ngettext("%d nonterminal useless in grammar", "%d nonterminals useless in grammar",
                       (unsigned long )nuseless_nonterminals);
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            nuseless_nonterminals);
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 394
  if (nuseless_productions > 0) {
    {
#line 396
    tmp___1 = gettext("warning");
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
            grammar_file, tmp___1);
#line 397
    tmp___2 = ngettext("%d rule useless in grammar", "%d rules useless in grammar",
                       (unsigned long )nuseless_productions);
#line 397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            nuseless_productions);
#line 401
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 403
  return;
}
}
#line 405 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
void reduce_grammar(void) 
{ 
  _Bool reduced ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 412
  N = bitset_create((bitset_bindex )nvars, (bitset_attrs )1);
#line 413
  P = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 414
  V = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 415
  V1 = bitset_create((bitset_bindex )nsyms, (bitset_attrs )1);
#line 417
  useless_nonterminals();
#line 418
  inaccessable_symbols();
#line 420
  reduced = (_Bool )(nuseless_nonterminals + nuseless_productions > 0);
  }
#line 421
  if (! reduced) {
#line 422
    return;
  }
  {
#line 424
  reduce_print();
#line 426
  tmp___0 = bitset_test(N, (bitset_bindex )(accept->number - ntokens));
  }
#line 426
  if (! tmp___0) {
    {
#line 427
    tmp = gettext("start symbol %s does not derive any sentence");
#line 427
    fatal_at(startsymbol_location, (char const   *)tmp, startsymbol->tag);
    }
  }
#line 434
  if (nuseless_nonterminals > 0) {
    {
#line 435
    nonterminals_reduce();
    }
  }
#line 436
  if (nuseless_productions > 0) {
    {
#line 437
    reduce_grammar_tables();
    }
  }
#line 439
  if (trace_flag & 128) {
    {
#line 441
    grammar_dump(stderr, "Reduced Grammar");
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reduced %s defines %d terminals, %d nonterminals, and %d productions.\n",
            grammar_file, ntokens, nvars, nrules);
    }
  }
#line 447
  return;
}
}
#line 449 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
_Bool reduce_token_unused_in_grammar(symbol_number i ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 452
  aver((_Bool )(i < ntokens));
#line 453
  tmp = bitset_test(V, (bitset_bindex )i);
  }
#line 453
  if (tmp) {
#line 453
    tmp___1 = 0;
  } else {
    {
#line 453
    tmp___0 = bitset_test(V1, (bitset_bindex )i);
    }
#line 453
    if (tmp___0) {
#line 453
      tmp___1 = 0;
    } else {
#line 453
      tmp___1 = 1;
    }
  }
#line 453
  return ((_Bool )tmp___1);
}
}
#line 456 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
_Bool reduce_nonterminal_useless_in_grammar(symbol_number i ) 
{ 
  int tmp ;

  {
#line 459
  if (ntokens <= i) {
#line 459
    if (i < nsyms + nuseless_nonterminals) {
#line 459
      tmp = 1;
    } else {
#line 459
      tmp = 0;
    }
  } else {
#line 459
    tmp = 0;
  }
  {
#line 459
  aver((_Bool )tmp);
  }
#line 460
  return ((_Bool )(nsyms <= i));
}
}
#line 467 "/home/pronto/abs/test-suite/bison-2.4/src/reduce.c"
void reduce_free(void) 
{ 


  {
  {
#line 470
  bitset_free(N);
#line 471
  bitset_free(V);
#line 472
  bitset_free(V1);
#line 473
  bitset_free(P);
  }
#line 474
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 73 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
struct __anonstruct_location_34  const  empty_location ;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/complain.h"
_Bool complaint_issued ;
#line 117 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
item_number *ritem ;
#line 249
void ritem_print(FILE *out ) ;
#line 52 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern _Bool glr_parser ;
#line 124
extern int warnings_flag ;
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
int gram_debug ;
#line 39
int gram_parse(void) ;
#line 44
void grammar_start_symbol_set(symbol *sym , location loc___0 ) ;
#line 45
void grammar_current_rule_begin(symbol *lhs , location loc___0 ) ;
#line 46
void grammar_current_rule_end(location loc___0 ) ;
#line 47
void grammar_midrule_action(void) ;
#line 48
void grammar_current_rule_prec_set(symbol *precsym , location loc___0 ) ;
#line 49
void grammar_current_rule_dprec_set(int dprec , location loc___0 ) ;
#line 50
void grammar_current_rule_merge_set(uniqstr name , location loc___0 ) ;
#line 51
void grammar_current_rule_symbol_append(symbol *sym , location loc___0 ) ;
#line 52
void grammar_current_rule_action_append(char const   *action , location loc___0 ) ;
#line 53
void reader(void) ;
#line 54
void free_merger_functions(void) ;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
merger_list *merge_functions  ;
#line 65
_Bool default_prec ;
#line 24 "/home/pronto/abs/test-suite/bison-2.4/src/scan-gram.h"
extern FILE *gram_in ;
#line 25
extern int gram__flex_debug ;
#line 26
extern void gram_scanner_initialize(void) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void check_and_convert_grammar(void) ;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static symbol_list *grammar  =    (symbol_list *)((void *)0);
#line 41 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static _Bool start_flag  =    (_Bool)0;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
_Bool union_seen  =    (_Bool)0;
#line 48 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
_Bool tag_seen  =    (_Bool)0;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
_Bool default_prec  =    (_Bool)1;
#line 57 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_start_symbol_set(symbol *sym , location loc___0 ) 
{ 
  char *tmp ;

  {
#line 60
  if (start_flag) {
    {
#line 61
    tmp = gettext("multiple %s declarations");
#line 61
    complain_at(loc___0, (char const   *)tmp, "%start");
    }
  } else {
#line 64
    start_flag = (_Bool)1;
#line 65
    startsymbol = sym;
#line 66
    startsymbol_location = loc___0;
  }
#line 68
  return;
}
}
#line 77 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static int get_merge_function(uniqstr name ) 
{ 
  merger_list *syms ;
  merger_list head ;
  int n ;
  void *tmp ;

  {
#line 84
  if (! glr_parser) {
#line 85
    return (0);
  }
#line 87
  head.next = merge_functions;
#line 88
  syms = & head;
#line 88
  n = 1;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! syms->next) {
#line 88
      goto while_break;
    }
#line 89
    if ((unsigned long )name == (unsigned long )(syms->next)->name) {
#line 90
      goto while_break;
    }
#line 88
    syms = syms->next;
#line 88
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if ((unsigned long )syms->next == (unsigned long )((void *)0)) {
    {
#line 93
    tmp = xmalloc((size_t )sizeof(*(syms->next + 0)));
#line 93
    syms->next = (struct merger_list *)tmp;
#line 94
    (syms->next)->name = uniqstr_new(name);
#line 97
    (syms->next)->type = (uniqstr )((void *)0);
#line 98
    (syms->next)->next = (struct merger_list *)((void *)0);
#line 99
    merge_functions = head.next;
    }
  }
#line 101
  return (n);
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void record_merge_function_type(int merger , uniqstr type , location declaration_loc ) 
{ 
  int merger_find ;
  merger_list *merge_function ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 116
  if (merger <= 0) {
#line 117
    return;
  }
#line 119
  if ((unsigned long )type == (unsigned long )((void *)0)) {
    {
#line 120
    type = uniqstr_new("");
    }
  }
#line 122
  merger_find = 1;
#line 123
  merge_function = merge_functions;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if ((unsigned long )merge_function != (unsigned long )((void *)0)) {
#line 123
      if (! (merger_find != merger)) {
#line 123
        goto while_break;
      }
    } else {
#line 123
      goto while_break;
    }
#line 126
    merger_find ++;
#line 123
    merge_function = merge_function->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if ((unsigned long )merge_function != (unsigned long )((void *)0)) {
#line 127
    if (merger_find == merger) {
#line 127
      tmp = 1;
    } else {
#line 127
      tmp = 0;
    }
  } else {
#line 127
    tmp = 0;
  }
  {
#line 127
  aver((_Bool )tmp);
  }
#line 128
  if ((unsigned long )merge_function->type != (unsigned long )((void *)0)) {
#line 128
    if (! ((unsigned long )merge_function->type == (unsigned long )type)) {
      {
#line 130
      tmp___0 = gettext("result type clash on merge function `%s\': <%s> != <%s>");
#line 130
      complain_at(declaration_loc, (char const   *)tmp___0, merge_function->name,
                  type, merge_function->type);
#line 133
      tmp___1 = gettext("previous declaration");
#line 133
      complain_at(merge_function->type_declaration_location, (char const   *)tmp___1);
      }
    }
  }
  {
#line 136
  merge_function->type = uniqstr_new(type);
#line 137
  merge_function->type_declaration_location = declaration_loc;
  }
#line 138
  return;
}
}
#line 144 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void free_merger_functions(void) 
{ 
  merger_list *L0 ;
  merger_list *L1 ;

  {
#line 147
  L0 = merge_functions;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! L0) {
#line 148
      goto while_break;
    }
    {
#line 150
    L1 = L0->next;
#line 151
    free((void *)L0);
#line 152
    L0 = L1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 169 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static symbol_list *grammar_end  =    (symbol_list *)((void *)0);
#line 172 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void grammar_symbol_append(symbol *sym , location loc___0 ) 
{ 
  symbol_list *p ;
  symbol_list *tmp ;

  {
  {
#line 175
  tmp = symbol_list_sym_new(sym, loc___0);
#line 175
  p = tmp;
  }
#line 177
  if (grammar_end) {
#line 178
    grammar_end->next = p;
  } else {
#line 180
    grammar = p;
  }
#line 182
  grammar_end = p;
#line 186
  if (sym) {
#line 187
    nritems ++;
  }
#line 188
  return;
}
}
#line 193 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static symbol_list *current_rule  =    (symbol_list *)((void *)0);
#line 194 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static symbol_list *previous_rule_end  =    (symbol_list *)((void *)0);
#line 201 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_begin(symbol *lhs , location loc___0 ) 
{ 
  char *tmp ;

  {
  {
#line 205
  nrules ++;
#line 206
  previous_rule_end = grammar_end;
#line 207
  grammar_symbol_append(lhs, loc___0);
#line 208
  current_rule = grammar_end;
  }
#line 211
  if ((unsigned int )lhs->class == 0U) {
#line 213
    lhs->class = (symbol_class )2;
#line 214
    lhs->number = nvars;
#line 215
    nvars ++;
  } else
#line 217
  if ((unsigned int )lhs->class == 1U) {
    {
#line 218
    tmp = gettext("rule given for %s, which is a token");
#line 218
    complain_at(loc___0, (char const   *)tmp, lhs->tag);
    }
  }
#line 219
  return;
}
}
#line 230 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static _Bool symbol_should_be_used(symbol_list const   *s ) 
{ 
  code_props const   *tmp ;
  symbol_list *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 233
  tmp = symbol_destructor_get((symbol const   *)s->content.sym);
  }
#line 233
  if (tmp->code) {
#line 234
    return ((_Bool)1);
  }
#line 235
  if (warnings_flag & 2) {
#line 236
    if (s->midrule) {
#line 236
      if ((s->midrule)->action_props.is_value_used) {
#line 236
        tmp___1 = 1;
      } else {
#line 236
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 236
    if (s->midrule_parent_rule) {
      {
#line 236
      tmp___0 = symbol_list_n_get((symbol_list *)s->midrule_parent_rule, (int )s->midrule_parent_rhs_index);
      }
#line 236
      if (tmp___0->action_props.is_value_used) {
#line 236
        tmp___1 = 1;
      } else {
#line 236
        tmp___1 = 0;
      }
    } else {
#line 236
      tmp___1 = 0;
    }
#line 236
    return ((_Bool )tmp___1);
  }
#line 241
  return ((_Bool)0);
}
}
#line 249 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void grammar_rule_check(symbol_list const   *r ) 
{ 
  symbol *first_rhs ;
  char const   *lhs_type ;
  char const   *rhs_type ;
  uniqstr tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  symbol_list const   *l ;
  int n ;
  char *tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;

  {
#line 259
  if (! r->action_props.code) {
#line 259
    if ((r->content.sym)->type_name) {
#line 261
      first_rhs = (r->next)->content.sym;
#line 263
      if (first_rhs) {
#line 265
        lhs_type = (r->content.sym)->type_name;
#line 266
        if (first_rhs->type_name) {
#line 266
          tmp = first_rhs->type_name;
        } else {
#line 266
          tmp = "";
        }
#line 266
        rhs_type = tmp;
#line 268
        if (! ((unsigned long )lhs_type == (unsigned long )rhs_type)) {
          {
#line 269
          tmp___0 = gettext("type clash on default action: <%s> != <%s>");
#line 269
          warn_at((location )r->location, (char const   *)tmp___0, lhs_type, rhs_type);
          }
        }
      } else {
        {
#line 275
        tmp___1 = gettext("empty rule for typed nonterminal, and no action");
#line 275
        warn_at((location )r->location, (char const   *)tmp___1);
        }
      }
    }
  }
#line 281
  l = r;
#line 282
  n = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (l) {
#line 283
      if (! l->content.sym) {
#line 283
        goto while_break;
      }
    } else {
#line 283
      goto while_break;
    }
#line 284
    if (! l->action_props.is_value_used) {
      {
#line 284
      tmp___4 = symbol_should_be_used(l);
      }
#line 284
      if (tmp___4) {
#line 284
        if (! r->action_props.code) {
#line 284
          if (! (n == 0)) {
#line 284
            if (! (n == 1)) {
#line 284
              goto _L;
            }
          }
        } else
        _L: /* CIL Label */ 
#line 289
        if (n) {
          {
#line 290
          tmp___2 = gettext("unused value: $%d");
#line 290
          warn_at((location )r->location, (char const   *)tmp___2, n);
          }
        } else {
          {
#line 292
          tmp___3 = gettext("unset value: $$");
#line 292
          warn_at((location )r->location, (char const   *)tmp___3);
          }
        }
      }
    }
#line 283
    l = (symbol_list const   *)l->next;
#line 283
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 302 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_end(location loc___0 ) 
{ 


  {
  {
#line 306
  grammar_symbol_append((symbol *)((void *)0), grammar_end->location);
#line 307
  current_rule->location = loc___0;
  }
#line 308
  return;
}
}
#line 318 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_midrule_action(void) 
{ 
  location dummy_location ;
  symbol *dummy ;
  symbol *tmp ;
  symbol_list *midrule ;
  symbol_list *tmp___0 ;

  {
  {
#line 327
  dummy_location = current_rule->action_props.location;
#line 328
  tmp = dummy_symbol_get(dummy_location);
#line 328
  dummy = tmp;
#line 329
  tmp___0 = symbol_list_sym_new(dummy, dummy_location);
#line 329
  midrule = tmp___0;
#line 333
  nrules ++;
#line 334
  nritems ++;
#line 336
  midrule->location = dummy_location;
#line 337
  code_props_rule_action_init(& midrule->action_props, current_rule->action_props.code,
                              current_rule->action_props.location, midrule);
#line 341
  code_props_none_init(& current_rule->action_props);
  }
#line 343
  if (previous_rule_end) {
#line 344
    previous_rule_end->next = midrule;
  } else {
#line 346
    grammar = midrule;
  }
  {
#line 349
  midrule->next = symbol_list_sym_new((symbol *)((void *)0), dummy_location);
#line 350
  (midrule->next)->next = current_rule;
#line 352
  previous_rule_end = midrule->next;
#line 356
  grammar_current_rule_symbol_append(dummy, dummy_location);
#line 357
  grammar_end->midrule = midrule;
#line 358
  midrule->midrule_parent_rule = current_rule;
#line 359
  midrule->midrule_parent_rhs_index = symbol_list_length((symbol_list const   *)current_rule->next);
  }
#line 360
  return;
}
}
#line 364 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_prec_set(symbol *precsym , location loc___0 ) 
{ 
  char *tmp ;

  {
  {
#line 367
  symbol_class_set(precsym, (symbol_class )1, loc___0, (_Bool)0);
  }
#line 368
  if (current_rule->ruleprec) {
    {
#line 369
    tmp = gettext("only one %s allowed per rule");
#line 369
    complain_at(loc___0, (char const   *)tmp, "%prec");
    }
  }
#line 370
  current_rule->ruleprec = precsym;
#line 371
  return;
}
}
#line 375 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_dprec_set(int dprec , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 378
  if (! glr_parser) {
    {
#line 379
    tmp = gettext("%s affects only GLR parsers");
#line 379
    warn_at(loc___0, (char const   *)tmp, "%dprec");
    }
  }
#line 380
  if (dprec <= 0) {
    {
#line 381
    tmp___0 = gettext("%s must be followed by positive number");
#line 381
    complain_at(loc___0, (char const   *)tmp___0, "%dprec");
    }
  } else
#line 382
  if (current_rule->dprec != 0) {
    {
#line 383
    tmp___1 = gettext("only one %s allowed per rule");
#line 383
    complain_at(loc___0, (char const   *)tmp___1, "%dprec");
    }
  }
#line 384
  current_rule->dprec = dprec;
#line 385
  return;
}
}
#line 390 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_merge_set(uniqstr name , location loc___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 393
  if (! glr_parser) {
    {
#line 394
    tmp = gettext("%s affects only GLR parsers");
#line 394
    warn_at(loc___0, (char const   *)tmp, "%merge");
    }
  }
#line 395
  if (current_rule->merger != 0) {
    {
#line 396
    tmp___0 = gettext("only one %s allowed per rule");
#line 396
    complain_at(loc___0, (char const   *)tmp___0, "%merge");
    }
  }
  {
#line 397
  current_rule->merger = get_merge_function(name);
#line 398
  current_rule->merger_declaration_location = loc___0;
  }
#line 399
  return;
}
}
#line 404 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_symbol_append(symbol *sym , location loc___0 ) 
{ 


  {
#line 407
  if (current_rule->action_props.code) {
    {
#line 408
    grammar_midrule_action();
    }
  }
  {
#line 409
  grammar_symbol_append(sym, loc___0);
  }
#line 410
  return;
}
}
#line 414 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void grammar_current_rule_action_append(char const   *action , location loc___0 ) 
{ 


  {
#line 417
  if (current_rule->action_props.code) {
    {
#line 418
    grammar_midrule_action();
    }
  }
  {
#line 421
  code_props_rule_action_init(& current_rule->action_props, action, loc___0, current_rule);
  }
#line 423
  return;
}
}
#line 431 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void packgram(void) 
{ 
  unsigned int itemno ;
  rule_number ruleno ;
  symbol_list *p ;
  void *tmp ;
  item_number *tmp___0 ;
  void *tmp___1 ;
  int rule_length ;
  symbol *ruleprec ;
  symbol_list *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 434
  itemno = 0U;
#line 435
  ruleno = 0;
#line 436
  p = grammar;
#line 438
  tmp = xnmalloc(nritems + 1U, (size_t )sizeof(*ritem));
#line 438
  ritem = (item_number *)tmp;
#line 441
  tmp___0 = ritem;
#line 441
  ritem ++;
#line 441
  *tmp___0 = 0;
#line 443
  tmp___1 = xnmalloc((size_t )nrules, (size_t )sizeof(*rules));
#line 443
  rules = (rule *)tmp___1;
  }
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! p) {
#line 445
      goto while_break;
    }
    {
#line 447
    rule_length = 0;
#line 448
    ruleprec = p->ruleprec;
#line 449
    record_merge_function_type(p->merger, (p->content.sym)->type_name, p->merger_declaration_location);
#line 451
    (rules + ruleno)->user_number = ruleno;
#line 452
    (rules + ruleno)->number = ruleno;
#line 453
    (rules + ruleno)->lhs = p->content.sym;
#line 454
    (rules + ruleno)->rhs = ritem + itemno;
#line 455
    (rules + ruleno)->prec = (symbol *)((void *)0);
#line 456
    (rules + ruleno)->dprec = p->dprec;
#line 457
    (rules + ruleno)->merger = p->merger;
#line 458
    (rules + ruleno)->precsym = (symbol *)((void *)0);
#line 459
    (rules + ruleno)->location = p->location;
#line 460
    (rules + ruleno)->useful = (_Bool)1;
#line 461
    (rules + ruleno)->action = p->action_props.code;
#line 462
    (rules + ruleno)->action_location = p->action_props.location;
    }
#line 467
    if (p->midrule_parent_rule) {
#line 467
      if (p->action_props.is_value_used) {
#line 472
        ((p->content.sym)->tag) ++;
      } else {
        {
#line 467
        tmp___2 = symbol_list_n_get(p->midrule_parent_rule, p->midrule_parent_rhs_index);
        }
#line 467
        if (tmp___2->action_props.is_value_used) {
#line 472
          ((p->content.sym)->tag) ++;
        }
      }
    }
#line 477
    if ((unsigned long )p != (unsigned long )grammar) {
      {
#line 478
      grammar_rule_check((symbol_list const   *)p);
      }
    }
#line 480
    p = p->next;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (p) {
#line 480
        if (! p->content.sym) {
#line 480
          goto while_break___0;
        }
      } else {
#line 480
        goto while_break___0;
      }
#line 482
      rule_length ++;
#line 486
      if (rule_length == 2147483647) {
        {
#line 487
        tmp___3 = gettext("rule is too long");
#line 487
        fatal_at((rules + ruleno)->location, (char const   *)tmp___3);
        }
      }
      {
#line 491
      tmp___4 = itemno;
#line 491
      itemno ++;
#line 491
      *(ritem + tmp___4) = symbol_number_as_item_number((p->content.sym)->number);
      }
#line 495
      if ((unsigned int )(p->content.sym)->class == 1U) {
#line 495
        if (default_prec) {
#line 496
          (rules + ruleno)->prec = p->content.sym;
        }
      }
#line 480
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 501
    if (ruleprec) {
#line 503
      (rules + ruleno)->precsym = ruleprec;
#line 504
      (rules + ruleno)->prec = ruleprec;
    }
    {
#line 507
    tmp___5 = itemno;
#line 507
    itemno ++;
#line 507
    *(ritem + tmp___5) = rule_number_as_item_number(ruleno);
#line 508
    aver((_Bool )(itemno < 2147483647U));
#line 509
    ruleno ++;
#line 510
    aver((_Bool )(ruleno < 2147483647));
    }
#line 512
    if (p) {
#line 513
      p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 516
  aver((_Bool )(itemno == nritems));
  }
#line 518
  if (trace_flag & 8) {
    {
#line 519
    ritem_print(stderr);
    }
  }
#line 520
  return;
}
}
#line 529 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
void reader(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 533
  symbols_new();
#line 536
  accept = symbol_get("$accept", (location )empty_location);
#line 537
  accept->class = (symbol_class )2;
#line 538
  tmp = nvars;
#line 538
  nvars ++;
#line 538
  accept->number = tmp;
#line 541
  errtoken = symbol_get("error", (location )empty_location);
#line 542
  errtoken->class = (symbol_class )1;
#line 543
  tmp___0 = ntokens;
#line 543
  ntokens ++;
#line 543
  errtoken->number = tmp___0;
#line 547
  undeftoken = symbol_get("$undefined", (location )empty_location);
#line 548
  undeftoken->class = (symbol_class )1;
#line 549
  tmp___1 = ntokens;
#line 549
  ntokens ++;
#line 549
  undeftoken->number = tmp___1;
#line 551
  gram_in = xfopen(grammar_file, "r");
#line 553
  gram__flex_debug = trace_flag & 1;
#line 554
  gram_debug = trace_flag & 2;
#line 555
  gram_scanner_initialize();
#line 556
  gram_parse();
  }
#line 558
  if (! complaint_issued) {
    {
#line 559
    check_and_convert_grammar();
    }
  }
  {
#line 561
  xfclose(gram_in);
  }
#line 562
  return;
}
}
#line 570 "/home/pronto/abs/test-suite/bison-2.4/src/reader.c"
static void check_and_convert_grammar(void) 
{ 
  char *tmp ;
  symbol_list *node ;
  _Bool tmp___0 ;
  symbol_list *p ;
  symbol_list *tmp___1 ;
  int tmp___2 ;
  symbol_list *sym ;

  {
#line 574
  if (nrules == 0) {
    {
#line 575
    tmp = gettext("no rules in the input grammar");
#line 575
    fatal((char const   *)tmp);
    }
  }
  {
#line 578
  symbols_check_defined();
  }
#line 581
  if (! endtoken) {
    {
#line 583
    endtoken = symbol_get("$end", (location )empty_location);
#line 584
    endtoken->class = (symbol_class )1;
#line 585
    endtoken->number = 0;
#line 587
    endtoken->user_token_number = 0;
    }
  }
#line 591
  if (! start_flag) {
#line 594
    node = grammar;
    {
#line 594
    while (1) {
      while_continue: /* CIL Label */ ;
#line 594
      if ((unsigned long )node != (unsigned long )((void *)0)) {
        {
#line 594
        tmp___0 = symbol_is_dummy((symbol const   *)node->content.sym);
        }
#line 594
        if (! tmp___0) {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
#line 598
      node = node->next;
      {
#line 598
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 598
        if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 598
          if (! ((unsigned long )node->content.sym != (unsigned long )((void *)0))) {
#line 598
            goto while_break___0;
          }
        } else {
#line 598
          goto while_break___0;
        }
#line 598
        node = node->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 594
      node = node->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 603
    aver((_Bool )((unsigned long )node != (unsigned long )((void *)0)));
#line 604
    grammar_start_symbol_set(node->content.sym, (node->content.sym)->location);
    }
  }
  {
#line 613
  tmp___1 = symbol_list_sym_new(accept, (location )empty_location);
#line 613
  p = tmp___1;
#line 614
  p->location = grammar->location;
#line 615
  p->next = symbol_list_sym_new(startsymbol, (location )empty_location);
#line 616
  (p->next)->next = symbol_list_sym_new(endtoken, (location )empty_location);
#line 617
  ((p->next)->next)->next = symbol_list_sym_new((symbol *)((void *)0), (location )empty_location);
#line 618
  (((p->next)->next)->next)->next = grammar;
#line 619
  nrules ++;
#line 620
  nritems += 3U;
#line 621
  grammar = p;
  }
#line 624
  if (nsyms <= 2147483647) {
#line 624
    if (nsyms == ntokens + nvars) {
#line 624
      tmp___2 = 1;
    } else {
#line 624
      tmp___2 = 0;
    }
  } else {
#line 624
    tmp___2 = 0;
  }
  {
#line 624
  aver((_Bool )tmp___2);
#line 628
  symbols_pack();
#line 643
  sym = grammar;
  }
  {
#line 643
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 643
    if (! sym) {
#line 643
      goto while_break___1;
    }
    {
#line 644
    code_props_translate_code(& sym->action_props);
#line 643
    sym = sym->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 648
  packgram();
#line 651
  symbol_list_free(grammar);
  }
#line 652
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 364 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) stpcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 336 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 157 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static rule_number item_number_as_rule_number(item_number i ) 
{ 


  {
#line 160
  return (-1 - i);
}
}
#line 163 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static _Bool item_number_is_rule_number(item_number i ) 
{ 


  {
#line 166
  return ((_Bool )(i < 0));
}
}
#line 261
void grammar_rules_print_xml(FILE *out , int level ) ;
#line 219 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern state_number nstates ;
#line 232
extern int state_reduction_find(state *s , rule *r ) ;
#line 240
extern void state_rule_lookahead_tokens_print_xml(state *s , rule *r , FILE *out ,
                                                  int level ) ;
#line 261
extern state **states ;
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/closure.h"
void new_closure(unsigned int n ) ;
#line 47
void closure(item_number *core , size_t n ) ;
#line 52
void free_closure(void) ;
#line 54
item_number *itemset ;
#line 55
size_t nitemset ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *spec_xml_file ;
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.h"
void xml_indent(FILE *out , int level ) ;
#line 26
void xml_puts(FILE *out , int level , char const   *s ) ;
#line 27
void xml_printf(FILE *out , int level , char const   *fmt  , ...) ;
#line 28
char const   *xml_escape_n(int n , char const   *str ) ;
#line 29
char const   *xml_escape(char const   *str ) ;
#line 30
void print_xml(void) ;
#line 111 "/home/pronto/abs/test-suite/bison-2.4/src/tables.h"
extern rule_number *yydefact ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static bitset no_reduce_set  ;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static struct escape_buf escape_bufs[2]  ;
#line 58 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_core(FILE *out , int level , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  _Bool printed ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  reductions *reds ;
  int red ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 62
  sitems = s->items;
#line 63
  snritems = s->nitems;
#line 66
  closure(sitems, snritems);
#line 67
  sitems = itemset;
#line 68
  snritems = nitemset;
  }
#line 70
  if (! snritems) {
    {
#line 71
    xml_puts(out, level, "<itemset/>");
    }
#line 72
    return;
  }
  {
#line 75
  xml_puts(out, level, "<itemset>");
#line 77
  i = (size_t )0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < snritems)) {
#line 77
      goto while_break;
    }
#line 79
    printed = (_Bool)0;
#line 84
    sp = ritem + *(sitems + i);
#line 84
    sp1 = sp;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! (*sp >= 0)) {
#line 86
        goto while_break___0;
      }
#line 87
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    r = item_number_as_rule_number(*sp);
#line 90
    sp = (rules + r)->rhs;
#line 93
    tmp___0 = item_number_is_rule_number(*sp1);
    }
#line 93
    if (tmp___0) {
      {
#line 95
      reds = s->reductions;
#line 96
      tmp = state_reduction_find(s, rules + r);
#line 96
      red = tmp;
      }
#line 98
      if (reds->lookahead_tokens) {
#line 98
        if (red != -1) {
          {
#line 100
          xml_printf(out, level + 1, "<item rule-number=\"%d\" point=\"%d\">", (rules + r)->number,
                     sp1 - sp);
#line 103
          state_rule_lookahead_tokens_print_xml(s, rules + r, out, level + 2);
#line 105
          xml_puts(out, level + 1, "</item>");
#line 106
          printed = (_Bool)1;
          }
        }
      }
    }
#line 110
    if (! printed) {
      {
#line 112
      xml_printf(out, level + 1, "<item rule-number=\"%d\" point=\"%d\"/>", (rules + r)->number,
                 sp1 - sp);
      }
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  xml_puts(out, level, "</itemset>");
  }
#line 119
  return;
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_transitions(state *s , FILE *out , int level ) 
{ 
  transitions *trans ;
  int n ;
  int i ;
  symbol *sym ;
  char const   *tag ;
  state *s1 ;
  char const   *tmp ;
  symbol *sym___0 ;
  char const   *tag___0 ;
  state *s1___0 ;
  char const   *tmp___0 ;

  {
#line 130
  trans = s->transitions;
#line 131
  n = 0;
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < trans->num)) {
#line 134
      goto while_break;
    }
#line 135
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 137
      n ++;
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (! n) {
    {
#line 142
    xml_puts(out, level, "<transitions/>");
    }
#line 143
    return;
  }
  {
#line 147
  xml_puts(out, level, "<transitions>");
#line 149
  i = 0;
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! (i < trans->num)) {
#line 149
      goto while_break___0;
    }
#line 150
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 150
      if ((trans->states[i])->accessing_symbol < ntokens) {
        {
#line 153
        sym = *(symbols + (trans->states[i])->accessing_symbol);
#line 154
        tag = sym->tag;
#line 155
        s1 = trans->states[i];
#line 157
        tmp = xml_escape(tag);
#line 157
        xml_printf(out, level + 1, "<transition type=\"shift\" symbol=\"%s\" state=\"%d\"/>",
                   tmp, s1->number);
        }
      }
    }
#line 149
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 162
    if (! (i < trans->num)) {
#line 162
      goto while_break___1;
    }
#line 163
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 163
      if (! ((trans->states[i])->accessing_symbol < ntokens)) {
        {
#line 166
        sym___0 = *(symbols + (trans->states[i])->accessing_symbol);
#line 167
        tag___0 = sym___0->tag;
#line 168
        s1___0 = trans->states[i];
#line 170
        tmp___0 = xml_escape(tag___0);
#line 170
        xml_printf(out, level + 1, "<transition type=\"goto\" symbol=\"%s\" state=\"%d\"/>",
                   tmp___0, s1___0->number);
        }
      }
    }
#line 162
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 175
  xml_puts(out, level, "</transitions>");
  }
#line 176
  return;
}
}
#line 183 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_errs(FILE *out , int level , state *s ) 
{ 
  errs *errp ;
  _Bool count ;
  int i ;
  char const   *tag ;
  char const   *tmp ;

  {
#line 186
  errp = s->errs;
#line 187
  count = (_Bool)0;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < errp->num)) {
#line 190
      goto while_break;
    }
#line 191
    if (errp->symbols[i]) {
#line 192
      count = (_Bool)1;
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (! count) {
    {
#line 196
    xml_puts(out, level, "<errors/>");
    }
#line 197
    return;
  }
  {
#line 201
  xml_puts(out, level, "<errors>");
#line 202
  i = 0;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! (i < errp->num)) {
#line 202
      goto while_break___0;
    }
#line 203
    if (errp->symbols[i]) {
      {
#line 205
      tag = (errp->symbols[i])->tag;
#line 206
      tmp = xml_escape(tag);
#line 206
      xml_printf(out, level + 1, "<error symbol=\"%s\">nonassociative</error>", tmp);
      }
    }
#line 202
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  xml_puts(out, level, "</errors>");
  }
#line 211
  return;
}
}
#line 220 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_reduction(FILE *out , int level , char const   *lookahead_token ,
                            rule *r , _Bool enabled ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 224
  if (r->number) {
#line 225
    if (enabled) {
#line 225
      tmp = "true";
    } else {
#line 225
      tmp = "false";
    }
    {
#line 225
    tmp___0 = xml_escape(lookahead_token);
#line 225
    xml_printf(out, level, "<reduction symbol=\"%s\" rule=\"%d\" enabled=\"%s\"/>",
               tmp___0, r->number, tmp);
    }
  } else {
#line 231
    if (enabled) {
#line 231
      tmp___1 = "true";
    } else {
#line 231
      tmp___1 = "false";
    }
    {
#line 231
    tmp___2 = xml_escape(lookahead_token);
#line 231
    xml_printf(out, level, "<reduction symbol=\"%s\" rule=\"accept\" enabled=\"%s\"/>",
               tmp___2, tmp___1);
    }
  }
#line 235
  return;
}
}
#line 242 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_reductions(FILE *out , int level , state *s ) 
{ 
  transitions *trans ;
  reductions *reds ;
  rule *default_rule ;
  int report ;
  int i ;
  int j ;
  _Bool count ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool defaulted ;
  _Bool count___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 245
  trans = s->transitions;
#line 246
  reds = s->reductions;
#line 247
  default_rule = (rule *)((void *)0);
#line 248
  report = 0;
#line 251
  if (reds->num == 0) {
    {
#line 252
    xml_puts(out, level, "<reductions/>");
    }
#line 253
    return;
  }
#line 256
  if (*(yydefact + s->number) != 0) {
#line 257
    default_rule = rules + (*(yydefact + s->number) - 1);
  }
  {
#line 259
  (*((no_reduce_set->b.vtable)->zero))(no_reduce_set);
#line 260
  i = 0;
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (i < trans->num) {
#line 260
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 260
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 260
          goto while_break;
        }
      }
    } else {
#line 260
      goto while_break;
    }
#line 260
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 261
      bitset_set(no_reduce_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 262
    if (! (i < (s->errs)->num)) {
#line 262
      goto while_break___0;
    }
#line 263
    if ((s->errs)->symbols[i]) {
      {
#line 264
      bitset_set(no_reduce_set, (bitset_bindex )((s->errs)->symbols[i])->number);
      }
    }
#line 262
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  if (default_rule) {
#line 267
    report = 1;
  }
#line 269
  if (reds->lookahead_tokens) {
#line 270
    i = 0;
    {
#line 270
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 270
      if (! (i < ntokens)) {
#line 270
        goto while_break___1;
      }
      {
#line 272
      tmp = bitset_test(no_reduce_set, (bitset_bindex )i);
#line 272
      count = tmp;
#line 274
      j = 0;
      }
      {
#line 274
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 274
        if (! (j < reds->num)) {
#line 274
          goto while_break___2;
        }
        {
#line 275
        tmp___0 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 275
        if (tmp___0) {
#line 277
          if (! count) {
#line 279
            if ((unsigned long )reds->rules[j] != (unsigned long )default_rule) {
#line 280
              report = 1;
            }
#line 281
            count = (_Bool)1;
          } else {
#line 285
            report = 1;
          }
        }
#line 274
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 270
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 291
  if (! report) {
    {
#line 292
    xml_puts(out, level, "<reductions/>");
    }
#line 293
    return;
  }
  {
#line 296
  xml_puts(out, level, "<reductions>");
  }
#line 299
  if (reds->lookahead_tokens) {
#line 300
    i = 0;
    {
#line 300
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 300
      if (! (i < ntokens)) {
#line 300
        goto while_break___3;
      }
      {
#line 302
      defaulted = (_Bool)0;
#line 303
      tmp___1 = bitset_test(no_reduce_set, (bitset_bindex )i);
#line 303
      count___0 = tmp___1;
#line 305
      j = 0;
      }
      {
#line 305
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 305
        if (! (j < reds->num)) {
#line 305
          goto while_break___4;
        }
        {
#line 306
        tmp___2 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 306
        if (tmp___2) {
#line 308
          if (! count___0) {
#line 310
            if ((unsigned long )reds->rules[j] != (unsigned long )default_rule) {
              {
#line 311
              print_reduction(out, level + 1, (*(symbols + i))->tag, reds->rules[j],
                              (_Bool)1);
              }
            } else {
#line 314
              defaulted = (_Bool)1;
            }
#line 315
            count___0 = (_Bool)1;
          } else {
#line 319
            if (defaulted) {
              {
#line 320
              print_reduction(out, level + 1, (*(symbols + i))->tag, default_rule,
                              (_Bool)1);
              }
            }
            {
#line 322
            defaulted = (_Bool)0;
#line 323
            print_reduction(out, level + 1, (*(symbols + i))->tag, reds->rules[j],
                            (_Bool)0);
            }
          }
        }
#line 305
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 300
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 329
  if (default_rule) {
    {
#line 330
    print_reduction(out, level + 1, "$default", default_rule, (_Bool)1);
    }
  }
  {
#line 333
  xml_puts(out, level, "</reductions>");
  }
#line 334
  return;
}
}
#line 342 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_actions(FILE *out , int level , state *s ) 
{ 


  {
  {
#line 345
  xml_puts(out, level, "<actions>");
#line 346
  print_transitions(s, out, level + 1);
#line 347
  print_errs(out, level + 1, s);
#line 348
  print_reductions(out, level + 1, s);
#line 349
  xml_puts(out, level, "</actions>");
  }
#line 350
  return;
}
}
#line 357 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_state(FILE *out , int level , state *s ) 
{ 


  {
  {
#line 360
  fputc_unlocked('\n', out);
#line 361
  xml_printf(out, level, "<state number=\"%d\">", s->number);
#line 362
  print_core(out, level + 1, s);
#line 363
  print_actions(out, level + 1, s);
  }
#line 364
  if (s->solved_conflicts_xml) {
    {
#line 366
    xml_puts(out, level + 1, "<solved-conflicts>");
#line 367
    fputs_unlocked((char const   */* __restrict  */)s->solved_conflicts_xml, (FILE */* __restrict  */)out);
#line 368
    xml_puts(out, level + 1, "</solved-conflicts>");
    }
  } else {
    {
#line 371
    xml_puts(out, level + 1, "<solved-conflicts/>");
    }
  }
  {
#line 372
  xml_puts(out, level, "</state>");
  }
#line 373
  return;
}
}
#line 380 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static void print_grammar(FILE *out , int level ) 
{ 
  symbol_number i ;
  char const   *tag ;
  int precedence ;
  assoc associativity ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tag___0 ;
  char const   *tmp___5 ;
  _Bool tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 385
  fputc_unlocked('\n', out);
#line 386
  xml_puts(out, level, "<grammar>");
#line 387
  grammar_rules_print_xml(out, level);
#line 390
  xml_puts(out, level + 1, "<terminals>");
#line 391
  i = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (i < max_user_token_number + 1)) {
#line 391
      goto while_break;
    }
#line 392
    if (*(token_translations + i) != undeftoken->number) {
      {
#line 394
      tag = (*(symbols + *(token_translations + i)))->tag;
#line 395
      precedence = (*(symbols + *(token_translations + i)))->prec;
#line 396
      associativity = (*(symbols + *(token_translations + i)))->assoc;
#line 397
      xml_indent(out, level + 2);
#line 398
      tmp___1 = reduce_token_unused_in_grammar(*(token_translations + i));
      }
#line 398
      if (tmp___1) {
#line 398
        tmp___0 = "unused-in-grammar";
      } else {
#line 398
        tmp___0 = "useful";
      }
      {
#line 398
      tmp___2 = xml_escape(tag);
#line 398
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"<terminal symbol-number=\"%d\" token-number=\"%d\" name=\"%s\" usefulness=\"%s\"",
              *(token_translations + i), i, tmp___2, tmp___0);
      }
#line 404
      if (precedence) {
        {
#line 405
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" prec=\"%d\"",
                precedence);
        }
      }
#line 406
      if ((unsigned int )associativity != 0U) {
        {
#line 407
        tmp___3 = assoc_to_string(associativity);
#line 407
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" assoc=\"%s\"",
                tmp___3 + 1);
        }
      }
      {
#line 408
      fputs_unlocked((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)out);
      }
    }
#line 391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  xml_puts(out, level + 1, "</terminals>");
#line 413
  xml_puts(out, level + 1, "<nonterminals>");
#line 414
  i = ntokens;
  }
  {
#line 414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 414
    if (! (i < nsyms + nuseless_nonterminals)) {
#line 414
      goto while_break___0;
    }
    {
#line 416
    tag___0 = (*(symbols + i))->tag;
#line 417
    tmp___6 = reduce_nonterminal_useless_in_grammar(i);
    }
#line 417
    if (tmp___6) {
#line 417
      tmp___5 = "useless-in-grammar";
    } else {
#line 417
      tmp___5 = "useful";
    }
    {
#line 417
    tmp___7 = xml_escape(tag___0);
#line 417
    xml_printf(out, level + 2, "<nonterminal symbol-number=\"%d\" name=\"%s\" usefulness=\"%s\"/>",
               i, tmp___7, tmp___5);
#line 414
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 424
  xml_puts(out, level + 1, "</nonterminals>");
#line 425
  xml_puts(out, level, "</grammar>");
  }
#line 426
  return;
}
}
#line 428 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
void xml_indent(FILE *out , int level ) 
{ 
  int i ;

  {
#line 432
  i = 0;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < level)) {
#line 432
      goto while_break;
    }
    {
#line 433
    fputs_unlocked((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)out);
#line 432
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 436 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
void xml_puts(FILE *out , int level , char const   *s ) 
{ 


  {
  {
#line 439
  xml_indent(out, level);
#line 440
  fputs_unlocked((char const   */* __restrict  */)s, (FILE */* __restrict  */)out);
#line 441
  fputc_unlocked('\n', out);
  }
#line 442
  return;
}
}
#line 444 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
void xml_printf(FILE *out , int level , char const   *fmt  , ...) 
{ 
  va_list arglist ;

  {
  {
#line 449
  xml_indent(out, level);
#line 451
  __builtin_va_start(arglist, fmt);
#line 452
  vfprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)fmt, arglist);
#line 453
  __builtin_va_end(arglist);
#line 455
  fputc_unlocked('\n', out);
  }
#line 456
  return;
}
}
#line 458 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
static char const   *xml_escape_string(struct escape_buf *buf___0 , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t max_expansion ;
  char *p ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 461
  tmp = strlen(str);
#line 461
  len = tmp;
#line 462
  max_expansion = (size_t )(sizeof("&quot;") - 1UL);
  }
#line 465
  if (buf___0->size <= max_expansion * len) {
    {
#line 467
    buf___0->size = max_expansion * len + 1U;
#line 468
    tmp___0 = x2realloc((void *)buf___0->ptr, & buf___0->size);
#line 468
    buf___0->ptr = (char *)tmp___0;
    }
  }
#line 470
  p = buf___0->ptr;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! *str) {
#line 472
      goto while_break;
    }
    {
#line 476
    if ((int const   )*str == 38) {
#line 476
      goto case_38;
    }
#line 477
    if ((int const   )*str == 60) {
#line 477
      goto case_60;
    }
#line 478
    if ((int const   )*str == 62) {
#line 478
      goto case_62;
    }
#line 479
    if ((int const   )*str == 34) {
#line 479
      goto case_34;
    }
#line 475
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 475
    tmp___1 = p;
#line 475
    p ++;
#line 475
    *tmp___1 = (char )*str;
#line 475
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 476
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&amp;");
    }
#line 476
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 477
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&lt;");
    }
#line 477
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 478
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&gt;");
    }
#line 478
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 479
    p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"&quot;");
    }
#line 479
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 472
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  *p = (char )'\000';
#line 483
  return ((char const   *)buf___0->ptr);
}
}
#line 486 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
char const   *xml_escape_n(int n , char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 489
  tmp = xml_escape_string(escape_bufs + n, str);
  }
#line 489
  return (tmp);
}
}
#line 492 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
char const   *xml_escape(char const   *str ) 
{ 
  char const   *tmp ;

  {
  {
#line 495
  tmp = xml_escape_n(0, str);
  }
#line 495
  return (tmp);
}
}
#line 498 "/home/pronto/abs/test-suite/bison-2.4/src/print-xml.c"
void print_xml(void) 
{ 
  state_number i ;
  int level ;
  FILE *out ;
  FILE *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 502
  level = 0;
#line 504
  tmp = xfopen((char const   *)spec_xml_file, "w");
#line 504
  out = tmp;
#line 506
  fputs_unlocked((char const   */* __restrict  */)"<?xml version=\"1.0\"?>\n\n", (FILE */* __restrict  */)out);
#line 507
  tmp___0 = xml_escape("2.4");
#line 507
  xml_printf(out, level, "<bison-xml-report version=\"%s\">", tmp___0);
#line 510
  fputc_unlocked('\n', out);
#line 511
  tmp___1 = xml_escape(grammar_file);
#line 511
  xml_printf(out, level + 1, "<filename>%s</filename>", tmp___1);
#line 515
  print_grammar(out, level + 1);
#line 517
  new_closure(nritems);
#line 518
  no_reduce_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 521
  fputc_unlocked('\n', out);
#line 522
  xml_puts(out, level + 1, "<automaton>");
#line 523
  i = 0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < nstates)) {
#line 523
      goto while_break;
    }
    {
#line 524
    print_state(out, level + 2, *(states + i));
#line 523
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  xml_puts(out, level + 1, "</automaton>");
#line 527
  bitset_free(no_reduce_set);
#line 528
  free_closure();
#line 530
  xml_puts(out, 0, "</bison-xml-report>");
#line 532
  free((void *)escape_bufs[0].ptr);
#line 533
  free((void *)escape_bufs[1].ptr);
#line 535
  xfclose(out);
  }
#line 536
  return;
}
}
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *spec_graph_file ;
#line 87 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern int report_flag ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/src/print_graph.h"
void print_graph(void) ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/print_graph.c"
static void print_core___0(struct obstack *oout , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  char buf___1[4096] ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  char buf___2[4096] ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  char *tmp___2 ;
  char buf___3[4096] ;
  struct obstack *__o___3 ;
  int __len___2 ;
  size_t tmp___3 ;
  reductions *reds ;
  int redno ;
  int tmp___4 ;
  bitset_iterator biter ;
  int k ;
  char const   *sep ;
  struct obstack *__o___4 ;
  int __len___3 ;
  size_t tmp___5 ;
  char buf___4[4096] ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___6 ;
  struct obstack *__o___6 ;
  int __len___5 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;

  {
#line 49
  sitems = s->items;
#line 50
  snritems = s->nitems;
#line 53
  if (report_flag & 2) {
    {
#line 55
    closure(sitems, snritems);
#line 56
    sitems = itemset;
#line 57
    snritems = nitemset;
    }
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
            s->number);
#line 60
    __o = oout;
#line 60
    tmp = strlen((char const   *)(buf___0));
#line 60
    __len = (int )tmp;
    }
#line 60
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 60
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 60
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 60
    __o->next_free += __len;
    }
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  i = (size_t )0;
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (i < snritems)) {
#line 61
      goto while_break___0;
    }
#line 67
    sp = ritem + *(sitems + i);
#line 67
    sp1 = sp;
    {
#line 69
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 69
      if (! (*sp >= 0)) {
#line 69
        goto while_break___1;
      }
#line 70
      sp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 72
    r = item_number_as_rule_number(*sp);
    }
    {
#line 74
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 74
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"\n%s -> ",
              ((rules + r)->lhs)->tag);
#line 74
      __o___0 = oout;
#line 74
      tmp___0 = strlen((char const   *)(buf___1));
#line 74
      __len___0 = (int )tmp___0;
      }
#line 74
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 74
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 74
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 74
      __o___0->next_free += __len___0;
      }
#line 74
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 76
    sp = (rules + r)->rhs;
    {
#line 76
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 76
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 76
        goto while_break___3;
      }
      {
#line 77
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 77
        sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s ",
                (*(symbols + *sp))->tag);
#line 77
        __o___1 = oout;
#line 77
        tmp___1 = strlen((char const   *)(buf___2));
#line 77
        __len___1 = (int )tmp___1;
        }
#line 77
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 77
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 77
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___2),
               (size_t )__len___1);
#line 77
        __o___1->next_free += __len___1;
        }
#line 77
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 76
      sp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 79
    __o___2 = oout;
#line 79
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 79
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 79
    tmp___2 = __o___2->next_free;
#line 79
    (__o___2->next_free) ++;
#line 79
    *tmp___2 = (char )'.';
    {
#line 81
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 81
      if (! (*sp >= 0)) {
#line 81
        goto while_break___5;
      }
      {
#line 82
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 82
        sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)" %s",
                (*(symbols + *sp))->tag);
#line 82
        __o___3 = oout;
#line 82
        tmp___3 = strlen((char const   *)(buf___3));
#line 82
        __len___2 = (int )tmp___3;
        }
#line 82
        if ((unsigned long )(__o___3->next_free + __len___2) > (unsigned long )__o___3->chunk_limit) {
          {
#line 82
          _obstack_newchunk(__o___3, __len___2);
          }
        }
        {
#line 82
        memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___3),
               (size_t )__len___2);
#line 82
        __o___3->next_free += __len___2;
        }
#line 82
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 81
      sp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 85
    if (report_flag & 4) {
      {
#line 85
      tmp___8 = item_number_is_rule_number(*sp1);
      }
#line 85
      if (tmp___8) {
        {
#line 89
        reds = s->reductions;
#line 90
        tmp___4 = state_reduction_find(s, rules + r);
#line 90
        redno = tmp___4;
        }
#line 93
        if (reds->lookahead_tokens) {
#line 93
          if (redno != -1) {
            {
#line 97
            sep = "";
#line 98
            __o___4 = oout;
#line 98
            tmp___5 = strlen("[");
#line 98
            __len___3 = (int )tmp___5;
            }
#line 98
            if ((unsigned long )(__o___4->next_free + __len___3) > (unsigned long )__o___4->chunk_limit) {
              {
#line 98
              _obstack_newchunk(__o___4, __len___3);
              }
            }
            {
#line 98
            memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)"[",
                   (size_t )__len___3);
#line 98
            __o___4->next_free += __len___3;
#line 99
            biter.next = (bitset_bindex )0;
#line 99
            biter.num = (bitset_bindex )1024;
            }
            {
#line 99
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 99
              if (biter.num == 1024U) {
                {
#line 99
                biter.num = (*(((*(reds->lookahead_tokens + redno))->b.vtable)->list))(*(reds->lookahead_tokens + redno),
                                                                                       biter.list,
                                                                                       (bitset_bindex )1024,
                                                                                       & biter.next);
                }
#line 99
                if (! biter.num) {
#line 99
                  goto while_break___7;
                }
              } else {
#line 99
                goto while_break___7;
              }
#line 99
              biter.i = (bitset_bindex )0;
              {
#line 99
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 99
                if (biter.i < biter.num) {
#line 99
                  k = (int )biter.list[biter.i];
                } else {
#line 99
                  goto while_break___8;
                }
                {
#line 101
                while (1) {
                  while_continue___9: /* CIL Label */ ;
                  {
#line 101
                  sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s%s",
                          sep, (*(symbols + k))->tag);
#line 101
                  __o___5 = oout;
#line 101
                  tmp___6 = strlen((char const   *)(buf___4));
#line 101
                  __len___4 = (int )tmp___6;
                  }
#line 101
                  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
                    {
#line 101
                    _obstack_newchunk(__o___5, __len___4);
                    }
                  }
                  {
#line 101
                  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___4),
                         (size_t )__len___4);
#line 101
                  __o___5->next_free += __len___4;
                  }
#line 101
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
#line 102
                sep = ", ";
#line 99
                (biter.i) ++;
              }
              while_break___8: /* CIL Label */ ;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 104
            __o___6 = oout;
#line 104
            tmp___7 = strlen("]");
#line 104
            __len___5 = (int )tmp___7;
            }
#line 104
            if ((unsigned long )(__o___6->next_free + __len___5) > (unsigned long )__o___6->chunk_limit) {
              {
#line 104
              _obstack_newchunk(__o___6, __len___5);
              }
            }
            {
#line 104
            memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)"]",
                   (size_t )__len___5);
#line 104
            __o___6->next_free += __len___5;
            }
          }
        }
      }
    }
#line 61
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 116 "/home/pronto/abs/test-suite/bison-2.4/src/print_graph.c"
static void print_actions___0(state const   *s , FILE *fgraph ) 
{ 
  int i ;
  transitions const   *trans ;
  state *s1 ;
  symbol_number sym ;
  char const   *style ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  uniqstr tmp___2 ;

  {
#line 121
  trans = (transitions const   *)s->transitions;
#line 123
  if (! trans->num) {
#line 123
    if (! s->reductions) {
#line 124
      return;
    }
  }
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < (int )trans->num)) {
#line 126
      goto while_break;
    }
#line 127
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 129
      s1 = trans->states[i];
#line 130
      sym = s1->accessing_symbol;
#line 133
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
#line 133
        tmp___0 = "dotted";
      } else {
#line 133
        if ((trans->states[i])->accessing_symbol < ntokens) {
#line 133
          tmp = "solid";
        } else {
#line 133
          tmp = "dashed";
        }
#line 133
        tmp___0 = tmp;
      }
#line 133
      style = tmp___0;
#line 138
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
        {
#line 138
        tmp___1 = strcmp((*(symbols + sym))->tag, "error");
        }
#line 138
        if (tmp___1 != 0) {
          {
#line 140
          abort();
          }
        }
      }
#line 141
      if ((trans->states[i])->accessing_symbol == errtoken->number) {
#line 141
        tmp___2 = (uniqstr )((void *)0);
      } else {
#line 141
        tmp___2 = (*(symbols + sym))->tag;
      }
      {
#line 141
      output_edge((int )s->number, s1->number, tmp___2, style, fgraph);
      }
    }
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 153 "/home/pronto/abs/test-suite/bison-2.4/src/print_graph.c"
static void print_state___0(state *s , FILE *fgraph ) 
{ 
  struct obstack node_obstack ;
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___2 ;

  {
  {
#line 159
  _obstack_begin(& node_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 160
  print_core___0(& node_obstack, s);
#line 161
  __o = & node_obstack;
  }
#line 161
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 161
    _obstack_newchunk(__o, 1);
    }
  }
#line 161
  tmp = __o->next_free;
#line 161
  (__o->next_free) ++;
#line 161
  *tmp = (char )'\000';
#line 162
  __o1 = & node_obstack;
#line 162
  __value = (void *)__o1->object_base;
#line 162
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 162
    __o1->maybe_empty_object = 1U;
  }
#line 162
  if (sizeof(int ) < sizeof(void *)) {
#line 162
    tmp___0 = __o1->object_base;
  } else {
#line 162
    tmp___0 = (char *)0;
  }
#line 162
  if (sizeof(int ) < sizeof(void *)) {
#line 162
    tmp___1 = __o1->object_base;
  } else {
#line 162
    tmp___1 = (char *)0;
  }
#line 162
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 162
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 162
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 162
  __o1->object_base = __o1->next_free;
#line 162
  output_node(s->number, (char const   *)__value, fgraph);
#line 163
  __o___0 = & node_obstack;
#line 163
  __obj = (void *)0;
  }
#line 163
  if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 163
    if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 163
      tmp___2 = (char *)__obj;
#line 163
      __o___0->object_base = tmp___2;
#line 163
      __o___0->next_free = tmp___2;
    } else {
      {
#line 163
      obstack_free(__o___0, __obj);
      }
    }
  } else {
    {
#line 163
    obstack_free(__o___0, __obj);
    }
  }
  {
#line 166
  print_actions___0((state const   *)s, fgraph);
  }
#line 167
  return;
}
}
#line 170 "/home/pronto/abs/test-suite/bison-2.4/src/print_graph.c"
void print_graph(void) 
{ 
  state_number i ;
  FILE *fgraph ;
  FILE *tmp ;

  {
  {
#line 174
  tmp = xfopen((char const   *)spec_graph_file, "w");
#line 174
  fgraph = tmp;
#line 175
  start_graph(fgraph);
#line 178
  new_closure(nritems);
#line 179
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < nstates)) {
#line 179
      goto while_break;
    }
    {
#line 180
    print_state___0(*(states + i), fgraph);
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  free_closure();
#line 183
  finish_graph(fgraph);
#line 184
  xfclose(fgraph);
  }
#line 185
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static symbol_number item_number_as_symbol_number(item_number i ) 
{ 


  {
#line 137
  return (i);
}
}
#line 217
_Bool rule_useless_in_parser_p(rule *r ) ;
#line 222
void rule_lhs_print(rule *r , symbol *previous_lhs , FILE *out ) ;
#line 259
void grammar_rules_print(FILE *out ) ;
#line 239 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern void state_rule_lookahead_tokens_print(state *s , rule *r , FILE *out ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.h"
void conflicts_output(FILE *out ) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *spec_verbose_file ;
#line 22 "/home/pronto/abs/test-suite/bison-2.4/src/print.h"
void print_results(void) ;
#line 41 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static bitset no_reduce_set___0  ;
#line 57 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void max_length(size_t *width , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 60
  tmp = strlen(str);
#line 60
  len = tmp;
  }
#line 61
  if (len > *width) {
#line 62
    *width = len;
  }
#line 63
  return;
}
}
#line 69 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_core___1(FILE *out , state *s ) 
{ 
  size_t i ;
  item_number *sitems ;
  size_t snritems ;
  symbol *previous_lhs ;
  item_number *sp ;
  item_number *sp1 ;
  rule_number r ;
  _Bool tmp ;

  {
#line 73
  sitems = s->items;
#line 74
  snritems = s->nitems;
#line 75
  previous_lhs = (symbol *)((void *)0);
#line 78
  if (report_flag & 2) {
    {
#line 80
    closure(sitems, snritems);
#line 81
    sitems = itemset;
#line 82
    snritems = nitemset;
    }
  }
#line 85
  if (! snritems) {
#line 86
    return;
  }
  {
#line 88
  fputc_unlocked('\n', out);
#line 90
  i = (size_t )0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < snritems)) {
#line 90
      goto while_break;
    }
#line 96
    sp = ritem + *(sitems + i);
#line 96
    sp1 = sp;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (*sp >= 0)) {
#line 98
        goto while_break___0;
      }
#line 99
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 101
    r = item_number_as_rule_number(*sp);
#line 103
    rule_lhs_print(rules + r, previous_lhs, out);
#line 104
    previous_lhs = (rules + r)->lhs;
#line 106
    sp = (rules + r)->rhs;
    }
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 106
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 106
        goto while_break___1;
      }
      {
#line 107
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" %s",
              (*(symbols + *sp))->tag);
#line 106
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 108
    fputs_unlocked((char const   */* __restrict  */)" .", (FILE */* __restrict  */)out);
    }
    {
#line 109
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 109
      if (! (*sp >= 0)) {
#line 109
        goto while_break___2;
      }
      {
#line 110
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" %s",
              (*(symbols + *sp))->tag);
#line 109
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 113
    if (report_flag & 4) {
      {
#line 113
      tmp = item_number_is_rule_number(*sp1);
      }
#line 113
      if (tmp) {
        {
#line 115
        state_rule_lookahead_tokens_print(s, rules + r, out);
        }
      }
    }
    {
#line 117
    fputc_unlocked('\n', out);
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 127 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_transitions___0(state *s , FILE *out , _Bool display_transitions_p ) 
{ 
  transitions *trans ;
  size_t width ;
  int i ;
  symbol *sym ;
  symbol *sym___0 ;
  char const   *tag ;
  state *s1 ;
  int j ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 130
  trans = s->transitions;
#line 131
  width = (size_t )0;
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < trans->num)) {
#line 135
      goto while_break;
    }
#line 136
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 136
      if (((trans->states[i])->accessing_symbol < ntokens) == (int )display_transitions_p) {
        {
#line 139
        sym = *(symbols + (trans->states[i])->accessing_symbol);
#line 140
        max_length(& width, sym->tag);
        }
      }
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (! width) {
#line 145
    return;
  }
  {
#line 147
  fputc_unlocked('\n', out);
#line 148
  width += 2U;
#line 151
  i = 0;
  }
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i < trans->num)) {
#line 151
      goto while_break___0;
    }
#line 152
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 152
      if (((trans->states[i])->accessing_symbol < ntokens) == (int )display_transitions_p) {
        {
#line 155
        sym___0 = *(symbols + (trans->states[i])->accessing_symbol);
#line 156
        tag = sym___0->tag;
#line 157
        s1 = trans->states[i];
#line 160
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"    %s",
                tag);
#line 161
        tmp = strlen(tag);
#line 161
        j = (int )(width - tmp);
        }
        {
#line 161
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 161
          if (! (j > 0)) {
#line 161
            goto while_break___1;
          }
          {
#line 162
          fputc_unlocked(' ', out);
#line 161
          j --;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 163
        if (display_transitions_p) {
          {
#line 164
          tmp___0 = gettext("shift, and go to state %d\n");
#line 164
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
                  s1->number);
          }
        } else {
          {
#line 166
          tmp___1 = gettext("go to state %d\n");
#line 166
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
                  s1->number);
          }
        }
      }
    }
#line 151
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 175 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_errs___0(FILE *out , state *s ) 
{ 
  errs *errp ;
  size_t width ;
  int i ;
  char const   *tag ;
  int j ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 178
  errp = s->errs;
#line 179
  width = (size_t )0;
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < errp->num)) {
#line 183
      goto while_break;
    }
#line 184
    if (errp->symbols[i]) {
      {
#line 185
      max_length(& width, (errp->symbols[i])->tag);
      }
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! width) {
#line 189
    return;
  }
  {
#line 191
  fputc_unlocked('\n', out);
#line 192
  width += 2U;
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < errp->num)) {
#line 195
      goto while_break___0;
    }
#line 196
    if (errp->symbols[i]) {
      {
#line 198
      tag = (errp->symbols[i])->tag;
#line 200
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"    %s",
              tag);
#line 201
      tmp = strlen(tag);
#line 201
      j = (int )(width - tmp);
      }
      {
#line 201
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 201
        if (! (j > 0)) {
#line 201
          goto while_break___1;
        }
        {
#line 202
        fputc_unlocked(' ', out);
#line 201
        j --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 203
      tmp___0 = gettext("error (nonassociative)\n");
#line 203
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)out);
      }
    }
#line 195
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 214 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_reduction___0(FILE *out , size_t width , char const   *lookahead_token ,
                                rule *r , _Bool enabled ) 
{ 
  int j ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 220
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"    %s",
          lookahead_token);
#line 221
  tmp = strlen(lookahead_token);
#line 221
  j = (int )(width - tmp);
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (j > 0)) {
#line 221
      goto while_break;
    }
    {
#line 222
    fputc_unlocked(' ', out);
#line 221
    j --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (! enabled) {
    {
#line 224
    fputc_unlocked('[', out);
    }
  }
#line 225
  if (r->number) {
    {
#line 226
    tmp___0 = gettext("reduce using rule %d (%s)");
#line 226
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
            r->number, (r->lhs)->tag);
    }
  } else {
    {
#line 228
    tmp___1 = gettext("accept");
#line 228
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1);
    }
  }
#line 229
  if (! enabled) {
    {
#line 230
    fputc_unlocked(']', out);
    }
  }
  {
#line 231
  fputc_unlocked('\n', out);
  }
#line 232
  return;
}
}
#line 239 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_reductions___0(FILE *out , state *s ) 
{ 
  transitions *trans ;
  reductions *reds ;
  rule *default_rule ;
  size_t width ;
  int i ;
  int j ;
  char *tmp ;
  _Bool count ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool defaulted ;
  _Bool count___0 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;

  {
#line 242
  trans = s->transitions;
#line 243
  reds = s->reductions;
#line 244
  default_rule = (rule *)((void *)0);
#line 245
  width = (size_t )0;
#line 248
  if (reds->num == 0) {
#line 249
    return;
  }
#line 251
  if (*(yydefact + s->number) != 0) {
#line 252
    default_rule = rules + (*(yydefact + s->number) - 1);
  }
  {
#line 254
  (*((no_reduce_set___0->b.vtable)->zero))(no_reduce_set___0);
#line 255
  i = 0;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (i < trans->num) {
#line 255
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 255
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 255
          goto while_break;
        }
      }
    } else {
#line 255
      goto while_break;
    }
#line 255
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 256
      bitset_set(no_reduce_set___0, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  i = 0;
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 257
    if (! (i < (s->errs)->num)) {
#line 257
      goto while_break___0;
    }
#line 258
    if ((s->errs)->symbols[i]) {
      {
#line 259
      bitset_set(no_reduce_set___0, (bitset_bindex )((s->errs)->symbols[i])->number);
      }
    }
#line 257
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 262
  if (default_rule) {
    {
#line 263
    tmp = gettext("$default");
#line 263
    width = strlen((char const   *)tmp);
    }
  }
#line 265
  if (reds->lookahead_tokens) {
#line 266
    i = 0;
    {
#line 266
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 266
      if (! (i < ntokens)) {
#line 266
        goto while_break___1;
      }
      {
#line 268
      tmp___0 = bitset_test(no_reduce_set___0, (bitset_bindex )i);
#line 268
      count = tmp___0;
#line 270
      j = 0;
      }
      {
#line 270
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 270
        if (! (j < reds->num)) {
#line 270
          goto while_break___2;
        }
        {
#line 271
        tmp___1 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 271
        if (tmp___1) {
#line 273
          if (! count) {
#line 275
            if ((unsigned long )reds->rules[j] != (unsigned long )default_rule) {
              {
#line 276
              max_length(& width, (*(symbols + i))->tag);
              }
            }
#line 277
            count = (_Bool)1;
          } else {
            {
#line 281
            max_length(& width, (*(symbols + i))->tag);
            }
          }
        }
#line 270
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 266
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 287
  if (! width) {
#line 288
    return;
  }
  {
#line 290
  fputc_unlocked('\n', out);
#line 291
  width += 2U;
  }
#line 294
  if (reds->lookahead_tokens) {
#line 295
    i = 0;
    {
#line 295
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 295
      if (! (i < ntokens)) {
#line 295
        goto while_break___3;
      }
      {
#line 297
      defaulted = (_Bool)0;
#line 298
      tmp___2 = bitset_test(no_reduce_set___0, (bitset_bindex )i);
#line 298
      count___0 = tmp___2;
#line 300
      j = 0;
      }
      {
#line 300
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 300
        if (! (j < reds->num)) {
#line 300
          goto while_break___4;
        }
        {
#line 301
        tmp___3 = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
        }
#line 301
        if (tmp___3) {
#line 303
          if (! count___0) {
#line 305
            if ((unsigned long )reds->rules[j] != (unsigned long )default_rule) {
              {
#line 306
              print_reduction___0(out, width, (*(symbols + i))->tag, reds->rules[j],
                                  (_Bool)1);
              }
            } else {
#line 310
              defaulted = (_Bool)1;
            }
#line 311
            count___0 = (_Bool)1;
          } else {
#line 315
            if (defaulted) {
              {
#line 316
              print_reduction___0(out, width, (*(symbols + i))->tag, default_rule,
                                  (_Bool)1);
              }
            }
            {
#line 319
            defaulted = (_Bool)0;
#line 320
            print_reduction___0(out, width, (*(symbols + i))->tag, reds->rules[j],
                                (_Bool)0);
            }
          }
        }
#line 300
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 295
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 327
  if (default_rule) {
    {
#line 328
    tmp___4 = gettext("$default");
#line 328
    print_reduction___0(out, width, (char const   *)tmp___4, default_rule, (_Bool)1);
    }
  }
#line 330
  return;
}
}
#line 338 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_actions___1(FILE *out , state *s ) 
{ 


  {
  {
#line 342
  print_transitions___0(s, out, (_Bool)1);
#line 343
  print_errs___0(out, s);
#line 344
  print_reductions___0(out, s);
#line 346
  print_transitions___0(s, out, (_Bool)0);
  }
#line 347
  return;
}
}
#line 354 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_state___1(FILE *out , state *s ) 
{ 
  char *tmp ;

  {
  {
#line 357
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
#line 358
  tmp = gettext("state %d");
#line 358
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp, s->number);
#line 359
  fputc_unlocked('\n', out);
#line 360
  print_core___1(out, s);
#line 361
  print_actions___1(out, s);
  }
#line 362
  if (report_flag & 8) {
#line 362
    if (s->solved_conflicts) {
      {
#line 364
      fputc_unlocked('\n', out);
#line 365
      fputs_unlocked((char const   */* __restrict  */)s->solved_conflicts, (FILE */* __restrict  */)out);
      }
    }
  }
#line 367
  return;
}
}
#line 384 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
static void print_grammar___0(FILE *out ) 
{ 
  symbol_number i ;
  char buffer[90] ;
  int column ;
  char *tmp ;
  char const   *tag ;
  rule_number r ;
  item_number *rhsp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  symbol_number tmp___4 ;
  char *tmp___5 ;
  int left_count ;
  int right_count ;
  rule_number r___0 ;
  char const   *tag___0 ;
  item_number *rhsp___0 ;
  symbol_number tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  item_number *rhsp___1 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  symbol_number tmp___20 ;

  {
  {
#line 389
  column = 0;
#line 391
  grammar_rules_print(out);
#line 394
  tmp = gettext("Terminals, with rules where they appear");
#line 394
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
          tmp);
#line 395
  i = 0;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (i < max_user_token_number + 1)) {
#line 395
      goto while_break;
    }
#line 396
    if (*(token_translations + i) != undeftoken->number) {
      {
#line 398
      tag = (*(symbols + *(token_translations + i)))->tag;
#line 402
      buffer[0] = (char)0;
#line 403
      tmp___0 = strlen(tag);
#line 403
      column = (int )tmp___0;
#line 404
      fputs_unlocked((char const   */* __restrict  */)tag, (FILE */* __restrict  */)out);
      }
      {
#line 405
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 405
        tmp___1 = strlen((char const   *)(buffer));
        }
#line 405
        if ((size_t )column + tmp___1 > 65U) {
          {
#line 405
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                  buffer);
#line 405
          column = 3;
#line 405
          buffer[0] = (char)0;
          }
        }
#line 405
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 406
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" (%d)",
              i);
#line 408
      r = 0;
      }
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 408
        if (! (r < nrules)) {
#line 408
          goto while_break___1;
        }
#line 409
        rhsp = (rules + r)->rhs;
        {
#line 409
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 409
          if (! (*rhsp >= 0)) {
#line 409
            goto while_break___2;
          }
          {
#line 410
          tmp___4 = item_number_as_symbol_number(*rhsp);
          }
#line 410
          if (tmp___4 == *(token_translations + i)) {
            {
#line 412
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 412
              tmp___2 = strlen((char const   *)(buffer));
              }
#line 412
              if ((size_t )column + tmp___2 > 65U) {
                {
#line 412
                fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                        buffer);
#line 412
                column = 3;
#line 412
                buffer[0] = (char)0;
                }
              }
#line 412
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 413
            tmp___3 = strlen((char const   *)(buffer));
#line 413
            sprintf((char */* __restrict  */)(buffer + tmp___3), (char const   */* __restrict  */)" %d",
                    r);
            }
#line 414
            goto while_break___2;
          }
#line 409
          rhsp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 408
        r ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 416
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n",
              buffer);
      }
    }
#line 395
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
#line 421
  tmp___5 = gettext("Nonterminals, with rules where they appear");
#line 421
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
          tmp___5);
#line 422
  i = ntokens;
  }
  {
#line 422
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 422
    if (! (i < nsyms)) {
#line 422
      goto while_break___4;
    }
#line 424
    left_count = 0;
#line 424
    right_count = 0;
#line 426
    tag___0 = (*(symbols + i))->tag;
#line 428
    r___0 = 0;
    {
#line 428
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 428
      if (! (r___0 < nrules)) {
#line 428
        goto while_break___5;
      }
#line 431
      if (((rules + r___0)->lhs)->number == i) {
#line 432
        left_count ++;
      }
#line 433
      rhsp___0 = (rules + r___0)->rhs;
      {
#line 433
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 433
        if (! (*rhsp___0 >= 0)) {
#line 433
          goto while_break___6;
        }
        {
#line 434
        tmp___6 = item_number_as_symbol_number(*rhsp___0);
        }
#line 434
        if (tmp___6 == i) {
#line 436
          right_count ++;
#line 437
          goto while_break___6;
        }
#line 433
        rhsp___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 428
      r___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 441
    buffer[0] = (char)0;
#line 442
    fputs_unlocked((char const   */* __restrict  */)tag___0, (FILE */* __restrict  */)out);
#line 443
    tmp___7 = strlen(tag___0);
#line 443
    column = (int )tmp___7;
#line 444
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" (%d)",
            i);
    }
    {
#line 445
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 445
      tmp___8 = strlen((char const   *)(buffer));
      }
#line 445
      if ((size_t )column + tmp___8 > 0U) {
        {
#line 445
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                buffer);
#line 445
        column = 3;
#line 445
        buffer[0] = (char)0;
        }
      }
#line 445
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 447
    if (left_count > 0) {
      {
#line 449
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 449
        tmp___9 = strlen((char const   *)(buffer));
        }
#line 449
        if ((size_t )column + tmp___9 > 65U) {
          {
#line 449
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                  buffer);
#line 449
          column = 3;
#line 449
          buffer[0] = (char)0;
          }
        }
#line 449
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 450
      tmp___10 = gettext(" on left:");
#line 450
      tmp___11 = strlen((char const   *)(buffer));
#line 450
      sprintf((char */* __restrict  */)(buffer + tmp___11), (char const   */* __restrict  */)tmp___10);
#line 452
      r___0 = 0;
      }
      {
#line 452
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 452
        if (! (r___0 < nrules)) {
#line 452
          goto while_break___9;
        }
#line 454
        if (((rules + r___0)->lhs)->number == i) {
          {
#line 456
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 456
            tmp___12 = strlen((char const   *)(buffer));
            }
#line 456
            if ((size_t )column + tmp___12 > 65U) {
              {
#line 456
              fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                      buffer);
#line 456
              column = 3;
#line 456
              buffer[0] = (char)0;
              }
            }
#line 456
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 457
          tmp___13 = strlen((char const   *)(buffer));
#line 457
          sprintf((char */* __restrict  */)(buffer + tmp___13), (char const   */* __restrict  */)" %d",
                  r___0);
          }
        }
#line 452
        r___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 462
    if (right_count > 0) {
#line 464
      if (left_count > 0) {
        {
#line 465
        tmp___14 = strlen((char const   *)(buffer));
#line 465
        sprintf((char */* __restrict  */)(buffer + tmp___14), (char const   */* __restrict  */)",");
        }
      }
      {
#line 466
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 466
        tmp___15 = strlen((char const   *)(buffer));
        }
#line 466
        if ((size_t )column + tmp___15 > 65U) {
          {
#line 466
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                  buffer);
#line 466
          column = 3;
#line 466
          buffer[0] = (char)0;
          }
        }
#line 466
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 467
      tmp___16 = gettext(" on right:");
#line 467
      tmp___17 = strlen((char const   *)(buffer));
#line 467
      sprintf((char */* __restrict  */)(buffer + tmp___17), (char const   */* __restrict  */)tmp___16);
#line 468
      r___0 = 0;
      }
      {
#line 468
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 468
        if (! (r___0 < nrules)) {
#line 468
          goto while_break___12;
        }
#line 471
        rhsp___1 = (rules + r___0)->rhs;
        {
#line 471
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 471
          if (! (*rhsp___1 >= 0)) {
#line 471
            goto while_break___13;
          }
          {
#line 472
          tmp___20 = item_number_as_symbol_number(*rhsp___1);
          }
#line 472
          if (tmp___20 == i) {
            {
#line 474
            while (1) {
              while_continue___14: /* CIL Label */ ;
              {
#line 474
              tmp___18 = strlen((char const   *)(buffer));
              }
#line 474
              if ((size_t )column + tmp___18 > 65U) {
                {
#line 474
                fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n   ",
                        buffer);
#line 474
                column = 3;
#line 474
                buffer[0] = (char)0;
                }
              }
#line 474
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
            {
#line 475
            tmp___19 = strlen((char const   *)(buffer));
#line 475
            sprintf((char */* __restrict  */)(buffer + tmp___19), (char const   */* __restrict  */)" %d",
                    r___0);
            }
#line 476
            goto while_break___13;
          }
#line 471
          rhsp___1 ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 468
        r___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    {
#line 480
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n",
            buffer);
#line 422
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 484 "/home/pronto/abs/test-suite/bison-2.4/src/print.c"
void print_results(void) 
{ 
  state_number i ;
  FILE *out ;
  FILE *tmp ;
  char *tmp___0 ;

  {
  {
#line 491
  tmp = xfopen((char const   *)spec_verbose_file, "w");
#line 491
  out = tmp;
#line 493
  reduce_output(out);
#line 494
  tmp___0 = gettext("Rules useless in parser due to conflicts");
#line 494
  grammar_rules_partial_print(out, (char const   *)tmp___0, & rule_useless_in_parser_p);
#line 497
  conflicts_output(out);
#line 499
  print_grammar___0(out);
  }
#line 503
  if (report_flag & 2) {
    {
#line 504
    new_closure(nritems);
    }
  }
  {
#line 506
  no_reduce_set___0 = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 507
  i = 0;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (i < nstates)) {
#line 507
      goto while_break;
    }
    {
#line 508
    print_state___1(out, *(states + i));
#line 507
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  bitset_free(no_reduce_set___0);
  }
#line 510
  if (report_flag & 2) {
    {
#line 511
    free_closure();
    }
  }
  {
#line 513
  xfclose(out);
  }
#line 514
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 87
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 167
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 355
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strverscmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid ) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
__inline static void boundary_set(boundary *b , char const   *f , int l , int c ) 
{ 


  {
#line 45
  b->file = f;
#line 46
  b->line = l;
#line 47
  b->column = c;
#line 48
  return;
}
}
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/location.h"
__inline static _Bool equal_boundaries(boundary a , boundary b ) 
{ 
  int tmp ;

  {
#line 54
  if (a.column == b.column) {
#line 54
    if (a.line == b.line) {
#line 54
      if ((unsigned long )a.file == (unsigned long )b.file) {
#line 54
        tmp = 1;
      } else {
#line 54
        tmp = 0;
      }
    } else {
#line 54
      tmp = 0;
    }
  } else {
#line 54
    tmp = 0;
  }
#line 54
  return ((_Bool )tmp);
}
}
#line 80
void location_print(FILE *out , location loc___0 ) ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.h"
int expected_sr_conflicts ;
#line 44
int expected_rr_conflicts ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char const   *spec_outfile ;
#line 33
char const   *spec_name_prefix ;
#line 36
char const   *spec_file_prefix ;
#line 48
char *spec_defines_file ;
#line 59
uniqstr current_file ;
#line 36 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern _Bool debug_flag ;
#line 37
extern _Bool defines_flag ;
#line 41
extern _Bool no_lines_flag ;
#line 42
extern _Bool token_table_flag ;
#line 45
extern _Bool error_verbose ;
#line 58
extern _Bool nondeterministic_parser ;
#line 135
extern void language_argmatch(char const   *arg , int prio , location const   *loc ) ;
#line 136
extern void skeleton_arg(char const   *arg , int prio , location const   *loc ) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.h"
char const   *muscle_find_const(char const   *key ) ;
#line 101
void muscle_code_grow(char const   *key , char const   *val , location loc___0 ) ;
#line 108
void muscle_pair_list_grow(char const   *muscle , char const   *a1 , char const   *a2 ) ;
#line 129
void muscle_percent_define_insert(char const   *variable , location variable_loc ,
                                  char const   *value ) ;
#line 167
_Bool muscle_percent_define_flag_if(char const   *variable ) ;
#line 191
void muscle_percent_code_grow(char const   *qualifier , location qualifier_loc , char const   *code ,
                              location code_loc ) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/reader.h"
int gram_debug  ;
#line 40
char const   *token_name(int type ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/scan-gram.h"
extern void gram_scanner_last_string_free(void) ;
#line 36
extern int gram_lex(YYSTYPE *val , location *loc ) ;
#line 37 "parse-gram.y"
static location lloc_default(location const   *rhs , int n ) ;
#line 42
static void version_check(location const   *loc___0 , char const   *version ) ;
#line 49
static void gram_error(location const   *loc___0 , char const   *msg ) ;
#line 51
static char const   *char_name(char c ) ;
#line 59
static void add_param(char const   *type , char *decl , location loc___0 ) ;
#line 62 "parse-gram.y"
static symbol_class current_class  =    (symbol_class )0;
#line 63 "parse-gram.y"
static uniqstr current_type  =    (uniqstr )((void *)0);
#line 64 "parse-gram.y"
static symbol *current_lhs  ;
#line 65 "parse-gram.y"
static location current_lhs_location  ;
#line 66 "parse-gram.y"
static int current_prec  =    0;
#line 578 "parse-gram.c"
static yytype_uint8 const   yytranslate[312]  = 
#line 578 "parse-gram.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56};
#line 617 "parse-gram.c"
static yytype_uint16 const   yyprhs[106]  = 
#line 617
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )8, 
        (yytype_uint16 const   )9,      (yytype_uint16 const   )12,      (yytype_uint16 const   )14,      (yytype_uint16 const   )16, 
        (yytype_uint16 const   )18,      (yytype_uint16 const   )22,      (yytype_uint16 const   )24,      (yytype_uint16 const   )27, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )32,      (yytype_uint16 const   )35,      (yytype_uint16 const   )38, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )44,      (yytype_uint16 const   )47,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )53,      (yytype_uint16 const   )55,      (yytype_uint16 const   )58,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )64,      (yytype_uint16 const   )66,      (yytype_uint16 const   )69,      (yytype_uint16 const   )73, 
        (yytype_uint16 const   )76,      (yytype_uint16 const   )78,      (yytype_uint16 const   )81,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )86,      (yytype_uint16 const   )88,      (yytype_uint16 const   )90,      (yytype_uint16 const   )92, 
        (yytype_uint16 const   )94,      (yytype_uint16 const   )96,      (yytype_uint16 const   )99,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )109,      (yytype_uint16 const   )111,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )118,      (yytype_uint16 const   )119,      (yytype_uint16 const   )121,      (yytype_uint16 const   )125, 
        (yytype_uint16 const   )126,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131,      (yytype_uint16 const   )135, 
        (yytype_uint16 const   )139,      (yytype_uint16 const   )143,      (yytype_uint16 const   )145,      (yytype_uint16 const   )147, 
        (yytype_uint16 const   )149,      (yytype_uint16 const   )150,      (yytype_uint16 const   )152,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )157,      (yytype_uint16 const   )159,      (yytype_uint16 const   )162,      (yytype_uint16 const   )164, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )169,      (yytype_uint16 const   )172,      (yytype_uint16 const   )174, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )178,      (yytype_uint16 const   )180,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )184,      (yytype_uint16 const   )187,      (yytype_uint16 const   )190,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )199,      (yytype_uint16 const   )201,      (yytype_uint16 const   )204, 
        (yytype_uint16 const   )206,      (yytype_uint16 const   )209,      (yytype_uint16 const   )212,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )217,      (yytype_uint16 const   )219,      (yytype_uint16 const   )223,      (yytype_uint16 const   )226, 
        (yytype_uint16 const   )227,      (yytype_uint16 const   )230,      (yytype_uint16 const   )233,      (yytype_uint16 const   )237, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )245,      (yytype_uint16 const   )247,      (yytype_uint16 const   )249, 
        (yytype_uint16 const   )250,      (yytype_uint16 const   )252,      (yytype_uint16 const   )254,      (yytype_uint16 const   )256, 
        (yytype_uint16 const   )258,      (yytype_uint16 const   )260,      (yytype_uint16 const   )262,      (yytype_uint16 const   )264, 
        (yytype_uint16 const   )266,      (yytype_uint16 const   )267};
#line 633 "parse-gram.c"
static yytype_int8 const   yyrhs[270]  = 
#line 633
  {      (yytype_int8 const   )58,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )59, 
        (yytype_int8 const   )49,      (yytype_int8 const   )76,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )59,      (yytype_int8 const   )60,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )61,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-1,      (yytype_int8 const   )19,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )21, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )4,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )23,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )46, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )25,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )43,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )43, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )30, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )46, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )32,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )33,      (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )46,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )35,      (yytype_int8 const   )43,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-1,      (yytype_int8 const   )37,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )38,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )40,      (yytype_int8 const   )-1,      (yytype_int8 const   )41,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )52,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )66,      (yytype_int8 const   )-1,      (yytype_int8 const   )63,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )8, 
        (yytype_int8 const   )43,      (yytype_int8 const   )72,      (yytype_int8 const   )-1,      (yytype_int8 const   )9, 
        (yytype_int8 const   )43,      (yytype_int8 const   )72,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )16, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )16,      (yytype_int8 const   )47, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )62,      (yytype_int8 const   )84, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )6,      (yytype_int8 const   )64, 
        (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )5, 
        (yytype_int8 const   )65,      (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )7, 
        (yytype_int8 const   )53,      (yytype_int8 const   )71,      (yytype_int8 const   )-1,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )-1,      (yytype_int8 const   )10, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )11,      (yytype_int8 const   )-1,      (yytype_int8 const   )12, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )53,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )70,      (yytype_int8 const   )-1,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )87, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )71,      (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )73, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )72,      (yytype_int8 const   )73,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )53,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )54,      (yytype_int8 const   )-1,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )53,      (yytype_int8 const   )-1,      (yytype_int8 const   )85,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )85,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )85, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )85,      (yytype_int8 const   )4, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )74,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )75,      (yytype_int8 const   )74,      (yytype_int8 const   )-1,      (yytype_int8 const   )77, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )76,      (yytype_int8 const   )77,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )78,      (yytype_int8 const   )-1,      (yytype_int8 const   )61,      (yytype_int8 const   )52, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )1,      (yytype_int8 const   )52,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )86,      (yytype_int8 const   )79,      (yytype_int8 const   )80, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )-1,      (yytype_int8 const   )80, 
        (yytype_int8 const   )50,      (yytype_int8 const   )81,      (yytype_int8 const   )-1,      (yytype_int8 const   )80, 
        (yytype_int8 const   )52,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )81, 
        (yytype_int8 const   )87,      (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )43, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )13,      (yytype_int8 const   )87, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )14,      (yytype_int8 const   )4, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )15,      (yytype_int8 const   )53, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )-1,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )43,      (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )44,      (yytype_int8 const   )-1,      (yytype_int8 const   )48,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )85,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )49, 
        (yytype_int8 const   )45,      (yytype_int8 const   )-1};
#line 665 "parse-gram.c"
static yytype_uint16 const   yyrline[106]  = 
#line 665
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )202,      (yytype_uint16 const   )202,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )216,      (yytype_uint16 const   )217,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )232,      (yytype_uint16 const   )233,      (yytype_uint16 const   )238, 
        (yytype_uint16 const   )239,      (yytype_uint16 const   )240,      (yytype_uint16 const   )241,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )248,      (yytype_uint16 const   )257,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )265,      (yytype_uint16 const   )266, 
        (yytype_uint16 const   )267,      (yytype_uint16 const   )280,      (yytype_uint16 const   )281,      (yytype_uint16 const   )305, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )307,      (yytype_uint16 const   )308,      (yytype_uint16 const   )312, 
        (yytype_uint16 const   )313,      (yytype_uint16 const   )314,      (yytype_uint16 const   )318,      (yytype_uint16 const   )325, 
        (yytype_uint16 const   )332,      (yytype_uint16 const   )336,      (yytype_uint16 const   )340,      (yytype_uint16 const   )347, 
        (yytype_uint16 const   )362,      (yytype_uint16 const   )363,      (yytype_uint16 const   )367,      (yytype_uint16 const   )379, 
        (yytype_uint16 const   )379,      (yytype_uint16 const   )384,      (yytype_uint16 const   )384,      (yytype_uint16 const   )389, 
        (yytype_uint16 const   )400,      (yytype_uint16 const   )415,      (yytype_uint16 const   )416,      (yytype_uint16 const   )417, 
        (yytype_uint16 const   )421,      (yytype_uint16 const   )422,      (yytype_uint16 const   )427,      (yytype_uint16 const   )429, 
        (yytype_uint16 const   )434,      (yytype_uint16 const   )435,      (yytype_uint16 const   )440,      (yytype_uint16 const   )442, 
        (yytype_uint16 const   )447,      (yytype_uint16 const   )448,      (yytype_uint16 const   )452,      (yytype_uint16 const   )453, 
        (yytype_uint16 const   )454,      (yytype_uint16 const   )455,      (yytype_uint16 const   )460,      (yytype_uint16 const   )465, 
        (yytype_uint16 const   )470,      (yytype_uint16 const   )476,      (yytype_uint16 const   )482,      (yytype_uint16 const   )493, 
        (yytype_uint16 const   )494,      (yytype_uint16 const   )503,      (yytype_uint16 const   )504,      (yytype_uint16 const   )510, 
        (yytype_uint16 const   )511,      (yytype_uint16 const   )512,      (yytype_uint16 const   )519,      (yytype_uint16 const   )519, 
        (yytype_uint16 const   )523,      (yytype_uint16 const   )524,      (yytype_uint16 const   )525,      (yytype_uint16 const   )530, 
        (yytype_uint16 const   )531,      (yytype_uint16 const   )533,      (yytype_uint16 const   )535,      (yytype_uint16 const   )537, 
        (yytype_uint16 const   )539,      (yytype_uint16 const   )549,      (yytype_uint16 const   )550,      (yytype_uint16 const   )556, 
        (yytype_uint16 const   )559,      (yytype_uint16 const   )568,      (yytype_uint16 const   )588,      (yytype_uint16 const   )590, 
        (yytype_uint16 const   )599,      (yytype_uint16 const   )604,      (yytype_uint16 const   )605,      (yytype_uint16 const   )610, 
        (yytype_uint16 const   )617,      (yytype_uint16 const   )619};
#line 684 "parse-gram.c"
static char const   * const  yytname[91]  = 
#line 684
  {      (char const   */* const  */)"\"end of file\"",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"\"string\"", 
        (char const   */* const  */)"\"integer\"",      (char const   */* const  */)"\"%token\"",      (char const   */* const  */)"\"%nterm\"",      (char const   */* const  */)"\"%type\"", 
        (char const   */* const  */)"\"%destructor\"",      (char const   */* const  */)"\"%printer\"",      (char const   */* const  */)"\"%left\"",      (char const   */* const  */)"\"%right\"", 
        (char const   */* const  */)"\"%nonassoc\"",      (char const   */* const  */)"\"%prec\"",      (char const   */* const  */)"\"%dprec\"",      (char const   */* const  */)"\"%merge\"", 
        (char const   */* const  */)"\"%code\"",      (char const   */* const  */)"\"%debug\"",      (char const   */* const  */)"\"%default-prec\"",      (char const   */* const  */)"\"%define\"", 
        (char const   */* const  */)"\"%defines\"",      (char const   */* const  */)"\"%error-verbose\"",      (char const   */* const  */)"\"%expect\"",      (char const   */* const  */)"\"%expect-rr\"", 
        (char const   */* const  */)"\"%file-prefix\"",      (char const   */* const  */)"\"%glr-parser\"",      (char const   */* const  */)"\"%initial-action\"",      (char const   */* const  */)"\"%language\"", 
        (char const   */* const  */)"\"%lex-param\"",      (char const   */* const  */)"\"%locations\"",      (char const   */* const  */)"\"%name-prefix\"",      (char const   */* const  */)"\"%no-default-prec\"", 
        (char const   */* const  */)"\"%no-lines\"",      (char const   */* const  */)"\"%nondeterministic-parser\"",      (char const   */* const  */)"\"%output\"",      (char const   */* const  */)"\"%parse-param\"", 
        (char const   */* const  */)"\"%pure-parser\"",      (char const   */* const  */)"\"%require\"",      (char const   */* const  */)"\"%skeleton\"",      (char const   */* const  */)"\"%start\"", 
        (char const   */* const  */)"\"%token-table\"",      (char const   */* const  */)"\"%verbose\"",      (char const   */* const  */)"\"%yacc\"",      (char const   */* const  */)"\"{...}\"", 
        (char const   */* const  */)"\"char\"",      (char const   */* const  */)"\"epilogue\"",      (char const   */* const  */)"\"=\"",      (char const   */* const  */)"\"identifier\"", 
        (char const   */* const  */)"\"identifier:\"",      (char const   */* const  */)"\"%%\"",      (char const   */* const  */)"\"|\"",      (char const   */* const  */)"\"%{...%}\"", 
        (char const   */* const  */)"\";\"",      (char const   */* const  */)"\"type\"",      (char const   */* const  */)"\"<*>\"",      (char const   */* const  */)"\"<>\"", 
        (char const   */* const  */)"\"%union\"",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"prologue_declarations", 
        (char const   */* const  */)"prologue_declaration",      (char const   */* const  */)"grammar_declaration",      (char const   */* const  */)"union_name",      (char const   */* const  */)"symbol_declaration", 
        (char const   */* const  */)"$@1",      (char const   */* const  */)"$@2",      (char const   */* const  */)"precedence_declaration",      (char const   */* const  */)"precedence_declarator", 
        (char const   */* const  */)"type.opt",      (char const   */* const  */)"symbols.prec",      (char const   */* const  */)"symbol.prec",      (char const   */* const  */)"symbols.1", 
        (char const   */* const  */)"generic_symlist",      (char const   */* const  */)"generic_symlist_item",      (char const   */* const  */)"symbol_def",      (char const   */* const  */)"symbol_defs.1", 
        (char const   */* const  */)"grammar",      (char const   */* const  */)"rules_or_grammar_declaration",      (char const   */* const  */)"rules",      (char const   */* const  */)"$@3", 
        (char const   */* const  */)"rhses.1",      (char const   */* const  */)"rhs",      (char const   */* const  */)"variable",      (char const   */* const  */)"content.opt", 
        (char const   */* const  */)"braceless",      (char const   */* const  */)"id",      (char const   */* const  */)"id_colon",      (char const   */* const  */)"symbol", 
        (char const   */* const  */)"string_as_id",      (char const   */* const  */)"epilogue.opt",      (char const   */* const  */)0};
#line 726 "parse-gram.c"
static yytype_uint8 const   yyr1[106]  = 
#line 726
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )61,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )65,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )79,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )89};
#line 742 "parse-gram.c"
static yytype_uint8 const   yyr2[106]  = 
#line 742
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
#line 760 "parse-gram.c"
static yytype_uint8 const   yydefact___0[143]  = 
#line 760
  {      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )34,      (yytype_uint8 const   )44,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )36,      (yytype_uint8 const   )35,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )93,      (yytype_uint8 const   )95,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )103,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )101,      (yytype_uint8 const   )37,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )79,      (yytype_uint8 const   )82,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )50,      (yytype_uint8 const   )71,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )62,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )38,      (yytype_uint8 const   )64,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )43,      (yytype_uint8 const   )96,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )22,      (yytype_uint8 const   )26,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )46,      (yytype_uint8 const   )52,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )76,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )65,      (yytype_uint8 const   )105,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )59,      (yytype_uint8 const   )61,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )86,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )89,      (yytype_uint8 const   )88,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92};
#line 780 "parse-gram.c"
static yytype_int16 const   yydefgoto___0[33]  = 
#line 780
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )2,      (yytype_int16 const   )43, 
        (yytype_int16 const   )82,      (yytype_int16 const   )88,      (yytype_int16 const   )45,      (yytype_int16 const   )49, 
        (yytype_int16 const   )48,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )90, 
        (yytype_int16 const   )118,      (yytype_int16 const   )119,      (yytype_int16 const   )96,      (yytype_int16 const   )101, 
        (yytype_int16 const   )102,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )83, 
        (yytype_int16 const   )84,      (yytype_int16 const   )85,      (yytype_int16 const   )116,      (yytype_int16 const   )127, 
        (yytype_int16 const   )128,      (yytype_int16 const   )58,      (yytype_int16 const   )107,      (yytype_int16 const   )55, 
        (yytype_int16 const   )77,      (yytype_int16 const   )86,      (yytype_int16 const   )103,      (yytype_int16 const   )79, 
        (yytype_int16 const   )115};
#line 791 "parse-gram.c"
static yytype_int16 const   yypact[143]  = 
#line 791
  {      (yytype_int16 const   )-60,      (yytype_int16 const   )18,      (yytype_int16 const   )100,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-16,      (yytype_int16 const   )24, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-8,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )11, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-60,      (yytype_int16 const   )71,      (yytype_int16 const   )80, 
        (yytype_int16 const   )2,      (yytype_int16 const   )-60,      (yytype_int16 const   )46,      (yytype_int16 const   )87, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-60,      (yytype_int16 const   )31,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )40,      (yytype_int16 const   )49, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )15, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )50,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )43, 
        (yytype_int16 const   )12,      (yytype_int16 const   )12,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )25,      (yytype_int16 const   )-60,      (yytype_int16 const   )55,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )97,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )98, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-60,      (yytype_int16 const   )110,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )51,      (yytype_int16 const   )-60,      (yytype_int16 const   )62,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )55,      (yytype_int16 const   )-60,      (yytype_int16 const   )0,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )12,      (yytype_int16 const   )84,      (yytype_int16 const   )12, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )25,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )25,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )101,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )0,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )111,      (yytype_int16 const   )-60,      (yytype_int16 const   )140,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )10, 
        (yytype_int16 const   )38,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )0,      (yytype_int16 const   )141, 
        (yytype_int16 const   )94,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )38, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60};
#line 811 "parse-gram.c"
static yytype_int16 const   yypgoto[33]  = 
#line 811
  {      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )142,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )-60,      (yytype_int16 const   )30,      (yytype_int16 const   )-60,      (yytype_int16 const   )102, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-27,      (yytype_int16 const   )104,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60, 
        (yytype_int16 const   )23,      (yytype_int16 const   )-60,      (yytype_int16 const   )-60,      (yytype_int16 const   )-50, 
        (yytype_int16 const   )-19,      (yytype_int16 const   )-60,      (yytype_int16 const   )-35,      (yytype_int16 const   )-58, 
        (yytype_int16 const   )-60};
#line 824 "parse-gram.c"
static yytype_int16 const   yytable[157]  = 
#line 824
  {      (yytype_int16 const   )78,      (yytype_int16 const   )-104,      (yytype_int16 const   )80,      (yytype_int16 const   )74, 
        (yytype_int16 const   )105,      (yytype_int16 const   )62,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )56,      (yytype_int16 const   )97, 
        (yytype_int16 const   )80,      (yytype_int16 const   )12,      (yytype_int16 const   )3,      (yytype_int16 const   )14, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )74,      (yytype_int16 const   )94,      (yytype_int16 const   )94,      (yytype_int16 const   )12, 
        (yytype_int16 const   )27,      (yytype_int16 const   )14,      (yytype_int16 const   )67,      (yytype_int16 const   )53, 
        (yytype_int16 const   )123,      (yytype_int16 const   )50,      (yytype_int16 const   )117,      (yytype_int16 const   )54, 
        (yytype_int16 const   )35,      (yytype_int16 const   )74,      (yytype_int16 const   )125,      (yytype_int16 const   )69, 
        (yytype_int16 const   )75,      (yytype_int16 const   )125,      (yytype_int16 const   )27,      (yytype_int16 const   )76, 
        (yytype_int16 const   )63,      (yytype_int16 const   )81,      (yytype_int16 const   )113,      (yytype_int16 const   )134, 
        (yytype_int16 const   )135,      (yytype_int16 const   )136,      (yytype_int16 const   )35,      (yytype_int16 const   )120, 
        (yytype_int16 const   )75,      (yytype_int16 const   )42,      (yytype_int16 const   )57,      (yytype_int16 const   )76, 
        (yytype_int16 const   )132,      (yytype_int16 const   )124,      (yytype_int16 const   )133,      (yytype_int16 const   )81, 
        (yytype_int16 const   )131,      (yytype_int16 const   )91,      (yytype_int16 const   )121,      (yytype_int16 const   )51, 
        (yytype_int16 const   )121,      (yytype_int16 const   )75,      (yytype_int16 const   )52,      (yytype_int16 const   )42, 
        (yytype_int16 const   )76,      (yytype_int16 const   )59,      (yytype_int16 const   )94,      (yytype_int16 const   )60, 
        (yytype_int16 const   )94,      (yytype_int16 const   )68,      (yytype_int16 const   )98,      (yytype_int16 const   )99, 
        (yytype_int16 const   )100,      (yytype_int16 const   )137,      (yytype_int16 const   )75,      (yytype_int16 const   )120, 
        (yytype_int16 const   )61,      (yytype_int16 const   )76,      (yytype_int16 const   )70,      (yytype_int16 const   )74, 
        (yytype_int16 const   )122,      (yytype_int16 const   )64,      (yytype_int16 const   )65,      (yytype_int16 const   )66, 
        (yytype_int16 const   )71,      (yytype_int16 const   )138,      (yytype_int16 const   )72,      (yytype_int16 const   )73, 
        (yytype_int16 const   )89,      (yytype_int16 const   )87,      (yytype_int16 const   )53,      (yytype_int16 const   )140, 
        (yytype_int16 const   )106,      (yytype_int16 const   )108,      (yytype_int16 const   )109,      (yytype_int16 const   )111, 
        (yytype_int16 const   )138,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )110,      (yytype_int16 const   )112,      (yytype_int16 const   )130, 
        (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )74, 
        (yytype_int16 const   )44,      (yytype_int16 const   )141,      (yytype_int16 const   )126,      (yytype_int16 const   )142, 
        (yytype_int16 const   )129,      (yytype_int16 const   )39,      (yytype_int16 const   )114,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )95,      (yytype_int16 const   )104,      (yytype_int16 const   )139, 
        (yytype_int16 const   )42};
#line 844 "parse-gram.c"
static yytype_uint8 const   yycheck[157]  = 
#line 844
  {      (yytype_uint8 const   )35,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )3,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )18,      (yytype_uint8 const   )3,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )53,      (yytype_uint8 const   )88,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )3,      (yytype_uint8 const   )101,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )104,      (yytype_uint8 const   )31,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )39,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )56,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )52,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )53,      (yytype_uint8 const   )93,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )44,      (yytype_uint8 const   )43,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )3,      (yytype_uint8 const   )93,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )46,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )43,      (yytype_uint8 const   )3,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )128,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )47,      (yytype_uint8 const   )43,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )3,      (yytype_uint8 const   )52,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )45,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )49,      (yytype_uint8 const   )83,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )49,      (yytype_uint8 const   )52,      (yytype_uint8 const   )132, 
        (yytype_uint8 const   )56};
#line 866 "parse-gram.c"
static yytype_uint8 const   yystos[143]  = 
#line 866
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )56,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )64,      (yytype_uint8 const   )53,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )47,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )47,      (yytype_uint8 const   )82,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )3,      (yytype_uint8 const   )43,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )3,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )48,      (yytype_uint8 const   )61,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )86,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )53,      (yytype_uint8 const   )68,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )85,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )87,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )84,      (yytype_uint8 const   )3,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )49,      (yytype_uint8 const   )77,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )84,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )74,      (yytype_uint8 const   )4,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )73,      (yytype_uint8 const   )45,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )70,      (yytype_uint8 const   )4,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )52,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )43,      (yytype_uint8 const   )87,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )4,      (yytype_uint8 const   )53};
#line 1008 "parse-gram.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ,
                                  location const   * const  yylocationp ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 1019
  if (! yyvaluep) {
#line 1020
    return;
  }
  {
#line 1030
  if (yytype == 3) {
#line 1030
    goto case_3;
  }
#line 1039
  if (yytype == 4) {
#line 1039
    goto case_4;
  }
#line 1048
  if (yytype == 43) {
#line 1048
    goto case_43;
  }
#line 1057
  if (yytype == 44) {
#line 1057
    goto case_44;
  }
#line 1066
  if (yytype == 45) {
#line 1066
    goto case_45;
  }
#line 1075
  if (yytype == 47) {
#line 1075
    goto case_47;
  }
#line 1084
  if (yytype == 48) {
#line 1084
    goto case_48;
  }
#line 1093
  if (yytype == 51) {
#line 1093
    goto case_51;
  }
#line 1102
  if (yytype == 53) {
#line 1102
    goto case_53;
  }
#line 1111
  if (yytype == 82) {
#line 1111
    goto case_82;
  }
#line 1120
  if (yytype == 83) {
#line 1120
    goto case_83;
  }
#line 1129
  if (yytype == 84) {
#line 1129
    goto case_84;
  }
#line 1138
  if (yytype == 85) {
#line 1138
    goto case_85;
  }
#line 1147
  if (yytype == 86) {
#line 1147
    goto case_86;
  }
#line 1156
  if (yytype == 87) {
#line 1156
    goto case_87;
  }
#line 1165
  if (yytype == 88) {
#line 1165
    goto case_88;
  }
#line 1174
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 180 "parse-gram.y"
  tmp = quotearg_style((enum quoting_style )3, (char const   *)yyvaluep->chars);
#line 180
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
  }
#line 1038 "parse-gram.c"
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 191 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d",
          yyvaluep->integer);
  }
#line 1047 "parse-gram.c"
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 182 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{\n%s\n}",
          yyvaluep->code);
  }
#line 1056 "parse-gram.c"
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 174 "parse-gram.y"
  tmp___0 = char_name((char )yyvaluep->character);
#line 174
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
  }
#line 1065 "parse-gram.c"
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 182 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{\n%s\n}",
          yyvaluep->chars);
  }
#line 1074 "parse-gram.c"
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 187 "parse-gram.y"
  fputs_unlocked((char const   */* __restrict  */)yyvaluep->uniqstr, (FILE */* __restrict  */)stderr);
  }
#line 1083 "parse-gram.c"
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 188 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
          yyvaluep->uniqstr);
  }
#line 1092 "parse-gram.c"
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 182 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{\n%s\n}",
          yyvaluep->chars);
  }
#line 1101 "parse-gram.c"
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 186 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<%s>",
          yyvaluep->uniqstr);
  }
#line 1110 "parse-gram.c"
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 187 "parse-gram.y"
  fputs_unlocked((char const   */* __restrict  */)yyvaluep->uniqstr, (FILE */* __restrict  */)stderr);
  }
#line 1119 "parse-gram.c"
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 182 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{\n%s\n}",
          yyvaluep->chars);
  }
#line 1128 "parse-gram.c"
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 182 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"{\n%s\n}",
          yyvaluep->chars);
  }
#line 1137 "parse-gram.c"
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 194 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          (yyvaluep->symbol)->tag);
  }
#line 1146 "parse-gram.c"
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 195 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
          (yyvaluep->symbol)->tag);
  }
#line 1155 "parse-gram.c"
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 194 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          (yyvaluep->symbol)->tag);
  }
#line 1164 "parse-gram.c"
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 194 "parse-gram.y"
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          (yyvaluep->symbol)->tag);
  }
#line 1173 "parse-gram.c"
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1175
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1186 "parse-gram.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ,
                            location const   * const  yylocationp ) 
{ 


  {
#line 1197
  if (yytype < 57) {
    {
#line 1198
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 1200
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 1202
  location_print(yyoutput, (location )*yylocationp);
#line 1203
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)": ");
#line 1204
  yy_symbol_value_print(yyoutput, yytype, yyvaluep, yylocationp);
#line 1205
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 1206
  return;
}
}
#line 1215 "parse-gram.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;

  {
  {
#line 1224
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1225
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 1225
      goto while_break;
    }
    {
#line 1227
    yybot = (int )*yybottom;
#line 1228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            yybot);
#line 1225
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1230
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1231
  return;
}
}
#line 1246 "parse-gram.c"
static void yy_reduce_print(YYSTYPE *yyvsp , location *yylsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 1256
  yynrhs = (int )yyr2[yyrule];
#line 1258
  yylno = (unsigned long )yyrline[yyrule];
#line 1259
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 1262
  yyi = 0;
  }
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! (yyi < yynrhs)) {
#line 1262
      goto while_break;
    }
    {
#line 1264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 1265
    yy_symbol_print(stderr, (int )yyrhs[yyprhs[yyrule] + (yytype_uint16 const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)),
                    (location const   */* const  */)(yylsp + ((yyi + 1) - yynrhs)));
#line 1268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1262
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  return;
}
}
#line 1368 "parse-gram.c"
static unsigned int yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned int yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1371
  if ((int const   )*yystr == 34) {
#line 1373
    yyn = 0U;
#line 1374
    yyp = yystr;
    {
#line 1376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1377
      yyp ++;
      {
#line 1380
      if ((int const   )*yyp == 44) {
#line 1380
        goto case_44;
      }
#line 1380
      if ((int const   )*yyp == 39) {
#line 1380
        goto case_44;
      }
#line 1383
      if ((int const   )*yyp == 92) {
#line 1383
        goto case_92;
      }
#line 1393
      if ((int const   )*yyp == 34) {
#line 1393
        goto case_34;
      }
#line 1387
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1381
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1384
      yyp ++;
#line 1384
      if ((int const   )*yyp != 92) {
#line 1385
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1388
      if (yyres) {
#line 1389
        *(yyres + yyn) = (char )*yyp;
      }
#line 1390
      yyn ++;
#line 1391
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1394
      if (yyres) {
#line 1395
        *(yyres + yyn) = (char )'\000';
      }
#line 1396
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1401
  if (! yyres) {
    {
#line 1402
    tmp = strlen(yystr);
    }
#line 1402
    return (tmp);
  }
  {
#line 1404
  tmp___0 = stpcpy((char */* __restrict  */)yyres, (char const   */* __restrict  */)yystr);
  }
#line 1404
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 1444
static unsigned int yysyntax_error(char *yyresult , int yystate , int gram_char ) ;
#line 1444 "parse-gram.c"
static char const   yyunexpected[28]  = 
#line 1444
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1445 "parse-gram.c"
static char const   yyexpecting[15]  = 
#line 1445
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1446 "parse-gram.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1415 "parse-gram.c"
static unsigned int yysyntax_error(char *yyresult , int yystate , int gram_char ) 
{ 
  int yyn ;
  int yytype ;
  yytype_uint8 tmp ;
  unsigned int yysize0 ;
  unsigned int tmp___0 ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *yyp ;
  int yyi ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  char tmp___9 ;

  {
#line 1418
  yyn = (int )yypact[yystate];
#line 1420
  if (-60 < yyn) {
#line 1420
    if (yyn <= 156) {
#line 1424
      if ((unsigned int )gram_char <= 311U) {
#line 1424
        tmp = yytranslate[gram_char];
      } else {
#line 1424
        tmp = (yytype_uint8 const   )2;
      }
      {
#line 1424
      yytype = (int )tmp;
#line 1425
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1425
      yysize0 = tmp___0;
#line 1426
      yysize = yysize0;
#line 1428
      yysize_overflow = 0;
#line 1451
      yyprefix = yyexpecting;
      }
#line 1455
      if (yyn < 0) {
#line 1455
        tmp___1 = - yyn;
      } else {
#line 1455
        tmp___1 = 0;
      }
#line 1455
      yyxbegin = tmp___1;
#line 1458
      yychecklim = (156 - yyn) + 1;
#line 1459
      if (yychecklim < 57) {
#line 1459
        tmp___2 = yychecklim;
      } else {
#line 1459
        tmp___2 = 57;
      }
      {
#line 1459
      yyxend = tmp___2;
#line 1460
      yycount = 1;
#line 1462
      yyarg[0] = (char const   *)yytname[yytype];
#line 1463
      yyfmt = stpcpy((char */* __restrict  */)(yyformat), (char const   */* __restrict  */)(yyunexpected));
#line 1465
      yyx = yyxbegin;
      }
      {
#line 1465
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1465
        if (! (yyx < yyxend)) {
#line 1465
          goto while_break;
        }
#line 1466
        if (yycheck[yyx + yyn] == (yytype_uint8 const   )yyx) {
#line 1466
          if (yyx != 1) {
#line 1468
            if (yycount == 5) {
#line 1470
              yycount = 1;
#line 1471
              yysize = yysize0;
#line 1472
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1473
              goto while_break;
            }
            {
#line 1475
            tmp___3 = yycount;
#line 1475
            yycount ++;
#line 1475
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1476
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1476
            yysize1 = yysize + tmp___4;
#line 1477
            yysize_overflow |= yysize1 < yysize;
#line 1478
            yysize = yysize1;
#line 1479
            yyfmt = stpcpy((char */* __restrict  */)yyfmt, (char const   */* __restrict  */)yyprefix);
#line 1480
            yyprefix = yyor;
            }
          }
        }
#line 1465
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1483
      tmp___5 = dgettext("bison-runtime", (char const   *)(yyformat));
#line 1483
      yyf = (char const   *)tmp___5;
#line 1484
      tmp___6 = strlen(yyf);
#line 1484
      yysize1 = yysize + tmp___6;
#line 1485
      yysize_overflow |= yysize1 < yysize;
#line 1486
      yysize = yysize1;
      }
#line 1488
      if (yysize_overflow) {
#line 1489
        return (4294967295U);
      }
#line 1491
      if (yyresult) {
#line 1496
        yyp = yyresult;
#line 1497
        yyi = 0;
        {
#line 1498
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1498
          tmp___9 = (char )*yyf;
#line 1498
          *yyp = tmp___9;
#line 1498
          if (! ((int )tmp___9 != 0)) {
#line 1498
            goto while_break___0;
          }
#line 1500
          if ((int )*yyp == 37) {
#line 1500
            if ((int const   )*(yyf + 1) == 115) {
#line 1500
              if (yyi < yycount) {
                {
#line 1502
                tmp___7 = yyi;
#line 1502
                yyi ++;
#line 1502
                tmp___8 = yytnamerr(yyp, yyarg[tmp___7]);
#line 1502
                yyp += tmp___8;
#line 1503
                yyf += 2;
                }
              } else {
#line 1507
                yyp ++;
#line 1508
                yyf ++;
              }
            } else {
#line 1507
              yyp ++;
#line 1508
              yyf ++;
            }
          } else {
#line 1507
            yyp ++;
#line 1508
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1512
      return (yysize);
    } else {
#line 1421
      return (0U);
    }
  } else {
#line 1421
    return (0U);
  }
}
}
#line 1525 "parse-gram.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , location *yylocationp ) 
{ 


  {
#line 1539
  if (! yymsg) {
#line 1540
    yymsg = "Deleting";
  }
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (gram_debug) {
      {
#line 1541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1541
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep, (location const   */* const  */)yylocationp);
#line 1541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1541
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1546
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1547
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1549
  return;
}
}
#line 1587 "parse-gram.c"
int gram_parse(void) 
{ 
  int gram_char ;
  YYSTYPE gram_lval ;
  location gram_lloc ;
  int gram_nerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  location yylsa[200] ;
  location *yyls ;
  location *yylsp ;
  location yyerror_range[2] ;
  unsigned int yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  location yyloc ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  unsigned int yynewbytes___1 ;
  code_props plain_code ;
  char const   *tmp___0 ;
  code_props action ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  char const   *skeleton_user ;
  size_t dir_length ;
  size_t tmp___3 ;
  char *skeleton_build ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  symbol_list *list ;
  symbol_list *list___0 ;
  symbol_list *list___1 ;
  symbol_list *list___2 ;
  symbol_list *tmp___8 ;
  symbol_list *tmp___9 ;
  code_props plain_code___0 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  code_props plain_code___1 ;
  unsigned int yysize___0 ;
  unsigned int tmp___13 ;
  unsigned int yyalloc ;
  void *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 1652
  yymsg = yymsgbuf;
#line 1653
  yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 1660
  yylen = 0;
#line 1662
  yytoken = 0;
#line 1663
  yyss = yyssa;
#line 1664
  yyvs = yyvsa;
#line 1665
  yyls = yylsa;
#line 1666
  yystacksize = 200U;
  {
#line 1668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    if (gram_debug) {
      {
#line 1668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1668
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1670
  yystate = 0;
#line 1671
  yyerrstatus = 0;
#line 1672
  gram_nerrs = 0;
#line 1673
  gram_char = -2;
#line 1679
  yyssp = yyss;
#line 1680
  yyvsp = yyvs;
#line 1681
  yylsp = yyls;
#line 87 "parse-gram.y"
  boundary_set(& gram_lloc.start, current_file, 1, 1);
#line 88
  boundary_set(& gram_lloc.end, current_file, 1, 1);
#line 1702 "parse-gram.c"
  *(yylsp + 0) = gram_lloc;
  }
#line 1704
  goto yysetstate;
  yynewstate: 
#line 1712
  yyssp ++;
  yysetstate: 
#line 1715
  *yyssp = (yytype_int16 )yystate;
#line 1717
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1720
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1750
    if (10000U <= yystacksize) {
#line 1751
      goto yyexhaustedlab;
    }
#line 1752
    yystacksize *= 2U;
#line 1753
    if (10000U < yystacksize) {
#line 1754
      yystacksize = 10000U;
    }
    {
#line 1757
    yyss1 = yyss;
#line 1758
    tmp = malloc((size_t )((unsigned long )yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + sizeof(location )) + 2UL * (sizeof(union yyalloc ) - 1UL)));
#line 1758
    yyptr = (union yyalloc *)tmp;
    }
#line 1760
    if (! yyptr) {
#line 1761
      goto yyexhaustedlab;
    }
    {
#line 1762
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1762
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1762
      yyss = & yyptr->yyss_alloc;
#line 1762
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1762
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1762
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1763
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1763
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1763
      yyvs = & yyptr->yyvs_alloc;
#line 1763
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1763
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1763
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1764
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1764
      __builtin_memcpy((void *)(& yyptr->yyls_alloc), (void const   *)yyls, (unsigned long )yysize * sizeof(*yyls));
#line 1764
      yyls = & yyptr->yyls_alloc;
#line 1764
      yynewbytes___1 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyls) + (sizeof(union yyalloc ) - 1UL));
#line 1764
      yyptr += (unsigned long )yynewbytes___1 / sizeof(*yyptr);
      }
#line 1764
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1766
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1767
      free((void *)yyss1);
      }
    }
#line 1772
    yyssp = (yyss + yysize) - 1;
#line 1773
    yyvsp = (yyvs + yysize) - 1;
#line 1774
    yylsp = (yyls + yysize) - 1;
    {
#line 1776
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1776
      if (gram_debug) {
        {
#line 1776
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yystacksize);
        }
      }
#line 1776
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1779
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1780
      goto yyabortlab;
    }
  }
  {
#line 1783
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1783
    if (gram_debug) {
      {
#line 1783
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1783
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1785
  if (yystate == 3) {
#line 1786
    goto yyacceptlab;
  }
#line 1788
  goto yybackup;
  yybackup: 
#line 1799
  yyn = (int )yypact[yystate];
#line 1800
  if (yyn == -60) {
#line 1801
    goto yydefault;
  }
#line 1806
  if (gram_char == -2) {
    {
#line 1808
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1808
      if (gram_debug) {
        {
#line 1808
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1808
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1809
    gram_char = gram_lex(& gram_lval, & gram_lloc);
    }
  }
#line 1812
  if (gram_char <= 0) {
#line 1814
    yytoken = 0;
#line 1814
    gram_char = yytoken;
    {
#line 1815
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1815
      if (gram_debug) {
        {
#line 1815
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1815
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 1819
    if ((unsigned int )gram_char <= 311U) {
#line 1819
      yytoken = (int )yytranslate[gram_char];
    } else {
#line 1819
      yytoken = 2;
    }
    {
#line 1820
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1820
      if (gram_debug) {
        {
#line 1820
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1820
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& gram_lval),
                        (location const   */* const  */)(& gram_lloc));
#line 1820
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1820
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 1825
  yyn += yytoken;
#line 1826
  if (yyn < 0) {
#line 1827
    goto yydefault;
  } else
#line 1826
  if (156 < yyn) {
#line 1827
    goto yydefault;
  } else
#line 1826
  if (yycheck[yyn] != (yytype_uint8 const   )yytoken) {
#line 1827
    goto yydefault;
  }
#line 1828
  yyn = (int )yytable[yyn];
#line 1829
  if (yyn <= 0) {
#line 1831
    if (yyn == 0) {
#line 1832
      goto yyerrlab;
    } else
#line 1831
    if (yyn == -105) {
#line 1832
      goto yyerrlab;
    }
#line 1833
    yyn = - yyn;
#line 1834
    goto yyreduce;
  }
#line 1839
  if (yyerrstatus) {
#line 1840
    yyerrstatus --;
  }
  {
#line 1843
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1843
    if (gram_debug) {
      {
#line 1843
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1843
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& gram_lval),
                      (location const   */* const  */)(& gram_lloc));
#line 1843
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1843
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1846
  gram_char = -2;
#line 1848
  yystate = yyn;
#line 1849
  yyvsp ++;
#line 1849
  *yyvsp = gram_lval;
#line 1850
  yylsp ++;
#line 1850
  *yylsp = gram_lloc;
#line 1851
  goto yynewstate;
  yydefault: 
#line 1858
  yyn = (int )yydefact___0[yystate];
#line 1859
  if (yyn == 0) {
#line 1860
    goto yyerrlab;
  }
#line 1861
  goto yyreduce;
  yyreduce: 
  {
#line 1869
  yylen = (int )yyr2[yyn];
#line 1879
  yyval = *(yyvsp + (1 - yylen));
#line 1882
  yyloc = lloc_default((location const   *)(yylsp - yylen), yylen);
  }
  {
#line 1883
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1883
    if (gram_debug) {
      {
#line 1883
      yy_reduce_print(yyvsp, yylsp, yyn);
      }
    }
#line 1883
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1886
  if (yyn == 6) {
#line 1886
    goto case_6;
  }
#line 229
  if (yyn == 7) {
#line 229 "parse-gram.y"
    goto case_7;
  }
#line 230
  if (yyn == 8) {
#line 230
    goto case_8;
  }
#line 234
  if (yyn == 9) {
#line 234
    goto case_9;
  }
#line 235
  if (yyn == 10) {
#line 235
    goto case_10;
  }
#line 240
  if (yyn == 11) {
#line 240
    goto case_11;
  }
#line 241
  if (yyn == 12) {
#line 241
    goto case_12;
  }
#line 242
  if (yyn == 13) {
#line 242
    goto case_13;
  }
#line 243
  if (yyn == 14) {
#line 243
    goto case_14;
  }
#line 244
  if (yyn == 15) {
#line 244
    goto case_15;
  }
#line 245
  if (yyn == 16) {
#line 245
    goto case_16;
  }
#line 250
  if (yyn == 17) {
#line 250
    goto case_17;
  }
#line 259
  if (yyn == 18) {
#line 259
    goto case_18;
  }
#line 260
  if (yyn == 19) {
#line 260
    goto case_19;
  }
#line 261
  if (yyn == 20) {
#line 261
    goto case_20;
  }
#line 262
  if (yyn == 21) {
#line 262
    goto case_21;
  }
#line 263
  if (yyn == 22) {
#line 263
    goto case_22;
  }
#line 264
  if (yyn == 23) {
#line 264
    goto case_23;
  }
#line 265
  if (yyn == 24) {
#line 265
    goto case_24;
  }
#line 266
  if (yyn == 25) {
#line 266
    goto case_25;
  }
#line 267
  if (yyn == 26) {
#line 267
    goto case_26;
  }
#line 268
  if (yyn == 27) {
#line 268
    goto case_27;
  }
#line 269
  if (yyn == 28) {
#line 269
    goto case_28;
  }
#line 282
  if (yyn == 29) {
#line 282
    goto case_29;
  }
#line 283
  if (yyn == 30) {
#line 283
    goto case_30;
  }
#line 307
  if (yyn == 31) {
#line 307
    goto case_31;
  }
#line 308
  if (yyn == 32) {
#line 308
    goto case_32;
  }
#line 309
  if (yyn == 33) {
#line 309
    goto case_33;
  }
#line 310
  if (yyn == 37) {
#line 310
    goto case_37;
  }
#line 320
  if (yyn == 38) {
#line 320
    goto case_38;
  }
#line 327
  if (yyn == 39) {
#line 327
    goto case_39;
  }
#line 334
  if (yyn == 40) {
#line 334
    goto case_40;
  }
#line 338
  if (yyn == 41) {
#line 338
    goto case_41;
  }
#line 342
  if (yyn == 42) {
#line 342
    goto case_42;
  }
#line 349
  if (yyn == 43) {
#line 349
    goto case_43;
  }
#line 354
  if (yyn == 44) {
#line 354
    goto case_44;
  }
#line 365
  if (yyn == 45) {
#line 365
    goto case_45;
  }
#line 366
  if (yyn == 46) {
#line 366
    goto case_46;
  }
#line 375
  if (yyn == 47) {
#line 375
    goto case_47;
  }
#line 382
  if (yyn == 48) {
#line 382
    goto case_48;
  }
#line 386
  if (yyn == 49) {
#line 386
    goto case_49;
  }
#line 387
  if (yyn == 50) {
#line 387
    goto case_50;
  }
#line 391
  if (yyn == 51) {
#line 391
    goto case_51;
  }
#line 399
  if (yyn == 52) {
#line 399
    goto case_52;
  }
#line 414
  if (yyn == 53) {
#line 414
    goto case_53;
  }
#line 418
  if (yyn == 54) {
#line 418
    goto case_54;
  }
#line 419
  if (yyn == 55) {
#line 419
    goto case_55;
  }
#line 420
  if (yyn == 56) {
#line 420
    goto case_56;
  }
#line 424
  if (yyn == 57) {
#line 424
    goto case_57;
  }
#line 425
  if (yyn == 58) {
#line 425
    goto case_58;
  }
#line 431
  if (yyn == 59) {
#line 431
    goto case_59;
  }
#line 433
  if (yyn == 60) {
#line 433
    goto case_60;
  }
#line 437
  if (yyn == 61) {
#line 437
    goto case_61;
  }
#line 438
  if (yyn == 62) {
#line 438
    goto case_62;
  }
#line 444
  if (yyn == 63) {
#line 444
    goto case_63;
  }
#line 446
  if (yyn == 64) {
#line 446
    goto case_64;
  }
#line 450
  if (yyn == 65) {
#line 450
    goto case_65;
  }
#line 451
  if (yyn == 66) {
#line 451
    goto case_66;
  }
#line 455
  if (yyn == 67) {
#line 455
    goto case_67;
  }
#line 456
  if (yyn == 68) {
#line 456
    goto case_68;
  }
#line 457
  if (yyn == 69) {
#line 457
    goto case_69;
  }
#line 458
  if (yyn == 70) {
#line 458
    goto case_70;
  }
#line 467
  if (yyn == 71) {
#line 467
    goto case_71;
  }
#line 472
  if (yyn == 72) {
#line 472
    goto case_72;
  }
#line 478
  if (yyn == 73) {
#line 478
    goto case_73;
  }
#line 484
  if (yyn == 74) {
#line 484
    goto case_74;
  }
#line 491
  if (yyn == 81) {
#line 491
    goto case_81;
  }
#line 518
  if (yyn == 82) {
#line 518
    goto case_82;
  }
#line 522
  if (yyn == 84) {
#line 522
    goto case_84;
  }
#line 526
  if (yyn == 85) {
#line 526
    goto case_85;
  }
#line 527
  if (yyn == 87) {
#line 527
    goto case_87;
  }
#line 533
  if (yyn == 88) {
#line 533
    goto case_88;
  }
#line 535
  if (yyn == 89) {
#line 535
    goto case_89;
  }
#line 537
  if (yyn == 90) {
#line 537
    goto case_90;
  }
#line 539
  if (yyn == 91) {
#line 539
    goto case_91;
  }
#line 541
  if (yyn == 92) {
#line 541
    goto case_92;
  }
#line 543
  if (yyn == 94) {
#line 543
    goto case_94;
  }
#line 553
  if (yyn == 95) {
#line 553
    goto case_95;
  }
#line 561
  if (yyn == 97) {
#line 561
    goto case_97;
  }
#line 579
  if (yyn == 98) {
#line 579
    goto case_98;
  }
#line 592
  if (yyn == 99) {
#line 592
    goto case_99;
  }
#line 598
  if (yyn == 100) {
#line 598
    goto case_100;
  }
#line 602
  if (yyn == 103) {
#line 602
    goto case_103;
  }
#line 617
  if (yyn == 105) {
#line 617
    goto case_105;
  }
#line 2628 "parse-gram.c"
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 220 "parse-gram.y"
  code_props_plain_init(& plain_code, (yyvsp + 0)->chars, *(yylsp + 0));
#line 221
  code_props_translate_code(& plain_code);
#line 222
  gram_scanner_last_string_free();
  }
#line 223
  if (union_seen) {
#line 223
    tmp___0 = "post_prologue";
  } else {
#line 223
    tmp___0 = "pre_prologue";
  }
  {
#line 223
  muscle_code_grow(tmp___0, plain_code.code, *(yylsp + 0));
#line 225
  code_scanner_last_string_free();
  }
#line 227
  goto switch_break;
  case_7: /* CIL Label */ 
#line 227
  debug_flag = (_Bool)1;
#line 228
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 230
  muscle_percent_define_insert((yyvsp + -1)->uniqstr, *(yylsp + -1), (yyvsp + 0)->chars);
  }
#line 232
  goto switch_break;
  case_9: /* CIL Label */ 
#line 232
  defines_flag = (_Bool)1;
#line 233
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 235
  defines_flag = (_Bool)1;
#line 236
  spec_defines_file = xstrdup((yyvsp + 0)->chars);
  }
#line 238
  goto switch_break;
  case_11: /* CIL Label */ 
#line 238
  error_verbose = (_Bool)1;
#line 239
  goto switch_break;
  case_12: /* CIL Label */ 
#line 239
  expected_sr_conflicts = (yyvsp + 0)->integer;
#line 240
  goto switch_break;
  case_13: /* CIL Label */ 
#line 240
  expected_rr_conflicts = (yyvsp + 0)->integer;
#line 241
  goto switch_break;
  case_14: /* CIL Label */ 
#line 241
  spec_file_prefix = (yyvsp + 0)->chars;
#line 242
  goto switch_break;
  case_15: /* CIL Label */ 
#line 242
  spec_file_prefix = (yyvsp + 0)->chars;
#line 243
  goto switch_break;
  case_16: /* CIL Label */ 
#line 245
  nondeterministic_parser = (_Bool)1;
#line 246
  glr_parser = (_Bool)1;
#line 248
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 251
  code_props_symbol_action_init(& action, (char const   *)(yyvsp + 0)->code, *(yylsp + 0));
#line 252
  code_props_translate_code(& action);
#line 253
  gram_scanner_last_string_free();
#line 254
  muscle_code_grow("initial_action", action.code, *(yylsp + 0));
#line 255
  code_scanner_last_string_free();
  }
#line 257
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 257
  language_argmatch((yyvsp + 0)->chars, 1, (location const   *)(yylsp + -1));
  }
#line 258
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 258
  add_param("lex_param", (yyvsp + 0)->code, *(yylsp + 0));
  }
#line 259
  goto switch_break;
  case_20: /* CIL Label */ 
#line 259
  locations_flag = (_Bool)1;
#line 260
  goto switch_break;
  case_21: /* CIL Label */ 
#line 260
  spec_name_prefix = (yyvsp + 0)->chars;
#line 261
  goto switch_break;
  case_22: /* CIL Label */ 
#line 261
  spec_name_prefix = (yyvsp + 0)->chars;
#line 262
  goto switch_break;
  case_23: /* CIL Label */ 
#line 262
  no_lines_flag = (_Bool)1;
#line 263
  goto switch_break;
  case_24: /* CIL Label */ 
#line 263
  nondeterministic_parser = (_Bool)1;
#line 264
  goto switch_break;
  case_25: /* CIL Label */ 
#line 264
  spec_outfile = (yyvsp + 0)->chars;
#line 265
  goto switch_break;
  case_26: /* CIL Label */ 
#line 265
  spec_outfile = (yyvsp + 0)->chars;
#line 266
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 266
  add_param("parse_param", (yyvsp + 0)->code, *(yylsp + 0));
  }
#line 267
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 272
  tmp___1 = muscle_find_const("percent_define(api.pure)");
  }
#line 272
  if (! tmp___1) {
    {
#line 273
    muscle_percent_define_insert("api.pure", *(yylsp + 0), "");
    }
  }
  {
#line 277
  tmp___2 = muscle_percent_define_flag_if("api.pure");
  }
#line 277
  if (! tmp___2) {
    {
#line 278
    muscle_percent_define_insert("api.pure", *(yylsp + 0), "");
    }
  }
#line 280
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 280
  version_check((location const   *)(yylsp + 0), (yyvsp + 0)->chars);
  }
#line 281
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 283
  skeleton_user = (yyvsp + 0)->chars;
#line 284
  tmp___7 = strchr(skeleton_user, '/');
  }
#line 284
  if (tmp___7) {
    {
#line 286
    tmp___3 = strlen(current_file);
#line 286
    dir_length = tmp___3;
    }
    {
#line 288
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 288
      if (dir_length) {
#line 288
        if (! ((int const   )*(current_file + (dir_length - 1U)) != 47)) {
#line 288
          goto while_break___10;
        }
      } else {
#line 288
        goto while_break___10;
      }
#line 289
      dir_length --;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 290
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 290
      if (dir_length) {
#line 290
        if (! ((int const   )*(current_file + (dir_length - 1U)) == 47)) {
#line 290
          goto while_break___11;
        }
      } else {
#line 290
        goto while_break___11;
      }
#line 291
      dir_length --;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 292
    tmp___4 = strlen(skeleton_user);
#line 292
    tmp___5 = xmalloc(((dir_length + 1U) + tmp___4) + 1U);
#line 292
    skeleton_build = (char *)tmp___5;
    }
#line 294
    if (dir_length > 0U) {
      {
#line 296
      strncpy((char */* __restrict  */)skeleton_build, (char const   */* __restrict  */)current_file,
              dir_length);
#line 297
      tmp___6 = dir_length;
#line 297
      dir_length ++;
#line 297
      *(skeleton_build + tmp___6) = (char )'/';
      }
    }
    {
#line 299
    strcpy((char */* __restrict  */)(skeleton_build + dir_length), (char const   */* __restrict  */)skeleton_user);
#line 300
    skeleton_user = uniqstr_new((char const   *)skeleton_build);
#line 301
    free((void *)skeleton_build);
    }
  }
  {
#line 303
  skeleton_arg(skeleton_user, 1, (location const   *)(yylsp + -1));
  }
#line 305
  goto switch_break;
  case_31: /* CIL Label */ 
#line 305
  token_table_flag = (_Bool)1;
#line 306
  goto switch_break;
  case_32: /* CIL Label */ 
#line 306
  report_flag |= 1;
#line 307
  goto switch_break;
  case_33: /* CIL Label */ 
#line 307
  yacc_flag = (_Bool)1;
#line 308
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 316
  grammar_start_symbol_set((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 318
  goto switch_break;
  case_38: /* CIL Label */ 
#line 321
  list = (yyvsp + 0)->list;
  {
#line 321
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 321
    if (! list) {
#line 321
      goto while_break___12;
    }
    {
#line 322
    symbol_list_destructor_set(list, (char const   *)(yyvsp + -1)->code, *(yylsp + -1));
#line 321
    list = list->next;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 323
  symbol_list_free((yyvsp + 0)->list);
  }
#line 325
  goto switch_break;
  case_39: /* CIL Label */ 
#line 328
  list___0 = (yyvsp + 0)->list;
  {
#line 328
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 328
    if (! list___0) {
#line 328
      goto while_break___13;
    }
    {
#line 329
    symbol_list_printer_set(list___0, (char const   *)(yyvsp + -1)->code, *(yylsp + -1));
#line 328
    list___0 = list___0->next;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 330
  symbol_list_free((yyvsp + 0)->list);
  }
#line 332
  goto switch_break;
  case_40: /* CIL Label */ 
#line 334
  default_prec = (_Bool)1;
#line 336
  goto switch_break;
  case_41: /* CIL Label */ 
#line 338
  default_prec = (_Bool)0;
#line 340
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 344
  muscle_code_grow("percent_code()", (yyvsp + 0)->chars, *(yylsp + 0));
#line 345
  code_scanner_last_string_free();
  }
#line 347
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 349
  muscle_percent_code_grow((yyvsp + -1)->uniqstr, *(yylsp + -1), (yyvsp + 0)->chars,
                           *(yylsp + 0));
#line 350
  code_scanner_last_string_free();
  }
#line 352
  goto switch_break;
  case_44: /* CIL Label */ ;
#line 363
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 363
  muscle_code_grow("union_name", (yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 364
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 369
  union_seen = (_Bool)1;
#line 370
  muscle_code_grow("stype", (yyvsp + 0)->chars, *(yylsp + 0));
#line 371
  code_scanner_last_string_free();
  }
#line 373
  goto switch_break;
  case_47: /* CIL Label */ 
#line 379
  current_class = (symbol_class )2;
#line 380
  goto switch_break;
  case_48: /* CIL Label */ 
#line 381
  current_class = (symbol_class )0;
#line 382
  current_type = (uniqstr )((void *)0);
#line 384
  goto switch_break;
  case_49: /* CIL Label */ 
#line 384
  current_class = (symbol_class )1;
#line 385
  goto switch_break;
  case_50: /* CIL Label */ 
#line 386
  current_class = (symbol_class )0;
#line 387
  current_type = (uniqstr )((void *)0);
#line 389
  goto switch_break;
  case_51: /* CIL Label */ 
#line 392
  tag_seen = (_Bool)1;
#line 393
  list___1 = (yyvsp + 0)->list;
  {
#line 393
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 393
    if (! list___1) {
#line 393
      goto while_break___14;
    }
    {
#line 394
    symbol_type_set(list___1->content.sym, (yyvsp + -1)->uniqstr, *(yylsp + -1));
#line 393
    list___1 = list___1->next;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 395
  symbol_list_free((yyvsp + 0)->list);
  }
#line 397
  goto switch_break;
  case_52: /* CIL Label */ 
#line 403
  current_prec ++;
#line 404
  list___2 = (yyvsp + 0)->list;
  {
#line 404
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 404
    if (! list___2) {
#line 404
      goto while_break___15;
    }
    {
#line 406
    symbol_type_set(list___2->content.sym, current_type, *(yylsp + -1));
#line 407
    symbol_precedence_set(list___2->content.sym, current_prec, (yyvsp + -2)->assoc,
                          *(yylsp + -2));
#line 404
    list___2 = list___2->next;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 409
  symbol_list_free((yyvsp + 0)->list);
#line 410
  current_type = (uniqstr )((void *)0);
  }
#line 412
  goto switch_break;
  case_53: /* CIL Label */ 
#line 415
  yyval.assoc = (assoc )2;
#line 416
  goto switch_break;
  case_54: /* CIL Label */ 
#line 416
  yyval.assoc = (assoc )1;
#line 417
  goto switch_break;
  case_55: /* CIL Label */ 
#line 417
  yyval.assoc = (assoc )3;
#line 418
  goto switch_break;
  case_56: /* CIL Label */ 
#line 421
  current_type = (uniqstr )((void *)0);
#line 422
  goto switch_break;
  case_57: /* CIL Label */ 
#line 422
  current_type = (yyvsp + 0)->uniqstr;
#line 422
  tag_seen = (_Bool)1;
#line 423
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 428
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 429
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 430
  tmp___8 = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
#line 430
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, tmp___8);
  }
#line 431
  goto switch_break;
  case_60: /* CIL Label */ 
#line 434
  yyval.symbol = (yyvsp + 0)->symbol;
#line 435
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 435
  yyval.symbol = (yyvsp + -1)->symbol;
#line 435
  symbol_user_token_number_set((yyvsp + -1)->symbol, (yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 436
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 441
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 442
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 443
  tmp___9 = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
#line 443
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, tmp___9);
  }
#line 444
  goto switch_break;
  case_64: /* CIL Label */ 
#line 447
  yyval.list = (yyvsp + 0)->list;
#line 448
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 448
  yyval.list = symbol_list_prepend((yyvsp + -1)->list, (yyvsp + 0)->list);
  }
#line 449
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 452
  yyval.list = symbol_list_sym_new((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 453
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 453
  yyval.list = symbol_list_type_new((yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 454
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 454
  yyval.list = symbol_list_default_tagged_new(*(yylsp + 0));
  }
#line 455
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 455
  yyval.list = symbol_list_default_tagless_new(*(yylsp + 0));
  }
#line 456
  goto switch_break;
  case_70: /* CIL Label */ 
#line 462
  current_type = (yyvsp + 0)->uniqstr;
#line 463
  tag_seen = (_Bool)1;
#line 465
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 467
  symbol_class_set((yyvsp + 0)->symbol, current_class, *(yylsp + 0), (_Bool)1);
#line 468
  symbol_type_set((yyvsp + 0)->symbol, current_type, *(yylsp + 0));
  }
#line 470
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 472
  symbol_class_set((yyvsp + -1)->symbol, current_class, *(yylsp + -1), (_Bool)1);
#line 473
  symbol_type_set((yyvsp + -1)->symbol, current_type, *(yylsp + -1));
#line 474
  symbol_user_token_number_set((yyvsp + -1)->symbol, (yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 476
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 478
  symbol_class_set((yyvsp + -1)->symbol, current_class, *(yylsp + -1), (_Bool)1);
#line 479
  symbol_type_set((yyvsp + -1)->symbol, current_type, *(yylsp + -1));
#line 480
  symbol_make_alias((yyvsp + -1)->symbol, (yyvsp + 0)->symbol, yyloc);
  }
#line 482
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 484
  symbol_class_set((yyvsp + -2)->symbol, current_class, *(yylsp + -2), (_Bool)1);
#line 485
  symbol_type_set((yyvsp + -2)->symbol, current_type, *(yylsp + -2));
#line 486
  symbol_user_token_number_set((yyvsp + -2)->symbol, (yyvsp + -1)->integer, *(yylsp + -1));
#line 487
  symbol_make_alias((yyvsp + -2)->symbol, (yyvsp + 0)->symbol, yyloc);
  }
#line 489
  goto switch_break;
  case_81: /* CIL Label */ 
#line 514
  yyerrstatus = 0;
#line 516
  goto switch_break;
  case_82: /* CIL Label */ 
#line 519
  current_lhs = (yyvsp + 0)->symbol;
#line 519
  current_lhs_location = *(yylsp + 0);
#line 520
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 523
  grammar_current_rule_end(*(yylsp + 0));
  }
#line 524
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 524
  grammar_current_rule_end(*(yylsp + 0));
  }
#line 525
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 530
  grammar_current_rule_begin(current_lhs, current_lhs_location);
  }
#line 531
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 532
  grammar_current_rule_symbol_append((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 533
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 534
  grammar_current_rule_action_append((char const   *)(yyvsp + 0)->code, *(yylsp + 0));
  }
#line 535
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 536
  grammar_current_rule_prec_set((yyvsp + 0)->symbol, *(yylsp + 0));
  }
#line 537
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 538
  grammar_current_rule_dprec_set((yyvsp + 0)->integer, *(yylsp + 0));
  }
#line 539
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 540
  grammar_current_rule_merge_set((yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 541
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 550
  yyval.uniqstr = uniqstr_new((yyvsp + 0)->chars);
  }
#line 551
  goto switch_break;
  case_95: /* CIL Label */ 
#line 557
  yyval.chars = "";
#line 559
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 571
  tmp___10 = strlen((char const   *)(yyvsp + 0)->code);
#line 571
  *((yyvsp + 0)->code + (tmp___10 - 1U)) = (char )'\n';
#line 572
  code_props_plain_init(& plain_code___0, (char const   *)((yyvsp + 0)->code + 1),
                        *(yylsp + 0));
#line 573
  code_props_translate_code(& plain_code___0);
#line 574
  gram_scanner_last_string_free();
#line 575
  yyval.chars = plain_code___0.code;
  }
#line 577
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 589
  yyval.symbol = symbol_from_uniqstr((uniqstr const   )(yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 590
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 592
  tmp___11 = char_name((char )(yyvsp + 0)->character);
#line 592
  yyval.symbol = symbol_get(tmp___11, *(yylsp + 0));
#line 593
  symbol_class_set(yyval.symbol, (symbol_class )1, *(yylsp + 0), (_Bool)0);
#line 594
  symbol_user_token_number_set(yyval.symbol, (int )(yyvsp + 0)->character, *(yylsp + 0));
  }
#line 596
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 599
  yyval.symbol = symbol_from_uniqstr((uniqstr const   )(yyvsp + 0)->uniqstr, *(yylsp + 0));
  }
#line 600
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 612
  tmp___12 = quotearg_style((enum quoting_style )3, (yyvsp + 0)->chars);
#line 612
  yyval.symbol = symbol_get((char const   *)tmp___12, *(yylsp + 0));
#line 613
  symbol_class_set(yyval.symbol, (symbol_class )1, *(yylsp + 0), (_Bool)0);
  }
#line 615
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 622
  code_props_plain_init(& plain_code___1, (yyvsp + 0)->chars, *(yylsp + 0));
#line 623
  code_props_translate_code(& plain_code___1);
#line 624
  gram_scanner_last_string_free();
#line 625
  muscle_code_grow("epilogue", plain_code___1.code, *(yylsp + 0));
#line 626
  code_scanner_last_string_free();
  }
#line 628
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2628 "parse-gram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2630
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2630
    if (gram_debug) {
      {
#line 2630
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 2630
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval),
                      (location const   */* const  */)(& yyloc));
#line 2630
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2630
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 2632
  yyvsp -= yylen;
#line 2632
  yyssp -= yylen;
#line 2632
  yylsp -= yylen;
#line 2633
  yylen = 0;
  {
#line 2634
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 2634
    if (gram_debug) {
      {
#line 2634
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2634
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 2636
  yyvsp ++;
#line 2636
  *yyvsp = yyval;
#line 2637
  yylsp ++;
#line 2637
  *yylsp = yyloc;
#line 2643
  yyn = (int )yyr1[yyn];
#line 2645
  yystate = (int )(yypgoto[yyn - 57] + (yytype_int16 const   )*yyssp);
#line 2646
  if (0 <= yystate) {
#line 2646
    if (yystate <= 156) {
#line 2646
      if (yycheck[yystate] == (yytype_uint8 const   )*yyssp) {
#line 2647
        yystate = (int )yytable[yystate];
      } else {
#line 2649
        yystate = (int )yydefgoto___0[yyn - 57];
      }
    } else {
#line 2649
      yystate = (int )yydefgoto___0[yyn - 57];
    }
  } else {
#line 2649
    yystate = (int )yydefgoto___0[yyn - 57];
  }
#line 2651
  goto yynewstate;
  yyerrlab: 
#line 2659
  if (! yyerrstatus) {
    {
#line 2661
    gram_nerrs ++;
#line 2666
    tmp___13 = yysyntax_error((char *)0, yystate, gram_char);
#line 2666
    yysize___0 = tmp___13;
    }
#line 2667
    if (yymsg_alloc < yysize___0) {
#line 2667
      if (yymsg_alloc < 4294967295U) {
#line 2669
        yyalloc = 2U * yysize___0;
#line 2670
        if (yysize___0 <= yyalloc) {
#line 2670
          if (! (yyalloc <= 4294967295U)) {
#line 2671
            yyalloc = 4294967295U;
          }
        } else {
#line 2671
          yyalloc = 4294967295U;
        }
#line 2672
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 2673
          free((void *)yymsg);
          }
        }
        {
#line 2674
        tmp___14 = malloc(yyalloc);
#line 2674
        yymsg = (char *)tmp___14;
        }
#line 2675
        if (yymsg) {
#line 2676
          yymsg_alloc = yyalloc;
        } else {
#line 2679
          yymsg = yymsgbuf;
#line 2680
          yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
        }
      }
    }
#line 2684
    if (0U < yysize___0) {
#line 2684
      if (yysize___0 <= yymsg_alloc) {
        {
#line 2686
        yysyntax_error(yymsg, yystate, gram_char);
#line 2687
        gram_error((location const   *)(& gram_lloc), (char const   *)yymsg);
        }
      } else {
#line 2684
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2691
      tmp___15 = dgettext("bison-runtime", "syntax error");
#line 2691
      gram_error((location const   *)(& gram_lloc), (char const   *)tmp___15);
      }
#line 2692
      if (yysize___0 != 0U) {
#line 2693
        goto yyexhaustedlab;
      }
    }
  }
#line 2699
  yyerror_range[0] = gram_lloc;
#line 2701
  if (yyerrstatus == 3) {
#line 2706
    if (gram_char <= 0) {
#line 2709
      if (gram_char == 0) {
#line 2710
        goto yyabortlab;
      }
    } else {
      {
#line 2714
      yydestruct("Error: discarding", yytoken, & gram_lval, & gram_lloc);
#line 2716
      gram_char = -2;
      }
    }
  }
#line 2722
  goto yyerrlab1;
#line 2736
  yyerror_range[0] = *(yylsp + (1 - yylen));
#line 2739
  yyvsp -= yylen;
#line 2739
  yyssp -= yylen;
#line 2739
  yylsp -= yylen;
#line 2740
  yylen = 0;
  {
#line 2741
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 2741
    if (gram_debug) {
      {
#line 2741
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2741
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 2742
  yystate = (int )*yyssp;
#line 2743
  goto yyerrlab1;
  yyerrlab1: 
#line 2750
  yyerrstatus = 3;
  {
#line 2752
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2754
    yyn = (int )yypact[yystate];
#line 2755
    if (yyn != -60) {
#line 2757
      yyn ++;
#line 2758
      if (0 <= yyn) {
#line 2758
        if (yyn <= 156) {
#line 2758
          if (yycheck[yyn] == 1UL) {
#line 2760
            yyn = (int )yytable[yyn];
#line 2761
            if (0 < yyn) {
#line 2762
              goto while_break___19;
            }
          }
        }
      }
    }
#line 2767
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2768
      goto yyabortlab;
    }
    {
#line 2770
    yyerror_range[0] = *yylsp;
#line 2771
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, yylsp);
#line 2773
    yyvsp --;
#line 2773
    yyssp --;
#line 2773
    yylsp --;
#line 2774
    yystate = (int )*yyssp;
    }
    {
#line 2775
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 2775
      if (gram_debug) {
        {
#line 2775
        yy_stack_print(yyss, yyssp);
        }
      }
#line 2775
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 2778
  yyvsp ++;
#line 2778
  *yyvsp = gram_lval;
#line 2780
  yyerror_range[1] = gram_lloc;
#line 2783
  yyloc = lloc_default((location const   *)(yyerror_range - 1), 2);
#line 2784
  yylsp ++;
#line 2784
  *yylsp = yyloc;
  }
  {
#line 2787
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2787
    if (gram_debug) {
      {
#line 2787
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 2787
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp,
                      (location const   */* const  */)yylsp);
#line 2787
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2787
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2789
  yystate = yyn;
#line 2790
  goto yynewstate;
  yyacceptlab: 
#line 2797
  yyresult = 0;
#line 2798
  goto yyreturn;
  yyabortlab: 
#line 2804
  yyresult = 1;
#line 2805
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2812
  tmp___16 = dgettext("bison-runtime", "memory exhausted");
#line 2812
  gram_error((location const   *)(& gram_lloc), (char const   *)tmp___16);
#line 2813
  yyresult = 2;
  }
  yyreturn: 
#line 2818
  if (gram_char != -2) {
    {
#line 2819
    yydestruct("Cleanup: discarding lookahead", yytoken, & gram_lval, & gram_lloc);
    }
  }
#line 2823
  yyvsp -= yylen;
#line 2823
  yyssp -= yylen;
#line 2823
  yylsp -= yylen;
  {
#line 2824
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2824
    if (gram_debug) {
      {
#line 2824
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2824
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 2825
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2825
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2825
      goto while_break___23;
    }
    {
#line 2827
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, yylsp);
#line 2829
    yyvsp --;
#line 2829
    yyssp --;
#line 2829
    yylsp --;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
#line 2832
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2833
    free((void *)yyss);
    }
  }
#line 2836
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2837
    free((void *)yymsg);
    }
  }
#line 2840
  return (yyresult);
}
}
#line 638 "parse-gram.y"
static location lloc_default(location const   *rhs , int n ) 
{ 
  int i ;
  location loc___0 ;
  _Bool tmp ;

  {
#line 646
  loc___0.start = (boundary )(rhs + n)->end;
#line 647
  loc___0.end = (boundary )(rhs + n)->end;
#line 652
  i = 1;
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (i <= n)) {
#line 652
      goto while_break;
    }
    {
#line 653
    tmp = equal_boundaries((boundary )(rhs + i)->start, (boundary )(rhs + i)->end);
    }
#line 653
    if (! tmp) {
#line 655
      loc___0.start = (boundary )(rhs + i)->start;
#line 656
      goto while_break;
    }
#line 652
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  return (loc___0);
}
}
#line 669 "parse-gram.y"
static char const   alphanum[63]  = 
#line 669
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'_',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'7',      (char const   )'8',      (char const   )'9'};
#line 666 "parse-gram.y"
static void add_param(char const   *type , char *decl , location loc___0 ) 
{ 
  char const   *name_start ;
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *name ;
  size_t name_len ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 674
  name_start = (char const   *)((void *)0);
#line 678
  p = decl;
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! *(p + 1)) {
#line 678
      goto while_break;
    }
#line 679
    if ((unsigned long )p == (unsigned long )decl) {
#line 679
      goto _L;
    } else {
      {
#line 679
      tmp = memchr((void const   *)(alphanum), (int )*(p + -1), (size_t )sizeof(alphanum));
      }
#line 679
      if (! tmp) {
        _L: /* CIL Label */ 
        {
#line 679
        tmp___0 = memchr((void const   *)(alphanum), (int )*(p + 0), (size_t )(sizeof(alphanum) - 10UL));
        }
#line 679
        if (tmp___0) {
#line 682
          name_start = (char const   *)p;
        }
      }
    }
#line 678
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    p --;
#line 686
    if (! ((int )*p == 32)) {
#line 686
      if (! ((int )*p == 9)) {
#line 686
        goto while_break___0;
      }
    }
#line 687
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 688
  *(p + 1) = (char )'\000';
  {
#line 689
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 689
    decl ++;
#line 689
    if (! ((int )*decl == 32)) {
#line 689
      if (! ((int )*decl == 9)) {
#line 689
        goto while_break___1;
      }
    }
#line 690
    goto while_continue___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 692
  if (! name_start) {
    {
#line 693
    tmp___1 = gettext("missing identifier in parameter declaration");
#line 693
    complain_at(loc___0, (char const   *)tmp___1);
    }
  } else {
#line 699
    name_len = (size_t )1;
    {
#line 699
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 699
      tmp___2 = memchr((void const   *)(alphanum), (int )*(name_start + name_len),
                       (size_t )sizeof(alphanum));
      }
#line 699
      if (! tmp___2) {
#line 699
        goto while_break___2;
      }
#line 702
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 699
      name_len ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 704
    tmp___3 = xmalloc(name_len + 1U);
#line 704
    name = (char *)tmp___3;
#line 705
    memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)name_start,
           name_len);
#line 706
    *(name + name_len) = (char )'\000';
#line 707
    muscle_pair_list_grow(type, (char const   *)decl, (char const   *)name);
#line 708
    free((void *)name);
    }
  }
  {
#line 711
  gram_scanner_last_string_free();
  }
#line 712
  return;
}
}
#line 715 "parse-gram.y"
static void version_check(location const   *loc___0 , char const   *version ) 
{ 
  int tmp ;

  {
  {
#line 718
  tmp = strverscmp(version, "2.4");
  }
#line 718
  if (tmp > 0) {
    {
#line 720
    complain_at((location )*loc___0, "require bison %s, but have %s", version, "2.4");
#line 722
    exit(63);
    }
  }
#line 724
  return;
}
}
#line 726 "parse-gram.y"
static void gram_error(location const   *loc___0 , char const   *msg ) 
{ 


  {
  {
#line 729
  complain_at((location )*loc___0, "%s", msg);
  }
#line 730
  return;
}
}
#line 732 "parse-gram.y"
char const   *token_name(int type ) 
{ 
  yytype_uint8 tmp ;

  {
#line 735
  if ((unsigned int )type <= 311U) {
#line 735
    tmp = yytranslate[type];
  } else {
#line 735
    tmp = (yytype_uint8 const   )2;
  }
#line 735
  return ((char const   *)yytname[tmp]);
}
}
#line 738 "parse-gram.y"
static char const   *char_name(char c ) 
{ 
  char buf___0[4] ;
  char *tmp ;

  {
#line 741
  if ((int )c == 39) {
#line 742
    return ("\'\\\'\'");
  } else {
    {
#line 746
    buf___0[0] = (char )'\'';
#line 746
    buf___0[1] = c;
#line 746
    buf___0[2] = (char )'\'';
#line 746
    buf___0[3] = (char )'\000';
#line 747
    tmp = quotearg_style((enum quoting_style )5, (char const   *)(buf___0));
    }
#line 747
    return ((char const   *)tmp);
  }
}
}
#line 675 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *parser_file_name ;
#line 62
char *all_but_ext ;
#line 31 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern char const   *skeleton ;
#line 71
extern struct bison_language  const  *language ;
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.h"
void muscle_insert(char const   *key , char const   *value ) ;
#line 32
struct obstack muscle_obstack ;
#line 194
void muscles_m4_output(FILE *out ) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.4/src/output.h"
void output(void) ;
#line 25
char const   *compute_pkgdatadir(void) ;
#line 220 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern state *final_state ;
#line 91 "/home/pronto/abs/test-suite/bison-2.4/src/tables.h"
extern int nvectors ;
#line 94
extern base_number *base ;
#line 98
extern base_number base_ninf ;
#line 100
extern unsigned int *conflict_table ;
#line 101
extern unsigned int *conflict_list ;
#line 102
extern int conflict_list_cnt ;
#line 104
extern base_number *table ;
#line 105
extern base_number *check ;
#line 108
extern base_number table_ninf ;
#line 110
extern state_number *yydefgoto ;
#line 112
extern int high ;
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static struct obstack format_obstack  ;
#line 102 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_unsigned_int_table(char const   *name , unsigned int *table_data ,
                                             unsigned int first , int begin , int end ) 
{ 
  unsigned int min ;
  unsigned int max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 102
  min = first;
#line 102
  max = first;
#line 102
  j = 1;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 102
    __o = & format_obstack;
#line 102
    tmp = strlen((char const   *)(buf___0));
#line 102
    __len = (int )tmp;
    }
#line 102
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 102
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 102
    __o->next_free += __len;
    }
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  i = begin;
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (i < end)) {
#line 102
      goto while_break___0;
    }
#line 102
    __o___0 = & format_obstack;
#line 102
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 102
    tmp___0 = __o___0->next_free;
#line 102
    (__o___0->next_free) ++;
#line 102
    *tmp___0 = (char )',';
#line 102
    if (j >= 10) {
      {
#line 102
      __o___1 = & format_obstack;
#line 102
      tmp___1 = strlen("\n  ");
#line 102
      __len___0 = (int )tmp___1;
      }
#line 102
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 102
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 102
      __o___1->next_free += __len___0;
#line 102
      j = 1;
      }
    } else {
#line 102
      j ++;
    }
    {
#line 102
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 102
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 102
      __o___2 = & format_obstack;
#line 102
      tmp___2 = strlen((char const   *)(buf___1));
#line 102
      __len___1 = (int )tmp___2;
      }
#line 102
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 102
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 102
      __o___2->next_free += __len___1;
      }
#line 102
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 102
    if (*(table_data + i) < min) {
#line 102
      min = *(table_data + i);
    }
#line 102
    if (max < *(table_data + i)) {
#line 102
      max = *(table_data + i);
    }
#line 102
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 102
  __o___3 = & format_obstack;
#line 102
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 102
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 102
  tmp___3 = __o___3->next_free;
#line 102
  (__o___3->next_free) ++;
#line 102
  *tmp___3 = (char)0;
#line 102
  __o1 = & format_obstack;
#line 102
  __value = (void *)__o1->object_base;
#line 102
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 102
    __o1->maybe_empty_object = 1U;
  }
#line 102
  if (sizeof(int ) < sizeof(void *)) {
#line 102
    tmp___4 = __o1->object_base;
  } else {
#line 102
    tmp___4 = (char *)0;
  }
#line 102
  if (sizeof(int ) < sizeof(void *)) {
#line 102
    tmp___5 = __o1->object_base;
  } else {
#line 102
    tmp___5 = (char *)0;
  }
#line 102
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 102
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 102
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 102
  __o1->object_base = __o1->next_free;
#line 102
  muscle_insert(name, (char const   *)__value);
#line 102
  lmin = (long )min;
#line 102
  lmax = (long )max;
  }
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 102
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 102
    __o___4 = & format_obstack;
#line 102
    tmp___6 = strlen((char const   *)(buf___2));
#line 102
    __len___2 = (int )tmp___6;
    }
#line 102
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 102
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 102
    __o___4->next_free += __len___2;
    }
#line 102
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 102
  __o___5 = & format_obstack;
#line 102
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 102
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 102
  tmp___7 = __o___5->next_free;
#line 102
  (__o___5->next_free) ++;
#line 102
  *tmp___7 = (char)0;
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 102
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 102
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 102
      __o___6 = & muscle_obstack;
#line 102
      tmp___8 = strlen((char const   *)(buf___3));
#line 102
      __len___3 = (int )tmp___8;
      }
#line 102
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 102
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 102
      __o___6->next_free += __len___3;
      }
#line 102
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 102
    __o___7 = & muscle_obstack;
#line 102
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 102
    tmp___9 = __o___7->next_free;
#line 102
    (__o___7->next_free) ++;
#line 102
    *tmp___9 = (char)0;
#line 102
    __o1___0 = & muscle_obstack;
#line 102
    __value___0 = (void *)__o1___0->object_base;
#line 102
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 102
      __o1___0->maybe_empty_object = 1U;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___10 = __o1___0->object_base;
    } else {
#line 102
      tmp___10 = (char *)0;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___11 = __o1___0->object_base;
    } else {
#line 102
      tmp___11 = (char *)0;
    }
#line 102
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 102
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 102
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 102
    __o1___0->object_base = __o1___0->next_free;
#line 102
    __o1___1 = & format_obstack;
#line 102
    __value___1 = (void *)__o1___1->object_base;
#line 102
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 102
      __o1___1->maybe_empty_object = 1U;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___12 = __o1___1->object_base;
    } else {
#line 102
      tmp___12 = (char *)0;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___13 = __o1___1->object_base;
    } else {
#line 102
      tmp___13 = (char *)0;
    }
#line 102
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 102
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 102
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 102
    __o1___1->object_base = __o1___1->next_free;
#line 102
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 102
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 102
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 102
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 102
    __o___8 = & format_obstack;
#line 102
    tmp___14 = strlen((char const   *)(buf___4));
#line 102
    __len___4 = (int )tmp___14;
    }
#line 102
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 102
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 102
    __o___8->next_free += __len___4;
    }
#line 102
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 102
  __o___9 = & format_obstack;
#line 102
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 102
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 102
  tmp___15 = __o___9->next_free;
#line 102
  (__o___9->next_free) ++;
#line 102
  *tmp___15 = (char)0;
  {
#line 102
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 102
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 102
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 102
      __o___10 = & muscle_obstack;
#line 102
      tmp___16 = strlen((char const   *)(buf___5));
#line 102
      __len___5 = (int )tmp___16;
      }
#line 102
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 102
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 102
      __o___10->next_free += __len___5;
      }
#line 102
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 102
    __o___11 = & muscle_obstack;
#line 102
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 102
    tmp___17 = __o___11->next_free;
#line 102
    (__o___11->next_free) ++;
#line 102
    *tmp___17 = (char)0;
#line 102
    __o1___2 = & muscle_obstack;
#line 102
    __value___2 = (void *)__o1___2->object_base;
#line 102
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 102
      __o1___2->maybe_empty_object = 1U;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___18 = __o1___2->object_base;
    } else {
#line 102
      tmp___18 = (char *)0;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___19 = __o1___2->object_base;
    } else {
#line 102
      tmp___19 = (char *)0;
    }
#line 102
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 102
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 102
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 102
    __o1___2->object_base = __o1___2->next_free;
#line 102
    __o1___3 = & format_obstack;
#line 102
    __value___3 = (void *)__o1___3->object_base;
#line 102
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 102
      __o1___3->maybe_empty_object = 1U;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___20 = __o1___3->object_base;
    } else {
#line 102
      tmp___20 = (char *)0;
    }
#line 102
    if (sizeof(int ) < sizeof(void *)) {
#line 102
      tmp___21 = __o1___3->object_base;
    } else {
#line 102
      tmp___21 = (char *)0;
    }
#line 102
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 102
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 102
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 102
    __o1___3->object_base = __o1___3->next_free;
#line 102
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 102
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 103 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_int_table(char const   *name , int *table_data , int first ,
                                    int begin , int end ) 
{ 
  int min ;
  int max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 103
  min = first;
#line 103
  max = first;
#line 103
  j = 1;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 103
    __o = & format_obstack;
#line 103
    tmp = strlen((char const   *)(buf___0));
#line 103
    __len = (int )tmp;
    }
#line 103
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 103
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 103
    __o->next_free += __len;
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  i = begin;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i < end)) {
#line 103
      goto while_break___0;
    }
#line 103
    __o___0 = & format_obstack;
#line 103
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 103
    tmp___0 = __o___0->next_free;
#line 103
    (__o___0->next_free) ++;
#line 103
    *tmp___0 = (char )',';
#line 103
    if (j >= 10) {
      {
#line 103
      __o___1 = & format_obstack;
#line 103
      tmp___1 = strlen("\n  ");
#line 103
      __len___0 = (int )tmp___1;
      }
#line 103
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 103
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 103
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 103
      __o___1->next_free += __len___0;
#line 103
      j = 1;
      }
    } else {
#line 103
      j ++;
    }
    {
#line 103
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 103
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 103
      __o___2 = & format_obstack;
#line 103
      tmp___2 = strlen((char const   *)(buf___1));
#line 103
      __len___1 = (int )tmp___2;
      }
#line 103
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 103
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 103
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 103
      __o___2->next_free += __len___1;
      }
#line 103
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    if (*(table_data + i) < min) {
#line 103
      min = *(table_data + i);
    }
#line 103
    if (max < *(table_data + i)) {
#line 103
      max = *(table_data + i);
    }
#line 103
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 103
  __o___3 = & format_obstack;
#line 103
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 103
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 103
  tmp___3 = __o___3->next_free;
#line 103
  (__o___3->next_free) ++;
#line 103
  *tmp___3 = (char)0;
#line 103
  __o1 = & format_obstack;
#line 103
  __value = (void *)__o1->object_base;
#line 103
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 103
    __o1->maybe_empty_object = 1U;
  }
#line 103
  if (sizeof(int ) < sizeof(void *)) {
#line 103
    tmp___4 = __o1->object_base;
  } else {
#line 103
    tmp___4 = (char *)0;
  }
#line 103
  if (sizeof(int ) < sizeof(void *)) {
#line 103
    tmp___5 = __o1->object_base;
  } else {
#line 103
    tmp___5 = (char *)0;
  }
#line 103
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 103
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 103
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 103
  __o1->object_base = __o1->next_free;
#line 103
  muscle_insert(name, (char const   *)__value);
#line 103
  lmin = (long )min;
#line 103
  lmax = (long )max;
  }
  {
#line 103
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 103
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 103
    __o___4 = & format_obstack;
#line 103
    tmp___6 = strlen((char const   *)(buf___2));
#line 103
    __len___2 = (int )tmp___6;
    }
#line 103
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 103
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 103
    __o___4->next_free += __len___2;
    }
#line 103
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  __o___5 = & format_obstack;
#line 103
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 103
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 103
  tmp___7 = __o___5->next_free;
#line 103
  (__o___5->next_free) ++;
#line 103
  *tmp___7 = (char)0;
  {
#line 103
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 103
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 103
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 103
      __o___6 = & muscle_obstack;
#line 103
      tmp___8 = strlen((char const   *)(buf___3));
#line 103
      __len___3 = (int )tmp___8;
      }
#line 103
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 103
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 103
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 103
      __o___6->next_free += __len___3;
      }
#line 103
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 103
    __o___7 = & muscle_obstack;
#line 103
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 103
    tmp___9 = __o___7->next_free;
#line 103
    (__o___7->next_free) ++;
#line 103
    *tmp___9 = (char)0;
#line 103
    __o1___0 = & muscle_obstack;
#line 103
    __value___0 = (void *)__o1___0->object_base;
#line 103
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 103
      __o1___0->maybe_empty_object = 1U;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___10 = __o1___0->object_base;
    } else {
#line 103
      tmp___10 = (char *)0;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___11 = __o1___0->object_base;
    } else {
#line 103
      tmp___11 = (char *)0;
    }
#line 103
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 103
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 103
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 103
    __o1___0->object_base = __o1___0->next_free;
#line 103
    __o1___1 = & format_obstack;
#line 103
    __value___1 = (void *)__o1___1->object_base;
#line 103
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 103
      __o1___1->maybe_empty_object = 1U;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___12 = __o1___1->object_base;
    } else {
#line 103
      tmp___12 = (char *)0;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___13 = __o1___1->object_base;
    } else {
#line 103
      tmp___13 = (char *)0;
    }
#line 103
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 103
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 103
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 103
    __o1___1->object_base = __o1___1->next_free;
#line 103
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 103
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 103
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 103
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 103
    __o___8 = & format_obstack;
#line 103
    tmp___14 = strlen((char const   *)(buf___4));
#line 103
    __len___4 = (int )tmp___14;
    }
#line 103
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 103
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 103
    __o___8->next_free += __len___4;
    }
#line 103
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 103
  __o___9 = & format_obstack;
#line 103
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 103
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 103
  tmp___15 = __o___9->next_free;
#line 103
  (__o___9->next_free) ++;
#line 103
  *tmp___15 = (char)0;
  {
#line 103
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 103
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 103
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 103
      __o___10 = & muscle_obstack;
#line 103
      tmp___16 = strlen((char const   *)(buf___5));
#line 103
      __len___5 = (int )tmp___16;
      }
#line 103
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 103
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 103
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 103
      __o___10->next_free += __len___5;
      }
#line 103
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 103
    __o___11 = & muscle_obstack;
#line 103
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 103
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 103
    tmp___17 = __o___11->next_free;
#line 103
    (__o___11->next_free) ++;
#line 103
    *tmp___17 = (char)0;
#line 103
    __o1___2 = & muscle_obstack;
#line 103
    __value___2 = (void *)__o1___2->object_base;
#line 103
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 103
      __o1___2->maybe_empty_object = 1U;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___18 = __o1___2->object_base;
    } else {
#line 103
      tmp___18 = (char *)0;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___19 = __o1___2->object_base;
    } else {
#line 103
      tmp___19 = (char *)0;
    }
#line 103
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 103
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 103
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 103
    __o1___2->object_base = __o1___2->next_free;
#line 103
    __o1___3 = & format_obstack;
#line 103
    __value___3 = (void *)__o1___3->object_base;
#line 103
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 103
      __o1___3->maybe_empty_object = 1U;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___20 = __o1___3->object_base;
    } else {
#line 103
      tmp___20 = (char *)0;
    }
#line 103
    if (sizeof(int ) < sizeof(void *)) {
#line 103
      tmp___21 = __o1___3->object_base;
    } else {
#line 103
      tmp___21 = (char *)0;
    }
#line 103
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 103
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 103
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 103
    __o1___3->object_base = __o1___3->next_free;
#line 103
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 103
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 104 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_base_table(char const   *name , base_number *table_data ,
                                     base_number first , int begin , int end ) 
{ 
  base_number min ;
  base_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 104
  min = first;
#line 104
  max = first;
#line 104
  j = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 104
    __o = & format_obstack;
#line 104
    tmp = strlen((char const   *)(buf___0));
#line 104
    __len = (int )tmp;
    }
#line 104
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 104
    __o->next_free += __len;
    }
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = begin;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < end)) {
#line 104
      goto while_break___0;
    }
#line 104
    __o___0 = & format_obstack;
#line 104
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 104
    tmp___0 = __o___0->next_free;
#line 104
    (__o___0->next_free) ++;
#line 104
    *tmp___0 = (char )',';
#line 104
    if (j >= 10) {
      {
#line 104
      __o___1 = & format_obstack;
#line 104
      tmp___1 = strlen("\n  ");
#line 104
      __len___0 = (int )tmp___1;
      }
#line 104
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 104
      __o___1->next_free += __len___0;
#line 104
      j = 1;
      }
    } else {
#line 104
      j ++;
    }
    {
#line 104
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 104
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 104
      __o___2 = & format_obstack;
#line 104
      tmp___2 = strlen((char const   *)(buf___1));
#line 104
      __len___1 = (int )tmp___2;
      }
#line 104
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 104
      __o___2->next_free += __len___1;
      }
#line 104
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 104
    if (*(table_data + i) < min) {
#line 104
      min = *(table_data + i);
    }
#line 104
    if (max < *(table_data + i)) {
#line 104
      max = *(table_data + i);
    }
#line 104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  __o___3 = & format_obstack;
#line 104
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 104
  tmp___3 = __o___3->next_free;
#line 104
  (__o___3->next_free) ++;
#line 104
  *tmp___3 = (char)0;
#line 104
  __o1 = & format_obstack;
#line 104
  __value = (void *)__o1->object_base;
#line 104
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 104
    __o1->maybe_empty_object = 1U;
  }
#line 104
  if (sizeof(int ) < sizeof(void *)) {
#line 104
    tmp___4 = __o1->object_base;
  } else {
#line 104
    tmp___4 = (char *)0;
  }
#line 104
  if (sizeof(int ) < sizeof(void *)) {
#line 104
    tmp___5 = __o1->object_base;
  } else {
#line 104
    tmp___5 = (char *)0;
  }
#line 104
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 104
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 104
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 104
  __o1->object_base = __o1->next_free;
#line 104
  muscle_insert(name, (char const   *)__value);
#line 104
  lmin = (long )min;
#line 104
  lmax = (long )max;
  }
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 104
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 104
    __o___4 = & format_obstack;
#line 104
    tmp___6 = strlen((char const   *)(buf___2));
#line 104
    __len___2 = (int )tmp___6;
    }
#line 104
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 104
    __o___4->next_free += __len___2;
    }
#line 104
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 104
  __o___5 = & format_obstack;
#line 104
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 104
  tmp___7 = __o___5->next_free;
#line 104
  (__o___5->next_free) ++;
#line 104
  *tmp___7 = (char)0;
  {
#line 104
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 104
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 104
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 104
      __o___6 = & muscle_obstack;
#line 104
      tmp___8 = strlen((char const   *)(buf___3));
#line 104
      __len___3 = (int )tmp___8;
      }
#line 104
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 104
      __o___6->next_free += __len___3;
      }
#line 104
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 104
    __o___7 = & muscle_obstack;
#line 104
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 104
    tmp___9 = __o___7->next_free;
#line 104
    (__o___7->next_free) ++;
#line 104
    *tmp___9 = (char)0;
#line 104
    __o1___0 = & muscle_obstack;
#line 104
    __value___0 = (void *)__o1___0->object_base;
#line 104
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 104
      __o1___0->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___10 = __o1___0->object_base;
    } else {
#line 104
      tmp___10 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___11 = __o1___0->object_base;
    } else {
#line 104
      tmp___11 = (char *)0;
    }
#line 104
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 104
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 104
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 104
    __o1___0->object_base = __o1___0->next_free;
#line 104
    __o1___1 = & format_obstack;
#line 104
    __value___1 = (void *)__o1___1->object_base;
#line 104
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 104
      __o1___1->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___12 = __o1___1->object_base;
    } else {
#line 104
      tmp___12 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___13 = __o1___1->object_base;
    } else {
#line 104
      tmp___13 = (char *)0;
    }
#line 104
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 104
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 104
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 104
    __o1___1->object_base = __o1___1->next_free;
#line 104
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 104
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 104
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 104
    __o___8 = & format_obstack;
#line 104
    tmp___14 = strlen((char const   *)(buf___4));
#line 104
    __len___4 = (int )tmp___14;
    }
#line 104
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 104
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 104
    __o___8->next_free += __len___4;
    }
#line 104
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 104
  __o___9 = & format_obstack;
#line 104
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 104
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 104
  tmp___15 = __o___9->next_free;
#line 104
  (__o___9->next_free) ++;
#line 104
  *tmp___15 = (char)0;
  {
#line 104
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 104
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 104
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 104
      __o___10 = & muscle_obstack;
#line 104
      tmp___16 = strlen((char const   *)(buf___5));
#line 104
      __len___5 = (int )tmp___16;
      }
#line 104
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 104
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 104
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 104
      __o___10->next_free += __len___5;
      }
#line 104
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 104
    __o___11 = & muscle_obstack;
#line 104
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 104
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 104
    tmp___17 = __o___11->next_free;
#line 104
    (__o___11->next_free) ++;
#line 104
    *tmp___17 = (char)0;
#line 104
    __o1___2 = & muscle_obstack;
#line 104
    __value___2 = (void *)__o1___2->object_base;
#line 104
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 104
      __o1___2->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___18 = __o1___2->object_base;
    } else {
#line 104
      tmp___18 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___19 = __o1___2->object_base;
    } else {
#line 104
      tmp___19 = (char *)0;
    }
#line 104
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 104
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 104
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 104
    __o1___2->object_base = __o1___2->next_free;
#line 104
    __o1___3 = & format_obstack;
#line 104
    __value___3 = (void *)__o1___3->object_base;
#line 104
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 104
      __o1___3->maybe_empty_object = 1U;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___20 = __o1___3->object_base;
    } else {
#line 104
      tmp___20 = (char *)0;
    }
#line 104
    if (sizeof(int ) < sizeof(void *)) {
#line 104
      tmp___21 = __o1___3->object_base;
    } else {
#line 104
      tmp___21 = (char *)0;
    }
#line 104
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 104
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 104
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 104
    __o1___3->object_base = __o1___3->next_free;
#line 104
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 104
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_rule_number_table(char const   *name , rule_number *table_data ,
                                            rule_number first , int begin , int end ) 
{ 
  rule_number min ;
  rule_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 105
  min = first;
#line 105
  max = first;
#line 105
  j = 1;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 105
    __o = & format_obstack;
#line 105
    tmp = strlen((char const   *)(buf___0));
#line 105
    __len = (int )tmp;
    }
#line 105
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 105
    __o->next_free += __len;
    }
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = begin;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (i < end)) {
#line 105
      goto while_break___0;
    }
#line 105
    __o___0 = & format_obstack;
#line 105
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 105
    tmp___0 = __o___0->next_free;
#line 105
    (__o___0->next_free) ++;
#line 105
    *tmp___0 = (char )',';
#line 105
    if (j >= 10) {
      {
#line 105
      __o___1 = & format_obstack;
#line 105
      tmp___1 = strlen("\n  ");
#line 105
      __len___0 = (int )tmp___1;
      }
#line 105
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 105
      __o___1->next_free += __len___0;
#line 105
      j = 1;
      }
    } else {
#line 105
      j ++;
    }
    {
#line 105
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 105
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 105
      __o___2 = & format_obstack;
#line 105
      tmp___2 = strlen((char const   *)(buf___1));
#line 105
      __len___1 = (int )tmp___2;
      }
#line 105
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 105
      __o___2->next_free += __len___1;
      }
#line 105
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 105
    if (*(table_data + i) < min) {
#line 105
      min = *(table_data + i);
    }
#line 105
    if (max < *(table_data + i)) {
#line 105
      max = *(table_data + i);
    }
#line 105
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  __o___3 = & format_obstack;
#line 105
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 105
  tmp___3 = __o___3->next_free;
#line 105
  (__o___3->next_free) ++;
#line 105
  *tmp___3 = (char)0;
#line 105
  __o1 = & format_obstack;
#line 105
  __value = (void *)__o1->object_base;
#line 105
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 105
    __o1->maybe_empty_object = 1U;
  }
#line 105
  if (sizeof(int ) < sizeof(void *)) {
#line 105
    tmp___4 = __o1->object_base;
  } else {
#line 105
    tmp___4 = (char *)0;
  }
#line 105
  if (sizeof(int ) < sizeof(void *)) {
#line 105
    tmp___5 = __o1->object_base;
  } else {
#line 105
    tmp___5 = (char *)0;
  }
#line 105
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 105
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 105
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 105
  __o1->object_base = __o1->next_free;
#line 105
  muscle_insert(name, (char const   *)__value);
#line 105
  lmin = (long )min;
#line 105
  lmax = (long )max;
  }
  {
#line 105
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 105
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 105
    __o___4 = & format_obstack;
#line 105
    tmp___6 = strlen((char const   *)(buf___2));
#line 105
    __len___2 = (int )tmp___6;
    }
#line 105
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 105
    __o___4->next_free += __len___2;
    }
#line 105
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 105
  __o___5 = & format_obstack;
#line 105
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 105
  tmp___7 = __o___5->next_free;
#line 105
  (__o___5->next_free) ++;
#line 105
  *tmp___7 = (char)0;
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 105
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 105
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 105
      __o___6 = & muscle_obstack;
#line 105
      tmp___8 = strlen((char const   *)(buf___3));
#line 105
      __len___3 = (int )tmp___8;
      }
#line 105
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 105
      __o___6->next_free += __len___3;
      }
#line 105
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 105
    __o___7 = & muscle_obstack;
#line 105
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 105
    tmp___9 = __o___7->next_free;
#line 105
    (__o___7->next_free) ++;
#line 105
    *tmp___9 = (char)0;
#line 105
    __o1___0 = & muscle_obstack;
#line 105
    __value___0 = (void *)__o1___0->object_base;
#line 105
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 105
      __o1___0->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___10 = __o1___0->object_base;
    } else {
#line 105
      tmp___10 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___11 = __o1___0->object_base;
    } else {
#line 105
      tmp___11 = (char *)0;
    }
#line 105
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 105
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 105
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 105
    __o1___0->object_base = __o1___0->next_free;
#line 105
    __o1___1 = & format_obstack;
#line 105
    __value___1 = (void *)__o1___1->object_base;
#line 105
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 105
      __o1___1->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___12 = __o1___1->object_base;
    } else {
#line 105
      tmp___12 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___13 = __o1___1->object_base;
    } else {
#line 105
      tmp___13 = (char *)0;
    }
#line 105
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 105
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 105
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 105
    __o1___1->object_base = __o1___1->next_free;
#line 105
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 105
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 105
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 105
    __o___8 = & format_obstack;
#line 105
    tmp___14 = strlen((char const   *)(buf___4));
#line 105
    __len___4 = (int )tmp___14;
    }
#line 105
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 105
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 105
    __o___8->next_free += __len___4;
    }
#line 105
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 105
  __o___9 = & format_obstack;
#line 105
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 105
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 105
  tmp___15 = __o___9->next_free;
#line 105
  (__o___9->next_free) ++;
#line 105
  *tmp___15 = (char)0;
  {
#line 105
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 105
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 105
      __o___10 = & muscle_obstack;
#line 105
      tmp___16 = strlen((char const   *)(buf___5));
#line 105
      __len___5 = (int )tmp___16;
      }
#line 105
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 105
      __o___10->next_free += __len___5;
      }
#line 105
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 105
    __o___11 = & muscle_obstack;
#line 105
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 105
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 105
    tmp___17 = __o___11->next_free;
#line 105
    (__o___11->next_free) ++;
#line 105
    *tmp___17 = (char)0;
#line 105
    __o1___2 = & muscle_obstack;
#line 105
    __value___2 = (void *)__o1___2->object_base;
#line 105
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 105
      __o1___2->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___18 = __o1___2->object_base;
    } else {
#line 105
      tmp___18 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___19 = __o1___2->object_base;
    } else {
#line 105
      tmp___19 = (char *)0;
    }
#line 105
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 105
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 105
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 105
    __o1___2->object_base = __o1___2->next_free;
#line 105
    __o1___3 = & format_obstack;
#line 105
    __value___3 = (void *)__o1___3->object_base;
#line 105
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 105
      __o1___3->maybe_empty_object = 1U;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___20 = __o1___3->object_base;
    } else {
#line 105
      tmp___20 = (char *)0;
    }
#line 105
    if (sizeof(int ) < sizeof(void *)) {
#line 105
      tmp___21 = __o1___3->object_base;
    } else {
#line 105
      tmp___21 = (char *)0;
    }
#line 105
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 105
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 105
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 105
    __o1___3->object_base = __o1___3->next_free;
#line 105
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 105
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 106 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_symbol_number_table(char const   *name , symbol_number *table_data ,
                                              symbol_number first , int begin , int end ) 
{ 
  symbol_number min ;
  symbol_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 106
  min = first;
#line 106
  max = first;
#line 106
  j = 1;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 106
    __o = & format_obstack;
#line 106
    tmp = strlen((char const   *)(buf___0));
#line 106
    __len = (int )tmp;
    }
#line 106
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 106
    __o->next_free += __len;
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  i = begin;
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (i < end)) {
#line 106
      goto while_break___0;
    }
#line 106
    __o___0 = & format_obstack;
#line 106
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 106
    tmp___0 = __o___0->next_free;
#line 106
    (__o___0->next_free) ++;
#line 106
    *tmp___0 = (char )',';
#line 106
    if (j >= 10) {
      {
#line 106
      __o___1 = & format_obstack;
#line 106
      tmp___1 = strlen("\n  ");
#line 106
      __len___0 = (int )tmp___1;
      }
#line 106
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 106
      __o___1->next_free += __len___0;
#line 106
      j = 1;
      }
    } else {
#line 106
      j ++;
    }
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 106
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 106
      __o___2 = & format_obstack;
#line 106
      tmp___2 = strlen((char const   *)(buf___1));
#line 106
      __len___1 = (int )tmp___2;
      }
#line 106
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 106
      __o___2->next_free += __len___1;
      }
#line 106
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 106
    if (*(table_data + i) < min) {
#line 106
      min = *(table_data + i);
    }
#line 106
    if (max < *(table_data + i)) {
#line 106
      max = *(table_data + i);
    }
#line 106
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  __o___3 = & format_obstack;
#line 106
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 106
  tmp___3 = __o___3->next_free;
#line 106
  (__o___3->next_free) ++;
#line 106
  *tmp___3 = (char)0;
#line 106
  __o1 = & format_obstack;
#line 106
  __value = (void *)__o1->object_base;
#line 106
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 106
    __o1->maybe_empty_object = 1U;
  }
#line 106
  if (sizeof(int ) < sizeof(void *)) {
#line 106
    tmp___4 = __o1->object_base;
  } else {
#line 106
    tmp___4 = (char *)0;
  }
#line 106
  if (sizeof(int ) < sizeof(void *)) {
#line 106
    tmp___5 = __o1->object_base;
  } else {
#line 106
    tmp___5 = (char *)0;
  }
#line 106
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 106
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 106
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 106
  __o1->object_base = __o1->next_free;
#line 106
  muscle_insert(name, (char const   *)__value);
#line 106
  lmin = (long )min;
#line 106
  lmax = (long )max;
  }
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 106
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 106
    __o___4 = & format_obstack;
#line 106
    tmp___6 = strlen((char const   *)(buf___2));
#line 106
    __len___2 = (int )tmp___6;
    }
#line 106
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 106
    __o___4->next_free += __len___2;
    }
#line 106
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 106
  __o___5 = & format_obstack;
#line 106
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 106
  tmp___7 = __o___5->next_free;
#line 106
  (__o___5->next_free) ++;
#line 106
  *tmp___7 = (char)0;
  {
#line 106
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 106
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 106
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 106
      __o___6 = & muscle_obstack;
#line 106
      tmp___8 = strlen((char const   *)(buf___3));
#line 106
      __len___3 = (int )tmp___8;
      }
#line 106
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 106
      __o___6->next_free += __len___3;
      }
#line 106
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 106
    __o___7 = & muscle_obstack;
#line 106
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 106
    tmp___9 = __o___7->next_free;
#line 106
    (__o___7->next_free) ++;
#line 106
    *tmp___9 = (char)0;
#line 106
    __o1___0 = & muscle_obstack;
#line 106
    __value___0 = (void *)__o1___0->object_base;
#line 106
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 106
      __o1___0->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___10 = __o1___0->object_base;
    } else {
#line 106
      tmp___10 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___11 = __o1___0->object_base;
    } else {
#line 106
      tmp___11 = (char *)0;
    }
#line 106
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 106
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 106
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 106
    __o1___0->object_base = __o1___0->next_free;
#line 106
    __o1___1 = & format_obstack;
#line 106
    __value___1 = (void *)__o1___1->object_base;
#line 106
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 106
      __o1___1->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___12 = __o1___1->object_base;
    } else {
#line 106
      tmp___12 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___13 = __o1___1->object_base;
    } else {
#line 106
      tmp___13 = (char *)0;
    }
#line 106
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 106
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 106
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 106
    __o1___1->object_base = __o1___1->next_free;
#line 106
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 106
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 106
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 106
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 106
    __o___8 = & format_obstack;
#line 106
    tmp___14 = strlen((char const   *)(buf___4));
#line 106
    __len___4 = (int )tmp___14;
    }
#line 106
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 106
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 106
    __o___8->next_free += __len___4;
    }
#line 106
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 106
  __o___9 = & format_obstack;
#line 106
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 106
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 106
  tmp___15 = __o___9->next_free;
#line 106
  (__o___9->next_free) ++;
#line 106
  *tmp___15 = (char)0;
  {
#line 106
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 106
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 106
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 106
      __o___10 = & muscle_obstack;
#line 106
      tmp___16 = strlen((char const   *)(buf___5));
#line 106
      __len___5 = (int )tmp___16;
      }
#line 106
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 106
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 106
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 106
      __o___10->next_free += __len___5;
      }
#line 106
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 106
    __o___11 = & muscle_obstack;
#line 106
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 106
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 106
    tmp___17 = __o___11->next_free;
#line 106
    (__o___11->next_free) ++;
#line 106
    *tmp___17 = (char)0;
#line 106
    __o1___2 = & muscle_obstack;
#line 106
    __value___2 = (void *)__o1___2->object_base;
#line 106
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 106
      __o1___2->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___18 = __o1___2->object_base;
    } else {
#line 106
      tmp___18 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___19 = __o1___2->object_base;
    } else {
#line 106
      tmp___19 = (char *)0;
    }
#line 106
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 106
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 106
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 106
    __o1___2->object_base = __o1___2->next_free;
#line 106
    __o1___3 = & format_obstack;
#line 106
    __value___3 = (void *)__o1___3->object_base;
#line 106
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 106
      __o1___3->maybe_empty_object = 1U;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___20 = __o1___3->object_base;
    } else {
#line 106
      tmp___20 = (char *)0;
    }
#line 106
    if (sizeof(int ) < sizeof(void *)) {
#line 106
      tmp___21 = __o1___3->object_base;
    } else {
#line 106
      tmp___21 = (char *)0;
    }
#line 106
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 106
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 106
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 106
    __o1___3->object_base = __o1___3->next_free;
#line 106
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 106
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 107 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_item_number_table(char const   *name , item_number *table_data ,
                                            item_number first , int begin , int end ) 
{ 
  item_number min ;
  item_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 107
  min = first;
#line 107
  max = first;
#line 107
  j = 1;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 107
    __o = & format_obstack;
#line 107
    tmp = strlen((char const   *)(buf___0));
#line 107
    __len = (int )tmp;
    }
#line 107
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 107
    __o->next_free += __len;
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = begin;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < end)) {
#line 107
      goto while_break___0;
    }
#line 107
    __o___0 = & format_obstack;
#line 107
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 107
    tmp___0 = __o___0->next_free;
#line 107
    (__o___0->next_free) ++;
#line 107
    *tmp___0 = (char )',';
#line 107
    if (j >= 10) {
      {
#line 107
      __o___1 = & format_obstack;
#line 107
      tmp___1 = strlen("\n  ");
#line 107
      __len___0 = (int )tmp___1;
      }
#line 107
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 107
      __o___1->next_free += __len___0;
#line 107
      j = 1;
      }
    } else {
#line 107
      j ++;
    }
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 107
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 107
      __o___2 = & format_obstack;
#line 107
      tmp___2 = strlen((char const   *)(buf___1));
#line 107
      __len___1 = (int )tmp___2;
      }
#line 107
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 107
      __o___2->next_free += __len___1;
      }
#line 107
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 107
    if (*(table_data + i) < min) {
#line 107
      min = *(table_data + i);
    }
#line 107
    if (max < *(table_data + i)) {
#line 107
      max = *(table_data + i);
    }
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  __o___3 = & format_obstack;
#line 107
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 107
  tmp___3 = __o___3->next_free;
#line 107
  (__o___3->next_free) ++;
#line 107
  *tmp___3 = (char)0;
#line 107
  __o1 = & format_obstack;
#line 107
  __value = (void *)__o1->object_base;
#line 107
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 107
    __o1->maybe_empty_object = 1U;
  }
#line 107
  if (sizeof(int ) < sizeof(void *)) {
#line 107
    tmp___4 = __o1->object_base;
  } else {
#line 107
    tmp___4 = (char *)0;
  }
#line 107
  if (sizeof(int ) < sizeof(void *)) {
#line 107
    tmp___5 = __o1->object_base;
  } else {
#line 107
    tmp___5 = (char *)0;
  }
#line 107
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 107
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 107
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 107
  __o1->object_base = __o1->next_free;
#line 107
  muscle_insert(name, (char const   *)__value);
#line 107
  lmin = (long )min;
#line 107
  lmax = (long )max;
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 107
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 107
    __o___4 = & format_obstack;
#line 107
    tmp___6 = strlen((char const   *)(buf___2));
#line 107
    __len___2 = (int )tmp___6;
    }
#line 107
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 107
    __o___4->next_free += __len___2;
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 107
  __o___5 = & format_obstack;
#line 107
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 107
  tmp___7 = __o___5->next_free;
#line 107
  (__o___5->next_free) ++;
#line 107
  *tmp___7 = (char)0;
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 107
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 107
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 107
      __o___6 = & muscle_obstack;
#line 107
      tmp___8 = strlen((char const   *)(buf___3));
#line 107
      __len___3 = (int )tmp___8;
      }
#line 107
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 107
      __o___6->next_free += __len___3;
      }
#line 107
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 107
    __o___7 = & muscle_obstack;
#line 107
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 107
    tmp___9 = __o___7->next_free;
#line 107
    (__o___7->next_free) ++;
#line 107
    *tmp___9 = (char)0;
#line 107
    __o1___0 = & muscle_obstack;
#line 107
    __value___0 = (void *)__o1___0->object_base;
#line 107
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 107
      __o1___0->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___10 = __o1___0->object_base;
    } else {
#line 107
      tmp___10 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___11 = __o1___0->object_base;
    } else {
#line 107
      tmp___11 = (char *)0;
    }
#line 107
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 107
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 107
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 107
    __o1___0->object_base = __o1___0->next_free;
#line 107
    __o1___1 = & format_obstack;
#line 107
    __value___1 = (void *)__o1___1->object_base;
#line 107
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 107
      __o1___1->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___12 = __o1___1->object_base;
    } else {
#line 107
      tmp___12 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___13 = __o1___1->object_base;
    } else {
#line 107
      tmp___13 = (char *)0;
    }
#line 107
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 107
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 107
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 107
    __o1___1->object_base = __o1___1->next_free;
#line 107
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 107
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 107
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 107
    __o___8 = & format_obstack;
#line 107
    tmp___14 = strlen((char const   *)(buf___4));
#line 107
    __len___4 = (int )tmp___14;
    }
#line 107
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 107
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 107
    __o___8->next_free += __len___4;
    }
#line 107
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 107
  __o___9 = & format_obstack;
#line 107
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 107
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 107
  tmp___15 = __o___9->next_free;
#line 107
  (__o___9->next_free) ++;
#line 107
  *tmp___15 = (char)0;
  {
#line 107
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 107
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 107
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 107
      __o___10 = & muscle_obstack;
#line 107
      tmp___16 = strlen((char const   *)(buf___5));
#line 107
      __len___5 = (int )tmp___16;
      }
#line 107
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 107
      __o___10->next_free += __len___5;
      }
#line 107
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 107
    __o___11 = & muscle_obstack;
#line 107
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 107
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 107
    tmp___17 = __o___11->next_free;
#line 107
    (__o___11->next_free) ++;
#line 107
    *tmp___17 = (char)0;
#line 107
    __o1___2 = & muscle_obstack;
#line 107
    __value___2 = (void *)__o1___2->object_base;
#line 107
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 107
      __o1___2->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___18 = __o1___2->object_base;
    } else {
#line 107
      tmp___18 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___19 = __o1___2->object_base;
    } else {
#line 107
      tmp___19 = (char *)0;
    }
#line 107
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 107
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 107
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 107
    __o1___2->object_base = __o1___2->next_free;
#line 107
    __o1___3 = & format_obstack;
#line 107
    __value___3 = (void *)__o1___3->object_base;
#line 107
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 107
      __o1___3->maybe_empty_object = 1U;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___20 = __o1___3->object_base;
    } else {
#line 107
      tmp___20 = (char *)0;
    }
#line 107
    if (sizeof(int ) < sizeof(void *)) {
#line 107
      tmp___21 = __o1___3->object_base;
    } else {
#line 107
      tmp___21 = (char *)0;
    }
#line 107
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 107
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 107
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 107
    __o1___3->object_base = __o1___3->next_free;
#line 107
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 107
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void muscle_insert_state_number_table(char const   *name , state_number *table_data ,
                                             state_number first , int begin , int end ) 
{ 
  state_number min ;
  state_number max ;
  long lmin ;
  long lmax ;
  int i ;
  int j ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___1 ;
  char buf___1[4096] ;
  struct obstack *__o___2 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___2[4096] ;
  struct obstack *__o___4 ;
  int __len___2 ;
  size_t tmp___6 ;
  struct obstack *__o___5 ;
  char *tmp___7 ;
  char buf___3[4096] ;
  struct obstack *__o___6 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___7 ;
  char *tmp___9 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___4[4096] ;
  struct obstack *__o___8 ;
  int __len___4 ;
  size_t tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  char buf___5[4096] ;
  struct obstack *__o___10 ;
  int __len___5 ;
  size_t tmp___16 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___18 ;
  char *tmp___19 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 108
  min = first;
#line 108
  max = first;
#line 108
  j = 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%6d",
            first);
#line 108
    __o = & format_obstack;
#line 108
    tmp = strlen((char const   *)(buf___0));
#line 108
    __len = (int )tmp;
    }
#line 108
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 108
    __o->next_free += __len;
    }
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  i = begin;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i < end)) {
#line 108
      goto while_break___0;
    }
#line 108
    __o___0 = & format_obstack;
#line 108
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 108
    tmp___0 = __o___0->next_free;
#line 108
    (__o___0->next_free) ++;
#line 108
    *tmp___0 = (char )',';
#line 108
    if (j >= 10) {
      {
#line 108
      __o___1 = & format_obstack;
#line 108
      tmp___1 = strlen("\n  ");
#line 108
      __len___0 = (int )tmp___1;
      }
#line 108
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"\n  ",
             (size_t )__len___0);
#line 108
      __o___1->next_free += __len___0;
#line 108
      j = 1;
      }
    } else {
#line 108
      j ++;
    }
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 108
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%6d",
              *(table_data + i));
#line 108
      __o___2 = & format_obstack;
#line 108
      tmp___2 = strlen((char const   *)(buf___1));
#line 108
      __len___1 = (int )tmp___2;
      }
#line 108
      if ((unsigned long )(__o___2->next_free + __len___1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___2, __len___1);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___1);
#line 108
      __o___2->next_free += __len___1;
      }
#line 108
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 108
    if (*(table_data + i) < min) {
#line 108
      min = *(table_data + i);
    }
#line 108
    if (max < *(table_data + i)) {
#line 108
      max = *(table_data + i);
    }
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  __o___3 = & format_obstack;
#line 108
  if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___3, 1);
    }
  }
#line 108
  tmp___3 = __o___3->next_free;
#line 108
  (__o___3->next_free) ++;
#line 108
  *tmp___3 = (char)0;
#line 108
  __o1 = & format_obstack;
#line 108
  __value = (void *)__o1->object_base;
#line 108
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 108
    __o1->maybe_empty_object = 1U;
  }
#line 108
  if (sizeof(int ) < sizeof(void *)) {
#line 108
    tmp___4 = __o1->object_base;
  } else {
#line 108
    tmp___4 = (char *)0;
  }
#line 108
  if (sizeof(int ) < sizeof(void *)) {
#line 108
    tmp___5 = __o1->object_base;
  } else {
#line 108
    tmp___5 = (char *)0;
  }
#line 108
  __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 108
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 108
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 108
  __o1->object_base = __o1->next_free;
#line 108
  muscle_insert(name, (char const   *)__value);
#line 108
  lmin = (long )min;
#line 108
  lmax = (long )max;
  }
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 108
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s_min",
            name);
#line 108
    __o___4 = & format_obstack;
#line 108
    tmp___6 = strlen((char const   *)(buf___2));
#line 108
    __len___2 = (int )tmp___6;
    }
#line 108
    if ((unsigned long )(__o___4->next_free + __len___2) > (unsigned long )__o___4->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___4, __len___2);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___2),
           (size_t )__len___2);
#line 108
    __o___4->next_free += __len___2;
    }
#line 108
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 108
  __o___5 = & format_obstack;
#line 108
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 108
  tmp___7 = __o___5->next_free;
#line 108
  (__o___5->next_free) ++;
#line 108
  *tmp___7 = (char)0;
  {
#line 108
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 108
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 108
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%ld",
              lmin);
#line 108
      __o___6 = & muscle_obstack;
#line 108
      tmp___8 = strlen((char const   *)(buf___3));
#line 108
      __len___3 = (int )tmp___8;
      }
#line 108
      if ((unsigned long )(__o___6->next_free + __len___3) > (unsigned long )__o___6->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___6, __len___3);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___3);
#line 108
      __o___6->next_free += __len___3;
      }
#line 108
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 108
    __o___7 = & muscle_obstack;
#line 108
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 108
    tmp___9 = __o___7->next_free;
#line 108
    (__o___7->next_free) ++;
#line 108
    *tmp___9 = (char)0;
#line 108
    __o1___0 = & muscle_obstack;
#line 108
    __value___0 = (void *)__o1___0->object_base;
#line 108
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 108
      __o1___0->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___10 = __o1___0->object_base;
    } else {
#line 108
      tmp___10 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___11 = __o1___0->object_base;
    } else {
#line 108
      tmp___11 = (char *)0;
    }
#line 108
    __o1___0->next_free = tmp___10 + (((__o1___0->next_free - tmp___11) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 108
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 108
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 108
    __o1___0->object_base = __o1___0->next_free;
#line 108
    __o1___1 = & format_obstack;
#line 108
    __value___1 = (void *)__o1___1->object_base;
#line 108
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 108
      __o1___1->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___12 = __o1___1->object_base;
    } else {
#line 108
      tmp___12 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___13 = __o1___1->object_base;
    } else {
#line 108
      tmp___13 = (char *)0;
    }
#line 108
    __o1___1->next_free = tmp___12 + (((__o1___1->next_free - tmp___13) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 108
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 108
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 108
    __o1___1->object_base = __o1___1->next_free;
#line 108
    muscle_insert((char const   *)__value___1, (char const   *)__value___0);
    }
#line 108
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 108
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%s_max",
            name);
#line 108
    __o___8 = & format_obstack;
#line 108
    tmp___14 = strlen((char const   *)(buf___4));
#line 108
    __len___4 = (int )tmp___14;
    }
#line 108
    if ((unsigned long )(__o___8->next_free + __len___4) > (unsigned long )__o___8->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___8, __len___4);
      }
    }
    {
#line 108
    memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___4),
           (size_t )__len___4);
#line 108
    __o___8->next_free += __len___4;
    }
#line 108
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 108
  __o___9 = & format_obstack;
#line 108
  if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
    {
#line 108
    _obstack_newchunk(__o___9, 1);
    }
  }
#line 108
  tmp___15 = __o___9->next_free;
#line 108
  (__o___9->next_free) ++;
#line 108
  *tmp___15 = (char)0;
  {
#line 108
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 108
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 108
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%ld",
              lmax);
#line 108
      __o___10 = & muscle_obstack;
#line 108
      tmp___16 = strlen((char const   *)(buf___5));
#line 108
      __len___5 = (int )tmp___16;
      }
#line 108
      if ((unsigned long )(__o___10->next_free + __len___5) > (unsigned long )__o___10->chunk_limit) {
        {
#line 108
        _obstack_newchunk(__o___10, __len___5);
        }
      }
      {
#line 108
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___5);
#line 108
      __o___10->next_free += __len___5;
      }
#line 108
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 108
    __o___11 = & muscle_obstack;
#line 108
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 108
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 108
    tmp___17 = __o___11->next_free;
#line 108
    (__o___11->next_free) ++;
#line 108
    *tmp___17 = (char)0;
#line 108
    __o1___2 = & muscle_obstack;
#line 108
    __value___2 = (void *)__o1___2->object_base;
#line 108
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 108
      __o1___2->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___18 = __o1___2->object_base;
    } else {
#line 108
      tmp___18 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___19 = __o1___2->object_base;
    } else {
#line 108
      tmp___19 = (char *)0;
    }
#line 108
    __o1___2->next_free = tmp___18 + (((__o1___2->next_free - tmp___19) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 108
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 108
      __o1___2->next_free = __o1___2->chunk_limit;
    }
#line 108
    __o1___2->object_base = __o1___2->next_free;
#line 108
    __o1___3 = & format_obstack;
#line 108
    __value___3 = (void *)__o1___3->object_base;
#line 108
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 108
      __o1___3->maybe_empty_object = 1U;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___20 = __o1___3->object_base;
    } else {
#line 108
      tmp___20 = (char *)0;
    }
#line 108
    if (sizeof(int ) < sizeof(void *)) {
#line 108
      tmp___21 = __o1___3->object_base;
    } else {
#line 108
      tmp___21 = (char *)0;
    }
#line 108
    __o1___3->next_free = tmp___20 + (((__o1___3->next_free - tmp___21) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 108
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 108
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 108
    __o1___3->object_base = __o1___3->next_free;
#line 108
    muscle_insert((char const   *)__value___3, (char const   *)__value___2);
    }
#line 108
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 115 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void escaped_output(FILE *out , char const   *string ) 
{ 
  char const   *p ;
  char *tmp ;

  {
  {
#line 119
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"[[");
#line 121
  tmp = quotearg_style((enum quoting_style )3, string);
#line 121
  p = (char const   *)tmp;
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! *p) {
#line 121
      goto while_break;
    }
    {
#line 124
    if ((int const   )*p == 36) {
#line 124
      goto case_36;
    }
#line 125
    if ((int const   )*p == 64) {
#line 125
      goto case_64;
    }
#line 126
    if ((int const   )*p == 91) {
#line 126
      goto case_91;
    }
#line 127
    if ((int const   )*p == 93) {
#line 127
      goto case_93;
    }
#line 128
    goto switch_default;
    case_36: /* CIL Label */ 
    {
#line 124
    fputs_unlocked((char const   */* __restrict  */)"$][", (FILE */* __restrict  */)out);
    }
#line 124
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 125
    fputs_unlocked((char const   */* __restrict  */)"@@", (FILE */* __restrict  */)out);
    }
#line 125
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 126
    fputs_unlocked((char const   */* __restrict  */)"@{", (FILE */* __restrict  */)out);
    }
#line 126
    goto switch_break;
    case_93: /* CIL Label */ 
    {
#line 127
    fputs_unlocked((char const   */* __restrict  */)"@}", (FILE */* __restrict  */)out);
    }
#line 127
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 128
    fputc_unlocked((int )*p, out);
    }
#line 128
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 121
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"]]");
  }
#line 132
  return;
}
}
#line 140 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void prepare_symbols(void) 
{ 
  int v ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___3 ;
  struct obstack *__o___2 ;
  char *tmp___4 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char buf___3[4096] ;
  struct obstack *__o___5 ;
  int __len___2 ;
  size_t tmp___11 ;
  struct obstack *__o___6 ;
  char *tmp___12 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char buf___4[4096] ;
  struct obstack *__o___7 ;
  int __len___3 ;
  size_t tmp___15 ;
  struct obstack *__o___8 ;
  char *tmp___16 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int i ;
  int j ;
  struct quoting_options *qo ;
  struct quoting_options *tmp___19 ;
  char *cp ;
  char *tmp___20 ;
  int width ;
  size_t tmp___21 ;
  struct obstack *__o___9 ;
  int __len___4 ;
  size_t tmp___22 ;
  struct obstack *__o___10 ;
  char *tmp___23 ;
  char const   *p ;
  struct obstack *__o___11 ;
  int __len___5 ;
  size_t tmp___24 ;
  struct obstack *__o___12 ;
  int __len___6 ;
  size_t tmp___25 ;
  struct obstack *__o___13 ;
  int __len___7 ;
  size_t tmp___26 ;
  struct obstack *__o___14 ;
  int __len___8 ;
  size_t tmp___27 ;
  struct obstack *__o___15 ;
  char *tmp___28 ;
  struct obstack *__o___16 ;
  char *tmp___29 ;
  struct obstack *__o___17 ;
  int __len___9 ;
  size_t tmp___30 ;
  struct obstack *__o___18 ;
  char *tmp___31 ;
  struct obstack *__o1___4 ;
  void *__value___4 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int i___0 ;
  int *values ;
  void *tmp___34 ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    v = (int )token_table_flag;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 143
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 143
        sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
                v);
#line 143
        __o = & muscle_obstack;
#line 143
        tmp = strlen((char const   *)(buf___0));
#line 143
        __len = (int )tmp;
        }
#line 143
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 143
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 143
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
               (size_t )__len);
#line 143
        __o->next_free += __len;
        }
#line 143
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 143
      __o___0 = & muscle_obstack;
#line 143
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 143
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 143
      tmp___0 = __o___0->next_free;
#line 143
      (__o___0->next_free) ++;
#line 143
      *tmp___0 = (char)0;
#line 143
      __o1 = & muscle_obstack;
#line 143
      __value = (void *)__o1->object_base;
#line 143
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 143
        __o1->maybe_empty_object = 1U;
      }
#line 143
      if (sizeof(int ) < sizeof(void *)) {
#line 143
        tmp___1 = __o1->object_base;
      } else {
#line 143
        tmp___1 = (char *)0;
      }
#line 143
      if (sizeof(int ) < sizeof(void *)) {
#line 143
        tmp___2 = __o1->object_base;
      } else {
#line 143
        tmp___2 = (char *)0;
      }
#line 143
      __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 143
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 143
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 143
      __o1->object_base = __o1->next_free;
#line 143
      muscle_insert("token_table", (char const   *)__value);
      }
#line 143
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 144
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 144
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
              ntokens);
#line 144
      __o___1 = & muscle_obstack;
#line 144
      tmp___3 = strlen((char const   *)(buf___1));
#line 144
      __len___0 = (int )tmp___3;
      }
#line 144
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 144
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 144
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 144
      __o___1->next_free += __len___0;
      }
#line 144
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 144
    __o___2 = & muscle_obstack;
#line 144
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 144
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 144
    tmp___4 = __o___2->next_free;
#line 144
    (__o___2->next_free) ++;
#line 144
    *tmp___4 = (char)0;
#line 144
    __o1___0 = & muscle_obstack;
#line 144
    __value___0 = (void *)__o1___0->object_base;
#line 144
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 144
      __o1___0->maybe_empty_object = 1U;
    }
#line 144
    if (sizeof(int ) < sizeof(void *)) {
#line 144
      tmp___5 = __o1___0->object_base;
    } else {
#line 144
      tmp___5 = (char *)0;
    }
#line 144
    if (sizeof(int ) < sizeof(void *)) {
#line 144
      tmp___6 = __o1___0->object_base;
    } else {
#line 144
      tmp___6 = (char *)0;
    }
#line 144
    __o1___0->next_free = tmp___5 + (((__o1___0->next_free - tmp___6) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 144
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 144
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 144
    __o1___0->object_base = __o1___0->next_free;
#line 144
    muscle_insert("tokens_number", (char const   *)__value___0);
    }
#line 144
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 145
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 145
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 145
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d",
              nvars);
#line 145
      __o___3 = & muscle_obstack;
#line 145
      tmp___7 = strlen((char const   *)(buf___2));
#line 145
      __len___1 = (int )tmp___7;
      }
#line 145
      if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 145
        _obstack_newchunk(__o___3, __len___1);
        }
      }
      {
#line 145
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 145
      __o___3->next_free += __len___1;
      }
#line 145
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 145
    __o___4 = & muscle_obstack;
#line 145
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 145
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 145
    tmp___8 = __o___4->next_free;
#line 145
    (__o___4->next_free) ++;
#line 145
    *tmp___8 = (char)0;
#line 145
    __o1___1 = & muscle_obstack;
#line 145
    __value___1 = (void *)__o1___1->object_base;
#line 145
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 145
      __o1___1->maybe_empty_object = 1U;
    }
#line 145
    if (sizeof(int ) < sizeof(void *)) {
#line 145
      tmp___9 = __o1___1->object_base;
    } else {
#line 145
      tmp___9 = (char *)0;
    }
#line 145
    if (sizeof(int ) < sizeof(void *)) {
#line 145
      tmp___10 = __o1___1->object_base;
    } else {
#line 145
      tmp___10 = (char *)0;
    }
#line 145
    __o1___1->next_free = tmp___9 + (((__o1___1->next_free - tmp___10) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 145
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 145
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 145
    __o1___1->object_base = __o1___1->next_free;
#line 145
    muscle_insert("nterms_number", (char const   *)__value___1);
    }
#line 145
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 146
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 146
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 146
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%d",
              undeftoken->number);
#line 146
      __o___5 = & muscle_obstack;
#line 146
      tmp___11 = strlen((char const   *)(buf___3));
#line 146
      __len___2 = (int )tmp___11;
      }
#line 146
      if ((unsigned long )(__o___5->next_free + __len___2) > (unsigned long )__o___5->chunk_limit) {
        {
#line 146
        _obstack_newchunk(__o___5, __len___2);
        }
      }
      {
#line 146
      memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___2);
#line 146
      __o___5->next_free += __len___2;
      }
#line 146
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 146
    __o___6 = & muscle_obstack;
#line 146
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 146
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 146
    tmp___12 = __o___6->next_free;
#line 146
    (__o___6->next_free) ++;
#line 146
    *tmp___12 = (char)0;
#line 146
    __o1___2 = & muscle_obstack;
#line 146
    __value___2 = (void *)__o1___2->object_base;
#line 146
    if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 146
      __o1___2->maybe_empty_object = 1U;
    }
#line 146
    if (sizeof(int ) < sizeof(void *)) {
#line 146
      tmp___13 = __o1___2->object_base;
    } else {
#line 146
      tmp___13 = (char *)0;
    }
#line 146
    if (sizeof(int ) < sizeof(void *)) {
#line 146
      tmp___14 = __o1___2->object_base;
    } else {
#line 146
      tmp___14 = (char *)0;
    }
#line 146
    __o1___2->next_free = tmp___13 + (((__o1___2->next_free - tmp___14) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 146
    if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 146
      __o1___2->next_free = __o1___2->chunk_limit;
    }
    {
#line 146
    __o1___2->object_base = __o1___2->next_free;
#line 146
    muscle_insert("undef_token_number", (char const   *)__value___2);
    }
#line 146
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 147
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 147
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 147
      sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%d",
              max_user_token_number);
#line 147
      __o___7 = & muscle_obstack;
#line 147
      tmp___15 = strlen((char const   *)(buf___4));
#line 147
      __len___3 = (int )tmp___15;
      }
#line 147
      if ((unsigned long )(__o___7->next_free + __len___3) > (unsigned long )__o___7->chunk_limit) {
        {
#line 147
        _obstack_newchunk(__o___7, __len___3);
        }
      }
      {
#line 147
      memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___4),
             (size_t )__len___3);
#line 147
      __o___7->next_free += __len___3;
      }
#line 147
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 147
    __o___8 = & muscle_obstack;
#line 147
    if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
      {
#line 147
      _obstack_newchunk(__o___8, 1);
      }
    }
#line 147
    tmp___16 = __o___8->next_free;
#line 147
    (__o___8->next_free) ++;
#line 147
    *tmp___16 = (char)0;
#line 147
    __o1___3 = & muscle_obstack;
#line 147
    __value___3 = (void *)__o1___3->object_base;
#line 147
    if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 147
      __o1___3->maybe_empty_object = 1U;
    }
#line 147
    if (sizeof(int ) < sizeof(void *)) {
#line 147
      tmp___17 = __o1___3->object_base;
    } else {
#line 147
      tmp___17 = (char *)0;
    }
#line 147
    if (sizeof(int ) < sizeof(void *)) {
#line 147
      tmp___18 = __o1___3->object_base;
    } else {
#line 147
      tmp___18 = (char *)0;
    }
#line 147
    __o1___3->next_free = tmp___17 + (((__o1___3->next_free - tmp___18) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 147
    if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 147
      __o1___3->next_free = __o1___3->chunk_limit;
    }
    {
#line 147
    __o1___3->object_base = __o1___3->next_free;
#line 147
    muscle_insert("user_token_number_max", (char const   *)__value___3);
    }
#line 147
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 149
  muscle_insert_symbol_number_table("translate", token_translations, *(token_translations + 0),
                                    1, max_user_token_number + 1);
#line 158
  j = 2;
#line 159
  tmp___19 = clone_quoting_options((struct quoting_options *)0);
#line 159
  qo = tmp___19;
#line 160
  set_quoting_style(qo, (enum quoting_style )3);
#line 161
  set_quoting_flags(qo, 4);
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 162
    if (! (i < nsyms)) {
#line 162
      goto while_break___10;
    }
    {
#line 164
    tmp___20 = quotearg_alloc((*(symbols + i))->tag, (size_t )-1, (struct quoting_options  const  *)qo);
#line 164
    cp = tmp___20;
#line 167
    tmp___21 = strlen((char const   *)cp);
#line 167
    width = (int )(tmp___21 + 2U);
    }
#line 169
    if (j + width > 75) {
      {
#line 171
      __o___9 = & format_obstack;
#line 171
      tmp___22 = strlen("\n ");
#line 171
      __len___4 = (int )tmp___22;
      }
#line 171
      if ((unsigned long )(__o___9->next_free + __len___4) > (unsigned long )__o___9->chunk_limit) {
        {
#line 171
        _obstack_newchunk(__o___9, __len___4);
        }
      }
      {
#line 171
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)"\n ",
             (size_t )__len___4);
#line 171
      __o___9->next_free += __len___4;
#line 172
      j = 1;
      }
    }
#line 175
    if (i) {
#line 176
      __o___10 = & format_obstack;
#line 176
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 176
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 176
      tmp___23 = __o___10->next_free;
#line 176
      (__o___10->next_free) ++;
#line 176
      *tmp___23 = (char )' ';
    }
    {
#line 177
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 177
      p = (char const   *)cp;
      {
#line 177
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 177
        if (! *p) {
#line 177
          goto while_break___12;
        }
        {
#line 177
        if ((int const   )*p == 36) {
#line 177
          goto case_36;
        }
#line 177
        if ((int const   )*p == 64) {
#line 177
          goto case_64;
        }
#line 177
        if ((int const   )*p == 91) {
#line 177
          goto case_91;
        }
#line 177
        if ((int const   )*p == 93) {
#line 177
          goto case_93;
        }
#line 177
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 177
        __o___11 = & format_obstack;
#line 177
        tmp___24 = strlen("$][");
#line 177
        __len___5 = (int )tmp___24;
        }
#line 177
        if ((unsigned long )(__o___11->next_free + __len___5) > (unsigned long )__o___11->chunk_limit) {
          {
#line 177
          _obstack_newchunk(__o___11, __len___5);
          }
        }
        {
#line 177
        memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___5);
#line 177
        __o___11->next_free += __len___5;
        }
#line 177
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 177
        __o___12 = & format_obstack;
#line 177
        tmp___25 = strlen("@@");
#line 177
        __len___6 = (int )tmp___25;
        }
#line 177
        if ((unsigned long )(__o___12->next_free + __len___6) > (unsigned long )__o___12->chunk_limit) {
          {
#line 177
          _obstack_newchunk(__o___12, __len___6);
          }
        }
        {
#line 177
        memcpy((void */* __restrict  */)__o___12->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___6);
#line 177
        __o___12->next_free += __len___6;
        }
#line 177
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 177
        __o___13 = & format_obstack;
#line 177
        tmp___26 = strlen("@{");
#line 177
        __len___7 = (int )tmp___26;
        }
#line 177
        if ((unsigned long )(__o___13->next_free + __len___7) > (unsigned long )__o___13->chunk_limit) {
          {
#line 177
          _obstack_newchunk(__o___13, __len___7);
          }
        }
        {
#line 177
        memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___7);
#line 177
        __o___13->next_free += __len___7;
        }
#line 177
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 177
        __o___14 = & format_obstack;
#line 177
        tmp___27 = strlen("@}");
#line 177
        __len___8 = (int )tmp___27;
        }
#line 177
        if ((unsigned long )(__o___14->next_free + __len___8) > (unsigned long )__o___14->chunk_limit) {
          {
#line 177
          _obstack_newchunk(__o___14, __len___8);
          }
        }
        {
#line 177
        memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___8);
#line 177
        __o___14->next_free += __len___8;
        }
#line 177
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 177
        __o___15 = & format_obstack;
#line 177
        if ((unsigned long )(__o___15->next_free + 1) > (unsigned long )__o___15->chunk_limit) {
          {
#line 177
          _obstack_newchunk(__o___15, 1);
          }
        }
#line 177
        tmp___28 = __o___15->next_free;
#line 177
        (__o___15->next_free) ++;
#line 177
        *tmp___28 = (char )*p;
#line 177
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 177
        p ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 177
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 178
    free((void *)cp);
#line 179
    __o___16 = & format_obstack;
    }
#line 179
    if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
      {
#line 179
      _obstack_newchunk(__o___16, 1);
      }
    }
#line 179
    tmp___29 = __o___16->next_free;
#line 179
    (__o___16->next_free) ++;
#line 179
    *tmp___29 = (char )',';
#line 180
    j += width;
#line 162
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 182
  free((void *)qo);
#line 183
  __o___17 = & format_obstack;
#line 183
  tmp___30 = strlen(" ]b4_null[");
#line 183
  __len___9 = (int )tmp___30;
  }
#line 183
  if ((unsigned long )(__o___17->next_free + __len___9) > (unsigned long )__o___17->chunk_limit) {
    {
#line 183
    _obstack_newchunk(__o___17, __len___9);
    }
  }
  {
#line 183
  memcpy((void */* __restrict  */)__o___17->next_free, (void const   */* __restrict  */)" ]b4_null[",
         (size_t )__len___9);
#line 183
  __o___17->next_free += __len___9;
#line 186
  __o___18 = & format_obstack;
  }
#line 186
  if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
    {
#line 186
    _obstack_newchunk(__o___18, 1);
    }
  }
#line 186
  tmp___31 = __o___18->next_free;
#line 186
  (__o___18->next_free) ++;
#line 186
  *tmp___31 = (char)0;
#line 187
  __o1___4 = & format_obstack;
#line 187
  __value___4 = (void *)__o1___4->object_base;
#line 187
  if ((unsigned long )__o1___4->next_free == (unsigned long )__value___4) {
#line 187
    __o1___4->maybe_empty_object = 1U;
  }
#line 187
  if (sizeof(int ) < sizeof(void *)) {
#line 187
    tmp___32 = __o1___4->object_base;
  } else {
#line 187
    tmp___32 = (char *)0;
  }
#line 187
  if (sizeof(int ) < sizeof(void *)) {
#line 187
    tmp___33 = __o1___4->object_base;
  } else {
#line 187
    tmp___33 = (char *)0;
  }
#line 187
  __o1___4->next_free = tmp___32 + (((__o1___4->next_free - tmp___33) + (long )__o1___4->alignment_mask) & (long )(~ __o1___4->alignment_mask));
#line 187
  if (__o1___4->next_free - (char *)__o1___4->chunk > __o1___4->chunk_limit - (char *)__o1___4->chunk) {
#line 187
    __o1___4->next_free = __o1___4->chunk_limit;
  }
  {
#line 187
  __o1___4->object_base = __o1___4->next_free;
#line 187
  muscle_insert("tname", (char const   *)__value___4);
#line 193
  tmp___34 = xnmalloc((size_t )ntokens, (size_t )sizeof(*values));
#line 193
  values = (int *)tmp___34;
#line 194
  i___0 = 0;
  }
  {
#line 194
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 194
    if (! (i___0 < ntokens)) {
#line 194
      goto while_break___13;
    }
#line 195
    *(values + i___0) = (*(symbols + i___0))->user_token_number;
#line 194
    i___0 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 196
  muscle_insert_int_table("toknum", values, *(values + 0), 1, ntokens);
#line 198
  free((void *)values);
  }
#line 200
  return;
}
}
#line 208 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void prepare_rules(void) 
{ 
  rule_number r ;
  unsigned int i ;
  item_number *rhs ;
  void *tmp ;
  unsigned int *prhs ;
  void *tmp___0 ;
  unsigned int *rline ;
  void *tmp___1 ;
  symbol_number *r1 ;
  void *tmp___2 ;
  unsigned int *r2 ;
  void *tmp___3 ;
  int *dprec ;
  void *tmp___4 ;
  int *merger ;
  void *tmp___5 ;
  item_number *rhsp ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___8 ;
  struct obstack *__o___0 ;
  char *tmp___9 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___10 ;
  char *tmp___11 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___12 ;
  struct obstack *__o___2 ;
  char *tmp___13 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 212
  i = 0U;
#line 213
  tmp = xnmalloc(nritems, (size_t )sizeof(*rhs));
#line 213
  rhs = (item_number *)tmp;
#line 214
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*prhs));
#line 214
  prhs = (unsigned int *)tmp___0;
#line 215
  tmp___1 = xnmalloc((size_t )nrules, (size_t )sizeof(*rline));
#line 215
  rline = (unsigned int *)tmp___1;
#line 216
  tmp___2 = xnmalloc((size_t )nrules, (size_t )sizeof(*r1));
#line 216
  r1 = (symbol_number *)tmp___2;
#line 217
  tmp___3 = xnmalloc((size_t )nrules, (size_t )sizeof(*r2));
#line 217
  r2 = (unsigned int *)tmp___3;
#line 218
  tmp___4 = xnmalloc((size_t )nrules, (size_t )sizeof(*dprec));
#line 218
  dprec = (int *)tmp___4;
#line 219
  tmp___5 = xnmalloc((size_t )nrules, (size_t )sizeof(*merger));
#line 219
  merger = (int *)tmp___5;
#line 221
  r = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (r < nrules)) {
#line 221
      goto while_break;
    }
#line 223
    rhsp = (item_number *)((void *)0);
#line 225
    *(prhs + r) = i;
#line 227
    rhsp = (rules + r)->rhs;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (*rhsp >= 0)) {
#line 227
        goto while_break___0;
      }
#line 228
      tmp___6 = i;
#line 228
      i ++;
#line 228
      *(rhs + tmp___6) = *rhsp;
#line 227
      rhsp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    *(r1 + r) = ((rules + r)->lhs)->number;
#line 232
    *(r2 + r) = i - *(prhs + r);
#line 234
    tmp___7 = i;
#line 234
    i ++;
#line 234
    *(rhs + tmp___7) = -1;
#line 236
    *(rline + r) = (unsigned int )(rules + r)->location.start.line;
#line 238
    *(dprec + r) = (rules + r)->dprec;
#line 240
    *(merger + r) = (rules + r)->merger;
#line 221
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  aver((_Bool )(i == nritems));
#line 244
  muscle_insert_item_number_table("rhs", rhs, *(ritem + 0), 1, (int )nritems);
#line 245
  muscle_insert_unsigned_int_table("prhs", prhs, 0U, 0, nrules);
#line 246
  muscle_insert_unsigned_int_table("rline", rline, 0U, 0, nrules);
#line 247
  muscle_insert_symbol_number_table("r1", r1, 0, 0, nrules);
#line 248
  muscle_insert_unsigned_int_table("r2", r2, 0U, 0, nrules);
#line 249
  muscle_insert_int_table("dprec", dprec, 0, 0, nrules);
#line 250
  muscle_insert_int_table("merger", merger, 0, 0, nrules);
  }
  {
#line 252
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 252
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 252
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              nrules);
#line 252
      __o = & muscle_obstack;
#line 252
      tmp___8 = strlen((char const   *)(buf___0));
#line 252
      __len = (int )tmp___8;
      }
#line 252
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 252
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 252
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 252
      __o->next_free += __len;
      }
#line 252
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 252
    __o___0 = & muscle_obstack;
#line 252
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 252
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 252
    tmp___9 = __o___0->next_free;
#line 252
    (__o___0->next_free) ++;
#line 252
    *tmp___9 = (char)0;
#line 252
    __o1 = & muscle_obstack;
#line 252
    __value = (void *)__o1->object_base;
#line 252
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 252
      __o1->maybe_empty_object = 1U;
    }
#line 252
    if (sizeof(int ) < sizeof(void *)) {
#line 252
      tmp___10 = __o1->object_base;
    } else {
#line 252
      tmp___10 = (char *)0;
    }
#line 252
    if (sizeof(int ) < sizeof(void *)) {
#line 252
      tmp___11 = __o1->object_base;
    } else {
#line 252
      tmp___11 = (char *)0;
    }
#line 252
    __o1->next_free = tmp___10 + (((__o1->next_free - tmp___11) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 252
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 252
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 252
    __o1->object_base = __o1->next_free;
#line 252
    muscle_insert("rules_number", (char const   *)__value);
    }
#line 252
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 253
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 253
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 253
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
              max_left_semantic_context);
#line 253
      __o___1 = & muscle_obstack;
#line 253
      tmp___12 = strlen((char const   *)(buf___1));
#line 253
      __len___0 = (int )tmp___12;
      }
#line 253
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 253
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 253
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 253
      __o___1->next_free += __len___0;
      }
#line 253
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 253
    __o___2 = & muscle_obstack;
#line 253
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 253
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 253
    tmp___13 = __o___2->next_free;
#line 253
    (__o___2->next_free) ++;
#line 253
    *tmp___13 = (char)0;
#line 253
    __o1___0 = & muscle_obstack;
#line 253
    __value___0 = (void *)__o1___0->object_base;
#line 253
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 253
      __o1___0->maybe_empty_object = 1U;
    }
#line 253
    if (sizeof(int ) < sizeof(void *)) {
#line 253
      tmp___14 = __o1___0->object_base;
    } else {
#line 253
      tmp___14 = (char *)0;
    }
#line 253
    if (sizeof(int ) < sizeof(void *)) {
#line 253
      tmp___15 = __o1___0->object_base;
    } else {
#line 253
      tmp___15 = (char *)0;
    }
#line 253
    __o1___0->next_free = tmp___14 + (((__o1___0->next_free - tmp___15) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 253
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 253
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 253
    __o1___0->object_base = __o1___0->next_free;
#line 253
    muscle_insert("max_left_semantic_context", (char const   *)__value___0);
    }
#line 253
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 255
  free((void *)rhs);
#line 256
  free((void *)prhs);
#line 257
  free((void *)rline);
#line 258
  free((void *)r1);
#line 259
  free((void *)r2);
#line 260
  free((void *)dprec);
#line 261
  free((void *)merger);
  }
#line 262
  return;
}
}
#line 268 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void prepare_states(void) 
{ 
  state_number i ;
  symbol_number *values ;
  void *tmp ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  char *tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___4 ;
  struct obstack *__o___2 ;
  char *tmp___5 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___8 ;
  struct obstack *__o___4 ;
  char *tmp___9 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 272
  tmp = xnmalloc((size_t )nstates, (size_t )sizeof(*values));
#line 272
  values = (symbol_number *)tmp;
#line 273
  i = 0;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < nstates)) {
#line 273
      goto while_break;
    }
#line 274
    *(values + i) = (*(states + i))->accessing_symbol;
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  muscle_insert_symbol_number_table("stos", values, 0, 1, nstates);
#line 277
  free((void *)values);
  }
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 279
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 279
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              high);
#line 279
      __o = & muscle_obstack;
#line 279
      tmp___0 = strlen((char const   *)(buf___0));
#line 279
      __len = (int )tmp___0;
      }
#line 279
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 279
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 279
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 279
      __o->next_free += __len;
      }
#line 279
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 279
    __o___0 = & muscle_obstack;
#line 279
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 279
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 279
    tmp___1 = __o___0->next_free;
#line 279
    (__o___0->next_free) ++;
#line 279
    *tmp___1 = (char)0;
#line 279
    __o1 = & muscle_obstack;
#line 279
    __value = (void *)__o1->object_base;
#line 279
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 279
      __o1->maybe_empty_object = 1U;
    }
#line 279
    if (sizeof(int ) < sizeof(void *)) {
#line 279
      tmp___2 = __o1->object_base;
    } else {
#line 279
      tmp___2 = (char *)0;
    }
#line 279
    if (sizeof(int ) < sizeof(void *)) {
#line 279
      tmp___3 = __o1->object_base;
    } else {
#line 279
      tmp___3 = (char *)0;
    }
#line 279
    __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 279
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 279
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 279
    __o1->object_base = __o1->next_free;
#line 279
    muscle_insert("last", (char const   *)__value);
    }
#line 279
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 280
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 280
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
              final_state->number);
#line 280
      __o___1 = & muscle_obstack;
#line 280
      tmp___4 = strlen((char const   *)(buf___1));
#line 280
      __len___0 = (int )tmp___4;
      }
#line 280
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 280
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 280
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 280
      __o___1->next_free += __len___0;
      }
#line 280
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 280
    __o___2 = & muscle_obstack;
#line 280
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 280
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 280
    tmp___5 = __o___2->next_free;
#line 280
    (__o___2->next_free) ++;
#line 280
    *tmp___5 = (char)0;
#line 280
    __o1___0 = & muscle_obstack;
#line 280
    __value___0 = (void *)__o1___0->object_base;
#line 280
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 280
      __o1___0->maybe_empty_object = 1U;
    }
#line 280
    if (sizeof(int ) < sizeof(void *)) {
#line 280
      tmp___6 = __o1___0->object_base;
    } else {
#line 280
      tmp___6 = (char *)0;
    }
#line 280
    if (sizeof(int ) < sizeof(void *)) {
#line 280
      tmp___7 = __o1___0->object_base;
    } else {
#line 280
      tmp___7 = (char *)0;
    }
#line 280
    __o1___0->next_free = tmp___6 + (((__o1___0->next_free - tmp___7) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 280
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 280
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 280
    __o1___0->object_base = __o1___0->next_free;
#line 280
    muscle_insert("final_state_number", (char const   *)__value___0);
    }
#line 280
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 281
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 281
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 281
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d",
              nstates);
#line 281
      __o___3 = & muscle_obstack;
#line 281
      tmp___8 = strlen((char const   *)(buf___2));
#line 281
      __len___1 = (int )tmp___8;
      }
#line 281
      if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 281
        _obstack_newchunk(__o___3, __len___1);
        }
      }
      {
#line 281
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 281
      __o___3->next_free += __len___1;
      }
#line 281
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 281
    __o___4 = & muscle_obstack;
#line 281
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 281
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 281
    tmp___9 = __o___4->next_free;
#line 281
    (__o___4->next_free) ++;
#line 281
    *tmp___9 = (char)0;
#line 281
    __o1___1 = & muscle_obstack;
#line 281
    __value___1 = (void *)__o1___1->object_base;
#line 281
    if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 281
      __o1___1->maybe_empty_object = 1U;
    }
#line 281
    if (sizeof(int ) < sizeof(void *)) {
#line 281
      tmp___10 = __o1___1->object_base;
    } else {
#line 281
      tmp___10 = (char *)0;
    }
#line 281
    if (sizeof(int ) < sizeof(void *)) {
#line 281
      tmp___11 = __o1___1->object_base;
    } else {
#line 281
      tmp___11 = (char *)0;
    }
#line 281
    __o1___1->next_free = tmp___10 + (((__o1___1->next_free - tmp___11) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 281
    if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 281
      __o1___1->next_free = __o1___1->chunk_limit;
    }
    {
#line 281
    __o1___1->object_base = __o1___1->next_free;
#line 281
    muscle_insert("states_number", (char const   *)__value___1);
    }
#line 281
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 282
  return;
}
}
#line 290 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void user_actions_output(FILE *out ) 
{ 
  rule_number r ;

  {
  {
#line 295
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_actions], \n[", (FILE */* __restrict  */)out);
#line 296
  r = 0;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (r < nrules)) {
#line 296
      goto while_break;
    }
#line 297
    if ((rules + r)->action) {
      {
#line 299
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"b4_case(%d, [b4_syncline(%d, ",
              r + 1, (rules + r)->action_location.start.line);
#line 301
      escaped_output(out, (rules + r)->action_location.start.file);
#line 302
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)")\n[    %s]])\n\n",
              (rules + r)->action);
      }
    }
#line 296
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 305
  return;
}
}
#line 311 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void merger_output(FILE *out ) 
{ 
  int n ;
  merger_list *p ;

  {
  {
#line 317
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_mergers], \n[[",
                 (FILE */* __restrict  */)out);
#line 318
  n = 1;
#line 318
  p = merge_functions;
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 318
      goto while_break;
    }
#line 320
    if ((int const   )*(p->type + 0) == 0) {
      {
#line 321
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  case %d: *yy0 = %s (*yy0, *yy1); break;\n",
              n, p->name);
      }
    } else {
      {
#line 324
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  case %d: yy0->%s = %s (*yy0, *yy1); break;\n",
              n, p->type, p->name);
      }
    }
#line 318
    n ++;
#line 318
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  fputs_unlocked((char const   */* __restrict  */)"]])\n\n", (FILE */* __restrict  */)out);
  }
#line 328
  return;
}
}
#line 334 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void token_definitions_output(FILE *out ) 
{ 
  int i ;
  char const   *sep ;
  symbol *sym ;
  int number ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 338
  sep = "";
#line 340
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_tokens], \n[", (FILE */* __restrict  */)out);
#line 341
  i = 0;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < ntokens)) {
#line 341
      goto while_break;
    }
    {
#line 343
    sym = *(symbols + i);
#line 344
    number = sym->user_token_number;
#line 349
    aver((_Bool )(number != -9991));
    }
#line 352
    if ((unsigned long )sym == (unsigned long )errtoken) {
#line 353
      goto __Cont;
    }
#line 357
    if (sym->alias) {
#line 358
      sym = sym->alias;
    }
#line 363
    if ((int const   )*(sym->tag + 0) == 39) {
#line 364
      goto __Cont;
    } else
#line 363
    if ((int const   )*(sym->tag + 0) == 34) {
#line 364
      goto __Cont;
    }
    {
#line 368
    tmp = strchr(sym->tag, '.');
    }
#line 368
    if (tmp) {
#line 369
      goto __Cont;
    } else {
      {
#line 368
      tmp___0 = strchr(sym->tag, '$');
      }
#line 368
      if (tmp___0) {
#line 369
        goto __Cont;
      }
    }
    {
#line 371
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s[[[%s]], %d]",
            sep, sym->tag, number);
#line 373
    sep = ",\n";
    }
    __Cont: /* CIL Label */ 
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 376
  return;
}
}
#line 383 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void symbol_code_props_output(FILE *out , char const   *what , code_props const   *(*get)(symbol const   * ) ) 
{ 
  int i ;
  char const   *sep ;
  symbol *sym ;
  char const   *code ;
  code_props const   *tmp ;
  location loc___0 ;
  code_props const   *tmp___0 ;

  {
  {
#line 388
  sep = "";
#line 390
  fputs_unlocked((char const   */* __restrict  */)"m4_define([b4_symbol_", (FILE */* __restrict  */)out);
#line 391
  fputs_unlocked((char const   */* __restrict  */)what, (FILE */* __restrict  */)out);
#line 392
  fputs_unlocked((char const   */* __restrict  */)"], \n[", (FILE */* __restrict  */)out);
#line 393
  i = 0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < nsyms)) {
#line 393
      goto while_break;
    }
    {
#line 395
    sym = *(symbols + i);
#line 396
    tmp = (*get)((symbol const   *)sym);
#line 396
    code = (char const   *)tmp->code;
    }
#line 397
    if (code) {
      {
#line 399
      tmp___0 = (*get)((symbol const   *)sym);
#line 399
      loc___0 = tmp___0->location;
#line 403
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s[",
              sep);
#line 404
      sep = ",\n";
#line 405
      escaped_output(out, loc___0.start.file);
#line 406
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)", %d, ",
              loc___0.start.line);
#line 407
      escaped_output(out, sym->tag);
#line 408
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)", %d, [[%s]]",
              sym->number, code);
      }
#line 409
      if (sym->type_name) {
        {
#line 410
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)", [[%s]]",
                sym->type_name);
        }
      }
      {
#line 411
      fputc_unlocked(']', out);
      }
    }
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  fputs_unlocked((char const   */* __restrict  */)"])\n\n", (FILE */* __restrict  */)out);
  }
#line 415
  return;
}
}
#line 418 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void prepare_actions(void) 
{ 
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___3 ;
  struct obstack *__o___2 ;
  char *tmp___4 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 424
  muscle_insert_rule_number_table("defact", yydefact, *(yydefact + 0), 1, nstates);
#line 430
  muscle_insert_state_number_table("defgoto", yydefgoto, *(yydefgoto + 0), 1, nsyms - ntokens);
#line 435
  muscle_insert_base_table("pact", base, *(base + 0), 1, nstates);
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 437
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              base_ninf);
#line 437
      __o = & muscle_obstack;
#line 437
      tmp = strlen((char const   *)(buf___0));
#line 437
      __len = (int )tmp;
      }
#line 437
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 437
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 437
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 437
      __o->next_free += __len;
      }
#line 437
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    __o___0 = & muscle_obstack;
#line 437
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 437
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 437
    tmp___0 = __o___0->next_free;
#line 437
    (__o___0->next_free) ++;
#line 437
    *tmp___0 = (char)0;
#line 437
    __o1 = & muscle_obstack;
#line 437
    __value = (void *)__o1->object_base;
#line 437
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 437
      __o1->maybe_empty_object = 1U;
    }
#line 437
    if (sizeof(int ) < sizeof(void *)) {
#line 437
      tmp___1 = __o1->object_base;
    } else {
#line 437
      tmp___1 = (char *)0;
    }
#line 437
    if (sizeof(int ) < sizeof(void *)) {
#line 437
      tmp___2 = __o1->object_base;
    } else {
#line 437
      tmp___2 = (char *)0;
    }
#line 437
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 437
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 437
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 437
    __o1->object_base = __o1->next_free;
#line 437
    muscle_insert("pact_ninf", (char const   *)__value);
    }
#line 437
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  muscle_insert_base_table("pgoto", base, *(base + nstates), nstates + 1, nvectors);
#line 443
  muscle_insert_base_table("table", table, *(table + 0), 1, high + 1);
  }
  {
#line 445
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 445
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 445
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
              table_ninf);
#line 445
      __o___1 = & muscle_obstack;
#line 445
      tmp___3 = strlen((char const   *)(buf___1));
#line 445
      __len___0 = (int )tmp___3;
      }
#line 445
      if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
        {
#line 445
        _obstack_newchunk(__o___1, __len___0);
        }
      }
      {
#line 445
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 445
      __o___1->next_free += __len___0;
      }
#line 445
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 445
    __o___2 = & muscle_obstack;
#line 445
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 445
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 445
    tmp___4 = __o___2->next_free;
#line 445
    (__o___2->next_free) ++;
#line 445
    *tmp___4 = (char)0;
#line 445
    __o1___0 = & muscle_obstack;
#line 445
    __value___0 = (void *)__o1___0->object_base;
#line 445
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 445
      __o1___0->maybe_empty_object = 1U;
    }
#line 445
    if (sizeof(int ) < sizeof(void *)) {
#line 445
      tmp___5 = __o1___0->object_base;
    } else {
#line 445
      tmp___5 = (char *)0;
    }
#line 445
    if (sizeof(int ) < sizeof(void *)) {
#line 445
      tmp___6 = __o1___0->object_base;
    } else {
#line 445
      tmp___6 = (char *)0;
    }
#line 445
    __o1___0->next_free = tmp___5 + (((__o1___0->next_free - tmp___6) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 445
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 445
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 445
    __o1___0->object_base = __o1___0->next_free;
#line 445
    muscle_insert("table_ninf", (char const   *)__value___0);
    }
#line 445
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 447
  muscle_insert_base_table("check", check, *(check + 0), 1, high + 1);
#line 459
  muscle_insert_unsigned_int_table("conflict_list_heads", conflict_table, *(conflict_table + 0),
                                   1, high + 1);
#line 461
  muscle_insert_unsigned_int_table("conflicting_rules", conflict_list, 0U, 1, conflict_list_cnt);
  }
#line 463
  return;
}
}
#line 470 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void output_skeleton(void) 
{ 
  FILE *in ;
  FILE *out ;
  int filter_fd[2] ;
  char const   *argv[9] ;
  pid_t pid ;
  char m4sugar[19] ;
  char m4bison[9] ;
  char *full_m4sugar ;
  char *full_m4bison ;
  char *full_skeleton ;
  char const   *p ;
  char const   *m4 ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *pkgdatadir ;
  char const   *tmp___2 ;
  size_t skeleton_size ;
  size_t tmp___3 ;
  size_t pkgdatadirlen ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  FILE *tmp___8 ;
  int i ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 480
  m4sugar[0] = (char )'m';
#line 480
  m4sugar[1] = (char )'4';
#line 480
  m4sugar[2] = (char )'s';
#line 480
  m4sugar[3] = (char )'u';
#line 480
  m4sugar[4] = (char )'g';
#line 480
  m4sugar[5] = (char )'a';
#line 480
  m4sugar[6] = (char )'r';
#line 480
  m4sugar[7] = (char )'/';
#line 480
  m4sugar[8] = (char )'m';
#line 480
  m4sugar[9] = (char )'4';
#line 480
  m4sugar[10] = (char )'s';
#line 480
  m4sugar[11] = (char )'u';
#line 480
  m4sugar[12] = (char )'g';
#line 480
  m4sugar[13] = (char )'a';
#line 480
  m4sugar[14] = (char )'r';
#line 480
  m4sugar[15] = (char )'.';
#line 480
  m4sugar[16] = (char )'m';
#line 480
  m4sugar[17] = (char )'4';
#line 480
  m4sugar[18] = (char )'\000';
#line 481
  m4bison[0] = (char )'b';
#line 481
  m4bison[1] = (char )'i';
#line 481
  m4bison[2] = (char )'s';
#line 481
  m4bison[3] = (char )'o';
#line 481
  m4bison[4] = (char )'n';
#line 481
  m4bison[5] = (char )'.';
#line 481
  m4bison[6] = (char )'m';
#line 481
  m4bison[7] = (char )'4';
#line 481
  m4bison[8] = (char )'\000';
#line 486
  tmp___1 = getenv("M4");
#line 486
  p = (char const   *)tmp___1;
  }
#line 486
  if (p) {
#line 486
    tmp___0 = p;
  } else {
#line 486
    tmp___0 = "/usr/bin/m4";
  }
  {
#line 486
  m4 = tmp___0;
#line 487
  tmp___2 = compute_pkgdatadir();
#line 487
  pkgdatadir = tmp___2;
#line 488
  tmp___3 = strlen(skeleton);
#line 488
  skeleton_size = tmp___3 + 1U;
#line 489
  tmp___4 = strlen(pkgdatadir);
#line 489
  pkgdatadirlen = tmp___4;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (pkgdatadirlen) {
#line 490
      if (! ((int const   )*(pkgdatadir + (pkgdatadirlen - 1U)) == 47)) {
#line 490
        goto while_break;
      }
    } else {
#line 490
      goto while_break;
    }
#line 491
    pkgdatadirlen --;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if ((unsigned long )skeleton_size < sizeof(m4sugar)) {
#line 492
    tmp___5 = sizeof(m4sugar);
  } else {
#line 492
    tmp___5 = (unsigned long )skeleton_size;
  }
  {
#line 492
  tmp___6 = xmalloc((size_t )((unsigned long )(pkgdatadirlen + 1U) + tmp___5));
#line 492
  full_skeleton = (char *)tmp___6;
#line 495
  strncpy((char */* __restrict  */)full_skeleton, (char const   */* __restrict  */)pkgdatadir,
          pkgdatadirlen);
#line 496
  *(full_skeleton + pkgdatadirlen) = (char )'/';
#line 497
  strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)(m4sugar));
#line 498
  full_m4sugar = xstrdup((char const   *)full_skeleton);
#line 499
  strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)(m4bison));
#line 500
  full_m4bison = xstrdup((char const   *)full_skeleton);
#line 501
  tmp___7 = strchr(skeleton, '/');
  }
#line 501
  if (tmp___7) {
    {
#line 502
    strcpy((char */* __restrict  */)full_skeleton, (char const   */* __restrict  */)skeleton);
    }
  } else {
    {
#line 504
    strcpy((char */* __restrict  */)((full_skeleton + pkgdatadirlen) + 1), (char const   */* __restrict  */)skeleton);
    }
  }
  {
#line 509
  tmp___8 = xfopen((char const   *)full_m4sugar, "r");
#line 509
  xfclose(tmp___8);
  }
#line 513
  if (trace_flag & 32) {
    {
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"running: %s %s - %s %s\n",
            m4, full_m4sugar, full_m4bison, full_skeleton);
    }
  }
#line 525
  i = 0;
#line 526
  tmp___9 = i;
#line 526
  i ++;
#line 526
  argv[tmp___9] = m4;
#line 527
  tmp___10 = i;
#line 527
  i ++;
#line 527
  argv[tmp___10] = "-I";
#line 528
  tmp___11 = i;
#line 528
  i ++;
#line 528
  argv[tmp___11] = pkgdatadir;
#line 529
  if (trace_flag & 1024) {
#line 530
    tmp___12 = i;
#line 530
    i ++;
#line 530
    argv[tmp___12] = "-dV";
  }
  {
#line 531
  tmp___13 = i;
#line 531
  i ++;
#line 531
  argv[tmp___13] = (char const   *)full_m4sugar;
#line 532
  tmp___14 = i;
#line 532
  i ++;
#line 532
  argv[tmp___14] = "-";
#line 533
  tmp___15 = i;
#line 533
  i ++;
#line 533
  argv[tmp___15] = (char const   *)full_m4bison;
#line 534
  tmp___16 = i;
#line 534
  i ++;
#line 534
  argv[tmp___16] = (char const   *)full_skeleton;
#line 535
  tmp___17 = i;
#line 535
  i ++;
#line 535
  argv[tmp___17] = (char const   *)((void *)0);
#line 555
  unsetenv("POSIXLY_CORRECT");
#line 556
  init_subpipe();
#line 557
  pid = create_subpipe((char const   * const  *)(argv), (int *)(filter_fd));
#line 558
  free((void *)full_m4sugar);
#line 559
  free((void *)full_m4bison);
#line 560
  free((void *)full_skeleton);
#line 562
  out = fdopen(filter_fd[0], "w");
  }
#line 563
  if (! out) {
    {
#line 564
    tmp___18 = get_errno();
#line 564
    error(1, tmp___18, "fdopen");
    }
  }
  {
#line 568
  fputs_unlocked((char const   */* __restrict  */)"m4_init()\n", (FILE */* __restrict  */)out);
#line 570
  user_actions_output(out);
#line 571
  merger_output(out);
#line 572
  token_definitions_output(out);
#line 573
  symbol_code_props_output(out, "destructors", & symbol_destructor_get);
#line 574
  symbol_code_props_output(out, "printers", & symbol_printer_get);
#line 576
  muscles_m4_output(out);
#line 577
  xfclose(out);
#line 580
  timevar_push((timevar_id_t )14);
#line 581
  end_of_output_subpipe(pid, (int *)(filter_fd));
#line 582
  in = fdopen(filter_fd[1], "r");
  }
#line 583
  if (! in) {
    {
#line 584
    tmp___19 = get_errno();
#line 584
    error(1, tmp___19, "fdopen");
    }
  }
  {
#line 586
  scan_skel(in);
#line 587
  xfclose(in);
#line 588
  reap_subpipe(pid, m4);
#line 589
  timevar_pop((timevar_id_t )14);
  }
#line 590
  return;
}
}
#line 592 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
static void prepare(void) 
{ 
  char const   *use_push_for_pull_env ;
  char *tmp ;
  _Bool use_push_for_pull_flag ;
  int tmp___0 ;
  int v ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  int v___0 ;
  char buf___1[4096] ;
  struct obstack *__o___1 ;
  int __len___0 ;
  size_t tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int v___1 ;
  char buf___2[4096] ;
  struct obstack *__o___3 ;
  int __len___1 ;
  size_t tmp___9 ;
  struct obstack *__o___4 ;
  char *tmp___10 ;
  struct obstack *__o1___1 ;
  void *__value___1 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int v___2 ;
  char buf___3[4096] ;
  struct obstack *__o___5 ;
  int __len___2 ;
  size_t tmp___13 ;
  struct obstack *__o___6 ;
  char *tmp___14 ;
  struct obstack *__o1___2 ;
  void *__value___2 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int v___3 ;
  char buf___4[4096] ;
  struct obstack *__o___7 ;
  int __len___3 ;
  size_t tmp___17 ;
  struct obstack *__o___8 ;
  char *tmp___18 ;
  struct obstack *__o1___3 ;
  void *__value___3 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int v___4 ;
  char buf___5[4096] ;
  struct obstack *__o___9 ;
  int __len___4 ;
  size_t tmp___21 ;
  struct obstack *__o___10 ;
  char *tmp___22 ;
  struct obstack *__o1___4 ;
  void *__value___4 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int v___5 ;
  char buf___6[4096] ;
  struct obstack *__o___11 ;
  int __len___5 ;
  size_t tmp___25 ;
  struct obstack *__o___12 ;
  char *tmp___26 ;
  struct obstack *__o1___5 ;
  void *__value___5 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int v___6 ;
  char buf___7[4096] ;
  struct obstack *__o___13 ;
  int __len___6 ;
  size_t tmp___29 ;
  struct obstack *__o___14 ;
  char *tmp___30 ;
  struct obstack *__o1___6 ;
  void *__value___6 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int v___7 ;
  char buf___8[4096] ;
  struct obstack *__o___15 ;
  int __len___7 ;
  size_t tmp___33 ;
  struct obstack *__o___16 ;
  char *tmp___34 ;
  struct obstack *__o1___7 ;
  void *__value___7 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int v___8 ;
  char buf___9[4096] ;
  struct obstack *__o___17 ;
  int __len___8 ;
  size_t tmp___37 ;
  struct obstack *__o___18 ;
  char *tmp___38 ;
  struct obstack *__o1___8 ;
  void *__value___8 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char const   *p ;
  struct obstack *__o___19 ;
  int __len___9 ;
  size_t tmp___41 ;
  struct obstack *__o___20 ;
  int __len___10 ;
  size_t tmp___42 ;
  struct obstack *__o___21 ;
  int __len___11 ;
  size_t tmp___43 ;
  struct obstack *__o___22 ;
  int __len___12 ;
  size_t tmp___44 ;
  struct obstack *__o___23 ;
  char *tmp___45 ;
  struct obstack *__o___24 ;
  char *tmp___46 ;
  struct obstack *__o1___9 ;
  void *__value___9 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char const   *p___0 ;
  struct obstack *__o___25 ;
  int __len___13 ;
  size_t tmp___49 ;
  struct obstack *__o___26 ;
  int __len___14 ;
  size_t tmp___50 ;
  struct obstack *__o___27 ;
  int __len___15 ;
  size_t tmp___51 ;
  struct obstack *__o___28 ;
  int __len___16 ;
  size_t tmp___52 ;
  struct obstack *__o___29 ;
  char *tmp___53 ;
  struct obstack *__o___30 ;
  char *tmp___54 ;
  struct obstack *__o1___10 ;
  void *__value___10 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char const   *p___1 ;
  struct obstack *__o___31 ;
  int __len___17 ;
  size_t tmp___57 ;
  struct obstack *__o___32 ;
  int __len___18 ;
  size_t tmp___58 ;
  struct obstack *__o___33 ;
  int __len___19 ;
  size_t tmp___59 ;
  struct obstack *__o___34 ;
  int __len___20 ;
  size_t tmp___60 ;
  struct obstack *__o___35 ;
  char *tmp___61 ;
  struct obstack *__o___36 ;
  char *tmp___62 ;
  struct obstack *__o1___11 ;
  void *__value___11 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char const   *p___2 ;
  struct obstack *__o___37 ;
  int __len___21 ;
  size_t tmp___65 ;
  struct obstack *__o___38 ;
  int __len___22 ;
  size_t tmp___66 ;
  struct obstack *__o___39 ;
  int __len___23 ;
  size_t tmp___67 ;
  struct obstack *__o___40 ;
  int __len___24 ;
  size_t tmp___68 ;
  struct obstack *__o___41 ;
  char *tmp___69 ;
  struct obstack *__o___42 ;
  char *tmp___70 ;
  struct obstack *__o1___12 ;
  void *__value___12 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char const   *p___3 ;
  struct obstack *__o___43 ;
  int __len___25 ;
  size_t tmp___73 ;
  struct obstack *__o___44 ;
  int __len___26 ;
  size_t tmp___74 ;
  struct obstack *__o___45 ;
  int __len___27 ;
  size_t tmp___75 ;
  struct obstack *__o___46 ;
  int __len___28 ;
  size_t tmp___76 ;
  struct obstack *__o___47 ;
  char *tmp___77 ;
  struct obstack *__o___48 ;
  char *tmp___78 ;
  struct obstack *__o1___13 ;
  void *__value___13 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char const   *p___4 ;
  struct obstack *__o___49 ;
  int __len___29 ;
  size_t tmp___81 ;
  struct obstack *__o___50 ;
  int __len___30 ;
  size_t tmp___82 ;
  struct obstack *__o___51 ;
  int __len___31 ;
  size_t tmp___83 ;
  struct obstack *__o___52 ;
  int __len___32 ;
  size_t tmp___84 ;
  struct obstack *__o___53 ;
  char *tmp___85 ;
  struct obstack *__o___54 ;
  char *tmp___86 ;
  struct obstack *__o1___14 ;
  void *__value___14 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char const   *p___5 ;
  struct obstack *__o___55 ;
  int __len___33 ;
  size_t tmp___89 ;
  struct obstack *__o___56 ;
  int __len___34 ;
  size_t tmp___90 ;
  struct obstack *__o___57 ;
  int __len___35 ;
  size_t tmp___91 ;
  struct obstack *__o___58 ;
  int __len___36 ;
  size_t tmp___92 ;
  struct obstack *__o___59 ;
  char *tmp___93 ;
  struct obstack *__o___60 ;
  char *tmp___94 ;
  struct obstack *__o1___15 ;
  void *__value___15 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char const   *p___6 ;
  struct obstack *__o___61 ;
  int __len___37 ;
  size_t tmp___97 ;
  struct obstack *__o___62 ;
  int __len___38 ;
  size_t tmp___98 ;
  struct obstack *__o___63 ;
  int __len___39 ;
  size_t tmp___99 ;
  struct obstack *__o___64 ;
  int __len___40 ;
  size_t tmp___100 ;
  struct obstack *__o___65 ;
  char *tmp___101 ;
  struct obstack *__o___66 ;
  char *tmp___102 ;
  struct obstack *__o1___16 ;
  void *__value___16 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char const   *p___7 ;
  struct obstack *__o___67 ;
  int __len___41 ;
  size_t tmp___105 ;
  struct obstack *__o___68 ;
  int __len___42 ;
  size_t tmp___106 ;
  struct obstack *__o___69 ;
  int __len___43 ;
  size_t tmp___107 ;
  struct obstack *__o___70 ;
  int __len___44 ;
  size_t tmp___108 ;
  struct obstack *__o___71 ;
  char *tmp___109 ;
  struct obstack *__o___72 ;
  char *tmp___110 ;
  struct obstack *__o1___17 ;
  void *__value___17 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char const   *p___8 ;
  struct obstack *__o___73 ;
  int __len___45 ;
  size_t tmp___113 ;
  struct obstack *__o___74 ;
  int __len___46 ;
  size_t tmp___114 ;
  struct obstack *__o___75 ;
  int __len___47 ;
  size_t tmp___115 ;
  struct obstack *__o___76 ;
  int __len___48 ;
  size_t tmp___116 ;
  struct obstack *__o___77 ;
  char *tmp___117 ;
  struct obstack *__o___78 ;
  char *tmp___118 ;
  struct obstack *__o1___18 ;
  void *__value___18 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char const   *p___9 ;
  char *tmp___121 ;
  struct obstack *__o___79 ;
  int __len___49 ;
  size_t tmp___122 ;
  struct obstack *__o___80 ;
  int __len___50 ;
  size_t tmp___123 ;
  struct obstack *__o___81 ;
  int __len___51 ;
  size_t tmp___124 ;
  struct obstack *__o___82 ;
  int __len___52 ;
  size_t tmp___125 ;
  struct obstack *__o___83 ;
  char *tmp___126 ;
  struct obstack *__o___84 ;
  char *tmp___127 ;
  struct obstack *__o1___19 ;
  void *__value___19 ;
  char *tmp___128 ;
  char *tmp___129 ;
  struct obstack *__o___85 ;
  int __len___53 ;
  char const   *tmp___130 ;
  size_t tmp___131 ;
  char const   *tmp___132 ;
  struct obstack *__o___86 ;
  char *tmp___133 ;
  struct obstack *__o1___20 ;
  void *__value___20 ;
  char *tmp___134 ;
  char *tmp___135 ;

  {
  {
#line 597
  tmp = getenv("BISON_USE_PUSH_FOR_PULL");
#line 597
  use_push_for_pull_env = (char const   *)tmp;
#line 598
  use_push_for_pull_flag = (_Bool)0;
  }
#line 599
  if ((unsigned long )use_push_for_pull_env != (unsigned long )((void *)0)) {
#line 599
    if ((int const   )*(use_push_for_pull_env + 0) != 0) {
      {
#line 599
      tmp___0 = strcmp(use_push_for_pull_env, "0");
      }
#line 599
      if (0 != tmp___0) {
#line 602
        use_push_for_pull_flag = (_Bool)1;
      }
    }
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    v = (int )debug_flag;
    {
#line 605
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 605
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 605
        sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
                v);
#line 605
        __o = & muscle_obstack;
#line 605
        tmp___1 = strlen((char const   *)(buf___0));
#line 605
        __len = (int )tmp___1;
        }
#line 605
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 605
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 605
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
               (size_t )__len);
#line 605
        __o->next_free += __len;
        }
#line 605
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 605
      __o___0 = & muscle_obstack;
#line 605
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 605
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 605
      tmp___2 = __o___0->next_free;
#line 605
      (__o___0->next_free) ++;
#line 605
      *tmp___2 = (char)0;
#line 605
      __o1 = & muscle_obstack;
#line 605
      __value = (void *)__o1->object_base;
#line 605
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 605
        __o1->maybe_empty_object = 1U;
      }
#line 605
      if (sizeof(int ) < sizeof(void *)) {
#line 605
        tmp___3 = __o1->object_base;
      } else {
#line 605
        tmp___3 = (char *)0;
      }
#line 605
      if (sizeof(int ) < sizeof(void *)) {
#line 605
        tmp___4 = __o1->object_base;
      } else {
#line 605
        tmp___4 = (char *)0;
      }
#line 605
      __o1->next_free = tmp___3 + (((__o1->next_free - tmp___4) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 605
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 605
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 605
      __o1->object_base = __o1->next_free;
#line 605
      muscle_insert("debug_flag", (char const   *)__value);
      }
#line 605
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 605
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 606
    v___0 = (int )defines_flag;
    {
#line 606
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 606
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 606
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
                v___0);
#line 606
        __o___1 = & muscle_obstack;
#line 606
        tmp___5 = strlen((char const   *)(buf___1));
#line 606
        __len___0 = (int )tmp___5;
        }
#line 606
        if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
          {
#line 606
          _obstack_newchunk(__o___1, __len___0);
          }
        }
        {
#line 606
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___1),
               (size_t )__len___0);
#line 606
        __o___1->next_free += __len___0;
        }
#line 606
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 606
      __o___2 = & muscle_obstack;
#line 606
      if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
        {
#line 606
        _obstack_newchunk(__o___2, 1);
        }
      }
#line 606
      tmp___6 = __o___2->next_free;
#line 606
      (__o___2->next_free) ++;
#line 606
      *tmp___6 = (char)0;
#line 606
      __o1___0 = & muscle_obstack;
#line 606
      __value___0 = (void *)__o1___0->object_base;
#line 606
      if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 606
        __o1___0->maybe_empty_object = 1U;
      }
#line 606
      if (sizeof(int ) < sizeof(void *)) {
#line 606
        tmp___7 = __o1___0->object_base;
      } else {
#line 606
        tmp___7 = (char *)0;
      }
#line 606
      if (sizeof(int ) < sizeof(void *)) {
#line 606
        tmp___8 = __o1___0->object_base;
      } else {
#line 606
        tmp___8 = (char *)0;
      }
#line 606
      __o1___0->next_free = tmp___7 + (((__o1___0->next_free - tmp___8) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 606
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 606
        __o1___0->next_free = __o1___0->chunk_limit;
      }
      {
#line 606
      __o1___0->object_base = __o1___0->next_free;
#line 606
      muscle_insert("defines_flag", (char const   *)__value___0);
      }
#line 606
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 606
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 607
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 607
    v___1 = (int )error_verbose;
    {
#line 607
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 607
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 607
        sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d",
                v___1);
#line 607
        __o___3 = & muscle_obstack;
#line 607
        tmp___9 = strlen((char const   *)(buf___2));
#line 607
        __len___1 = (int )tmp___9;
        }
#line 607
        if ((unsigned long )(__o___3->next_free + __len___1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 607
          _obstack_newchunk(__o___3, __len___1);
          }
        }
        {
#line 607
        memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___2),
               (size_t )__len___1);
#line 607
        __o___3->next_free += __len___1;
        }
#line 607
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 607
      __o___4 = & muscle_obstack;
#line 607
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 607
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 607
      tmp___10 = __o___4->next_free;
#line 607
      (__o___4->next_free) ++;
#line 607
      *tmp___10 = (char)0;
#line 607
      __o1___1 = & muscle_obstack;
#line 607
      __value___1 = (void *)__o1___1->object_base;
#line 607
      if ((unsigned long )__o1___1->next_free == (unsigned long )__value___1) {
#line 607
        __o1___1->maybe_empty_object = 1U;
      }
#line 607
      if (sizeof(int ) < sizeof(void *)) {
#line 607
        tmp___11 = __o1___1->object_base;
      } else {
#line 607
        tmp___11 = (char *)0;
      }
#line 607
      if (sizeof(int ) < sizeof(void *)) {
#line 607
        tmp___12 = __o1___1->object_base;
      } else {
#line 607
        tmp___12 = (char *)0;
      }
#line 607
      __o1___1->next_free = tmp___11 + (((__o1___1->next_free - tmp___12) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 607
      if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 607
        __o1___1->next_free = __o1___1->chunk_limit;
      }
      {
#line 607
      __o1___1->object_base = __o1___1->next_free;
#line 607
      muscle_insert("error_verbose_flag", (char const   *)__value___1);
      }
#line 607
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 607
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 608
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 608
    v___2 = (int )glr_parser;
    {
#line 608
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 608
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 608
        sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"%d",
                v___2);
#line 608
        __o___5 = & muscle_obstack;
#line 608
        tmp___13 = strlen((char const   *)(buf___3));
#line 608
        __len___2 = (int )tmp___13;
        }
#line 608
        if ((unsigned long )(__o___5->next_free + __len___2) > (unsigned long )__o___5->chunk_limit) {
          {
#line 608
          _obstack_newchunk(__o___5, __len___2);
          }
        }
        {
#line 608
        memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___3),
               (size_t )__len___2);
#line 608
        __o___5->next_free += __len___2;
        }
#line 608
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 608
      __o___6 = & muscle_obstack;
#line 608
      if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
        {
#line 608
        _obstack_newchunk(__o___6, 1);
        }
      }
#line 608
      tmp___14 = __o___6->next_free;
#line 608
      (__o___6->next_free) ++;
#line 608
      *tmp___14 = (char)0;
#line 608
      __o1___2 = & muscle_obstack;
#line 608
      __value___2 = (void *)__o1___2->object_base;
#line 608
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___2) {
#line 608
        __o1___2->maybe_empty_object = 1U;
      }
#line 608
      if (sizeof(int ) < sizeof(void *)) {
#line 608
        tmp___15 = __o1___2->object_base;
      } else {
#line 608
        tmp___15 = (char *)0;
      }
#line 608
      if (sizeof(int ) < sizeof(void *)) {
#line 608
        tmp___16 = __o1___2->object_base;
      } else {
#line 608
        tmp___16 = (char *)0;
      }
#line 608
      __o1___2->next_free = tmp___15 + (((__o1___2->next_free - tmp___16) + (long )__o1___2->alignment_mask) & (long )(~ __o1___2->alignment_mask));
#line 608
      if (__o1___2->next_free - (char *)__o1___2->chunk > __o1___2->chunk_limit - (char *)__o1___2->chunk) {
#line 608
        __o1___2->next_free = __o1___2->chunk_limit;
      }
      {
#line 608
      __o1___2->object_base = __o1___2->next_free;
#line 608
      muscle_insert("glr_flag", (char const   *)__value___2);
      }
#line 608
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 608
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 609
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 609
    v___3 = (int )locations_flag;
    {
#line 609
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 609
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 609
        sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%d",
                v___3);
#line 609
        __o___7 = & muscle_obstack;
#line 609
        tmp___17 = strlen((char const   *)(buf___4));
#line 609
        __len___3 = (int )tmp___17;
        }
#line 609
        if ((unsigned long )(__o___7->next_free + __len___3) > (unsigned long )__o___7->chunk_limit) {
          {
#line 609
          _obstack_newchunk(__o___7, __len___3);
          }
        }
        {
#line 609
        memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___4),
               (size_t )__len___3);
#line 609
        __o___7->next_free += __len___3;
        }
#line 609
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 609
      __o___8 = & muscle_obstack;
#line 609
      if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
        {
#line 609
        _obstack_newchunk(__o___8, 1);
        }
      }
#line 609
      tmp___18 = __o___8->next_free;
#line 609
      (__o___8->next_free) ++;
#line 609
      *tmp___18 = (char)0;
#line 609
      __o1___3 = & muscle_obstack;
#line 609
      __value___3 = (void *)__o1___3->object_base;
#line 609
      if ((unsigned long )__o1___3->next_free == (unsigned long )__value___3) {
#line 609
        __o1___3->maybe_empty_object = 1U;
      }
#line 609
      if (sizeof(int ) < sizeof(void *)) {
#line 609
        tmp___19 = __o1___3->object_base;
      } else {
#line 609
        tmp___19 = (char *)0;
      }
#line 609
      if (sizeof(int ) < sizeof(void *)) {
#line 609
        tmp___20 = __o1___3->object_base;
      } else {
#line 609
        tmp___20 = (char *)0;
      }
#line 609
      __o1___3->next_free = tmp___19 + (((__o1___3->next_free - tmp___20) + (long )__o1___3->alignment_mask) & (long )(~ __o1___3->alignment_mask));
#line 609
      if (__o1___3->next_free - (char *)__o1___3->chunk > __o1___3->chunk_limit - (char *)__o1___3->chunk) {
#line 609
        __o1___3->next_free = __o1___3->chunk_limit;
      }
      {
#line 609
      __o1___3->object_base = __o1___3->next_free;
#line 609
      muscle_insert("locations_flag", (char const   *)__value___3);
      }
#line 609
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 609
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 610
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 610
    v___4 = (int )nondeterministic_parser;
    {
#line 610
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 610
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 610
        sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"%d",
                v___4);
#line 610
        __o___9 = & muscle_obstack;
#line 610
        tmp___21 = strlen((char const   *)(buf___5));
#line 610
        __len___4 = (int )tmp___21;
        }
#line 610
        if ((unsigned long )(__o___9->next_free + __len___4) > (unsigned long )__o___9->chunk_limit) {
          {
#line 610
          _obstack_newchunk(__o___9, __len___4);
          }
        }
        {
#line 610
        memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)(buf___5),
               (size_t )__len___4);
#line 610
        __o___9->next_free += __len___4;
        }
#line 610
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 610
      __o___10 = & muscle_obstack;
#line 610
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 610
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 610
      tmp___22 = __o___10->next_free;
#line 610
      (__o___10->next_free) ++;
#line 610
      *tmp___22 = (char)0;
#line 610
      __o1___4 = & muscle_obstack;
#line 610
      __value___4 = (void *)__o1___4->object_base;
#line 610
      if ((unsigned long )__o1___4->next_free == (unsigned long )__value___4) {
#line 610
        __o1___4->maybe_empty_object = 1U;
      }
#line 610
      if (sizeof(int ) < sizeof(void *)) {
#line 610
        tmp___23 = __o1___4->object_base;
      } else {
#line 610
        tmp___23 = (char *)0;
      }
#line 610
      if (sizeof(int ) < sizeof(void *)) {
#line 610
        tmp___24 = __o1___4->object_base;
      } else {
#line 610
        tmp___24 = (char *)0;
      }
#line 610
      __o1___4->next_free = tmp___23 + (((__o1___4->next_free - tmp___24) + (long )__o1___4->alignment_mask) & (long )(~ __o1___4->alignment_mask));
#line 610
      if (__o1___4->next_free - (char *)__o1___4->chunk > __o1___4->chunk_limit - (char *)__o1___4->chunk) {
#line 610
        __o1___4->next_free = __o1___4->chunk_limit;
      }
      {
#line 610
      __o1___4->object_base = __o1___4->next_free;
#line 610
      muscle_insert("nondeterministic_flag", (char const   *)__value___4);
      }
#line 610
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 610
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 611
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 611
    v___5 = ! no_lines_flag;
    {
#line 611
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 611
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 611
        sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
                v___5);
#line 611
        __o___11 = & muscle_obstack;
#line 611
        tmp___25 = strlen((char const   *)(buf___6));
#line 611
        __len___5 = (int )tmp___25;
        }
#line 611
        if ((unsigned long )(__o___11->next_free + __len___5) > (unsigned long )__o___11->chunk_limit) {
          {
#line 611
          _obstack_newchunk(__o___11, __len___5);
          }
        }
        {
#line 611
        memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)(buf___6),
               (size_t )__len___5);
#line 611
        __o___11->next_free += __len___5;
        }
#line 611
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 611
      __o___12 = & muscle_obstack;
#line 611
      if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
        {
#line 611
        _obstack_newchunk(__o___12, 1);
        }
      }
#line 611
      tmp___26 = __o___12->next_free;
#line 611
      (__o___12->next_free) ++;
#line 611
      *tmp___26 = (char)0;
#line 611
      __o1___5 = & muscle_obstack;
#line 611
      __value___5 = (void *)__o1___5->object_base;
#line 611
      if ((unsigned long )__o1___5->next_free == (unsigned long )__value___5) {
#line 611
        __o1___5->maybe_empty_object = 1U;
      }
#line 611
      if (sizeof(int ) < sizeof(void *)) {
#line 611
        tmp___27 = __o1___5->object_base;
      } else {
#line 611
        tmp___27 = (char *)0;
      }
#line 611
      if (sizeof(int ) < sizeof(void *)) {
#line 611
        tmp___28 = __o1___5->object_base;
      } else {
#line 611
        tmp___28 = (char *)0;
      }
#line 611
      __o1___5->next_free = tmp___27 + (((__o1___5->next_free - tmp___28) + (long )__o1___5->alignment_mask) & (long )(~ __o1___5->alignment_mask));
#line 611
      if (__o1___5->next_free - (char *)__o1___5->chunk > __o1___5->chunk_limit - (char *)__o1___5->chunk) {
#line 611
        __o1___5->next_free = __o1___5->chunk_limit;
      }
      {
#line 611
      __o1___5->object_base = __o1___5->next_free;
#line 611
      muscle_insert("synclines_flag", (char const   *)__value___5);
      }
#line 611
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 611
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 612
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 612
    v___6 = (int )tag_seen;
    {
#line 612
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 612
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 612
        sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"%d",
                v___6);
#line 612
        __o___13 = & muscle_obstack;
#line 612
        tmp___29 = strlen((char const   *)(buf___7));
#line 612
        __len___6 = (int )tmp___29;
        }
#line 612
        if ((unsigned long )(__o___13->next_free + __len___6) > (unsigned long )__o___13->chunk_limit) {
          {
#line 612
          _obstack_newchunk(__o___13, __len___6);
          }
        }
        {
#line 612
        memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)(buf___7),
               (size_t )__len___6);
#line 612
        __o___13->next_free += __len___6;
        }
#line 612
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 612
      __o___14 = & muscle_obstack;
#line 612
      if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
        {
#line 612
        _obstack_newchunk(__o___14, 1);
        }
      }
#line 612
      tmp___30 = __o___14->next_free;
#line 612
      (__o___14->next_free) ++;
#line 612
      *tmp___30 = (char)0;
#line 612
      __o1___6 = & muscle_obstack;
#line 612
      __value___6 = (void *)__o1___6->object_base;
#line 612
      if ((unsigned long )__o1___6->next_free == (unsigned long )__value___6) {
#line 612
        __o1___6->maybe_empty_object = 1U;
      }
#line 612
      if (sizeof(int ) < sizeof(void *)) {
#line 612
        tmp___31 = __o1___6->object_base;
      } else {
#line 612
        tmp___31 = (char *)0;
      }
#line 612
      if (sizeof(int ) < sizeof(void *)) {
#line 612
        tmp___32 = __o1___6->object_base;
      } else {
#line 612
        tmp___32 = (char *)0;
      }
#line 612
      __o1___6->next_free = tmp___31 + (((__o1___6->next_free - tmp___32) + (long )__o1___6->alignment_mask) & (long )(~ __o1___6->alignment_mask));
#line 612
      if (__o1___6->next_free - (char *)__o1___6->chunk > __o1___6->chunk_limit - (char *)__o1___6->chunk) {
#line 612
        __o1___6->next_free = __o1___6->chunk_limit;
      }
      {
#line 612
      __o1___6->object_base = __o1___6->next_free;
#line 612
      muscle_insert("tag_seen_flag", (char const   *)__value___6);
      }
#line 612
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 612
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 613
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 613
    v___7 = (int )use_push_for_pull_flag;
    {
#line 613
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 613
      while (1) {
        while_continue___25: /* CIL Label */ ;
        {
#line 613
        sprintf((char */* __restrict  */)(buf___8), (char const   */* __restrict  */)"%d",
                v___7);
#line 613
        __o___15 = & muscle_obstack;
#line 613
        tmp___33 = strlen((char const   *)(buf___8));
#line 613
        __len___7 = (int )tmp___33;
        }
#line 613
        if ((unsigned long )(__o___15->next_free + __len___7) > (unsigned long )__o___15->chunk_limit) {
          {
#line 613
          _obstack_newchunk(__o___15, __len___7);
          }
        }
        {
#line 613
        memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)(buf___8),
               (size_t )__len___7);
#line 613
        __o___15->next_free += __len___7;
        }
#line 613
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 613
      __o___16 = & muscle_obstack;
#line 613
      if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
        {
#line 613
        _obstack_newchunk(__o___16, 1);
        }
      }
#line 613
      tmp___34 = __o___16->next_free;
#line 613
      (__o___16->next_free) ++;
#line 613
      *tmp___34 = (char)0;
#line 613
      __o1___7 = & muscle_obstack;
#line 613
      __value___7 = (void *)__o1___7->object_base;
#line 613
      if ((unsigned long )__o1___7->next_free == (unsigned long )__value___7) {
#line 613
        __o1___7->maybe_empty_object = 1U;
      }
#line 613
      if (sizeof(int ) < sizeof(void *)) {
#line 613
        tmp___35 = __o1___7->object_base;
      } else {
#line 613
        tmp___35 = (char *)0;
      }
#line 613
      if (sizeof(int ) < sizeof(void *)) {
#line 613
        tmp___36 = __o1___7->object_base;
      } else {
#line 613
        tmp___36 = (char *)0;
      }
#line 613
      __o1___7->next_free = tmp___35 + (((__o1___7->next_free - tmp___36) + (long )__o1___7->alignment_mask) & (long )(~ __o1___7->alignment_mask));
#line 613
      if (__o1___7->next_free - (char *)__o1___7->chunk > __o1___7->chunk_limit - (char *)__o1___7->chunk) {
#line 613
        __o1___7->next_free = __o1___7->chunk_limit;
      }
      {
#line 613
      __o1___7->object_base = __o1___7->next_free;
#line 613
      muscle_insert("use_push_for_pull_flag", (char const   *)__value___7);
      }
#line 613
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 613
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 614
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 614
    v___8 = (int )yacc_flag;
    {
#line 614
    while (1) {
      while_continue___27: /* CIL Label */ ;
      {
#line 614
      while (1) {
        while_continue___28: /* CIL Label */ ;
        {
#line 614
        sprintf((char */* __restrict  */)(buf___9), (char const   */* __restrict  */)"%d",
                v___8);
#line 614
        __o___17 = & muscle_obstack;
#line 614
        tmp___37 = strlen((char const   *)(buf___9));
#line 614
        __len___8 = (int )tmp___37;
        }
#line 614
        if ((unsigned long )(__o___17->next_free + __len___8) > (unsigned long )__o___17->chunk_limit) {
          {
#line 614
          _obstack_newchunk(__o___17, __len___8);
          }
        }
        {
#line 614
        memcpy((void */* __restrict  */)__o___17->next_free, (void const   */* __restrict  */)(buf___9),
               (size_t )__len___8);
#line 614
        __o___17->next_free += __len___8;
        }
#line 614
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 614
      __o___18 = & muscle_obstack;
#line 614
      if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
        {
#line 614
        _obstack_newchunk(__o___18, 1);
        }
      }
#line 614
      tmp___38 = __o___18->next_free;
#line 614
      (__o___18->next_free) ++;
#line 614
      *tmp___38 = (char)0;
#line 614
      __o1___8 = & muscle_obstack;
#line 614
      __value___8 = (void *)__o1___8->object_base;
#line 614
      if ((unsigned long )__o1___8->next_free == (unsigned long )__value___8) {
#line 614
        __o1___8->maybe_empty_object = 1U;
      }
#line 614
      if (sizeof(int ) < sizeof(void *)) {
#line 614
        tmp___39 = __o1___8->object_base;
      } else {
#line 614
        tmp___39 = (char *)0;
      }
#line 614
      if (sizeof(int ) < sizeof(void *)) {
#line 614
        tmp___40 = __o1___8->object_base;
      } else {
#line 614
        tmp___40 = (char *)0;
      }
#line 614
      __o1___8->next_free = tmp___39 + (((__o1___8->next_free - tmp___40) + (long )__o1___8->alignment_mask) & (long )(~ __o1___8->alignment_mask));
#line 614
      if (__o1___8->next_free - (char *)__o1___8->chunk > __o1___8->chunk_limit - (char *)__o1___8->chunk) {
#line 614
        __o1___8->next_free = __o1___8->chunk_limit;
      }
      {
#line 614
      __o1___8->object_base = __o1___8->next_free;
#line 614
      muscle_insert("yacc_flag", (char const   *)__value___8);
      }
#line 614
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 614
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 617
  if (spec_name_prefix) {
    {
#line 618
    while (1) {
      while_continue___29: /* CIL Label */ ;
      {
#line 618
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 618
        p = spec_name_prefix;
        {
#line 618
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 618
          if (! *p) {
#line 618
            goto while_break___31;
          }
          {
#line 618
          if ((int const   )*p == 36) {
#line 618
            goto case_36;
          }
#line 618
          if ((int const   )*p == 64) {
#line 618
            goto case_64;
          }
#line 618
          if ((int const   )*p == 91) {
#line 618
            goto case_91;
          }
#line 618
          if ((int const   )*p == 93) {
#line 618
            goto case_93;
          }
#line 618
          goto switch_default;
          case_36: /* CIL Label */ 
          {
#line 618
          __o___19 = & muscle_obstack;
#line 618
          tmp___41 = strlen("$][");
#line 618
          __len___9 = (int )tmp___41;
          }
#line 618
          if ((unsigned long )(__o___19->next_free + __len___9) > (unsigned long )__o___19->chunk_limit) {
            {
#line 618
            _obstack_newchunk(__o___19, __len___9);
            }
          }
          {
#line 618
          memcpy((void */* __restrict  */)__o___19->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len___9);
#line 618
          __o___19->next_free += __len___9;
          }
#line 618
          goto switch_break;
          case_64: /* CIL Label */ 
          {
#line 618
          __o___20 = & muscle_obstack;
#line 618
          tmp___42 = strlen("@@");
#line 618
          __len___10 = (int )tmp___42;
          }
#line 618
          if ((unsigned long )(__o___20->next_free + __len___10) > (unsigned long )__o___20->chunk_limit) {
            {
#line 618
            _obstack_newchunk(__o___20, __len___10);
            }
          }
          {
#line 618
          memcpy((void */* __restrict  */)__o___20->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___10);
#line 618
          __o___20->next_free += __len___10;
          }
#line 618
          goto switch_break;
          case_91: /* CIL Label */ 
          {
#line 618
          __o___21 = & muscle_obstack;
#line 618
          tmp___43 = strlen("@{");
#line 618
          __len___11 = (int )tmp___43;
          }
#line 618
          if ((unsigned long )(__o___21->next_free + __len___11) > (unsigned long )__o___21->chunk_limit) {
            {
#line 618
            _obstack_newchunk(__o___21, __len___11);
            }
          }
          {
#line 618
          memcpy((void */* __restrict  */)__o___21->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___11);
#line 618
          __o___21->next_free += __len___11;
          }
#line 618
          goto switch_break;
          case_93: /* CIL Label */ 
          {
#line 618
          __o___22 = & muscle_obstack;
#line 618
          tmp___44 = strlen("@}");
#line 618
          __len___12 = (int )tmp___44;
          }
#line 618
          if ((unsigned long )(__o___22->next_free + __len___12) > (unsigned long )__o___22->chunk_limit) {
            {
#line 618
            _obstack_newchunk(__o___22, __len___12);
            }
          }
          {
#line 618
          memcpy((void */* __restrict  */)__o___22->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___12);
#line 618
          __o___22->next_free += __len___12;
          }
#line 618
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 618
          __o___23 = & muscle_obstack;
#line 618
          if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
            {
#line 618
            _obstack_newchunk(__o___23, 1);
            }
          }
#line 618
          tmp___45 = __o___23->next_free;
#line 618
          (__o___23->next_free) ++;
#line 618
          *tmp___45 = (char )*p;
#line 618
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 618
          p ++;
        }
        while_break___31: /* CIL Label */ ;
        }
#line 618
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 618
      __o___24 = & muscle_obstack;
#line 618
      if ((unsigned long )(__o___24->next_free + 1) > (unsigned long )__o___24->chunk_limit) {
        {
#line 618
        _obstack_newchunk(__o___24, 1);
        }
      }
#line 618
      tmp___46 = __o___24->next_free;
#line 618
      (__o___24->next_free) ++;
#line 618
      *tmp___46 = (char)0;
#line 618
      __o1___9 = & muscle_obstack;
#line 618
      __value___9 = (void *)__o1___9->object_base;
#line 618
      if ((unsigned long )__o1___9->next_free == (unsigned long )__value___9) {
#line 618
        __o1___9->maybe_empty_object = 1U;
      }
#line 618
      if (sizeof(int ) < sizeof(void *)) {
#line 618
        tmp___47 = __o1___9->object_base;
      } else {
#line 618
        tmp___47 = (char *)0;
      }
#line 618
      if (sizeof(int ) < sizeof(void *)) {
#line 618
        tmp___48 = __o1___9->object_base;
      } else {
#line 618
        tmp___48 = (char *)0;
      }
#line 618
      __o1___9->next_free = tmp___47 + (((__o1___9->next_free - tmp___48) + (long )__o1___9->alignment_mask) & (long )(~ __o1___9->alignment_mask));
#line 618
      if (__o1___9->next_free - (char *)__o1___9->chunk > __o1___9->chunk_limit - (char *)__o1___9->chunk) {
#line 618
        __o1___9->next_free = __o1___9->chunk_limit;
      }
      {
#line 618
      __o1___9->object_base = __o1___9->next_free;
#line 618
      muscle_insert("prefix", (char const   *)__value___9);
      }
#line 618
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
  }
  {
#line 620
  while (1) {
    while_continue___32: /* CIL Label */ ;
    {
#line 620
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 620
      p___0 = (char const   *)all_but_ext;
      {
#line 620
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 620
        if (! *p___0) {
#line 620
          goto while_break___34;
        }
        {
#line 620
        if ((int const   )*p___0 == 36) {
#line 620
          goto case_36___0;
        }
#line 620
        if ((int const   )*p___0 == 64) {
#line 620
          goto case_64___0;
        }
#line 620
        if ((int const   )*p___0 == 91) {
#line 620
          goto case_91___0;
        }
#line 620
        if ((int const   )*p___0 == 93) {
#line 620
          goto case_93___0;
        }
#line 620
        goto switch_default___0;
        case_36___0: /* CIL Label */ 
        {
#line 620
        __o___25 = & muscle_obstack;
#line 620
        tmp___49 = strlen("$][");
#line 620
        __len___13 = (int )tmp___49;
        }
#line 620
        if ((unsigned long )(__o___25->next_free + __len___13) > (unsigned long )__o___25->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___25, __len___13);
          }
        }
        {
#line 620
        memcpy((void */* __restrict  */)__o___25->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___13);
#line 620
        __o___25->next_free += __len___13;
        }
#line 620
        goto switch_break___0;
        case_64___0: /* CIL Label */ 
        {
#line 620
        __o___26 = & muscle_obstack;
#line 620
        tmp___50 = strlen("@@");
#line 620
        __len___14 = (int )tmp___50;
        }
#line 620
        if ((unsigned long )(__o___26->next_free + __len___14) > (unsigned long )__o___26->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___26, __len___14);
          }
        }
        {
#line 620
        memcpy((void */* __restrict  */)__o___26->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___14);
#line 620
        __o___26->next_free += __len___14;
        }
#line 620
        goto switch_break___0;
        case_91___0: /* CIL Label */ 
        {
#line 620
        __o___27 = & muscle_obstack;
#line 620
        tmp___51 = strlen("@{");
#line 620
        __len___15 = (int )tmp___51;
        }
#line 620
        if ((unsigned long )(__o___27->next_free + __len___15) > (unsigned long )__o___27->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___27, __len___15);
          }
        }
        {
#line 620
        memcpy((void */* __restrict  */)__o___27->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___15);
#line 620
        __o___27->next_free += __len___15;
        }
#line 620
        goto switch_break___0;
        case_93___0: /* CIL Label */ 
        {
#line 620
        __o___28 = & muscle_obstack;
#line 620
        tmp___52 = strlen("@}");
#line 620
        __len___16 = (int )tmp___52;
        }
#line 620
        if ((unsigned long )(__o___28->next_free + __len___16) > (unsigned long )__o___28->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___28, __len___16);
          }
        }
        {
#line 620
        memcpy((void */* __restrict  */)__o___28->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___16);
#line 620
        __o___28->next_free += __len___16;
        }
#line 620
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 620
        __o___29 = & muscle_obstack;
#line 620
        if ((unsigned long )(__o___29->next_free + 1) > (unsigned long )__o___29->chunk_limit) {
          {
#line 620
          _obstack_newchunk(__o___29, 1);
          }
        }
#line 620
        tmp___53 = __o___29->next_free;
#line 620
        (__o___29->next_free) ++;
#line 620
        *tmp___53 = (char )*p___0;
#line 620
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 620
        p___0 ++;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 620
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
#line 620
    __o___30 = & muscle_obstack;
#line 620
    if ((unsigned long )(__o___30->next_free + 1) > (unsigned long )__o___30->chunk_limit) {
      {
#line 620
      _obstack_newchunk(__o___30, 1);
      }
    }
#line 620
    tmp___54 = __o___30->next_free;
#line 620
    (__o___30->next_free) ++;
#line 620
    *tmp___54 = (char)0;
#line 620
    __o1___10 = & muscle_obstack;
#line 620
    __value___10 = (void *)__o1___10->object_base;
#line 620
    if ((unsigned long )__o1___10->next_free == (unsigned long )__value___10) {
#line 620
      __o1___10->maybe_empty_object = 1U;
    }
#line 620
    if (sizeof(int ) < sizeof(void *)) {
#line 620
      tmp___55 = __o1___10->object_base;
    } else {
#line 620
      tmp___55 = (char *)0;
    }
#line 620
    if (sizeof(int ) < sizeof(void *)) {
#line 620
      tmp___56 = __o1___10->object_base;
    } else {
#line 620
      tmp___56 = (char *)0;
    }
#line 620
    __o1___10->next_free = tmp___55 + (((__o1___10->next_free - tmp___56) + (long )__o1___10->alignment_mask) & (long )(~ __o1___10->alignment_mask));
#line 620
    if (__o1___10->next_free - (char *)__o1___10->chunk > __o1___10->chunk_limit - (char *)__o1___10->chunk) {
#line 620
      __o1___10->next_free = __o1___10->chunk_limit;
    }
    {
#line 620
    __o1___10->object_base = __o1___10->next_free;
#line 620
    muscle_insert("file_name_all_but_ext", (char const   *)__value___10);
    }
#line 620
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 623
  while (1) {
    while_continue___35: /* CIL Label */ ;
    {
#line 623
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 623
      if (dir_prefix) {
#line 623
        p___1 = (char const   *)dir_prefix;
      } else {
#line 623
        p___1 = "";
      }
      {
#line 623
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 623
        if (! *p___1) {
#line 623
          goto while_break___37;
        }
        {
#line 623
        if ((int const   )*p___1 == 36) {
#line 623
          goto case_36___1;
        }
#line 623
        if ((int const   )*p___1 == 64) {
#line 623
          goto case_64___1;
        }
#line 623
        if ((int const   )*p___1 == 91) {
#line 623
          goto case_91___1;
        }
#line 623
        if ((int const   )*p___1 == 93) {
#line 623
          goto case_93___1;
        }
#line 623
        goto switch_default___1;
        case_36___1: /* CIL Label */ 
        {
#line 623
        __o___31 = & muscle_obstack;
#line 623
        tmp___57 = strlen("$][");
#line 623
        __len___17 = (int )tmp___57;
        }
#line 623
        if ((unsigned long )(__o___31->next_free + __len___17) > (unsigned long )__o___31->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___31, __len___17);
          }
        }
        {
#line 623
        memcpy((void */* __restrict  */)__o___31->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___17);
#line 623
        __o___31->next_free += __len___17;
        }
#line 623
        goto switch_break___1;
        case_64___1: /* CIL Label */ 
        {
#line 623
        __o___32 = & muscle_obstack;
#line 623
        tmp___58 = strlen("@@");
#line 623
        __len___18 = (int )tmp___58;
        }
#line 623
        if ((unsigned long )(__o___32->next_free + __len___18) > (unsigned long )__o___32->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___32, __len___18);
          }
        }
        {
#line 623
        memcpy((void */* __restrict  */)__o___32->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___18);
#line 623
        __o___32->next_free += __len___18;
        }
#line 623
        goto switch_break___1;
        case_91___1: /* CIL Label */ 
        {
#line 623
        __o___33 = & muscle_obstack;
#line 623
        tmp___59 = strlen("@{");
#line 623
        __len___19 = (int )tmp___59;
        }
#line 623
        if ((unsigned long )(__o___33->next_free + __len___19) > (unsigned long )__o___33->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___33, __len___19);
          }
        }
        {
#line 623
        memcpy((void */* __restrict  */)__o___33->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___19);
#line 623
        __o___33->next_free += __len___19;
        }
#line 623
        goto switch_break___1;
        case_93___1: /* CIL Label */ 
        {
#line 623
        __o___34 = & muscle_obstack;
#line 623
        tmp___60 = strlen("@}");
#line 623
        __len___20 = (int )tmp___60;
        }
#line 623
        if ((unsigned long )(__o___34->next_free + __len___20) > (unsigned long )__o___34->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___34, __len___20);
          }
        }
        {
#line 623
        memcpy((void */* __restrict  */)__o___34->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___20);
#line 623
        __o___34->next_free += __len___20;
        }
#line 623
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 623
        __o___35 = & muscle_obstack;
#line 623
        if ((unsigned long )(__o___35->next_free + 1) > (unsigned long )__o___35->chunk_limit) {
          {
#line 623
          _obstack_newchunk(__o___35, 1);
          }
        }
#line 623
        tmp___61 = __o___35->next_free;
#line 623
        (__o___35->next_free) ++;
#line 623
        *tmp___61 = (char )*p___1;
#line 623
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 623
        p___1 ++;
      }
      while_break___37: /* CIL Label */ ;
      }
#line 623
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 623
    __o___36 = & muscle_obstack;
#line 623
    if ((unsigned long )(__o___36->next_free + 1) > (unsigned long )__o___36->chunk_limit) {
      {
#line 623
      _obstack_newchunk(__o___36, 1);
      }
    }
#line 623
    tmp___62 = __o___36->next_free;
#line 623
    (__o___36->next_free) ++;
#line 623
    *tmp___62 = (char)0;
#line 623
    __o1___11 = & muscle_obstack;
#line 623
    __value___11 = (void *)__o1___11->object_base;
#line 623
    if ((unsigned long )__o1___11->next_free == (unsigned long )__value___11) {
#line 623
      __o1___11->maybe_empty_object = 1U;
    }
#line 623
    if (sizeof(int ) < sizeof(void *)) {
#line 623
      tmp___63 = __o1___11->object_base;
    } else {
#line 623
      tmp___63 = (char *)0;
    }
#line 623
    if (sizeof(int ) < sizeof(void *)) {
#line 623
      tmp___64 = __o1___11->object_base;
    } else {
#line 623
      tmp___64 = (char *)0;
    }
#line 623
    __o1___11->next_free = tmp___63 + (((__o1___11->next_free - tmp___64) + (long )__o1___11->alignment_mask) & (long )(~ __o1___11->alignment_mask));
#line 623
    if (__o1___11->next_free - (char *)__o1___11->chunk > __o1___11->chunk_limit - (char *)__o1___11->chunk) {
#line 623
      __o1___11->next_free = __o1___11->chunk_limit;
    }
    {
#line 623
    __o1___11->object_base = __o1___11->next_free;
#line 623
    muscle_insert("dir_prefix", (char const   *)__value___11);
    }
#line 623
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
  {
#line 624
  while (1) {
    while_continue___38: /* CIL Label */ ;
    {
#line 624
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 624
      if (parser_file_name) {
#line 624
        p___2 = (char const   *)parser_file_name;
      } else {
#line 624
        p___2 = "";
      }
      {
#line 624
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 624
        if (! *p___2) {
#line 624
          goto while_break___40;
        }
        {
#line 624
        if ((int const   )*p___2 == 36) {
#line 624
          goto case_36___2;
        }
#line 624
        if ((int const   )*p___2 == 64) {
#line 624
          goto case_64___2;
        }
#line 624
        if ((int const   )*p___2 == 91) {
#line 624
          goto case_91___2;
        }
#line 624
        if ((int const   )*p___2 == 93) {
#line 624
          goto case_93___2;
        }
#line 624
        goto switch_default___2;
        case_36___2: /* CIL Label */ 
        {
#line 624
        __o___37 = & muscle_obstack;
#line 624
        tmp___65 = strlen("$][");
#line 624
        __len___21 = (int )tmp___65;
        }
#line 624
        if ((unsigned long )(__o___37->next_free + __len___21) > (unsigned long )__o___37->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___37, __len___21);
          }
        }
        {
#line 624
        memcpy((void */* __restrict  */)__o___37->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___21);
#line 624
        __o___37->next_free += __len___21;
        }
#line 624
        goto switch_break___2;
        case_64___2: /* CIL Label */ 
        {
#line 624
        __o___38 = & muscle_obstack;
#line 624
        tmp___66 = strlen("@@");
#line 624
        __len___22 = (int )tmp___66;
        }
#line 624
        if ((unsigned long )(__o___38->next_free + __len___22) > (unsigned long )__o___38->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___38, __len___22);
          }
        }
        {
#line 624
        memcpy((void */* __restrict  */)__o___38->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___22);
#line 624
        __o___38->next_free += __len___22;
        }
#line 624
        goto switch_break___2;
        case_91___2: /* CIL Label */ 
        {
#line 624
        __o___39 = & muscle_obstack;
#line 624
        tmp___67 = strlen("@{");
#line 624
        __len___23 = (int )tmp___67;
        }
#line 624
        if ((unsigned long )(__o___39->next_free + __len___23) > (unsigned long )__o___39->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___39, __len___23);
          }
        }
        {
#line 624
        memcpy((void */* __restrict  */)__o___39->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___23);
#line 624
        __o___39->next_free += __len___23;
        }
#line 624
        goto switch_break___2;
        case_93___2: /* CIL Label */ 
        {
#line 624
        __o___40 = & muscle_obstack;
#line 624
        tmp___68 = strlen("@}");
#line 624
        __len___24 = (int )tmp___68;
        }
#line 624
        if ((unsigned long )(__o___40->next_free + __len___24) > (unsigned long )__o___40->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___40, __len___24);
          }
        }
        {
#line 624
        memcpy((void */* __restrict  */)__o___40->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___24);
#line 624
        __o___40->next_free += __len___24;
        }
#line 624
        goto switch_break___2;
        switch_default___2: /* CIL Label */ 
#line 624
        __o___41 = & muscle_obstack;
#line 624
        if ((unsigned long )(__o___41->next_free + 1) > (unsigned long )__o___41->chunk_limit) {
          {
#line 624
          _obstack_newchunk(__o___41, 1);
          }
        }
#line 624
        tmp___69 = __o___41->next_free;
#line 624
        (__o___41->next_free) ++;
#line 624
        *tmp___69 = (char )*p___2;
#line 624
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 624
        p___2 ++;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 624
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 624
    __o___42 = & muscle_obstack;
#line 624
    if ((unsigned long )(__o___42->next_free + 1) > (unsigned long )__o___42->chunk_limit) {
      {
#line 624
      _obstack_newchunk(__o___42, 1);
      }
    }
#line 624
    tmp___70 = __o___42->next_free;
#line 624
    (__o___42->next_free) ++;
#line 624
    *tmp___70 = (char)0;
#line 624
    __o1___12 = & muscle_obstack;
#line 624
    __value___12 = (void *)__o1___12->object_base;
#line 624
    if ((unsigned long )__o1___12->next_free == (unsigned long )__value___12) {
#line 624
      __o1___12->maybe_empty_object = 1U;
    }
#line 624
    if (sizeof(int ) < sizeof(void *)) {
#line 624
      tmp___71 = __o1___12->object_base;
    } else {
#line 624
      tmp___71 = (char *)0;
    }
#line 624
    if (sizeof(int ) < sizeof(void *)) {
#line 624
      tmp___72 = __o1___12->object_base;
    } else {
#line 624
      tmp___72 = (char *)0;
    }
#line 624
    __o1___12->next_free = tmp___71 + (((__o1___12->next_free - tmp___72) + (long )__o1___12->alignment_mask) & (long )(~ __o1___12->alignment_mask));
#line 624
    if (__o1___12->next_free - (char *)__o1___12->chunk > __o1___12->chunk_limit - (char *)__o1___12->chunk) {
#line 624
      __o1___12->next_free = __o1___12->chunk_limit;
    }
    {
#line 624
    __o1___12->object_base = __o1___12->next_free;
#line 624
    muscle_insert("parser_file_name", (char const   *)__value___12);
    }
#line 624
    goto while_break___38;
  }
  while_break___38: /* CIL Label */ ;
  }
  {
#line 625
  while (1) {
    while_continue___41: /* CIL Label */ ;
    {
#line 625
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 625
      if (spec_defines_file) {
#line 625
        p___3 = (char const   *)spec_defines_file;
      } else {
#line 625
        p___3 = "";
      }
      {
#line 625
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 625
        if (! *p___3) {
#line 625
          goto while_break___43;
        }
        {
#line 625
        if ((int const   )*p___3 == 36) {
#line 625
          goto case_36___3;
        }
#line 625
        if ((int const   )*p___3 == 64) {
#line 625
          goto case_64___3;
        }
#line 625
        if ((int const   )*p___3 == 91) {
#line 625
          goto case_91___3;
        }
#line 625
        if ((int const   )*p___3 == 93) {
#line 625
          goto case_93___3;
        }
#line 625
        goto switch_default___3;
        case_36___3: /* CIL Label */ 
        {
#line 625
        __o___43 = & muscle_obstack;
#line 625
        tmp___73 = strlen("$][");
#line 625
        __len___25 = (int )tmp___73;
        }
#line 625
        if ((unsigned long )(__o___43->next_free + __len___25) > (unsigned long )__o___43->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___43, __len___25);
          }
        }
        {
#line 625
        memcpy((void */* __restrict  */)__o___43->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___25);
#line 625
        __o___43->next_free += __len___25;
        }
#line 625
        goto switch_break___3;
        case_64___3: /* CIL Label */ 
        {
#line 625
        __o___44 = & muscle_obstack;
#line 625
        tmp___74 = strlen("@@");
#line 625
        __len___26 = (int )tmp___74;
        }
#line 625
        if ((unsigned long )(__o___44->next_free + __len___26) > (unsigned long )__o___44->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___44, __len___26);
          }
        }
        {
#line 625
        memcpy((void */* __restrict  */)__o___44->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___26);
#line 625
        __o___44->next_free += __len___26;
        }
#line 625
        goto switch_break___3;
        case_91___3: /* CIL Label */ 
        {
#line 625
        __o___45 = & muscle_obstack;
#line 625
        tmp___75 = strlen("@{");
#line 625
        __len___27 = (int )tmp___75;
        }
#line 625
        if ((unsigned long )(__o___45->next_free + __len___27) > (unsigned long )__o___45->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___45, __len___27);
          }
        }
        {
#line 625
        memcpy((void */* __restrict  */)__o___45->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___27);
#line 625
        __o___45->next_free += __len___27;
        }
#line 625
        goto switch_break___3;
        case_93___3: /* CIL Label */ 
        {
#line 625
        __o___46 = & muscle_obstack;
#line 625
        tmp___76 = strlen("@}");
#line 625
        __len___28 = (int )tmp___76;
        }
#line 625
        if ((unsigned long )(__o___46->next_free + __len___28) > (unsigned long )__o___46->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___46, __len___28);
          }
        }
        {
#line 625
        memcpy((void */* __restrict  */)__o___46->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___28);
#line 625
        __o___46->next_free += __len___28;
        }
#line 625
        goto switch_break___3;
        switch_default___3: /* CIL Label */ 
#line 625
        __o___47 = & muscle_obstack;
#line 625
        if ((unsigned long )(__o___47->next_free + 1) > (unsigned long )__o___47->chunk_limit) {
          {
#line 625
          _obstack_newchunk(__o___47, 1);
          }
        }
#line 625
        tmp___77 = __o___47->next_free;
#line 625
        (__o___47->next_free) ++;
#line 625
        *tmp___77 = (char )*p___3;
#line 625
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 625
        p___3 ++;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 625
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 625
    __o___48 = & muscle_obstack;
#line 625
    if ((unsigned long )(__o___48->next_free + 1) > (unsigned long )__o___48->chunk_limit) {
      {
#line 625
      _obstack_newchunk(__o___48, 1);
      }
    }
#line 625
    tmp___78 = __o___48->next_free;
#line 625
    (__o___48->next_free) ++;
#line 625
    *tmp___78 = (char)0;
#line 625
    __o1___13 = & muscle_obstack;
#line 625
    __value___13 = (void *)__o1___13->object_base;
#line 625
    if ((unsigned long )__o1___13->next_free == (unsigned long )__value___13) {
#line 625
      __o1___13->maybe_empty_object = 1U;
    }
#line 625
    if (sizeof(int ) < sizeof(void *)) {
#line 625
      tmp___79 = __o1___13->object_base;
    } else {
#line 625
      tmp___79 = (char *)0;
    }
#line 625
    if (sizeof(int ) < sizeof(void *)) {
#line 625
      tmp___80 = __o1___13->object_base;
    } else {
#line 625
      tmp___80 = (char *)0;
    }
#line 625
    __o1___13->next_free = tmp___79 + (((__o1___13->next_free - tmp___80) + (long )__o1___13->alignment_mask) & (long )(~ __o1___13->alignment_mask));
#line 625
    if (__o1___13->next_free - (char *)__o1___13->chunk > __o1___13->chunk_limit - (char *)__o1___13->chunk) {
#line 625
      __o1___13->next_free = __o1___13->chunk_limit;
    }
    {
#line 625
    __o1___13->object_base = __o1___13->next_free;
#line 625
    muscle_insert("spec_defines_file", (char const   *)__value___13);
    }
#line 625
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
  {
#line 626
  while (1) {
    while_continue___44: /* CIL Label */ ;
    {
#line 626
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 626
      if (spec_file_prefix) {
#line 626
        p___4 = spec_file_prefix;
      } else {
#line 626
        p___4 = "";
      }
      {
#line 626
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 626
        if (! *p___4) {
#line 626
          goto while_break___46;
        }
        {
#line 626
        if ((int const   )*p___4 == 36) {
#line 626
          goto case_36___4;
        }
#line 626
        if ((int const   )*p___4 == 64) {
#line 626
          goto case_64___4;
        }
#line 626
        if ((int const   )*p___4 == 91) {
#line 626
          goto case_91___4;
        }
#line 626
        if ((int const   )*p___4 == 93) {
#line 626
          goto case_93___4;
        }
#line 626
        goto switch_default___4;
        case_36___4: /* CIL Label */ 
        {
#line 626
        __o___49 = & muscle_obstack;
#line 626
        tmp___81 = strlen("$][");
#line 626
        __len___29 = (int )tmp___81;
        }
#line 626
        if ((unsigned long )(__o___49->next_free + __len___29) > (unsigned long )__o___49->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___49, __len___29);
          }
        }
        {
#line 626
        memcpy((void */* __restrict  */)__o___49->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___29);
#line 626
        __o___49->next_free += __len___29;
        }
#line 626
        goto switch_break___4;
        case_64___4: /* CIL Label */ 
        {
#line 626
        __o___50 = & muscle_obstack;
#line 626
        tmp___82 = strlen("@@");
#line 626
        __len___30 = (int )tmp___82;
        }
#line 626
        if ((unsigned long )(__o___50->next_free + __len___30) > (unsigned long )__o___50->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___50, __len___30);
          }
        }
        {
#line 626
        memcpy((void */* __restrict  */)__o___50->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___30);
#line 626
        __o___50->next_free += __len___30;
        }
#line 626
        goto switch_break___4;
        case_91___4: /* CIL Label */ 
        {
#line 626
        __o___51 = & muscle_obstack;
#line 626
        tmp___83 = strlen("@{");
#line 626
        __len___31 = (int )tmp___83;
        }
#line 626
        if ((unsigned long )(__o___51->next_free + __len___31) > (unsigned long )__o___51->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___51, __len___31);
          }
        }
        {
#line 626
        memcpy((void */* __restrict  */)__o___51->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___31);
#line 626
        __o___51->next_free += __len___31;
        }
#line 626
        goto switch_break___4;
        case_93___4: /* CIL Label */ 
        {
#line 626
        __o___52 = & muscle_obstack;
#line 626
        tmp___84 = strlen("@}");
#line 626
        __len___32 = (int )tmp___84;
        }
#line 626
        if ((unsigned long )(__o___52->next_free + __len___32) > (unsigned long )__o___52->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___52, __len___32);
          }
        }
        {
#line 626
        memcpy((void */* __restrict  */)__o___52->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___32);
#line 626
        __o___52->next_free += __len___32;
        }
#line 626
        goto switch_break___4;
        switch_default___4: /* CIL Label */ 
#line 626
        __o___53 = & muscle_obstack;
#line 626
        if ((unsigned long )(__o___53->next_free + 1) > (unsigned long )__o___53->chunk_limit) {
          {
#line 626
          _obstack_newchunk(__o___53, 1);
          }
        }
#line 626
        tmp___85 = __o___53->next_free;
#line 626
        (__o___53->next_free) ++;
#line 626
        *tmp___85 = (char )*p___4;
#line 626
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 626
        p___4 ++;
      }
      while_break___46: /* CIL Label */ ;
      }
#line 626
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 626
    __o___54 = & muscle_obstack;
#line 626
    if ((unsigned long )(__o___54->next_free + 1) > (unsigned long )__o___54->chunk_limit) {
      {
#line 626
      _obstack_newchunk(__o___54, 1);
      }
    }
#line 626
    tmp___86 = __o___54->next_free;
#line 626
    (__o___54->next_free) ++;
#line 626
    *tmp___86 = (char)0;
#line 626
    __o1___14 = & muscle_obstack;
#line 626
    __value___14 = (void *)__o1___14->object_base;
#line 626
    if ((unsigned long )__o1___14->next_free == (unsigned long )__value___14) {
#line 626
      __o1___14->maybe_empty_object = 1U;
    }
#line 626
    if (sizeof(int ) < sizeof(void *)) {
#line 626
      tmp___87 = __o1___14->object_base;
    } else {
#line 626
      tmp___87 = (char *)0;
    }
#line 626
    if (sizeof(int ) < sizeof(void *)) {
#line 626
      tmp___88 = __o1___14->object_base;
    } else {
#line 626
      tmp___88 = (char *)0;
    }
#line 626
    __o1___14->next_free = tmp___87 + (((__o1___14->next_free - tmp___88) + (long )__o1___14->alignment_mask) & (long )(~ __o1___14->alignment_mask));
#line 626
    if (__o1___14->next_free - (char *)__o1___14->chunk > __o1___14->chunk_limit - (char *)__o1___14->chunk) {
#line 626
      __o1___14->next_free = __o1___14->chunk_limit;
    }
    {
#line 626
    __o1___14->object_base = __o1___14->next_free;
#line 626
    muscle_insert("spec_file_prefix", (char const   *)__value___14);
    }
#line 626
    goto while_break___44;
  }
  while_break___44: /* CIL Label */ ;
  }
  {
#line 627
  while (1) {
    while_continue___47: /* CIL Label */ ;
    {
#line 627
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 627
      if (spec_graph_file) {
#line 627
        p___5 = (char const   *)spec_graph_file;
      } else {
#line 627
        p___5 = "";
      }
      {
#line 627
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 627
        if (! *p___5) {
#line 627
          goto while_break___49;
        }
        {
#line 627
        if ((int const   )*p___5 == 36) {
#line 627
          goto case_36___5;
        }
#line 627
        if ((int const   )*p___5 == 64) {
#line 627
          goto case_64___5;
        }
#line 627
        if ((int const   )*p___5 == 91) {
#line 627
          goto case_91___5;
        }
#line 627
        if ((int const   )*p___5 == 93) {
#line 627
          goto case_93___5;
        }
#line 627
        goto switch_default___5;
        case_36___5: /* CIL Label */ 
        {
#line 627
        __o___55 = & muscle_obstack;
#line 627
        tmp___89 = strlen("$][");
#line 627
        __len___33 = (int )tmp___89;
        }
#line 627
        if ((unsigned long )(__o___55->next_free + __len___33) > (unsigned long )__o___55->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___55, __len___33);
          }
        }
        {
#line 627
        memcpy((void */* __restrict  */)__o___55->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___33);
#line 627
        __o___55->next_free += __len___33;
        }
#line 627
        goto switch_break___5;
        case_64___5: /* CIL Label */ 
        {
#line 627
        __o___56 = & muscle_obstack;
#line 627
        tmp___90 = strlen("@@");
#line 627
        __len___34 = (int )tmp___90;
        }
#line 627
        if ((unsigned long )(__o___56->next_free + __len___34) > (unsigned long )__o___56->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___56, __len___34);
          }
        }
        {
#line 627
        memcpy((void */* __restrict  */)__o___56->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___34);
#line 627
        __o___56->next_free += __len___34;
        }
#line 627
        goto switch_break___5;
        case_91___5: /* CIL Label */ 
        {
#line 627
        __o___57 = & muscle_obstack;
#line 627
        tmp___91 = strlen("@{");
#line 627
        __len___35 = (int )tmp___91;
        }
#line 627
        if ((unsigned long )(__o___57->next_free + __len___35) > (unsigned long )__o___57->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___57, __len___35);
          }
        }
        {
#line 627
        memcpy((void */* __restrict  */)__o___57->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___35);
#line 627
        __o___57->next_free += __len___35;
        }
#line 627
        goto switch_break___5;
        case_93___5: /* CIL Label */ 
        {
#line 627
        __o___58 = & muscle_obstack;
#line 627
        tmp___92 = strlen("@}");
#line 627
        __len___36 = (int )tmp___92;
        }
#line 627
        if ((unsigned long )(__o___58->next_free + __len___36) > (unsigned long )__o___58->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___58, __len___36);
          }
        }
        {
#line 627
        memcpy((void */* __restrict  */)__o___58->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___36);
#line 627
        __o___58->next_free += __len___36;
        }
#line 627
        goto switch_break___5;
        switch_default___5: /* CIL Label */ 
#line 627
        __o___59 = & muscle_obstack;
#line 627
        if ((unsigned long )(__o___59->next_free + 1) > (unsigned long )__o___59->chunk_limit) {
          {
#line 627
          _obstack_newchunk(__o___59, 1);
          }
        }
#line 627
        tmp___93 = __o___59->next_free;
#line 627
        (__o___59->next_free) ++;
#line 627
        *tmp___93 = (char )*p___5;
#line 627
        goto switch_break___5;
        switch_break___5: /* CIL Label */ ;
        }
#line 627
        p___5 ++;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 627
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 627
    __o___60 = & muscle_obstack;
#line 627
    if ((unsigned long )(__o___60->next_free + 1) > (unsigned long )__o___60->chunk_limit) {
      {
#line 627
      _obstack_newchunk(__o___60, 1);
      }
    }
#line 627
    tmp___94 = __o___60->next_free;
#line 627
    (__o___60->next_free) ++;
#line 627
    *tmp___94 = (char)0;
#line 627
    __o1___15 = & muscle_obstack;
#line 627
    __value___15 = (void *)__o1___15->object_base;
#line 627
    if ((unsigned long )__o1___15->next_free == (unsigned long )__value___15) {
#line 627
      __o1___15->maybe_empty_object = 1U;
    }
#line 627
    if (sizeof(int ) < sizeof(void *)) {
#line 627
      tmp___95 = __o1___15->object_base;
    } else {
#line 627
      tmp___95 = (char *)0;
    }
#line 627
    if (sizeof(int ) < sizeof(void *)) {
#line 627
      tmp___96 = __o1___15->object_base;
    } else {
#line 627
      tmp___96 = (char *)0;
    }
#line 627
    __o1___15->next_free = tmp___95 + (((__o1___15->next_free - tmp___96) + (long )__o1___15->alignment_mask) & (long )(~ __o1___15->alignment_mask));
#line 627
    if (__o1___15->next_free - (char *)__o1___15->chunk > __o1___15->chunk_limit - (char *)__o1___15->chunk) {
#line 627
      __o1___15->next_free = __o1___15->chunk_limit;
    }
    {
#line 627
    __o1___15->object_base = __o1___15->next_free;
#line 627
    muscle_insert("spec_graph_file", (char const   *)__value___15);
    }
#line 627
    goto while_break___47;
  }
  while_break___47: /* CIL Label */ ;
  }
  {
#line 628
  while (1) {
    while_continue___50: /* CIL Label */ ;
    {
#line 628
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 628
      if (spec_name_prefix) {
#line 628
        p___6 = spec_name_prefix;
      } else {
#line 628
        p___6 = "";
      }
      {
#line 628
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 628
        if (! *p___6) {
#line 628
          goto while_break___52;
        }
        {
#line 628
        if ((int const   )*p___6 == 36) {
#line 628
          goto case_36___6;
        }
#line 628
        if ((int const   )*p___6 == 64) {
#line 628
          goto case_64___6;
        }
#line 628
        if ((int const   )*p___6 == 91) {
#line 628
          goto case_91___6;
        }
#line 628
        if ((int const   )*p___6 == 93) {
#line 628
          goto case_93___6;
        }
#line 628
        goto switch_default___6;
        case_36___6: /* CIL Label */ 
        {
#line 628
        __o___61 = & muscle_obstack;
#line 628
        tmp___97 = strlen("$][");
#line 628
        __len___37 = (int )tmp___97;
        }
#line 628
        if ((unsigned long )(__o___61->next_free + __len___37) > (unsigned long )__o___61->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___61, __len___37);
          }
        }
        {
#line 628
        memcpy((void */* __restrict  */)__o___61->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___37);
#line 628
        __o___61->next_free += __len___37;
        }
#line 628
        goto switch_break___6;
        case_64___6: /* CIL Label */ 
        {
#line 628
        __o___62 = & muscle_obstack;
#line 628
        tmp___98 = strlen("@@");
#line 628
        __len___38 = (int )tmp___98;
        }
#line 628
        if ((unsigned long )(__o___62->next_free + __len___38) > (unsigned long )__o___62->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___62, __len___38);
          }
        }
        {
#line 628
        memcpy((void */* __restrict  */)__o___62->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___38);
#line 628
        __o___62->next_free += __len___38;
        }
#line 628
        goto switch_break___6;
        case_91___6: /* CIL Label */ 
        {
#line 628
        __o___63 = & muscle_obstack;
#line 628
        tmp___99 = strlen("@{");
#line 628
        __len___39 = (int )tmp___99;
        }
#line 628
        if ((unsigned long )(__o___63->next_free + __len___39) > (unsigned long )__o___63->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___63, __len___39);
          }
        }
        {
#line 628
        memcpy((void */* __restrict  */)__o___63->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___39);
#line 628
        __o___63->next_free += __len___39;
        }
#line 628
        goto switch_break___6;
        case_93___6: /* CIL Label */ 
        {
#line 628
        __o___64 = & muscle_obstack;
#line 628
        tmp___100 = strlen("@}");
#line 628
        __len___40 = (int )tmp___100;
        }
#line 628
        if ((unsigned long )(__o___64->next_free + __len___40) > (unsigned long )__o___64->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___64, __len___40);
          }
        }
        {
#line 628
        memcpy((void */* __restrict  */)__o___64->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___40);
#line 628
        __o___64->next_free += __len___40;
        }
#line 628
        goto switch_break___6;
        switch_default___6: /* CIL Label */ 
#line 628
        __o___65 = & muscle_obstack;
#line 628
        if ((unsigned long )(__o___65->next_free + 1) > (unsigned long )__o___65->chunk_limit) {
          {
#line 628
          _obstack_newchunk(__o___65, 1);
          }
        }
#line 628
        tmp___101 = __o___65->next_free;
#line 628
        (__o___65->next_free) ++;
#line 628
        *tmp___101 = (char )*p___6;
#line 628
        goto switch_break___6;
        switch_break___6: /* CIL Label */ ;
        }
#line 628
        p___6 ++;
      }
      while_break___52: /* CIL Label */ ;
      }
#line 628
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
#line 628
    __o___66 = & muscle_obstack;
#line 628
    if ((unsigned long )(__o___66->next_free + 1) > (unsigned long )__o___66->chunk_limit) {
      {
#line 628
      _obstack_newchunk(__o___66, 1);
      }
    }
#line 628
    tmp___102 = __o___66->next_free;
#line 628
    (__o___66->next_free) ++;
#line 628
    *tmp___102 = (char)0;
#line 628
    __o1___16 = & muscle_obstack;
#line 628
    __value___16 = (void *)__o1___16->object_base;
#line 628
    if ((unsigned long )__o1___16->next_free == (unsigned long )__value___16) {
#line 628
      __o1___16->maybe_empty_object = 1U;
    }
#line 628
    if (sizeof(int ) < sizeof(void *)) {
#line 628
      tmp___103 = __o1___16->object_base;
    } else {
#line 628
      tmp___103 = (char *)0;
    }
#line 628
    if (sizeof(int ) < sizeof(void *)) {
#line 628
      tmp___104 = __o1___16->object_base;
    } else {
#line 628
      tmp___104 = (char *)0;
    }
#line 628
    __o1___16->next_free = tmp___103 + (((__o1___16->next_free - tmp___104) + (long )__o1___16->alignment_mask) & (long )(~ __o1___16->alignment_mask));
#line 628
    if (__o1___16->next_free - (char *)__o1___16->chunk > __o1___16->chunk_limit - (char *)__o1___16->chunk) {
#line 628
      __o1___16->next_free = __o1___16->chunk_limit;
    }
    {
#line 628
    __o1___16->object_base = __o1___16->next_free;
#line 628
    muscle_insert("spec_name_prefix", (char const   *)__value___16);
    }
#line 628
    goto while_break___50;
  }
  while_break___50: /* CIL Label */ ;
  }
  {
#line 629
  while (1) {
    while_continue___53: /* CIL Label */ ;
    {
#line 629
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 629
      if (spec_outfile) {
#line 629
        p___7 = spec_outfile;
      } else {
#line 629
        p___7 = "";
      }
      {
#line 629
      while (1) {
        while_continue___55: /* CIL Label */ ;
#line 629
        if (! *p___7) {
#line 629
          goto while_break___55;
        }
        {
#line 629
        if ((int const   )*p___7 == 36) {
#line 629
          goto case_36___7;
        }
#line 629
        if ((int const   )*p___7 == 64) {
#line 629
          goto case_64___7;
        }
#line 629
        if ((int const   )*p___7 == 91) {
#line 629
          goto case_91___7;
        }
#line 629
        if ((int const   )*p___7 == 93) {
#line 629
          goto case_93___7;
        }
#line 629
        goto switch_default___7;
        case_36___7: /* CIL Label */ 
        {
#line 629
        __o___67 = & muscle_obstack;
#line 629
        tmp___105 = strlen("$][");
#line 629
        __len___41 = (int )tmp___105;
        }
#line 629
        if ((unsigned long )(__o___67->next_free + __len___41) > (unsigned long )__o___67->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___67, __len___41);
          }
        }
        {
#line 629
        memcpy((void */* __restrict  */)__o___67->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___41);
#line 629
        __o___67->next_free += __len___41;
        }
#line 629
        goto switch_break___7;
        case_64___7: /* CIL Label */ 
        {
#line 629
        __o___68 = & muscle_obstack;
#line 629
        tmp___106 = strlen("@@");
#line 629
        __len___42 = (int )tmp___106;
        }
#line 629
        if ((unsigned long )(__o___68->next_free + __len___42) > (unsigned long )__o___68->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___68, __len___42);
          }
        }
        {
#line 629
        memcpy((void */* __restrict  */)__o___68->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___42);
#line 629
        __o___68->next_free += __len___42;
        }
#line 629
        goto switch_break___7;
        case_91___7: /* CIL Label */ 
        {
#line 629
        __o___69 = & muscle_obstack;
#line 629
        tmp___107 = strlen("@{");
#line 629
        __len___43 = (int )tmp___107;
        }
#line 629
        if ((unsigned long )(__o___69->next_free + __len___43) > (unsigned long )__o___69->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___69, __len___43);
          }
        }
        {
#line 629
        memcpy((void */* __restrict  */)__o___69->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___43);
#line 629
        __o___69->next_free += __len___43;
        }
#line 629
        goto switch_break___7;
        case_93___7: /* CIL Label */ 
        {
#line 629
        __o___70 = & muscle_obstack;
#line 629
        tmp___108 = strlen("@}");
#line 629
        __len___44 = (int )tmp___108;
        }
#line 629
        if ((unsigned long )(__o___70->next_free + __len___44) > (unsigned long )__o___70->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___70, __len___44);
          }
        }
        {
#line 629
        memcpy((void */* __restrict  */)__o___70->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___44);
#line 629
        __o___70->next_free += __len___44;
        }
#line 629
        goto switch_break___7;
        switch_default___7: /* CIL Label */ 
#line 629
        __o___71 = & muscle_obstack;
#line 629
        if ((unsigned long )(__o___71->next_free + 1) > (unsigned long )__o___71->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___71, 1);
          }
        }
#line 629
        tmp___109 = __o___71->next_free;
#line 629
        (__o___71->next_free) ++;
#line 629
        *tmp___109 = (char )*p___7;
#line 629
        goto switch_break___7;
        switch_break___7: /* CIL Label */ ;
        }
#line 629
        p___7 ++;
      }
      while_break___55: /* CIL Label */ ;
      }
#line 629
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
#line 629
    __o___72 = & muscle_obstack;
#line 629
    if ((unsigned long )(__o___72->next_free + 1) > (unsigned long )__o___72->chunk_limit) {
      {
#line 629
      _obstack_newchunk(__o___72, 1);
      }
    }
#line 629
    tmp___110 = __o___72->next_free;
#line 629
    (__o___72->next_free) ++;
#line 629
    *tmp___110 = (char)0;
#line 629
    __o1___17 = & muscle_obstack;
#line 629
    __value___17 = (void *)__o1___17->object_base;
#line 629
    if ((unsigned long )__o1___17->next_free == (unsigned long )__value___17) {
#line 629
      __o1___17->maybe_empty_object = 1U;
    }
#line 629
    if (sizeof(int ) < sizeof(void *)) {
#line 629
      tmp___111 = __o1___17->object_base;
    } else {
#line 629
      tmp___111 = (char *)0;
    }
#line 629
    if (sizeof(int ) < sizeof(void *)) {
#line 629
      tmp___112 = __o1___17->object_base;
    } else {
#line 629
      tmp___112 = (char *)0;
    }
#line 629
    __o1___17->next_free = tmp___111 + (((__o1___17->next_free - tmp___112) + (long )__o1___17->alignment_mask) & (long )(~ __o1___17->alignment_mask));
#line 629
    if (__o1___17->next_free - (char *)__o1___17->chunk > __o1___17->chunk_limit - (char *)__o1___17->chunk) {
#line 629
      __o1___17->next_free = __o1___17->chunk_limit;
    }
    {
#line 629
    __o1___17->object_base = __o1___17->next_free;
#line 629
    muscle_insert("spec_outfile", (char const   *)__value___17);
    }
#line 629
    goto while_break___53;
  }
  while_break___53: /* CIL Label */ ;
  }
  {
#line 630
  while (1) {
    while_continue___56: /* CIL Label */ ;
    {
#line 630
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 630
      if (spec_verbose_file) {
#line 630
        p___8 = (char const   *)spec_verbose_file;
      } else {
#line 630
        p___8 = "";
      }
      {
#line 630
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 630
        if (! *p___8) {
#line 630
          goto while_break___58;
        }
        {
#line 630
        if ((int const   )*p___8 == 36) {
#line 630
          goto case_36___8;
        }
#line 630
        if ((int const   )*p___8 == 64) {
#line 630
          goto case_64___8;
        }
#line 630
        if ((int const   )*p___8 == 91) {
#line 630
          goto case_91___8;
        }
#line 630
        if ((int const   )*p___8 == 93) {
#line 630
          goto case_93___8;
        }
#line 630
        goto switch_default___8;
        case_36___8: /* CIL Label */ 
        {
#line 630
        __o___73 = & muscle_obstack;
#line 630
        tmp___113 = strlen("$][");
#line 630
        __len___45 = (int )tmp___113;
        }
#line 630
        if ((unsigned long )(__o___73->next_free + __len___45) > (unsigned long )__o___73->chunk_limit) {
          {
#line 630
          _obstack_newchunk(__o___73, __len___45);
          }
        }
        {
#line 630
        memcpy((void */* __restrict  */)__o___73->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___45);
#line 630
        __o___73->next_free += __len___45;
        }
#line 630
        goto switch_break___8;
        case_64___8: /* CIL Label */ 
        {
#line 630
        __o___74 = & muscle_obstack;
#line 630
        tmp___114 = strlen("@@");
#line 630
        __len___46 = (int )tmp___114;
        }
#line 630
        if ((unsigned long )(__o___74->next_free + __len___46) > (unsigned long )__o___74->chunk_limit) {
          {
#line 630
          _obstack_newchunk(__o___74, __len___46);
          }
        }
        {
#line 630
        memcpy((void */* __restrict  */)__o___74->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___46);
#line 630
        __o___74->next_free += __len___46;
        }
#line 630
        goto switch_break___8;
        case_91___8: /* CIL Label */ 
        {
#line 630
        __o___75 = & muscle_obstack;
#line 630
        tmp___115 = strlen("@{");
#line 630
        __len___47 = (int )tmp___115;
        }
#line 630
        if ((unsigned long )(__o___75->next_free + __len___47) > (unsigned long )__o___75->chunk_limit) {
          {
#line 630
          _obstack_newchunk(__o___75, __len___47);
          }
        }
        {
#line 630
        memcpy((void */* __restrict  */)__o___75->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___47);
#line 630
        __o___75->next_free += __len___47;
        }
#line 630
        goto switch_break___8;
        case_93___8: /* CIL Label */ 
        {
#line 630
        __o___76 = & muscle_obstack;
#line 630
        tmp___116 = strlen("@}");
#line 630
        __len___48 = (int )tmp___116;
        }
#line 630
        if ((unsigned long )(__o___76->next_free + __len___48) > (unsigned long )__o___76->chunk_limit) {
          {
#line 630
          _obstack_newchunk(__o___76, __len___48);
          }
        }
        {
#line 630
        memcpy((void */* __restrict  */)__o___76->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___48);
#line 630
        __o___76->next_free += __len___48;
        }
#line 630
        goto switch_break___8;
        switch_default___8: /* CIL Label */ 
#line 630
        __o___77 = & muscle_obstack;
#line 630
        if ((unsigned long )(__o___77->next_free + 1) > (unsigned long )__o___77->chunk_limit) {
          {
#line 630
          _obstack_newchunk(__o___77, 1);
          }
        }
#line 630
        tmp___117 = __o___77->next_free;
#line 630
        (__o___77->next_free) ++;
#line 630
        *tmp___117 = (char )*p___8;
#line 630
        goto switch_break___8;
        switch_break___8: /* CIL Label */ ;
        }
#line 630
        p___8 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 630
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
#line 630
    __o___78 = & muscle_obstack;
#line 630
    if ((unsigned long )(__o___78->next_free + 1) > (unsigned long )__o___78->chunk_limit) {
      {
#line 630
      _obstack_newchunk(__o___78, 1);
      }
    }
#line 630
    tmp___118 = __o___78->next_free;
#line 630
    (__o___78->next_free) ++;
#line 630
    *tmp___118 = (char)0;
#line 630
    __o1___18 = & muscle_obstack;
#line 630
    __value___18 = (void *)__o1___18->object_base;
#line 630
    if ((unsigned long )__o1___18->next_free == (unsigned long )__value___18) {
#line 630
      __o1___18->maybe_empty_object = 1U;
    }
#line 630
    if (sizeof(int ) < sizeof(void *)) {
#line 630
      tmp___119 = __o1___18->object_base;
    } else {
#line 630
      tmp___119 = (char *)0;
    }
#line 630
    if (sizeof(int ) < sizeof(void *)) {
#line 630
      tmp___120 = __o1___18->object_base;
    } else {
#line 630
      tmp___120 = (char *)0;
    }
#line 630
    __o1___18->next_free = tmp___119 + (((__o1___18->next_free - tmp___120) + (long )__o1___18->alignment_mask) & (long )(~ __o1___18->alignment_mask));
#line 630
    if (__o1___18->next_free - (char *)__o1___18->chunk > __o1___18->chunk_limit - (char *)__o1___18->chunk) {
#line 630
      __o1___18->next_free = __o1___18->chunk_limit;
    }
    {
#line 630
    __o1___18->object_base = __o1___18->next_free;
#line 630
    muscle_insert("spec_verbose_file", (char const   *)__value___18);
    }
#line 630
    goto while_break___56;
  }
  while_break___56: /* CIL Label */ ;
  }
#line 634
  if (skeleton) {
    {
#line 635
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 635
      while (1) {
        while_continue___60: /* CIL Label */ ;
        {
#line 635
        tmp___121 = quotearg_style((enum quoting_style )3, skeleton);
#line 635
        p___9 = (char const   *)tmp___121;
        }
        {
#line 635
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 635
          if (! *p___9) {
#line 635
            goto while_break___61;
          }
          {
#line 635
          if ((int const   )*p___9 == 36) {
#line 635
            goto case_36___9;
          }
#line 635
          if ((int const   )*p___9 == 64) {
#line 635
            goto case_64___9;
          }
#line 635
          if ((int const   )*p___9 == 91) {
#line 635
            goto case_91___9;
          }
#line 635
          if ((int const   )*p___9 == 93) {
#line 635
            goto case_93___9;
          }
#line 635
          goto switch_default___9;
          case_36___9: /* CIL Label */ 
          {
#line 635
          __o___79 = & muscle_obstack;
#line 635
          tmp___122 = strlen("$][");
#line 635
          __len___49 = (int )tmp___122;
          }
#line 635
          if ((unsigned long )(__o___79->next_free + __len___49) > (unsigned long )__o___79->chunk_limit) {
            {
#line 635
            _obstack_newchunk(__o___79, __len___49);
            }
          }
          {
#line 635
          memcpy((void */* __restrict  */)__o___79->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len___49);
#line 635
          __o___79->next_free += __len___49;
          }
#line 635
          goto switch_break___9;
          case_64___9: /* CIL Label */ 
          {
#line 635
          __o___80 = & muscle_obstack;
#line 635
          tmp___123 = strlen("@@");
#line 635
          __len___50 = (int )tmp___123;
          }
#line 635
          if ((unsigned long )(__o___80->next_free + __len___50) > (unsigned long )__o___80->chunk_limit) {
            {
#line 635
            _obstack_newchunk(__o___80, __len___50);
            }
          }
          {
#line 635
          memcpy((void */* __restrict  */)__o___80->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___50);
#line 635
          __o___80->next_free += __len___50;
          }
#line 635
          goto switch_break___9;
          case_91___9: /* CIL Label */ 
          {
#line 635
          __o___81 = & muscle_obstack;
#line 635
          tmp___124 = strlen("@{");
#line 635
          __len___51 = (int )tmp___124;
          }
#line 635
          if ((unsigned long )(__o___81->next_free + __len___51) > (unsigned long )__o___81->chunk_limit) {
            {
#line 635
            _obstack_newchunk(__o___81, __len___51);
            }
          }
          {
#line 635
          memcpy((void */* __restrict  */)__o___81->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___51);
#line 635
          __o___81->next_free += __len___51;
          }
#line 635
          goto switch_break___9;
          case_93___9: /* CIL Label */ 
          {
#line 635
          __o___82 = & muscle_obstack;
#line 635
          tmp___125 = strlen("@}");
#line 635
          __len___52 = (int )tmp___125;
          }
#line 635
          if ((unsigned long )(__o___82->next_free + __len___52) > (unsigned long )__o___82->chunk_limit) {
            {
#line 635
            _obstack_newchunk(__o___82, __len___52);
            }
          }
          {
#line 635
          memcpy((void */* __restrict  */)__o___82->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___52);
#line 635
          __o___82->next_free += __len___52;
          }
#line 635
          goto switch_break___9;
          switch_default___9: /* CIL Label */ 
#line 635
          __o___83 = & muscle_obstack;
#line 635
          if ((unsigned long )(__o___83->next_free + 1) > (unsigned long )__o___83->chunk_limit) {
            {
#line 635
            _obstack_newchunk(__o___83, 1);
            }
          }
#line 635
          tmp___126 = __o___83->next_free;
#line 635
          (__o___83->next_free) ++;
#line 635
          *tmp___126 = (char )*p___9;
#line 635
          goto switch_break___9;
          switch_break___9: /* CIL Label */ ;
          }
#line 635
          p___9 ++;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 635
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
#line 635
      __o___84 = & muscle_obstack;
#line 635
      if ((unsigned long )(__o___84->next_free + 1) > (unsigned long )__o___84->chunk_limit) {
        {
#line 635
        _obstack_newchunk(__o___84, 1);
        }
      }
#line 635
      tmp___127 = __o___84->next_free;
#line 635
      (__o___84->next_free) ++;
#line 635
      *tmp___127 = (char)0;
#line 635
      __o1___19 = & muscle_obstack;
#line 635
      __value___19 = (void *)__o1___19->object_base;
#line 635
      if ((unsigned long )__o1___19->next_free == (unsigned long )__value___19) {
#line 635
        __o1___19->maybe_empty_object = 1U;
      }
#line 635
      if (sizeof(int ) < sizeof(void *)) {
#line 635
        tmp___128 = __o1___19->object_base;
      } else {
#line 635
        tmp___128 = (char *)0;
      }
#line 635
      if (sizeof(int ) < sizeof(void *)) {
#line 635
        tmp___129 = __o1___19->object_base;
      } else {
#line 635
        tmp___129 = (char *)0;
      }
#line 635
      __o1___19->next_free = tmp___128 + (((__o1___19->next_free - tmp___129) + (long )__o1___19->alignment_mask) & (long )(~ __o1___19->alignment_mask));
#line 635
      if (__o1___19->next_free - (char *)__o1___19->chunk > __o1___19->chunk_limit - (char *)__o1___19->chunk) {
#line 635
        __o1___19->next_free = __o1___19->chunk_limit;
      }
      {
#line 635
      __o1___19->object_base = __o1___19->next_free;
#line 635
      muscle_insert("skeleton", (char const   *)__value___19);
      }
#line 635
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
  } else {
#line 637
    skeleton = (char const   *)(language->skeleton);
  }
  {
#line 644
  while (1) {
    while_continue___62: /* CIL Label */ ;
    {
#line 644
    __o___85 = & muscle_obstack;
#line 644
    tmp___130 = compute_pkgdatadir();
#line 644
    tmp___131 = strlen(tmp___130);
#line 644
    __len___53 = (int )tmp___131;
    }
#line 644
    if ((unsigned long )(__o___85->next_free + __len___53) > (unsigned long )__o___85->chunk_limit) {
      {
#line 644
      _obstack_newchunk(__o___85, __len___53);
      }
    }
    {
#line 644
    tmp___132 = compute_pkgdatadir();
#line 644
    memcpy((void */* __restrict  */)__o___85->next_free, (void const   */* __restrict  */)tmp___132,
           (size_t )__len___53);
#line 644
    __o___85->next_free += __len___53;
#line 644
    __o___86 = & muscle_obstack;
    }
#line 644
    if ((unsigned long )(__o___86->next_free + 1) > (unsigned long )__o___86->chunk_limit) {
      {
#line 644
      _obstack_newchunk(__o___86, 1);
      }
    }
#line 644
    tmp___133 = __o___86->next_free;
#line 644
    (__o___86->next_free) ++;
#line 644
    *tmp___133 = (char)0;
#line 644
    __o1___20 = & muscle_obstack;
#line 644
    __value___20 = (void *)__o1___20->object_base;
#line 644
    if ((unsigned long )__o1___20->next_free == (unsigned long )__value___20) {
#line 644
      __o1___20->maybe_empty_object = 1U;
    }
#line 644
    if (sizeof(int ) < sizeof(void *)) {
#line 644
      tmp___134 = __o1___20->object_base;
    } else {
#line 644
      tmp___134 = (char *)0;
    }
#line 644
    if (sizeof(int ) < sizeof(void *)) {
#line 644
      tmp___135 = __o1___20->object_base;
    } else {
#line 644
      tmp___135 = (char *)0;
    }
#line 644
    __o1___20->next_free = tmp___134 + (((__o1___20->next_free - tmp___135) + (long )__o1___20->alignment_mask) & (long )(~ __o1___20->alignment_mask));
#line 644
    if (__o1___20->next_free - (char *)__o1___20->chunk > __o1___20->chunk_limit - (char *)__o1___20->chunk) {
#line 644
      __o1___20->next_free = __o1___20->chunk_limit;
    }
    {
#line 644
    __o1___20->object_base = __o1___20->next_free;
#line 644
    muscle_insert("pkgdatadir", (char const   *)__value___20);
    }
#line 644
    goto while_break___62;
  }
  while_break___62: /* CIL Label */ ;
  }
#line 646
  return;
}
}
#line 653 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
void output(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 656
  _obstack_begin(& format_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 658
  prepare_symbols();
#line 659
  prepare_rules();
#line 660
  prepare_states();
#line 661
  prepare_actions();
#line 663
  prepare();
#line 666
  output_skeleton();
#line 668
  __o = & format_obstack;
#line 668
  __obj = (void *)0;
  }
#line 668
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 668
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 668
      tmp = (char *)__obj;
#line 668
      __o->object_base = tmp;
#line 668
      __o->next_free = tmp;
    } else {
      {
#line 668
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 668
    obstack_free(__o, __obj);
    }
  }
#line 669
  return;
}
}
#line 671 "/home/pronto/abs/test-suite/bison-2.4/src/output.c"
char const   *compute_pkgdatadir(void) 
{ 
  char const   *pkgdatadir ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 674
  tmp = getenv("BISON_PKGDATADIR");
#line 674
  pkgdatadir = (char const   *)tmp;
  }
#line 675
  if (pkgdatadir) {
#line 675
    tmp___0 = pkgdatadir;
  } else {
#line 675
    tmp___0 = "/usr/local/share/bison";
  }
#line 675
  return (tmp___0);
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.h"
_Bool *nullable ;
#line 27
void nullable_compute(void) ;
#line 30
void nullable_free(void) ;
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
_Bool *nullable  =    (_Bool *)((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
static void nullable_print(FILE *out ) 
{ 
  int i ;
  char const   *tmp ;

  {
  {
#line 48
  fputs_unlocked((char const   */* __restrict  */)"NULLABLE\n", (FILE */* __restrict  */)out);
#line 49
  i = ntokens;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < nsyms)) {
#line 49
      goto while_break;
    }
#line 50
    if (*(nullable + (i - ntokens))) {
#line 50
      tmp = "yes";
    } else {
#line 50
      tmp = "no";
    }
    {
#line 50
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s: %s\n",
            (*(symbols + i))->tag, tmp);
#line 49
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
  }
#line 53
  return;
}
}
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
void nullable_compute(void) 
{ 
  rule_number ruleno ;
  symbol_number *s1 ;
  symbol_number *s2 ;
  rule_list *p ;
  symbol_number *squeue ;
  void *tmp ;
  size_t *rcount ;
  void *tmp___0 ;
  rule_list **rsets ;
  void *tmp___1 ;
  rule_list *relts ;
  void *tmp___2 ;
  void *tmp___3 ;
  rule *rules_ruleno ;
  item_number *rp ;
  _Bool any_tokens ;
  rule_number tmp___4 ;
  symbol_number *tmp___5 ;
  symbol_number *tmp___6 ;
  rule *r ;
  symbol_number *tmp___7 ;

  {
  {
#line 63
  tmp = xnmalloc((size_t )nvars, (size_t )sizeof(*squeue));
#line 63
  squeue = (symbol_number *)tmp;
#line 64
  tmp___0 = xcalloc((size_t )nrules, (size_t )sizeof(*rcount));
#line 64
  rcount = (size_t *)tmp___0;
#line 67
  tmp___1 = xcalloc((size_t )nvars, (size_t )sizeof(*rsets));
#line 67
  rsets = (rule_list **)tmp___1;
#line 70
  tmp___2 = xnmalloc((nritems + (unsigned int )nvars) + 1U, (size_t )sizeof(*relts));
#line 70
  relts = (rule_list *)tmp___2;
#line 72
  tmp___3 = xcalloc((size_t )nvars, (size_t )sizeof(*nullable));
#line 72
  nullable = (_Bool *)tmp___3;
#line 74
  s2 = squeue;
#line 74
  s1 = s2;
#line 75
  p = relts;
#line 77
  ruleno = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (ruleno < nrules)) {
#line 77
      goto while_break;
    }
#line 78
    if ((rules + ruleno)->useful) {
#line 80
      rules_ruleno = rules + ruleno;
#line 81
      if (*(rules_ruleno->rhs + 0) >= 0) {
#line 84
        rp = (item_number *)((void *)0);
#line 85
        any_tokens = (_Bool)0;
#line 86
        rp = rules_ruleno->rhs;
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (! (*rp >= 0)) {
#line 86
            goto while_break___0;
          }
#line 87
          if (*rp < ntokens) {
#line 88
            any_tokens = (_Bool)1;
          }
#line 86
          rp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 92
        if (! any_tokens) {
#line 93
          rp = rules_ruleno->rhs;
          {
#line 93
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 93
            if (! (*rp >= 0)) {
#line 93
              goto while_break___1;
            }
#line 95
            (*(rcount + ruleno)) ++;
#line 96
            p->next = *(rsets + (*rp - ntokens));
#line 97
            p->value = rules_ruleno;
#line 98
            *(rsets + (*rp - ntokens)) = p;
#line 99
            p ++;
#line 93
            rp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 105
        tmp___4 = item_number_as_rule_number(*(rules_ruleno->rhs + 0));
#line 105
        aver((_Bool )(tmp___4 == ruleno));
        }
#line 107
        if (rules_ruleno->useful) {
#line 107
          if (! *(nullable + ((rules_ruleno->lhs)->number - ntokens))) {
#line 110
            *(nullable + ((rules_ruleno->lhs)->number - ntokens)) = (_Bool)1;
#line 111
            tmp___5 = s2;
#line 111
            s2 ++;
#line 111
            *tmp___5 = (rules_ruleno->lhs)->number;
          }
        }
      }
    }
#line 77
    ruleno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )s1 < (unsigned long )s2)) {
#line 116
      goto while_break___2;
    }
#line 117
    tmp___6 = s1;
#line 117
    s1 ++;
#line 117
    p = *(rsets + (*tmp___6 - ntokens));
    {
#line 117
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 117
      if (! p) {
#line 117
        goto while_break___3;
      }
#line 119
      r = p->value;
#line 120
      (*(rcount + r->number)) --;
#line 120
      if (*(rcount + r->number) == 0U) {
#line 121
        if (r->useful) {
#line 121
          if (! *(nullable + ((r->lhs)->number - ntokens))) {
#line 123
            *(nullable + ((r->lhs)->number - ntokens)) = (_Bool)1;
#line 124
            tmp___7 = s2;
#line 124
            s2 ++;
#line 124
            *tmp___7 = (r->lhs)->number;
          }
        }
      }
#line 117
      p = p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 128
  free((void *)squeue);
#line 129
  free((void *)rcount);
#line 130
  free((void *)rsets);
#line 131
  free((void *)relts);
  }
#line 133
  if (trace_flag & 8) {
    {
#line 134
    nullable_print(stderr);
    }
  }
#line 135
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/bison-2.4/src/nullable.c"
void nullable_free(void) 
{ 


  {
  {
#line 141
  free((void *)nullable);
  }
#line 142
  return;
}
}
#line 24 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.h"
void muscle_init(void) ;
#line 27
char *muscle_find(char const   *key ) ;
#line 28
void muscle_free(void) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.h"
struct obstack muscle_obstack  ;
#line 95
void muscle_grow(char const   *key , char const   *val , char const   *separator ) ;
#line 113
void muscle_location_grow(char const   *key , location loc___0 ) ;
#line 117
void muscle_boundary_grow(char const   *key , boundary bound ) ;
#line 122
void muscle_user_name_list_grow(char const   *key , char const   *user_name , location loc___0 ) ;
#line 137
char *muscle_percent_define_get(char const   *variable ) ;
#line 145
location muscle_percent_define_get_loc(char const   *variable ) ;
#line 153
char const   *muscle_percent_define_get_syncline(char const   *variable ) ;
#line 159
_Bool muscle_percent_define_ifdef(char const   *variable ) ;
#line 173
void muscle_percent_define_default(char const   *variable , char const   *value ) ;
#line 186
void muscle_percent_define_check_values(char const   * const  *values ) ;
#line 47 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static struct hash_table *muscle_table  =    (struct hash_table *)((void *)0);
#line 49 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static _Bool hash_compare_muscles(void const   *x , void const   *y ) 
{ 
  muscle_entry const   *m1 ;
  muscle_entry const   *m2 ;
  int tmp ;

  {
  {
#line 52
  m1 = (muscle_entry const   *)x;
#line 53
  m2 = (muscle_entry const   *)y;
#line 54
  tmp = strcmp((char const   *)m1->key, (char const   *)m2->key);
  }
#line 54
  return ((_Bool )(tmp == 0));
}
}
#line 57 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static size_t hash_muscle(void const   *x , size_t tablesize ) 
{ 
  muscle_entry const   *m ;
  size_t tmp ;

  {
  {
#line 60
  m = (muscle_entry const   *)x;
#line 61
  tmp = hash_string((char const   *)m->key, tablesize);
  }
#line 61
  return (tmp);
}
}
#line 69 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static void muscle_entry_free(void *entry ) 
{ 
  muscle_entry *mentry ;

  {
  {
#line 72
  mentry = (muscle_entry *)entry;
#line 73
  free((void *)mentry->storage);
#line 74
  free((void *)mentry);
  }
#line 75
  return;
}
}
#line 77 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_init(void) 
{ 
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *p___0 ;
  char *tmp___7 ;
  struct obstack *__o___5 ;
  int __len___3 ;
  size_t tmp___8 ;
  struct obstack *__o___6 ;
  int __len___4 ;
  size_t tmp___9 ;
  struct obstack *__o___7 ;
  int __len___5 ;
  size_t tmp___10 ;
  struct obstack *__o___8 ;
  int __len___6 ;
  size_t tmp___11 ;
  struct obstack *__o___9 ;
  char *tmp___12 ;
  struct obstack *__o___10 ;
  char *tmp___13 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 81
  _obstack_begin(& muscle_obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 83
  muscle_table = hash_initialize((size_t )257, (Hash_tuning const   *)((void *)0),
                                 & hash_muscle, & hash_compare_muscles, & muscle_entry_free);
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 87
      p = "2.4";
      {
#line 87
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 87
        if (! *p) {
#line 87
          goto while_break___1;
        }
        {
#line 87
        if ((int const   )*p == 36) {
#line 87
          goto case_36;
        }
#line 87
        if ((int const   )*p == 64) {
#line 87
          goto case_64;
        }
#line 87
        if ((int const   )*p == 91) {
#line 87
          goto case_91;
        }
#line 87
        if ((int const   )*p == 93) {
#line 87
          goto case_93;
        }
#line 87
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 87
        __o = & muscle_obstack;
#line 87
        tmp = strlen("$][");
#line 87
        __len = (int )tmp;
        }
#line 87
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 87
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 87
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len);
#line 87
        __o->next_free += __len;
        }
#line 87
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 87
        __o___0 = & muscle_obstack;
#line 87
        tmp___0 = strlen("@@");
#line 87
        __len___0 = (int )tmp___0;
        }
#line 87
        if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
          {
#line 87
          _obstack_newchunk(__o___0, __len___0);
          }
        }
        {
#line 87
        memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___0);
#line 87
        __o___0->next_free += __len___0;
        }
#line 87
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 87
        __o___1 = & muscle_obstack;
#line 87
        tmp___1 = strlen("@{");
#line 87
        __len___1 = (int )tmp___1;
        }
#line 87
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 87
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 87
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___1);
#line 87
        __o___1->next_free += __len___1;
        }
#line 87
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 87
        __o___2 = & muscle_obstack;
#line 87
        tmp___2 = strlen("@}");
#line 87
        __len___2 = (int )tmp___2;
        }
#line 87
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 87
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 87
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___2);
#line 87
        __o___2->next_free += __len___2;
        }
#line 87
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 87
        __o___3 = & muscle_obstack;
#line 87
        if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 87
          _obstack_newchunk(__o___3, 1);
          }
        }
#line 87
        tmp___3 = __o___3->next_free;
#line 87
        (__o___3->next_free) ++;
#line 87
        *tmp___3 = (char )*p;
#line 87
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 87
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 87
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    __o___4 = & muscle_obstack;
#line 87
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 87
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 87
    tmp___4 = __o___4->next_free;
#line 87
    (__o___4->next_free) ++;
#line 87
    *tmp___4 = (char)0;
#line 87
    __o1 = & muscle_obstack;
#line 87
    __value = (void *)__o1->object_base;
#line 87
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 87
      __o1->maybe_empty_object = 1U;
    }
#line 87
    if (sizeof(int ) < sizeof(void *)) {
#line 87
      tmp___5 = __o1->object_base;
    } else {
#line 87
      tmp___5 = (char *)0;
    }
#line 87
    if (sizeof(int ) < sizeof(void *)) {
#line 87
      tmp___6 = __o1->object_base;
    } else {
#line 87
      tmp___6 = (char *)0;
    }
#line 87
    __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 87
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 87
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 87
    __o1->object_base = __o1->next_free;
#line 87
    muscle_insert("version", (char const   *)__value);
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 88
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 88
      tmp___7 = quotearg_style((enum quoting_style )3, grammar_file);
#line 88
      p___0 = (char const   *)tmp___7;
      }
      {
#line 88
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 88
        if (! *p___0) {
#line 88
          goto while_break___4;
        }
        {
#line 88
        if ((int const   )*p___0 == 36) {
#line 88
          goto case_36___0;
        }
#line 88
        if ((int const   )*p___0 == 64) {
#line 88
          goto case_64___0;
        }
#line 88
        if ((int const   )*p___0 == 91) {
#line 88
          goto case_91___0;
        }
#line 88
        if ((int const   )*p___0 == 93) {
#line 88
          goto case_93___0;
        }
#line 88
        goto switch_default___0;
        case_36___0: /* CIL Label */ 
        {
#line 88
        __o___5 = & muscle_obstack;
#line 88
        tmp___8 = strlen("$][");
#line 88
        __len___3 = (int )tmp___8;
        }
#line 88
        if ((unsigned long )(__o___5->next_free + __len___3) > (unsigned long )__o___5->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___5, __len___3);
          }
        }
        {
#line 88
        memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len___3);
#line 88
        __o___5->next_free += __len___3;
        }
#line 88
        goto switch_break___0;
        case_64___0: /* CIL Label */ 
        {
#line 88
        __o___6 = & muscle_obstack;
#line 88
        tmp___9 = strlen("@@");
#line 88
        __len___4 = (int )tmp___9;
        }
#line 88
        if ((unsigned long )(__o___6->next_free + __len___4) > (unsigned long )__o___6->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___6, __len___4);
          }
        }
        {
#line 88
        memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___4);
#line 88
        __o___6->next_free += __len___4;
        }
#line 88
        goto switch_break___0;
        case_91___0: /* CIL Label */ 
        {
#line 88
        __o___7 = & muscle_obstack;
#line 88
        tmp___10 = strlen("@{");
#line 88
        __len___5 = (int )tmp___10;
        }
#line 88
        if ((unsigned long )(__o___7->next_free + __len___5) > (unsigned long )__o___7->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___7, __len___5);
          }
        }
        {
#line 88
        memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___5);
#line 88
        __o___7->next_free += __len___5;
        }
#line 88
        goto switch_break___0;
        case_93___0: /* CIL Label */ 
        {
#line 88
        __o___8 = & muscle_obstack;
#line 88
        tmp___11 = strlen("@}");
#line 88
        __len___6 = (int )tmp___11;
        }
#line 88
        if ((unsigned long )(__o___8->next_free + __len___6) > (unsigned long )__o___8->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___8, __len___6);
          }
        }
        {
#line 88
        memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___6);
#line 88
        __o___8->next_free += __len___6;
        }
#line 88
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 88
        __o___9 = & muscle_obstack;
#line 88
        if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___9, 1);
          }
        }
#line 88
        tmp___12 = __o___9->next_free;
#line 88
        (__o___9->next_free) ++;
#line 88
        *tmp___12 = (char )*p___0;
#line 88
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 88
        p___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 88
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 88
    __o___10 = & muscle_obstack;
#line 88
    if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
      {
#line 88
      _obstack_newchunk(__o___10, 1);
      }
    }
#line 88
    tmp___13 = __o___10->next_free;
#line 88
    (__o___10->next_free) ++;
#line 88
    *tmp___13 = (char)0;
#line 88
    __o1___0 = & muscle_obstack;
#line 88
    __value___0 = (void *)__o1___0->object_base;
#line 88
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 88
      __o1___0->maybe_empty_object = 1U;
    }
#line 88
    if (sizeof(int ) < sizeof(void *)) {
#line 88
      tmp___14 = __o1___0->object_base;
    } else {
#line 88
      tmp___14 = (char *)0;
    }
#line 88
    if (sizeof(int ) < sizeof(void *)) {
#line 88
      tmp___15 = __o1___0->object_base;
    } else {
#line 88
      tmp___15 = (char *)0;
    }
#line 88
    __o1___0->next_free = tmp___14 + (((__o1___0->next_free - tmp___15) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 88
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 88
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 88
    __o1___0->object_base = __o1___0->next_free;
#line 88
    muscle_insert("file_name", (char const   *)__value___0);
    }
#line 88
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 99
  hash_free(muscle_table);
#line 100
  __o = & muscle_obstack;
#line 100
  __obj = (void *)0;
  }
#line 100
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 100
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 100
      tmp = (char *)__obj;
#line 100
      __o->object_base = tmp;
#line 100
      __o->next_free = tmp;
    } else {
      {
#line 100
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 100
    obstack_free(__o, __obj);
    }
  }
#line 101
  return;
}
}
#line 110 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_insert(char const   *key , char const   *value ) 
{ 
  muscle_entry probe ;
  muscle_entry *entry ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 116
  probe.key = key;
#line 117
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 117
  entry = (muscle_entry *)tmp;
  }
#line 119
  if (! entry) {
    {
#line 122
    tmp___0 = xmalloc((size_t )sizeof(*entry));
#line 122
    entry = (muscle_entry *)tmp___0;
#line 123
    entry->key = key;
#line 124
    hash_insert(muscle_table, (void const   *)entry);
    }
  } else {
    {
#line 127
    free((void *)entry->storage);
    }
  }
#line 128
  entry->value = value;
#line 129
  entry->storage = (char *)((void *)0);
#line 130
  return;
}
}
#line 139 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_grow(char const   *key , char const   *val , char const   *separator ) 
{ 
  muscle_entry probe ;
  muscle_entry *entry ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *new_val ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___2 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___3 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___4 ;
  struct obstack *__o___2 ;
  char *tmp___5 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct obstack *__o___3 ;
  void *__obj ;
  char *tmp___9 ;

  {
  {
#line 143
  entry = (muscle_entry *)((void *)0);
#line 145
  probe.key = key;
#line 146
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 146
  entry = (muscle_entry *)tmp;
  }
#line 148
  if (! entry) {
    {
#line 151
    tmp___0 = xmalloc((size_t )sizeof(*entry));
#line 151
    entry = (muscle_entry *)tmp___0;
#line 152
    entry->key = key;
#line 153
    hash_insert(muscle_table, (void const   *)entry);
#line 154
    tmp___1 = xstrdup(val);
#line 154
    entry->storage = tmp___1;
#line 154
    entry->value = (char const   *)tmp___1;
    }
  } else {
    {
#line 160
    __o = & muscle_obstack;
#line 160
    tmp___2 = strlen(entry->value);
#line 160
    __len = (int )tmp___2;
    }
#line 160
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 160
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 160
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)entry->value,
           (size_t )__len);
#line 160
    __o->next_free += __len;
#line 161
    free((void *)entry->storage);
#line 162
    __o___0 = & muscle_obstack;
#line 162
    tmp___3 = strlen(separator);
#line 162
    __len___0 = (int )tmp___3;
    }
#line 162
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 162
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 162
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)separator,
           (size_t )__len___0);
#line 162
    __o___0->next_free += __len___0;
#line 163
    __o___1 = & muscle_obstack;
#line 163
    tmp___4 = strlen(val);
#line 163
    __len___1 = (int )tmp___4;
    }
#line 163
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 163
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 163
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)val,
           (size_t )__len___1);
#line 163
    __o___1->next_free += __len___1;
#line 164
    __o___2 = & muscle_obstack;
    }
#line 164
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 164
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 164
    tmp___5 = __o___2->next_free;
#line 164
    (__o___2->next_free) ++;
#line 164
    *tmp___5 = (char)0;
#line 165
    __o1 = & muscle_obstack;
#line 165
    __value = (void *)__o1->object_base;
#line 165
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 165
      __o1->maybe_empty_object = 1U;
    }
#line 165
    if (sizeof(int ) < sizeof(void *)) {
#line 165
      tmp___6 = __o1->object_base;
    } else {
#line 165
      tmp___6 = (char *)0;
    }
#line 165
    if (sizeof(int ) < sizeof(void *)) {
#line 165
      tmp___7 = __o1->object_base;
    } else {
#line 165
      tmp___7 = (char *)0;
    }
#line 165
    __o1->next_free = tmp___6 + (((__o1->next_free - tmp___7) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 165
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 165
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 165
    __o1->object_base = __o1->next_free;
#line 165
    new_val = (char *)__value;
#line 166
    tmp___8 = xstrdup((char const   *)new_val);
#line 166
    entry->storage = tmp___8;
#line 166
    entry->value = (char const   *)tmp___8;
#line 167
    __o___3 = & muscle_obstack;
#line 167
    __obj = (void *)new_val;
    }
#line 167
    if ((unsigned long )__obj > (unsigned long )((void *)__o___3->chunk)) {
#line 167
      if ((unsigned long )__obj < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 167
        tmp___9 = (char *)__obj;
#line 167
        __o___3->object_base = tmp___9;
#line 167
        __o___3->next_free = tmp___9;
      } else {
        {
#line 167
        obstack_free(__o___3, __obj);
        }
      }
    } else {
      {
#line 167
      obstack_free(__o___3, __obj);
      }
    }
  }
#line 169
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static void muscle_syncline_grow(char const   *key , location loc___0 ) 
{ 
  char *extension ;
  char buf___0[4096] ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  char const   *p ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___3 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___4 ;
  struct obstack *__o___4 ;
  char *tmp___5 ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___6 ;
  struct obstack *__o___6 ;
  char *tmp___7 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct obstack *__o___7 ;
  void *__obj ;
  char *tmp___10 ;

  {
#line 179
  extension = (char *)((void *)0);
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"]b4_syncline(%d, [[",
            loc___0.start.line);
#line 180
    __o = & muscle_obstack;
#line 180
    tmp = strlen((char const   *)(buf___0));
#line 180
    __len = (int )tmp;
    }
#line 180
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 180
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 180
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len);
#line 180
    __o->next_free += __len;
    }
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 181
    tmp___0 = quotearg_style((enum quoting_style )3, loc___0.start.file);
#line 181
    p = (char const   *)tmp___0;
    }
    {
#line 181
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 181
      if (! *p) {
#line 181
        goto while_break___1;
      }
      {
#line 181
      if ((int const   )*p == 36) {
#line 181
        goto case_36;
      }
#line 181
      if ((int const   )*p == 64) {
#line 181
        goto case_64;
      }
#line 181
      if ((int const   )*p == 91) {
#line 181
        goto case_91;
      }
#line 181
      if ((int const   )*p == 93) {
#line 181
        goto case_93;
      }
#line 181
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 181
      __o___0 = & muscle_obstack;
#line 181
      tmp___1 = strlen("$][");
#line 181
      __len___0 = (int )tmp___1;
      }
#line 181
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___0);
#line 181
      __o___0->next_free += __len___0;
      }
#line 181
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 181
      __o___1 = & muscle_obstack;
#line 181
      tmp___2 = strlen("@@");
#line 181
      __len___1 = (int )tmp___2;
      }
#line 181
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___1);
#line 181
      __o___1->next_free += __len___1;
      }
#line 181
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 181
      __o___2 = & muscle_obstack;
#line 181
      tmp___3 = strlen("@{");
#line 181
      __len___2 = (int )tmp___3;
      }
#line 181
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___2);
#line 181
      __o___2->next_free += __len___2;
      }
#line 181
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 181
      __o___3 = & muscle_obstack;
#line 181
      tmp___4 = strlen("@}");
#line 181
      __len___3 = (int )tmp___4;
      }
#line 181
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 181
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___3);
#line 181
      __o___3->next_free += __len___3;
      }
#line 181
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 181
      __o___4 = & muscle_obstack;
#line 181
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 181
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 181
      tmp___5 = __o___4->next_free;
#line 181
      (__o___4->next_free) ++;
#line 181
      *tmp___5 = (char )*p;
#line 181
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 181
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 181
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 183
  __o___5 = & muscle_obstack;
#line 183
  tmp___6 = strlen("]])[");
#line 183
  __len___4 = (int )tmp___6;
  }
#line 183
  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
    {
#line 183
    _obstack_newchunk(__o___5, __len___4);
    }
  }
  {
#line 183
  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)"]])[",
         (size_t )__len___4);
#line 183
  __o___5->next_free += __len___4;
#line 184
  __o___6 = & muscle_obstack;
  }
#line 184
  if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
    {
#line 184
    _obstack_newchunk(__o___6, 1);
    }
  }
#line 184
  tmp___7 = __o___6->next_free;
#line 184
  (__o___6->next_free) ++;
#line 184
  *tmp___7 = (char)0;
#line 185
  __o1 = & muscle_obstack;
#line 185
  __value = (void *)__o1->object_base;
#line 185
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 185
    __o1->maybe_empty_object = 1U;
  }
#line 185
  if (sizeof(int ) < sizeof(void *)) {
#line 185
    tmp___8 = __o1->object_base;
  } else {
#line 185
    tmp___8 = (char *)0;
  }
#line 185
  if (sizeof(int ) < sizeof(void *)) {
#line 185
    tmp___9 = __o1->object_base;
  } else {
#line 185
    tmp___9 = (char *)0;
  }
#line 185
  __o1->next_free = tmp___8 + (((__o1->next_free - tmp___9) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 185
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 185
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 185
  __o1->object_base = __o1->next_free;
#line 185
  extension = (char *)__value;
#line 186
  muscle_grow(key, (char const   *)extension, "");
#line 187
  __o___7 = & muscle_obstack;
#line 187
  __obj = (void *)extension;
  }
#line 187
  if ((unsigned long )__obj > (unsigned long )((void *)__o___7->chunk)) {
#line 187
    if ((unsigned long )__obj < (unsigned long )((void *)__o___7->chunk_limit)) {
#line 187
      tmp___10 = (char *)__obj;
#line 187
      __o___7->object_base = tmp___10;
#line 187
      __o___7->next_free = tmp___10;
    } else {
      {
#line 187
      obstack_free(__o___7, __obj);
      }
    }
  } else {
    {
#line 187
    obstack_free(__o___7, __obj);
    }
  }
#line 188
  return;
}
}
#line 196 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_code_grow(char const   *key , char const   *val , location loc___0 ) 
{ 


  {
  {
#line 199
  muscle_syncline_grow(key, loc___0);
#line 200
  muscle_grow(key, val, "\n");
  }
#line 201
  return;
}
}
#line 204 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_pair_list_grow(char const   *muscle , char const   *a1 , char const   *a2 ) 
{ 
  char *pair ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  char const   *p ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  struct obstack *__o___5 ;
  int __len___4 ;
  size_t tmp___5 ;
  char const   *p___0 ;
  struct obstack *__o___6 ;
  int __len___5 ;
  size_t tmp___6 ;
  struct obstack *__o___7 ;
  int __len___6 ;
  size_t tmp___7 ;
  struct obstack *__o___8 ;
  int __len___7 ;
  size_t tmp___8 ;
  struct obstack *__o___9 ;
  int __len___8 ;
  size_t tmp___9 ;
  struct obstack *__o___10 ;
  char *tmp___10 ;
  struct obstack *__o___11 ;
  int __len___9 ;
  size_t tmp___11 ;
  struct obstack *__o___12 ;
  char *tmp___12 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___13 ;
  char *tmp___14 ;
  struct obstack *__o___13 ;
  void *__obj ;
  char *tmp___15 ;

  {
  {
#line 208
  __o = & muscle_obstack;
#line 208
  tmp = strlen("[[[");
#line 208
  __len = (int )tmp;
  }
#line 208
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 208
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 208
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"[[[",
         (size_t )__len);
#line 208
  __o->next_free += __len;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    p = a1;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! *p) {
#line 209
        goto while_break___0;
      }
      {
#line 209
      if ((int const   )*p == 36) {
#line 209
        goto case_36;
      }
#line 209
      if ((int const   )*p == 64) {
#line 209
        goto case_64;
      }
#line 209
      if ((int const   )*p == 91) {
#line 209
        goto case_91;
      }
#line 209
      if ((int const   )*p == 93) {
#line 209
        goto case_93;
      }
#line 209
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 209
      __o___0 = & muscle_obstack;
#line 209
      tmp___0 = strlen("$][");
#line 209
      __len___0 = (int )tmp___0;
      }
#line 209
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___0);
#line 209
      __o___0->next_free += __len___0;
      }
#line 209
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 209
      __o___1 = & muscle_obstack;
#line 209
      tmp___1 = strlen("@@");
#line 209
      __len___1 = (int )tmp___1;
      }
#line 209
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___1);
#line 209
      __o___1->next_free += __len___1;
      }
#line 209
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 209
      __o___2 = & muscle_obstack;
#line 209
      tmp___2 = strlen("@{");
#line 209
      __len___2 = (int )tmp___2;
      }
#line 209
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___2);
#line 209
      __o___2->next_free += __len___2;
      }
#line 209
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 209
      __o___3 = & muscle_obstack;
#line 209
      tmp___3 = strlen("@}");
#line 209
      __len___3 = (int )tmp___3;
      }
#line 209
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 209
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___3);
#line 209
      __o___3->next_free += __len___3;
      }
#line 209
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 209
      __o___4 = & muscle_obstack;
#line 209
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 209
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 209
      tmp___4 = __o___4->next_free;
#line 209
      (__o___4->next_free) ++;
#line 209
      *tmp___4 = (char )*p;
#line 209
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 209
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  __o___5 = & muscle_obstack;
#line 210
  tmp___5 = strlen("]], [[");
#line 210
  __len___4 = (int )tmp___5;
  }
#line 210
  if ((unsigned long )(__o___5->next_free + __len___4) > (unsigned long )__o___5->chunk_limit) {
    {
#line 210
    _obstack_newchunk(__o___5, __len___4);
    }
  }
  {
#line 210
  memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)"]], [[",
         (size_t )__len___4);
#line 210
  __o___5->next_free += __len___4;
  }
  {
#line 211
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 211
    p___0 = a2;
    {
#line 211
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 211
      if (! *p___0) {
#line 211
        goto while_break___2;
      }
      {
#line 211
      if ((int const   )*p___0 == 36) {
#line 211
        goto case_36___0;
      }
#line 211
      if ((int const   )*p___0 == 64) {
#line 211
        goto case_64___0;
      }
#line 211
      if ((int const   )*p___0 == 91) {
#line 211
        goto case_91___0;
      }
#line 211
      if ((int const   )*p___0 == 93) {
#line 211
        goto case_93___0;
      }
#line 211
      goto switch_default___0;
      case_36___0: /* CIL Label */ 
      {
#line 211
      __o___6 = & muscle_obstack;
#line 211
      tmp___6 = strlen("$][");
#line 211
      __len___5 = (int )tmp___6;
      }
#line 211
      if ((unsigned long )(__o___6->next_free + __len___5) > (unsigned long )__o___6->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___6, __len___5);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len___5);
#line 211
      __o___6->next_free += __len___5;
      }
#line 211
      goto switch_break___0;
      case_64___0: /* CIL Label */ 
      {
#line 211
      __o___7 = & muscle_obstack;
#line 211
      tmp___7 = strlen("@@");
#line 211
      __len___6 = (int )tmp___7;
      }
#line 211
      if ((unsigned long )(__o___7->next_free + __len___6) > (unsigned long )__o___7->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___7, __len___6);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___6);
#line 211
      __o___7->next_free += __len___6;
      }
#line 211
      goto switch_break___0;
      case_91___0: /* CIL Label */ 
      {
#line 211
      __o___8 = & muscle_obstack;
#line 211
      tmp___8 = strlen("@{");
#line 211
      __len___7 = (int )tmp___8;
      }
#line 211
      if ((unsigned long )(__o___8->next_free + __len___7) > (unsigned long )__o___8->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___8, __len___7);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___7);
#line 211
      __o___8->next_free += __len___7;
      }
#line 211
      goto switch_break___0;
      case_93___0: /* CIL Label */ 
      {
#line 211
      __o___9 = & muscle_obstack;
#line 211
      tmp___9 = strlen("@}");
#line 211
      __len___8 = (int )tmp___9;
      }
#line 211
      if ((unsigned long )(__o___9->next_free + __len___8) > (unsigned long )__o___9->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___9, __len___8);
        }
      }
      {
#line 211
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___8);
#line 211
      __o___9->next_free += __len___8;
      }
#line 211
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 211
      __o___10 = & muscle_obstack;
#line 211
      if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
        {
#line 211
        _obstack_newchunk(__o___10, 1);
        }
      }
#line 211
      tmp___10 = __o___10->next_free;
#line 211
      (__o___10->next_free) ++;
#line 211
      *tmp___10 = (char )*p___0;
#line 211
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 211
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 211
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  __o___11 = & muscle_obstack;
#line 212
  tmp___11 = strlen("]]]");
#line 212
  __len___9 = (int )tmp___11;
  }
#line 212
  if ((unsigned long )(__o___11->next_free + __len___9) > (unsigned long )__o___11->chunk_limit) {
    {
#line 212
    _obstack_newchunk(__o___11, __len___9);
    }
  }
  {
#line 212
  memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)"]]]",
         (size_t )__len___9);
#line 212
  __o___11->next_free += __len___9;
#line 213
  __o___12 = & muscle_obstack;
  }
#line 213
  if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
    {
#line 213
    _obstack_newchunk(__o___12, 1);
    }
  }
#line 213
  tmp___12 = __o___12->next_free;
#line 213
  (__o___12->next_free) ++;
#line 213
  *tmp___12 = (char)0;
#line 214
  __o1 = & muscle_obstack;
#line 214
  __value = (void *)__o1->object_base;
#line 214
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 214
    __o1->maybe_empty_object = 1U;
  }
#line 214
  if (sizeof(int ) < sizeof(void *)) {
#line 214
    tmp___13 = __o1->object_base;
  } else {
#line 214
    tmp___13 = (char *)0;
  }
#line 214
  if (sizeof(int ) < sizeof(void *)) {
#line 214
    tmp___14 = __o1->object_base;
  } else {
#line 214
    tmp___14 = (char *)0;
  }
#line 214
  __o1->next_free = tmp___13 + (((__o1->next_free - tmp___14) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 214
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 214
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 214
  __o1->object_base = __o1->next_free;
#line 214
  pair = (char *)__value;
#line 215
  muscle_grow(muscle, (char const   *)pair, ",\n");
#line 216
  __o___13 = & muscle_obstack;
#line 216
  __obj = (void *)pair;
  }
#line 216
  if ((unsigned long )__obj > (unsigned long )((void *)__o___13->chunk)) {
#line 216
    if ((unsigned long )__obj < (unsigned long )((void *)__o___13->chunk_limit)) {
#line 216
      tmp___15 = (char *)__obj;
#line 216
      __o___13->object_base = tmp___15;
#line 216
      __o___13->next_free = tmp___15;
    } else {
      {
#line 216
      obstack_free(__o___13, __obj);
      }
    }
  } else {
    {
#line 216
    obstack_free(__o___13, __obj);
    }
  }
#line 217
  return;
}
}
#line 225 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
char const   *muscle_find_const(char const   *key ) 
{ 
  muscle_entry probe ;
  muscle_entry *result ;
  void *tmp ;

  {
  {
#line 229
  result = (muscle_entry *)((void *)0);
#line 231
  probe.key = key;
#line 232
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 232
  result = (muscle_entry *)tmp;
  }
#line 233
  if (result) {
#line 234
    return (result->value);
  }
#line 235
  return ((char const   *)((void *)0));
}
}
#line 245 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
char *muscle_find(char const   *key ) 
{ 
  muscle_entry probe ;
  muscle_entry *result ;
  void *tmp ;

  {
  {
#line 249
  result = (muscle_entry *)((void *)0);
#line 251
  probe.key = key;
#line 252
  tmp = hash_lookup((Hash_table const   *)muscle_table, (void const   *)(& probe));
#line 252
  result = (muscle_entry *)tmp;
  }
#line 253
  if (result) {
    {
#line 255
    aver((_Bool )((unsigned long )result->value == (unsigned long )result->storage));
    }
#line 256
    return (result->storage);
  }
#line 258
  return ((char *)((void *)0));
}
}
#line 262 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_boundary_grow(char const   *key , boundary bound ) 
{ 
  char *extension ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  struct obstack *__o___4 ;
  char *tmp___4 ;
  char buf___0[4096] ;
  struct obstack *__o___5 ;
  int __len___3 ;
  size_t tmp___5 ;
  struct obstack *__o___6 ;
  char *tmp___6 ;
  char buf___1[4096] ;
  struct obstack *__o___7 ;
  int __len___4 ;
  size_t tmp___7 ;
  struct obstack *__o___8 ;
  char *tmp___8 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct obstack *__o___9 ;
  void *__obj ;
  char *tmp___11 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    p = bound.file;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! *p) {
#line 266
        goto while_break___0;
      }
      {
#line 266
      if ((int const   )*p == 36) {
#line 266
        goto case_36;
      }
#line 266
      if ((int const   )*p == 64) {
#line 266
        goto case_64;
      }
#line 266
      if ((int const   )*p == 91) {
#line 266
        goto case_91;
      }
#line 266
      if ((int const   )*p == 93) {
#line 266
        goto case_93;
      }
#line 266
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 266
      __o = & muscle_obstack;
#line 266
      tmp = strlen("$][");
#line 266
      __len = (int )tmp;
      }
#line 266
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
             (size_t )__len);
#line 266
      __o->next_free += __len;
      }
#line 266
      goto switch_break;
      case_64: /* CIL Label */ 
      {
#line 266
      __o___0 = & muscle_obstack;
#line 266
      tmp___0 = strlen("@@");
#line 266
      __len___0 = (int )tmp___0;
      }
#line 266
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
             (size_t )__len___0);
#line 266
      __o___0->next_free += __len___0;
      }
#line 266
      goto switch_break;
      case_91: /* CIL Label */ 
      {
#line 266
      __o___1 = & muscle_obstack;
#line 266
      tmp___1 = strlen("@{");
#line 266
      __len___1 = (int )tmp___1;
      }
#line 266
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
             (size_t )__len___1);
#line 266
      __o___1->next_free += __len___1;
      }
#line 266
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 266
      __o___2 = & muscle_obstack;
#line 266
      tmp___2 = strlen("@}");
#line 266
      __len___2 = (int )tmp___2;
      }
#line 266
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 266
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
             (size_t )__len___2);
#line 266
      __o___2->next_free += __len___2;
      }
#line 266
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 266
      __o___3 = & muscle_obstack;
#line 266
      if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
        {
#line 266
        _obstack_newchunk(__o___3, 1);
        }
      }
#line 266
      tmp___3 = __o___3->next_free;
#line 266
      (__o___3->next_free) ++;
#line 266
      *tmp___3 = (char )*p;
#line 266
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 266
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  __o___4 = & muscle_obstack;
#line 267
  if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
    {
#line 267
    _obstack_newchunk(__o___4, 1);
    }
  }
#line 267
  tmp___4 = __o___4->next_free;
#line 267
  (__o___4->next_free) ++;
#line 267
  *tmp___4 = (char )':';
  {
#line 268
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 268
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
            bound.line);
#line 268
    __o___5 = & muscle_obstack;
#line 268
    tmp___5 = strlen((char const   *)(buf___0));
#line 268
    __len___3 = (int )tmp___5;
    }
#line 268
    if ((unsigned long )(__o___5->next_free + __len___3) > (unsigned long )__o___5->chunk_limit) {
      {
#line 268
      _obstack_newchunk(__o___5, __len___3);
      }
    }
    {
#line 268
    memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___0),
           (size_t )__len___3);
#line 268
    __o___5->next_free += __len___3;
    }
#line 268
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 269
  __o___6 = & muscle_obstack;
#line 269
  if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
    {
#line 269
    _obstack_newchunk(__o___6, 1);
    }
  }
#line 269
  tmp___6 = __o___6->next_free;
#line 269
  (__o___6->next_free) ++;
#line 269
  *tmp___6 = (char )'.';
  {
#line 270
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 270
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
            bound.column);
#line 270
    __o___7 = & muscle_obstack;
#line 270
    tmp___7 = strlen((char const   *)(buf___1));
#line 270
    __len___4 = (int )tmp___7;
    }
#line 270
    if ((unsigned long )(__o___7->next_free + __len___4) > (unsigned long )__o___7->chunk_limit) {
      {
#line 270
      _obstack_newchunk(__o___7, __len___4);
      }
    }
    {
#line 270
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)(buf___1),
           (size_t )__len___4);
#line 270
    __o___7->next_free += __len___4;
    }
#line 270
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 271
  __o___8 = & muscle_obstack;
#line 271
  if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
    {
#line 271
    _obstack_newchunk(__o___8, 1);
    }
  }
#line 271
  tmp___8 = __o___8->next_free;
#line 271
  (__o___8->next_free) ++;
#line 271
  *tmp___8 = (char )'\000';
#line 272
  __o1 = & muscle_obstack;
#line 272
  __value = (void *)__o1->object_base;
#line 272
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 272
    __o1->maybe_empty_object = 1U;
  }
#line 272
  if (sizeof(int ) < sizeof(void *)) {
#line 272
    tmp___9 = __o1->object_base;
  } else {
#line 272
    tmp___9 = (char *)0;
  }
#line 272
  if (sizeof(int ) < sizeof(void *)) {
#line 272
    tmp___10 = __o1->object_base;
  } else {
#line 272
    tmp___10 = (char *)0;
  }
#line 272
  __o1->next_free = tmp___9 + (((__o1->next_free - tmp___10) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 272
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 272
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 272
  __o1->object_base = __o1->next_free;
#line 272
  extension = (char *)__value;
#line 273
  muscle_grow(key, (char const   *)extension, "");
#line 274
  __o___9 = & muscle_obstack;
#line 274
  __obj = (void *)extension;
  }
#line 274
  if ((unsigned long )__obj > (unsigned long )((void *)__o___9->chunk)) {
#line 274
    if ((unsigned long )__obj < (unsigned long )((void *)__o___9->chunk_limit)) {
#line 274
      tmp___11 = (char *)__obj;
#line 274
      __o___9->object_base = tmp___11;
#line 274
      __o___9->next_free = tmp___11;
    } else {
      {
#line 274
      obstack_free(__o___9, __obj);
      }
    }
  } else {
    {
#line 274
    obstack_free(__o___9, __obj);
    }
  }
#line 275
  return;
}
}
#line 277 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_location_grow(char const   *key , location loc___0 ) 
{ 


  {
  {
#line 280
  muscle_grow(key, "[[", "");
#line 281
  muscle_boundary_grow(key, loc___0.start);
#line 282
  muscle_grow(key, "]], [[", "");
#line 283
  muscle_boundary_grow(key, loc___0.end);
#line 284
  muscle_grow(key, "]]", "");
  }
#line 285
  return;
}
}
#line 307 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static char *muscle_string_decode(char const   *key ) 
{ 
  char const   *value ;
  char *value_decoded ;
  char *result ;
  struct obstack *__o ;
  int __len ;
  size_t tmp ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___1 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___2 ;
  struct obstack *__o___3 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o___4 ;
  void *__obj ;
  char *tmp___7 ;

  {
  {
#line 314
  value = muscle_find_const(key);
  }
#line 315
  if (! value) {
#line 316
    return ((char *)((void *)0));
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    if ((int const   )*value == 36) {
#line 320
      goto case_36;
    }
#line 320
    if ((int const   )*value == 64) {
#line 320
      goto case_64;
    }
#line 322
    if ((int const   )*value == 93) {
#line 322
      goto case_93;
    }
#line 322
    if ((int const   )*value == 91) {
#line 322
      goto case_93;
    }
#line 320
    goto switch_default___0;
    case_36: /* CIL Label */ 
    {
#line 320
    value ++;
#line 320
    aver((_Bool )((int const   )*value == 93));
#line 320
    value ++;
#line 320
    aver((_Bool )((int const   )*value == 91));
#line 320
    __o = & muscle_obstack;
#line 320
    tmp = strlen("$");
#line 320
    __len = (int )tmp;
    }
#line 320
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$",
           (size_t )__len);
#line 320
    __o->next_free += __len;
    }
#line 320
    goto switch_break;
    case_64: /* CIL Label */ 
#line 320
    value ++;
    {
#line 320
    if ((int const   )*value == 64) {
#line 320
      goto case_64___0;
    }
#line 320
    if ((int const   )*value == 123) {
#line 320
      goto case_123;
    }
#line 320
    if ((int const   )*value == 125) {
#line 320
      goto case_125;
    }
#line 320
    goto switch_default;
    case_64___0: /* CIL Label */ 
    {
#line 320
    __o___0 = & muscle_obstack;
#line 320
    tmp___0 = strlen("@");
#line 320
    __len___0 = (int )tmp___0;
    }
#line 320
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@",
           (size_t )__len___0);
#line 320
    __o___0->next_free += __len___0;
    }
#line 320
    goto switch_break___0;
    case_123: /* CIL Label */ 
    {
#line 320
    __o___1 = & muscle_obstack;
#line 320
    tmp___1 = strlen("[");
#line 320
    __len___1 = (int )tmp___1;
    }
#line 320
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"[",
           (size_t )__len___1);
#line 320
    __o___1->next_free += __len___1;
    }
#line 320
    goto switch_break___0;
    case_125: /* CIL Label */ 
    {
#line 320
    __o___2 = & muscle_obstack;
#line 320
    tmp___2 = strlen("]");
#line 320
    __len___2 = (int )tmp___2;
    }
#line 320
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 320
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"]",
           (size_t )__len___2);
#line 320
    __o___2->next_free += __len___2;
    }
#line 320
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 320
    aver((_Bool)0);
    }
#line 320
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 320
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 320
    __o___3 = & muscle_obstack;
#line 320
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 320
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 320
    tmp___3 = __o___3->next_free;
#line 320
    (__o___3->next_free) ++;
#line 320
    *tmp___3 = (char )*value;
#line 320
    goto switch_break;
    case_93: /* CIL Label */ 
    case_91: /* CIL Label */ 
    {
#line 323
    aver((_Bool)0);
    }
#line 324
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 317
    tmp___4 = value;
#line 317
    value ++;
#line 317
    if (! *tmp___4) {
#line 317
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  __o1 = & muscle_obstack;
#line 327
  __value = (void *)__o1->object_base;
#line 327
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 327
    __o1->maybe_empty_object = 1U;
  }
#line 327
  if (sizeof(int ) < sizeof(void *)) {
#line 327
    tmp___5 = __o1->object_base;
  } else {
#line 327
    tmp___5 = (char *)0;
  }
#line 327
  if (sizeof(int ) < sizeof(void *)) {
#line 327
    tmp___6 = __o1->object_base;
  } else {
#line 327
    tmp___6 = (char *)0;
  }
#line 327
  __o1->next_free = tmp___5 + (((__o1->next_free - tmp___6) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 327
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 327
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 327
  __o1->object_base = __o1->next_free;
#line 327
  value_decoded = (char *)__value;
#line 328
  result = xstrdup((char const   *)value_decoded);
#line 329
  __o___4 = & muscle_obstack;
#line 329
  __obj = (void *)value_decoded;
  }
#line 329
  if ((unsigned long )__obj > (unsigned long )((void *)__o___4->chunk)) {
#line 329
    if ((unsigned long )__obj < (unsigned long )((void *)__o___4->chunk_limit)) {
#line 329
      tmp___7 = (char *)__obj;
#line 329
      __o___4->object_base = tmp___7;
#line 329
      __o___4->next_free = tmp___7;
    } else {
      {
#line 329
      obstack_free(__o___4, __obj);
      }
    }
  } else {
    {
#line 329
    obstack_free(__o___4, __obj);
    }
  }
#line 330
  return (result);
}
}
#line 334 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static location muscle_location_decode(char const   *key ) 
{ 
  location loc___0 ;
  char const   *value ;
  char const   *tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___1 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___2 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___3 ;
  struct obstack *__o___3 ;
  char *tmp___4 ;
  char *boundary_str ;
  struct obstack *__o___4 ;
  char *tmp___5 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct obstack *__o___5 ;
  void *__obj ;
  char *tmp___8 ;
  struct obstack *__o___6 ;
  void *__obj___0 ;
  char *tmp___9 ;

  {
  {
#line 338
  tmp = muscle_find_const(key);
#line 338
  value = tmp;
#line 339
  aver((_Bool )value);
#line 340
  aver((_Bool )((int const   )*value == 91));
#line 341
  value ++;
#line 341
  aver((_Bool )((int const   )*value == 91));
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    value ++;
#line 342
    if (! *value) {
#line 342
      goto while_break;
    }
    {
#line 345
    if ((int const   )*value == 36) {
#line 345
      goto case_36;
    }
#line 345
    if ((int const   )*value == 64) {
#line 345
      goto case_64;
    }
#line 346
    if ((int const   )*value == 91) {
#line 346
      goto case_91;
    }
#line 349
    if ((int const   )*value == 93) {
#line 349
      goto case_93;
    }
#line 345
    goto switch_default___0;
    case_36: /* CIL Label */ 
    {
#line 345
    value ++;
#line 345
    aver((_Bool )((int const   )*value == 93));
#line 345
    value ++;
#line 345
    aver((_Bool )((int const   )*value == 91));
#line 345
    __o = & muscle_obstack;
#line 345
    tmp___0 = strlen("$");
#line 345
    __len = (int )tmp___0;
    }
#line 345
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$",
           (size_t )__len);
#line 345
    __o->next_free += __len;
    }
#line 345
    goto switch_break;
    case_64: /* CIL Label */ 
#line 345
    value ++;
    {
#line 345
    if ((int const   )*value == 64) {
#line 345
      goto case_64___0;
    }
#line 345
    if ((int const   )*value == 123) {
#line 345
      goto case_123;
    }
#line 345
    if ((int const   )*value == 125) {
#line 345
      goto case_125;
    }
#line 345
    goto switch_default;
    case_64___0: /* CIL Label */ 
    {
#line 345
    __o___0 = & muscle_obstack;
#line 345
    tmp___1 = strlen("@");
#line 345
    __len___0 = (int )tmp___1;
    }
#line 345
    if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@",
           (size_t )__len___0);
#line 345
    __o___0->next_free += __len___0;
    }
#line 345
    goto switch_break___0;
    case_123: /* CIL Label */ 
    {
#line 345
    __o___1 = & muscle_obstack;
#line 345
    tmp___2 = strlen("[");
#line 345
    __len___1 = (int )tmp___2;
    }
#line 345
    if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___1, __len___1);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"[",
           (size_t )__len___1);
#line 345
    __o___1->next_free += __len___1;
    }
#line 345
    goto switch_break___0;
    case_125: /* CIL Label */ 
    {
#line 345
    __o___2 = & muscle_obstack;
#line 345
    tmp___3 = strlen("]");
#line 345
    __len___2 = (int )tmp___3;
    }
#line 345
    if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___2, __len___2);
      }
    }
    {
#line 345
    memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"]",
           (size_t )__len___2);
#line 345
    __o___2->next_free += __len___2;
    }
#line 345
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 345
    aver((_Bool)0);
    }
#line 345
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 345
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 345
    __o___3 = & muscle_obstack;
#line 345
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 345
    tmp___4 = __o___3->next_free;
#line 345
    (__o___3->next_free) ++;
#line 345
    *tmp___4 = (char )*value;
#line 345
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 347
    aver((_Bool)0);
    }
#line 348
    goto switch_break;
    case_93: /* CIL Label */ 
    {
#line 352
    value ++;
#line 352
    aver((_Bool )((int const   )*value == 93));
#line 353
    __o___4 = & muscle_obstack;
    }
#line 353
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 353
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 353
    tmp___5 = __o___4->next_free;
#line 353
    (__o___4->next_free) ++;
#line 353
    *tmp___5 = (char )'\000';
#line 354
    __o1 = & muscle_obstack;
#line 354
    __value = (void *)__o1->object_base;
#line 354
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 354
      __o1->maybe_empty_object = 1U;
    }
#line 354
    if (sizeof(int ) < sizeof(void *)) {
#line 354
      tmp___6 = __o1->object_base;
    } else {
#line 354
      tmp___6 = (char *)0;
    }
#line 354
    if (sizeof(int ) < sizeof(void *)) {
#line 354
      tmp___7 = __o1->object_base;
    } else {
#line 354
      tmp___7 = (char *)0;
    }
#line 354
    __o1->next_free = tmp___6 + (((__o1->next_free - tmp___7) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 354
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 354
      __o1->next_free = __o1->chunk_limit;
    }
#line 354
    __o1->object_base = __o1->next_free;
#line 354
    boundary_str = (char *)__value;
#line 355
    value ++;
    {
#line 357
    if ((int const   )*value == 44) {
#line 357
      goto case_44;
    }
#line 364
    if ((int const   )*value == 0) {
#line 364
      goto case_0;
    }
#line 369
    goto switch_default___1;
    case_44: /* CIL Label */ 
    {
#line 358
    boundary_set_from_string(& loc___0.start, boundary_str);
#line 359
    __o___5 = & muscle_obstack;
#line 359
    __obj = (void *)boundary_str;
    }
#line 359
    if ((unsigned long )__obj > (unsigned long )((void *)__o___5->chunk)) {
#line 359
      if ((unsigned long )__obj < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 359
        tmp___8 = (char *)__obj;
#line 359
        __o___5->object_base = tmp___8;
#line 359
        __o___5->next_free = tmp___8;
      } else {
        {
#line 359
        obstack_free(__o___5, __obj);
        }
      }
    } else {
      {
#line 359
      obstack_free(__o___5, __obj);
      }
    }
    {
#line 360
    value ++;
#line 360
    aver((_Bool )((int const   )*value == 32));
#line 361
    value ++;
#line 361
    aver((_Bool )((int const   )*value == 91));
#line 362
    value ++;
#line 362
    aver((_Bool )((int const   )*value == 91));
    }
#line 363
    goto switch_break___1;
    case_0: /* CIL Label */ 
    {
#line 365
    boundary_set_from_string(& loc___0.end, boundary_str);
#line 366
    __o___6 = & muscle_obstack;
#line 366
    __obj___0 = (void *)boundary_str;
    }
#line 366
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___6->chunk)) {
#line 366
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___6->chunk_limit)) {
#line 366
        tmp___9 = (char *)__obj___0;
#line 366
        __o___6->object_base = tmp___9;
#line 366
        __o___6->next_free = tmp___9;
      } else {
        {
#line 366
        obstack_free(__o___6, __obj___0);
        }
      }
    } else {
      {
#line 366
      obstack_free(__o___6, __obj___0);
      }
    }
#line 367
    return (loc___0);
#line 368
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 370
    aver((_Bool)0);
    }
#line 371
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 374
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  aver((_Bool)0);
  }
#line 377
  return (loc___0);
}
}
#line 380 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_user_name_list_grow(char const   *key , char const   *user_name , location loc___0 ) 
{ 


  {
  {
#line 384
  muscle_grow(key, "[[[[", ",");
#line 385
  muscle_grow(key, user_name, "");
#line 386
  muscle_grow(key, "]], ", "");
#line 387
  muscle_location_grow(key, loc___0);
#line 388
  muscle_grow(key, "]]", "");
  }
#line 389
  return;
}
}
#line 403 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_percent_define_insert(char const   *variable , location variable_loc ,
                                  char const   *value ) 
{ 
  char const   *name ;
  char const   *loc_name ;
  char const   *syncline_name ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t length___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  size_t length___1 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  location tmp___10 ;
  char const   *tmp___11 ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___12 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___13 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___14 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___15 ;
  struct obstack *__o___3 ;
  char *tmp___16 ;
  struct obstack *__o___4 ;
  char *tmp___17 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 411
    tmp___0 = strlen(variable);
#line 411
    length = tmp___0;
#line 411
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 411
    tmp = (char *)tmp___1;
#line 411
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define(");
#line 411
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define(")) - 1), (char const   */* __restrict  */)variable);
#line 411
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 411
    name = uniqstr_new((char const   *)tmp);
#line 411
    free((void *)tmp);
    }
#line 411
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 412
    tmp___3 = strlen(variable);
#line 412
    length___0 = tmp___3;
#line 412
    tmp___4 = xmalloc((size_t )(((sizeof("percent_define_loc(") - 1UL) + (unsigned long )length___0) + sizeof(")")));
#line 412
    tmp___2 = (char *)tmp___4;
#line 412
    strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)"percent_define_loc(");
#line 412
    strcpy((char */* __restrict  */)((tmp___2 + sizeof("percent_define_loc(")) - 1),
           (char const   */* __restrict  */)variable);
#line 412
    strcpy((char */* __restrict  */)(((tmp___2 + sizeof("percent_define_loc(")) - 1) + length___0),
           (char const   */* __restrict  */)")");
#line 412
    loc_name = uniqstr_new((char const   *)tmp___2);
#line 412
    free((void *)tmp___2);
    }
#line 412
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 413
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 413
    tmp___6 = strlen(variable);
#line 413
    length___1 = tmp___6;
#line 413
    tmp___7 = xmalloc((size_t )(((sizeof("percent_define_syncline(") - 1UL) + (unsigned long )length___1) + sizeof(")")));
#line 413
    tmp___5 = (char *)tmp___7;
#line 413
    strcpy((char */* __restrict  */)tmp___5, (char const   */* __restrict  */)"percent_define_syncline(");
#line 413
    strcpy((char */* __restrict  */)((tmp___5 + sizeof("percent_define_syncline(")) - 1),
           (char const   */* __restrict  */)variable);
#line 413
    strcpy((char */* __restrict  */)(((tmp___5 + sizeof("percent_define_syncline(")) - 1) + length___1),
           (char const   */* __restrict  */)")");
#line 413
    syncline_name = uniqstr_new((char const   *)tmp___5);
#line 413
    free((void *)tmp___5);
    }
#line 413
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 416
  tmp___11 = muscle_find_const(name);
  }
#line 416
  if (tmp___11) {
    {
#line 418
    tmp___8 = gettext("%s `%s\' redefined");
#line 418
    warn_at(variable_loc, (char const   *)tmp___8, "%define variable", variable);
#line 420
    tmp___9 = gettext("previous definition");
#line 420
    tmp___10 = muscle_percent_define_get_loc(variable);
#line 420
    warn_at(tmp___10, (char const   *)tmp___9);
    }
  }
  {
#line 423
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 423
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 423
      p = value;
      {
#line 423
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 423
        if (! *p) {
#line 423
          goto while_break___4;
        }
        {
#line 423
        if ((int const   )*p == 36) {
#line 423
          goto case_36;
        }
#line 423
        if ((int const   )*p == 64) {
#line 423
          goto case_64;
        }
#line 423
        if ((int const   )*p == 91) {
#line 423
          goto case_91;
        }
#line 423
        if ((int const   )*p == 93) {
#line 423
          goto case_93;
        }
#line 423
        goto switch_default;
        case_36: /* CIL Label */ 
        {
#line 423
        __o = & muscle_obstack;
#line 423
        tmp___12 = strlen("$][");
#line 423
        __len = (int )tmp___12;
        }
#line 423
        if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
          {
#line 423
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 423
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
               (size_t )__len);
#line 423
        __o->next_free += __len;
        }
#line 423
        goto switch_break;
        case_64: /* CIL Label */ 
        {
#line 423
        __o___0 = & muscle_obstack;
#line 423
        tmp___13 = strlen("@@");
#line 423
        __len___0 = (int )tmp___13;
        }
#line 423
        if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
          {
#line 423
          _obstack_newchunk(__o___0, __len___0);
          }
        }
        {
#line 423
        memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
               (size_t )__len___0);
#line 423
        __o___0->next_free += __len___0;
        }
#line 423
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 423
        __o___1 = & muscle_obstack;
#line 423
        tmp___14 = strlen("@{");
#line 423
        __len___1 = (int )tmp___14;
        }
#line 423
        if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
          {
#line 423
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 423
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
               (size_t )__len___1);
#line 423
        __o___1->next_free += __len___1;
        }
#line 423
        goto switch_break;
        case_93: /* CIL Label */ 
        {
#line 423
        __o___2 = & muscle_obstack;
#line 423
        tmp___15 = strlen("@}");
#line 423
        __len___2 = (int )tmp___15;
        }
#line 423
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 423
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 423
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
               (size_t )__len___2);
#line 423
        __o___2->next_free += __len___2;
        }
#line 423
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 423
        __o___3 = & muscle_obstack;
#line 423
        if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
          {
#line 423
          _obstack_newchunk(__o___3, 1);
          }
        }
#line 423
        tmp___16 = __o___3->next_free;
#line 423
        (__o___3->next_free) ++;
#line 423
        *tmp___16 = (char )*p;
#line 423
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 423
        p ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 423
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 423
    __o___4 = & muscle_obstack;
#line 423
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 423
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 423
    tmp___17 = __o___4->next_free;
#line 423
    (__o___4->next_free) ++;
#line 423
    *tmp___17 = (char)0;
#line 423
    __o1 = & muscle_obstack;
#line 423
    __value = (void *)__o1->object_base;
#line 423
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 423
      __o1->maybe_empty_object = 1U;
    }
#line 423
    if (sizeof(int ) < sizeof(void *)) {
#line 423
      tmp___18 = __o1->object_base;
    } else {
#line 423
      tmp___18 = (char *)0;
    }
#line 423
    if (sizeof(int ) < sizeof(void *)) {
#line 423
      tmp___19 = __o1->object_base;
    } else {
#line 423
      tmp___19 = (char *)0;
    }
#line 423
    __o1->next_free = tmp___18 + (((__o1->next_free - tmp___19) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 423
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 423
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 423
    __o1->object_base = __o1->next_free;
#line 423
    muscle_insert(name, (char const   *)__value);
    }
#line 423
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 425
  muscle_insert(loc_name, "");
#line 426
  muscle_location_grow(loc_name, variable_loc);
#line 427
  muscle_insert(syncline_name, "");
#line 428
  muscle_syncline_grow(syncline_name, variable_loc);
#line 429
  muscle_user_name_list_grow("percent_define_user_variables", variable, variable_loc);
  }
#line 431
  return;
}
}
#line 433 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
char *muscle_percent_define_get(char const   *variable ) 
{ 
  char const   *name ;
  char const   *usage_name ;
  char *value ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t length___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    tmp___0 = strlen(variable);
#line 440
    length = tmp___0;
#line 440
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 440
    tmp = (char *)tmp___1;
#line 440
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define(");
#line 440
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define(")) - 1), (char const   */* __restrict  */)variable);
#line 440
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 440
    name = uniqstr_new((char const   *)tmp);
#line 440
    free((void *)tmp);
    }
#line 440
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 441
    tmp___3 = strlen(variable);
#line 441
    length___0 = tmp___3;
#line 441
    tmp___4 = xmalloc((size_t )(((sizeof("percent_define_bison_variables(") - 1UL) + (unsigned long )length___0) + sizeof(")")));
#line 441
    tmp___2 = (char *)tmp___4;
#line 441
    strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)"percent_define_bison_variables(");
#line 441
    strcpy((char */* __restrict  */)((tmp___2 + sizeof("percent_define_bison_variables(")) - 1),
           (char const   */* __restrict  */)variable);
#line 441
    strcpy((char */* __restrict  */)(((tmp___2 + sizeof("percent_define_bison_variables(")) - 1) + length___0),
           (char const   */* __restrict  */)")");
#line 441
    usage_name = uniqstr_new((char const   *)tmp___2);
#line 441
    free((void *)tmp___2);
    }
#line 441
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 444
  muscle_insert(usage_name, "");
#line 445
  value = muscle_string_decode(name);
  }
#line 446
  if (! value) {
    {
#line 447
    value = xstrdup("");
    }
  }
#line 448
  return (value);
}
}
#line 451 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
location muscle_percent_define_get_loc(char const   *variable ) 
{ 
  char const   *loc_name ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  location tmp___4 ;

  {
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    tmp___0 = strlen(variable);
#line 455
    length = tmp___0;
#line 455
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define_loc(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 455
    tmp = (char *)tmp___1;
#line 455
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define_loc(");
#line 455
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define_loc(")) - 1), (char const   */* __restrict  */)variable);
#line 455
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define_loc(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 455
    loc_name = uniqstr_new((char const   *)tmp);
#line 455
    free((void *)tmp);
    }
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  tmp___3 = muscle_find_const(loc_name);
  }
#line 456
  if (! tmp___3) {
    {
#line 457
    tmp___2 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_get_loc");
#line 457
    fatal((char const   *)tmp___2, variable);
    }
  }
  {
#line 459
  tmp___4 = muscle_location_decode(loc_name);
  }
#line 459
  return (tmp___4);
}
}
#line 462 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
char const   *muscle_percent_define_get_syncline(char const   *variable ) 
{ 
  char const   *syncline_name ;
  char const   *syncline ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 467
    tmp___0 = strlen(variable);
#line 467
    length = tmp___0;
#line 467
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define_syncline(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 467
    tmp = (char *)tmp___1;
#line 467
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define_syncline(");
#line 467
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define_syncline(")) - 1),
           (char const   */* __restrict  */)variable);
#line 467
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define_syncline(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 467
    syncline_name = uniqstr_new((char const   *)tmp);
#line 467
    free((void *)tmp);
    }
#line 467
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  syncline = muscle_find_const(syncline_name);
  }
#line 470
  if (! syncline) {
    {
#line 471
    tmp___2 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_get_syncline");
#line 471
    fatal((char const   *)tmp___2, variable);
    }
  }
#line 473
  return (syncline);
}
}
#line 476 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
_Bool muscle_percent_define_ifdef(char const   *variable ) 
{ 
  char const   *name ;
  char const   *usage_name ;
  char const   *value ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t length___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 483
    tmp___0 = strlen(variable);
#line 483
    length = tmp___0;
#line 483
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 483
    tmp = (char *)tmp___1;
#line 483
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define(");
#line 483
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define(")) - 1), (char const   */* __restrict  */)variable);
#line 483
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 483
    name = uniqstr_new((char const   *)tmp);
#line 483
    free((void *)tmp);
    }
#line 483
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 484
    tmp___3 = strlen(variable);
#line 484
    length___0 = tmp___3;
#line 484
    tmp___4 = xmalloc((size_t )(((sizeof("percent_define_bison_variables(") - 1UL) + (unsigned long )length___0) + sizeof(")")));
#line 484
    tmp___2 = (char *)tmp___4;
#line 484
    strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)"percent_define_bison_variables(");
#line 484
    strcpy((char */* __restrict  */)((tmp___2 + sizeof("percent_define_bison_variables(")) - 1),
           (char const   */* __restrict  */)variable);
#line 484
    strcpy((char */* __restrict  */)(((tmp___2 + sizeof("percent_define_bison_variables(")) - 1) + length___0),
           (char const   */* __restrict  */)")");
#line 484
    usage_name = uniqstr_new((char const   *)tmp___2);
#line 484
    free((void *)tmp___2);
    }
#line 484
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  value = muscle_find_const(name);
  }
#line 488
  if (value) {
    {
#line 490
    muscle_insert(usage_name, "");
    }
#line 491
    return ((_Bool)1);
  }
#line 494
  return ((_Bool)0);
}
}
#line 497 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
_Bool muscle_percent_define_flag_if(char const   *variable ) 
{ 
  char const   *invalid_boolean_name ;
  _Bool result ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *value ;
  char *tmp___2 ;
  char *tmp___3 ;
  location tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;

  {
#line 501
  result = (_Bool)0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 503
    tmp___0 = strlen(variable);
#line 503
    length = tmp___0;
#line 503
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define_invalid_boolean(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 503
    tmp = (char *)tmp___1;
#line 503
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define_invalid_boolean(");
#line 503
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define_invalid_boolean(")) - 1),
           (char const   */* __restrict  */)variable);
#line 503
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define_invalid_boolean(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 503
    invalid_boolean_name = uniqstr_new((char const   *)tmp);
#line 503
    free((void *)tmp);
    }
#line 503
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 506
  tmp___9 = muscle_percent_define_ifdef(variable);
  }
#line 506
  if (tmp___9) {
    {
#line 508
    tmp___2 = muscle_percent_define_get(variable);
#line 508
    value = tmp___2;
    }
#line 509
    if ((int )*(value + 0) == 0) {
#line 510
      result = (_Bool)1;
    } else {
      {
#line 509
      tmp___7 = strcmp((char const   *)value, "true");
      }
#line 509
      if (0 == tmp___7) {
#line 510
        result = (_Bool)1;
      } else {
        {
#line 511
        tmp___6 = strcmp((char const   *)value, "false");
        }
#line 511
        if (0 == tmp___6) {
#line 512
          result = (_Bool)0;
        } else {
          {
#line 513
          tmp___5 = muscle_find_const(invalid_boolean_name);
          }
#line 513
          if (! tmp___5) {
            {
#line 515
            muscle_insert(invalid_boolean_name, "");
#line 516
            tmp___3 = gettext("invalid value for %%define Boolean variable `%s\'");
#line 516
            tmp___4 = muscle_percent_define_get_loc(variable);
#line 516
            complain_at(tmp___4, (char const   *)tmp___3, variable);
            }
          }
        }
      }
    }
    {
#line 520
    free((void *)value);
    }
  } else {
    {
#line 523
    tmp___8 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_flag_if");
#line 523
    fatal((char const   *)tmp___8, variable);
    }
  }
#line 526
  return (result);
}
}
#line 529 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_percent_define_default(char const   *variable , char const   *value ) 
{ 
  char const   *name ;
  char const   *loc_name ;
  char const   *syncline_name ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t length___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  size_t length___1 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  location loc___0 ;
  char const   *p ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___8 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___9 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___10 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___11 ;
  struct obstack *__o___3 ;
  char *tmp___12 ;
  struct obstack *__o___4 ;
  char *tmp___13 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;

  {
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 535
    tmp___0 = strlen(variable);
#line 535
    length = tmp___0;
#line 535
    tmp___1 = xmalloc((size_t )(((sizeof("percent_define(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 535
    tmp = (char *)tmp___1;
#line 535
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define(");
#line 535
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_define(")) - 1), (char const   */* __restrict  */)variable);
#line 535
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 535
    name = uniqstr_new((char const   *)tmp);
#line 535
    free((void *)tmp);
    }
#line 535
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 536
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 536
    tmp___3 = strlen(variable);
#line 536
    length___0 = tmp___3;
#line 536
    tmp___4 = xmalloc((size_t )(((sizeof("percent_define_loc(") - 1UL) + (unsigned long )length___0) + sizeof(")")));
#line 536
    tmp___2 = (char *)tmp___4;
#line 536
    strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)"percent_define_loc(");
#line 536
    strcpy((char */* __restrict  */)((tmp___2 + sizeof("percent_define_loc(")) - 1),
           (char const   */* __restrict  */)variable);
#line 536
    strcpy((char */* __restrict  */)(((tmp___2 + sizeof("percent_define_loc(")) - 1) + length___0),
           (char const   */* __restrict  */)")");
#line 536
    loc_name = uniqstr_new((char const   *)tmp___2);
#line 536
    free((void *)tmp___2);
    }
#line 536
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 537
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 537
    tmp___6 = strlen(variable);
#line 537
    length___1 = tmp___6;
#line 537
    tmp___7 = xmalloc((size_t )(((sizeof("percent_define_syncline(") - 1UL) + (unsigned long )length___1) + sizeof(")")));
#line 537
    tmp___5 = (char *)tmp___7;
#line 537
    strcpy((char */* __restrict  */)tmp___5, (char const   */* __restrict  */)"percent_define_syncline(");
#line 537
    strcpy((char */* __restrict  */)((tmp___5 + sizeof("percent_define_syncline(")) - 1),
           (char const   */* __restrict  */)variable);
#line 537
    strcpy((char */* __restrict  */)(((tmp___5 + sizeof("percent_define_syncline(")) - 1) + length___1),
           (char const   */* __restrict  */)")");
#line 537
    syncline_name = uniqstr_new((char const   *)tmp___5);
#line 537
    free((void *)tmp___5);
    }
#line 537
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 539
  tmp___16 = muscle_find_const(name);
  }
#line 539
  if (! tmp___16) {
    {
#line 542
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 542
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 542
        p = value;
        {
#line 542
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 542
          if (! *p) {
#line 542
            goto while_break___4;
          }
          {
#line 542
          if ((int const   )*p == 36) {
#line 542
            goto case_36;
          }
#line 542
          if ((int const   )*p == 64) {
#line 542
            goto case_64;
          }
#line 542
          if ((int const   )*p == 91) {
#line 542
            goto case_91;
          }
#line 542
          if ((int const   )*p == 93) {
#line 542
            goto case_93;
          }
#line 542
          goto switch_default;
          case_36: /* CIL Label */ 
          {
#line 542
          __o = & muscle_obstack;
#line 542
          tmp___8 = strlen("$][");
#line 542
          __len = (int )tmp___8;
          }
#line 542
          if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
            {
#line 542
            _obstack_newchunk(__o, __len);
            }
          }
          {
#line 542
          memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"$][",
                 (size_t )__len);
#line 542
          __o->next_free += __len;
          }
#line 542
          goto switch_break;
          case_64: /* CIL Label */ 
          {
#line 542
          __o___0 = & muscle_obstack;
#line 542
          tmp___9 = strlen("@@");
#line 542
          __len___0 = (int )tmp___9;
          }
#line 542
          if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
            {
#line 542
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 542
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"@@",
                 (size_t )__len___0);
#line 542
          __o___0->next_free += __len___0;
          }
#line 542
          goto switch_break;
          case_91: /* CIL Label */ 
          {
#line 542
          __o___1 = & muscle_obstack;
#line 542
          tmp___10 = strlen("@{");
#line 542
          __len___1 = (int )tmp___10;
          }
#line 542
          if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
            {
#line 542
            _obstack_newchunk(__o___1, __len___1);
            }
          }
          {
#line 542
          memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)"@{",
                 (size_t )__len___1);
#line 542
          __o___1->next_free += __len___1;
          }
#line 542
          goto switch_break;
          case_93: /* CIL Label */ 
          {
#line 542
          __o___2 = & muscle_obstack;
#line 542
          tmp___11 = strlen("@}");
#line 542
          __len___2 = (int )tmp___11;
          }
#line 542
          if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
            {
#line 542
            _obstack_newchunk(__o___2, __len___2);
            }
          }
          {
#line 542
          memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)"@}",
                 (size_t )__len___2);
#line 542
          __o___2->next_free += __len___2;
          }
#line 542
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 542
          __o___3 = & muscle_obstack;
#line 542
          if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
            {
#line 542
            _obstack_newchunk(__o___3, 1);
            }
          }
#line 542
          tmp___12 = __o___3->next_free;
#line 542
          (__o___3->next_free) ++;
#line 542
          *tmp___12 = (char )*p;
#line 542
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 542
          p ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 542
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 542
      __o___4 = & muscle_obstack;
#line 542
      if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
        {
#line 542
        _obstack_newchunk(__o___4, 1);
        }
      }
#line 542
      tmp___13 = __o___4->next_free;
#line 542
      (__o___4->next_free) ++;
#line 542
      *tmp___13 = (char)0;
#line 542
      __o1 = & muscle_obstack;
#line 542
      __value = (void *)__o1->object_base;
#line 542
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 542
        __o1->maybe_empty_object = 1U;
      }
#line 542
      if (sizeof(int ) < sizeof(void *)) {
#line 542
        tmp___14 = __o1->object_base;
      } else {
#line 542
        tmp___14 = (char *)0;
      }
#line 542
      if (sizeof(int ) < sizeof(void *)) {
#line 542
        tmp___15 = __o1->object_base;
      } else {
#line 542
        tmp___15 = (char *)0;
      }
#line 542
      __o1->next_free = tmp___14 + (((__o1->next_free - tmp___15) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 542
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 542
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 542
      __o1->object_base = __o1->next_free;
#line 542
      muscle_insert(name, (char const   *)__value);
      }
#line 542
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 543
    loc___0.end.file = "[Bison:muscle_percent_define_default]";
#line 543
    loc___0.start.file = loc___0.end.file;
#line 544
    loc___0.end.line = 1;
#line 544
    loc___0.start.line = loc___0.end.line;
#line 545
    loc___0.end.column = 0;
#line 545
    loc___0.start.column = loc___0.end.column;
#line 546
    muscle_insert(loc_name, "");
#line 547
    muscle_location_grow(loc_name, loc___0);
#line 548
    muscle_insert(syncline_name, "");
#line 549
    muscle_syncline_grow(syncline_name, loc___0);
    }
  }
#line 551
  return;
}
}
#line 553 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_percent_define_check_values(char const   * const  *values ) 
{ 
  char const   *variable ;
  char const   *name ;
  char *value ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  _Bool valid ;
  int tmp___2 ;
  char *tmp___3 ;
  location tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! *values) {
#line 556
      goto while_break;
    }
#line 558
    variable = (char const   *)*values;
    {
#line 562
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 562
      tmp___0 = strlen(variable);
#line 562
      length = tmp___0;
#line 562
      tmp___1 = xmalloc((size_t )(((sizeof("percent_define(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 562
      tmp = (char *)tmp___1;
#line 562
      strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_define(");
#line 562
      strcpy((char */* __restrict  */)((tmp + sizeof("percent_define(")) - 1), (char const   */* __restrict  */)variable);
#line 562
      strcpy((char */* __restrict  */)(((tmp + sizeof("percent_define(")) - 1) + length),
             (char const   */* __restrict  */)")");
#line 562
      name = uniqstr_new((char const   *)tmp);
#line 562
      free((void *)tmp);
      }
#line 562
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 564
    value = muscle_string_decode(name);
    }
#line 565
    if (value) {
#line 567
      valid = (_Bool)0;
#line 568
      values ++;
      {
#line 568
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 568
        if (! *values) {
#line 568
          goto while_break___1;
        }
        {
#line 570
        tmp___2 = strcmp((char const   *)value, (char const   *)*values);
        }
#line 570
        if (0 == tmp___2) {
#line 572
          valid = (_Bool)1;
          {
#line 573
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 573
            if (! *values) {
#line 573
              goto while_break___2;
            }
#line 574
            values ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 575
          goto while_break___1;
        }
#line 568
        values ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 578
      if (! valid) {
        {
#line 579
        tmp___3 = gettext("invalid value for %%define variable `%s\': `%s\'");
#line 579
        tmp___4 = muscle_percent_define_get_loc(variable);
#line 579
        complain_at(tmp___4, (char const   *)tmp___3, variable, value);
        }
      }
      {
#line 582
      free((void *)value);
      }
    } else {
      {
#line 585
      tmp___5 = gettext("undefined %%define variable `%s\' passed to muscle_percent_define_check_values");
#line 585
      fatal((char const   *)tmp___5, variable);
      }
    }
#line 556
    values ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  return;
}
}
#line 590 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscle_percent_code_grow(char const   *qualifier , location qualifier_loc , char const   *code ,
                              location code_loc ) 
{ 
  char const   *name ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 595
    tmp___0 = strlen(qualifier);
#line 595
    length = tmp___0;
#line 595
    tmp___1 = xmalloc((size_t )(((sizeof("percent_code(") - 1UL) + (unsigned long )length) + sizeof(")")));
#line 595
    tmp = (char *)tmp___1;
#line 595
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)"percent_code(");
#line 595
    strcpy((char */* __restrict  */)((tmp + sizeof("percent_code(")) - 1), (char const   */* __restrict  */)qualifier);
#line 595
    strcpy((char */* __restrict  */)(((tmp + sizeof("percent_code(")) - 1) + length),
           (char const   */* __restrict  */)")");
#line 595
    name = uniqstr_new((char const   *)tmp);
#line 595
    free((void *)tmp);
    }
#line 595
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 596
  muscle_code_grow(name, code, code_loc);
#line 597
  muscle_user_name_list_grow("percent_code_user_qualifiers", qualifier, qualifier_loc);
  }
#line 599
  return;
}
}
#line 606 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
__inline static _Bool muscle_m4_output(muscle_entry *entry , FILE *out ) 
{ 


  {
  {
#line 609
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"m4_define([b4_%s],\n",
          entry->key);
#line 610
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"[[%s]])\n\n\n",
          entry->value);
  }
#line 611
  return ((_Bool)1);
}
}
#line 614 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
static _Bool muscle_m4_output_processor(void *entry , void *out ) 
{ 
  _Bool tmp ;

  {
  {
#line 617
  tmp = muscle_m4_output((muscle_entry *)entry, (FILE *)out);
  }
#line 617
  return (tmp);
}
}
#line 626 "/home/pronto/abs/test-suite/bison-2.4/src/muscle_tab.c"
void muscles_m4_output(FILE *out ) 
{ 


  {
  {
#line 629
  hash_do_for_each((Hash_table const   *)muscle_table, & muscle_m4_output_processor,
                   (void *)out);
  }
#line 630
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 81 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 85
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 273 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
void grammar_free(void) ;
#line 258 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern void state_remove_unreachable_states(state_number *old_to_new ) ;
#line 264
extern void states_free(void) ;
#line 24 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.h"
void generate_states(void) ;
#line 23 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.h"
void conflicts_solve(void) ;
#line 34
void conflicts_update_state_numbers(state_number *old_to_new , state_number nstates_old ) ;
#line 37
void conflicts_print(void) ;
#line 40
void conflicts_free(void) ;
#line 32 "/home/pronto/abs/test-suite/bison-2.4/src/derives.h"
void derives_compute(void) ;
#line 33
void derives_free(void) ;
#line 64 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
void compute_output_file_names(void) ;
#line 65
void output_file_names_free(void) ;
#line 26 "/home/pronto/abs/test-suite/bison-2.4/src/getargs.h"
extern char *program_name ;
#line 38
extern _Bool graph_flag ;
#line 39
extern _Bool xml_flag ;
#line 132
extern void getargs(int argc , char **argv ) ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.h"
void lalr(void) ;
#line 56
void lalr_update_state_numbers(state_number *old_to_new , state_number nstates_old ) ;
#line 63
void lalr_free(void) ;
#line 27 "/home/pronto/abs/test-suite/bison-2.4/src/scan-gram.h"
extern void gram_scanner_free(void) ;
#line 114 "/home/pronto/abs/test-suite/bison-2.4/src/tables.h"
extern void tables_generate(void) ;
#line 115
extern void tables_free(void) ;
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/main.c"
int main(int argc , char **argv ) 
{ 
  state_number *old_to_new ;
  void *tmp ;
  state_number nstates_old ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  program_name = *(argv + 0);
#line 59
  setlocale(6, "");
#line 60
  bindtextdomain("bison", "/usr/local/share/locale");
#line 61
  bindtextdomain("bison-runtime", "/usr/local/share/locale");
#line 62
  textdomain("bison");
#line 64
  uniqstrs_new();
#line 66
  getargs(argc, argv);
#line 68
  timevar_report = trace_flag & 256;
#line 69
  init_timevar();
#line 70
  timevar_start((timevar_id_t )0);
  }
#line 72
  if (trace_flag & 16) {
    {
#line 73
    bitset_stats_enable();
    }
  }
  {
#line 75
  muscle_init();
#line 81
  timevar_push((timevar_id_t )1);
#line 82
  reader();
#line 83
  timevar_pop((timevar_id_t )1);
  }
#line 85
  if (complaint_issued) {
#line 86
    goto finish;
  }
  {
#line 89
  timevar_push((timevar_id_t )4);
#line 90
  reduce_grammar();
#line 91
  timevar_pop((timevar_id_t )4);
#line 95
  timevar_push((timevar_id_t )5);
#line 96
  derives_compute();
#line 97
  nullable_compute();
#line 98
  timevar_pop((timevar_id_t )5);
#line 102
  timevar_push((timevar_id_t )6);
#line 103
  generate_states();
#line 104
  timevar_pop((timevar_id_t )6);
#line 107
  timevar_push((timevar_id_t )7);
#line 108
  lalr();
#line 109
  timevar_pop((timevar_id_t )7);
#line 115
  timevar_push((timevar_id_t )8);
#line 116
  conflicts_solve();
#line 117
  muscle_percent_define_default("lr.keep_unreachable_states", "false");
#line 118
  tmp___0 = muscle_percent_define_flag_if("lr.keep_unreachable_states");
  }
#line 118
  if (! tmp___0) {
    {
#line 120
    tmp = xnmalloc((size_t )nstates, (size_t )sizeof(*old_to_new));
#line 120
    old_to_new = (state_number *)tmp;
#line 121
    nstates_old = nstates;
#line 122
    state_remove_unreachable_states(old_to_new);
#line 123
    lalr_update_state_numbers(old_to_new, nstates_old);
#line 124
    conflicts_update_state_numbers(old_to_new, nstates_old);
#line 125
    free((void *)old_to_new);
    }
  }
  {
#line 127
  conflicts_print();
#line 128
  timevar_pop((timevar_id_t )8);
#line 131
  timevar_push((timevar_id_t )12);
#line 132
  tables_generate();
#line 133
  timevar_pop((timevar_id_t )12);
#line 135
  tmp___1 = gettext("rule useless in parser due to conflicts");
#line 135
  grammar_rules_useless_report((char const   *)tmp___1);
#line 139
  compute_output_file_names();
  }
#line 142
  if (report_flag) {
    {
#line 144
    timevar_push((timevar_id_t )9);
#line 145
    print_results();
#line 146
    timevar_pop((timevar_id_t )9);
    }
  }
#line 150
  if (graph_flag) {
    {
#line 152
    timevar_push((timevar_id_t )10);
#line 153
    print_graph();
#line 154
    timevar_pop((timevar_id_t )10);
    }
  }
#line 158
  if (xml_flag) {
    {
#line 160
    timevar_push((timevar_id_t )11);
#line 161
    print_xml();
#line 162
    timevar_pop((timevar_id_t )11);
    }
  }
#line 167
  if (complaint_issued) {
#line 168
    goto finish;
  }
  {
#line 171
  timevar_push((timevar_id_t )15);
#line 172
  lalr_free();
#line 173
  timevar_pop((timevar_id_t )15);
#line 176
  timevar_push((timevar_id_t )13);
#line 177
  output();
#line 178
  timevar_pop((timevar_id_t )13);
#line 180
  timevar_push((timevar_id_t )15);
#line 181
  nullable_free();
#line 182
  derives_free();
#line 183
  tables_free();
#line 184
  states_free();
#line 185
  reduce_free();
#line 186
  conflicts_free();
#line 187
  grammar_free();
#line 188
  output_file_names_free();
#line 192
  gram_scanner_free();
#line 193
  muscle_free();
#line 194
  uniqstrs_free();
#line 195
  code_scanner_free();
#line 196
  skel_scanner_free();
#line 197
  quotearg_free();
#line 198
  timevar_pop((timevar_id_t )15);
  }
#line 200
  if (trace_flag & 16) {
    {
#line 201
    bitset_stats_dump(stderr);
    }
  }
  finish: 
  {
#line 206
  timevar_stop((timevar_id_t )0);
#line 207
  timevar_print(stderr);
  }
#line 209
  if (complaint_issued) {
#line 209
    tmp___2 = 1;
  } else {
#line 209
    tmp___2 = 0;
  }
#line 209
  return (tmp___2);
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 170 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/location.c"
struct __anonstruct_location_34  const  empty_location  =    {{(uniqstr )((void *)0), 0, 0}, {(uniqstr )((void *)0), 0, 0}};
#line 35 "/home/pronto/abs/test-suite/bison-2.4/src/location.c"
__inline static int add_column_width(int column , char const   *buf___0 , size_t bufsize ) 
{ 
  size_t width ;
  unsigned int remaining_columns ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 39
  remaining_columns = (unsigned int )(2147483647 - column);
#line 41
  if (buf___0) {
#line 43
    if (1073741823U <= bufsize) {
#line 44
      return (2147483647);
    }
    {
#line 45
    tmp = mbsnwidth(buf___0, bufsize, 0);
#line 45
    width = (size_t )tmp;
    }
  } else {
#line 48
    width = bufsize;
  }
#line 50
  if (width <= remaining_columns) {
#line 50
    tmp___0 = (size_t )column + width;
  } else {
#line 50
    tmp___0 = (size_t )2147483647;
  }
#line 50
  return ((int )tmp___0);
}
}
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/location.c"
void location_compute(location *loc___0 , boundary *cur , char const   *token , size_t size ) 
{ 
  int line ;
  int column ;
  char const   *p0 ;
  char const   *p ;
  char const   *lim ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 59
  line = cur->line;
#line 60
  column = cur->column;
#line 61
  p0 = token;
#line 62
  p = token;
#line 63
  lim = token + size;
#line 65
  loc___0->start = *cur;
#line 67
  p = token;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 67
      goto while_break;
    }
    {
#line 70
    if ((int const   )*p == 10) {
#line 70
      goto case_10;
    }
#line 76
    if ((int const   )*p == 9) {
#line 76
      goto case_9;
    }
#line 82
    goto switch_default;
    case_10: /* CIL Label */ 
#line 71
    line += line < 2147483647;
#line 72
    column = 1;
#line 73
    p0 = p + 1;
#line 74
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 77
    column = add_column_width(column, p0, (size_t )(p - p0));
#line 78
    column = add_column_width(column, (char const   *)((void *)0), (size_t )(8 - ((column - 1) & 7)));
#line 79
    p0 = p + 1;
    }
#line 80
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 83
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 67
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  cur->line = line;
#line 87
  column = add_column_width(column, p0, (size_t )(p - p0));
#line 87
  cur->column = column;
#line 89
  loc___0->end = *cur;
  }
#line 91
  if (line == 2147483647) {
#line 91
    if (loc___0->start.line != 2147483647) {
      {
#line 92
      tmp = gettext("line number overflow");
#line 92
      warn_at(*loc___0, (char const   *)tmp);
      }
    }
  }
#line 93
  if (column == 2147483647) {
#line 93
    if (loc___0->start.column != 2147483647) {
      {
#line 94
      tmp___0 = gettext("column number overflow");
#line 94
      warn_at(*loc___0, (char const   *)tmp___0);
      }
    }
  }
#line 95
  return;
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.4/src/location.c"
void location_print(FILE *out , location loc___0 ) 
{ 
  int end_col ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 103
  if (0 < loc___0.end.column) {
#line 103
    tmp = loc___0.end.column - 1;
  } else {
#line 103
    tmp = 0;
  }
  {
#line 103
  end_col = tmp;
#line 104
  tmp___0 = quotearg_n_style(3, (enum quoting_style )5, loc___0.start.file);
#line 104
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s:%d.%d",
          tmp___0, loc___0.start.line, loc___0.start.column);
  }
#line 108
  if ((unsigned long )loc___0.start.file != (unsigned long )loc___0.end.file) {
    {
#line 109
    tmp___1 = quotearg_n_style(3, (enum quoting_style )5, loc___0.end.file);
#line 109
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"-%s:%d.%d",
            tmp___1, loc___0.end.line, end_col);
    }
  } else
#line 112
  if (loc___0.start.line < loc___0.end.line) {
    {
#line 113
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"-%d.%d",
            loc___0.end.line, end_col);
    }
  } else
#line 114
  if (loc___0.start.column < end_col) {
    {
#line 115
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"-%d",
            end_col);
    }
  }
#line 116
  return;
}
}
#line 118 "/home/pronto/abs/test-suite/bison-2.4/src/location.c"
void boundary_set_from_string(boundary *bound , char *loc_str ) 
{ 
  char *delim ;
  char *tmp ;

  {
  {
#line 123
  tmp = strrchr((char const   *)loc_str, '.');
#line 123
  delim = tmp;
#line 124
  aver((_Bool )delim);
#line 125
  *delim = (char )'\000';
#line 126
  bound->column = atoi((char const   *)(delim + 1));
#line 127
  delim = strrchr((char const   *)loc_str, ':');
#line 128
  aver((_Bool )delim);
#line 129
  *delim = (char )'\000';
#line 130
  bound->line = atoi((char const   *)(delim + 1));
#line 131
  bound->file = uniqstr_new((char const   *)loc_str);
  }
#line 132
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 252 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
size_t ritem_longest_rhs(void) ;
#line 162 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern struct state *transitions_to(transitions *shifts , symbol_number sym ) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/derives.h"
rule ***derives ;
#line 74 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.h"
goto_number *goto_map  ;
#line 77 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.h"
state_number *from_state  ;
#line 80 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.h"
state_number *to_state  ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static goto_number ngotos  ;
#line 62 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static bitsetv LA  =    (bitsetv )((void *)0);
#line 63 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
size_t nLA  ;
#line 68 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static bitsetv F___0  =    (bitsetv )((void *)0);
#line 70 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static goto_number **includes  ;
#line 71 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static goto_list **lookback  ;
#line 76 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void set_goto_map(void) 
{ 
  state_number s ;
  goto_number *temp_map ;
  void *tmp ;
  void *tmp___0 ;
  transitions *sp ;
  int i ;
  goto_number k ;
  int i___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  transitions *sp___0 ;
  int i___1 ;
  goto_number k___0 ;
  goto_number tmp___3 ;

  {
  {
#line 82
  tmp = xcalloc((size_t )(nvars + 1), (size_t )sizeof(*goto_map));
#line 82
  goto_map = (goto_number *)tmp;
#line 83
  tmp___0 = xnmalloc((size_t )(nvars + 1), (size_t )sizeof(*temp_map));
#line 83
  temp_map = (goto_number *)tmp___0;
#line 85
  ngotos = (goto_number )0;
#line 86
  s = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (s < nstates)) {
#line 86
      goto while_break;
    }
#line 88
    sp = (*(states + s))->transitions;
#line 90
    i = sp->num - 1;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (i >= 0) {
#line 90
        if (! (! ((sp->states[i])->accessing_symbol < ntokens))) {
#line 90
          goto while_break___0;
        }
      } else {
#line 90
        goto while_break___0;
      }
      {
#line 92
      ngotos ++;
#line 95
      aver((_Bool )(ngotos != 4294967295U));
#line 97
      (*(goto_map + ((sp->states[i])->accessing_symbol - ntokens))) ++;
#line 90
      i --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  k = (goto_number )0;
#line 104
  i___0 = ntokens;
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 104
    if (! (i___0 < nsyms)) {
#line 104
      goto while_break___1;
    }
#line 106
    *(temp_map + (i___0 - ntokens)) = k;
#line 107
    k += *(goto_map + (i___0 - ntokens));
#line 104
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 110
  i___0 = ntokens;
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    if (! (i___0 < nsyms)) {
#line 110
      goto while_break___2;
    }
#line 111
    *(goto_map + (i___0 - ntokens)) = *(temp_map + (i___0 - ntokens));
#line 110
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 113
  *(goto_map + (nsyms - ntokens)) = ngotos;
#line 114
  *(temp_map + (nsyms - ntokens)) = ngotos;
#line 117
  tmp___1 = xcalloc(ngotos, (size_t )sizeof(*from_state));
#line 117
  from_state = (state_number *)tmp___1;
#line 118
  tmp___2 = xcalloc(ngotos, (size_t )sizeof(*to_state));
#line 118
  to_state = (state_number *)tmp___2;
#line 120
  s = 0;
  }
  {
#line 120
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 120
    if (! (s < nstates)) {
#line 120
      goto while_break___3;
    }
#line 122
    sp___0 = (*(states + s))->transitions;
#line 124
    i___1 = sp___0->num - 1;
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (i___1 >= 0) {
#line 124
        if (! (! ((sp___0->states[i___1])->accessing_symbol < ntokens))) {
#line 124
          goto while_break___4;
        }
      } else {
#line 124
        goto while_break___4;
      }
#line 126
      tmp___3 = *(temp_map + ((sp___0->states[i___1])->accessing_symbol - ntokens));
#line 126
      (*(temp_map + ((sp___0->states[i___1])->accessing_symbol - ntokens))) ++;
#line 126
      k___0 = tmp___3;
#line 127
      *(from_state + k___0) = s;
#line 128
      *(to_state + k___0) = (sp___0->states[i___1])->number;
#line 124
      i___1 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 120
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 132
  free((void *)temp_map);
  }
#line 133
  return;
}
}
#line 141 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static goto_number map_goto(state_number s0 , symbol_number sym ) 
{ 
  goto_number high___0 ;
  goto_number low ;
  goto_number middle ;
  state_number s ;

  {
#line 149
  low = *(goto_map + (sym - ntokens));
#line 150
  high___0 = *(goto_map + ((sym - ntokens) + 1)) - 1U;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    aver((_Bool )(low <= high___0));
#line 155
    middle = (low + high___0) / 2U;
#line 156
    s = *(from_state + middle);
    }
#line 157
    if (s == s0) {
#line 158
      return (middle);
    } else
#line 159
    if (s < s0) {
#line 160
      low = middle + 1U;
    } else {
#line 162
      high___0 = middle - 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 167 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void initialize_F(void) 
{ 
  goto_number **reads ;
  void *tmp ;
  goto_number *edge ;
  void *tmp___0 ;
  goto_number nedges ;
  goto_number i ;
  state_number stateno ;
  transitions *sp ;
  int j ;
  symbol_number sym ;
  goto_number tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 170
  tmp = xnmalloc(ngotos, (size_t )sizeof(*reads));
#line 170
  reads = (goto_number **)tmp;
#line 171
  tmp___0 = xnmalloc(ngotos + 1U, (size_t )sizeof(*edge));
#line 171
  edge = (goto_number *)tmp___0;
#line 172
  nedges = (goto_number )0;
#line 176
  F___0 = bitsetv_create(ngotos, (bitset_bindex )ntokens, 1U);
#line 178
  i = (goto_number )0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < ngotos)) {
#line 178
      goto while_break;
    }
#line 180
    stateno = *(to_state + i);
#line 181
    sp = (*(states + stateno))->transitions;
#line 184
    j = 0;
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if (j < sp->num) {
#line 184
        if (! ((unsigned long )sp->states[j] == (unsigned long )((void *)0))) {
#line 184
          if (! ((sp->states[j])->accessing_symbol < ntokens)) {
#line 184
            goto while_break___0;
          }
        }
      } else {
#line 184
        goto while_break___0;
      }
#line 184
      if (! ((unsigned long )sp->states[j] == (unsigned long )((void *)0))) {
        {
#line 185
        bitset_set(*(F___0 + i), (bitset_bindex )(sp->states[j])->accessing_symbol);
        }
      }
#line 184
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if (! (j < sp->num)) {
#line 187
        goto while_break___1;
      }
#line 189
      sym = (sp->states[j])->accessing_symbol;
#line 190
      if (*(nullable + (sym - ntokens))) {
        {
#line 191
        tmp___1 = nedges;
#line 191
        nedges ++;
#line 191
        *(edge + tmp___1) = map_goto(stateno, sym);
        }
      }
#line 187
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    if (nedges == 0U) {
#line 195
      *(reads + i) = (goto_number *)((void *)0);
    } else {
      {
#line 198
      tmp___2 = xnmalloc(nedges + 1U, (size_t )sizeof(*(*(reads + i) + 0)));
#line 198
      *(reads + i) = (goto_number *)tmp___2;
#line 199
      memcpy((void */* __restrict  */)*(reads + i), (void const   */* __restrict  */)edge,
             (size_t )((unsigned long )nedges * sizeof(*(edge + 0))));
#line 200
      *(*(reads + i) + nedges) = (relation_node )-1;
#line 201
      nedges = (goto_number )0;
      }
    }
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  relation_digraph(reads, ngotos, & F___0);
#line 207
  i = (goto_number )0;
  }
  {
#line 207
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 207
    if (! (i < ngotos)) {
#line 207
      goto while_break___2;
    }
    {
#line 208
    free((void *)*(reads + i));
#line 207
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)reads);
#line 211
  free((void *)edge);
  }
#line 212
  return;
}
}
#line 215 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void add_lookback_edge(state *s , rule *r , goto_number gotono ) 
{ 
  int ri ;
  int tmp ;
  goto_list *sp ;
  void *tmp___0 ;

  {
  {
#line 218
  tmp = state_reduction_find(s, r);
#line 218
  ri = tmp;
#line 219
  tmp___0 = xmalloc((size_t )sizeof(*sp));
#line 219
  sp = (goto_list *)tmp___0;
#line 220
  sp->next = *(lookback + (((s->reductions)->lookahead_tokens - LA) + (long )ri));
#line 221
  sp->value = gotono;
#line 222
  *(lookback + (((s->reductions)->lookahead_tokens - LA) + (long )ri)) = sp;
  }
#line 223
  return;
}
}
#line 227 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void build_relations(void) 
{ 
  goto_number *edge ;
  void *tmp ;
  state_number *states1 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  goto_number i ;
  void *tmp___2 ;
  int nedges ;
  symbol_number symbol1 ;
  rule **rulep ;
  _Bool done ;
  int length ;
  item_number const   *rp ;
  state *s ;
  symbol_number tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  symbol_number tmp___7 ;
  int j ;
  void *tmp___8 ;

  {
  {
#line 230
  tmp = xnmalloc(ngotos + 1U, (size_t )sizeof(*edge));
#line 230
  edge = (goto_number *)tmp;
#line 231
  tmp___0 = ritem_longest_rhs();
#line 231
  tmp___1 = xnmalloc(tmp___0 + 1U, (size_t )sizeof(*states1));
#line 231
  states1 = (state_number *)tmp___1;
#line 234
  tmp___2 = xnmalloc(ngotos, (size_t )sizeof(*includes));
#line 234
  includes = (goto_number **)tmp___2;
#line 236
  i = (goto_number )0;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < ngotos)) {
#line 236
      goto while_break;
    }
#line 238
    nedges = 0;
#line 239
    symbol1 = (*(states + *(to_state + i)))->accessing_symbol;
#line 242
    rulep = *(derives + (symbol1 - ntokens));
    {
#line 242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 242
      if (! *rulep) {
#line 242
        goto while_break___0;
      }
#line 245
      length = 1;
#line 247
      s = *(states + *(from_state + i));
#line 248
      *(states1 + 0) = s->number;
#line 250
      rp = (item_number const   *)(*rulep)->rhs;
      {
#line 250
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 250
        tmp___5 = item_number_is_rule_number((item_number )*rp);
        }
#line 250
        if (tmp___5) {
#line 250
          goto while_break___1;
        }
        {
#line 252
        tmp___3 = item_number_as_symbol_number((item_number )*rp);
#line 252
        s = transitions_to(s->transitions, tmp___3);
#line 254
        tmp___4 = length;
#line 254
        length ++;
#line 254
        *(states1 + tmp___4) = s->number;
#line 250
        rp ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 257
      if (! s->consistent) {
        {
#line 258
        add_lookback_edge(s, *rulep, i);
        }
      }
#line 260
      length --;
#line 261
      done = (_Bool)0;
      {
#line 262
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 262
        if (! (! done)) {
#line 262
          goto while_break___2;
        }
#line 264
        done = (_Bool)1;
#line 268
        rp --;
#line 269
        if (*rp >= (item_number const   )ntokens) {
          {
#line 272
          tmp___6 = nedges;
#line 272
          nedges ++;
#line 272
          tmp___7 = item_number_as_symbol_number((item_number )*rp);
#line 272
          length --;
#line 272
          *(edge + tmp___6) = map_goto(*(states1 + length), tmp___7);
          }
#line 274
          if (*(nullable + (*rp - (item_number const   )ntokens))) {
#line 275
            done = (_Bool)0;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 242
      rulep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    if (nedges == 0) {
#line 281
      *(includes + i) = (goto_number *)((void *)0);
    } else {
      {
#line 285
      tmp___8 = xnmalloc((size_t )(nedges + 1), (size_t )sizeof(*(*(includes + i) + 0)));
#line 285
      *(includes + i) = (goto_number *)tmp___8;
#line 286
      j = 0;
      }
      {
#line 286
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 286
        if (! (j < nedges)) {
#line 286
          goto while_break___3;
        }
#line 287
        *(*(includes + i) + j) = *(edge + j);
#line 286
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 288
      *(*(includes + i) + nedges) = (relation_node )-1;
    }
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  free((void *)edge);
#line 293
  free((void *)states1);
#line 295
  relation_transpose(& includes, ngotos);
  }
#line 296
  return;
}
}
#line 300 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void compute_FOLLOWS(void) 
{ 
  goto_number i ;

  {
  {
#line 305
  relation_digraph(includes, ngotos, & F___0);
#line 307
  i = (goto_number )0;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < ngotos)) {
#line 307
      goto while_break;
    }
    {
#line 308
    free((void *)*(includes + i));
#line 307
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  free((void *)includes);
  }
#line 311
  return;
}
}
#line 314 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void compute_lookahead_tokens(void) 
{ 
  size_t i ;
  goto_list *sp ;
  goto_list *_node ;
  goto_list *_next ;

  {
#line 320
  i = (size_t )0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < nLA)) {
#line 320
      goto while_break;
    }
#line 321
    sp = *(lookback + i);
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! sp) {
#line 321
        goto while_break___0;
      }
      {
#line 322
      (*(((*(LA + i))->b.vtable)->or_))(*(LA + i), *(LA + i), *(F___0 + sp->value));
#line 321
      sp = sp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  i = (size_t )0;
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 325
    if (! (i < nLA)) {
#line 325
      goto while_break___1;
    }
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 326
      _node = *(lookback + i);
      {
#line 326
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 326
        if (! _node) {
#line 326
          goto while_break___3;
        }
        {
#line 326
        _next = _node->next;
#line 326
        free((void *)_node);
#line 326
        _node = _next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 326
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 325
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 328
  free((void *)lookback);
#line 329
  bitsetv_free(F___0);
  }
#line 330
  return;
}
}
#line 338 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static int state_lookahead_tokens_count(state *s ) 
{ 
  int n_lookahead_tokens ;
  reductions *rp ;
  transitions *sp ;
  int tmp ;

  {
#line 341
  n_lookahead_tokens = 0;
#line 342
  rp = s->reductions;
#line 343
  sp = s->transitions;
#line 352
  if (sp->num == 0) {
#line 352
    tmp = 1;
  } else
#line 352
  if (! ((unsigned long )sp->states[0] == (unsigned long )((void *)0))) {
#line 352
    tmp = 1;
  } else {
#line 352
    tmp = 0;
  }
  {
#line 352
  aver((_Bool )tmp);
  }
#line 353
  if (rp->num > 1) {
#line 355
    n_lookahead_tokens += rp->num;
  } else
#line 353
  if (rp->num == 1) {
#line 353
    if (sp->num) {
#line 353
      if ((sp->states[0])->accessing_symbol < ntokens) {
#line 355
        n_lookahead_tokens += rp->num;
      } else {
#line 357
        s->consistent = (char)1;
      }
    } else {
#line 357
      s->consistent = (char)1;
    }
  } else {
#line 357
    s->consistent = (char)1;
  }
#line 359
  return (n_lookahead_tokens);
}
}
#line 367 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void initialize_LA(void) 
{ 
  state_number i ;
  bitsetv pLA ;
  int tmp ;
  void *tmp___0 ;
  int count ;
  int tmp___1 ;

  {
#line 374
  nLA = (size_t )0;
#line 375
  i = 0;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i < nstates)) {
#line 375
      goto while_break;
    }
    {
#line 376
    tmp = state_lookahead_tokens_count(*(states + i));
#line 376
    nLA += (size_t )tmp;
#line 375
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  if (! nLA) {
#line 379
    nLA = (size_t )1;
  }
  {
#line 381
  LA = bitsetv_create(nLA, (bitset_bindex )ntokens, 1U);
#line 381
  pLA = LA;
#line 382
  tmp___0 = xcalloc(nLA, (size_t )sizeof(*lookback));
#line 382
  lookback = (goto_list **)tmp___0;
#line 386
  i = 0;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (i < nstates)) {
#line 386
      goto while_break___0;
    }
    {
#line 388
    tmp___1 = state_lookahead_tokens_count(*(states + i));
#line 388
    count = tmp___1;
    }
#line 389
    if (count) {
#line 391
      ((*(states + i))->reductions)->lookahead_tokens = pLA;
#line 392
      pLA += count;
    }
#line 386
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 402 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
static void lookahead_tokens_print(FILE *out ) 
{ 
  state_number i ;
  int j ;
  int k ;
  reductions *reds ;
  bitset_iterator iter ;
  int n_lookahead_tokens ;

  {
  {
#line 407
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Lookahead tokens: BEGIN\n");
#line 408
  i = 0;
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i < nstates)) {
#line 408
      goto while_break;
    }
#line 410
    reds = (*(states + i))->reductions;
#line 412
    n_lookahead_tokens = 0;
#line 414
    if (reds->lookahead_tokens) {
#line 415
      k = 0;
      {
#line 415
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 415
        if (! (k < reds->num)) {
#line 415
          goto while_break___0;
        }
#line 416
        if (*(reds->lookahead_tokens + k)) {
#line 417
          n_lookahead_tokens ++;
        }
#line 415
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 419
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"State %d: %d lookahead tokens\n",
            i, n_lookahead_tokens);
    }
#line 422
    if (reds->lookahead_tokens) {
#line 423
      j = 0;
      {
#line 423
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 423
        if (! (j < reds->num)) {
#line 423
          goto while_break___1;
        }
#line 424
        iter.next = (bitset_bindex )0;
#line 424
        iter.num = (bitset_bindex )1024;
        {
#line 424
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 424
          if (iter.num == 1024U) {
            {
#line 424
            iter.num = (*(((*(reds->lookahead_tokens + j))->b.vtable)->list))(*(reds->lookahead_tokens + j),
                                                                              iter.list,
                                                                              (bitset_bindex )1024,
                                                                              & iter.next);
            }
#line 424
            if (! iter.num) {
#line 424
              goto while_break___2;
            }
          } else {
#line 424
            goto while_break___2;
          }
#line 424
          iter.i = (bitset_bindex )0;
          {
#line 424
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 424
            if (iter.i < iter.num) {
#line 424
              k = (int )iter.list[iter.i];
            } else {
#line 424
              goto while_break___3;
            }
            {
#line 426
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"   on %d (%s) -> rule %d\n",
                    k, (*(symbols + k))->tag, (reds->rules[j])->number);
#line 424
            (iter.i) ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 423
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 408
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Lookahead tokens: END\n");
  }
#line 432
  return;
}
}
#line 434 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
void lalr(void) 
{ 


  {
  {
#line 437
  initialize_LA();
#line 438
  set_goto_map();
#line 439
  initialize_F();
#line 440
  build_relations();
#line 441
  compute_FOLLOWS();
#line 442
  compute_lookahead_tokens();
  }
#line 444
  if (trace_flag & 8) {
    {
#line 445
    lookahead_tokens_print(stderr);
    }
  }
#line 446
  return;
}
}
#line 449 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
void lalr_update_state_numbers(state_number *old_to_new , state_number nstates_old ) 
{ 
  goto_number ngotos_reachable ;
  symbol_number nonterminal ;
  goto_number i ;
  symbol_number tmp ;
  symbol_number tmp___0 ;

  {
  {
#line 452
  ngotos_reachable = (goto_number )0;
#line 453
  nonterminal = 0;
#line 454
  aver((_Bool )(nsyms == nvars + ntokens));
#line 457
  i = (goto_number )0;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (i < ngotos)) {
#line 457
      goto while_break;
    }
    {
#line 459
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 459
      if (! (i == *(goto_map + nonterminal))) {
#line 459
        goto while_break___0;
      }
#line 460
      tmp = nonterminal;
#line 460
      nonterminal ++;
#line 460
      *(goto_map + tmp) = ngotos_reachable;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    if (*(old_to_new + *(from_state + i)) != nstates_old) {
      {
#line 467
      aver((_Bool )(*(old_to_new + *(to_state + i)) != nstates_old));
#line 468
      *(from_state + ngotos_reachable) = *(old_to_new + *(from_state + i));
#line 469
      *(to_state + ngotos_reachable) = *(old_to_new + *(to_state + i));
#line 470
      ngotos_reachable ++;
      }
    }
#line 457
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 474
    if (! (nonterminal <= nvars)) {
#line 474
      goto while_break___1;
    }
    {
#line 476
    aver((_Bool )(ngotos == *(goto_map + nonterminal)));
#line 477
    tmp___0 = nonterminal;
#line 477
    nonterminal ++;
#line 477
    *(goto_map + tmp___0) = ngotos_reachable;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 479
  ngotos = ngotos_reachable;
#line 480
  return;
}
}
#line 483 "/home/pronto/abs/test-suite/bison-2.4/src/lalr.c"
void lalr_free(void) 
{ 
  state_number s ;

  {
#line 487
  s = 0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! (s < nstates)) {
#line 487
      goto while_break;
    }
#line 488
    ((*(states + s))->reductions)->lookahead_tokens = (bitset *)((void *)0);
#line 487
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  bitsetv_free(LA);
  }
#line 490
  return;
}
}
#line 209 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
_Bool rule_useful_in_grammar_p(rule *r ) ;
#line 223
void rule_lhs_print_xml(rule *r , FILE *out , int level ) ;
#line 229
void rule_rhs_print(rule *r , FILE *out ) ;
#line 232
void rule_print(rule *r , FILE *out ) ;
#line 34 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
item_number *ritem  =    (item_number *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
unsigned int nritems  =    0U;
#line 37 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
rule *rules  =    (rule *)((void *)0);
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
rule_number nrules  =    0;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
symbol **symbols  =    (symbol **)((void *)0);
#line 41 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
int nsyms  =    0;
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
int ntokens  =    1;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
int nvars  =    0;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
symbol_number *token_translations  =    (symbol_number *)((void *)0);
#line 47 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
int max_user_token_number  =    256;
#line 49 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
_Bool rule_useful_in_grammar_p(rule *r ) 
{ 


  {
#line 52
  return ((_Bool )(r->number < nrules));
}
}
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
_Bool rule_useless_in_grammar_p(rule *r ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 58
  tmp = rule_useful_in_grammar_p(r);
  }
#line 58
  if (tmp) {
#line 58
    tmp___0 = 0;
  } else {
#line 58
    tmp___0 = 1;
  }
#line 58
  return ((_Bool )tmp___0);
}
}
#line 61 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
_Bool rule_useless_in_parser_p(rule *r ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 64
  if (! r->useful) {
    {
#line 64
    tmp = rule_useful_in_grammar_p(r);
    }
#line 64
    if (tmp) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return ((_Bool )tmp___0);
}
}
#line 67 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void rule_lhs_print(rule *r , symbol *previous_lhs , FILE *out ) 
{ 
  int n ;
  size_t tmp ;

  {
  {
#line 70
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  %3d ",
          r->number);
  }
#line 71
  if ((unsigned long )previous_lhs != (unsigned long )r->lhs) {
    {
#line 73
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s:",
            (r->lhs)->tag);
    }
  } else {
    {
#line 78
    tmp = strlen(previous_lhs->tag);
#line 78
    n = (int )tmp;
    }
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if (! (n > 0)) {
#line 78
        goto while_break;
      }
      {
#line 79
      fputc_unlocked(' ', out);
#line 78
      n --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 80
    fputc_unlocked('|', out);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void rule_lhs_print_xml(rule *r , FILE *out , int level ) 
{ 


  {
  {
#line 87
  xml_printf(out, level, "<lhs>%s</lhs>", (r->lhs)->tag);
  }
#line 88
  return;
}
}
#line 90 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
int rule_rhs_length(rule *r ) 
{ 
  int res ;
  item_number *rhsp ;

  {
#line 93
  res = 0;
#line 95
  rhsp = r->rhs;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (*rhsp >= 0)) {
#line 95
      goto while_break;
    }
#line 96
    res ++;
#line 95
    rhsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (res);
}
}
#line 100 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void rule_rhs_print(rule *r , FILE *out ) 
{ 
  item_number *rp ;
  char *tmp ;

  {
#line 103
  if (*(r->rhs) >= 0) {
#line 106
    rp = r->rhs;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! (*rp >= 0)) {
#line 106
        goto while_break;
      }
      {
#line 107
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" %s",
              (*(symbols + *rp))->tag);
#line 106
      rp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    fputc_unlocked('\n', out);
    }
  } else {
    {
#line 112
    tmp = gettext("empty");
#line 112
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" /* %s */\n",
            tmp);
    }
  }
#line 114
  return;
}
}
#line 116 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
static void rule_rhs_print_xml(rule *r , FILE *out , int level ) 
{ 
  item_number *rp ;
  char const   *tmp ;

  {
#line 119
  if (*(r->rhs) >= 0) {
    {
#line 122
    xml_puts(out, level, "<rhs>");
#line 123
    rp = r->rhs;
    }
    {
#line 123
    while (1) {
      while_continue: /* CIL Label */ ;
#line 123
      if (! (*rp >= 0)) {
#line 123
        goto while_break;
      }
      {
#line 124
      tmp = xml_escape((*(symbols + *rp))->tag);
#line 124
      xml_printf(out, level + 1, "<symbol>%s</symbol>", tmp);
#line 123
      rp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 126
    xml_puts(out, level, "</rhs>");
    }
  } else {
    {
#line 130
    xml_puts(out, level, "<rhs>");
#line 131
    xml_puts(out, level + 1, "<empty/>");
#line 132
    xml_puts(out, level, "</rhs>");
    }
  }
#line 134
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void rule_print(rule *r , FILE *out ) 
{ 


  {
  {
#line 139
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s:", (r->lhs)->tag);
#line 140
  rule_rhs_print(r, out);
  }
#line 141
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void ritem_print(FILE *out ) 
{ 
  unsigned int i ;
  rule_number tmp ;

  {
  {
#line 147
  fputs_unlocked((char const   */* __restrict  */)"RITEM\n", (FILE */* __restrict  */)out);
#line 148
  i = 0U;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < nritems)) {
#line 148
      goto while_break;
    }
#line 149
    if (*(ritem + i) >= 0) {
      {
#line 150
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  %s",
              (*(symbols + *(ritem + i)))->tag);
      }
    } else {
      {
#line 152
      tmp = item_number_as_rule_number(*(ritem + i));
#line 152
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  (rule %d)\n",
              tmp);
      }
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
  }
#line 154
  return;
}
}
#line 156 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
size_t ritem_longest_rhs(void) 
{ 
  int max ;
  rule_number r ;
  int length ;
  int tmp ;

  {
#line 159
  max = 0;
#line 162
  r = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (r < nrules)) {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp = rule_rhs_length(rules + r);
#line 164
    length = tmp;
    }
#line 165
    if (length > max) {
#line 166
      max = length;
    }
#line 162
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return ((size_t )max);
}
}
#line 172 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_rules_partial_print(FILE *out , char const   *title , _Bool (*filter)(rule * ) ) 
{ 
  rule_number r ;
  _Bool first ;
  symbol *previous_lhs ;
  _Bool tmp ;

  {
#line 177
  first = (_Bool)1;
#line 178
  previous_lhs = (symbol *)((void *)0);
#line 181
  r = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (r < nrules + nuseless_productions)) {
#line 181
      goto while_break;
    }
#line 183
    if (filter) {
      {
#line 183
      tmp = (*filter)(rules + r);
      }
#line 183
      if (! tmp) {
#line 184
        goto __Cont;
      }
    }
#line 185
    if (first) {
      {
#line 186
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
              title);
      }
    } else
#line 187
    if (previous_lhs) {
#line 187
      if ((unsigned long )previous_lhs != (unsigned long )(rules + r)->lhs) {
        {
#line 188
        fputc_unlocked('\n', out);
        }
      }
    }
    {
#line 189
    first = (_Bool)0;
#line 190
    rule_lhs_print(rules + r, previous_lhs, out);
#line 191
    rule_rhs_print(rules + r, out);
#line 192
    previous_lhs = (rules + r)->lhs;
    }
    __Cont: /* CIL Label */ 
#line 181
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (! first) {
    {
#line 195
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 196
  return;
}
}
#line 198 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_rules_print(FILE *out ) 
{ 
  char *tmp ;

  {
  {
#line 201
  tmp = gettext("Grammar");
#line 201
  grammar_rules_partial_print(out, (char const   *)tmp, & rule_useful_in_grammar_p);
  }
#line 202
  return;
}
}
#line 204 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_rules_print_xml(FILE *out , int level ) 
{ 
  rule_number r ;
  _Bool first ;
  char const   *usefulness ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 208
  first = (_Bool)1;
#line 210
  r = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (r < nrules + nuseless_productions)) {
#line 210
      goto while_break;
    }
#line 212
    if (first) {
      {
#line 213
      xml_puts(out, level + 1, "<rules>");
      }
    }
    {
#line 214
    first = (_Bool)0;
#line 217
    tmp___0 = rule_useless_in_grammar_p(rules + r);
    }
#line 217
    if (tmp___0) {
#line 218
      usefulness = "useless-in-grammar";
    } else {
      {
#line 219
      tmp = rule_useless_in_parser_p(rules + r);
      }
#line 219
      if (tmp) {
#line 220
        usefulness = "useless-in-parser";
      } else {
#line 222
        usefulness = "useful";
      }
    }
    {
#line 223
    xml_indent(out, level + 2);
#line 224
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"<rule number=\"%d\" usefulness=\"%s\"",
            (rules + r)->number, usefulness);
    }
#line 226
    if ((rules + r)->precsym) {
      {
#line 227
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" percent_prec=\"%s\"",
              ((rules + r)->precsym)->tag);
      }
    }
    {
#line 228
    fputs_unlocked((char const   */* __restrict  */)">\n", (FILE */* __restrict  */)out);
#line 230
    rule_lhs_print_xml(rules + r, out, level + 3);
#line 231
    rule_rhs_print_xml(rules + r, out, level + 3);
#line 232
    xml_puts(out, level + 2, "</rule>");
#line 210
    r ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if (! first) {
    {
#line 235
    xml_puts(out, level + 1, "</rules>");
    }
  } else {
    {
#line 237
    xml_puts(out, level + 1, "<rules/>");
    }
  }
#line 238
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_dump(FILE *out , char const   *title ) 
{ 
  symbol_number i ;
  rule_number i___0 ;
  rule *rule_i ;
  item_number *rp ;
  unsigned int rhs_itemno ;
  unsigned int rhs_count ;
  unsigned int tmp ;
  int tmp___0 ;
  rule_number tmp___1 ;
  rule_number r ;

  {
  {
#line 243
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s\n\n",
          title);
#line 244
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"ntokens = %d, nvars = %d, nsyms = %d, nrules = %d, nritems = %d\n\n",
          ntokens, nvars, nsyms, nrules, nritems);
#line 249
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Variables\n---------\n\n");
#line 252
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Value  Sprec  Sassoc  Tag\n");
#line 254
  i = ntokens;
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < nsyms)) {
#line 254
      goto while_break;
    }
    {
#line 255
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%5d  %5d   %5d  %s\n",
            i, (*(symbols + i))->prec, (unsigned int )(*(symbols + i))->assoc, (*(symbols + i))->tag);
#line 254
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n\n");
#line 262
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Rules\n-----\n\n");
#line 265
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Num (Prec, Assoc, Useful, Ritem Range) Lhs -> Rhs (Ritem range) [Num]\n");
#line 266
  i___0 = 0;
  }
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    if (! (i___0 < nrules + nuseless_productions)) {
#line 266
      goto while_break___0;
    }
#line 268
    rule_i = rules + i___0;
#line 269
    rp = (item_number *)((void *)0);
#line 270
    rhs_itemno = (unsigned int )(rule_i->rhs - ritem);
#line 271
    rhs_count = 0U;
#line 273
    rp = rule_i->rhs;
    {
#line 273
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 273
      if (! (*rp >= 0)) {
#line 273
        goto while_break___1;
      }
#line 274
      rhs_count ++;
#line 273
      rp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 275
    if (rule_i->prec) {
#line 275
      tmp = (unsigned int )(rule_i->prec)->assoc;
    } else {
#line 275
      tmp = 0U;
    }
#line 275
    if (rule_i->prec) {
#line 275
      tmp___0 = (rule_i->prec)->prec;
    } else {
#line 275
      tmp___0 = 0;
    }
    {
#line 275
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%3d (%2d, %2d, %2d, %2u-%2u)   %2d ->",
            i___0, tmp___0, tmp, (int )rule_i->useful, rhs_itemno, (rhs_itemno + rhs_count) - 1U,
            (rule_i->lhs)->number);
#line 284
    rp = rule_i->rhs;
    }
    {
#line 284
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 284
      if (! (*rp >= 0)) {
#line 284
        goto while_break___2;
      }
      {
#line 285
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" %3d",
              *rp);
#line 284
      rp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 286
    tmp___1 = item_number_as_rule_number(*rp);
#line 286
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  [%d]\n",
            tmp___1);
#line 266
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 289
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n\n");
#line 291
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Rules interpreted\n-----------------\n\n");
#line 294
  r = 0;
  }
  {
#line 294
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 294
    if (! (r < nrules + nuseless_productions)) {
#line 294
      goto while_break___3;
    }
    {
#line 296
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%-5d  ",
            r);
#line 297
    rule_print(rules + r, out);
#line 294
    r ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 300
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n\n");
  }
#line 301
  return;
}
}
#line 303 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_rules_useless_report(char const   *message ) 
{ 
  rule_number r ;
  char *tmp ;

  {
#line 307
  r = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (r < nrules)) {
#line 307
      goto while_break;
    }
#line 308
    if (! (rules + r)->useful) {
      {
#line 310
      location_print(stderr, (rules + r)->location);
#line 311
      tmp = gettext("warning");
#line 311
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s: %s: ",
              tmp, message);
#line 312
      rule_print(rules + r, stderr);
      }
    }
#line 307
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 316 "/home/pronto/abs/test-suite/bison-2.4/src/gram.c"
void grammar_free(void) 
{ 


  {
#line 319
  if (ritem) {
    {
#line 320
    free((void *)(ritem - 1));
    }
  }
  {
#line 321
  free((void *)rules);
#line 322
  free((void *)token_translations);
#line 324
  symbols_free();
#line 325
  free_merger_functions();
  }
#line 326
  return;
}
}
#line 30 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *parser_file_name  ;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *dir_prefix  ;
#line 62 "/home/pronto/abs/test-suite/bison-2.4/src/files.h"
char *all_but_ext  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char const   *spec_outfile  =    (char const   *)((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char const   *spec_file_prefix  =    (char const   *)((void *)0);
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char const   *spec_name_prefix  =    (char const   *)((void *)0);
#line 46 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char *spec_verbose_file  =    (char *)((void *)0);
#line 47 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char *spec_graph_file  =    (char *)((void *)0);
#line 48 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char *spec_xml_file  =    (char *)((void *)0);
#line 49 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
char *spec_defines_file  =    (char *)((void *)0);
#line 53 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static char **file_names  =    (char **)((void *)0);
#line 54 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static int file_names_count  =    0;
#line 56 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
uniqstr grammar_file  =    (uniqstr )((void *)0);
#line 57 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
uniqstr current_file  =    (uniqstr )((void *)0);
#line 76 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static char *all_but_tab_ext  ;
#line 80 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static char *src_extension  =    (char *)((void *)0);
#line 82 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static char *header_extension  =    (char *)((void *)0);
#line 89 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static char *concat2(char const   *str1 , char const   *str2 ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *res ;
  void *tmp___1 ;
  char *cp ;

  {
  {
#line 92
  tmp = strlen(str1);
#line 92
  tmp___0 = strlen(str2);
#line 92
  len = tmp + tmp___0;
#line 93
  tmp___1 = xmalloc(len + 1U);
#line 93
  res = (char *)tmp___1;
#line 95
  cp = stpcpy((char */* __restrict  */)res, (char const   */* __restrict  */)str1);
#line 96
  cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)str2);
  }
#line 97
  return (res);
}
}
#line 105 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
FILE *xfopen(char const   *name , char const   *mode ) 
{ 
  FILE *ptr ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 110
  ptr = fopen_safer(name, mode);
  }
#line 111
  if (! ptr) {
    {
#line 112
    tmp = gettext("cannot open file `%s\'");
#line 112
    tmp___0 = get_errno();
#line 112
    error(1, tmp___0, (char const   *)tmp, name);
    }
  }
#line 114
  return (ptr);
}
}
#line 121 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
void xfclose(FILE *ptr ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 124
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 125
    return;
  }
  {
#line 127
  tmp___0 = ferror_unlocked(ptr);
  }
#line 127
  if (tmp___0) {
    {
#line 128
    tmp = gettext("I/O error");
#line 128
    error(1, 0, (char const   *)tmp);
    }
  }
  {
#line 130
  tmp___3 = fclose(ptr);
  }
#line 130
  if (tmp___3 != 0) {
    {
#line 131
    tmp___1 = gettext("cannot close file");
#line 131
    tmp___2 = get_errno();
#line 131
    error(1, tmp___2, (char const   *)tmp___1);
    }
  }
#line 132
  return;
}
}
#line 140 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static void tr(char *s , char from , char to ) 
{ 


  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! *s) {
#line 143
      goto while_break;
    }
#line 144
    if ((int )*s == (int )from) {
#line 145
      *s = to;
    }
#line 143
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 149 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static void compute_exts_from_gf(char const   *ext ) 
{ 
  int tmp ;

  {
  {
#line 152
  tmp = strcmp(ext, ".y");
  }
#line 152
  if (tmp == 0) {
    {
#line 154
    src_extension = xstrdup((char const   *)(language->src_extension));
#line 155
    header_extension = xstrdup((char const   *)(language->header_extension));
    }
  } else {
    {
#line 159
    src_extension = xstrdup(ext);
#line 160
    header_extension = xstrdup(ext);
#line 161
    tr(src_extension, (char )'y', (char )'c');
#line 162
    tr(src_extension, (char )'Y', (char )'C');
#line 163
    tr(header_extension, (char )'y', (char )'h');
#line 164
    tr(header_extension, (char )'Y', (char )'H');
    }
  }
#line 166
  return;
}
}
#line 169 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static void compute_exts_from_src(char const   *ext ) 
{ 


  {
  {
#line 175
  src_extension = xstrdup(ext);
#line 176
  header_extension = xstrdup(ext);
#line 177
  tr(header_extension, (char )'c', (char )'h');
#line 178
  tr(header_extension, (char )'C', (char )'H');
  }
#line 179
  return;
}
}
#line 210 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static void file_name_split(char const   *file_name , char const   **base___0 , char const   **tab ,
                            char const   **ext ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t baselen ;
  size_t dottablen ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 214
  tmp = last_component(file_name);
#line 214
  *base___0 = (char const   *)tmp;
#line 217
  tmp___0 = strrchr(*base___0, '.');
#line 217
  *ext = (char const   *)tmp___0;
#line 218
  *tab = (char const   *)((void *)0);
  }
#line 222
  if (*ext) {
#line 224
    baselen = (size_t )(*ext - *base___0);
#line 225
    dottablen = (size_t )4;
#line 226
    if (dottablen < baselen) {
      {
#line 226
      tmp___1 = strncmp(*ext - dottablen, ".tab", dottablen);
      }
#line 226
      if (tmp___1 == 0) {
#line 229
        *tab = *ext - dottablen;
      } else {
        {
#line 226
        tmp___2 = strncmp(*ext - dottablen, "_tab", dottablen);
        }
#line 226
        if (tmp___2 == 0) {
#line 229
          *tab = *ext - dottablen;
        }
      }
    }
  }
#line 231
  return;
}
}
#line 234 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
static void compute_file_name_parts(void) 
{ 
  char const   *base___0 ;
  char const   *tab ;
  char const   *ext ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 244
  if (spec_outfile) {
    {
#line 246
    file_name_split(spec_outfile, & base___0, & tab, & ext);
#line 247
    dir_prefix = xstrndup(spec_outfile, (size_t )(base___0 - spec_outfile));
#line 250
    tmp = strlen(spec_outfile);
    }
#line 250
    if (ext) {
      {
#line 250
      tmp___0 = strlen(ext);
#line 250
      tmp___1 = tmp___0;
      }
    } else {
#line 250
      tmp___1 = (size_t )0;
    }
    {
#line 250
    all_but_ext = xstrndup(spec_outfile, tmp - tmp___1);
#line 255
    tmp___2 = strlen(spec_outfile);
    }
#line 255
    if (tab) {
      {
#line 255
      tmp___3 = strlen(tab);
#line 255
      tmp___6 = tmp___3;
      }
    } else {
#line 255
      if (ext) {
        {
#line 255
        tmp___4 = strlen(ext);
#line 255
        tmp___5 = tmp___4;
        }
      } else {
#line 255
        tmp___5 = (size_t )0;
      }
#line 255
      tmp___6 = tmp___5;
    }
    {
#line 255
    all_but_tab_ext = xstrndup(spec_outfile, tmp___2 - tmp___6);
    }
#line 260
    if (ext) {
      {
#line 261
      compute_exts_from_src(ext);
      }
    }
  } else {
    {
#line 265
    file_name_split(grammar_file, & base___0, & tab, & ext);
    }
#line 267
    if (spec_file_prefix) {
      {
#line 270
      tmp___7 = last_component(spec_file_prefix);
#line 270
      dir_prefix = xstrndup(spec_file_prefix, (size_t )(tmp___7 - (char *)spec_file_prefix));
#line 273
      all_but_tab_ext = xstrdup(spec_file_prefix);
      }
    } else
#line 275
    if (yacc_flag) {
      {
#line 278
      dir_prefix = xstrdup("");
#line 279
      all_but_tab_ext = xstrdup("y");
      }
    } else {
      {
#line 285
      dir_prefix = xstrdup("");
#line 286
      tmp___8 = strlen(base___0);
      }
#line 286
      if (ext) {
        {
#line 286
        tmp___9 = strlen(ext);
#line 286
        tmp___10 = tmp___9;
        }
      } else {
#line 286
        tmp___10 = (size_t )0;
      }
      {
#line 286
      all_but_tab_ext = xstrndup(base___0, tmp___8 - tmp___10);
      }
    }
#line 290
    if (language->add_tab) {
      {
#line 291
      all_but_ext = concat2((char const   *)all_but_tab_ext, ".tab");
      }
    } else {
      {
#line 293
      all_but_ext = xstrdup((char const   *)all_but_tab_ext);
      }
    }
#line 296
    if (ext) {
#line 296
      if (! yacc_flag) {
        {
#line 297
        compute_exts_from_gf(ext);
        }
      }
    }
  }
#line 299
  return;
}
}
#line 305 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
void compute_output_file_names(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 308
  compute_file_name_parts();
  }
#line 311
  if (! src_extension) {
    {
#line 312
    src_extension = xstrdup(".c");
    }
  }
#line 313
  if (! header_extension) {
    {
#line 314
    header_extension = xstrdup(".h");
    }
  }
#line 316
  if (spec_outfile) {
    {
#line 316
    tmp = xstrdup(spec_outfile);
#line 316
    parser_file_name = tmp;
    }
  } else {
    {
#line 316
    tmp___0 = concat2((char const   *)all_but_ext, (char const   *)src_extension);
#line 316
    parser_file_name = tmp___0;
    }
  }
#line 321
  if (defines_flag) {
#line 323
    if (! spec_defines_file) {
      {
#line 324
      spec_defines_file = concat2((char const   *)all_but_ext, (char const   *)header_extension);
      }
    }
  }
#line 327
  if (graph_flag) {
#line 329
    if (! spec_graph_file) {
      {
#line 330
      spec_graph_file = concat2((char const   *)all_but_tab_ext, ".dot");
      }
    }
    {
#line 331
    output_file_name_check((char const   *)spec_graph_file);
    }
  }
#line 334
  if (xml_flag) {
#line 336
    if (! spec_xml_file) {
      {
#line 337
      spec_xml_file = concat2((char const   *)all_but_tab_ext, ".xml");
      }
    }
    {
#line 338
    output_file_name_check((char const   *)spec_xml_file);
    }
  }
#line 341
  if (report_flag) {
#line 343
    if (! spec_verbose_file) {
      {
#line 344
      spec_verbose_file = concat2((char const   *)all_but_tab_ext, ".output");
      }
    }
    {
#line 345
    output_file_name_check((char const   *)spec_verbose_file);
    }
  }
  {
#line 348
  free((void *)all_but_tab_ext);
#line 349
  free((void *)src_extension);
#line 350
  free((void *)header_extension);
  }
#line 351
  return;
}
}
#line 353 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
void output_file_name_check(char const   *file_name ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int i ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 356
  tmp___1 = strcmp(file_name, grammar_file);
  }
#line 356
  if (0 == tmp___1) {
    {
#line 357
    tmp = quote(file_name);
#line 357
    tmp___0 = gettext("refusing to overwrite the input file %s");
#line 357
    fatal((char const   *)tmp___0, tmp);
    }
  }
#line 360
  i = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < file_names_count)) {
#line 360
      goto while_break;
    }
    {
#line 361
    tmp___4 = strcmp((char const   *)*(file_names + i), file_name);
    }
#line 361
    if (0 == tmp___4) {
      {
#line 362
      tmp___2 = quote(file_name);
#line 362
      tmp___3 = gettext("conflicting outputs to file %s");
#line 362
      warn((char const   *)tmp___3, tmp___2);
      }
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  file_names_count ++;
#line 364
  tmp___5 = xnrealloc((void *)file_names, (size_t )file_names_count, (size_t )sizeof(*file_names));
#line 364
  file_names = (char **)tmp___5;
#line 365
  *(file_names + (file_names_count - 1)) = xstrdup(file_name);
  }
#line 366
  return;
}
}
#line 368 "/home/pronto/abs/test-suite/bison-2.4/src/files.c"
void output_file_names_free(void) 
{ 
  int i ;

  {
  {
#line 371
  free((void *)all_but_ext);
#line 372
  free((void *)spec_verbose_file);
#line 373
  free((void *)spec_graph_file);
#line 374
  free((void *)spec_xml_file);
#line 375
  free((void *)spec_defines_file);
#line 376
  free((void *)parser_file_name);
#line 377
  free((void *)dir_prefix);
#line 380
  i = 0;
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! (i < file_names_count)) {
#line 380
      goto while_break;
    }
    {
#line 381
    free((void *)*(file_names + i));
#line 380
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  free((void *)file_names);
  }
#line 384
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 28 "/home/pronto/abs/test-suite/bison-2.4/src/derives.h"
rule ***derives  ;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/derives.c"
static void print_derives(void) 
{ 
  int i ;
  rule **rp ;

  {
  {
#line 45
  fputs_unlocked((char const   */* __restrict  */)"DERIVES\n", (FILE */* __restrict  */)stderr);
#line 47
  i = ntokens;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < nsyms)) {
#line 47
      goto while_break;
    }
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s derives\n",
            (*(symbols + i))->tag);
#line 51
    rp = *(derives + (i - ntokens));
    }
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      if (! *rp) {
#line 51
        goto while_break___0;
      }
      {
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t%3d ",
              (*rp)->user_number);
#line 54
      rule_rhs_print(*rp, stderr);
#line 51
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stderr);
  }
#line 59
  return;
}
}
#line 62 "/home/pronto/abs/test-suite/bison-2.4/src/derives.c"
void derives_compute(void) 
{ 
  symbol_number i ;
  rule_number r ;
  rule **q ;
  rule_list **dset ;
  void *tmp ;
  rule_list *delts ;
  void *tmp___0 ;
  symbol_number lhs ;
  rule_list *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  rule_list *p___0 ;
  rule **tmp___3 ;
  rule **tmp___4 ;

  {
  {
#line 71
  tmp = xcalloc((size_t )nvars, (size_t )sizeof(*dset));
#line 71
  dset = (rule_list **)tmp;
#line 76
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*delts));
#line 76
  delts = (rule_list *)tmp___0;
#line 78
  r = nrules - 1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (r >= 0)) {
#line 78
      goto while_break;
    }
#line 80
    lhs = ((rules + r)->lhs)->number;
#line 81
    p = delts + r;
#line 83
    p->next = *(dset + (lhs - ntokens));
#line 84
    p->value = rules + r;
#line 85
    *(dset + (lhs - ntokens)) = p;
#line 78
    r --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  tmp___1 = xnmalloc((size_t )nvars, (size_t )sizeof(*derives));
#line 91
  derives = (rule ***)tmp___1;
#line 92
  tmp___2 = xnmalloc((size_t )(nvars + nrules), (size_t )sizeof(*q));
#line 92
  q = (rule **)tmp___2;
#line 94
  i = ntokens;
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! (i < nsyms)) {
#line 94
      goto while_break___0;
    }
#line 96
    p___0 = *(dset + (i - ntokens));
#line 97
    *(derives + (i - ntokens)) = q;
    {
#line 98
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 98
      if (! p___0) {
#line 98
        goto while_break___1;
      }
#line 100
      tmp___3 = q;
#line 100
      q ++;
#line 100
      *tmp___3 = p___0->value;
#line 101
      p___0 = p___0->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    tmp___4 = q;
#line 103
    q ++;
#line 103
    *tmp___4 = (rule *)((void *)0);
#line 94
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 106
  if (trace_flag & 8) {
    {
#line 107
    print_derives();
    }
  }
  {
#line 109
  free((void *)dset);
#line 110
  free((void *)delts);
  }
#line 111
  return;
}
}
#line 114 "/home/pronto/abs/test-suite/bison-2.4/src/derives.c"
void derives_free(void) 
{ 


  {
  {
#line 117
  free((void *)*(derives + 0));
#line 118
  free((void *)derives);
  }
#line 119
  return;
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 175 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern errs *errs_new(int num , symbol **tokens ) ;
#line 235
extern void state_errs_set(state *s , int num , symbol **errors ) ;
#line 38 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.h"
int conflicts_total_count(void) ;
#line 39 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
int expected_sr_conflicts  =    -1;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
int expected_rr_conflicts  =    -1;
#line 41 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static char *conflicts  ;
#line 42 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static struct obstack solved_conflicts_obstack  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static struct obstack solved_conflicts_xml_obstack  ;
#line 45 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static bitset shift_set  ;
#line 46 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static bitset lookahead_set  ;
#line 65 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
__inline static void log_resolution(rule *r , symbol_number token , enum conflict_resolution resolution ) 
{ 
  char buf___0[4096] ;
  char *tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  char buf___1[4096] ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  size_t tmp___2 ;
  char buf___2[4096] ;
  char *tmp___3 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___4 ;
  char buf___3[4096] ;
  struct obstack *__o___2 ;
  int __len___2 ;
  size_t tmp___5 ;
  char buf___4[4096] ;
  struct obstack *__o___3 ;
  int __len___3 ;
  size_t tmp___6 ;
  char buf___5[4096] ;
  struct obstack *__o___4 ;
  int __len___4 ;
  size_t tmp___7 ;
  char buf___6[4096] ;
  struct obstack *__o___5 ;
  int __len___5 ;
  size_t tmp___8 ;
  char buf___7[4096] ;
  struct obstack *__o___6 ;
  int __len___6 ;
  size_t tmp___9 ;
  struct obstack *__o___7 ;
  int __len___7 ;
  size_t tmp___10 ;
  char buf___8[4096] ;
  char const   *tmp___11 ;
  struct obstack *__o___8 ;
  int __len___8 ;
  size_t tmp___12 ;
  char buf___9[4096] ;
  char const   *tmp___13 ;
  struct obstack *__o___9 ;
  int __len___9 ;
  size_t tmp___14 ;
  char buf___10[4096] ;
  char const   *tmp___15 ;
  struct obstack *__o___10 ;
  int __len___10 ;
  size_t tmp___16 ;
  char buf___11[4096] ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  struct obstack *__o___11 ;
  int __len___11 ;
  size_t tmp___19 ;
  char buf___12[4096] ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  struct obstack *__o___12 ;
  int __len___12 ;
  size_t tmp___22 ;
  char buf___13[4096] ;
  char const   *tmp___23 ;
  struct obstack *__o___13 ;
  int __len___13 ;
  size_t tmp___24 ;
  char buf___14[4096] ;
  char const   *tmp___25 ;
  struct obstack *__o___14 ;
  int __len___14 ;
  size_t tmp___26 ;
  char buf___15[4096] ;
  char const   *tmp___27 ;
  struct obstack *__o___15 ;
  int __len___15 ;
  size_t tmp___28 ;
  struct obstack *__o___16 ;
  int __len___16 ;
  size_t tmp___29 ;

  {
#line 69
  if (report_flag & 8) {
    {
#line 75
    if ((unsigned int )resolution == 3U) {
#line 75
      goto case_3;
    }
#line 75
    if ((unsigned int )resolution == 0U) {
#line 75
      goto case_3;
    }
#line 84
    if ((unsigned int )resolution == 2U) {
#line 84
      goto case_2;
    }
#line 84
    if ((unsigned int )resolution == 1U) {
#line 84
      goto case_2;
    }
#line 92
    if ((unsigned int )resolution == 4U) {
#line 92
      goto case_4;
    }
#line 72
    goto switch_break;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 76
      tmp = gettext("    Conflict between rule %d and token %s resolved as shift");
#line 76
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)tmp,
              r->number, (*(symbols + token))->tag);
#line 76
      __o = & solved_conflicts_obstack;
#line 76
      tmp___0 = strlen((char const   *)(buf___0));
#line 76
      __len = (int )tmp___0;
      }
#line 76
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 76
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 76
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf___0),
             (size_t )__len);
#line 76
      __o->next_free += __len;
      }
#line 76
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 85
      tmp___1 = gettext("    Conflict between rule %d and token %s resolved as reduce");
#line 85
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)tmp___1,
              r->number, (*(symbols + token))->tag);
#line 85
      __o___0 = & solved_conflicts_obstack;
#line 85
      tmp___2 = strlen((char const   *)(buf___1));
#line 85
      __len___0 = (int )tmp___2;
      }
#line 85
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 85
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 85
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)(buf___1),
             (size_t )__len___0);
#line 85
      __o___0->next_free += __len___0;
      }
#line 85
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 93
      tmp___3 = gettext("    Conflict between rule %d and token %s resolved as an error");
#line 93
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)tmp___3,
              r->number, (*(symbols + token))->tag);
#line 93
      __o___1 = & solved_conflicts_obstack;
#line 93
      tmp___4 = strlen((char const   *)(buf___2));
#line 93
      __len___1 = (int )tmp___4;
      }
#line 93
      if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
        {
#line 93
        _obstack_newchunk(__o___1, __len___1);
        }
      }
      {
#line 93
      memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)(buf___2),
             (size_t )__len___1);
#line 93
      __o___1->next_free += __len___1;
      }
#line 93
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 98
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 104
    if ((unsigned int )resolution == 0U) {
#line 104
      goto case_0___0;
    }
#line 111
    if ((unsigned int )resolution == 1U) {
#line 111
      goto case_1___0;
    }
#line 118
    if ((unsigned int )resolution == 2U) {
#line 118
      goto case_2___0;
    }
#line 124
    if ((unsigned int )resolution == 3U) {
#line 124
      goto case_3___0;
    }
#line 130
    if ((unsigned int )resolution == 4U) {
#line 130
      goto case_4___0;
    }
#line 102
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 105
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 105
      sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)" (%s < %s)",
              (r->prec)->tag, (*(symbols + token))->tag);
#line 105
      __o___2 = & solved_conflicts_obstack;
#line 105
      tmp___5 = strlen((char const   *)(buf___3));
#line 105
      __len___2 = (int )tmp___5;
      }
#line 105
      if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
        {
#line 105
        _obstack_newchunk(__o___2, __len___2);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(buf___3),
             (size_t )__len___2);
#line 105
      __o___2->next_free += __len___2;
      }
#line 105
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 109
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 112
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 112
      sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)" (%s < %s)",
              (*(symbols + token))->tag, (r->prec)->tag);
#line 112
      __o___3 = & solved_conflicts_obstack;
#line 112
      tmp___6 = strlen((char const   *)(buf___4));
#line 112
      __len___3 = (int )tmp___6;
      }
#line 112
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 112
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 112
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)(buf___4),
             (size_t )__len___3);
#line 112
      __o___3->next_free += __len___3;
      }
#line 112
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 116
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 119
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 119
      sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)" (%%left %s)",
              (*(symbols + token))->tag);
#line 119
      __o___4 = & solved_conflicts_obstack;
#line 119
      tmp___7 = strlen((char const   *)(buf___5));
#line 119
      __len___4 = (int )tmp___7;
      }
#line 119
      if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
        {
#line 119
        _obstack_newchunk(__o___4, __len___4);
        }
      }
      {
#line 119
      memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)(buf___5),
             (size_t )__len___4);
#line 119
      __o___4->next_free += __len___4;
      }
#line 119
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 122
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 125
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 125
      sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)" (%%right %s)",
              (*(symbols + token))->tag);
#line 125
      __o___5 = & solved_conflicts_obstack;
#line 125
      tmp___8 = strlen((char const   *)(buf___6));
#line 125
      __len___5 = (int )tmp___8;
      }
#line 125
      if ((unsigned long )(__o___5->next_free + __len___5) > (unsigned long )__o___5->chunk_limit) {
        {
#line 125
        _obstack_newchunk(__o___5, __len___5);
        }
      }
      {
#line 125
      memcpy((void */* __restrict  */)__o___5->next_free, (void const   */* __restrict  */)(buf___6),
             (size_t )__len___5);
#line 125
      __o___5->next_free += __len___5;
      }
#line 125
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 128
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 131
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 131
      sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)" (%%nonassoc %s)",
              (*(symbols + token))->tag);
#line 131
      __o___6 = & solved_conflicts_obstack;
#line 131
      tmp___9 = strlen((char const   *)(buf___7));
#line 131
      __len___6 = (int )tmp___9;
      }
#line 131
      if ((unsigned long )(__o___6->next_free + __len___6) > (unsigned long )__o___6->chunk_limit) {
        {
#line 131
        _obstack_newchunk(__o___6, __len___6);
        }
      }
      {
#line 131
      memcpy((void */* __restrict  */)__o___6->next_free, (void const   */* __restrict  */)(buf___7),
             (size_t )__len___6);
#line 131
      __o___6->next_free += __len___6;
      }
#line 131
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 134
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 137
    __o___7 = & solved_conflicts_obstack;
#line 137
    tmp___10 = strlen(".\n");
#line 137
    __len___7 = (int )tmp___10;
    }
#line 137
    if ((unsigned long )(__o___7->next_free + __len___7) > (unsigned long )__o___7->chunk_limit) {
      {
#line 137
      _obstack_newchunk(__o___7, __len___7);
      }
    }
    {
#line 137
    memcpy((void */* __restrict  */)__o___7->next_free, (void const   */* __restrict  */)".\n",
           (size_t )__len___7);
#line 137
    __o___7->next_free += __len___7;
    }
  }
#line 141
  if (xml_flag) {
    {
#line 147
    if ((unsigned int )resolution == 3U) {
#line 147
      goto case_3___1;
    }
#line 147
    if ((unsigned int )resolution == 0U) {
#line 147
      goto case_3___1;
    }
#line 156
    if ((unsigned int )resolution == 2U) {
#line 156
      goto case_2___1;
    }
#line 156
    if ((unsigned int )resolution == 1U) {
#line 156
      goto case_2___1;
    }
#line 164
    if ((unsigned int )resolution == 4U) {
#line 164
      goto case_4___1;
    }
#line 144
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    case_0___1: /* CIL Label */ 
    {
#line 148
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 148
      tmp___11 = xml_escape((*(symbols + token))->tag);
#line 148
      sprintf((char */* __restrict  */)(buf___8), (char const   */* __restrict  */)"        <resolution rule=\"%d\" symbol=\"%s\" type=\"shift\">",
              r->number, tmp___11);
#line 148
      __o___8 = & solved_conflicts_xml_obstack;
#line 148
      tmp___12 = strlen((char const   *)(buf___8));
#line 148
      __len___8 = (int )tmp___12;
      }
#line 148
      if ((unsigned long )(__o___8->next_free + __len___8) > (unsigned long )__o___8->chunk_limit) {
        {
#line 148
        _obstack_newchunk(__o___8, __len___8);
        }
      }
      {
#line 148
      memcpy((void */* __restrict  */)__o___8->next_free, (void const   */* __restrict  */)(buf___8),
             (size_t )__len___8);
#line 148
      __o___8->next_free += __len___8;
      }
#line 148
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 153
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    case_1___1: /* CIL Label */ 
    {
#line 157
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 157
      tmp___13 = xml_escape((*(symbols + token))->tag);
#line 157
      sprintf((char */* __restrict  */)(buf___9), (char const   */* __restrict  */)"        <resolution rule=\"%d\" symbol=\"%s\" type=\"reduce\">",
              r->number, tmp___13);
#line 157
      __o___9 = & solved_conflicts_xml_obstack;
#line 157
      tmp___14 = strlen((char const   *)(buf___9));
#line 157
      __len___9 = (int )tmp___14;
      }
#line 157
      if ((unsigned long )(__o___9->next_free + __len___9) > (unsigned long )__o___9->chunk_limit) {
        {
#line 157
        _obstack_newchunk(__o___9, __len___9);
        }
      }
      {
#line 157
      memcpy((void */* __restrict  */)__o___9->next_free, (void const   */* __restrict  */)(buf___9),
             (size_t )__len___9);
#line 157
      __o___9->next_free += __len___9;
      }
#line 157
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 162
    goto switch_break___1;
    case_4___1: /* CIL Label */ 
    {
#line 165
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 165
      tmp___15 = xml_escape((*(symbols + token))->tag);
#line 165
      sprintf((char */* __restrict  */)(buf___10), (char const   */* __restrict  */)"        <resolution rule=\"%d\" symbol=\"%s\" type=\"error\">",
              r->number, tmp___15);
#line 165
      __o___10 = & solved_conflicts_xml_obstack;
#line 165
      tmp___16 = strlen((char const   *)(buf___10));
#line 165
      __len___10 = (int )tmp___16;
      }
#line 165
      if ((unsigned long )(__o___10->next_free + __len___10) > (unsigned long )__o___10->chunk_limit) {
        {
#line 165
        _obstack_newchunk(__o___10, __len___10);
        }
      }
      {
#line 165
      memcpy((void */* __restrict  */)__o___10->next_free, (void const   */* __restrict  */)(buf___10),
             (size_t )__len___10);
#line 165
      __o___10->next_free += __len___10;
      }
#line 165
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 170
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 176
    if ((unsigned int )resolution == 0U) {
#line 176
      goto case_0___2;
    }
#line 183
    if ((unsigned int )resolution == 1U) {
#line 183
      goto case_1___2;
    }
#line 190
    if ((unsigned int )resolution == 2U) {
#line 190
      goto case_2___2;
    }
#line 196
    if ((unsigned int )resolution == 3U) {
#line 196
      goto case_3___2;
    }
#line 202
    if ((unsigned int )resolution == 4U) {
#line 202
      goto case_4___2;
    }
#line 174
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
    {
#line 177
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 177
      tmp___17 = xml_escape_n(1, (*(symbols + token))->tag);
#line 177
      tmp___18 = xml_escape_n(0, (r->prec)->tag);
#line 177
      sprintf((char */* __restrict  */)(buf___11), (char const   */* __restrict  */)"%s &lt; %s",
              tmp___18, tmp___17);
#line 177
      __o___11 = & solved_conflicts_xml_obstack;
#line 177
      tmp___19 = strlen((char const   *)(buf___11));
#line 177
      __len___11 = (int )tmp___19;
      }
#line 177
      if ((unsigned long )(__o___11->next_free + __len___11) > (unsigned long )__o___11->chunk_limit) {
        {
#line 177
        _obstack_newchunk(__o___11, __len___11);
        }
      }
      {
#line 177
      memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)(buf___11),
             (size_t )__len___11);
#line 177
      __o___11->next_free += __len___11;
      }
#line 177
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 181
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 184
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 184
      tmp___20 = xml_escape_n(1, (r->prec)->tag);
#line 184
      tmp___21 = xml_escape_n(0, (*(symbols + token))->tag);
#line 184
      sprintf((char */* __restrict  */)(buf___12), (char const   */* __restrict  */)"%s &lt; %s",
              tmp___21, tmp___20);
#line 184
      __o___12 = & solved_conflicts_xml_obstack;
#line 184
      tmp___22 = strlen((char const   *)(buf___12));
#line 184
      __len___12 = (int )tmp___22;
      }
#line 184
      if ((unsigned long )(__o___12->next_free + __len___12) > (unsigned long )__o___12->chunk_limit) {
        {
#line 184
        _obstack_newchunk(__o___12, __len___12);
        }
      }
      {
#line 184
      memcpy((void */* __restrict  */)__o___12->next_free, (void const   */* __restrict  */)(buf___12),
             (size_t )__len___12);
#line 184
      __o___12->next_free += __len___12;
      }
#line 184
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 188
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
    {
#line 191
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 191
      tmp___23 = xml_escape((*(symbols + token))->tag);
#line 191
      sprintf((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)"%%left %s",
              tmp___23);
#line 191
      __o___13 = & solved_conflicts_xml_obstack;
#line 191
      tmp___24 = strlen((char const   *)(buf___13));
#line 191
      __len___13 = (int )tmp___24;
      }
#line 191
      if ((unsigned long )(__o___13->next_free + __len___13) > (unsigned long )__o___13->chunk_limit) {
        {
#line 191
        _obstack_newchunk(__o___13, __len___13);
        }
      }
      {
#line 191
      memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)(buf___13),
             (size_t )__len___13);
#line 191
      __o___13->next_free += __len___13;
      }
#line 191
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 194
    goto switch_break___2;
    case_3___2: /* CIL Label */ 
    {
#line 197
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 197
      tmp___25 = xml_escape((*(symbols + token))->tag);
#line 197
      sprintf((char */* __restrict  */)(buf___14), (char const   */* __restrict  */)"%%right %s",
              tmp___25);
#line 197
      __o___14 = & solved_conflicts_xml_obstack;
#line 197
      tmp___26 = strlen((char const   *)(buf___14));
#line 197
      __len___14 = (int )tmp___26;
      }
#line 197
      if ((unsigned long )(__o___14->next_free + __len___14) > (unsigned long )__o___14->chunk_limit) {
        {
#line 197
        _obstack_newchunk(__o___14, __len___14);
        }
      }
      {
#line 197
      memcpy((void */* __restrict  */)__o___14->next_free, (void const   */* __restrict  */)(buf___14),
             (size_t )__len___14);
#line 197
      __o___14->next_free += __len___14;
      }
#line 197
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 200
    goto switch_break___2;
    case_4___2: /* CIL Label */ 
    {
#line 203
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 203
      tmp___27 = xml_escape((*(symbols + token))->tag);
#line 203
      sprintf((char */* __restrict  */)(buf___15), (char const   */* __restrict  */)"%%nonassoc %s",
              tmp___27);
#line 203
      __o___15 = & solved_conflicts_xml_obstack;
#line 203
      tmp___28 = strlen((char const   *)(buf___15));
#line 203
      __len___15 = (int )tmp___28;
      }
#line 203
      if ((unsigned long )(__o___15->next_free + __len___15) > (unsigned long )__o___15->chunk_limit) {
        {
#line 203
        _obstack_newchunk(__o___15, __len___15);
        }
      }
      {
#line 203
      memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)(buf___15),
             (size_t )__len___15);
#line 203
      __o___15->next_free += __len___15;
      }
#line 203
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 206
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 209
    __o___16 = & solved_conflicts_xml_obstack;
#line 209
    tmp___29 = strlen("</resolution>\n");
#line 209
    __len___16 = (int )tmp___29;
    }
#line 209
    if ((unsigned long )(__o___16->next_free + __len___16) > (unsigned long )__o___16->chunk_limit) {
      {
#line 209
      _obstack_newchunk(__o___16, __len___16);
      }
    }
    {
#line 209
    memcpy((void */* __restrict  */)__o___16->next_free, (void const   */* __restrict  */)"</resolution>\n",
           (size_t )__len___16);
#line 209
    __o___16->next_free += __len___16;
    }
  }
#line 211
  return;
}
}
#line 220 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static void flush_shift(state *s , int token ) 
{ 
  transitions *trans ;
  int i ;

  {
  {
#line 223
  trans = s->transitions;
#line 226
  bitset_reset(lookahead_set, (bitset_bindex )token);
#line 227
  i = 0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < trans->num)) {
#line 227
      goto while_break;
    }
#line 228
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 228
      if ((trans->states[i])->accessing_symbol == token) {
#line 230
        trans->states[i] = (state *)((void *)0);
      }
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static void flush_reduce(bitset lookahead_tokens , int token ) 
{ 


  {
  {
#line 243
  bitset_reset(lookahead_tokens, (bitset_bindex )token);
  }
#line 244
  return;
}
}
#line 259 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static void resolve_sr_conflict(state *s , int ruleno , symbol **errors , int *nerrs ) 
{ 
  symbol_number i ;
  reductions *reds ;
  rule *redrule ;
  int redprec ;
  bitset lookahead_tokens ;
  int tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 263
  reds = s->reductions;
#line 265
  redrule = reds->rules[ruleno];
#line 266
  redprec = (redrule->prec)->prec;
#line 267
  lookahead_tokens = *(reds->lookahead_tokens + ruleno);
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < ntokens)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp___0 = bitset_test(lookahead_tokens, (bitset_bindex )i);
    }
#line 270
    if (tmp___0) {
      {
#line 270
      tmp___1 = bitset_test(lookahead_set, (bitset_bindex )i);
      }
#line 270
      if (tmp___1) {
#line 270
        if ((*(symbols + i))->prec) {
#line 277
          if ((*(symbols + i))->prec < redprec) {
            {
#line 279
            log_resolution(redrule, i, (enum conflict_resolution )1);
#line 280
            flush_shift(s, i);
            }
          } else
#line 282
          if ((*(symbols + i))->prec > redprec) {
            {
#line 284
            log_resolution(redrule, i, (enum conflict_resolution )0);
#line 285
            flush_reduce(lookahead_tokens, i);
            }
          } else {
            {
#line 298
            if ((unsigned int )(*(symbols + i))->assoc == 1U) {
#line 298
              goto case_1;
            }
#line 303
            if ((unsigned int )(*(symbols + i))->assoc == 2U) {
#line 303
              goto case_2;
            }
#line 308
            if ((unsigned int )(*(symbols + i))->assoc == 3U) {
#line 308
              goto case_3;
            }
#line 295
            goto switch_default;
            switch_default: /* CIL Label */ 
            {
#line 296
            abort();
            }
            case_1: /* CIL Label */ 
            {
#line 299
            log_resolution(redrule, i, (enum conflict_resolution )3);
#line 300
            flush_reduce(lookahead_tokens, i);
            }
#line 301
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 304
            log_resolution(redrule, i, (enum conflict_resolution )2);
#line 305
            flush_shift(s, i);
            }
#line 306
            goto switch_break;
            case_3: /* CIL Label */ 
            {
#line 309
            log_resolution(redrule, i, (enum conflict_resolution )4);
#line 310
            flush_shift(s, i);
#line 311
            flush_reduce(lookahead_tokens, i);
#line 313
            tmp = *nerrs;
#line 313
            (*nerrs) ++;
#line 313
            *(errors + tmp) = *(symbols + i);
            }
#line 314
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 327 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static void set_conflicts(state *s , symbol **errors ) 
{ 
  int i ;
  transitions *trans ;
  reductions *reds ;
  int nerrs ;
  _Bool tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack  const  *__o___0 ;
  struct obstack *__o___1 ;
  char *tmp___3 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct obstack  const  *__o___2 ;
  _Bool tmp___6 ;

  {
#line 331
  trans = s->transitions;
#line 332
  reds = s->reductions;
#line 333
  nerrs = 0;
#line 335
  if (s->consistent) {
#line 336
    return;
  }
  {
#line 338
  (*((lookahead_set->b.vtable)->zero))(lookahead_set);
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (i < trans->num) {
#line 340
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 340
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 340
          goto while_break;
        }
      }
    } else {
#line 340
      goto while_break;
    }
#line 340
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 341
      bitset_set(lookahead_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (! (i < reds->num)) {
#line 346
      goto while_break___0;
    }
#line 347
    if ((reds->rules[i])->prec) {
#line 347
      if (((reds->rules[i])->prec)->prec) {
        {
#line 347
        tmp = (*((lookahead_set->b.vtable)->disjoint_p))(*(reds->lookahead_tokens + i),
                                                         lookahead_set);
        }
#line 347
        if (! tmp) {
          {
#line 349
          resolve_sr_conflict(s, i, errors, & nerrs);
          }
        }
      }
    }
#line 346
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 351
  if (nerrs) {
    {
#line 355
    state_errs_set(s, nerrs, errors);
    }
  }
#line 357
  __o___0 = (struct obstack  const  *)(& solved_conflicts_obstack);
#line 357
  if ((unsigned int )(__o___0->next_free - __o___0->object_base)) {
#line 359
    __o = & solved_conflicts_obstack;
#line 359
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 359
      _obstack_newchunk(__o, 1);
      }
    }
#line 359
    tmp___0 = __o->next_free;
#line 359
    (__o->next_free) ++;
#line 359
    *tmp___0 = (char )'\000';
#line 360
    __o1 = & solved_conflicts_obstack;
#line 360
    __value = (void *)__o1->object_base;
#line 360
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 360
      __o1->maybe_empty_object = 1U;
    }
#line 360
    if (sizeof(int ) < sizeof(void *)) {
#line 360
      tmp___1 = __o1->object_base;
    } else {
#line 360
      tmp___1 = (char *)0;
    }
#line 360
    if (sizeof(int ) < sizeof(void *)) {
#line 360
      tmp___2 = __o1->object_base;
    } else {
#line 360
      tmp___2 = (char *)0;
    }
#line 360
    __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 360
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 360
      __o1->next_free = __o1->chunk_limit;
    }
#line 360
    __o1->object_base = __o1->next_free;
#line 360
    s->solved_conflicts = (char const   *)__value;
  }
#line 362
  __o___2 = (struct obstack  const  *)(& solved_conflicts_xml_obstack);
#line 362
  if ((unsigned int )(__o___2->next_free - __o___2->object_base)) {
#line 364
    __o___1 = & solved_conflicts_xml_obstack;
#line 364
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 364
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 364
    tmp___3 = __o___1->next_free;
#line 364
    (__o___1->next_free) ++;
#line 364
    *tmp___3 = (char )'\000';
#line 365
    __o1___0 = & solved_conflicts_xml_obstack;
#line 365
    __value___0 = (void *)__o1___0->object_base;
#line 365
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 365
      __o1___0->maybe_empty_object = 1U;
    }
#line 365
    if (sizeof(int ) < sizeof(void *)) {
#line 365
      tmp___4 = __o1___0->object_base;
    } else {
#line 365
      tmp___4 = (char *)0;
    }
#line 365
    if (sizeof(int ) < sizeof(void *)) {
#line 365
      tmp___5 = __o1___0->object_base;
    } else {
#line 365
      tmp___5 = (char *)0;
    }
#line 365
    __o1___0->next_free = tmp___4 + (((__o1___0->next_free - tmp___5) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 365
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 365
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 365
    __o1___0->object_base = __o1___0->next_free;
#line 365
    s->solved_conflicts_xml = (char const   *)__value___0;
  }
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (! (i < reds->num)) {
#line 370
      goto while_break___1;
    }
    {
#line 372
    tmp___6 = (*((lookahead_set->b.vtable)->disjoint_p))(*(reds->lookahead_tokens + i),
                                                         lookahead_set);
    }
#line 372
    if (! tmp___6) {
#line 373
      *(conflicts + s->number) = (char)1;
    }
    {
#line 374
    (*((lookahead_set->b.vtable)->or_))(lookahead_set, lookahead_set, *(reds->lookahead_tokens + i));
#line 370
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 384 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
void conflicts_solve(void) 
{ 
  state_number i ;
  symbol **errors ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 389
  tmp = xnmalloc((size_t )(ntokens + 1), (size_t )sizeof(*errors));
#line 389
  errors = (symbol **)tmp;
#line 391
  tmp___0 = xcalloc((size_t )nstates, (size_t )sizeof(*conflicts));
#line 391
  conflicts = (char *)tmp___0;
#line 392
  shift_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 393
  lookahead_set = bitset_create((bitset_bindex )ntokens, (bitset_attrs )1);
#line 394
  _obstack_begin(& solved_conflicts_obstack, 0, 0, (void *(*)(long  ))(& xmalloc),
                 & free);
#line 395
  _obstack_begin(& solved_conflicts_xml_obstack, 0, 0, (void *(*)(long  ))(& xmalloc),
                 & free);
#line 397
  i = 0;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (i < nstates)) {
#line 397
      goto while_break;
    }
    {
#line 399
    set_conflicts(*(states + i), errors);
    }
#line 403
    if (! (*(states + i))->errs) {
      {
#line 404
      (*(states + i))->errs = errs_new(0, (symbol **)0);
      }
    }
#line 397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 407
  free((void *)errors);
  }
#line 408
  return;
}
}
#line 411 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
void conflicts_update_state_numbers(state_number *old_to_new , state_number nstates_old ) 
{ 
  state_number i ;

  {
#line 416
  i = 0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (i < nstates_old)) {
#line 416
      goto while_break;
    }
#line 417
    if (*(old_to_new + i) != nstates_old) {
#line 418
      *(conflicts + *(old_to_new + i)) = *(conflicts + i);
    }
#line 416
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 426 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static int count_sr_conflicts(state *s ) 
{ 
  int i ;
  int src_count ;
  transitions *trans ;
  reductions *reds ;
  bitset_bindex tmp ;

  {
#line 430
  src_count = 0;
#line 431
  trans = s->transitions;
#line 432
  reds = s->reductions;
#line 434
  if (! trans) {
#line 435
    return (0);
  }
  {
#line 437
  (*((lookahead_set->b.vtable)->zero))(lookahead_set);
#line 438
  (*((shift_set->b.vtable)->zero))(shift_set);
#line 440
  i = 0;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (i < trans->num) {
#line 440
      if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
#line 440
        if (! ((trans->states[i])->accessing_symbol < ntokens)) {
#line 440
          goto while_break;
        }
      }
    } else {
#line 440
      goto while_break;
    }
#line 440
    if (! ((unsigned long )trans->states[i] == (unsigned long )((void *)0))) {
      {
#line 441
      bitset_set(shift_set, (bitset_bindex )(trans->states[i])->accessing_symbol);
      }
    }
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 443
    if (! (i < reds->num)) {
#line 443
      goto while_break___0;
    }
    {
#line 444
    (*((lookahead_set->b.vtable)->or_))(lookahead_set, lookahead_set, *(reds->lookahead_tokens + i));
#line 443
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 446
  (*((lookahead_set->b.vtable)->and_))(lookahead_set, lookahead_set, shift_set);
#line 448
  tmp = (*((lookahead_set->b.vtable)->count))(lookahead_set);
#line 448
  src_count = (int )tmp;
  }
#line 450
  return (src_count);
}
}
#line 461 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static int count_rr_conflicts(state *s , _Bool one_per_token ) 
{ 
  int i ;
  reductions *reds ;
  int rrc_count ;
  int count ;
  int j ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 465
  reds = s->reductions;
#line 466
  rrc_count = 0;
#line 468
  i = 0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! (i < ntokens)) {
#line 468
      goto while_break;
    }
#line 470
    count = 0;
#line 472
    j = 0;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (j < reds->num)) {
#line 472
        goto while_break___0;
      }
      {
#line 473
      tmp = bitset_test(*(reds->lookahead_tokens + j), (bitset_bindex )i);
      }
#line 473
      if (tmp) {
#line 474
        count ++;
      }
#line 472
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 476
    if (count >= 2) {
#line 477
      if (one_per_token) {
#line 477
        tmp___0 = 1;
      } else {
#line 477
        tmp___0 = count - 1;
      }
#line 477
      rrc_count += tmp___0;
    }
#line 468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  return (rrc_count);
}
}
#line 488 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
static void conflict_report(FILE *out , int src_num , int rrc_num ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 491
  if (src_num) {
#line 491
    if (rrc_num) {
      {
#line 492
      tmp = gettext("conflicts: %d shift/reduce, %d reduce/reduce\n");
#line 492
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp,
              src_num, rrc_num);
      }
    } else {
#line 491
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 494
  if (src_num) {
    {
#line 495
    tmp___0 = gettext("conflicts: %d shift/reduce\n");
#line 495
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
            src_num);
    }
  } else
#line 496
  if (rrc_num) {
    {
#line 497
    tmp___1 = gettext("conflicts: %d reduce/reduce\n");
#line 497
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
            rrc_num);
    }
  }
#line 498
  return;
}
}
#line 505 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
void conflicts_output(FILE *out ) 
{ 
  _Bool printed_sth ;
  state_number i ;
  state *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 508
  printed_sth = (_Bool)0;
#line 510
  i = 0;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! (i < nstates)) {
#line 510
      goto while_break;
    }
#line 512
    s = *(states + i);
#line 513
    if (*(conflicts + i)) {
      {
#line 515
      tmp = gettext("State %d ");
#line 515
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp,
              i);
#line 516
      tmp___0 = count_rr_conflicts(s, (_Bool)1);
#line 516
      tmp___1 = count_sr_conflicts(s);
#line 516
      conflict_report(out, tmp___1, tmp___0);
#line 518
      printed_sth = (_Bool)1;
      }
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  if (printed_sth) {
    {
#line 522
    fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
    }
  }
#line 523
  return;
}
}
#line 532 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
int conflicts_total_count(void) 
{ 
  state_number i ;
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 539
  count = 0;
#line 540
  i = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (i < nstates)) {
#line 540
      goto while_break;
    }
#line 541
    if (*(conflicts + i)) {
      {
#line 543
      tmp = count_sr_conflicts(*(states + i));
#line 543
      count += tmp;
#line 544
      tmp___0 = count_rr_conflicts(*(states + i), (_Bool)0);
#line 544
      count += tmp___0;
      }
    }
#line 540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  return (count);
}
}
#line 554 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
void conflicts_print(void) 
{ 
  _Bool src_ok ;
  _Bool rrc_ok ;
  int src_total ;
  int rrc_total ;
  int src_expected ;
  int rrc_expected ;
  state_number i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 563
  src_total = 0;
#line 564
  rrc_total = 0;
#line 572
  i = 0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! (i < nstates)) {
#line 572
      goto while_break;
    }
#line 573
    if (*(conflicts + i)) {
      {
#line 575
      tmp = count_sr_conflicts(*(states + i));
#line 575
      src_total += tmp;
#line 576
      tmp___0 = count_rr_conflicts(*(states + i), (_Bool)1);
#line 576
      rrc_total += tmp___0;
      }
    }
#line 572
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if (! glr_parser) {
#line 580
    if (rrc_total > 0) {
#line 580
      if (expected_rr_conflicts != -1) {
        {
#line 582
        tmp___1 = gettext("%%expect-rr applies only to GLR parsers");
#line 582
        warn((char const   *)tmp___1);
#line 583
        expected_rr_conflicts = -1;
        }
      }
    }
  }
#line 586
  if (expected_sr_conflicts == -1) {
#line 586
    src_expected = 0;
  } else {
#line 586
    src_expected = expected_sr_conflicts;
  }
#line 587
  if (expected_rr_conflicts == -1) {
#line 587
    rrc_expected = 0;
  } else {
#line 587
    rrc_expected = expected_rr_conflicts;
  }
#line 588
  src_ok = (_Bool )(src_total == src_expected);
#line 589
  rrc_ok = (_Bool )(rrc_total == rrc_expected);
#line 593
  if ((int )rrc_ok & (int )src_ok) {
#line 594
    return;
  }
#line 597
  if (src_total | rrc_total) {
#line 599
    if (! yacc_flag) {
      {
#line 600
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              current_file);
      }
    }
    {
#line 601
    conflict_report(stderr, src_total, rrc_total);
    }
  }
#line 604
  if (expected_sr_conflicts != -1) {
#line 604
    goto _L;
  } else
#line 604
  if (expected_rr_conflicts != -1) {
    _L: /* CIL Label */ 
#line 606
    if (! src_ok) {
      {
#line 607
      tmp___2 = ngettext("expected %d shift/reduce conflict", "expected %d shift/reduce conflicts",
                         (unsigned long )src_expected);
#line 607
      complain((char const   *)tmp___2, src_expected);
      }
    }
#line 611
    if (! rrc_ok) {
      {
#line 612
      tmp___3 = ngettext("expected %d reduce/reduce conflict", "expected %d reduce/reduce conflicts",
                         (unsigned long )rrc_expected);
#line 612
      complain((char const   *)tmp___3, rrc_expected);
      }
    }
  }
#line 617
  return;
}
}
#line 620 "/home/pronto/abs/test-suite/bison-2.4/src/conflicts.c"
void conflicts_free(void) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;

  {
  {
#line 623
  free((void *)conflicts);
#line 624
  bitset_free(shift_set);
#line 625
  bitset_free(lookahead_set);
#line 626
  __o = & solved_conflicts_obstack;
#line 626
  __obj = (void *)0;
  }
#line 626
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 626
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 626
      tmp = (char *)__obj;
#line 626
      __o->object_base = tmp;
#line 626
      __o->next_free = tmp;
    } else {
      {
#line 626
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 626
    obstack_free(__o, __obj);
    }
  }
#line 627
  __o___0 = & solved_conflicts_xml_obstack;
#line 627
  __obj___0 = (void *)0;
#line 627
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 627
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 627
      tmp___0 = (char *)__obj___0;
#line 627
      __o___0->object_base = tmp___0;
#line 627
      __o___0->next_free = tmp___0;
    } else {
      {
#line 627
      obstack_free(__o___0, __obj___0);
      }
    }
  } else {
    {
#line 627
    obstack_free(__o___0, __obj___0);
    }
  }
#line 628
  return;
}
}
#line 221 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 51 "/home/pronto/abs/test-suite/bison-2.4/src/complain.h"
_Bool complaint_issued  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
static void error_message(location *loc___0 , char const   *prefix , char const   *message ,
                          va_list args ) 
{ 
  char const   *tmp ;

  {
#line 49
  if (loc___0) {
    {
#line 50
    location_print(stderr, *loc___0);
    }
  } else {
#line 52
    if (current_file) {
#line 52
      tmp = current_file;
    } else {
#line 52
      tmp = (char const   *)program_name;
    }
    {
#line 52
    fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 53
  fputs_unlocked((char const   */* __restrict  */)": ", (FILE */* __restrict  */)stderr);
  }
#line 55
  if (prefix) {
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            prefix);
    }
  }
  {
#line 58
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 59
  __builtin_va_end(args);
#line 60
  putc_unlocked('\n', stderr);
#line 61
  fflush_unlocked(stderr);
  }
#line 62
  return;
}
}
#line 80
static void set_warning_issued(void) ;
#line 80 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
static _Bool warning_issued  =    (_Bool)0;
#line 77 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
static void set_warning_issued(void) 
{ 


  {
#line 81
  if (! warning_issued) {
#line 81
    if (warnings_flag & 1) {
      {
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warnings being treated as errors\n",
              program_name);
#line 84
      complaint_issued = (_Bool)1;
      }
    }
  }
#line 86
  warning_issued = (_Bool)1;
#line 87
  return;
}
}
#line 89 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  warn_at)(location loc___0 , char const   *message 
                                        , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 92
  set_warning_issued();
#line 93
  __builtin_va_start(args, message);
#line 93
  tmp = gettext("warning");
#line 93
  error_message(& loc___0, (char const   *)tmp, message, args);
  }
#line 94
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  warn)(char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 99
  set_warning_issued();
#line 100
  __builtin_va_start(args, message);
#line 100
  tmp = gettext("warning");
#line 100
  error_message((location *)((void *)0), (char const   *)tmp, message, args);
  }
#line 101
  return;
}
}
#line 108 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  complain_at)(location loc___0 , char const   *message 
                                            , ...) 
{ 
  va_list args ;

  {
  {
#line 111
  __builtin_va_start(args, message);
#line 111
  error_message(& loc___0, (char const   *)((void *)0), message, args);
#line 112
  complaint_issued = (_Bool)1;
  }
#line 113
  return;
}
}
#line 115 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  complain)(char const   *message  , ...) 
{ 
  va_list args ;

  {
  {
#line 118
  __builtin_va_start(args, message);
#line 118
  error_message((location *)((void *)0), (char const   *)((void *)0), message, args);
#line 119
  complaint_issued = (_Bool)1;
  }
#line 120
  return;
}
}
#line 127
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal_at)(location loc___0 ,
                                                                        char const   *message 
                                                                        , ...) ;
#line 127 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  fatal_at)(location loc___0 , char const   *message 
                                         , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 130
  __builtin_va_start(args, message);
#line 130
  tmp = gettext("fatal error");
#line 130
  error_message(& loc___0, (char const   *)tmp, message, args);
#line 131
  exit(1);
  }
}
}
#line 134
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *message 
                                                                     , ...) ;
#line 134 "/home/pronto/abs/test-suite/bison-2.4/src/complain.c"
void ( /* format attribute */  fatal)(char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 137
  __builtin_va_start(args, message);
#line 137
  tmp = gettext("fatal error");
#line 137
  error_message((location *)((void *)0), (char const   *)tmp, message, args);
#line 138
  exit(1);
  }
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 54 "/home/pronto/abs/test-suite/bison-2.4/src/closure.h"
item_number *itemset  ;
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/closure.h"
size_t nitemset  ;
#line 40 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static bitset ruleset  ;
#line 43 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static bitsetv fderives  =    (bitsetv )((void *)0);
#line 44 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static bitsetv firsts  =    (bitsetv )((void *)0);
#line 55 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static void print_closure(char const   *title , item_number *array , size_t size ) 
{ 
  size_t i ;
  item_number *rp ;

  {
  {
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Closure: %s\n",
          title);
#line 60
  i = (size_t )0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < size)) {
#line 60
      goto while_break;
    }
    {
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %2d: .",
            *(array + i));
#line 64
    rp = ritem + *(array + i);
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (*rp >= 0)) {
#line 64
        goto while_break___0;
      }
      {
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s",
              (*(symbols + *rp))->tag);
#line 64
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  (rule %d)\n",
            - *rp - 1);
#line 60
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  fputs_unlocked((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stderr);
  }
#line 69
  return;
}
}
#line 72 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static void print_firsts(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  bitset_iterator iter ;

  {
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIRSTS\n");
#line 78
  i = ntokens;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < nsyms)) {
#line 78
      goto while_break;
    }
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s firsts\n",
            (*(symbols + i))->tag);
#line 82
    iter.next = (bitset_bindex )0;
#line 82
    iter.num = (bitset_bindex )1024;
    }
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (iter.num == 1024U) {
        {
#line 82
        iter.num = (*(((*(firsts + (i - ntokens)))->b.vtable)->list))(*(firsts + (i - ntokens)),
                                                                      iter.list, (bitset_bindex )1024,
                                                                      & iter.next);
        }
#line 82
        if (! iter.num) {
#line 82
          goto while_break___0;
        }
      } else {
#line 82
        goto while_break___0;
      }
#line 82
      iter.i = (bitset_bindex )0;
      {
#line 82
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 82
        if (iter.i < iter.num) {
#line 82
          j = (symbol_number )iter.list[iter.i];
        } else {
#line 82
          goto while_break___1;
        }
        {
#line 84
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t%s\n",
                (*(symbols + (j + ntokens)))->tag);
#line 82
        (iter.i) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
  }
#line 89
  return;
}
}
#line 92 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static void print_fderives(void) 
{ 
  int i ;
  rule_number r ;
  bitset_iterator iter ;

  {
  {
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FDERIVES\n");
#line 99
  i = ntokens;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < nsyms)) {
#line 99
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s derives\n",
            (*(symbols + i))->tag);
#line 103
    iter.next = (bitset_bindex )0;
#line 103
    iter.num = (bitset_bindex )1024;
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (iter.num == 1024U) {
        {
#line 103
        iter.num = (*(((*(fderives + (i - ntokens)))->b.vtable)->list))(*(fderives + (i - ntokens)),
                                                                        iter.list,
                                                                        (bitset_bindex )1024,
                                                                        & iter.next);
        }
#line 103
        if (! iter.num) {
#line 103
          goto while_break___0;
        }
      } else {
#line 103
        goto while_break___0;
      }
#line 103
      iter.i = (bitset_bindex )0;
      {
#line 103
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 103
        if (iter.i < iter.num) {
#line 103
          r = (rule_number )iter.list[iter.i];
        } else {
#line 103
          goto while_break___1;
        }
        {
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t%3d ",
                r);
#line 106
        rule_rhs_print(rules + r, stderr);
#line 103
        (iter.i) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
  }
#line 110
  return;
}
}
#line 123 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static void set_firsts(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  item_number sym ;

  {
  {
#line 128
  firsts = bitsetv_create((bitset_bindex )nvars, (bitset_bindex )nvars, 1U);
#line 130
  i = ntokens;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < nsyms)) {
#line 130
      goto while_break;
    }
#line 131
    j = 0;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (! *(*(derives + (i - ntokens)) + j)) {
#line 131
        goto while_break___0;
      }
#line 133
      sym = *((*(*(derives + (i - ntokens)) + j))->rhs + 0);
#line 134
      if (sym >= ntokens) {
        {
#line 135
        bitset_set(*(firsts + (i - ntokens)), (bitset_bindex )(sym - ntokens));
        }
      }
#line 131
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (trace_flag & 8) {
    {
#line 139
    bitsetv_matrix_dump(stderr, "RTC: Firsts Input", firsts);
    }
  }
  {
#line 140
  bitsetv_reflexive_transitive_closure(firsts);
  }
#line 141
  if (trace_flag & 8) {
    {
#line 142
    bitsetv_matrix_dump(stderr, "RTC: Firsts Output", firsts);
    }
  }
#line 144
  if (trace_flag & 8) {
    {
#line 145
    print_firsts();
    }
  }
#line 146
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
static void set_fderives(void) 
{ 
  symbol_number i ;
  symbol_number j ;
  rule_number k ;
  _Bool tmp ;

  {
  {
#line 164
  fderives = bitsetv_create((bitset_bindex )nvars, (bitset_bindex )nrules, 1U);
#line 166
  set_firsts();
#line 168
  i = ntokens;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < nsyms)) {
#line 168
      goto while_break;
    }
#line 169
    j = ntokens;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! (j < nsyms)) {
#line 169
        goto while_break___0;
      }
      {
#line 170
      tmp = bitset_test(*(firsts + (i - ntokens)), (bitset_bindex )(j - ntokens));
      }
#line 170
      if (tmp) {
#line 171
        k = 0;
        {
#line 171
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 171
          if (! *(*(derives + (j - ntokens)) + k)) {
#line 171
            goto while_break___1;
          }
          {
#line 172
          bitset_set(*(fderives + (i - ntokens)), (bitset_bindex )(*(*(derives + (j - ntokens)) + k))->number);
#line 171
          k ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 169
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (trace_flag & 8) {
    {
#line 175
    print_fderives();
    }
  }
  {
#line 177
  bitsetv_free(firsts);
  }
#line 178
  return;
}
}
#line 182 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
void new_closure(unsigned int n ) 
{ 
  void *tmp ;

  {
  {
#line 185
  tmp = xnmalloc(n, (size_t )sizeof(*itemset));
#line 185
  itemset = (item_number *)tmp;
#line 187
  ruleset = bitset_create((bitset_bindex )nrules, (bitset_attrs )1);
#line 189
  set_fderives();
  }
#line 190
  return;
}
}
#line 194 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
void closure(item_number *core , size_t n ) 
{ 
  size_t c ;
  rule_number ruleno ;
  bitset_iterator iter ;
  item_number itemno ;

  {
#line 205
  if (trace_flag & 8) {
    {
#line 206
    print_closure("input", core, n);
    }
  }
  {
#line 208
  (*((ruleset->b.vtable)->zero))(ruleset);
#line 210
  c = (size_t )0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (c < n)) {
#line 210
      goto while_break;
    }
#line 211
    if (*(ritem + *(core + c)) >= ntokens) {
      {
#line 212
      (*((ruleset->b.vtable)->or_))(ruleset, ruleset, *(fderives + (*(ritem + *(core + c)) - ntokens)));
      }
    }
#line 210
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  nitemset = (size_t )0;
#line 217
  c = (size_t )0;
#line 218
  iter.next = (bitset_bindex )0;
#line 218
  iter.num = (bitset_bindex )1024;
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (iter.num == 1024U) {
      {
#line 218
      iter.num = (*((ruleset->b.vtable)->list))(ruleset, iter.list, (bitset_bindex )1024,
                                                & iter.next);
      }
#line 218
      if (! iter.num) {
#line 218
        goto while_break___0;
      }
    } else {
#line 218
      goto while_break___0;
    }
#line 218
    iter.i = (bitset_bindex )0;
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 218
      if (iter.i < iter.num) {
#line 218
        ruleno = (rule_number )iter.list[iter.i];
      } else {
#line 218
        goto while_break___1;
      }
#line 220
      itemno = (item_number )((rules + ruleno)->rhs - ritem);
      {
#line 221
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 221
        if (c < n) {
#line 221
          if (! (*(core + c) < itemno)) {
#line 221
            goto while_break___2;
          }
        } else {
#line 221
          goto while_break___2;
        }
#line 223
        *(itemset + nitemset) = *(core + c);
#line 224
        nitemset ++;
#line 225
        c ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 227
      *(itemset + nitemset) = itemno;
#line 228
      nitemset ++;
#line 218
      (iter.i) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! (c < n)) {
#line 231
      goto while_break___3;
    }
#line 233
    *(itemset + nitemset) = *(core + c);
#line 234
    nitemset ++;
#line 235
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 238
  if (trace_flag & 8) {
    {
#line 239
    print_closure("output", itemset, nitemset);
    }
  }
#line 240
  return;
}
}
#line 243 "/home/pronto/abs/test-suite/bison-2.4/src/closure.c"
void free_closure(void) 
{ 


  {
  {
#line 246
  free((void *)itemset);
#line 247
  bitset_free(ruleset);
#line 248
  bitsetv_free(fderives);
  }
#line 249
  return;
}
}
#line 25 "/home/pronto/abs/test-suite/bison-2.4/src/assoc.c"
char const   *assoc_to_string(assoc a ) 
{ 


  {
  {
#line 33
  if ((unsigned int )a == 0U) {
#line 33
    goto case_0;
  }
#line 36
  if ((unsigned int )a == 1U) {
#line 36
    goto case_1;
  }
#line 39
  if ((unsigned int )a == 2U) {
#line 39
    goto case_2;
  }
#line 42
  if ((unsigned int )a == 3U) {
#line 42
    goto case_3;
  }
#line 30
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 31
  abort();
  }
  case_0: /* CIL Label */ 
#line 34
  return ("undefined associativity");
  case_1: /* CIL Label */ 
#line 37
  return ("%right");
  case_2: /* CIL Label */ 
#line 40
  return ("%left");
  case_3: /* CIL Label */ 
#line 43
  return ("%nonassoc");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 119 "../lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 140 "/home/pronto/abs/test-suite/bison-2.4/src/gram.h"
__inline static _Bool item_number_is_symbol_number(item_number i ) 
{ 


  {
#line 143
  return ((_Bool )(i >= 0));
}
}
#line 223 "/home/pronto/abs/test-suite/bison-2.4/src/state.h"
extern state *state_new(symbol_number accessing_symbol , size_t core_size , item_number *core ) ;
#line 227
extern void state_transitions_set(state *s , int num , state **trans ) ;
#line 230
extern void state_reductions_set(state *s , int num , rule **reds ) ;
#line 244
extern void state_hash_new(void) ;
#line 245
extern void state_hash_free(void) ;
#line 249
extern state *state_hash_lookup(size_t core_size , item_number *core ) ;
#line 49 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static state_list *first_state  =    (state_list *)((void *)0);
#line 50 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static state_list *last_state  =    (state_list *)((void *)0);
#line 58 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static state *state_list_append(symbol_number sym , size_t core_size , item_number *core ) 
{ 
  state_list *node ;
  void *tmp ;
  state *s ;
  state *tmp___0 ;

  {
  {
#line 61
  tmp = xmalloc((size_t )sizeof(*node));
#line 61
  node = (state_list *)tmp;
#line 62
  tmp___0 = state_new(sym, core_size, core);
#line 62
  s = tmp___0;
  }
#line 64
  if (trace_flag & 64) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"state_list_append (state = %d, symbol = %d (%s))\n",
            nstates, sym, (*(symbols + sym))->tag);
    }
  }
#line 68
  node->next = (struct state_list *)((void *)0);
#line 69
  node->state = s;
#line 71
  if (! first_state) {
#line 72
    first_state = node;
  }
#line 73
  if (last_state) {
#line 74
    last_state->next = node;
  }
#line 75
  last_state = node;
#line 77
  return (s);
}
}
#line 80 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static int nshifts  ;
#line 81 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static symbol_number *shift_symbol  ;
#line 83 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static rule **redset  ;
#line 84 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static state **shiftset  ;
#line 86 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static item_number **kernel_base  ;
#line 87 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static int *kernel_size  ;
#line 88 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static item_number *kernel_items  ;
#line 91 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void allocate_itemsets(void) 
{ 
  symbol_number i ;
  rule_number r ;
  item_number *rhsp ;
  size_t count ;
  size_t *symbol_count ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 102
  count = (size_t )0;
#line 103
  tmp = xcalloc((size_t )(nsyms + nuseless_nonterminals), (size_t )sizeof(*symbol_count));
#line 103
  symbol_count = (size_t *)tmp;
#line 106
  r = 0;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (r < nrules)) {
#line 106
      goto while_break;
    }
#line 107
    rhsp = (rules + r)->rhs;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (*rhsp >= 0)) {
#line 107
        goto while_break___0;
      }
#line 109
      count ++;
#line 110
      (*(symbol_count + *rhsp)) ++;
#line 107
      rhsp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp___0 = xnmalloc((size_t )nsyms, (size_t )sizeof(*kernel_base));
#line 119
  kernel_base = (item_number **)tmp___0;
#line 120
  tmp___1 = xnmalloc(count, (size_t )sizeof(*kernel_items));
#line 120
  kernel_items = (item_number *)tmp___1;
#line 122
  count = (size_t )0;
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! (i < nsyms)) {
#line 123
      goto while_break___1;
    }
#line 125
    *(kernel_base + i) = kernel_items + count;
#line 126
    count += *(symbol_count + i);
#line 123
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 129
  free((void *)symbol_count);
#line 130
  tmp___2 = xnmalloc((size_t )nsyms, (size_t )sizeof(*kernel_size));
#line 130
  kernel_size = (int *)tmp___2;
  }
#line 131
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void allocate_storage(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 137
  allocate_itemsets();
#line 139
  tmp = xnmalloc((size_t )nsyms, (size_t )sizeof(*shiftset));
#line 139
  shiftset = (state **)tmp;
#line 140
  tmp___0 = xnmalloc((size_t )nrules, (size_t )sizeof(*redset));
#line 140
  redset = (rule **)tmp___0;
#line 141
  state_hash_new();
#line 142
  tmp___1 = xnmalloc((size_t )nsyms, (size_t )sizeof(*shift_symbol));
#line 142
  shift_symbol = (symbol_number *)tmp___1;
  }
#line 143
  return;
}
}
#line 146 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void free_storage(void) 
{ 


  {
  {
#line 149
  free((void *)shift_symbol);
#line 150
  free((void *)redset);
#line 151
  free((void *)shiftset);
#line 152
  free((void *)kernel_base);
#line 153
  free((void *)kernel_size);
#line 154
  free((void *)kernel_items);
#line 155
  state_hash_free();
  }
#line 156
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void new_itemsets(state *s ) 
{ 
  size_t i ;
  symbol_number sym ;
  symbol_number tmp ;
  _Bool tmp___0 ;

  {
#line 181
  if (trace_flag & 64) {
    {
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering new_itemsets, state = %d\n",
            s->number);
    }
  }
  {
#line 184
  memset((void *)kernel_size, 0, (size_t )((unsigned long )nsyms * sizeof(*kernel_size)));
#line 186
  nshifts = 0;
#line 188
  i = (size_t )0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i < nitemset)) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp___0 = item_number_is_symbol_number(*(ritem + *(itemset + i)));
    }
#line 189
    if (tmp___0) {
      {
#line 191
      tmp = item_number_as_symbol_number(*(ritem + *(itemset + i)));
#line 191
      sym = tmp;
      }
#line 192
      if (! *(kernel_size + sym)) {
#line 194
        *(shift_symbol + nshifts) = sym;
#line 195
        nshifts ++;
      }
#line 198
      *(*(kernel_base + sym) + *(kernel_size + sym)) = *(itemset + i) + 1;
#line 199
      (*(kernel_size + sym)) ++;
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 211 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static state *get_state(symbol_number sym , size_t core_size , item_number *core ) 
{ 
  state *s ;

  {
#line 216
  if (trace_flag & 64) {
    {
#line 217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering get_state, symbol = %d (%s)\n",
            sym, (*(symbols + sym))->tag);
    }
  }
  {
#line 220
  s = state_hash_lookup(core_size, core);
  }
#line 221
  if (! s) {
    {
#line 222
    s = state_list_append(sym, core_size, core);
    }
  }
#line 224
  if (trace_flag & 64) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exiting get_state => %d\n",
            s->number);
    }
  }
#line 227
  return (s);
}
}
#line 237 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void append_states(state *s ) 
{ 
  int i ;
  symbol_number sym ;
  int j ;
  symbol_number sym___0 ;

  {
#line 242
  if (trace_flag & 64) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering append_states, state = %d\n",
            s->number);
    }
  }
#line 247
  i = 1;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < nshifts)) {
#line 247
      goto while_break;
    }
#line 249
    sym = *(shift_symbol + i);
#line 251
    j = i;
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (0 < j) {
#line 251
        if (! (sym < *(shift_symbol + (j - 1)))) {
#line 251
          goto while_break___0;
        }
      } else {
#line 251
        goto while_break___0;
      }
#line 252
      *(shift_symbol + j) = *(shift_symbol + (j - 1));
#line 251
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 253
    *(shift_symbol + j) = sym;
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (! (i < nshifts)) {
#line 256
      goto while_break___1;
    }
    {
#line 258
    sym___0 = *(shift_symbol + i);
#line 259
    *(shiftset + i) = get_state(sym___0, (size_t )*(kernel_size + sym___0), *(kernel_base + sym___0));
#line 256
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 270 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void save_reductions(state *s ) 
{ 
  int count ;
  size_t i ;
  item_number item ;
  rule_number r ;
  rule_number tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 273
  count = 0;
#line 277
  i = (size_t )0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < nitemset)) {
#line 277
      goto while_break;
    }
    {
#line 279
    item = *(ritem + *(itemset + i));
#line 280
    tmp___1 = item_number_is_rule_number(item);
    }
#line 280
    if (tmp___1) {
      {
#line 282
      tmp = item_number_as_rule_number(item);
#line 282
      r = tmp;
#line 283
      tmp___0 = count;
#line 283
      count ++;
#line 283
      *(redset + tmp___0) = rules + r;
      }
#line 284
      if (r == 0) {
        {
#line 287
        aver((_Bool )(! final_state));
#line 288
        final_state = s;
        }
      }
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  state_reductions_set(s, count, redset);
  }
#line 295
  return;
}
}
#line 302 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
static void set_states(void) 
{ 
  void *tmp ;
  state_list *this ;
  state *s ;

  {
  {
#line 305
  tmp = xcalloc((size_t )nstates, (size_t )sizeof(*states));
#line 305
  states = (state **)tmp;
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! first_state) {
#line 307
      goto while_break;
    }
#line 309
    this = first_state;
#line 315
    s = this->state;
#line 316
    if (! s->transitions) {
      {
#line 317
      state_transitions_set(s, 0, (state **)0);
      }
    }
#line 318
    if (! s->reductions) {
      {
#line 319
      state_reductions_set(s, 0, (rule **)0);
      }
    }
    {
#line 321
    *(states + s->number) = s;
#line 323
    first_state = this->next;
#line 324
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  first_state = (state_list *)((void *)0);
#line 327
  last_state = (state_list *)((void *)0);
#line 328
  return;
}
}
#line 336 "/home/pronto/abs/test-suite/bison-2.4/src/LR0.c"
void generate_states(void) 
{ 
  item_number initial_core ;
  state_list *list ;
  state *s ;

  {
  {
#line 339
  initial_core = 0;
#line 340
  list = (state_list *)((void *)0);
#line 341
  allocate_storage();
#line 342
  new_closure(nritems);
#line 346
  state_list_append(0, (size_t )1, & initial_core);
#line 349
  list = first_state;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! list) {
#line 349
      goto while_break;
    }
#line 351
    s = list->state;
#line 352
    if (trace_flag & 64) {
      {
#line 353
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Processing state %d (reached by %s)\n",
              s->number, (*(symbols + s->accessing_symbol))->tag);
      }
    }
    {
#line 358
    closure(s->items, s->nitems);
#line 360
    save_reductions(s);
#line 362
    new_itemsets(s);
#line 364
    append_states(s);
#line 368
    state_transitions_set(s, nshifts, shiftset);
#line 349
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  free_closure();
#line 373
  free_storage();
#line 376
  set_states();
  }
#line 377
  return;
}
}
