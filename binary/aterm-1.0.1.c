/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 267 "/usr/include/X11/Xlib.h"
struct _XDisplay;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_78 XButtonEvent;
#line 380 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_action_t_168 {
   short type ;
   short len ;
   unsigned char *str ;
};
#line 380 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_action_t_168 action_t;
#line 386
struct menu_t;
#line 386 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_submenu_t_169 {
   short type ;
   struct menu_t *menu ;
};
#line 386 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_submenu_t_169 submenu_t;
#line 391 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
union __anonunion_entry_170 {
   short type ;
   action_t action ;
   submenu_t submenu ;
};
#line 391 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct menuitem_t {
   struct menuitem_t *prev ;
   struct menuitem_t *next ;
   char *name ;
   char *name2 ;
   short len ;
   short len2 ;
   union __anonunion_entry_170 entry ;
};
#line 391 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct menuitem_t menuitem_t;
#line 412 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct menu_t {
   struct menu_t *parent ;
   struct menu_t *prev ;
   struct menu_t *next ;
   menuitem_t *head ;
   menuitem_t *tail ;
   menuitem_t *item ;
   char *name ;
   short len ;
   short width ;
   Window win ;
   short x ;
   short y ;
   short w ;
   short h ;
};
#line 412 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct menu_t menu_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_51 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_51 fd_set;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_57 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_57 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_58 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_58 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_59 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_59 Depth;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_60 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_60 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_61 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_61 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_62 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_62 XSetWindowAttributes;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_67 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_67 XColor;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_76 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_76 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_77 XKeyEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_79 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_80 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_81 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_82 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_83 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_84 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_85 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_86 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_87 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_88 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_89 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_90 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_91 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_92 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_93 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_94 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_95 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_96 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_97 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_98 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_99 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_100 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_101 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_102 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_103 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_105 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_105 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_104 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_106 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_107 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_107 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_108 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_109 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_109 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_110 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_111 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_111 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_112 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_112 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_113 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_113 XFontStruct;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 122 "/usr/include/X11/Intrinsic.h"
typedef unsigned long Pixel;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 155 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct MyStyle;
#line 209 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef unsigned short R_u_int16_t;
#line 242 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct ShadingInfo {
   XColor tintColor ;
   int shading ;
};
#line 242 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct ShadingInfo ShadingInfo;
#line 253
enum __anonenum_trgType_164 {
    BGT_Tile = 1,
    BGT_Center = 2,
    BGT_Scale = 3,
    BGT_ScaleH = 4,
    BGT_ScaleV = 5,
    BGT_NoTile = 6,
    BGT_NoTileH = 7,
    BGT_NoTileV = 8,
    BGT_Cut = 9,
    BGT_None = 10
} ;
#line 253 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct _BackroundInfo {
   Pixmap srcPixmap ;
   struct MyStyle *mystyle ;
   unsigned int user_flags ;
   int srcWidth ;
   int srcHeight ;
   int srcX ;
   int srcY ;
   int Width ;
   int Height ;
   int bMySource ;
   enum __anonenum_trgType_164 trgType ;
   Pixmap trgPixmap ;
   int trgPixmapSet ;
   int finWidth ;
   int finHeight ;
   int cutX ;
   int cutY ;
   ShadingInfo Shading ;
};
#line 253 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct _BackroundInfo BackgroundInfo;
#line 308 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_TermWin_t_165 {
   R_u_int16_t width ;
   R_u_int16_t height ;
   R_u_int16_t fwidth ;
   R_u_int16_t fheight ;
   R_u_int16_t fprop ;
   R_u_int16_t ncol ;
   R_u_int16_t nrow ;
   R_u_int16_t bcol ;
   R_u_int16_t min_bcol ;
   R_u_int16_t focus ;
   R_u_int16_t saveLines ;
   R_u_int16_t borderWidth ;
   R_u_int16_t nscrolled ;
   R_u_int16_t view_start ;
   Window parent ;
   Window vt ;
   GC gc ;
   XFontStruct *font ;
   XFontStruct *boldFont ;
   BackgroundInfo background ;
   int root_x ;
   int root_y ;
   int root_width ;
   int root_height ;
   GC tintGC ;
   Pixmap LastPixmapUsed ;
   int LastPixmap_width ;
   int LastPixmap_height ;
   int LastPixmap_root_x ;
   int LastPixmap_root_y ;
   int bMapped ;
};
#line 308 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_TermWin_t_165 TermWin_t;
#line 1013 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct ExtWMSupportData {
   unsigned long flags ;
   Window supporting_wm_check ;
   CARD32 current_desktop ;
   CARD32 aterm_desktop ;
};
#line 1013 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct ExtWMSupportData ExtWMSupportData;
#line 212 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef long R_int_p_t;
#line 213 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef unsigned long R_u_int_p_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_63 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_63 XWindowAttributes;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_75 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_75 XModifierKeymap;
#line 584 "/usr/include/X11/Xlib.h"
typedef XKeyEvent XKeyPressedEvent;
#line 1157
struct _XIM;
#line 1157 "/usr/include/X11/Xlib.h"
typedef struct _XIM *XIM;
#line 1158
struct _XIC;
#line 1158 "/usr/include/X11/Xlib.h"
typedef struct _XIC *XIC;
#line 1178 "/usr/include/X11/Xlib.h"
typedef unsigned long XIMStyle;
#line 1180 "/usr/include/X11/Xlib.h"
struct __anonstruct_XIMStyles_125 {
   unsigned short count_styles ;
   XIMStyle *supported_styles ;
};
#line 1180 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XIMStyles_125 XIMStyles;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 368 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_scrollBar_t_166 {
   short beg ;
   short end ;
   short top ;
   short bot ;
   short state ;
   Window win ;
};
#line 368 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_scrollBar_t_166 scrollBar_t;
#line 465 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct termios ttymode_t;
#line 2237 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
struct __anonstruct_MEvent_192 {
   int clicks ;
   Time time ;
   unsigned int state ;
   unsigned int button ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 84 "/usr/include/X11/Xresource.h"
typedef int XrmQuark;
#line 84 "/usr/include/X11/Xresource.h"
typedef int *XrmQuarkList;
#line 87 "/usr/include/X11/Xresource.h"
typedef char *XrmString;
#line 117
enum __anonenum_XrmBinding_144 {
    XrmBindTightly = 0,
    XrmBindLoosely = 1
} ;
#line 117 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmBinding_144 *XrmBindingList;
#line 156 "/usr/include/X11/Xresource.h"
typedef XrmQuark XrmRepresentation;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_145 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_145 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 93 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
struct __anonstruct_optList_178 {
   unsigned long flag ;
   char const   **dp ;
   char const   * const  kw ;
   char const   * const  opt ;
   char const   * const  arg ;
   char const   * const  desc ;
};
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_138 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_138 XTextProperty;
#line 174
enum __anonenum_XICCEncodingStyle_139 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
#line 174 "/usr/include/X11/Xutil.h"
typedef enum __anonenum_XICCEncodingStyle_139 XICCEncodingStyle;
#line 208 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef short R_int16_t;
#line 458 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_row_col_t_171 {
   R_int16_t row ;
   R_int16_t col ;
};
#line 458 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_row_col_t_171 row_col_t;
#line 8 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
typedef unsigned char text_t;
#line 13 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
typedef R_u_int16_t rend_t;
#line 58 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
struct __anonstruct_screen_t_174 {
   text_t **text ;
   R_int16_t *tlen ;
   rend_t **rend ;
   row_col_t cur ;
   R_int16_t tscroll ;
   R_int16_t bscroll ;
   R_int16_t rscroll ;
   R_int16_t lscroll ;
   R_int16_t charset ;
   unsigned int flags ;
};
#line 58 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
typedef struct __anonstruct_screen_t_174 screen_t;
#line 71 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
struct __anonstruct_save_t_175 {
   row_col_t cur ;
   R_int16_t charset ;
   char charset_char ;
   rend_t rstyle ;
};
#line 71 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
typedef struct __anonstruct_save_t_175 save_t;
#line 78
enum __anonenum_op_177 {
    SELECTION_CLEAR = 0,
    SELECTION_INIT = 1,
    SELECTION_BEGIN = 2,
    SELECTION_CONT = 3,
    SELECTION_DONE = 4
} ;
#line 78 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
struct __anonstruct_selection_t_176 {
   unsigned char *text ;
   int len ;
   enum __anonenum_op_177 op ;
   short screen ;
   short clicks ;
   row_col_t beg ;
   row_col_t mark ;
   row_col_t end ;
   char type ;
   int request_time ;
};
#line 78 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
typedef struct __anonstruct_selection_t_176 selection_t;
#line 3301 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
enum __anonenum_closeto_179 {
    LEFT = 0,
    RIGHT = 1
} ;
#line 440 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct grcmd_t {
   char cmd ;
   short color ;
   short ncoords ;
   int *coords ;
   unsigned char *text ;
   struct grcmd_t *next ;
};
#line 440 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct grcmd_t grcmd_t;
#line 449 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct grwin_t {
   Window win ;
   int x ;
   int y ;
   unsigned int w ;
   unsigned int h ;
   short screen ;
   grcmd_t *graphics ;
   struct grwin_t *prev ;
   struct grwin_t *next ;
};
#line 449 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct grwin_t grwin_t;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_136 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_135 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_136 min_aspect ;
   struct __anonstruct_min_aspect_136 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_135 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_137 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_137 XWMHints;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_141 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_141 XClassHint;
#line 287 "/usr/include/X11/Xutil.h"
struct __anonstruct_XVisualInfo_142 {
   Visual *visual ;
   VisualID visualid ;
   int screen ;
   int depth ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int colormap_size ;
   int bits_per_rgb ;
};
#line 287 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XVisualInfo_142 XVisualInfo;
#line 98 "/usr/include/X11/Xmd.h"
typedef int INT32;
#line 375 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct __anonstruct_menuBar_t_167 {
   short state ;
   Window win ;
};
#line 375 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct __anonstruct_menuBar_t_167 menuBar_t;
#line 548 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
struct MwmHints {
   CARD32 flags ;
   CARD32 functions ;
   CARD32 decorations ;
   INT32 input_mode ;
   CARD32 status ;
};
#line 548 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
typedef struct MwmHints MwmHints;
#line 1840 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
union __anonunion_data_337 {
   unsigned char *uc_ptr ;
   long *long_ptr ;
};
#line 1877 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
union __anonunion_buffer_338 {
   unsigned char *uc_ptr ;
   long *long_ptr ;
};
#line 124 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
struct __anonstruct_Icon_178 {
   Pixmap icon ;
   Pixmap icon_mask ;
   int origin_x ;
   int origin_y ;
   int width ;
   int height ;
};
#line 124 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
typedef struct __anonstruct_Icon_178 Icon;
#line 130 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
struct __anonstruct_ScrollArrows_179 {
   unsigned int arrow_width ;
   unsigned int arrow_height ;
   int bValid ;
   char **Data[4] ;
   Icon Arrows[4] ;
};
#line 130 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
typedef struct __anonstruct_ScrollArrows_179 ScrollArrows;
#line 186 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
struct __anonstruct_IconGC_180 {
   GC blackGC ;
   GC whiteGC ;
   GC darkGC ;
   GC maskGC ;
   GC maskGC_0 ;
};
#line 186 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
typedef struct __anonstruct_IconGC_180 IconGC;
#line 471 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
struct __anonstruct_TransparencyCache_181 {
   Pixmap root ;
   unsigned int x ;
   unsigned int y ;
   unsigned int height ;
   Pixmap cache ;
};
#line 471 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
typedef struct __anonstruct_TransparencyCache_181 TransparencyCache;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/menubar.pro"
menuitem_t *menuitem_find(menu_t *menu , char *name ) ;
#line 2
void menuitem_free(menu_t *menu , menuitem_t *item ) ;
#line 3
int action_type(action_t *action , unsigned char *str ) ;
#line 4
int action_dispatch(action_t *action ) ;
#line 5
int menuarrow_find(char name ) ;
#line 6
void menuarrow_free(char name ) ;
#line 7
void menuarrow_add(char *string ) ;
#line 8
menuitem_t *menuitem_add(menu_t *menu , char *name , char *name2 , char *action ) ;
#line 9
char *menu_find_base(menu_t **menu , char *path ) ;
#line 10
menu_t *menu_delete(menu_t *menu ) ;
#line 11
menu_t *menu_add(menu_t *parent , char *path ) ;
#line 12
void drawbox_menubar(int x , int len , int state ) ;
#line 13
void drawtriangle(int x , int y , int state ) ;
#line 14
void drawbox_menuitem(int y , int state ) ;
#line 17
void menu_show(void) ;
#line 18
void menu_display(void (*update)(void) ) ;
#line 19
void menu_hide_all(void) ;
#line 20
void menu_hide(void) ;
#line 21
void menu_clear(menu_t *menu ) ;
#line 22
void menubar_clear(void) ;
#line 29
void menubar_read(char const   *filename ) ;
#line 30
void menubar_dispatch(char *str ) ;
#line 31
void draw_Arrows(int name , int state ) ;
#line 32
void menubar_expose(void) ;
#line 33
int menubar_mapping(int map ) ;
#line 34
int menu_select(XButtonEvent *ev ) ;
#line 35
void menubar_select(XButtonEvent *ev ) ;
#line 36
void menubar_control(XButtonEvent *ev ) ;
#line 37
void map_menuBar(int map ) ;
#line 38
void create_menuBar(Cursor cursor ) ;
#line 39
void Resize_menuBar(int x , int y , unsigned int width , unsigned int height ) ;
#line 89 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
menuitem_t *menuitem_find(menu_t *menu , char *name ) 
{ 


  {
#line 109
  return ((menuitem_t *)((void *)0));
}
}
#line 117 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menuitem_free(menu_t *menu , menuitem_t *item ) 
{ 


  {
#line 154
  return;
}
}
#line 161 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
int action_type(action_t *action , unsigned char *str ) 
{ 


  {
#line 196
  return (0);
}
}
#line 200 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
int action_dispatch(action_t *action ) 
{ 


  {
#line 218
  return (0);
}
}
#line 223 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
int menuarrow_find(char name ) 
{ 


  {
#line 233
  return (-1);
}
}
#line 238 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menuarrow_free(char name ) 
{ 


  {
#line 264
  return;
}
}
#line 267 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menuarrow_add(char *string ) 
{ 


  {
#line 391
  return;
}
}
#line 394 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
menuitem_t *menuitem_add(menu_t *menu , char *name , char *name2 , char *action ) 
{ 


  {
#line 501
  return ((menuitem_t *)((void *)0));
}
}
#line 510 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
char *menu_find_base(menu_t **menu , char *path ) 
{ 


  {
#line 583
  return ((char *)((void *)0));
}
}
#line 591 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
menu_t *menu_delete(menu_t *menu ) 
{ 


  {
#line 650
  return ((menu_t *)((void *)0));
}
}
#line 655 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
menu_t *menu_add(menu_t *parent , char *path ) 
{ 


  {
#line 733
  return ((menu_t *)((void *)0));
}
}
#line 738 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void drawbox_menubar(int x , int len , int state ) 
{ 


  {
#line 771
  return;
}
}
#line 774 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void drawtriangle(int x , int y , int state ) 
{ 


  {
#line 805
  return;
}
}
#line 808 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void drawbox_menuitem(int y , int state ) 
{ 


  {
#line 838
  return;
}
}
#line 914 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menu_show(void) 
{ 


  {
#line 1052
  return;
}
}
#line 1055 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menu_display(void (*update)(void) ) 
{ 


  {
#line 1071
  return;
}
}
#line 1074 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menu_hide_all(void) 
{ 


  {
#line 1080
  return;
}
}
#line 1083 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menu_hide(void) 
{ 


  {
#line 1089
  return;
}
}
#line 1092 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menu_clear(menu_t *menu ) 
{ 


  {
#line 1109
  return;
}
}
#line 1112 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_clear(void) 
{ 


  {
#line 1135
  return;
}
}
#line 1460 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_read(char const   *filename ) 
{ 


  {
#line 1558
  return;
}
}
#line 1564 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_dispatch(char *str ) 
{ 


  {
#line 1897
  return;
}
}
#line 1900 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void draw_Arrows(int name , int state ) 
{ 


  {
#line 1939
  return;
}
}
#line 1942 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_expose(void) 
{ 


  {
#line 2066
  return;
}
}
#line 2069 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
int menubar_mapping(int map ) 
{ 
  int change ;

  {
#line 2072
  change = 0;
#line 2088
  return (change);
}
}
#line 2092 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
int menu_select(XButtonEvent *ev ) 
{ 


  {
#line 2230
  return (0);
}
}
#line 2234 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_select(XButtonEvent *ev ) 
{ 


  {
#line 2321
  return;
}
}
#line 2328 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void menubar_control(XButtonEvent *ev ) 
{ 


  {
#line 2367
  return;
}
}
#line 2370 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void map_menuBar(int map ) 
{ 


  {
#line 2379
  return;
}
}
#line 2382 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void create_menuBar(Cursor cursor ) 
{ 


  {
#line 2399
  return;
}
}
#line 2402 "/home/june/collector/temp/aterm-1.0.1/src/menubar.c"
void Resize_menuBar(int x , int y , unsigned int width , unsigned int height ) 
{ 


  {
#line 2408
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 1468 "/usr/include/X11/Xlib.h"
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 2134
extern int XCheckWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2528
extern int XFree(void * ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2632
extern int XGetGeometry(Display * , Drawable  , Window * , int * , int * , unsigned int * ,
                        unsigned int * , unsigned int * , unsigned int * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2753
extern int XGrabServer(Display * ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3351
extern int XSetWindowBackgroundPixmap(Display * , Window  , Pixmap  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3458
extern int XTranslateCoordinates(Display * , Window  , Window  , int  , int  , int * ,
                                 int * , Window * ) ;
#line 3498
extern int XUngrabServer(Display * ) ;
#line 166 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom _XROOTPMAP_ID ;
#line 993
int Xdepth ;
#line 996
TermWin_t TermWin ;
#line 1003
int TermWin_internalBorder ;
#line 1010
Display *Xdisplay ;
#line 1011
int XdisplayWidth ;
#line 1011
int XdisplayHeight ;
#line 1027
ExtWMSupportData ExtWM ;
#line 1032
unsigned long Options ;
#line 1046
Pixel *PixColors ;
#line 3 "/home/june/collector/temp/aterm-1.0.1/src/command.pro"
void set_background_updated(void) ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.pro"
Pixmap GetRootPixmap(Atom id ) ;
#line 2
Pixmap ValidatePixmap(Pixmap p , int bSetHandler , int bTransparent , unsigned int *pWidth ,
                      unsigned int *pHeight ) ;
#line 3
int GetRootDimensions(int *width , int *height ) ;
#line 4
int GetWinPosition(Window w , int *x , int *y ) ;
#line 5
Pixmap CutWinPixmap(Window win , Drawable src , int src_w , int src_h , int width ,
                    int height , GC gc , ShadingInfo *shading ) ;
#line 6
int FillPixmapWithTile(Pixmap pixmap , Pixmap tile , int x , int y , int width , int height ,
                       int tile_x , int tile_y ) ;
#line 7
void SetSrcPixmap(Pixmap p ) ;
#line 8
void ValidateSrcPixmap(int bSetHandler ) ;
#line 9
int GetMyPosition(int *x , int *y ) ;
#line 10
int IsTransparentPixmap(void) ;
#line 11
int TransparentPixmapNeedsUpdate(void) ;
#line 12
void RenderPixmap(int DontCheckSource ) ;
#line 32 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int pixmap_error_handler(Display *dpy , XErrorEvent *error ) 
{ 


  {
#line 39
  return (0);
}
}
#line 51 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
Pixmap GetRootPixmap(Atom id ) 
{ 
  Pixmap currentRootPixmap ;
  Atom act_type ;
  int act_format ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  unsigned char *prop ;
  int tmp ;

  {
  {
#line 54
  currentRootPixmap = (Pixmap )0L;
#line 59
  prop = (unsigned char *)((void *)0);
#line 62
  tmp = XGetWindowProperty(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                           _XROOTPMAP_ID, 0L, 1L, 0, (Atom )20, & act_type, & act_format,
                           & nitems, & bytes_after, & prop);
  }
#line 62
  if (tmp == 0) {
#line 66
    if (prop) {
      {
#line 68
      currentRootPixmap = *((Pixmap *)prop);
#line 69
      XFree((void *)prop);
      }
    }
  }
#line 74
  return (currentRootPixmap);
}
}
#line 78 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
Pixmap ValidatePixmap(Pixmap p , int bSetHandler , int bTransparent , unsigned int *pWidth ,
                      unsigned int *pHeight ) 
{ 
  int (*oldXErrorHandler)(Display * , XErrorEvent * ) ;
  Window root ;
  int junk ;
  int tmp ;

  {
#line 82
  oldXErrorHandler = (int (*)(Display * , XErrorEvent * ))((void *)0);
#line 86
  if (bSetHandler) {
    {
#line 87
    oldXErrorHandler = XSetErrorHandler(& pixmap_error_handler);
    }
  }
#line 89
  if (bTransparent) {
    {
#line 90
    p = GetRootPixmap((Atom )0L);
    }
  }
#line 91
  if (! pWidth) {
#line 92
    pWidth = (unsigned int *)(& junk);
  }
#line 93
  if (! pHeight) {
#line 94
    pHeight = (unsigned int *)(& junk);
  }
#line 96
  if (p != 0UL) {
    {
#line 98
    tmp = XGetGeometry(Xdisplay, p, & root, & junk, & junk, pWidth, pHeight, (unsigned int *)(& junk),
                       (unsigned int *)(& junk));
    }
#line 98
    if (! tmp) {
#line 99
      p = (Pixmap )0L;
    }
  }
#line 101
  if (bSetHandler) {
    {
#line 102
    XSetErrorHandler(oldXErrorHandler);
    }
  }
#line 104
  return (p);
}
}
#line 111 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int GetRootDimensions(int *width , int *height ) 
{ 
  Window root ;
  int w_x ;
  int w_y ;
  unsigned int junk ;
  int tmp ;
  int tmp___0 ;

  {
#line 118
  if ((unsigned long )Xdisplay == (unsigned long )((void *)0)) {
#line 119
    return (0);
  }
  {
#line 120
  tmp = XGetGeometry(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                     & root, & w_x, & w_y, (unsigned int *)width, (unsigned int *)height,
                     & junk, & junk);
  }
#line 120
  if (! tmp) {
#line 123
    *width = 0;
#line 124
    *height = 0;
  }
#line 126
  if (*width > 0) {
#line 126
    if (*height > 0) {
#line 126
      tmp___0 = 1;
    } else {
#line 126
      tmp___0 = 0;
    }
  } else {
#line 126
    tmp___0 = 0;
  }
#line 126
  return (tmp___0);
}
}
#line 138 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
static int rootWidth  =    0;
#line 138 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
static int rootHeight  =    0;
#line 133 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int GetWinPosition(Window w , int *x , int *y ) 
{ 
  int bRes ;
  int my_x ;
  int my_y ;
  Window wdumm ;
  int tmp ;

  {
#line 137
  bRes = 1;
#line 142
  if (! x) {
#line 143
    x = & my_x;
  }
#line 144
  if (! y) {
#line 145
    y = & my_y;
  }
#line 147
  *x = 0;
#line 148
  *y = 0;
#line 150
  if (! rootWidth) {
#line 150
    goto _L;
  } else
#line 150
  if (! rootHeight) {
    _L: /* CIL Label */ 
    {
#line 151
    tmp = GetRootDimensions(& rootWidth, & rootHeight);
    }
#line 151
    if (! tmp) {
#line 152
      return (0);
    }
  }
  {
#line 154
  XTranslateCoordinates(Xdisplay, w, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                        0, 0, x, y, & wdumm);
  }
#line 156
  if (*x < 0) {
#line 157
    bRes = 0;
  } else
#line 156
  if (*x >= rootWidth) {
#line 157
    bRes = 0;
  } else
#line 156
  if (*y < 0) {
#line 157
    bRes = 0;
  } else
#line 156
  if (*y >= rootHeight) {
#line 157
    bRes = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (*x < 0)) {
#line 159
      goto while_break;
    }
#line 160
    *x += rootWidth;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (*y < 0)) {
#line 161
      goto while_break___0;
    }
#line 162
    *y += rootHeight;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  if (*x > rootWidth) {
#line 164
    *x %= rootWidth;
  }
#line 165
  if (*y > rootHeight) {
#line 166
    *y %= rootHeight;
  }
#line 167
  return (bRes);
#line 169
  *x = 0;
#line 170
  *y = 0;
#line 171
  return (0);
}
}
#line 174 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void ShadeXImage(XImage *srcImage , ShadingInfo *shading , GC gc ) 
{ 
  int sh_r ;
  int sh_g ;
  int sh_b ;
  unsigned int mask_r ;
  unsigned int mask_g ;
  unsigned int mask_b ;
  unsigned int *lookup ;
  unsigned int *lookup_r ;
  unsigned int *lookup_g ;
  unsigned int *lookup_b ;
  unsigned int lower_lim_r ;
  unsigned int lower_lim_g ;
  unsigned int lower_lim_b ;
  unsigned int upper_lim_r ;
  unsigned int upper_lim_g ;
  unsigned int upper_lim_b ;
  int i ;
  Visual *visual ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int shade ;
  int shade___0 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned short *p1 ;
  unsigned short *pf ;
  unsigned short *p ;
  unsigned short *pl ;
  unsigned short *p1___0 ;
  unsigned short *pf___0 ;
  unsigned short *p___0 ;
  unsigned short *pl___0 ;
  unsigned char *p1___1 ;
  unsigned char *pf___1 ;
  unsigned char *p___1 ;
  unsigned char *pl___1 ;
  unsigned int *p1___2 ;
  unsigned int *pf___2 ;
  unsigned int *p___2 ;
  unsigned int *pl___2 ;

  {
#line 190
  visual = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_visual;
#line 193
  if (visual->class != 4) {
#line 193
    return;
  } else
#line 193
  if (srcImage->format != 2) {
#line 193
    return;
  }
#line 196
  mask_r = (unsigned int )visual->red_mask;
#line 197
  mask_g = (unsigned int )visual->green_mask;
#line 198
  mask_b = (unsigned int )visual->blue_mask;
  {
#line 202
  if (srcImage->bits_per_pixel == 15) {
#line 202
    goto case_15;
  }
#line 215
  if (srcImage->bits_per_pixel == 16) {
#line 215
    goto case_16;
  }
#line 228
  if (srcImage->bits_per_pixel == 24) {
#line 228
    goto case_24;
  }
#line 241
  if (srcImage->bits_per_pixel == 32) {
#line 241
    goto case_32;
  }
#line 254
  goto switch_default;
  case_15: /* CIL Label */ 
#line 203
  if (mask_r != 31744U) {
#line 206
    return;
  } else
#line 203
  if (mask_g != 992U) {
#line 206
    return;
  } else
#line 203
  if (mask_b != 31U) {
#line 206
    return;
  }
  {
#line 207
  tmp = malloc(sizeof(unsigned int ) * 96UL);
#line 207
  lookup = (unsigned int *)tmp;
#line 208
  lookup_r = lookup;
#line 209
  lookup_g = lookup + 32;
#line 210
  lookup_b = (lookup + 32) + 32;
#line 211
  sh_r = 10;
#line 212
  sh_g = 5;
#line 213
  sh_b = 0;
  }
#line 214
  goto switch_break;
  case_16: /* CIL Label */ 
#line 216
  if (mask_r != 63488U) {
#line 219
    return;
  } else
#line 216
  if (mask_g != 2016U) {
#line 219
    return;
  } else
#line 216
  if (mask_b != 31U) {
#line 219
    return;
  }
  {
#line 220
  tmp___0 = malloc(sizeof(unsigned int ) * 128UL);
#line 220
  lookup = (unsigned int *)tmp___0;
#line 221
  lookup_r = lookup;
#line 222
  lookup_g = lookup + 32;
#line 223
  lookup_b = (lookup + 32) + 64;
#line 224
  sh_r = 11;
#line 225
  sh_g = 5;
#line 226
  sh_b = 0;
  }
#line 227
  goto switch_break;
  case_24: /* CIL Label */ 
#line 229
  if (mask_r != 16711680U) {
#line 232
    return;
  } else
#line 229
  if (mask_g != 65280U) {
#line 232
    return;
  } else
#line 229
  if (mask_b != 255U) {
#line 232
    return;
  }
  {
#line 233
  tmp___1 = malloc(sizeof(unsigned int ) * 768UL);
#line 233
  lookup = (unsigned int *)tmp___1;
#line 234
  lookup_r = lookup;
#line 235
  lookup_g = lookup + 256;
#line 236
  lookup_b = (lookup + 256) + 256;
#line 237
  sh_r = 16;
#line 238
  sh_g = 8;
#line 239
  sh_b = 0;
  }
#line 240
  goto switch_break;
  case_32: /* CIL Label */ 
#line 242
  if (mask_r != 16711680U) {
#line 245
    return;
  } else
#line 242
  if (mask_g != 65280U) {
#line 245
    return;
  } else
#line 242
  if (mask_b != 255U) {
#line 245
    return;
  }
  {
#line 246
  tmp___2 = malloc(sizeof(unsigned int ) * 768UL);
#line 246
  lookup = (unsigned int *)tmp___2;
#line 247
  lookup_r = lookup;
#line 248
  lookup_g = lookup + 256;
#line 249
  lookup_b = (lookup + 256) + 256;
#line 250
  sh_r = 16;
#line 251
  sh_g = 8;
#line 252
  sh_b = 0;
  }
#line 253
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 255
  return;
  switch_break: /* CIL Label */ ;
  }
#line 259
  if (shading->shading < 0) {
#line 261
    shade = - shading->shading;
#line 262
    if (shade < 0) {
#line 262
      shade = 0;
    }
#line 263
    if (shade > 100) {
#line 263
      shade = 100;
    }
#line 265
    lower_lim_r = (unsigned int )(65535 - (int )shading->tintColor.red);
#line 266
    lower_lim_g = (unsigned int )(65535 - (int )shading->tintColor.green);
#line 267
    lower_lim_b = (unsigned int )(65535 - (int )shading->tintColor.blue);
#line 269
    lower_lim_r = 65535U - (lower_lim_r * (unsigned int )shade) / 100U;
#line 270
    lower_lim_g = 65535U - (lower_lim_g * (unsigned int )shade) / 100U;
#line 271
    lower_lim_b = 65535U - (lower_lim_b * (unsigned int )shade) / 100U;
#line 273
    upper_lim_b = 65535U;
#line 273
    upper_lim_g = upper_lim_b;
#line 273
    upper_lim_r = upper_lim_g;
  } else {
#line 276
    shade___0 = shading->shading;
#line 277
    if (shade___0 < 0) {
#line 277
      shade___0 = 0;
    }
#line 278
    if (shade___0 > 100) {
#line 278
      shade___0 = 100;
    }
#line 280
    lower_lim_b = 0U;
#line 280
    lower_lim_g = lower_lim_b;
#line 280
    lower_lim_r = lower_lim_g;
#line 282
    upper_lim_r = ((unsigned int )shading->tintColor.red * (unsigned int )shading->shading) / 100U;
#line 283
    upper_lim_g = ((unsigned int )shading->tintColor.green * (unsigned int )shading->shading) / 100U;
#line 284
    upper_lim_b = ((unsigned int )shading->tintColor.blue * (unsigned int )shading->shading) / 100U;
  }
#line 288
  if (srcImage->bits_per_pixel == 24) {
#line 288
    if (mask_r >= 16711680U) {
#line 292
      tmp___3 = lower_lim_r;
#line 293
      lower_lim_r = lower_lim_b;
#line 294
      lower_lim_b = tmp___3;
#line 296
      tmp___3 = upper_lim_r;
#line 297
      upper_lim_r = upper_lim_b;
#line 298
      upper_lim_b = tmp___3;
    }
  }
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! ((unsigned int )i <= mask_r >> sh_r)) {
#line 302
      goto while_break;
    }
#line 305
    tmp___4 = (unsigned int )i * (upper_lim_r - lower_lim_r);
#line 306
    tmp___4 += (mask_r >> sh_r) * lower_lim_r;
#line 307
    *(lookup_r + i) = tmp___4 / 65535U << sh_r;
#line 302
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if (! ((unsigned int )i <= mask_g >> sh_g)) {
#line 309
      goto while_break___0;
    }
#line 312
    tmp___5 = (unsigned int )i * (upper_lim_g - lower_lim_g);
#line 313
    tmp___5 += (mask_g >> sh_g) * lower_lim_g;
#line 314
    *(lookup_g + i) = tmp___5 / 65535U << sh_g;
#line 309
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 316
    if (! ((unsigned int )i <= mask_b >> sh_b)) {
#line 316
      goto while_break___1;
    }
#line 319
    tmp___6 = (unsigned int )i * (upper_lim_b - lower_lim_b);
#line 320
    tmp___6 += (mask_b >> sh_b) * lower_lim_b;
#line 321
    *(lookup_b + i) = tmp___6 / 65535U << sh_b;
#line 316
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  if (srcImage->bits_per_pixel == 15) {
#line 327
    goto case_15___0;
  }
#line 346
  if (srcImage->bits_per_pixel == 16) {
#line 346
    goto case_16___0;
  }
#line 365
  if (srcImage->bits_per_pixel == 24) {
#line 365
    goto case_24___0;
  }
#line 384
  if (srcImage->bits_per_pixel == 32) {
#line 384
    goto case_32___0;
  }
#line 325
  goto switch_break___0;
  case_15___0: /* CIL Label */ 
#line 330
  p1 = (unsigned short *)srcImage->data;
#line 331
  pf = (unsigned short *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 332
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )p1 < (unsigned long )pf)) {
#line 332
      goto while_break___2;
    }
#line 334
    p = p1;
#line 335
    pl = p1 + srcImage->width;
    {
#line 336
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 336
      if (! ((unsigned long )p < (unsigned long )pl)) {
#line 336
        goto while_break___3;
      }
#line 338
      *p = (unsigned short )((*(lookup_r + (((int )*p & 31744) >> 10)) | *(lookup_g + (((int )*p & 992) >> 5))) | *(lookup_b + ((int )*p & 31)));
#line 336
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 342
    p1 = (unsigned short *)((char *)p1 + srcImage->bytes_per_line);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 344
  goto switch_break___0;
  case_16___0: /* CIL Label */ 
#line 349
  p1___0 = (unsigned short *)srcImage->data;
#line 350
  pf___0 = (unsigned short *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 351
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )p1___0 < (unsigned long )pf___0)) {
#line 351
      goto while_break___4;
    }
#line 353
    p___0 = p1___0;
#line 354
    pl___0 = p1___0 + srcImage->width;
    {
#line 355
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 355
      if (! ((unsigned long )p___0 < (unsigned long )pl___0)) {
#line 355
        goto while_break___5;
      }
#line 357
      *p___0 = (unsigned short )((*(lookup_r + (((int )*p___0 & 63488) >> 11)) | *(lookup_g + (((int )*p___0 & 2016) >> 5))) | *(lookup_b + ((int )*p___0 & 31)));
#line 355
      p___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 361
    p1___0 = (unsigned short *)((char *)p1___0 + srcImage->bytes_per_line);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 363
  goto switch_break___0;
  case_24___0: /* CIL Label */ 
#line 368
  p1___1 = (unsigned char *)srcImage->data;
#line 369
  pf___1 = (unsigned char *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 370
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )p1___1 < (unsigned long )pf___1)) {
#line 370
      goto while_break___6;
    }
#line 372
    p___1 = p1___1;
#line 373
    pl___1 = p1___1 + srcImage->width * 3;
    {
#line 374
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 374
      if (! ((unsigned long )p___1 < (unsigned long )pl___1)) {
#line 374
        goto while_break___7;
      }
#line 376
      *(p___1 + 0) = (unsigned char )*(lookup_r + (((int )*(p___1 + 0) & 16711680) >> 16));
#line 377
      *(p___1 + 1) = (unsigned char )*(lookup_r + (((int )*(p___1 + 1) & 65280) >> 8));
#line 378
      *(p___1 + 2) = (unsigned char )*(lookup_r + ((int )*(p___1 + 2) & 255));
#line 374
      p___1 += 3;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 380
    p1___1 = (unsigned char *)((char *)p1___1 + srcImage->bytes_per_line);
  }
  while_break___6: /* CIL Label */ ;
  }
#line 382
  goto switch_break___0;
  case_32___0: /* CIL Label */ 
#line 387
  p1___2 = (unsigned int *)srcImage->data;
#line 388
  pf___2 = (unsigned int *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 390
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 390
    if (! ((unsigned long )p1___2 < (unsigned long )pf___2)) {
#line 390
      goto while_break___8;
    }
#line 392
    p___2 = p1___2;
#line 393
    pl___2 = p1___2 + srcImage->width;
    {
#line 394
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 394
      if (! ((unsigned long )p___2 < (unsigned long )pl___2)) {
#line 394
        goto while_break___9;
      }
#line 396
      *p___2 = ((*(lookup_r + ((*p___2 & 16711680U) >> 16)) | *(lookup_g + ((*p___2 & 65280U) >> 8))) | *(lookup_b + (*p___2 & 255U))) | (*p___2 & 4278190080U);
#line 394
      p___2 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 401
    p1___2 = (unsigned int *)((char *)p1___2 + srcImage->bytes_per_line);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 403
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 407
  free((void *)lookup);
  }
#line 413
  return;
}
}
#line 415 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void CopyAndShadeArea(Drawable src , Pixmap trg , int x , int y , int w , int h ,
                      int trg_x , int trg_y , GC gc , ShadingInfo *shading ) 
{ 
  int (*oldXErrorHandler)(Display * , XErrorEvent * ) ;
  XImage *img ;
  int tmp ;

  {
  {
#line 422
  oldXErrorHandler = XSetErrorHandler(& pixmap_error_handler);
  }
#line 424
  if (shading) {
#line 428
    if (x < 0) {
#line 428
      return;
    } else
#line 428
    if (y < 0) {
#line 428
      return;
    }
    {
#line 429
    img = XGetImage(Xdisplay, src, x, y, (unsigned int )w, (unsigned int )h, (unsigned long )(~ 0L),
                    2);
    }
#line 429
    if ((unsigned long )img != (unsigned long )((void *)0)) {
      {
#line 431
      ShadeXImage(img, shading, gc);
#line 432
      XPutImage(Xdisplay, trg, gc, img, 0, 0, trg_x, trg_y, (unsigned int )w, (unsigned int )h);
#line 448
      (*(img->f.destroy_image))(img);
      }
#line 449
      return;
    }
  }
  {
#line 452
  tmp = XCopyArea(Xdisplay, src, trg, gc, x, y, (unsigned int )w, (unsigned int )h,
                  trg_x, trg_y);
  }
#line 452
  if (! tmp) {
    {
#line 453
    XFillRectangle(Xdisplay, trg, gc, trg_x, trg_y, (unsigned int )w, (unsigned int )h);
    }
  }
  {
#line 454
  XSetErrorHandler(oldXErrorHandler);
  }
#line 455
  return;
}
}
#line 457 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void ShadeTiledPixmap(Pixmap src , Pixmap trg , int src_w , int src_h , int x , int y ,
                      int w , int h , GC gc , ShadingInfo *shading ) 
{ 
  int tile_x ;
  int tile_y ;
  int left_w ;
  int bott_h ;

  {
#line 461
  if (src_w > 0) {
#line 461
    if (src_h > 0) {
#line 463
      tile_x = x % src_w;
#line 464
      tile_y = y % src_h;
#line 465
      if (src_w - tile_x < w) {
#line 465
        left_w = src_w - tile_x;
      } else {
#line 465
        left_w = w;
      }
#line 466
      if (src_h - tile_y < h) {
#line 466
        bott_h = src_h - tile_y;
      } else {
#line 466
        bott_h = h;
      }
      {
#line 468
      CopyAndShadeArea(src, trg, tile_x, tile_y, left_w, bott_h, 0, 0, gc, shading);
      }
#line 469
      if (bott_h < h) {
        {
#line 471
        CopyAndShadeArea(src, trg, tile_x, 0, left_w, h - bott_h, 0, bott_h, gc, shading);
        }
      }
#line 473
      if (left_w < w) {
        {
#line 475
        CopyAndShadeArea(src, trg, 0, tile_y, w - left_w, bott_h, left_w, 0, gc, shading);
        }
#line 476
        if (bott_h < h) {
          {
#line 477
          CopyAndShadeArea(src, trg, 0, 0, w - left_w, h - bott_h, left_w, bott_h,
                           gc, shading);
          }
        }
      }
    }
  }
#line 480
  return;
}
}
#line 482 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
Pixmap ShadePixmap(Pixmap src , int x , int y , int width , int height , GC gc , ShadingInfo *shading ) 
{ 
  Pixmap trg ;
  Pixmap tmp ;

  {
  {
#line 485
  tmp = XCreatePixmap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                      (unsigned int )width, (unsigned int )height, (unsigned int )Xdepth);
#line 485
  trg = tmp;
  }
#line 486
  if (trg != 0UL) {
    {
#line 488
    CopyAndShadeArea(src, trg, x, y, width, height, 0, 0, gc, shading);
    }
  }
#line 490
  return (trg);
}
}
#line 494 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void sleep_a_little(int n ) 
{ 
  struct timeval value ;

  {
#line 499
  if (n <= 0) {
#line 500
    return;
  }
  {
#line 502
  value.tv_usec = (__suseconds_t )(n % 1000000);
#line 503
  value.tv_sec = (__time_t )(n / 1000000);
#line 505
  select(1, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
         (struct timeval */* __restrict  */)(& value));
  }
#line 506
  return;
}
}
#line 509 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
static Pixmap CutPixmap(Pixmap src , Pixmap trg , int x , int y , unsigned int src_w ,
                        unsigned int src_h , unsigned int width , unsigned int height ,
                        GC gc , ShadingInfo *shading ) 
{ 
  int my_pixmap ;
  int tmp ;
  int screen_w ;
  int screen_h ;
  int offset_x ;
  int offset_y ;
  XSetWindowAttributes attr ;
  XEvent event ;
  int tick_count ;
  int grabbed ;
  int tmp___0 ;
  XImage *img ;
  Pixmap tmp___1 ;

  {
#line 516
  if (trg == 0UL) {
#line 516
    tmp = 1;
  } else {
#line 516
    tmp = 0;
  }
#line 516
  my_pixmap = tmp;
#line 518
  offset_x = 0;
#line 518
  offset_y = 0;
#line 520
  screen_w = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->width;
#line 521
  screen_h = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->height;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (x + (int )width < 0)) {
#line 523
      goto while_break;
    }
#line 523
    x += screen_w;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 524
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 524
    if (! (x >= screen_w)) {
#line 524
      goto while_break___0;
    }
#line 524
    x -= screen_w;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 525
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 525
    if (! (y + (int )height < 0)) {
#line 525
      goto while_break___1;
    }
#line 525
    y += screen_h;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 526
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 526
    if (! (y >= screen_h)) {
#line 526
      goto while_break___2;
    }
#line 526
    y -= screen_h;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 528
  if (width < 2U) {
#line 529
    return (trg);
  } else
#line 528
  if (height < 2U) {
#line 529
    return (trg);
  }
#line 530
  if (x < 0) {
#line 532
    offset_x = - x;
#line 533
    x = 0;
#line 534
    width -= (unsigned int )offset_x;
  }
#line 536
  if (y < 0) {
#line 538
    offset_y = - y;
#line 539
    y = 0;
#line 540
    height -= (unsigned int )offset_y;
  }
#line 542
  if ((unsigned int )x + width >= (unsigned int )screen_w) {
#line 542
    width = (unsigned int )(screen_w - x);
  }
#line 543
  if ((unsigned int )y + height >= (unsigned int )screen_h) {
#line 543
    height = (unsigned int )(screen_h - y);
  }
#line 545
  if (src == 0UL) {
    {
#line 550
    tick_count = 0;
#line 551
    grabbed = 0;
#line 552
    attr.background_pixmap = (Pixmap )1L;
#line 553
    attr.backing_store = 2;
#line 554
    attr.event_mask = 1L << 15;
#line 555
    attr.override_redirect = 1;
#line 556
    src = XCreateWindow(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                        x, y, width, height, 0U, 0, 0U, (Visual *)0L, (unsigned long )(((1L | (1L << 6)) | (1L << 9)) | (1L << 11)),
                        & attr);
    }
#line 562
    if (src == 0UL) {
#line 562
      return (trg);
    }
    {
#line 563
    XGrabServer(Xdisplay);
#line 564
    grabbed = 1;
#line 565
    XMapRaised(Xdisplay, src);
#line 566
    XSync(Xdisplay, 0);
#line 568
    tick_count = 0;
    }
    {
#line 568
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 568
      tmp___0 = XCheckWindowEvent(Xdisplay, src, 1L << 15, & event);
      }
#line 568
      if (tmp___0) {
#line 568
        goto while_break___3;
      } else
#line 568
      if (! (tick_count < 100)) {
#line 568
        goto while_break___3;
      }
      {
#line 569
      sleep_a_little(100);
#line 568
      tick_count ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 571
    if (tick_count < 100) {
#line 573
      if (trg == 0UL) {
        {
#line 573
        trg = XCreatePixmap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                            width + (unsigned int )offset_x, height + (unsigned int )offset_y,
                            (unsigned int )Xdepth);
        }
      }
#line 574
      if (trg != 0UL) {
#line 576
        if (shading) {
          {
#line 579
          img = XGetImage(Xdisplay, src, 0, 0, width, height, (unsigned long )(~ 0L),
                          2);
#line 580
          XDestroyWindow(Xdisplay, src);
#line 581
          src = (Pixmap )0L;
#line 582
          XUngrabServer(Xdisplay);
#line 583
          grabbed = 0;
          }
#line 584
          if ((unsigned long )img != (unsigned long )((void *)0)) {
            {
#line 586
            ShadeXImage(img, shading, gc);
#line 587
            XPutImage(Xdisplay, trg, gc, img, 0, 0, offset_x, offset_y, width, height);
#line 603
            (*(img->f.destroy_image))(img);
            }
          } else
#line 604
          if (my_pixmap) {
            {
#line 607
            XFreePixmap(Xdisplay, trg);
#line 608
            trg = (Pixmap )0L;
            }
          }
        } else {
          {
#line 611
          XCopyArea(Xdisplay, src, trg, gc, 0, 0, width, height, offset_x, offset_y);
          }
        }
      }
    }
#line 615
    if (src) {
      {
#line 616
      XDestroyWindow(Xdisplay, src);
      }
    }
#line 617
    if (grabbed) {
      {
#line 618
      XUngrabServer(Xdisplay);
      }
    }
#line 619
    return (trg);
  }
#line 623
  if ((unsigned int )x + width > src_w) {
#line 623
    goto _L;
  } else
#line 623
  if ((unsigned int )y + height > src_h) {
    _L: /* CIL Label */ 
#line 626
    if (width < src_w) {
#line 626
      width = width;
    } else {
#line 626
      width = src_w;
    }
#line 627
    if (height < src_h) {
#line 627
      height = height;
    } else {
#line 627
      height = src_h;
    }
    {
#line 629
    tmp___1 = XCreatePixmap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                            width, height, (unsigned int )Xdepth);
    }
#line 630
    if (tmp___1 != 0UL) {
      {
#line 632
      ShadeTiledPixmap(src, tmp___1, (int )src_w, (int )src_h, x, y, (int )width,
                       (int )height, gc, shading);
      }
#line 634
      if (trg == 0UL) {
        {
#line 635
        trg = XCreatePixmap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                            width + (unsigned int )offset_x, height + (unsigned int )offset_y,
                            (unsigned int )Xdepth);
        }
      }
#line 636
      if (trg != 0UL) {
        {
#line 637
        XCopyArea(Xdisplay, tmp___1, trg, gc, 0, 0, width, height, offset_x, offset_y);
        }
      }
      {
#line 639
      XFreePixmap(Xdisplay, tmp___1);
      }
#line 640
      return (trg);
    }
  }
#line 645
  if (trg == 0UL) {
    {
#line 645
    trg = XCreatePixmap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                        width + (unsigned int )offset_x, height + (unsigned int )offset_y,
                        (unsigned int )Xdepth);
    }
  }
#line 646
  if (trg != 0UL) {
    {
#line 649
    CopyAndShadeArea(src, trg, x, y, (int )width, (int )height, offset_x, offset_y,
                     gc, shading);
    }
  }
#line 653
  return (trg);
}
}
#line 657 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
Pixmap CutWinPixmap(Window win , Drawable src , int src_w , int src_h , int width ,
                    int height , GC gc , ShadingInfo *shading ) 
{ 
  unsigned int x ;
  unsigned int y ;
  int tmp ;
  Pixmap tmp___0 ;

  {
#line 660
  x = 0U;
#line 660
  y = 0U;
#line 663
  if (src == 0UL) {
#line 668
    if (! (Options & (1UL << 13))) {
#line 669
      return ((Pixmap )0L);
    }
  }
  {
#line 673
  tmp = GetWinPosition(win, (int *)(& x), (int *)(& y));
  }
#line 673
  if (! tmp) {
#line 674
    return ((Pixmap )0L);
  }
  {
#line 676
  tmp___0 = CutPixmap(src, (Pixmap )0L, (int )x, (int )y, (unsigned int )src_w, (unsigned int )src_h,
                      (unsigned int )width, (unsigned int )height, gc, shading);
  }
#line 676
  return (tmp___0);
}
}
#line 680 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int FillPixmapWithTile(Pixmap pixmap , Pixmap tile , int x , int y , int width , int height ,
                       int tile_x , int tile_y ) 
{ 
  GC gc ;
  XGCValues gcv ;

  {
#line 683
  if (tile != 0UL) {
#line 683
    if (pixmap != 0UL) {
      {
#line 688
      gcv.tile = tile;
#line 689
      gcv.fill_style = 1;
#line 690
      gcv.ts_x_origin = - tile_x;
#line 691
      gcv.ts_y_origin = - tile_y;
#line 692
      gc = XCreateGC(Xdisplay, tile, (unsigned long )((((1L << 8) | (1L << 10)) | (1L << 12)) | (1L << 13)),
                     & gcv);
#line 696
      XFillRectangle(Xdisplay, pixmap, gc, x, y, (unsigned int )width, (unsigned int )height);
#line 697
      XFreeGC(Xdisplay, gc);
      }
#line 698
      return (1);
    }
  }
#line 700
  return (0);
}
}
#line 712 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void FreeTargetPixmap(void) 
{ 


  {
#line 714
  if (TermWin.background.trgPixmap != 0UL) {
    {
#line 716
    XFreePixmap(Xdisplay, TermWin.background.trgPixmap);
#line 717
    TermWin.background.trgPixmap = (Pixmap )0L;
    }
  }
#line 719
  return;
}
}
#line 723 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void SetSrcPixmap(Pixmap p ) 
{ 
  Window root ;
  unsigned int dum ;
  unsigned int w ;
  unsigned int h ;
  int dummy ;
  int tmp ;

  {
#line 730
  if (TermWin.background.srcPixmap != 0UL) {
#line 730
    if (TermWin.background.bMySource) {
#line 730
      if (TermWin.background.srcPixmap != p) {
        {
#line 732
        XFreePixmap(Xdisplay, TermWin.background.srcPixmap);
#line 733
        TermWin.background.srcPixmap = p;
#line 734
        TermWin.background.bMySource = 0;
        }
      }
    }
  }
#line 737
  TermWin.background.srcPixmap = p;
#line 739
  TermWin.background.Width = 0;
#line 740
  TermWin.background.Height = 0;
#line 742
  if (TermWin.background.srcPixmap != 0UL) {
    {
#line 750
    tmp = XGetGeometry(Xdisplay, TermWin.background.srcPixmap, & root, & dummy, & dummy,
                       & w, & h, & dum, & dum);
    }
#line 750
    if (tmp) {
#line 752
      TermWin.background.Width = (int )w;
#line 753
      TermWin.background.Height = (int )h;
    } else {
#line 762
      TermWin.background.srcPixmap = (Pixmap )0L;
    }
  }
#line 765
  return;
}
}
#line 768 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void ValidateSrcPixmap(int bSetHandler ) 
{ 
  Pixmap new_p ;
  int tmp ;

  {
#line 772
  if (! TermWin.background.bMySource) {
#line 776
    if (Options & (1UL << 13)) {
#line 776
      if ((unsigned int )TermWin.background.trgType != 10U) {
#line 776
        tmp = 1;
      } else {
#line 776
        tmp = 0;
      }
    } else {
#line 776
      tmp = 0;
    }
    {
#line 776
    new_p = ValidatePixmap(TermWin.background.srcPixmap, bSetHandler, tmp, (unsigned int *)((void *)0),
                           (unsigned int *)((void *)0));
    }
#line 781
    if (new_p != TermWin.background.srcPixmap) {
      {
#line 781
      SetSrcPixmap(new_p);
      }
    }
  }
#line 783
  return;
}
}
#line 788 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int GetMyPosition(int *x , int *y ) 
{ 
  int bRet ;
  int (*old)(Display * , XErrorEvent * ) ;
  XErrorHandler tmp ;

  {
  {
#line 791
  bRet = 0;
#line 792
  tmp = XSetErrorHandler(& pixmap_error_handler);
#line 792
  old = tmp;
#line 794
  bRet = GetWinPosition(TermWin.vt, x, y);
#line 795
  XSetErrorHandler(old);
  }
#line 797
  return (bRet);
}
}
#line 801 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int IsTransparentPixmap(void) 
{ 


  {
#line 809
  if (Options & (1UL << 13)) {
#line 809
    if ((unsigned int )TermWin.background.trgType != 10U) {
#line 810
      return (1);
    }
  }
#line 812
  return (0);
}
}
#line 816 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
int TransparentPixmapNeedsUpdate(void) 
{ 
  int tmp ;

  {
  {
#line 822
  tmp = IsTransparentPixmap();
  }
#line 822
  if (! tmp) {
#line 823
    return (0);
  }
#line 828
  if (ExtWM.current_desktop != ExtWM.aterm_desktop) {
#line 828
    if (ExtWM.aterm_desktop != 4294967295U) {
#line 828
      if (ExtWM.flags & 1UL) {
#line 828
        if (! (ExtWM.flags & (unsigned long )(1 << 1))) {
#line 830
          return (0);
        }
      }
    }
  }
#line 832
  if (ExtWM.flags & (unsigned long )((1 << 2) | (1 << 3))) {
#line 833
    return (0);
  }
#line 839
  if (TermWin.LastPixmapUsed == TermWin.background.srcPixmap) {
#line 839
    if (TermWin.LastPixmap_root_x == TermWin.root_x) {
#line 839
      if (TermWin.LastPixmap_root_y == TermWin.root_y) {
#line 839
        if (TermWin.LastPixmap_width == TermWin.root_width) {
#line 839
          if (TermWin.LastPixmap_height == TermWin.root_height) {
#line 844
            return (0);
          }
        }
      }
    }
  }
#line 848
  if (TermWin.root_x + TermWin.root_width <= 0) {
#line 850
    return (0);
  } else
#line 848
  if (TermWin.root_y + TermWin.root_height <= 0) {
#line 850
    return (0);
  } else
#line 848
  if (TermWin.root_x >= XdisplayWidth) {
#line 850
    return (0);
  } else
#line 848
  if (TermWin.root_y >= XdisplayHeight) {
#line 850
    return (0);
  }
#line 855
  return (1);
}
}
#line 900 "/home/june/collector/temp/aterm-1.0.1/src/pixmap.c"
void RenderPixmap(int DontCheckSource ) 
{ 
  XGCValues gcvalue ;
  GC gc ;
  int width ;
  int height ;
  unsigned int fin_width ;
  unsigned int fin_height ;
  int (*oldXErrorHandler)(Display * , XErrorEvent * ) ;
  int tmp ;
  ShadingInfo *tmp___0 ;
  ShadingInfo *tmp___1 ;

  {
  {
#line 905
  width = (int )TermWin.width + 2 * TermWin_internalBorder;
#line 906
  height = (int )TermWin.height + 2 * TermWin_internalBorder;
#line 910
  set_background_updated();
#line 914
  oldXErrorHandler = XSetErrorHandler(& pixmap_error_handler);
  }
#line 919
  if (! DontCheckSource) {
    {
#line 919
    ValidateSrcPixmap(0);
    }
  }
  {
#line 921
  tmp = IsTransparentPixmap();
  }
#line 921
  if (tmp) {
#line 923
    if (ExtWM.current_desktop != ExtWM.aterm_desktop) {
#line 923
      if (ExtWM.flags & 1UL) {
        {
#line 926
        XSetErrorHandler(oldXErrorHandler);
        }
#line 927
        return;
      }
    }
  }
#line 933
  if (TermWin.background.srcPixmap == 0UL) {
#line 940
    if (! (Options & (1UL << 13))) {
      {
#line 943
      XSetErrorHandler(oldXErrorHandler);
      }
#line 944
      return;
    } else
#line 940
    if ((unsigned int )TermWin.background.trgType == 10U) {
      {
#line 943
      XSetErrorHandler(oldXErrorHandler);
      }
#line 944
      return;
    }
#line 946
    if (DontCheckSource) {
      {
#line 947
      ValidateSrcPixmap(0);
      }
    }
  }
  {
#line 951
  fin_width = (unsigned int )width;
#line 952
  fin_height = (unsigned int )height;
#line 955
  gcvalue.foreground = *(PixColors + 1);
#line 959
  gc = XCreateGC(Xdisplay, TermWin.vt, (unsigned long )(1L << 2), & gcvalue);
  }
#line 965
  if (TermWin.background.trgPixmap != TermWin.background.srcPixmap) {
    {
#line 966
    FreeTargetPixmap();
    }
  }
#line 970
  if ((unsigned int )TermWin.background.trgType == 1U) {
#line 972
    if (TermWin.background.bMySource) {
#line 974
      TermWin.background.trgPixmap = TermWin.background.srcPixmap;
#line 975
      fin_width = (unsigned int )TermWin.background.Width;
#line 976
      fin_height = (unsigned int )TermWin.background.Height;
    } else
#line 972
    if (TermWin.background.Shading.shading == 100) {
#line 972
      if ((int )TermWin.background.Shading.tintColor.red == 65535) {
#line 972
        if ((int )TermWin.background.Shading.tintColor.green == 65535) {
#line 972
          if ((int )TermWin.background.Shading.tintColor.blue == 65535) {
#line 974
            TermWin.background.trgPixmap = TermWin.background.srcPixmap;
#line 975
            fin_width = (unsigned int )TermWin.background.Width;
#line 976
            fin_height = (unsigned int )TermWin.background.Height;
          } else {
#line 972
            goto _L___3;
          }
        } else {
#line 972
          goto _L___3;
        }
      } else {
#line 972
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 977
    if (TermWin.background.finWidth != width) {
#line 977
      goto _L___0;
    } else
#line 977
    if (TermWin.background.finHeight != height) {
      _L___0: /* CIL Label */ 
#line 977
      if (TermWin.background.Width != TermWin.background.finWidth) {
#line 977
        goto _L;
      } else
#line 977
      if (TermWin.background.Height != TermWin.background.finHeight) {
        _L: /* CIL Label */ 
#line 980
        if (TermWin.background.Width < width) {
#line 980
          fin_width = (unsigned int )TermWin.background.Width;
        } else {
#line 980
          fin_width = (unsigned int )width;
        }
#line 981
        if (TermWin.background.Height < height) {
#line 981
          fin_height = (unsigned int )TermWin.background.Height;
        } else {
#line 981
          fin_height = (unsigned int )height;
        }
#line 982
        if (TermWin.background.bMySource) {
#line 982
          tmp___0 = (ShadingInfo *)((void *)0);
        } else {
#line 982
          tmp___0 = & TermWin.background.Shading;
        }
        {
#line 982
        TermWin.background.trgPixmap = ShadePixmap(TermWin.background.srcPixmap, 0,
                                                   0, (int )fin_width, (int )fin_height,
                                                   gc, tmp___0);
        }
      }
    }
  } else
#line 1027
  if ((unsigned int )TermWin.background.trgType == 9U) {
#line 1032
    if (TermWin.background.bMySource) {
#line 1032
      tmp___1 = (ShadingInfo *)((void *)0);
    } else {
#line 1032
      tmp___1 = & TermWin.background.Shading;
    }
    {
#line 1032
    TermWin.background.trgPixmap = CutWinPixmap(TermWin.vt, TermWin.background.srcPixmap,
                                                TermWin.background.Width, TermWin.background.Height,
                                                width, height, gc, tmp___1);
    }
  }
  {
#line 1055
  XFreeGC(Xdisplay, gc);
  }
#line 1056
  if (TermWin.background.trgPixmap != 0UL) {
    {
#line 1058
    TermWin.background.finWidth = (int )fin_width;
#line 1059
    TermWin.background.finHeight = (int )fin_height;
#line 1060
    XSync(Xdisplay, 0);
#line 1064
    XSetWindowBackgroundPixmap(Xdisplay, TermWin.vt, TermWin.background.trgPixmap);
#line 1066
    XSync(Xdisplay, 0);
#line 1067
    TermWin.LastPixmapUsed = TermWin.background.srcPixmap;
#line 1068
    TermWin.LastPixmap_root_x = TermWin.root_x;
#line 1069
    TermWin.LastPixmap_root_y = TermWin.root_y;
#line 1070
    TermWin.LastPixmap_width = TermWin.root_width;
#line 1071
    TermWin.LastPixmap_height = TermWin.root_height;
#line 1072
    TermWin.background.trgPixmapSet = 1;
    }
#line 1075
    if (TermWin.background.trgPixmap != TermWin.background.srcPixmap) {
      {
#line 1077
      XFreePixmap(Xdisplay, TermWin.background.trgPixmap);
#line 1078
      XSync(Xdisplay, 0);
      }
    }
#line 1080
    TermWin.background.trgPixmap = (Pixmap )0L;
  }
  {
#line 1083
  XSetErrorHandler(oldXErrorHandler);
  }
#line 1085
  return;
}
}
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/rmemset.pro"
void rmemset(void *p , unsigned char c , R_int_p_t len ) ;
#line 45 "/home/june/collector/temp/aterm-1.0.1/src/rmemset.c"
void rmemset(void *p , unsigned char c , R_int_p_t len ) 
{ 
  R_u_int_p_t i ;
  R_u_int_p_t val ;
  R_u_int_p_t *rp ;
  unsigned char *lp ;
  unsigned char *tmp ;
  R_u_int_p_t tmp___0 ;
  R_u_int_p_t *tmp___1 ;
  R_u_int_p_t tmp___2 ;
  unsigned char *tmp___3 ;
  R_int_p_t tmp___4 ;

  {
#line 51
  if (len < 16L) {
#line 52
    lp = (unsigned char *)p;
  } else {
#line 55
    i = - ((R_u_int_p_t )p) & 7UL;
#line 55
    if (i == 0UL) {
#line 56
      rp = (R_u_int_p_t *)p;
    } else {
#line 58
      len = (R_int_p_t )((R_u_int_p_t )len - i);
#line 59
      lp = (unsigned char *)p;
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        tmp___0 = i;
#line 59
        i --;
#line 59
        if (! tmp___0) {
#line 59
          goto while_break;
        }
#line 60
        tmp = lp;
#line 60
        lp ++;
#line 60
        *tmp = c;
      }
      while_break: /* CIL Label */ ;
      }
#line 61
      rp = (R_u_int_p_t *)((R_int_p_t *)lp);
    }
#line 65
    val = (R_u_int_p_t )(((int )c << 8) + (int )c);
#line 67
    val |= val << 16;
#line 70
    val |= val << 32;
#line 75
    i = (R_u_int_p_t )(len / 8L);
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 75
      tmp___2 = i;
#line 75
      i --;
#line 75
      if (! tmp___2) {
#line 75
        goto while_break___0;
      }
#line 76
      tmp___1 = rp;
#line 76
      rp ++;
#line 76
      *tmp___1 = val;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 77
    len &= 7L;
#line 78
    lp = (unsigned char *)rp;
  }
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    tmp___4 = len;
#line 81
    len --;
#line 81
    if (! tmp___4) {
#line 81
      goto while_break___1;
    }
#line 82
    tmp___3 = lp;
#line 82
    lp ++;
#line 82
    *tmp___3 = c;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 10 "/home/june/collector/temp/aterm-1.0.1/src/thai.h"
char thai_map[256]  = 
#line 10 "/home/june/collector/temp/aterm-1.0.1/src/thai.h"
  {      (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)0,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)-1,      (char)-1,      (char)-1,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 924
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 944
extern int getpt(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 1435 "/usr/include/X11/Xlib.h"
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2578
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3029
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 3079
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 3565
extern char *XSetLocaleModifiers(char const   * ) ;
#line 3838
extern XIM XOpenIM(Display * , struct _XrmHashBucketRec * , char * , char * ) ;
#line 3845
extern int XCloseIM(XIM  ) ;
#line 3849
extern char *XGetIMValues(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3865
extern XIC XCreateIC(XIM   , ...)  __attribute__((__sentinel__(0))) ;
#line 3873
extern void XSetICFocus(XIC  ) ;
#line 3877
extern void XUnsetICFocus(XIC  ) ;
#line 3905
extern int XFilterEvent(XEvent * , Window  ) ;
#line 3910
extern int XmbLookupString(XIC  , XKeyPressedEvent * , char * , int  , KeySym * ,
                           int * ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 169 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom _XA_NET_SUPPORTING_WM_CHECK ;
#line 171
Atom _XA_NET_CURRENT_DESKTOP ;
#line 172
Atom _XA_NET_WM_DESKTOP ;
#line 173
Atom _XA_NET_WM_STATE ;
#line 999
Window ParentWin[3] ;
#line 1000
int ParentWinNum ;
#line 1008
scrollBar_t scrollBar ;
#line 1036
char const   *rs_name ;
#line 1039
Pixel PixColorsFocused[29] ;
#line 1041
Pixel PixColorsUnFocused[29] ;
#line 1047
char const   *rs_title ;
#line 1059
char const   *rs_modifier ;
#line 1062
char const   *rs_backspace_key ;
#line 1065
char const   *rs_delete_key ;
#line 1085
unsigned char const   *KeySym_map[256] ;
#line 1105
char const   *rs_fade ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/command.pro"
void request_background_update(void) ;
#line 2
void cancel_background_update(void) ;
#line 5
void privileges(int mode ) ;
#line 6
void Child_signal(int unused ) ;
#line 7
void Exit_signal(int sig ) ;
#line 8
void clean_exit(void) ;
#line 9
int get_pty(void) ;
#line 10
int get_tty(void) ;
#line 12
void get_ttymode(ttymode_t *tio ) ;
#line 13
int run_command(char **argv ) ;
#line 14
void init_command(char **argv ) ;
#line 15
void init_xlocale(void) ;
#line 16
void tt_winsize(int fd ) ;
#line 17
void tt_resize(void) ;
#line 18
void lookup_key(XEvent *ev ) ;
#line 20
unsigned char cmd_getc(void) ;
#line 21
void mouse_report(XButtonEvent *ev ) ;
#line 22
void process_x_event(XEvent *ev ) ;
#line 23
void tt_printf(unsigned char const   *fmt  , ...) ;
#line 27
void process_escape_seq(void) ;
#line 28
void process_csi_seq(void) ;
#line 29
void process_xterm_seq(void) ;
#line 30
void process_terminal_mode(int mode , int priv , unsigned int nargs , int *arg ) ;
#line 31
void process_sgr_mode(unsigned int nargs , int *arg ) ;
#line 32
void process_graphics(void) ;
#line 33
void main_loop(void) ;
#line 34
void tt_write(unsigned char const   *d , int len ) ;
#line 8 "/home/june/collector/temp/aterm-1.0.1/src/graphics.pro"
void Gr_ButtonReport(int but , int x , int y ) ;
#line 13
void Gr_expose(Window win ) ;
#line 10 "/home/june/collector/temp/aterm-1.0.1/src/main.pro"
void set_width(unsigned short width ) ;
#line 11
void resize_window(XEvent *ev ) ;
#line 15
void xterm_seq(int op , char const   *str ) ;
#line 17
void change_font(int init , char const   *fontname ) ;
#line 20
int read_32bit_property(Window w , Atom property , CARD32 *trg ) ;
#line 22
int check_extended_wm_state(void) ;
#line 23
void check_extended_wm_hints_support(void) ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/misc.pro"
char const   *my_basename(char const   *str ) ;
#line 2
void print_error(char const   *fmt  , ...) ;
#line 4 "/home/june/collector/temp/aterm-1.0.1/src/screen.pro"
void scr_release(void) ;
#line 5
void scr_poweron(void) ;
#line 6
void scr_cursor(int mode ) ;
#line 7
int scr_change_screen(int scrn ) ;
#line 8
void scr_color(unsigned int color , unsigned int Intensity ) ;
#line 9
void scr_rendition(int set , int style ) ;
#line 11
void scr_add_lines(unsigned char const   *str , int nlines , int len ) ;
#line 12
void scr_backspace(void) ;
#line 13
void scr_tab(int count ) ;
#line 14
void scr_gotorc(int row , int col , int relative ) ;
#line 15
void scr_index(int direction ) ;
#line 16
void scr_erase_line(int mode ) ;
#line 17
void scr_erase_screen(int mode ) ;
#line 18
void scr_E(void) ;
#line 19
void scr_insdel_lines(int count , int insdel ) ;
#line 20
void scr_insdel_chars(int count , int insdel ) ;
#line 21
void scr_scroll_region(int top , int bot ) ;
#line 22
void scr_cursor_visible(int mode ) ;
#line 23
void scr_autowrap(int mode ) ;
#line 24
void scr_relative_origin(int mode ) ;
#line 25
void scr_insert_mode(int mode ) ;
#line 26
void scr_set_tab(int mode ) ;
#line 27
void scr_rvideo_mode(int mode ) ;
#line 28
void scr_report_position(void) ;
#line 30
void scr_charset_choose(int set ) ;
#line 31
void scr_charset_set(int set , unsigned int ch ) ;
#line 38
void scr_expose(int x , int y , int width , int height ) ;
#line 39
void scr_touch(void) ;
#line 40
int scr_move_to(int y , int len ) ;
#line 41
int scr_page(int direction , int nlines ) ;
#line 42
void scr_bell(void) ;
#line 44
void scr_refresh(int type ) ;
#line 45
void scr_clear_tint(int bWithTinting ) ;
#line 46
void on_colors_changed(int idx ) ;
#line 50
void selection_paste(Window win , unsigned int prop , int Delete ) ;
#line 51
void selection_request(Time tm , int x , int y ) ;
#line 52
void selection_clear(void) ;
#line 53
void selection_make(Time tm , unsigned int key_state ) ;
#line 54
void selection_click(int clicks , int x , int y ) ;
#line 57
void selection_extend(int x , int y , int flag ) ;
#line 59
void selection_rotate(int x , int y ) ;
#line 60
void selection_send(XSelectionRequestEvent *rq ) ;
#line 61
void pixel_position(int *x , int *y ) ;
#line 3 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.pro"
int scrollbar_show(int update ) ;
#line 4
void refresh_transparent_scrollbar(void) ;
#line 5
void map_scrollBar(int map ) ;
#line 100 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned int ModMetaMask  ;
#line 100 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned int ModNumLockMask  ;
#line 103 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *v_buffer  ;
#line 104 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *v_bufstr  =    (char *)((void *)0);
#line 105 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *v_bufptr  ;
#line 106 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *v_bufend  ;
#line 110 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static time_t last_update_background_request_sec  =    (time_t )0;
#line 111 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static time_t last_update_background_request_usec  =    (time_t )0;
#line 112 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int first_background_update  =    1;
#line 115 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static void timer_get_time(time_t *sec , time_t *usec ) 
{ 
  struct timeval tv ;

  {
  {
#line 120
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 121
  *sec = tv.tv_sec;
#line 122
  *usec = tv.tv_usec;
  }
#line 123
  return;
}
}
#line 127 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void request_background_update(void) 
{ 
  int repetitive ;
  int tmp ;

  {
  {
#line 130
  repetitive = last_update_background_request_sec != 0L;
#line 131
  timer_get_time(& last_update_background_request_sec, & last_update_background_request_usec);
  }
#line 132
  if (first_background_update) {
#line 134
    last_update_background_request_usec += 5000L;
  } else {
#line 136
    if (repetitive) {
#line 136
      tmp = 350000;
    } else {
#line 136
      tmp = 700000;
    }
#line 136
    last_update_background_request_usec += (time_t )tmp;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (last_update_background_request_usec > 1000000L)) {
#line 137
      goto while_break;
    }
#line 139
    last_update_background_request_sec ++;
#line 140
    last_update_background_request_usec -= 1000000L;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 148 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void cancel_background_update(void) 
{ 


  {
#line 151
  last_update_background_request_sec = (time_t )0;
#line 155
  return;
}
}
#line 158 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void set_background_updated(void) 
{ 


  {
#line 161
  first_background_update = 0;
#line 162
  last_update_background_request_sec = (time_t )0;
#line 166
  return;
}
}
#line 169
void get_ourmods(void) ;
#line 326 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *ptydev  =    (char *)((void *)0);
#line 326 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *ttydev  =    (char *)((void *)0);
#line 327 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int cmd_fd  =    -1;
#line 328 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static pid_t cmd_pid  =    -1;
#line 329 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int Xfd  =    -1;
#line 330 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned int num_fds  =    0U;
#line 331 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static struct stat ttyfd_stat  ;
#line 334 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int scroll_arrow_delay  ;
#line 338 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char meta_char  =    (unsigned char)27;
#line 340 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned int ModXMask  =    (unsigned int )(1 << 3);
#line 371 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned long PrivateModes  =    (((1UL << 5) | (1UL << 7)) | (1UL << 10)) | (1UL << 11);
#line 372 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned long SavedModes  =    (((1UL << 5) | (1UL << 7)) | (1UL << 10)) | (1UL << 11);
#line 376 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int refresh_count  =    0;
#line 376 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int refresh_limit  =    1;
#line 376 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int refresh_type  =    1 << 2;
#line 379 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static Atom wmDeleteWindow  ;
#line 390 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *rs_inputMethod  =    (char *)"";
#line 391 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static char *rs_preeditType  =    (char *)((void *)0);
#line 392 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static XIC Input_Context  ;
#line 400 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char cmdbuf_base[8192]  ;
#line 400 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char *cmdbuf_ptr  ;
#line 400 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char *cmdbuf_endp  ;
#line 429 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static uid_t euid  ;
#line 430 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static gid_t egid  ;
#line 425 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void privileges(int mode ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 433
  if (mode == 0) {
#line 433
    goto case_0;
  }
#line 442
  if (mode == 115) {
#line 442
    goto case_115;
  }
#line 447
  if (mode == 114) {
#line 447
    goto case_114;
  }
#line 432
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 438
  tmp = getuid();
#line 438
  seteuid(tmp);
#line 439
  tmp___0 = getgid();
#line 439
  setegid(tmp___0);
  }
#line 440
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 443
  euid = geteuid();
#line 444
  egid = getegid();
  }
#line 445
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 448
  seteuid(euid);
#line 449
  setegid(egid);
  }
#line 450
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 467
  return;
}
}
#line 476 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void Child_signal(int unused ) 
{ 
  int pid ;
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 479
  tmp = __errno_location();
#line 479
  save_errno = *tmp;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 482
    tmp___0 = __errno_location();
#line 482
    *tmp___0 = 0;
#line 481
    pid = waitpid(-1, (int *)((void *)0), 1);
    }
#line 481
    if (-1 == pid) {
      {
#line 481
      tmp___1 = __errno_location();
      }
#line 481
      if (! (*tmp___1 == 4)) {
#line 481
        goto while_break;
      }
    } else {
#line 481
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  if (pid == cmd_pid) {
    {
#line 488
    exit(0);
    }
  }
  {
#line 489
  tmp___2 = __errno_location();
#line 489
  *tmp___2 = save_errno;
#line 491
  signal(17, & Child_signal);
  }
#line 492
  return;
}
}
#line 498 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void Exit_signal(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 504
  signal(sig, (void (*)(int  ))0);
#line 512
  tmp = getpid();
#line 512
  kill(tmp, sig);
  }
#line 513
  return;
}
}
#line 520 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void clean_exit(void) 
{ 


  {
  {
#line 527
  scr_release();
#line 528
  privileges('r');
#line 530
  chmod((char const   *)ttydev, ttyfd_stat.st_mode);
#line 531
  chown((char const   *)ttydev, ttyfd_stat.st_uid, ttyfd_stat.st_gid);
#line 536
  privileges(0);
  }
#line 537
  return;
}
}
#line 550 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
int get_pty(void) 
{ 
  int fd ;

  {
  {
#line 553
  fd = -1;
#line 565
  fd = getpt();
  }
#line 565
  if (fd < 0) {
#line 569
    goto Failed;
  } else {
    {
#line 571
    grantpt(fd);
#line 572
    unlockpt(fd);
#line 573
    ttydev = ptsname(fd);
#line 573
    ptydev = ttydev;
    }
#line 574
    goto Found;
  }
  Found: 
  {
#line 633
  fcntl(fd, 4, 2048);
  }
#line 634
  return (fd);
  Failed: 
  {
#line 637
  print_error("can\'t open pseudo-tty");
  }
#line 638
  return (-1);
}
}
#line 648 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
int get_tty(void) 
{ 
  int fd ;
  pid_t pid ;
  int i ;
  int tmp ;

  {
  {
#line 662
  pid = setsid();
  }
#line 664
  if (pid < 0) {
    {
#line 665
    perror(rs_name);
    }
  }
  {
#line 671
  fd = open((char const   *)ttydev, 2);
  }
#line 671
  if (fd < 0) {
    {
#line 672
    print_error("can\'t open slave tty %s", ttydev);
#line 673
    exit(1);
    }
  }
  {
#line 682
  ioctl(fd, (unsigned long )((83 << 8) | 2), "ptem");
#line 683
  ioctl(fd, (unsigned long )((83 << 8) | 2), "ldterm");
#line 684
  ioctl(fd, (unsigned long )((83 << 8) | 2), "ttcompat");
#line 720
  i = 0;
  }
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! ((unsigned int )i < num_fds)) {
#line 720
      goto while_break;
    }
#line 721
    if (i != fd) {
      {
#line 722
      close(i);
      }
    }
#line 720
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 726
  dup(fd);
#line 727
  dup(fd);
#line 728
  dup(fd);
  }
#line 730
  if (fd > 2) {
    {
#line 731
    close(fd);
    }
  }
  {
#line 746
  ioctl(0, 21518UL, 0);
#line 751
  tcsetpgrp(0, pid);
#line 759
  tmp = open((char const   *)ttydev, 2, 0);
#line 759
  close(tmp);
#line 763
  privileges(0);
  }
#line 765
  return (fd);
}
}
#line 853 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void get_ttymode(ttymode_t *tio ) 
{ 
  int tmp ;

  {
  {
#line 860
  tmp = tcgetattr(0, tio);
  }
#line 860
  if (tmp < 0) {
#line 862
    tio->c_cc[0] = (cc_t )3;
#line 863
    tio->c_cc[1] = (cc_t )28;
#line 864
    tio->c_cc[2] = (cc_t )127;
#line 865
    tio->c_cc[3] = (cc_t )21;
#line 866
    tio->c_cc[8] = (cc_t )17;
#line 867
    tio->c_cc[9] = (cc_t )19;
#line 868
    tio->c_cc[10] = (cc_t )26;
#line 873
    tio->c_cc[12] = (cc_t )18;
#line 876
    tio->c_cc[13] = (cc_t )15;
#line 879
    tio->c_cc[14] = (cc_t )23;
#line 882
    tio->c_cc[15] = (cc_t )22;
  }
#line 885
  tio->c_cc[4] = (cc_t )4;
#line 886
  tio->c_cc[11] = (cc_t )'\000';
#line 888
  tio->c_cc[16] = (cc_t )'\000';
#line 891
  tio->c_cc[7] = (cc_t )'\000';
#line 897
  tio->c_cc[6] = (cc_t )1;
#line 900
  tio->c_cc[5] = (cc_t )0;
#line 904
  tio->c_iflag = (tcflag_t )9478;
#line 911
  tio->c_oflag = (tcflag_t )5;
#line 914
  tio->c_cflag = (tcflag_t )176;
#line 917
  tio->c_lflag = (tcflag_t )35387;
#line 988
  return;
}
}
#line 998 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
int run_command(char **argv ) 
{ 
  ttymode_t tio ;
  int ptyfd ;
  unsigned int on ;
  char const   *argv0 ;
  char const   *shell ;
  char *tmp ;
  char *p ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1004
  ptyfd = get_pty();
  }
#line 1005
  if (ptyfd < 0) {
#line 1006
    return (-1);
  }
  {
#line 1009
  lstat((char const   */* __restrict  */)ttydev, (struct stat */* __restrict  */)(& ttyfd_stat));
#line 1017
  atexit(& clean_exit);
#line 1032
  get_ttymode(& tio);
  }
#line 1039
  if (scrollBar.state) {
#line 1040
    PrivateModes |= 1UL << 14;
#line 1041
    SavedModes |= 1UL << 14;
  }
  {
#line 1052
  signal(1, & Exit_signal);
#line 1054
  signal(2, & Exit_signal);
#line 1056
  signal(3, & Exit_signal);
#line 1057
  signal(15, & Exit_signal);
#line 1058
  signal(17, & Child_signal);
#line 1061
  tt_winsize(ptyfd);
#line 1066
  cmd_pid = fork();
  }
#line 1067
  if (cmd_pid < 0) {
    {
#line 1068
    print_error("can\'t fork");
    }
#line 1069
    return (-1);
  }
#line 1071
  if (cmd_pid == 0) {
    {
#line 1076
    unsetenv("LINES");
#line 1077
    unsetenv("COLUMNS");
#line 1079
    unsetenv("TERMCAP");
#line 1082
    get_tty();
#line 1085
    cfsetospeed(& tio, (speed_t )15);
#line 1085
    cfsetispeed(& tio, (speed_t )15);
#line 1085
    tcsetattr(0, 0, (struct termios  const  *)(& tio));
    }
#line 1088
    if (Options & 1UL) {
      {
#line 1090
      on = 1U;
#line 1092
      ioctl(0, 21533UL, & on);
      }
    }
    {
#line 1103
    tt_winsize(0);
#line 1106
    signal(2, (void (*)(int  ))0);
#line 1107
    signal(3, (void (*)(int  ))0);
#line 1108
    signal(17, (void (*)(int  ))0);
#line 1114
    signal(20, (void (*)(int  ))1);
#line 1115
    signal(21, (void (*)(int  ))1);
#line 1116
    signal(22, (void (*)(int  ))1);
    }
#line 1126
    if ((unsigned long )argv != (unsigned long )((void *)0)) {
      {
#line 1133
      execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 1134
      print_error("can\'t execute \"%s\"", *(argv + 0));
      }
    } else {
      {
#line 1138
      tmp = getenv("SHELL");
#line 1138
      shell = (char const   *)tmp;
      }
#line 1138
      if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1139
        shell = "/bin/bash";
      } else
#line 1138
      if ((int const   )*shell == 0) {
#line 1139
        shell = "/bin/bash";
      }
      {
#line 1141
      argv0 = my_basename(shell);
      }
#line 1142
      if (Options & (1UL << 1)) {
        {
#line 1143
        tmp___0 = strlen(argv0);
#line 1143
        tmp___1 = malloc((tmp___0 + 2UL) * sizeof(char ));
#line 1143
        p = (char *)tmp___1;
#line 1145
        *(p + 0) = (char )'-';
#line 1146
        strcpy((char */* __restrict  */)(p + 1), (char const   */* __restrict  */)((char *)argv0));
#line 1147
        argv0 = (char const   *)p;
        }
      }
      {
#line 1149
      execlp(shell, argv0, (void *)0);
#line 1150
      print_error("can\'t execute \"%s\"", shell);
      }
    }
    {
#line 1152
    exit(1);
    }
  }
#line 1161
  return (ptyfd);
}
}
#line 1169 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void get_ourmods(void) 
{ 
  int i ;
  int j ;
  int k ;
  int got_meta ;
  int got_numlock ;
  XModifierKeymap *map ;
  KeyCode *kc ;
  unsigned int modmasks[5] ;
  KeySym __attribute__((__deprecated__))  tmp ;

  {
  {
#line 1176
  modmasks[0] = (unsigned int )(1 << 3);
#line 1176
  modmasks[1] = (unsigned int )(1 << 4);
#line 1176
  modmasks[2] = (unsigned int )(1 << 5);
#line 1176
  modmasks[3] = (unsigned int )(1 << 6);
#line 1176
  modmasks[4] = (unsigned int )(1 << 7);
#line 1179
  got_numlock = 0;
#line 1179
  got_meta = got_numlock;
#line 1180
  map = XGetModifierMapping(Xdisplay);
#line 1181
  kc = map->modifiermap;
#line 1182
  i = 3;
  }
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1182
    if (! (i < 8)) {
#line 1182
      goto while_break;
    }
#line 1183
    k = i * map->max_keypermod;
#line 1184
    j = 0;
    {
#line 1184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1184
      if (! (j < map->max_keypermod)) {
#line 1184
        goto while_break___0;
      }
#line 1185
      if ((int )*(kc + k) == 0) {
#line 1186
        goto while_break___0;
      }
      {
#line 1187
      tmp = XKeycodeToKeysym(Xdisplay, *(kc + k), 0);
      }
      {
#line 1188
      if (tmp == (KeySym __attribute__((__deprecated__))  )65407) {
#line 1188
        goto case_65407;
      }
#line 1197
      if (tmp == (KeySym __attribute__((__deprecated__))  )65514) {
#line 1197
        goto case_65514;
      }
#line 1197
      if (tmp == (KeySym __attribute__((__deprecated__))  )65513) {
#line 1197
        goto case_65514;
      }
#line 1197
      if (tmp == (KeySym __attribute__((__deprecated__))  )65512) {
#line 1197
        goto case_65514;
      }
#line 1197
      if (tmp == (KeySym __attribute__((__deprecated__))  )65511) {
#line 1197
        goto case_65514;
      }
#line 1187
      goto switch_break;
      case_65407: /* CIL Label */ 
#line 1189
      if (! got_numlock) {
#line 1190
        ModNumLockMask = modmasks[i - 3];
#line 1191
        got_numlock = 1;
      }
#line 1193
      goto switch_break;
      case_65514: /* CIL Label */ 
      case_65513: /* CIL Label */ 
      case_65512: /* CIL Label */ 
      case_65511: /* CIL Label */ 
#line 1198
      if (! got_meta) {
#line 1199
        ModMetaMask = modmasks[i - 3];
#line 1200
        got_meta = 1;
      }
#line 1202
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1184
      j ++;
#line 1184
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1205
    if (got_meta) {
#line 1205
      if (got_numlock) {
#line 1206
        goto while_break;
      }
    }
#line 1182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1208
  XFreeModifiermap(map);
  }
#line 1209
  return;
}
}
#line 1214 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void init_command(char **argv ) 
{ 
  long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1223
  wmDeleteWindow = XInternAtom(Xdisplay, "WM_DELETE_WINDOW", 0);
#line 1224
  XSetWMProtocols(Xdisplay, TermWin.parent, & wmDeleteWindow, 1);
#line 1233
  init_xlocale();
#line 1245
  tmp = sysconf(4);
#line 1245
  num_fds = (unsigned int )tmp;
  }
#line 1251
  if (Options & (1UL << 10)) {
#line 1251
    meta_char = (unsigned char)128;
  } else {
#line 1251
    meta_char = (unsigned char)27;
  }
#line 1252
  if (rs_modifier) {
    {
#line 1252
    tmp___0 = strlen(rs_modifier);
    }
#line 1252
    if (tmp___0 == 4UL) {
      {
#line 1252
      tmp___1 = toupper((int )*rs_modifier);
      }
#line 1252
      if (tmp___1 == 77) {
        {
#line 1252
        tmp___2 = toupper((int )*(rs_modifier + 1));
        }
#line 1252
        if (tmp___2 == 79) {
          {
#line 1252
          tmp___3 = toupper((int )*(rs_modifier + 2));
          }
#line 1252
          if (tmp___3 == 68) {
            {
#line 1258
            if ((int const   )*(rs_modifier + 3) == 50) {
#line 1258
              goto case_50;
            }
#line 1261
            if ((int const   )*(rs_modifier + 3) == 51) {
#line 1261
              goto case_51;
            }
#line 1264
            if ((int const   )*(rs_modifier + 3) == 52) {
#line 1264
              goto case_52;
            }
#line 1267
            if ((int const   )*(rs_modifier + 3) == 53) {
#line 1267
              goto case_53;
            }
#line 1270
            goto switch_default;
            case_50: /* CIL Label */ 
#line 1259
            ModXMask = (unsigned int )(1 << 4);
#line 1260
            goto switch_break;
            case_51: /* CIL Label */ 
#line 1262
            ModXMask = (unsigned int )(1 << 5);
#line 1263
            goto switch_break;
            case_52: /* CIL Label */ 
#line 1265
            ModXMask = (unsigned int )(1 << 6);
#line 1266
            goto switch_break;
            case_53: /* CIL Label */ 
#line 1268
            ModXMask = (unsigned int )(1 << 7);
#line 1269
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 1271
            ModXMask = (unsigned int )(1 << 3);
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 1274
  get_ourmods();
  }
#line 1275
  if (! (Options & (1UL << 11))) {
#line 1276
    PrivateModes |= 1UL << 16;
  }
#line 1277
  if (Options & (1UL << 12)) {
#line 1278
    PrivateModes |= 1UL << 17;
  }
  {
#line 1280
  tmp___4 = strcmp(rs_backspace_key, "DEC");
  }
#line 1280
  if (tmp___4 == 0) {
#line 1281
    PrivateModes |= 1UL << 8;
  }
  {
#line 1288
  Xfd = XConnectionNumber(Xdisplay);
#line 1293
  cmdbuf_endp = cmdbuf_base;
#line 1293
  cmdbuf_ptr = cmdbuf_endp;
#line 1295
  cmd_fd = run_command(argv);
  }
#line 1295
  if (cmd_fd < 0) {
    {
#line 1296
    print_error("aborting");
#line 1297
    exit(1);
    }
  }
#line 1299
  return;
}
}
#line 1308 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void init_xlocale(void) 
{ 
  char *p ;
  char *s ;
  char buf___0[32] ;
  char tmp[1024] ;
  XIM xim ;
  XIMStyle input_style ;
  XIMStyles *xim_styles ;
  int found ;
  char *end ;
  char *next_s ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short i ;
  char *end___0 ;
  char *next_s___0 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1314
  xim = (XIM )((void *)0);
#line 1315
  input_style = (XIMStyle )0;
#line 1316
  xim_styles = (XIMStyles *)((void *)0);
#line 1319
  Input_Context = (XIC )((void *)0);
#line 1324
  if ((unsigned long )rs_inputMethod == (unsigned long )((void *)0)) {
#line 1324
    goto _L;
  } else
#line 1324
  if (! *rs_inputMethod) {
    _L: /* CIL Label */ 
    {
#line 1325
    p = XSetLocaleModifiers("");
    }
#line 1325
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 1326
      xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                    (char *)((void *)0));
      }
    }
  } else {
    {
#line 1328
    strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)rs_inputMethod);
#line 1329
    s = tmp;
    }
    {
#line 1329
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1329
      if (! *s) {
#line 1329
        goto while_break;
      }
      {
#line 1332
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1332
        if (*s) {
          {
#line 1332
          tmp___0 = __ctype_b_loc();
          }
#line 1332
          if (! ((int const   )*(*tmp___0 + (int )*s) & 8192)) {
#line 1332
            goto while_break___0;
          }
        } else {
#line 1332
          goto while_break___0;
        }
#line 1332
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1334
      if (! *s) {
#line 1335
        goto while_break;
      }
#line 1336
      end = s;
      {
#line 1336
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1336
        if (*end) {
#line 1336
          if (! ((int )*end != 44)) {
#line 1336
            goto while_break___1;
          }
        } else {
#line 1336
          goto while_break___1;
        }
#line 1336
        end ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1338
      tmp___1 = end;
#line 1338
      end --;
#line 1338
      next_s = tmp___1;
      {
#line 1338
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1338
        if ((unsigned long )end >= (unsigned long )s) {
          {
#line 1338
          tmp___2 = __ctype_b_loc();
          }
#line 1338
          if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 1338
            goto while_break___2;
          }
        } else {
#line 1338
          goto while_break___2;
        }
#line 1338
        end --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1340
      end ++;
#line 1340
      *end = (char )'\000';
#line 1341
      if (*s) {
        {
#line 1342
        strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)((char *)"@im="));
#line 1343
        strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)s);
#line 1344
        p = XSetLocaleModifiers((char const   *)(buf___0));
        }
#line 1344
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 1344
          xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                        (char *)((void *)0));
          }
#line 1344
          if ((unsigned long )xim != (unsigned long )((void *)0)) {
#line 1346
            goto while_break;
          }
        }
      }
#line 1348
      s = next_s;
#line 1348
      if (! *s) {
#line 1349
        goto while_break;
      }
#line 1329
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1353
  if ((unsigned long )xim == (unsigned long )((void *)0)) {
    {
#line 1353
    p = XSetLocaleModifiers("@im=none");
    }
#line 1353
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 1354
      xim = XOpenIM(Xdisplay, (struct _XrmHashBucketRec *)((void *)0), (char *)((void *)0),
                    (char *)((void *)0));
      }
    }
  }
#line 1356
  if ((unsigned long )xim == (unsigned long )((void *)0)) {
    {
#line 1357
    print_error("Failed to open input method");
    }
#line 1358
    return;
  }
  {
#line 1360
  tmp___3 = XGetIMValues(xim, "queryInputStyle", & xim_styles, (void *)0);
  }
#line 1360
  if (tmp___3) {
    {
#line 1361
    print_error("input method doesn\'t support any style");
#line 1362
    XCloseIM(xim);
    }
#line 1363
    return;
  } else
#line 1360
  if (! xim_styles) {
    {
#line 1361
    print_error("input method doesn\'t support any style");
#line 1362
    XCloseIM(xim);
    }
#line 1363
    return;
  }
#line 1365
  if (rs_preeditType) {
#line 1365
    tmp___4 = (char const   *)rs_preeditType;
  } else {
#line 1365
    tmp___4 = "Root";
  }
  {
#line 1365
  strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)((char *)tmp___4));
#line 1366
  found = 0;
#line 1366
  s = tmp;
  }
  {
#line 1366
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1366
    if (*s) {
#line 1366
      if (! (! found)) {
#line 1366
        goto while_break___3;
      }
    } else {
#line 1366
      goto while_break___3;
    }
    {
#line 1370
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1370
      if (*s) {
        {
#line 1370
        tmp___5 = __ctype_b_loc();
        }
#line 1370
        if (! ((int const   )*(*tmp___5 + (int )*s) & 8192)) {
#line 1370
          goto while_break___4;
        }
      } else {
#line 1370
        goto while_break___4;
      }
#line 1370
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1372
    if (! *s) {
#line 1373
      goto while_break___3;
    }
#line 1374
    end___0 = s;
    {
#line 1374
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1374
      if (*end___0) {
#line 1374
        if (! ((int )*end___0 != 44)) {
#line 1374
          goto while_break___5;
        }
      } else {
#line 1374
        goto while_break___5;
      }
#line 1374
      end___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1376
    tmp___6 = end___0;
#line 1376
    end___0 --;
#line 1376
    next_s___0 = tmp___6;
    {
#line 1376
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1376
      if ((unsigned long )end___0 >= (unsigned long )s) {
        {
#line 1376
        tmp___8 = __ctype_b_loc();
        }
#line 1376
        if (! ((int const   )*(*tmp___8 + (int )*end___0) & 8192)) {
#line 1376
          goto while_break___6;
        }
      } else {
#line 1376
        goto while_break___6;
      }
#line 1377
      tmp___7 = end___0;
#line 1377
      end___0 --;
#line 1377
      *tmp___7 = (char)0;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1379
    tmp___11 = strcmp((char const   *)s, "OverTheSpot");
    }
#line 1379
    if (tmp___11) {
      {
#line 1381
      tmp___10 = strcmp((char const   *)s, "OffTheSpot");
      }
#line 1381
      if (tmp___10) {
        {
#line 1383
        tmp___9 = strcmp((char const   *)s, "Root");
        }
#line 1383
        if (! tmp___9) {
#line 1384
          input_style = (XIMStyle )1032L;
        }
      } else {
#line 1382
        input_style = (XIMStyle )257L;
      }
    } else {
#line 1380
      input_style = (XIMStyle )260L;
    }
#line 1386
    i = (unsigned short)0;
    {
#line 1386
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1386
      if (! ((int )i < (int )xim_styles->count_styles)) {
#line 1386
        goto while_break___7;
      }
#line 1387
      if (input_style == *(xim_styles->supported_styles + i)) {
#line 1388
        found = 1;
#line 1389
        goto while_break___7;
      }
#line 1386
      i = (unsigned short )((int )i + 1);
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1391
    s = next_s___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1393
  XFree((void *)xim_styles);
  }
#line 1395
  if (found == 0) {
    {
#line 1396
    print_error("input method doesn\'t support my preedit type");
#line 1397
    XCloseIM(xim);
    }
#line 1398
    return;
  }
#line 1406
  if (input_style != 1032UL) {
    {
#line 1407
    print_error("This program only supports the \"Root\" preedit type");
#line 1408
    XCloseIM(xim);
    }
#line 1409
    return;
  }
  {
#line 1411
  Input_Context = XCreateIC(xim, "inputStyle", input_style, "clientWindow", TermWin.parent,
                            "focusWindow", TermWin.parent, (void *)0);
  }
#line 1416
  if ((unsigned long )Input_Context == (unsigned long )((void *)0)) {
    {
#line 1417
    print_error("Failed to create input context");
#line 1418
    XCloseIM(xim);
    }
  }
#line 1422
  return;
}
}
#line 1431 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void tt_winsize(int fd ) 
{ 
  struct winsize ws ;

  {
#line 1436
  if (fd < 0) {
#line 1437
    return;
  }
  {
#line 1439
  ws.ws_col = TermWin.ncol;
#line 1440
  ws.ws_row = TermWin.nrow;
#line 1442
  ws.ws_ypixel = (unsigned short)0;
#line 1442
  ws.ws_xpixel = ws.ws_ypixel;
#line 1444
  ioctl(fd, 21524UL, & ws);
  }
#line 1445
  return;
}
}
#line 1448 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void tt_resize(void) 
{ 


  {
  {
#line 1451
  tt_winsize(cmd_fd);
  }
#line 1452
  return;
}
}
#line 1461 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int numlock_state  =    0;
#line 1469 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static XComposeStatus compose  =    {(XPointer )((void *)0), 0};
#line 1471 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char kbuf[8]  ;
#line 1458 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void lookup_key(XEvent *ev ) 
{ 
  int ctrl ;
  int meta ;
  int shft ;
  int len ;
  KeySym keysym ;
  int status_return ;
  int tmp ;
  int lnsppg ;
  unsigned char const   *kbuf___0 ;
  unsigned int len___0 ;
  unsigned char const   *tmp___0 ;
  unsigned char ch ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char *ch___0 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char ch___1 ;

  {
#line 1473
  keysym = (KeySym )0;
#line 1481
  shft = (int )(ev->xkey.state & 1U);
#line 1482
  ctrl = (int )(ev->xkey.state & (unsigned int )(1 << 2));
#line 1483
  meta = (int )(ev->xkey.state & ModXMask);
#line 1485
  if (numlock_state) {
#line 1485
    goto _L;
  } else
#line 1485
  if (ev->xkey.state & ModNumLockMask) {
    _L: /* CIL Label */ 
#line 1486
    numlock_state = (int )(ev->xkey.state & ModNumLockMask);
    {
#line 1487
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1487
      if (! numlock_state) {
#line 1487
        PrivateModes |= 1UL << 7;
      } else {
#line 1487
        PrivateModes &= ~ (1UL << 7);
      }
#line 1487
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1490
  len = 0;
#line 1491
  tmp = XFilterEvent(ev, ev->xkey.window);
  }
#line 1491
  if (! tmp) {
#line 1492
    if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
      {
#line 1495
      kbuf[0] = (unsigned char )'\000';
#line 1496
      len = XmbLookupString(Input_Context, & ev->xkey, (char *)(kbuf), (int )sizeof(kbuf),
                            & keysym, & status_return);
      }
    } else {
      {
#line 1500
      len = XLookupString(& ev->xkey, (char *)(kbuf), (int )sizeof(kbuf), & keysym,
                          & compose);
      }
    }
  }
#line 1517
  if (len) {
#line 1517
    if (Options & (1UL << 12)) {
#line 1518
      TermWin.view_start = (R_u_int16_t )0;
    }
  }
#line 1541
  if (shft) {
#line 1543
    if (keysym >= 65470UL) {
#line 1543
      if (keysym <= 65479UL) {
#line 1544
        keysym += 10UL;
#line 1545
        shft = 0;
      } else {
#line 1543
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1546
    if (! ctrl) {
#line 1546
      if (! meta) {
#line 1546
        if (PrivateModes & (1UL << 10)) {
#line 1547
          lnsppg = ((int )TermWin.nrow * 4) / 5;
#line 1550
          lnsppg = (int )TermWin.nrow - 1;
          {
#line 1555
          if (keysym == 65365UL) {
#line 1555
            goto case_65365;
          }
#line 1562
          if (keysym == 65362UL) {
#line 1562
            goto case_65362;
          }
#line 1569
          if (keysym == 65364UL) {
#line 1569
            goto case_65364;
          }
#line 1576
          if (keysym == 65366UL) {
#line 1576
            goto case_65366;
          }
#line 1583
          if (keysym == 65379UL) {
#line 1583
            goto case_65379;
          }
#line 1589
          if (keysym == 65451UL) {
#line 1589
            goto case_65451;
          }
#line 1594
          if (keysym == 65453UL) {
#line 1594
            goto case_65453;
          }
#line 1553
          goto switch_break;
          case_65365: /* CIL Label */ 
#line 1556
          if (TermWin.saveLines) {
            {
#line 1557
            scr_page(0, lnsppg);
            }
#line 1558
            return;
          }
#line 1560
          goto switch_break;
          case_65362: /* CIL Label */ 
#line 1563
          if (TermWin.saveLines) {
            {
#line 1564
            scr_page(0, 1);
            }
#line 1565
            return;
          }
#line 1567
          goto switch_break;
          case_65364: /* CIL Label */ 
#line 1570
          if (TermWin.saveLines) {
            {
#line 1571
            scr_page(1, 1);
            }
#line 1572
            return;
          }
#line 1574
          goto switch_break;
          case_65366: /* CIL Label */ 
#line 1577
          if (TermWin.saveLines) {
            {
#line 1578
            scr_page(1, lnsppg);
            }
#line 1579
            return;
          }
#line 1581
          goto switch_break;
          case_65379: /* CIL Label */ 
          {
#line 1584
          selection_request(ev->xkey.time, ev->xkey.x, ev->xkey.y);
          }
#line 1585
          return;
#line 1586
          goto switch_break;
          case_65451: /* CIL Label */ 
          {
#line 1590
          change_font(0, "#+");
          }
#line 1591
          return;
#line 1592
          goto switch_break;
          case_65453: /* CIL Label */ 
          {
#line 1595
          change_font(0, "#-");
          }
#line 1596
          return;
#line 1597
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 1622
  if (keysym == 65377UL) {
#line 1622
    goto case_65377;
  }
#line 1629
  if (keysym == 65406UL) {
#line 1629
    goto case_65406;
  }
#line 1621
  goto switch_break___0;
  case_65377: /* CIL Label */ 
#line 1627
  goto switch_break___0;
  case_65406: /* CIL Label */ 
#line 1640
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1643
  if (keysym >= 65280UL) {
#line 1643
    if (keysym <= 65535UL) {
#line 1645
      if (! (shft | ctrl)) {
#line 1645
        if ((unsigned long )KeySym_map[keysym - 65280UL] != (unsigned long )((void *)0)) {
#line 1649
          kbuf___0 = KeySym_map[keysym - 65280UL];
#line 1650
          tmp___0 = kbuf___0;
#line 1650
          kbuf___0 ++;
#line 1650
          len___0 = (unsigned int )*tmp___0;
#line 1653
          if (meta) {
#line 1653
            if ((int )meta_char == 27) {
              {
#line 1658
              ch = (unsigned char )'\033';
#line 1660
              tt_write((unsigned char const   *)(& ch), 1);
              }
            }
          }
          {
#line 1662
          tt_write(kbuf___0, (int )len___0);
          }
#line 1663
          return;
        } else {
#line 1645
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1668
        if (keysym == 65288UL) {
#line 1668
          goto case_65288;
        }
#line 1678
        if (keysym == 65535UL) {
#line 1678
          goto case_65535;
        }
#line 1682
        if (keysym == 65289UL) {
#line 1682
          goto case_65289;
        }
#line 1690
        if (keysym == 65429UL) {
#line 1690
          goto case_65429;
        }
#line 1699
        if (keysym == 65360UL) {
#line 1699
          goto case_65360;
        }
#line 1707
        if (keysym == 65433UL) {
#line 1707
          goto case_65433;
        }
#line 1707
        if (keysym == 65432UL) {
#line 1707
          goto case_65433;
        }
#line 1707
        if (keysym == 65431UL) {
#line 1707
          goto case_65433;
        }
#line 1707
        if (keysym == 65430UL) {
#line 1707
          goto case_65433;
        }
#line 1722
        if (keysym == 65364UL) {
#line 1722
          goto case_65364___0;
        }
#line 1722
        if (keysym == 65363UL) {
#line 1722
          goto case_65364___0;
        }
#line 1722
        if (keysym == 65362UL) {
#line 1722
          goto case_65364___0;
        }
#line 1722
        if (keysym == 65361UL) {
#line 1722
          goto case_65364___0;
        }
#line 1739
        if (keysym == 65434UL) {
#line 1739
          goto case_65434;
        }
#line 1748
        if (keysym == 65365UL) {
#line 1748
          goto case_65365___0;
        }
#line 1753
        if (keysym == 65435UL) {
#line 1753
          goto case_65435;
        }
#line 1762
        if (keysym == 65366UL) {
#line 1762
          goto case_65366___0;
        }
#line 1768
        if (keysym == 65436UL) {
#line 1768
          goto case_65436;
        }
#line 1777
        if (keysym == 65367UL) {
#line 1777
          goto case_65367;
        }
#line 1781
        if (keysym == 65376UL) {
#line 1781
          goto case_65376;
        }
#line 1788
        if (keysym == 65378UL) {
#line 1788
          goto case_65378;
        }
#line 1792
        if (keysym == 65379UL) {
#line 1792
          goto case_65379___0;
        }
#line 1797
        if (keysym == 65383UL) {
#line 1797
          goto case_65383;
        }
#line 1801
        if (keysym == 65384UL) {
#line 1801
          goto case_65384;
        }
#line 1805
        if (keysym == 65386UL) {
#line 1805
          goto case_65386;
        }
#line 1810
        if (keysym == 65421UL) {
#line 1810
          goto case_65421;
        }
#line 1822
        if (keysym == 65437UL) {
#line 1822
          goto case_65437;
        }
#line 1827
        if (keysym == 65438UL) {
#line 1827
          goto case_65438;
        }
#line 1832
        if (keysym == 65439UL) {
#line 1832
          goto case_65439;
        }
#line 1841
        if (keysym == 65428UL) {
#line 1841
          goto case_65428;
        }
#line 1841
        if (keysym == 65427UL) {
#line 1841
          goto case_65428;
        }
#line 1841
        if (keysym == 65426UL) {
#line 1841
          goto case_65428;
        }
#line 1841
        if (keysym == 65425UL) {
#line 1841
          goto case_65428;
        }
#line 1862
        if (keysym == 65465UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65464UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65463UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65462UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65461UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65460UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65459UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65458UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65457UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65456UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65455UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65454UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65453UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65452UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65451UL) {
#line 1862
          goto case_65465;
        }
#line 1862
        if (keysym == 65450UL) {
#line 1862
          goto case_65465;
        }
#line 1877
        if (keysym == 65473UL) {
#line 1877
          goto case_65473;
        }
#line 1877
        if (keysym == 65472UL) {
#line 1877
          goto case_65473;
        }
#line 1877
        if (keysym == 65471UL) {
#line 1877
          goto case_65473;
        }
#line 1877
        if (keysym == 65470UL) {
#line 1877
          goto case_65473;
        }
#line 1894
        if (keysym == 65474UL) {
#line 1894
          goto case_65474;
        }
#line 1902
        if (keysym == 65479UL) {
#line 1902
          goto case_65479;
        }
#line 1902
        if (keysym == 65478UL) {
#line 1902
          goto case_65479;
        }
#line 1902
        if (keysym == 65477UL) {
#line 1902
          goto case_65479;
        }
#line 1902
        if (keysym == 65476UL) {
#line 1902
          goto case_65479;
        }
#line 1902
        if (keysym == 65475UL) {
#line 1902
          goto case_65479;
        }
#line 1909
        if (keysym == 65483UL) {
#line 1909
          goto case_65483;
        }
#line 1909
        if (keysym == 65482UL) {
#line 1909
          goto case_65483;
        }
#line 1909
        if (keysym == 65481UL) {
#line 1909
          goto case_65483;
        }
#line 1909
        if (keysym == 65480UL) {
#line 1909
          goto case_65483;
        }
#line 1914
        if (keysym == 65485UL) {
#line 1914
          goto case_65485;
        }
#line 1914
        if (keysym == 65484UL) {
#line 1914
          goto case_65485;
        }
#line 1936
        if (keysym == 65504UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65503UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65502UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65501UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65500UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65499UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65498UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65497UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65496UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65495UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65494UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65493UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65492UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65491UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65490UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65489UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65488UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65487UL) {
#line 1936
          goto case_65504;
        }
#line 1936
        if (keysym == 65486UL) {
#line 1936
          goto case_65504;
        }
#line 1666
        goto switch_break___1;
        case_65288: /* CIL Label */ 
#line 1669
        if (PrivateModes & (1UL << 8)) {
#line 1670
          len = 1;
#line 1671
          if (PrivateModes & (1UL << 9)) {
#line 1671
            tmp___2 = ! (shft | ctrl);
          } else {
#line 1671
            tmp___2 = shft | ctrl;
          }
#line 1671
          if (tmp___2) {
#line 1671
            kbuf[0] = (unsigned char )'\b';
          } else {
#line 1671
            kbuf[0] = (unsigned char )'\177';
          }
        } else {
          {
#line 1674
          tmp___3 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)rs_backspace_key));
#line 1674
          tmp___4 = strlen((char const   *)tmp___3);
#line 1674
          len = (int )tmp___4;
          }
        }
#line 1675
        goto switch_break___1;
        case_65535: /* CIL Label */ 
        {
#line 1679
        tmp___5 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)rs_delete_key));
#line 1679
        tmp___6 = strlen((char const   *)tmp___5);
#line 1679
        len = (int )tmp___6;
        }
#line 1680
        goto switch_break___1;
        case_65289: /* CIL Label */ 
#line 1683
        if (shft) {
          {
#line 1684
          len = 3;
#line 1685
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[Z"));
          }
        }
#line 1687
        goto switch_break___1;
        case_65429: /* CIL Label */ 
#line 1692
        if (PrivateModes & (1UL << 7)) {
#line 1692
          tmp___7 = ! shft;
        } else {
#line 1692
          tmp___7 = shft;
        }
#line 1692
        if (tmp___7) {
          {
#line 1693
          len = 3;
#line 1694
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Ow"));
          }
#line 1695
          goto switch_break___1;
        }
        case_65360: /* CIL Label */ 
        {
#line 1700
        tmp___8 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[7~"));
#line 1700
        tmp___9 = strlen((char const   *)tmp___8);
#line 1700
        len = (int )tmp___9;
        }
#line 1701
        goto switch_break___1;
        case_65433: /* CIL Label */ 
        case_65432: /* CIL Label */ 
        case_65431: /* CIL Label */ 
        case_65430: /* CIL Label */ 
#line 1708
        if (PrivateModes & (1UL << 7)) {
#line 1708
          tmp___10 = ! shft;
        } else {
#line 1708
          tmp___10 = shft;
        }
#line 1708
        if (tmp___10) {
          {
#line 1709
          len = 3;
#line 1710
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033OZ"));
#line 1711
          kbuf[2] = (unsigned char )*("txvr" + (keysym - 65430UL));
          }
#line 1712
          goto switch_break___1;
        } else {
#line 1715
          keysym = 65361UL + (keysym - 65430UL);
        }
        case_65364___0: /* CIL Label */ 
        case_65363: /* CIL Label */ 
        case_65362___0: /* CIL Label */ 
        case_65361: /* CIL Label */ 
        {
#line 1723
        len = 3;
#line 1724
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[@"));
#line 1725
        kbuf[2] = (unsigned char )*("DACB" + (keysym - 65361UL));
        }
#line 1727
        if (shft) {
#line 1728
          kbuf[2] = (unsigned char )*("dacb" + (keysym - 65361UL));
        } else
#line 1729
        if (ctrl) {
#line 1730
          kbuf[1] = (unsigned char )'O';
#line 1731
          kbuf[2] = (unsigned char )*("dacb" + (keysym - 65361UL));
        } else
#line 1732
        if (PrivateModes & (1UL << 6)) {
#line 1733
          kbuf[1] = (unsigned char )'O';
        }
#line 1735
        goto switch_break___1;
        case_65434: /* CIL Label */ 
#line 1741
        if (PrivateModes & (1UL << 7)) {
#line 1741
          tmp___11 = ! shft;
        } else {
#line 1741
          tmp___11 = shft;
        }
#line 1741
        if (tmp___11) {
          {
#line 1742
          len = 3;
#line 1743
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Oy"));
          }
#line 1744
          goto switch_break___1;
        }
        case_65365___0: /* CIL Label */ 
        {
#line 1749
        len = 4;
#line 1750
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[5~"));
        }
#line 1751
        goto switch_break___1;
        case_65435: /* CIL Label */ 
#line 1755
        if (PrivateModes & (1UL << 7)) {
#line 1755
          tmp___12 = ! shft;
        } else {
#line 1755
          tmp___12 = shft;
        }
#line 1755
        if (tmp___12) {
          {
#line 1756
          len = 3;
#line 1757
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Os"));
          }
#line 1758
          goto switch_break___1;
        }
        case_65366___0: /* CIL Label */ 
        {
#line 1763
        len = 4;
#line 1764
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[6~"));
        }
#line 1765
        goto switch_break___1;
        case_65436: /* CIL Label */ 
#line 1770
        if (PrivateModes & (1UL << 7)) {
#line 1770
          tmp___13 = ! shft;
        } else {
#line 1770
          tmp___13 = shft;
        }
#line 1770
        if (tmp___13) {
          {
#line 1771
          len = 3;
#line 1772
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Oq"));
          }
#line 1773
          goto switch_break___1;
        }
        case_65367: /* CIL Label */ 
        {
#line 1778
        tmp___14 = strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[8~"));
#line 1778
        tmp___15 = strlen((char const   *)tmp___14);
#line 1778
        len = (int )tmp___15;
        }
#line 1779
        goto switch_break___1;
        case_65376: /* CIL Label */ 
        {
#line 1782
        len = 4;
#line 1783
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[4~"));
        }
#line 1784
        goto switch_break___1;
        case_65378: /* CIL Label */ 
        {
#line 1789
        len = 4;
#line 1790
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[3~"));
        }
#line 1791
        goto switch_break___1;
        case_65379___0: /* CIL Label */ 
        {
#line 1793
        len = 4;
#line 1794
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[2~"));
        }
#line 1795
        goto switch_break___1;
        case_65383: /* CIL Label */ 
        {
#line 1798
        len = 5;
#line 1799
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[29~"));
        }
#line 1800
        goto switch_break___1;
        case_65384: /* CIL Label */ 
        {
#line 1802
        len = 4;
#line 1803
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[1~"));
        }
#line 1804
        goto switch_break___1;
        case_65386: /* CIL Label */ 
        {
#line 1806
        len = 5;
#line 1807
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033[28~"));
        }
#line 1808
        goto switch_break___1;
        case_65421: /* CIL Label */ 
#line 1812
        if (PrivateModes & (1UL << 7)) {
#line 1812
          tmp___16 = ! shft;
        } else {
#line 1812
          tmp___16 = shft;
        }
#line 1812
        if (tmp___16) {
          {
#line 1813
          len = 3;
#line 1814
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033OM"));
          }
        } else {
#line 1816
          len = 1;
#line 1817
          kbuf[0] = (unsigned char )'\r';
        }
#line 1819
        goto switch_break___1;
        case_65437: /* CIL Label */ 
        {
#line 1823
        len = 3;
#line 1824
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Ou"));
        }
#line 1825
        goto switch_break___1;
        case_65438: /* CIL Label */ 
        {
#line 1828
        len = 3;
#line 1829
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Op"));
        }
#line 1830
        goto switch_break___1;
        case_65439: /* CIL Label */ 
        {
#line 1833
        len = 3;
#line 1834
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033On"));
        }
#line 1835
        goto switch_break___1;
        case_65428: /* CIL Label */ 
        case_65427: /* CIL Label */ 
        case_65426: /* CIL Label */ 
        case_65425: /* CIL Label */ 
        {
#line 1842
        len = 3;
#line 1843
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033OP"));
#line 1844
        kbuf[2] = (unsigned char )((KeySym )kbuf[2] + (keysym - 65425UL));
        }
#line 1845
        goto switch_break___1;
        case_65465: /* CIL Label */ 
        case_65464: /* CIL Label */ 
        case_65463: /* CIL Label */ 
        case_65462: /* CIL Label */ 
        case_65461: /* CIL Label */ 
        case_65460: /* CIL Label */ 
        case_65459: /* CIL Label */ 
        case_65458: /* CIL Label */ 
        case_65457: /* CIL Label */ 
        case_65456: /* CIL Label */ 
        case_65455: /* CIL Label */ 
        case_65454: /* CIL Label */ 
        case_65453___0: /* CIL Label */ 
        case_65452: /* CIL Label */ 
        case_65451___0: /* CIL Label */ 
        case_65450: /* CIL Label */ 
#line 1864
        if (PrivateModes & (1UL << 7)) {
#line 1864
          tmp___17 = ! shft;
        } else {
#line 1864
          tmp___17 = shft;
        }
#line 1864
        if (tmp___17) {
          {
#line 1865
          len = 3;
#line 1866
          strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033Oj"));
#line 1867
          kbuf[2] = (unsigned char )((KeySym )kbuf[2] + (keysym - 65450UL));
          }
        } else {
#line 1869
          len = 1;
#line 1870
          kbuf[0] = (unsigned char )(42UL + (keysym - 65450UL));
        }
#line 1872
        goto switch_break___1;
        case_65473: /* CIL Label */ 
        case_65472: /* CIL Label */ 
        case_65471: /* CIL Label */ 
        case_65470: /* CIL Label */ 
        {
#line 1878
        len = 3;
#line 1879
        strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)((char *)"\033OP"));
#line 1880
        kbuf[2] = (unsigned char )((KeySym )kbuf[2] + (keysym - 65470UL));
        }
#line 1881
        goto switch_break___1;
        case_65474: /* CIL Label */ 
        {
#line 1895
        len = 5;
#line 1895
        sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
                (int )(15UL + (keysym - 65474UL)));
        }
#line 1896
        goto switch_break___1;
        case_65479: /* CIL Label */ 
        case_65478: /* CIL Label */ 
        case_65477: /* CIL Label */ 
        case_65476: /* CIL Label */ 
        case_65475: /* CIL Label */ 
        {
#line 1903
        len = 5;
#line 1903
        sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
                (int )(17UL + (keysym - 65475UL)));
        }
#line 1904
        goto switch_break___1;
        case_65483: /* CIL Label */ 
        case_65482: /* CIL Label */ 
        case_65481: /* CIL Label */ 
        case_65480: /* CIL Label */ 
        {
#line 1910
        len = 5;
#line 1910
        sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
                (int )(23UL + (keysym - 65480UL)));
        }
#line 1911
        goto switch_break___1;
        case_65485: /* CIL Label */ 
        case_65484: /* CIL Label */ 
        {
#line 1915
        len = 5;
#line 1915
        sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
                (int )(28UL + (keysym - 65484UL)));
        }
#line 1916
        goto switch_break___1;
        case_65504: /* CIL Label */ 
        case_65503: /* CIL Label */ 
        case_65502: /* CIL Label */ 
        case_65501: /* CIL Label */ 
        case_65500: /* CIL Label */ 
        case_65499: /* CIL Label */ 
        case_65498: /* CIL Label */ 
        case_65497: /* CIL Label */ 
        case_65496: /* CIL Label */ 
        case_65495: /* CIL Label */ 
        case_65494: /* CIL Label */ 
        case_65493: /* CIL Label */ 
        case_65492: /* CIL Label */ 
        case_65491: /* CIL Label */ 
        case_65490: /* CIL Label */ 
        case_65489: /* CIL Label */ 
        case_65488: /* CIL Label */ 
        case_65487: /* CIL Label */ 
        case_65486: /* CIL Label */ 
        {
#line 1937
        len = 5;
#line 1937
        sprintf((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[%02d~",
                (int )(31UL + (keysym - 65486UL)));
        }
#line 1938
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 1945
      if (meta) {
#line 1945
        if ((int )meta_char == 128) {
#line 1945
          if (len > 0) {
#line 1946
            kbuf[len - 1] = (unsigned char )((int )kbuf[len - 1] | 128);
          }
        }
      }
    } else {
#line 1643
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1949
  if (ctrl) {
#line 1949
    if (keysym == 45UL) {
#line 1950
      len = 1;
#line 1951
      kbuf[0] = (unsigned char )'\037';
    } else {
#line 1949
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1955
  if (meta) {
#line 1955
    if ((int )meta_char == 128) {
#line 1958
      ch___0 = kbuf;
      {
#line 1958
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1958
        if (! ((unsigned long )ch___0 < (unsigned long )(kbuf + len))) {
#line 1958
          goto while_break___0;
        }
#line 1959
        *ch___0 = (unsigned char )((int )*ch___0 | 128);
#line 1958
        ch___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1960
      meta = 0;
    }
  }
#line 1970
  if (len <= 0) {
#line 1971
    return;
  }
#line 1984
  if ((int )kbuf[0] == 27) {
#line 1984
    if ((int )kbuf[1] == 91) {
#line 1984
      if ((int )kbuf[len - 1] == 126) {
#line 1985
        if (shft) {
#line 1985
          if (ctrl) {
#line 1985
            tmp___18 = '@';
          } else {
#line 1985
            tmp___18 = '$';
          }
#line 1985
          kbuf[len - 1] = (unsigned char )tmp___18;
        } else {
#line 1985
          if (ctrl) {
#line 1985
            tmp___19 = '^';
          } else {
#line 1985
            tmp___19 = '~';
          }
#line 1985
          kbuf[len - 1] = (unsigned char )tmp___19;
        }
      }
    }
  }
#line 1988
  if (meta) {
#line 1988
    if ((int )meta_char == 27) {
      {
#line 1993
      ch___1 = (unsigned char )'\033';
#line 1995
      tt_write((unsigned char const   *)(& ch___1), 1);
      }
    }
  }
  {
#line 2008
  tt_write((unsigned char const   *)(kbuf), len);
  }
#line 2009
  return;
}
}
#line 2065 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static short refreshed  =    (short)0;
#line 2061 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
unsigned char cmd_getc(void) 
{ 
  fd_set readfds ;
  int retval ;
  struct timeval value ;
  struct timeval *timeout ;
  XEvent ev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __d0 ;
  int __d1 ;
  time_t curr_t_sec ;
  time_t curr_t_usec ;
  time_t wait_usec ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int n ;
  unsigned int count ;
  int *tmp___6 ;
  ssize_t tmp___7 ;
  time_t curr_t_sec___0 ;
  time_t curr_t_usec___0 ;
  unsigned char *tmp___8 ;

  {
#line 2085
  if (refresh_count >= refresh_limit * ((int )TermWin.nrow - 1)) {
#line 2086
    if (refresh_limit < 1) {
#line 2087
      refresh_limit ++;
    }
    {
#line 2088
    refresh_count = 0;
#line 2089
    refreshed = (short)1;
#line 2090
    scr_refresh(refresh_type);
    }
  }
#line 2093
  if ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp) {
#line 2094
    goto Return_Char;
  }
  {
#line 2096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    timeout = & value;
#line 2099
    if ((unsigned long )v_bufstr < (unsigned long )v_bufptr) {
      {
#line 2100
      tt_write((unsigned char const   *)((void *)0), 0);
      }
    }
    {
#line 2101
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2101
      tmp = XPending(Xdisplay);
      }
#line 2101
      if (! tmp) {
#line 2101
        goto while_break___0;
      }
      {
#line 2102
      refreshed = (short)0;
#line 2108
      XNextEvent(Xdisplay, & ev);
#line 2110
      process_x_event(& ev);
      }
#line 2114
      if ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp) {
#line 2115
        goto Return_Char;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2118
    if ((int )scrollBar.state == 85) {
#line 2119
      tmp___0 = scroll_arrow_delay;
#line 2119
      scroll_arrow_delay --;
#line 2119
      if (! tmp___0) {
        {
#line 2119
        tmp___1 = scr_page(0, 1);
        }
#line 2119
        if (tmp___1) {
#line 2120
          scroll_arrow_delay = 2;
#line 2121
          refreshed = (short)0;
#line 2122
          refresh_type |= 1 << 3;
        }
      }
    } else
#line 2124
    if ((int )scrollBar.state == 68) {
#line 2125
      tmp___2 = scroll_arrow_delay;
#line 2125
      scroll_arrow_delay --;
#line 2125
      if (! tmp___2) {
        {
#line 2125
        tmp___3 = scr_page(1, 1);
        }
#line 2125
        if (tmp___3) {
#line 2126
          scroll_arrow_delay = 2;
#line 2127
          refreshed = (short)0;
#line 2128
          refresh_type |= 1 << 3;
        }
      }
    }
    {
#line 2134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2134
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.fds_bits[0]): "memory");
#line 2134
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2135
    readfds.fds_bits[cmd_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << cmd_fd % (8 * (int )sizeof(__fd_mask ));
#line 2136
    readfds.fds_bits[Xfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << Xfd % (8 * (int )sizeof(__fd_mask ));
#line 2138
    if (refreshed) {
#line 2138
      if (last_update_background_request_sec == 0L) {
        {
#line 2138
        tmp___4 = __ctype_b_loc();
        }
#line 2138
        if ((int const   )*(*tmp___4 + (int )scrollBar.state) & 256) {
#line 2138
          goto _L___0;
        } else {
#line 2143
          timeout = (struct timeval *)((void *)0);
        }
      } else {
#line 2138
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2144
    if (! refreshed) {
#line 2146
      timeout->tv_usec = (__suseconds_t )5000;
#line 2147
      timeout->tv_sec = (__time_t )0;
    } else
#line 2148
    if (last_update_background_request_sec) {
      {
#line 2150
      wait_usec = (time_t )0;
#line 2151
      timer_get_time(& curr_t_sec, & curr_t_usec);
      }
#line 2152
      if (curr_t_sec == last_update_background_request_sec) {
#line 2154
        if (curr_t_usec < last_update_background_request_usec) {
#line 2155
          wait_usec = last_update_background_request_usec - curr_t_usec;
        }
      } else
#line 2156
      if (curr_t_sec < last_update_background_request_sec) {
#line 2158
        wait_usec = (last_update_background_request_sec - curr_t_sec) * 1000000L;
#line 2159
        wait_usec += last_update_background_request_usec;
#line 2160
        wait_usec -= curr_t_usec;
      }
#line 2162
      if (wait_usec == 0L) {
#line 2163
        wait_usec = (time_t )5000;
      }
#line 2164
      timeout->tv_usec = wait_usec;
#line 2165
      timeout->tv_sec = (__time_t )0;
    }
#line 2168
    if (cmd_fd > Xfd) {
#line 2168
      tmp___5 = cmd_fd;
    } else {
#line 2168
      tmp___5 = Xfd;
    }
    {
#line 2168
    retval = select(tmp___5 + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)timeout);
    }
#line 2171
    if ((readfds.fds_bits[cmd_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << cmd_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 2175
      cmdbuf_endp = cmdbuf_base;
#line 2175
      cmdbuf_ptr = cmdbuf_endp;
#line 2176
      count = 8192U;
      {
#line 2176
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2176
        if (! count) {
#line 2176
          goto while_break___2;
        }
        {
#line 2177
        tmp___7 = read(cmd_fd, (void *)cmdbuf_endp, (size_t )count);
#line 2177
        n = (int )tmp___7;
        }
#line 2177
        if (! (n > 0)) {
#line 2179
          if (n == 0) {
#line 2180
            goto while_break___2;
          } else
#line 2179
          if (n < 0) {
            {
#line 2179
            tmp___6 = __errno_location();
            }
#line 2179
            if (*tmp___6 == 11) {
#line 2180
              goto while_break___2;
            } else {
              {
#line 2185
              exit(0);
              }
            }
          } else {
            {
#line 2185
            exit(0);
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 2176
        count -= (unsigned int )n;
#line 2176
        cmdbuf_endp += n;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2188
      if (count != 8192U) {
#line 2189
        goto Return_Char;
      }
    }
#line 2192
    if (retval == 0) {
#line 2194
      refresh_count = 0;
#line 2195
      refresh_limit = 1;
#line 2196
      if (last_update_background_request_sec > 0L) {
        {
#line 2199
        timer_get_time(& curr_t_sec___0, & curr_t_usec___0);
        }
#line 2200
        if (last_update_background_request_sec == curr_t_sec___0) {
#line 2200
          if (last_update_background_request_usec < curr_t_usec___0) {
            {
#line 2206
            RenderPixmap(1);
#line 2207
            refresh_transparent_scrollbar();
#line 2208
            scr_clear_tint(1);
#line 2209
            scr_touch();
#line 2210
            refreshed = (short)1;
            }
          } else {
#line 2200
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 2200
        if (last_update_background_request_sec < curr_t_sec___0) {
          {
#line 2206
          RenderPixmap(1);
#line 2207
          refresh_transparent_scrollbar();
#line 2208
          scr_clear_tint(1);
#line 2209
          scr_touch();
#line 2210
          refreshed = (short)1;
          }
        } else
#line 2200
        if (last_update_background_request_sec - 1L > curr_t_sec___0) {
          {
#line 2206
          RenderPixmap(1);
#line 2207
          refresh_transparent_scrollbar();
#line 2208
          scr_clear_tint(1);
#line 2209
          scr_touch();
#line 2210
          refreshed = (short)1;
          }
        }
      }
#line 2213
      if (! refreshed) {
        {
#line 2215
        refreshed = (short)1;
#line 2216
        scr_refresh(refresh_type);
#line 2217
        scrollbar_show(1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2225
  return ((unsigned char)0);
  Return_Char: 
#line 2228
  refreshed = (short)0;
#line 2229
  tmp___8 = cmdbuf_ptr;
#line 2229
  cmdbuf_ptr ++;
#line 2229
  return (*tmp___8);
}
}
#line 2237 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static struct __anonstruct_MEvent_192 MEvent  =    {0, (Time )0L, 0U, 0U};
#line 2247 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void mouse_report(XButtonEvent *ev ) 
{ 
  int button_number ;
  int key_state ;
  int x ;
  int y ;
  int tmp ;

  {
  {
#line 2250
  key_state = 0;
#line 2253
  x = ev->x;
#line 2254
  y = ev->y;
#line 2255
  pixel_position(& x, & y);
  }
#line 2257
  if ((long )MEvent.button == 0L) {
#line 2257
    button_number = 3;
  } else {
#line 2257
    button_number = (int )(MEvent.button - 1U);
  }
#line 2260
  if (PrivateModes & (1UL << 12)) {
#line 2265
    key_state = 0;
#line 2266
    if (button_number == 3) {
#line 2267
      return;
    }
  } else {
#line 2281
    if (MEvent.state & (unsigned int )(1 << 3)) {
#line 2281
      tmp = 2;
    } else {
#line 2281
      tmp = 0;
    }
#line 2281
    key_state = (int )(((MEvent.state & (unsigned int )(1 | (1 << 2))) + (unsigned int )tmp) << 2);
#line 2288
    if (ev->button == 4U) {
#line 2289
      key_state |= 1 << 6;
#line 2290
      button_number = (int )(ev->button - 4U);
    } else
#line 2288
    if (ev->button == 5U) {
#line 2289
      key_state |= 1 << 6;
#line 2290
      button_number = (int )(ev->button - 4U);
    }
  }
  {
#line 2309
  tt_printf((unsigned char const   *)((unsigned char *)"\033[M%c%c%c"), (32 + button_number) + key_state,
            (32 + x) + 1, (32 + y) + 1);
  }
#line 2314
  return;
}
}
#line 2321 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int bypass_keystate  =    0;
#line 2323 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static int csrO  =    0;
#line 2318 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_x_event(XEvent *ev ) 
{ 
  int reportmode ;
  int tmp ;
  Pixmap p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int n ;
  XWindowAttributes attr ;
  int (*oldXErrorHandler)(Display * , XErrorEvent * ) ;
  XErrorHandler tmp___9 ;
  Window root ;
  Window parent ;
  Window *list ;
  int tmp___10 ;
  XEvent unused_xevent ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  Window unused_root ;
  Window unused_child ;
  int unused_root_x ;
  int unused_root_y ;
  unsigned int unused_mask ;
  int tmp___18 ;
  int tmp___19 ;
  Window unused_root___0 ;
  Window unused_child___0 ;
  int unused_root_x___0 ;
  int unused_root_y___0 ;
  unsigned int unused_mask___0 ;
  int tmp___20 ;

  {
  {
#line 2333
  if (ev->type == 2) {
#line 2333
    goto case_2;
  }
#line 2337
  if (ev->type == 17) {
#line 2337
    goto case_17;
  }
#line 2349
  if (ev->type == 33) {
#line 2349
    goto case_33;
  }
#line 2388
  if (ev->type == 34) {
#line 2388
    goto case_34;
  }
#line 2400
  if (ev->type == 15) {
#line 2400
    goto case_15;
  }
#line 2416
  if (ev->type == 9) {
#line 2416
    goto case_9;
  }
#line 2433
  if (ev->type == 10) {
#line 2433
    goto case_10;
  }
#line 2450
  if (ev->type == 22) {
#line 2450
    goto case_22;
  }
#line 2456
  if (ev->type == 29) {
#line 2456
    goto case_29;
  }
#line 2460
  if (ev->type == 31) {
#line 2460
    goto case_31;
  }
#line 2464
  if (ev->type == 30) {
#line 2464
    goto case_30;
  }
#line 2468
  if (ev->type == 28) {
#line 2468
    goto case_28;
  }
#line 2584
  if (ev->type == 18) {
#line 2584
    goto case_18;
  }
#line 2589
  if (ev->type == 19) {
#line 2589
    goto case_19;
  }
#line 2622
  if (ev->type == 21) {
#line 2622
    goto case_21;
  }
#line 2661
  if (ev->type == 12) {
#line 2661
    goto case_12;
  }
#line 2661
  if (ev->type == 13) {
#line 2661
    goto case_12;
  }
#line 2688
  if (ev->type == 4) {
#line 2688
    goto case_4;
  }
#line 2862
  if (ev->type == 5) {
#line 2862
    goto case_5;
  }
#line 2934
  if (ev->type == 6) {
#line 2934
    goto case_6;
  }
#line 2332
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2334
  lookup_key(ev);
  }
#line 2335
  goto switch_break;
  case_17: /* CIL Label */ 
#line 2338
  if (ev->xdestroywindow.window == TermWin.vt) {
    {
#line 2345
    exit(0);
    }
  } else
#line 2338
  if (ev->xdestroywindow.window == TermWin.parent) {
    {
#line 2345
    exit(0);
    }
  }
#line 2347
  goto switch_break;
  case_33: /* CIL Label */ 
#line 2350
  if (ev->xclient.format == 32) {
#line 2350
    if ((Atom )ev->xclient.data.l[0] == wmDeleteWindow) {
      {
#line 2357
      exit(0);
      }
    }
  }
#line 2386
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 2389
  XRefreshKeyboardMapping(& ev->xmapping);
  }
#line 2390
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 2402
  if (ev->xvisibility.state == 0) {
#line 2402
    goto case_0;
  }
#line 2406
  if (ev->xvisibility.state == 1) {
#line 2406
    goto case_1;
  }
#line 2410
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2403
  refresh_type = 1 << 1;
#line 2404
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 2407
  refresh_type = 1 << 2;
#line 2408
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2411
  refresh_type = 0;
#line 2412
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2414
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2417
  if (! TermWin.focus) {
#line 2418
    TermWin.focus = (R_u_int16_t )1;
#line 2420
    if ((unsigned long )rs_fade != (unsigned long )((void *)0)) {
      {
#line 2422
      PixColors = & PixColorsFocused[0];
#line 2423
      on_colors_changed(1);
      }
    }
#line 2427
    if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
      {
#line 2428
      XSetICFocus(Input_Context);
      }
    }
  }
#line 2431
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2434
  if (TermWin.focus) {
#line 2435
    TermWin.focus = (R_u_int16_t )0;
#line 2437
    if ((unsigned long )rs_fade != (unsigned long )((void *)0)) {
      {
#line 2439
      PixColors = & PixColorsUnFocused[0];
#line 2440
      on_colors_changed(1);
      }
    }
#line 2444
    if ((unsigned long )Input_Context != (unsigned long )((void *)0)) {
      {
#line 2445
      XUnsetICFocus(Input_Context);
      }
    }
  }
#line 2448
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2451
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2451
    tmp = XCheckTypedWindowEvent(Xdisplay, ev->xconfigure.window, 22, ev);
    }
#line 2451
    if (! tmp) {
#line 2451
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2452
  resize_window(ev);
#line 2453
  menubar_expose();
  }
#line 2454
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 2457
  selection_clear();
  }
#line 2458
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 2461
  selection_paste(ev->xselection.requestor, (unsigned int )ev->xselection.property,
                  1);
  }
#line 2462
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 2465
  selection_send(& ev->xselectionrequest);
  }
#line 2466
  goto switch_break;
  case_28: /* CIL Label */ 
#line 2477
  if (ev->xproperty.window == (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root) {
#line 2507
    if (ev->xproperty.atom == _XROOTPMAP_ID) {
      {
#line 2509
      tmp___2 = IsTransparentPixmap();
      }
#line 2509
      if (tmp___2) {
        {
#line 2512
        tmp___0 = read_32bit_property((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                      _XROOTPMAP_ID, (CARD32 *)(& p));
        }
#line 2512
        if (tmp___0) {
#line 2514
          if (p != TermWin.background.srcPixmap) {
            {
#line 2515
            SetSrcPixmap(p);
            }
          }
        } else {
          {
#line 2517
          ValidateSrcPixmap(1);
          }
        }
        {
#line 2523
        tmp___1 = TransparentPixmapNeedsUpdate();
        }
#line 2523
        if (tmp___1) {
          {
#line 2524
          request_background_update();
          }
        }
      } else
#line 2525
      if (Options & (1UL << 13)) {
        {
#line 2527
        scr_clear_tint(1);
#line 2528
        scr_touch();
        }
      }
    }
#line 2532
    if (ev->xproperty.atom == _XA_NET_SUPPORTING_WM_CHECK) {
      {
#line 2534
      check_extended_wm_hints_support();
      }
    } else
#line 2538
    if (ev->xproperty.atom == _XA_NET_CURRENT_DESKTOP) {
      {
#line 2540
      tmp___3 = read_32bit_property((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                    _XA_NET_CURRENT_DESKTOP, & ExtWM.current_desktop);
      }
#line 2540
      if (tmp___3) {
#line 2542
        if (ExtWM.flags & (unsigned long )(1 << 4)) {
#line 2543
          ExtWM.flags |= 1UL;
        }
      } else {
#line 2541
        ExtWM.flags &= 0xfffffffffffffffeUL;
      }
    }
  }
#line 2555
  if (ev->xproperty.window == TermWin.parent) {
#line 2557
    if (ev->xproperty.atom == _XA_NET_WM_DESKTOP) {
      {
#line 2562
      tmp___4 = read_32bit_property(TermWin.parent, _XA_NET_WM_DESKTOP, & ExtWM.aterm_desktop);
      }
#line 2562
      if (! tmp___4) {
#line 2563
        ExtWM.flags &= 0xfffffffffffffffeUL;
      }
      {
#line 2567
      tmp___5 = TransparentPixmapNeedsUpdate();
      }
#line 2567
      if (tmp___5) {
        {
#line 2568
        request_background_update();
        }
      }
    } else
#line 2569
    if (ev->xproperty.atom == _XA_NET_WM_STATE) {
      {
#line 2571
      tmp___7 = check_extended_wm_state();
      }
#line 2571
      if (tmp___7) {
        {
#line 2572
        tmp___6 = TransparentPixmapNeedsUpdate();
        }
#line 2572
        if (tmp___6) {
          {
#line 2573
          request_background_update();
          }
        }
      }
    }
  }
#line 2583
  goto switch_break;
  case_18: /* CIL Label */ 
#line 2585
  TermWin.bMapped = 0;
#line 2587
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2599
  TermWin.bMapped = 1;
#line 2601
  tmp___8 = TransparentPixmapNeedsUpdate();
  }
#line 2601
  if (tmp___8) {
    {
#line 2602
    request_background_update();
    }
  }
#line 2621
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 2627
  tmp___9 = XSetErrorHandler(& pixmap_error_handler);
#line 2627
  oldXErrorHandler = tmp___9;
#line 2630
  n = 1;
  }
  {
#line 2630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2630
    if (! (n < 3)) {
#line 2630
      goto while_break___0;
    }
#line 2630
    ParentWin[n] = (Window )0L;
#line 2630
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2636
  ParentWinNum = 1;
  {
#line 2636
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2636
    if (! (ParentWinNum < 3)) {
#line 2636
      goto while_break___1;
    }
    {
#line 2642
    XQueryTree(Xdisplay, ParentWin[ParentWinNum - 1], & root, & parent, & list, (unsigned int *)(& n));
#line 2643
    XFree((void *)list);
    }
#line 2644
    if (parent == (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root) {
#line 2644
      goto while_break___1;
    }
#line 2645
    ParentWin[ParentWinNum] = parent;
#line 2649
    if (Options & (1UL << 13)) {
      {
#line 2650
      XSetWindowBackgroundPixmap(Xdisplay, parent, (Pixmap )1L);
      }
    }
#line 2636
    ParentWinNum ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2652
  tmp___10 = XGetWindowAttributes(Xdisplay, ParentWin[0], & attr);
  }
#line 2652
  if (tmp___10) {
#line 2653
    if (attr.map_state == 2) {
#line 2653
      TermWin.bMapped = 1;
    } else {
#line 2653
      TermWin.bMapped = 0;
    }
  }
  {
#line 2655
  XSetErrorHandler(oldXErrorHandler);
#line 2656
  scr_clear_tint(1);
  }
#line 2659
  goto switch_break;
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 2662
  if (ev->xany.window == TermWin.vt) {
    {
#line 2667
    scr_expose(ev->xexpose.x, ev->xexpose.y, ev->xexpose.width, ev->xexpose.height);
    }
  } else {
    {
#line 2672
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2672
      tmp___11 = XCheckTypedWindowEvent(Xdisplay, ev->xany.window, 12, & unused_xevent);
      }
#line 2672
      if (! tmp___11) {
#line 2672
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2675
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 2675
      tmp___12 = XCheckTypedWindowEvent(Xdisplay, ev->xany.window, 13, & unused_xevent);
      }
#line 2675
      if (! tmp___12) {
#line 2675
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2678
    if (scrollBar.state) {
#line 2678
      if (ev->xany.window == scrollBar.win) {
        {
#line 2679
        scrollBar.state = (short)1;
#line 2680
        scrollbar_show(0);
        }
      }
    }
    {
#line 2684
    Gr_expose(ev->xany.window);
    }
  }
#line 2686
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2689
  bypass_keystate = (int )(ev->xbutton.state & (unsigned int )((1 << 3) | 1));
#line 2690
  if (bypass_keystate) {
#line 2690
    reportmode = 0;
  } else {
#line 2690
    reportmode = (int )(PrivateModes & ((1UL << 12) | (1UL << 13)));
  }
#line 2693
  if (ev->xany.window == TermWin.vt) {
#line 2694
    if (ev->xbutton.subwindow != 0UL) {
      {
#line 2695
      Gr_ButtonReport('P', ev->xbutton.x, ev->xbutton.y);
      }
    } else {
#line 2697
      if (reportmode) {
        {
#line 2700
        MEvent.state = ev->xbutton.state;
#line 2722
        MEvent.button = ev->xbutton.button;
#line 2723
        mouse_report(& ev->xbutton);
        }
      } else {
#line 2726
        if (ev->xbutton.button != MEvent.button) {
#line 2727
          MEvent.clicks = 0;
        }
        {
#line 2729
        if (ev->xbutton.button == 1U) {
#line 2729
          goto case_1___0;
        }
#line 2740
        if (ev->xbutton.button == 3U) {
#line 2740
          goto case_3;
        }
#line 2728
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
#line 2730
        if (MEvent.button == 1U) {
#line 2730
          if (ev->xbutton.time - MEvent.time < 500UL) {
#line 2732
            (MEvent.clicks) ++;
          } else {
#line 2734
            MEvent.clicks = 1;
          }
        } else {
#line 2734
          MEvent.clicks = 1;
        }
        {
#line 2735
        selection_click(MEvent.clicks, ev->xbutton.x, ev->xbutton.y);
#line 2737
        MEvent.button = 1U;
        }
#line 2738
        goto switch_break___1;
        case_3: /* CIL Label */ 
#line 2741
        if (MEvent.button == 3U) {
#line 2741
          if (ev->xbutton.time - MEvent.time < 500UL) {
            {
#line 2743
            selection_rotate(ev->xbutton.x, ev->xbutton.y);
            }
          } else {
            {
#line 2745
            selection_extend(ev->xbutton.x, ev->xbutton.y, 1);
            }
          }
        } else {
          {
#line 2745
          selection_extend(ev->xbutton.x, ev->xbutton.y, 1);
          }
        }
#line 2746
        MEvent.button = 3U;
#line 2747
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 2750
      MEvent.time = ev->xbutton.time;
#line 2751
      return;
    }
  }
#line 2754
  if (scrollBar.state) {
#line 2754
    if (ev->xany.window == scrollBar.win) {
#line 2755
      scrollBar.state = (short)1;
#line 2767
      if (reportmode) {
#line 2773
        if (ev->xbutton.y > (int )scrollBar.end) {
#line 2773
          if (ev->xbutton.y <= (int )scrollBar.end + 18) {
            {
#line 2774
            tt_printf((unsigned char const   *)((unsigned char *)"\033[A"));
            }
          } else {
#line 2773
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2775
        if (ev->xbutton.y > (int )scrollBar.end + 18) {
          {
#line 2776
          tt_printf((unsigned char const   *)((unsigned char *)"\033[B"));
          }
        } else {
          {
#line 2779
          if (ev->xbutton.button == 2U) {
#line 2779
            goto case_2___0;
          }
#line 2782
          if (ev->xbutton.button == 1U) {
#line 2782
            goto case_1___1;
          }
#line 2785
          if (ev->xbutton.button == 3U) {
#line 2785
            goto case_3___0;
          }
#line 2778
          goto switch_break___2;
          case_2___0: /* CIL Label */ 
          {
#line 2780
          tt_printf((unsigned char const   *)((unsigned char *)"\f"));
          }
#line 2781
          goto switch_break___2;
          case_1___1: /* CIL Label */ 
          {
#line 2783
          tt_printf((unsigned char const   *)((unsigned char *)"\033[6~"));
          }
#line 2784
          goto switch_break___2;
          case_3___0: /* CIL Label */ 
          {
#line 2786
          tt_printf((unsigned char const   *)((unsigned char *)"\033[5~"));
          }
#line 2787
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      } else
#line 2792
      if (ev->xbutton.y > (int )scrollBar.end) {
#line 2792
        if (ev->xbutton.y <= (int )scrollBar.end + 18) {
          {
#line 2794
          scroll_arrow_delay = 40;
#line 2796
          tmp___13 = scr_page(0, 1);
          }
#line 2796
          if (tmp___13) {
#line 2797
            scrollBar.state = (short )'U';
          }
        } else {
#line 2792
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2798
      if (ev->xbutton.y > (int )scrollBar.end + 18) {
        {
#line 2800
        scroll_arrow_delay = 40;
#line 2802
        tmp___14 = scr_page(1, 1);
        }
#line 2802
        if (tmp___14) {
#line 2803
          scrollBar.state = (short )'D';
        }
      } else {
        {
#line 2806
        if (ev->xbutton.button == 2U) {
#line 2806
          goto case_2___1;
        }
#line 2821
        if (ev->xbutton.button == 1U) {
#line 2821
          goto case_1___2;
        }
#line 2828
        if (ev->xbutton.button == 3U) {
#line 2828
          goto case_3___1;
        }
#line 2805
        goto switch_break___3;
        case_2___1: /* CIL Label */ 
        {
#line 2808
        csrO = ((int )scrollBar.bot - (int )scrollBar.top) / 2;
#line 2816
        scr_move_to((ev->xbutton.y - (int )scrollBar.beg) - csrO, (int )scrollBar.end - (int )scrollBar.beg);
#line 2818
        scrollBar.state = (short )'m';
        }
#line 2819
        goto switch_break___3;
        case_1___2: /* CIL Label */ 
#line 2823
        csrO = ev->xbutton.y - (int )scrollBar.top;
        case_3___1: /* CIL Label */ 
#line 2830
        if (ev->xbutton.y < (int )scrollBar.top) {
          {
#line 2832
          scr_page(0, (int )TermWin.nrow - 1);
          }
        } else
#line 2836
        if (ev->xbutton.y > (int )scrollBar.bot) {
          {
#line 2838
          scr_page(1, (int )TermWin.nrow - 1);
          }
        } else {
#line 2843
          scrollBar.state = (short )'m';
        }
#line 2851
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
      }
#line 2854
      return;
    }
  }
#line 2860
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2863
  csrO = 0;
#line 2864
  if (bypass_keystate) {
#line 2864
    reportmode = 0;
  } else {
#line 2864
    reportmode = (int )(PrivateModes & ((1UL << 12) | (1UL << 13)));
  }
  {
#line 2867
  tmp___15 = __ctype_b_loc();
  }
#line 2867
  if ((int const   )*(*tmp___15 + (int )scrollBar.state) & 256) {
    {
#line 2868
    scrollBar.state = (short)1;
#line 2869
    scrollbar_show(0);
#line 2871
    refresh_type &= ~ (1 << 3);
    }
  }
#line 2874
  if (ev->xany.window == TermWin.vt) {
#line 2875
    if (ev->xbutton.subwindow != 0UL) {
      {
#line 2876
      Gr_ButtonReport('R', ev->xbutton.x, ev->xbutton.y);
      }
    } else {
#line 2878
      if (reportmode) {
#line 2880
        if (ev->xbutton.button == 4U) {
#line 2881
          return;
        } else
#line 2880
        if (ev->xbutton.button == 5U) {
#line 2881
          return;
        }
        {
#line 2894
        MEvent.button = 0U;
#line 2895
        mouse_report(& ev->xbutton);
        }
#line 2897
        return;
      }
#line 2903
      if (PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 2903
        if (bypass_keystate) {
#line 2903
          if (ev->xbutton.button == 1U) {
#line 2903
            if (MEvent.clicks <= 1) {
              {
#line 2907
              selection_extend(ev->xbutton.x, ev->xbutton.y, 0);
              }
            }
          }
        }
      }
      {
#line 2911
      if (ev->xbutton.button == 3U) {
#line 2911
        goto case_3___2;
      }
#line 2911
      if (ev->xbutton.button == 1U) {
#line 2911
        goto case_3___2;
      }
#line 2915
      if (ev->xbutton.button == 2U) {
#line 2915
        goto case_2___2;
      }
#line 2920
      if (ev->xbutton.button == 4U) {
#line 2920
        goto case_4___0;
      }
#line 2923
      if (ev->xbutton.button == 5U) {
#line 2923
        goto case_5___0;
      }
#line 2909
      goto switch_break___4;
      case_3___2: /* CIL Label */ 
      case_1___3: /* CIL Label */ 
      {
#line 2912
      selection_make(ev->xbutton.time, ev->xbutton.state);
      }
#line 2913
      goto switch_break___4;
      case_2___2: /* CIL Label */ 
      {
#line 2916
      selection_request(ev->xbutton.time, ev->xbutton.x, ev->xbutton.y);
      }
#line 2918
      goto switch_break___4;
      case_4___0: /* CIL Label */ 
#line 2921
      if (ev->xbutton.state & 1U) {
#line 2921
        tmp___16 = 1;
      } else {
#line 2921
        tmp___16 = 5;
      }
      {
#line 2921
      scr_page(0, tmp___16);
      }
#line 2922
      goto switch_break___4;
      case_5___0: /* CIL Label */ 
#line 2924
      if (ev->xbutton.state & 1U) {
#line 2924
        tmp___17 = 1;
      } else {
#line 2924
        tmp___17 = 5;
      }
      {
#line 2924
      scr_page(1, tmp___17);
      }
#line 2925
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
    }
  }
#line 2932
  goto switch_break;
  case_6: /* CIL Label */ ;
#line 2939
  if (PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 2939
    if (! bypass_keystate) {
#line 2940
      goto switch_break;
    }
  }
#line 2942
  if (ev->xany.window == TermWin.vt) {
#line 2943
    if (ev->xbutton.state & (unsigned int )((1 << 8) | (1 << 10))) {
      {
#line 2948
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2948
        tmp___18 = XCheckTypedWindowEvent(Xdisplay, TermWin.vt, 6, ev);
        }
#line 2948
        if (! tmp___18) {
#line 2948
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2950
      XQueryPointer(Xdisplay, TermWin.vt, & unused_root, & unused_child, & unused_root_x,
                    & unused_root_y, & ev->xbutton.x, & ev->xbutton.y, & unused_mask);
      }
#line 2957
      if (ev->xmotion.time - MEvent.time > 50UL) {
#line 2959
        if (ev->xbutton.state & (unsigned int )(1 << 10)) {
#line 2959
          tmp___19 = 2;
        } else {
#line 2959
          tmp___19 = 0;
        }
        {
#line 2959
        selection_extend(ev->xbutton.x, ev->xbutton.y, tmp___19);
        }
      }
    }
  } else
#line 2962
  if (ev->xany.window == scrollBar.win) {
#line 2962
    if ((int )scrollBar.state == 109) {
      {
#line 2967
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2967
        tmp___20 = XCheckTypedWindowEvent(Xdisplay, scrollBar.win, 6, ev);
        }
#line 2967
        if (! tmp___20) {
#line 2967
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2969
      XQueryPointer(Xdisplay, scrollBar.win, & unused_root___0, & unused_child___0,
                    & unused_root_x___0, & unused_root_y___0, & ev->xbutton.x, & ev->xbutton.y,
                    & unused_mask___0);
#line 2974
      scr_move_to((ev->xbutton.y - (int )scrollBar.beg) - csrO, (int )scrollBar.end - (int )scrollBar.beg);
#line 2976
      scr_refresh(refresh_type);
#line 2977
      refresh_limit = 0;
#line 2977
      refresh_count = refresh_limit;
#line 2978
      scrollbar_show(1);
      }
    }
  }
#line 2983
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2985
  return;
}
}
#line 2996 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
static unsigned char buf[1024]  ;
#line 2993 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void tt_printf(unsigned char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  size_t tmp ;

  {
  {
#line 2999
  __builtin_va_start(arg_ptr, fmt);
#line 3000
  vsprintf((char */* __restrict  */)((char *)(buf)), (char const   */* __restrict  */)((char *)fmt),
           arg_ptr);
#line 3001
  __builtin_va_end(arg_ptr);
#line 3002
  tmp = strlen((char const   *)(buf));
#line 3002
  tt_write((unsigned char const   *)(buf), (int )tmp);
  }
#line 3003
  return;
}
}
#line 3088 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_escape_seq(void) 
{ 
  unsigned char ch ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
  {
#line 3091
  tmp = cmd_getc();
#line 3091
  ch = tmp;
  }
  {
#line 3095
  if ((int )ch == 35) {
#line 3095
    goto case_35;
  }
#line 3099
  if ((int )ch == 40) {
#line 3099
    goto case_40;
  }
#line 3102
  if ((int )ch == 41) {
#line 3102
    goto case_41;
  }
#line 3105
  if ((int )ch == 42) {
#line 3105
    goto case_42;
  }
#line 3108
  if ((int )ch == 43) {
#line 3108
    goto case_43;
  }
#line 3116
  if ((int )ch == 55) {
#line 3116
    goto case_55;
  }
#line 3119
  if ((int )ch == 56) {
#line 3119
    goto case_56;
  }
#line 3123
  if ((int )ch == 62) {
#line 3123
    goto case_62;
  }
#line 3123
  if ((int )ch == 61) {
#line 3123
    goto case_62;
  }
#line 3126
  if ((int )ch == 64) {
#line 3126
    goto case_64;
  }
#line 3129
  if ((int )ch == 68) {
#line 3129
    goto case_68;
  }
#line 3132
  if ((int )ch == 69) {
#line 3132
    goto case_69;
  }
#line 3135
  if ((int )ch == 71) {
#line 3135
    goto case_71;
  }
#line 3138
  if ((int )ch == 72) {
#line 3138
    goto case_72;
  }
#line 3141
  if ((int )ch == 77) {
#line 3141
    goto case_77;
  }
#line 3146
  if ((int )ch == 90) {
#line 3146
    goto case_90;
  }
#line 3149
  if ((int )ch == 91) {
#line 3149
    goto case_91;
  }
#line 3152
  if ((int )ch == 93) {
#line 3152
    goto case_93;
  }
#line 3155
  if ((int )ch == 99) {
#line 3155
    goto case_99;
  }
#line 3158
  if ((int )ch == 110) {
#line 3158
    goto case_110;
  }
#line 3161
  if ((int )ch == 111) {
#line 3161
    goto case_111;
  }
#line 3093
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 3096
  tmp___0 = cmd_getc();
  }
#line 3096
  if ((int )tmp___0 == 56) {
    {
#line 3097
    scr_E();
    }
  }
#line 3098
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 3100
  tmp___1 = cmd_getc();
#line 3100
  scr_charset_set(0, (unsigned int )tmp___1);
  }
#line 3101
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 3103
  tmp___2 = cmd_getc();
#line 3103
  scr_charset_set(1, (unsigned int )tmp___2);
  }
#line 3104
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 3106
  tmp___3 = cmd_getc();
#line 3106
  scr_charset_set(2, (unsigned int )tmp___3);
  }
#line 3107
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 3109
  tmp___4 = cmd_getc();
#line 3109
  scr_charset_set(3, (unsigned int )tmp___4);
  }
#line 3110
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 3117
  scr_cursor('s');
  }
#line 3118
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 3120
  scr_cursor('r');
  }
#line 3121
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  {
#line 3124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3124
    if ((int )ch == 61) {
#line 3124
      PrivateModes |= 1UL << 7;
    } else {
#line 3124
      PrivateModes &= ~ (1UL << 7);
    }
#line 3124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3125
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 3127
  cmd_getc();
  }
#line 3128
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 3130
  scr_index(0);
  }
#line 3131
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 3133
  scr_add_lines((unsigned char const   *)((unsigned char *)"\n\r"), 1, 2);
  }
#line 3134
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 3136
  process_graphics();
  }
#line 3137
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 3139
  scr_set_tab(1);
  }
#line 3140
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 3142
  scr_index(1);
  }
#line 3143
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 3147
  tt_printf((unsigned char const   *)((unsigned char *)"\033[?1;2c"));
  }
#line 3148
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 3150
  process_csi_seq();
  }
#line 3151
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 3153
  process_xterm_seq();
  }
#line 3154
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 3156
  scr_poweron();
  }
#line 3157
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 3159
  scr_charset_choose(2);
  }
#line 3160
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 3162
  scr_charset_choose(3);
  }
#line 3163
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3165
  return;
}
}
#line 3170 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_csi_seq(void) 
{ 
  unsigned char ch ;
  unsigned char priv ;
  unsigned int nargs ;
  int arg[32] ;
  int n ;
  unsigned short const   **tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 3177
  nargs = 0U;
#line 3178
  arg[0] = 0;
#line 3179
  arg[1] = 0;
#line 3181
  priv = (unsigned char)0;
#line 3182
  ch = cmd_getc();
  }
#line 3183
  if ((int )ch >= 60) {
#line 3183
    if ((int )ch <= 63) {
      {
#line 3184
      priv = ch;
#line 3185
      ch = cmd_getc();
      }
    }
  }
  {
#line 3188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3191
    n = 0;
    {
#line 3191
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3191
      tmp = __ctype_b_loc();
      }
#line 3191
      if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 3191
        goto while_break___0;
      }
      {
#line 3192
      n = n * 10 + ((int )ch - 48);
#line 3191
      ch = cmd_getc();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3194
    if (nargs < 32U) {
#line 3195
      tmp___0 = nargs;
#line 3195
      nargs ++;
#line 3195
      arg[tmp___0] = n;
    }
#line 3196
    if ((int )ch == 8) {
      {
#line 3197
      scr_backspace();
      }
    } else
#line 3198
    if ((int )ch == 27) {
      {
#line 3199
      process_escape_seq();
      }
#line 3200
      return;
    } else
#line 3201
    if ((int )ch < 32) {
      {
#line 3202
      scr_add_lines((unsigned char const   *)(& ch), 0, 1);
      }
#line 3203
      return;
    }
#line 3205
    if ((int )ch < 64) {
      {
#line 3206
      ch = cmd_getc();
      }
    }
#line 3188
    if ((int )ch >= 32) {
#line 3188
      if (! ((int )ch < 64)) {
#line 3188
        goto while_break;
      }
    } else {
#line 3188
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3209
  if ((int )ch == 27) {
    {
#line 3210
    process_escape_seq();
    }
#line 3211
    return;
  } else
#line 3212
  if ((int )ch < 32) {
#line 3213
    return;
  }
  {
#line 3229
  if ((int )ch == 101) {
#line 3229
    goto case_101;
  }
#line 3229
  if ((int )ch == 65) {
#line 3229
    goto case_101;
  }
#line 3232
  if ((int )ch == 66) {
#line 3232
    goto case_66;
  }
#line 3236
  if ((int )ch == 97) {
#line 3236
    goto case_97;
  }
#line 3236
  if ((int )ch == 67) {
#line 3236
    goto case_97;
  }
#line 3239
  if ((int )ch == 68) {
#line 3239
    goto case_68;
  }
#line 3242
  if ((int )ch == 69) {
#line 3242
    goto case_69;
  }
#line 3245
  if ((int )ch == 70) {
#line 3245
    goto case_70;
  }
#line 3249
  if ((int )ch == 96) {
#line 3249
    goto case_96;
  }
#line 3249
  if ((int )ch == 71) {
#line 3249
    goto case_96;
  }
#line 3252
  if ((int )ch == 100) {
#line 3252
    goto case_100;
  }
#line 3256
  if ((int )ch == 102) {
#line 3256
    goto case_102;
  }
#line 3256
  if ((int )ch == 72) {
#line 3256
    goto case_102;
  }
#line 3269
  if ((int )ch == 73) {
#line 3269
    goto case_73;
  }
#line 3272
  if ((int )ch == 90) {
#line 3272
    goto case_90;
  }
#line 3275
  if ((int )ch == 74) {
#line 3275
    goto case_74;
  }
#line 3278
  if ((int )ch == 75) {
#line 3278
    goto case_75;
  }
#line 3281
  if ((int )ch == 64) {
#line 3281
    goto case_64;
  }
#line 3284
  if ((int )ch == 76) {
#line 3284
    goto case_76;
  }
#line 3287
  if ((int )ch == 77) {
#line 3287
    goto case_77;
  }
#line 3290
  if ((int )ch == 88) {
#line 3290
    goto case_88;
  }
#line 3293
  if ((int )ch == 80) {
#line 3293
    goto case_80;
  }
#line 3297
  if ((int )ch == 99) {
#line 3297
    goto case_99;
  }
#line 3300
  if ((int )ch == 109) {
#line 3300
    goto case_109;
  }
#line 3303
  if ((int )ch == 110) {
#line 3303
    goto case_110;
  }
#line 3322
  if ((int )ch == 114) {
#line 3322
    goto case_114;
  }
#line 3332
  if ((int )ch == 116) {
#line 3332
    goto case_116;
  }
#line 3332
  if ((int )ch == 115) {
#line 3332
    goto case_116;
  }
#line 3337
  if ((int )ch == 108) {
#line 3337
    goto case_108;
  }
#line 3337
  if ((int )ch == 104) {
#line 3337
    goto case_108;
  }
#line 3340
  if ((int )ch == 103) {
#line 3340
    goto case_103;
  }
#line 3350
  if ((int )ch == 87) {
#line 3350
    goto case_87;
  }
#line 3215
  goto switch_break;
  case_101: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 3230
  if (arg[0]) {
#line 3230
    tmp___1 = - arg[0];
  } else {
#line 3230
    tmp___1 = -1;
  }
  {
#line 3230
  scr_gotorc(tmp___1, 0, 3);
  }
#line 3231
  goto switch_break;
  case_66: /* CIL Label */ 
#line 3233
  if (arg[0]) {
#line 3233
    tmp___2 = arg[0];
  } else {
#line 3233
    tmp___2 = 1;
  }
  {
#line 3233
  scr_gotorc(tmp___2, 0, 3);
  }
#line 3234
  goto switch_break;
  case_97: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 3237
  if (arg[0]) {
#line 3237
    tmp___3 = arg[0];
  } else {
#line 3237
    tmp___3 = 1;
  }
  {
#line 3237
  scr_gotorc(0, tmp___3, 3);
  }
#line 3238
  goto switch_break;
  case_68: /* CIL Label */ 
#line 3240
  if (arg[0]) {
#line 3240
    tmp___4 = - arg[0];
  } else {
#line 3240
    tmp___4 = -1;
  }
  {
#line 3240
  scr_gotorc(0, tmp___4, 3);
  }
#line 3241
  goto switch_break;
  case_69: /* CIL Label */ 
#line 3243
  if (arg[0]) {
#line 3243
    tmp___5 = arg[0];
  } else {
#line 3243
    tmp___5 = 1;
  }
  {
#line 3243
  scr_gotorc(tmp___5, 0, 2);
  }
#line 3244
  goto switch_break;
  case_70: /* CIL Label */ 
#line 3246
  if (arg[0]) {
#line 3246
    tmp___6 = - arg[0];
  } else {
#line 3246
    tmp___6 = -1;
  }
  {
#line 3246
  scr_gotorc(tmp___6, 0, 2);
  }
#line 3247
  goto switch_break;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 3250
  if (arg[0]) {
#line 3250
    tmp___7 = arg[0] - 1;
  } else {
#line 3250
    tmp___7 = 1;
  }
  {
#line 3250
  scr_gotorc(0, tmp___7, 2);
  }
#line 3251
  goto switch_break;
  case_100: /* CIL Label */ 
#line 3253
  if (arg[0]) {
#line 3253
    tmp___8 = arg[0] - 1;
  } else {
#line 3253
    tmp___8 = 1;
  }
  {
#line 3253
  scr_gotorc(tmp___8, 0, 1);
  }
#line 3254
  goto switch_break;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
  {
#line 3258
  if (nargs == 0U) {
#line 3258
    goto case_0;
  }
#line 3261
  if (nargs == 1U) {
#line 3261
    goto case_1;
  }
#line 3264
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 3259
  scr_gotorc(0, 0, 0);
  }
#line 3260
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 3262
  if (arg[0]) {
#line 3262
    tmp___9 = arg[0] - 1;
  } else {
#line 3262
    tmp___9 = 0;
  }
  {
#line 3262
  scr_gotorc(tmp___9, 0, 0);
  }
#line 3263
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 3265
  scr_gotorc(arg[0] - 1, arg[1] - 1, 0);
  }
#line 3266
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3268
  goto switch_break;
  case_73: /* CIL Label */ 
#line 3270
  if (arg[0]) {
#line 3270
    tmp___10 = arg[0];
  } else {
#line 3270
    tmp___10 = 1;
  }
  {
#line 3270
  scr_tab(tmp___10);
  }
#line 3271
  goto switch_break;
  case_90: /* CIL Label */ 
#line 3273
  if (arg[0]) {
#line 3273
    tmp___11 = - arg[0];
  } else {
#line 3273
    tmp___11 = -1;
  }
  {
#line 3273
  scr_tab(tmp___11);
  }
#line 3274
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 3276
  scr_erase_screen(arg[0]);
  }
#line 3277
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 3279
  scr_erase_line(arg[0]);
  }
#line 3280
  goto switch_break;
  case_64: /* CIL Label */ 
#line 3282
  if (arg[0]) {
#line 3282
    tmp___12 = arg[0];
  } else {
#line 3282
    tmp___12 = 1;
  }
  {
#line 3282
  scr_insdel_chars(tmp___12, -1);
  }
#line 3283
  goto switch_break;
  case_76: /* CIL Label */ 
#line 3285
  if (arg[0]) {
#line 3285
    tmp___13 = arg[0];
  } else {
#line 3285
    tmp___13 = 1;
  }
  {
#line 3285
  scr_insdel_lines(tmp___13, -1);
  }
#line 3286
  goto switch_break;
  case_77: /* CIL Label */ 
#line 3288
  if (arg[0]) {
#line 3288
    tmp___14 = arg[0];
  } else {
#line 3288
    tmp___14 = 1;
  }
  {
#line 3288
  scr_insdel_lines(tmp___14, 1);
  }
#line 3289
  goto switch_break;
  case_88: /* CIL Label */ 
#line 3291
  if (arg[0]) {
#line 3291
    tmp___15 = arg[0];
  } else {
#line 3291
    tmp___15 = 1;
  }
  {
#line 3291
  scr_insdel_chars(tmp___15, 2);
  }
#line 3292
  goto switch_break;
  case_80: /* CIL Label */ 
#line 3294
  if (arg[0]) {
#line 3294
    tmp___16 = arg[0];
  } else {
#line 3294
    tmp___16 = 1;
  }
  {
#line 3294
  scr_insdel_chars(tmp___16, 1);
  }
#line 3295
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 3298
  tt_printf((unsigned char const   *)((unsigned char *)"\033[?1;2c"));
  }
#line 3299
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 3301
  process_sgr_mode(nargs, arg);
  }
#line 3302
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 3305
  if (arg[0] == 5) {
#line 3305
    goto case_5;
  }
#line 3308
  if (arg[0] == 6) {
#line 3308
    goto case_6;
  }
#line 3317
  if (arg[0] == 8) {
#line 3317
    goto case_8;
  }
#line 3304
  goto switch_break___1;
  case_5: /* CIL Label */ 
  {
#line 3306
  tt_printf((unsigned char const   *)((unsigned char *)"\033[0n"));
  }
#line 3307
  goto switch_break___1;
  case_6: /* CIL Label */ 
  {
#line 3309
  scr_report_position();
  }
#line 3310
  goto switch_break___1;
  case_8: /* CIL Label */ 
  {
#line 3318
  xterm_seq(2, "aterm-1.00.01");
  }
#line 3319
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 3321
  goto switch_break;
  case_114: /* CIL Label */ 
#line 3323
  if ((int )priv != 63) {
#line 3324
    if (nargs < 2U) {
      {
#line 3325
      scr_scroll_region(0, 10000);
      }
    } else
#line 3324
    if (arg[0] >= arg[1]) {
      {
#line 3325
      scr_scroll_region(0, 10000);
      }
    } else {
      {
#line 3327
      scr_scroll_region(arg[0] - 1, arg[1] - 1);
      }
    }
#line 3328
    goto switch_break;
  }
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 3333
  if (arg[0] == 21) {
    {
#line 3334
    tt_printf((unsigned char const   *)((unsigned char *)"\033]l%s\033\\"), rs_title);
    }
  }
#line 3335
  goto switch_break;
  case_108: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 3338
  process_terminal_mode((int )ch, (int )priv, nargs, arg);
  }
#line 3339
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 3342
  if (arg[0] == 0) {
#line 3342
    goto case_0___0;
  }
#line 3345
  if (arg[0] == 3) {
#line 3345
    goto case_3;
  }
#line 3341
  goto switch_break___2;
  case_0___0: /* CIL Label */ 
  {
#line 3343
  scr_set_tab(0);
  }
#line 3344
  goto switch_break___2;
  case_3: /* CIL Label */ 
  {
#line 3346
  scr_set_tab(-1);
  }
#line 3347
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 3349
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 3352
  if (arg[0] == 0) {
#line 3352
    goto case_0___1;
  }
#line 3355
  if (arg[0] == 2) {
#line 3355
    goto case_2;
  }
#line 3358
  if (arg[0] == 5) {
#line 3358
    goto case_5___0;
  }
#line 3351
  goto switch_break___3;
  case_0___1: /* CIL Label */ 
  {
#line 3353
  scr_set_tab(1);
  }
#line 3354
  goto switch_break___3;
  case_2: /* CIL Label */ 
  {
#line 3356
  scr_set_tab(0);
  }
#line 3357
  goto switch_break___3;
  case_5___0: /* CIL Label */ 
  {
#line 3359
  scr_set_tab(-1);
  }
#line 3360
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 3362
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3364
  return;
}
}
#line 3369 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_xterm_seq(void) 
{ 
  unsigned char ch ;
  unsigned char string[512] ;
  int arg ;
  unsigned short const   **tmp ;
  int n ;
  int tmp___0 ;

  {
  {
#line 3375
  ch = cmd_getc();
#line 3376
  arg = 0;
  }
  {
#line 3376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3376
    tmp = __ctype_b_loc();
    }
#line 3376
    if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 3376
      goto while_break;
    }
    {
#line 3377
    arg = arg * 10 + ((int )ch - 48);
#line 3376
    ch = cmd_getc();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3379
  if ((int )ch == 59) {
#line 3380
    n = 0;
    {
#line 3382
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3382
      ch = cmd_getc();
      }
#line 3382
      if (! ((int )ch != 7)) {
#line 3382
        goto while_break___0;
      }
#line 3383
      if (ch) {
#line 3384
        if ((int )ch == 9) {
#line 3385
          ch = (unsigned char )' ';
        } else
#line 3386
        if ((int )ch < 32) {
#line 3387
          return;
        }
#line 3389
        if ((unsigned long )n < sizeof(string) - 1UL) {
#line 3390
          tmp___0 = n;
#line 3390
          n ++;
#line 3390
          string[tmp___0] = ch;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3393
    string[n] = (unsigned char )'\000';
#line 3398
    if (arg == 10) {
      {
#line 3399
      menubar_dispatch((char *)(string));
      }
    } else {
      {
#line 3401
      xterm_seq(arg, (char const   *)((char *)(string)));
      }
    }
  }
#line 3403
  return;
}
}
#line 3417 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_terminal_mode(int mode , int priv , unsigned int nargs , int *arg ) 
{ 
  unsigned int i ;
  int state ;
  int tmp ;

  {
#line 3423
  if (nargs == 0U) {
#line 3424
    return;
  }
  {
#line 3428
  if (mode == 108) {
#line 3428
    goto case_108;
  }
#line 3431
  if (mode == 104) {
#line 3431
    goto case_104;
  }
#line 3427
  goto switch_break;
  case_108: /* CIL Label */ 
#line 3429
  mode = 0;
#line 3430
  goto switch_break;
  case_104: /* CIL Label */ 
#line 3432
  mode = 1;
#line 3433
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3437
  if (priv == 0) {
#line 3437
    goto case_0;
  }
#line 3466
  if (priv == 63) {
#line 3466
    goto case_63;
  }
#line 3436
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 3438
  if (mode) {
#line 3438
    if (mode != 1) {
#line 3439
      return;
    }
  }
#line 3440
  i = 0U;
  {
#line 3440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3440
    if (! (i < nargs)) {
#line 3440
      goto while_break;
    }
    {
#line 3442
    if (*(arg + i) == 4) {
#line 3442
      goto case_4;
    }
#line 3441
    goto switch_break___1;
    case_4: /* CIL Label */ 
    {
#line 3443
    scr_insert_mode(mode);
    }
#line 3444
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 3440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3447
  goto switch_break___0;
  case_63: /* CIL Label */ 
#line 3467
  i = 0U;
  {
#line 3467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3467
    if (! (i < nargs)) {
#line 3467
      goto while_break___0;
    }
    {
#line 3469
    if (*(arg + i) == 1) {
#line 3469
      goto case_1;
    }
#line 3475
    if (*(arg + i) == 3) {
#line 3475
      goto case_3;
    }
#line 3483
    if (*(arg + i) == 5) {
#line 3483
      goto case_5;
    }
#line 3488
    if (*(arg + i) == 6) {
#line 3488
      goto case_6;
    }
#line 3493
    if (*(arg + i) == 7) {
#line 3493
      goto case_7;
    }
#line 3500
    if (*(arg + i) == 9) {
#line 3500
      goto case_9;
    }
#line 3507
    if (*(arg + i) == 10) {
#line 3507
      goto case_10;
    }
#line 3513
    if (*(arg + i) == 30) {
#line 3513
      goto case_30;
    }
#line 3518
    if (*(arg + i) == 25) {
#line 3518
      goto case_25;
    }
#line 3523
    if (*(arg + i) == 35) {
#line 3523
      goto case_35;
    }
#line 3527
    if (*(arg + i) == 40) {
#line 3527
      goto case_40;
    }
#line 3531
    if (*(arg + i) == 47) {
#line 3531
      goto case_47;
    }
#line 3536
    if (*(arg + i) == 66) {
#line 3536
      goto case_66;
    }
#line 3540
    if (*(arg + i) == 67) {
#line 3540
      goto case_67;
    }
#line 3548
    if (*(arg + i) == 1000) {
#line 3548
      goto case_1000;
    }
#line 3558
    if (*(arg + i) == 1010) {
#line 3558
      goto case_1010;
    }
#line 3565
    if (*(arg + i) == 1011) {
#line 3565
      goto case_1011;
    }
#line 3468
    goto switch_break___2;
    case_1: /* CIL Label */ 
#line 3470
    if (mode == 116) {
#line 3470
      state = ! (PrivateModes & (1UL << 6));
    } else {
#line 3470
      state = mode;
    }
    {
#line 3470
    if (state == 115) {
#line 3470
      goto case_115;
    }
#line 3470
    if (state == 114) {
#line 3470
      goto case_114;
    }
#line 3470
    goto switch_default;
    case_115: /* CIL Label */ 
#line 3470
    SavedModes |= PrivateModes & (1UL << 6);
#line 3470
    goto __Cont;
#line 3470
    goto switch_break___3;
    case_114: /* CIL Label */ 
#line 3470
    if (SavedModes & (1UL << 6)) {
#line 3470
      state = 1;
    } else {
#line 3470
      state = 0;
    }
    switch_default: /* CIL Label */ 
    {
#line 3470
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3470
      if (state) {
#line 3470
        PrivateModes |= 1UL << 6;
      } else {
#line 3470
        PrivateModes &= ~ (1UL << 6);
      }
#line 3470
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 3471
    goto switch_break___2;
    case_3: /* CIL Label */ 
#line 3476
    if (mode == 116) {
#line 3476
      state = ! (PrivateModes & 1UL);
    } else {
#line 3476
      state = mode;
    }
    {
#line 3476
    if (state == 115) {
#line 3476
      goto case_115___0;
    }
#line 3476
    if (state == 114) {
#line 3476
      goto case_114___0;
    }
#line 3476
    goto switch_default___0;
    case_115___0: /* CIL Label */ 
#line 3476
    SavedModes |= PrivateModes & 1UL;
#line 3476
    goto __Cont;
#line 3476
    goto switch_break___4;
    case_114___0: /* CIL Label */ 
#line 3476
    if (SavedModes & 1UL) {
#line 3476
      state = 1;
    } else {
#line 3476
      state = 0;
    }
    switch_default___0: /* CIL Label */ 
    {
#line 3476
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3476
      if (state) {
#line 3476
        PrivateModes |= 1UL;
      } else {
#line 3476
        PrivateModes &= 0xfffffffffffffffeUL;
      }
#line 3476
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 3477
    if (PrivateModes & (1UL << 1)) {
#line 3478
      if (state) {
#line 3478
        tmp = 132;
      } else {
#line 3478
        tmp = 80;
      }
      {
#line 3478
      set_width((unsigned short )tmp);
      }
    }
#line 3479
    goto switch_break___2;
    case_5: /* CIL Label */ 
#line 3484
    if (mode == 116) {
#line 3484
      state = ! (PrivateModes & (1UL << 2));
    } else {
#line 3484
      state = mode;
    }
    {
#line 3484
    if (state == 115) {
#line 3484
      goto case_115___1;
    }
#line 3484
    if (state == 114) {
#line 3484
      goto case_114___1;
    }
#line 3484
    goto switch_default___1;
    case_115___1: /* CIL Label */ 
#line 3484
    SavedModes |= PrivateModes & (1UL << 2);
#line 3484
    goto __Cont;
#line 3484
    goto switch_break___5;
    case_114___1: /* CIL Label */ 
#line 3484
    if (SavedModes & (1UL << 2)) {
#line 3484
      state = 1;
    } else {
#line 3484
      state = 0;
    }
    switch_default___1: /* CIL Label */ 
    {
#line 3484
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3484
      if (state) {
#line 3484
        PrivateModes |= 1UL << 2;
      } else {
#line 3484
        PrivateModes &= ~ (1UL << 2);
      }
#line 3484
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    switch_break___5: /* CIL Label */ ;
    }
    {
#line 3485
    scr_rvideo_mode(state);
    }
#line 3486
    goto switch_break___2;
    case_6: /* CIL Label */ 
#line 3489
    if (mode == 116) {
#line 3489
      state = ! (PrivateModes & (1UL << 3));
    } else {
#line 3489
      state = mode;
    }
    {
#line 3489
    if (state == 115) {
#line 3489
      goto case_115___2;
    }
#line 3489
    if (state == 114) {
#line 3489
      goto case_114___2;
    }
#line 3489
    goto switch_default___2;
    case_115___2: /* CIL Label */ 
#line 3489
    SavedModes |= PrivateModes & (1UL << 3);
#line 3489
    goto __Cont;
#line 3489
    goto switch_break___6;
    case_114___2: /* CIL Label */ 
#line 3489
    if (SavedModes & (1UL << 3)) {
#line 3489
      state = 1;
    } else {
#line 3489
      state = 0;
    }
    switch_default___2: /* CIL Label */ 
    {
#line 3489
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3489
      if (state) {
#line 3489
        PrivateModes |= 1UL << 3;
      } else {
#line 3489
        PrivateModes &= ~ (1UL << 3);
      }
#line 3489
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    switch_break___6: /* CIL Label */ ;
    }
    {
#line 3490
    scr_relative_origin(state);
    }
#line 3491
    goto switch_break___2;
    case_7: /* CIL Label */ 
#line 3494
    if (mode == 116) {
#line 3494
      state = ! (PrivateModes & (1UL << 5));
    } else {
#line 3494
      state = mode;
    }
    {
#line 3494
    if (state == 115) {
#line 3494
      goto case_115___3;
    }
#line 3494
    if (state == 114) {
#line 3494
      goto case_114___3;
    }
#line 3494
    goto switch_default___3;
    case_115___3: /* CIL Label */ 
#line 3494
    SavedModes |= PrivateModes & (1UL << 5);
#line 3494
    goto __Cont;
#line 3494
    goto switch_break___7;
    case_114___3: /* CIL Label */ 
#line 3494
    if (SavedModes & (1UL << 5)) {
#line 3494
      state = 1;
    } else {
#line 3494
      state = 0;
    }
    switch_default___3: /* CIL Label */ 
    {
#line 3494
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3494
      if (state) {
#line 3494
        PrivateModes |= 1UL << 5;
      } else {
#line 3494
        PrivateModes &= ~ (1UL << 5);
      }
#line 3494
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    switch_break___7: /* CIL Label */ ;
    }
    {
#line 3495
    scr_autowrap(state);
    }
#line 3496
    goto switch_break___2;
    case_9: /* CIL Label */ 
#line 3501
    if (mode == 116) {
#line 3501
      state = ! (PrivateModes & (1UL << 12));
    } else {
#line 3501
      state = mode;
    }
    {
#line 3501
    if (state == 115) {
#line 3501
      goto case_115___4;
    }
#line 3501
    if (state == 114) {
#line 3501
      goto case_114___4;
    }
#line 3501
    goto switch_default___4;
    case_115___4: /* CIL Label */ 
#line 3501
    SavedModes |= PrivateModes & (1UL << 12);
#line 3501
    goto __Cont;
#line 3501
    goto switch_break___8;
    case_114___4: /* CIL Label */ 
#line 3501
    if (SavedModes & (1UL << 12)) {
#line 3501
      state = 1;
    } else {
#line 3501
      state = 0;
    }
    switch_default___4: /* CIL Label */ 
    {
#line 3501
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3501
      if (state) {
#line 3501
        PrivateModes |= 1UL << 12;
      } else {
#line 3501
        PrivateModes &= ~ (1UL << 12);
      }
#line 3501
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    switch_break___8: /* CIL Label */ ;
    }
#line 3503
    if (PrivateModes & (1UL << 12)) {
#line 3504
      PrivateModes &= ~ (1UL << 13);
    }
#line 3505
    goto switch_break___2;
    case_10: /* CIL Label */ 
#line 3508
    if (mode == 116) {
#line 3508
      state = ! (PrivateModes & (1UL << 15));
    } else {
#line 3508
      state = mode;
    }
    {
#line 3508
    if (state == 115) {
#line 3508
      goto case_115___5;
    }
#line 3508
    if (state == 114) {
#line 3508
      goto case_114___5;
    }
#line 3508
    goto switch_default___5;
    case_115___5: /* CIL Label */ 
#line 3508
    SavedModes |= PrivateModes & (1UL << 15);
#line 3508
    goto __Cont;
#line 3508
    goto switch_break___9;
    case_114___5: /* CIL Label */ 
#line 3508
    if (SavedModes & (1UL << 15)) {
#line 3508
      state = 1;
    } else {
#line 3508
      state = 0;
    }
    switch_default___5: /* CIL Label */ 
    {
#line 3508
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3508
      if (state) {
#line 3508
        PrivateModes |= 1UL << 15;
      } else {
#line 3508
        PrivateModes &= ~ (1UL << 15);
      }
#line 3508
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    switch_break___9: /* CIL Label */ ;
    }
    {
#line 3509
    map_menuBar(state);
    }
#line 3510
    goto switch_break___2;
    case_30: /* CIL Label */ 
#line 3514
    if (mode == 116) {
#line 3514
      state = ! (PrivateModes & (1UL << 14));
    } else {
#line 3514
      state = mode;
    }
    {
#line 3514
    if (state == 115) {
#line 3514
      goto case_115___6;
    }
#line 3514
    if (state == 114) {
#line 3514
      goto case_114___6;
    }
#line 3514
    goto switch_default___6;
    case_115___6: /* CIL Label */ 
#line 3514
    SavedModes |= PrivateModes & (1UL << 14);
#line 3514
    goto __Cont;
#line 3514
    goto switch_break___10;
    case_114___6: /* CIL Label */ 
#line 3514
    if (SavedModes & (1UL << 14)) {
#line 3514
      state = 1;
    } else {
#line 3514
      state = 0;
    }
    switch_default___6: /* CIL Label */ 
    {
#line 3514
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3514
      if (state) {
#line 3514
        PrivateModes |= 1UL << 14;
      } else {
#line 3514
        PrivateModes &= ~ (1UL << 14);
      }
#line 3514
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    switch_break___10: /* CIL Label */ ;
    }
    {
#line 3515
    map_scrollBar(state);
    }
#line 3516
    goto switch_break___2;
    case_25: /* CIL Label */ 
#line 3519
    if (mode == 116) {
#line 3519
      state = ! (PrivateModes & (1UL << 11));
    } else {
#line 3519
      state = mode;
    }
    {
#line 3519
    if (state == 115) {
#line 3519
      goto case_115___7;
    }
#line 3519
    if (state == 114) {
#line 3519
      goto case_114___7;
    }
#line 3519
    goto switch_default___7;
    case_115___7: /* CIL Label */ 
#line 3519
    SavedModes |= PrivateModes & (1UL << 11);
#line 3519
    goto __Cont;
#line 3519
    goto switch_break___11;
    case_114___7: /* CIL Label */ 
#line 3519
    if (SavedModes & (1UL << 11)) {
#line 3519
      state = 1;
    } else {
#line 3519
      state = 0;
    }
    switch_default___7: /* CIL Label */ 
    {
#line 3519
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 3519
      if (state) {
#line 3519
        PrivateModes |= 1UL << 11;
      } else {
#line 3519
        PrivateModes &= ~ (1UL << 11);
      }
#line 3519
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    switch_break___11: /* CIL Label */ ;
    }
    {
#line 3520
    scr_cursor_visible(state);
    }
#line 3521
    goto switch_break___2;
    case_35: /* CIL Label */ 
#line 3524
    if (mode == 116) {
#line 3524
      state = ! (PrivateModes & (1UL << 10));
    } else {
#line 3524
      state = mode;
    }
    {
#line 3524
    if (state == 115) {
#line 3524
      goto case_115___8;
    }
#line 3524
    if (state == 114) {
#line 3524
      goto case_114___8;
    }
#line 3524
    goto switch_default___8;
    case_115___8: /* CIL Label */ 
#line 3524
    SavedModes |= PrivateModes & (1UL << 10);
#line 3524
    goto __Cont;
#line 3524
    goto switch_break___12;
    case_114___8: /* CIL Label */ 
#line 3524
    if (SavedModes & (1UL << 10)) {
#line 3524
      state = 1;
    } else {
#line 3524
      state = 0;
    }
    switch_default___8: /* CIL Label */ 
    {
#line 3524
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3524
      if (state) {
#line 3524
        PrivateModes |= 1UL << 10;
      } else {
#line 3524
        PrivateModes &= ~ (1UL << 10);
      }
#line 3524
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    switch_break___12: /* CIL Label */ ;
    }
#line 3525
    goto switch_break___2;
    case_40: /* CIL Label */ 
#line 3528
    if (mode == 116) {
#line 3528
      state = ! (PrivateModes & (1UL << 1));
    } else {
#line 3528
      state = mode;
    }
    {
#line 3528
    if (state == 115) {
#line 3528
      goto case_115___9;
    }
#line 3528
    if (state == 114) {
#line 3528
      goto case_114___9;
    }
#line 3528
    goto switch_default___9;
    case_115___9: /* CIL Label */ 
#line 3528
    SavedModes |= PrivateModes & (1UL << 1);
#line 3528
    goto __Cont;
#line 3528
    goto switch_break___13;
    case_114___9: /* CIL Label */ 
#line 3528
    if (SavedModes & (1UL << 1)) {
#line 3528
      state = 1;
    } else {
#line 3528
      state = 0;
    }
    switch_default___9: /* CIL Label */ 
    {
#line 3528
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 3528
      if (state) {
#line 3528
        PrivateModes |= 1UL << 1;
      } else {
#line 3528
        PrivateModes &= ~ (1UL << 1);
      }
#line 3528
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    switch_break___13: /* CIL Label */ ;
    }
#line 3529
    goto switch_break___2;
    case_47: /* CIL Label */ 
#line 3532
    if (mode == 116) {
#line 3532
      state = ! (PrivateModes & (1UL << 4));
    } else {
#line 3532
      state = mode;
    }
    {
#line 3532
    if (state == 115) {
#line 3532
      goto case_115___10;
    }
#line 3532
    if (state == 114) {
#line 3532
      goto case_114___10;
    }
#line 3532
    goto switch_default___10;
    case_115___10: /* CIL Label */ 
#line 3532
    SavedModes |= PrivateModes & (1UL << 4);
#line 3532
    goto __Cont;
#line 3532
    goto switch_break___14;
    case_114___10: /* CIL Label */ 
#line 3532
    if (SavedModes & (1UL << 4)) {
#line 3532
      state = 1;
    } else {
#line 3532
      state = 0;
    }
    switch_default___10: /* CIL Label */ 
    {
#line 3532
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 3532
      if (state) {
#line 3532
        PrivateModes |= 1UL << 4;
      } else {
#line 3532
        PrivateModes &= ~ (1UL << 4);
      }
#line 3532
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    switch_break___14: /* CIL Label */ ;
    }
    {
#line 3533
    scr_change_screen(state);
    }
#line 3534
    goto switch_break___2;
    case_66: /* CIL Label */ 
#line 3537
    if (mode == 116) {
#line 3537
      state = ! (PrivateModes & (1UL << 7));
    } else {
#line 3537
      state = mode;
    }
    {
#line 3537
    if (state == 115) {
#line 3537
      goto case_115___11;
    }
#line 3537
    if (state == 114) {
#line 3537
      goto case_114___11;
    }
#line 3537
    goto switch_default___11;
    case_115___11: /* CIL Label */ 
#line 3537
    SavedModes |= PrivateModes & (1UL << 7);
#line 3537
    goto __Cont;
#line 3537
    goto switch_break___15;
    case_114___11: /* CIL Label */ 
#line 3537
    if (SavedModes & (1UL << 7)) {
#line 3537
      state = 1;
    } else {
#line 3537
      state = 0;
    }
    switch_default___11: /* CIL Label */ 
    {
#line 3537
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 3537
      if (state) {
#line 3537
        PrivateModes |= 1UL << 7;
      } else {
#line 3537
        PrivateModes &= ~ (1UL << 7);
      }
#line 3537
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    switch_break___15: /* CIL Label */ ;
    }
#line 3538
    goto switch_break___2;
    case_67: /* CIL Label */ 
#line 3542
    if (PrivateModes & (1UL << 8)) {
#line 3543
      if (mode == 116) {
#line 3543
        state = ! (PrivateModes & (1UL << 9));
      } else {
#line 3543
        state = mode;
      }
      {
#line 3543
      if (state == 115) {
#line 3543
        goto case_115___12;
      }
#line 3543
      if (state == 114) {
#line 3543
        goto case_114___12;
      }
#line 3543
      goto switch_default___12;
      case_115___12: /* CIL Label */ 
#line 3543
      SavedModes |= PrivateModes & (1UL << 9);
#line 3543
      goto __Cont;
#line 3543
      goto switch_break___16;
      case_114___12: /* CIL Label */ 
#line 3543
      if (SavedModes & (1UL << 9)) {
#line 3543
        state = 1;
      } else {
#line 3543
        state = 0;
      }
      switch_default___12: /* CIL Label */ 
      {
#line 3543
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 3543
        if (state) {
#line 3543
          PrivateModes |= 1UL << 9;
        } else {
#line 3543
          PrivateModes &= ~ (1UL << 9);
        }
#line 3543
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      switch_break___16: /* CIL Label */ ;
      }
    }
#line 3546
    goto switch_break___2;
    case_1000: /* CIL Label */ 
#line 3549
    if (mode == 116) {
#line 3549
      state = ! (PrivateModes & (1UL << 13));
    } else {
#line 3549
      state = mode;
    }
    {
#line 3549
    if (state == 115) {
#line 3549
      goto case_115___13;
    }
#line 3549
    if (state == 114) {
#line 3549
      goto case_114___13;
    }
#line 3549
    goto switch_default___13;
    case_115___13: /* CIL Label */ 
#line 3549
    SavedModes |= PrivateModes & (1UL << 13);
#line 3549
    goto __Cont;
#line 3549
    goto switch_break___17;
    case_114___13: /* CIL Label */ 
#line 3549
    if (SavedModes & (1UL << 13)) {
#line 3549
      state = 1;
    } else {
#line 3549
      state = 0;
    }
    switch_default___13: /* CIL Label */ 
    {
#line 3549
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 3549
      if (state) {
#line 3549
        PrivateModes |= 1UL << 13;
      } else {
#line 3549
        PrivateModes &= ~ (1UL << 13);
      }
#line 3549
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    switch_break___17: /* CIL Label */ ;
    }
#line 3551
    if (PrivateModes & (1UL << 13)) {
#line 3552
      PrivateModes &= ~ (1UL << 12);
    }
#line 3553
    goto switch_break___2;
    case_1010: /* CIL Label */ 
#line 3559
    if (mode == 116) {
#line 3559
      state = ! (PrivateModes & (1UL << 16));
    } else {
#line 3559
      state = mode;
    }
    {
#line 3559
    if (state == 115) {
#line 3559
      goto case_115___14;
    }
#line 3559
    if (state == 114) {
#line 3559
      goto case_114___14;
    }
#line 3559
    goto switch_default___14;
    case_115___14: /* CIL Label */ 
#line 3559
    SavedModes |= PrivateModes & (1UL << 16);
#line 3559
    goto __Cont;
#line 3559
    goto switch_break___18;
    case_114___14: /* CIL Label */ 
#line 3559
    if (SavedModes & (1UL << 16)) {
#line 3559
      state = 1;
    } else {
#line 3559
      state = 0;
    }
    switch_default___14: /* CIL Label */ 
    {
#line 3559
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3559
      if (state) {
#line 3559
        PrivateModes |= 1UL << 16;
      } else {
#line 3559
        PrivateModes &= ~ (1UL << 16);
      }
#line 3559
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    switch_break___18: /* CIL Label */ ;
    }
#line 3560
    if (PrivateModes & (1UL << 16)) {
#line 3561
      Options &= ~ (1UL << 11);
    } else {
#line 3563
      Options |= 1UL << 11;
    }
#line 3564
    goto switch_break___2;
    case_1011: /* CIL Label */ 
#line 3566
    if (mode == 116) {
#line 3566
      state = ! (PrivateModes & (1UL << 17));
    } else {
#line 3566
      state = mode;
    }
    {
#line 3566
    if (state == 115) {
#line 3566
      goto case_115___15;
    }
#line 3566
    if (state == 114) {
#line 3566
      goto case_114___15;
    }
#line 3566
    goto switch_default___15;
    case_115___15: /* CIL Label */ 
#line 3566
    SavedModes |= PrivateModes & (1UL << 17);
#line 3566
    goto __Cont;
#line 3566
    goto switch_break___19;
    case_114___15: /* CIL Label */ 
#line 3566
    if (SavedModes & (1UL << 17)) {
#line 3566
      state = 1;
    } else {
#line 3566
      state = 0;
    }
    switch_default___15: /* CIL Label */ 
    {
#line 3566
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 3566
      if (state) {
#line 3566
        PrivateModes |= 1UL << 17;
      } else {
#line 3566
        PrivateModes &= ~ (1UL << 17);
      }
#line 3566
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    switch_break___19: /* CIL Label */ ;
    }
#line 3567
    if (PrivateModes & (1UL << 17)) {
#line 3568
      Options |= 1UL << 12;
    } else {
#line 3570
      Options &= ~ (1UL << 12);
    }
#line 3571
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3467
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3574
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3576
  return;
}
}
#line 3581 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_sgr_mode(unsigned int nargs , int *arg ) 
{ 
  unsigned int i ;

  {
#line 3586
  if (nargs == 0U) {
    {
#line 3587
    scr_rendition(0, ~ 0);
    }
#line 3588
    return;
  }
#line 3590
  i = 0U;
  {
#line 3590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3590
    if (! (i < nargs)) {
#line 3590
      goto while_break;
    }
    {
#line 3592
    if (*(arg + i) == 0) {
#line 3592
      goto case_0;
    }
#line 3595
    if (*(arg + i) == 1) {
#line 3595
      goto case_1;
    }
#line 3598
    if (*(arg + i) == 4) {
#line 3598
      goto case_4;
    }
#line 3601
    if (*(arg + i) == 5) {
#line 3601
      goto case_5;
    }
#line 3604
    if (*(arg + i) == 7) {
#line 3604
      goto case_7;
    }
#line 3607
    if (*(arg + i) == 22) {
#line 3607
      goto case_22;
    }
#line 3610
    if (*(arg + i) == 24) {
#line 3610
      goto case_24;
    }
#line 3613
    if (*(arg + i) == 25) {
#line 3613
      goto case_25;
    }
#line 3616
    if (*(arg + i) == 27) {
#line 3616
      goto case_27;
    }
#line 3627
    if (*(arg + i) == 37) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 36) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 35) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 34) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 33) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 32) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 31) {
#line 3627
      goto case_37;
    }
#line 3627
    if (*(arg + i) == 30) {
#line 3627
      goto case_37;
    }
#line 3630
    if (*(arg + i) == 39) {
#line 3630
      goto case_39;
    }
#line 3641
    if (*(arg + i) == 47) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 46) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 45) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 44) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 43) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 42) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 41) {
#line 3641
      goto case_47;
    }
#line 3641
    if (*(arg + i) == 40) {
#line 3641
      goto case_47;
    }
#line 3644
    if (*(arg + i) == 49) {
#line 3644
      goto case_49;
    }
#line 3591
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 3593
    scr_rendition(0, ~ 0);
    }
#line 3594
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3596
    scr_rendition(1, 1024);
    }
#line 3597
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3599
    scr_rendition(1, 8192);
    }
#line 3600
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 3602
    scr_rendition(1, 2048);
    }
#line 3603
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 3605
    scr_rendition(1, 4096);
    }
#line 3606
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 3608
    scr_rendition(0, 1024);
    }
#line 3609
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 3611
    scr_rendition(0, 8192);
    }
#line 3612
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 3614
    scr_rendition(0, 2048);
    }
#line 3615
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 3617
    scr_rendition(0, 4096);
    }
#line 3618
    goto switch_break;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    {
#line 3628
    scr_color((unsigned int )(2 + (*(arg + i) - 30)), 1024U);
    }
#line 3629
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 3631
    scr_color(39U, 1024U);
    }
#line 3632
    goto switch_break;
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 3642
    scr_color((unsigned int )(2 + (*(arg + i) - 40)), 2048U);
    }
#line 3643
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 3645
    scr_color(49U, 2048U);
    }
#line 3646
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3590
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3648
  return;
}
}
#line 3653 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void process_graphics(void) 
{ 
  unsigned char ch ;
  unsigned char cmd ;
  unsigned char tmp ;

  {
  {
#line 3656
  tmp = cmd_getc();
#line 3656
  cmd = tmp;
  }
#line 3659
  if ((int )cmd == 81) {
    {
#line 3660
    tt_printf((unsigned char const   *)((unsigned char *)"\033G0\n"));
    }
#line 3661
    return;
  }
  {
#line 3664
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3665
    ch = cmd_getc();
    }
#line 3664
    if (! ((int )ch != 58)) {
#line 3664
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3711
  return;
}
}
#line 3716 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void main_loop(void) 
{ 
  int ch ;
  unsigned char tmp ;
  int nlines ;
  unsigned char *str ;
  unsigned char *tmp___0 ;

  {
  {
#line 3720
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3721
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3721
      tmp = cmd_getc();
#line 3721
      ch = (int )tmp;
      }
#line 3721
      if (! (ch == 0)) {
#line 3721
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3723
    if (ch >= 32) {
#line 3723
      goto _L;
    } else
#line 3723
    if (ch == 9) {
#line 3723
      goto _L;
    } else
#line 3723
    if (ch == 10) {
#line 3723
      goto _L;
    } else
#line 3723
    if (ch == 13) {
      _L: /* CIL Label */ 
#line 3725
      nlines = 0;
#line 3732
      cmdbuf_ptr --;
#line 3732
      str = cmdbuf_ptr;
      {
#line 3733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3733
        if (! ((unsigned long )cmdbuf_ptr < (unsigned long )cmdbuf_endp)) {
#line 3733
          goto while_break___1;
        }
#line 3735
        tmp___0 = cmdbuf_ptr;
#line 3735
        cmdbuf_ptr ++;
#line 3735
        ch = (int )*tmp___0;
#line 3737
        if (! (ch >= 32)) {
#line 3737
          if (! (ch == 9)) {
#line 3740
            if (ch == 13) {
#line 3743
              if ((unsigned long )cmdbuf_ptr >= (unsigned long )cmdbuf_endp) {
#line 3745
                goto while_break___1;
              } else
#line 3743
              if ((int )*cmdbuf_ptr != 10) {
#line 3743
                if ((int )*cmdbuf_ptr != 13) {
#line 3745
                  goto while_break___1;
                }
              }
            } else
#line 3746
            if (ch == 10) {
#line 3748
              nlines ++;
#line 3749
              refresh_count ++;
#line 3749
              if (refresh_count >= refresh_limit * ((int )TermWin.nrow - 1)) {
#line 3750
                goto while_break___1;
              }
            } else {
#line 3752
              cmdbuf_ptr --;
#line 3753
              goto while_break___1;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3756
      scr_add_lines((unsigned char const   *)str, nlines, (int )(cmdbuf_ptr - str));
      }
#line 3757
      if (ch == 13) {
        {
#line 3759
        scr_refresh(refresh_type);
        }
      }
    } else {
      {
#line 3763
      if (ch == 5) {
#line 3763
        goto case_5;
      }
#line 3766
      if (ch == 7) {
#line 3766
        goto case_7;
      }
#line 3769
      if (ch == 8) {
#line 3769
        goto case_8;
      }
#line 3773
      if (ch == 12) {
#line 3773
        goto case_12;
      }
#line 3773
      if (ch == 11) {
#line 3773
        goto case_12;
      }
#line 3776
      if (ch == 14) {
#line 3776
        goto case_14;
      }
#line 3779
      if (ch == 15) {
#line 3779
        goto case_15;
      }
#line 3782
      if (ch == 27) {
#line 3782
        goto case_27;
      }
#line 3762
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 3764
      tt_printf((unsigned char const   *)((unsigned char *)"\033[?1;2c"));
      }
#line 3765
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 3767
      scr_bell();
      }
#line 3768
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 3770
      scr_backspace();
      }
#line 3771
      goto switch_break;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      {
#line 3774
      scr_index(0);
      }
#line 3775
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 3777
      scr_charset_choose(1);
      }
#line 3778
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 3780
      scr_charset_choose(0);
      }
#line 3781
      goto switch_break;
      case_27: /* CIL Label */ 
      {
#line 3783
      process_escape_seq();
      }
#line 3784
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3720
    if (! (ch != -1)) {
#line 3720
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3788
  return;
}
}
#line 3798 "/home/june/collector/temp/aterm-1.0.1/src/command.c"
void tt_write(unsigned char const   *d , int len ) 
{ 
  int riten ;
  int p ;
  void *tmp ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int start ;
  int size___0 ;
  int allocsize ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 3803
  if ((unsigned long )v_bufstr == (unsigned long )((void *)0)) {
#line 3803
    if (len > 0) {
      {
#line 3804
      tmp = malloc((size_t )len);
#line 3804
      v_bufptr = (char *)tmp;
#line 3804
      v_bufstr = v_bufptr;
#line 3804
      v_buffer = v_bufstr;
#line 3805
      v_bufend = v_buffer + len;
      }
    }
  }
#line 3813
  if (len > 0) {
#line 3814
    if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
#line 3815
      if ((unsigned long )v_bufstr != (unsigned long )v_buffer) {
        {
#line 3819
        memcpy((void */* __restrict  */)v_buffer, (void const   */* __restrict  */)v_bufstr,
               (size_t )(v_bufptr - v_bufstr));
#line 3820
        v_bufptr -= v_bufstr - v_buffer;
#line 3821
        v_bufstr = v_buffer;
        }
      }
#line 3823
      if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
#line 3826
        size = (int )(v_bufptr - v_buffer);
#line 3829
        if (v_buffer) {
          {
#line 3829
          tmp___0 = realloc((void *)v_buffer, (size_t )(size + len));
#line 3829
          v_buffer = (char *)tmp___0;
          }
        } else {
          {
#line 3829
          tmp___1 = malloc((size_t )(size + len));
#line 3829
          v_buffer = (char *)tmp___1;
          }
        }
#line 3830
        if (v_buffer) {
#line 3831
          v_bufstr = v_buffer;
#line 3832
          v_bufptr = v_buffer + size;
#line 3833
          v_bufend = v_bufptr + len;
        } else {
          {
#line 3836
          print_error("cannot allocate buffer space");
#line 3837
          v_buffer = v_bufstr;
          }
        }
      }
    }
#line 3841
    if ((unsigned long )v_bufend >= (unsigned long )(v_bufptr + len)) {
      {
#line 3842
      memcpy((void */* __restrict  */)v_bufptr, (void const   */* __restrict  */)d,
             (size_t )len);
#line 3843
      v_bufptr += len;
      }
    }
  }
#line 3862
  p = (int )(v_bufptr - v_bufstr);
#line 3862
  if (p > 0) {
#line 3863
    if (p < 128) {
#line 3863
      tmp___2 = p;
    } else {
#line 3863
      tmp___2 = 128;
    }
    {
#line 3863
    tmp___3 = write(cmd_fd, (void const   *)v_bufstr, (size_t )tmp___2);
#line 3863
    riten = (int )tmp___3;
    }
#line 3864
    if (riten < 0) {
#line 3865
      riten = 0;
    }
#line 3866
    v_bufstr += riten;
#line 3867
    if ((unsigned long )v_bufstr >= (unsigned long )v_bufptr) {
#line 3868
      v_bufptr = v_buffer;
#line 3868
      v_bufstr = v_bufptr;
    }
  }
#line 3873
  if (v_bufend - v_bufptr > 1024L) {
#line 3875
    start = (int )(v_bufstr - v_buffer);
#line 3876
    size___0 = (int )(v_bufptr - v_buffer);
#line 3877
    if (size___0) {
#line 3877
      tmp___4 = size___0;
    } else {
#line 3877
      tmp___4 = 1;
    }
#line 3877
    allocsize = tmp___4;
#line 3879
    if (v_buffer) {
      {
#line 3879
      tmp___5 = realloc((void *)v_buffer, (size_t )allocsize);
#line 3879
      v_buffer = (char *)tmp___5;
      }
    } else {
      {
#line 3879
      tmp___6 = malloc((size_t )allocsize);
#line 3879
      v_buffer = (char *)tmp___6;
      }
    }
#line 3880
    if (v_buffer) {
#line 3881
      v_bufstr = v_buffer + start;
#line 3882
      v_bufptr = v_buffer + size___0;
#line 3883
      v_bufend = v_buffer + allocsize;
    } else {
#line 3886
      v_buffer = v_bufstr - start;
    }
  }
#line 3889
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 1722 "/usr/include/X11/Xlib.h"
extern KeySym XStringToKeysym(char const   * ) ;
#line 100 "/usr/include/X11/Xresource.h"
extern XrmString XrmQuarkToString(XrmQuark  ) ;
#line 1035 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *display_name ;
#line 1037
char const   *rs_term_name ;
#line 1038
char const   *rs_color[27] ;
#line 1048
char const   *rs_iconName ;
#line 1049
char const   *rs_geometry ;
#line 1050
char const   *rs_minBufferWidth ;
#line 1051
char const   *rs_saveLines ;
#line 1055
char const   *rs_borderWidth ;
#line 1056
char const   *rs_internal_border ;
#line 1057
char const   *rs_cutchars ;
#line 1067
char const   *rs_font[5] ;
#line 1072
char const   *rs_boldFont ;
#line 1099
char const   *rs_backgroundType ;
#line 1100
char const   *rs_tintType ;
#line 1101
char const   *rs_shade ;
#line 1108
char const   *rs_textType ;
#line 3 "/home/june/collector/temp/aterm-1.0.1/src/misc.pro"
int Str_match(char const   *s1 , char const   *s2 ) ;
#line 4
char *Str_skip_space(char *str ) ;
#line 5
char *Str_trim(char *str ) ;
#line 6
int Str_escaped(char *str ) ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.pro"
void list_options(void) ;
#line 2
void version(int type ) ;
#line 3
void usage(int type ) ;
#line 4
void get_options(int argc , char **argv ) ;
#line 5
int my_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 6
int define_key(XrmDatabase *database , XrmBindingList bindings , XrmQuarkList quarks ,
               XrmRepresentation *type , XrmValue *value , XPointer closure ) ;
#line 7
int parse_keysym(char *str , char *arg ) ;
#line 8
void get_xdefaults(FILE *stream , char const   *name ) ;
#line 9
void extract_resources(Display *display , char const   *name ) ;
#line 47 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_borderLess  =    (char const   *)((void *)0);
#line 48 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_loginShell  =    (char const   *)((void *)0);
#line 49 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_utmpInhibit  =    (char const   *)((void *)0);
#line 50 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_scrollBar  =    (char const   *)((void *)0);
#line 51 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_scrollBar_right  =    (char const   *)((void *)0);
#line 52 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_scrollBar_floating  =    (char const   *)((void *)0);
#line 53 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_scrollTtyOutput  =    (char const   *)((void *)0);
#line 54 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_scrollKeypress  =    (char const   *)((void *)0);
#line 57 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_transparent  =    (char const   *)((void *)0);
#line 58 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_transparent_sb  =    (char const   *)((void *)0);
#line 68 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_mapAlert  =    (char const   *)((void *)0);
#line 71 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_visualBell  =    (char const   *)((void *)0);
#line 72 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_reverseVideo  =    (char const   *)((void *)0);
#line 73 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_cutToBeginningOfLine  =    (char const   *)((void *)0);
#line 76 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   *rs_meta8  =    (char const   *)((void *)0);
#line 93 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static struct __anonstruct_optList_178  const  optList[75]  = 
#line 93
  {      {0UL, & display_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"display",
      (char const   */* const  */)"string", (char const   */* const  */)"X server to contact"}, 
        {0UL,
      & rs_term_name, (char const   */* const  */)"termName", (char const   */* const  */)"tn",
      (char const   */* const  */)"string", (char const   */* const  */)"value of the TERM environment variable"}, 
        {0UL,
      & rs_geometry, (char const   */* const  */)"geometry", (char const   */* const  */)"geometry",
      (char const   */* const  */)"geometry", (char const   */* const  */)"size (in characters) and position"}, 
        {0UL,
      & display_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"d",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_geometry, (char const   */* const  */)((void *)0), (char const   */* const  */)"g",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {(1UL << 31) | (1UL << 5),
      & rs_reverseVideo, (char const   */* const  */)"reverseVideo", (char const   */* const  */)"rv",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"reverse video"}, 
        {0UL,
      & rs_color[1], (char const   */* const  */)"background", (char const   */* const  */)"bg",
      (char const   */* const  */)"color", (char const   */* const  */)"background color"}, 
        {0UL,
      & rs_color[0], (char const   */* const  */)"foreground", (char const   */* const  */)"fg",
      (char const   */* const  */)"color", (char const   */* const  */)"foreground color"}, 
        {0UL,
      & rs_color[2], (char const   */* const  */)"color0", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[3], (char const   */* const  */)"color1", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[4], (char const   */* const  */)"color2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[5], (char const   */* const  */)"color3", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[6], (char const   */* const  */)"color4", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[7], (char const   */* const  */)"color5", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[8], (char const   */* const  */)"color6", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[9], (char const   */* const  */)"color7", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[10], (char const   */* const  */)"color8", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[11], (char const   */* const  */)"color9", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[12], (char const   */* const  */)"color10", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[13], (char const   */* const  */)"color11", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[14], (char const   */* const  */)"color12", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[15], (char const   */* const  */)"color13", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[16], (char const   */* const  */)"color14", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[17], (char const   */* const  */)"color15", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[23], (char const   */* const  */)"colorBD", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[24], (char const   */* const  */)"colorUL", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[25], (char const   */* const  */)"scrollColor", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[26], (char const   */* const  */)"troughColor", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_backgroundType, (char const   */* const  */)"backgroundType", (char const   */* const  */)"bgtype",
      (char const   */* const  */)"tile|center|scale|scaleh|scalev|notile|notileh|notilev|cut",
      (char const   */* const  */)"type of the background pixmap transformation"}, 
        {0UL,
      & rs_tintType, (char const   */* const  */)"tintingType", (char const   */* const  */)"tinttype",
      (char const   */* const  */)"true|and|andReverse|andInverted|xor|or|nor|invert|equiv|invert|orReverse|orInverted|nand",
      (char const   */* const  */)"defines function to be used for background tinting"}, 
        {0UL,
      & rs_shade, (char const   */* const  */)"shading", (char const   */* const  */)"sh",
      (char const   */* const  */)"%", (char const   */* const  */)"make transparent background x% darker"}, 
        {0UL,
      & rs_color[22], (char const   */* const  */)"tinting", (char const   */* const  */)"tint",
      (char const   */* const  */)"color", (char const   */* const  */)"tinted transparency color"}, 
        {0UL,
      & rs_textType, (char const   */* const  */)"textType", (char const   */* const  */)"txttype",
      (char const   */* const  */)"and|andReverse|andInverted|xor|or|nor|invert|equiv|invert|orReverse|orInverted|nand",
      (char const   */* const  */)"defines function to be used for text drawing"}, 
        {0UL,
      & rs_fade, (char const   */* const  */)"fading", (char const   */* const  */)"fade",
      (char const   */* const  */)"%", (char const   */* const  */)"make colors x% darker when aterm is loosing focus."}, 
        {(1UL << 31) | (1UL << 13),
      & rs_transparent, (char const   */* const  */)"transparent", (char const   */* const  */)"tr",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"transparent background"}, 
        {(1UL << 31) | (1UL << 14),
      & rs_transparent_sb, (char const   */* const  */)"transpscrollbar", (char const   */* const  */)"trsb",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"transparent scrollbar"}, 
        {0UL,
      & rs_boldFont, (char const   */* const  */)"boldFont", (char const   */* const  */)"fb",
      (char const   */* const  */)"fontname", (char const   */* const  */)"bold text font"}, 
        {0UL,
      & rs_font[0], (char const   */* const  */)"font", (char const   */* const  */)"fn",
      (char const   */* const  */)"fontname", (char const   */* const  */)"normal text font"}, 
        {0UL,
      & rs_font[1], (char const   */* const  */)"font1", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[2], (char const   */* const  */)"font2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[3], (char const   */* const  */)"font3", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_font[4], (char const   */* const  */)"font4", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"fontname", (char const   */* const  */)((void *)0)}, 
        {1UL << 2,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"iconic",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"start iconic"}, 
        {1UL << 2,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"ic",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_name, (char const   */* const  */)((void *)0), (char const   */* const  */)"name",
      (char const   */* const  */)"string", (char const   */* const  */)"client instance, icon, and title strings"}, 
        {0UL,
      & rs_title, (char const   */* const  */)"title", (char const   */* const  */)"title",
      (char const   */* const  */)"string", (char const   */* const  */)"title name for window"}, 
        {0UL,
      & rs_title, (char const   */* const  */)((void *)0), (char const   */* const  */)"T",
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_iconName, (char const   */* const  */)"iconName", (char const   */* const  */)"n",
      (char const   */* const  */)"string", (char const   */* const  */)"icon name for window"}, 
        {0UL,
      & rs_color[18], (char const   */* const  */)"cursorColor", (char const   */* const  */)"cr",
      (char const   */* const  */)"color", (char const   */* const  */)"cursor color"}, 
        {0UL,
      & rs_color[19], (char const   */* const  */)"cursorColor2", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"color", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_color[20], (char const   */* const  */)"pointerColor", (char const   */* const  */)"pr",
      (char const   */* const  */)"color", (char const   */* const  */)"pointer color"}, 
        {0UL,
      & rs_borderWidth, (char const   */* const  */)"borderWidth", (char const   */* const  */)"bw",
      (char const   */* const  */)"number", (char const   */* const  */)"width of border"}, 
        {0UL,
      & rs_internal_border, (char const   */* const  */)"internalBorder", (char const   */* const  */)"ib",
      (char const   */* const  */)"number", (char const   */* const  */)"width of the internal border"}, 
        {0UL,
      & rs_color[21], (char const   */* const  */)"borderColor", (char const   */* const  */)"bd",
      (char const   */* const  */)"color", (char const   */* const  */)"border color"}, 
        {(1UL << 31) | (1UL << 16),
      & rs_borderLess, (char const   */* const  */)"borderLess", (char const   */* const  */)"bl",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"no decoration"}, 
        {(1UL << 31) | (1UL << 1),
      & rs_loginShell, (char const   */* const  */)"loginShell", (char const   */* const  */)"ls",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"login shell"}, 
        {(1UL << 31) | (1UL << 7),
      & rs_scrollBar, (char const   */* const  */)"scrollBar", (char const   */* const  */)"sb",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scrollbar"}, 
        {(1UL << 31) | (1UL << 8),
      & rs_scrollBar_right, (char const   */* const  */)"scrollBar_right", (char const   */* const  */)"sr",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scrollbar right"}, 
        {(1UL << 31) | (1UL << 9),
      & rs_scrollBar_floating, (char const   */* const  */)"scrollBar_floating", (char const   */* const  */)"st",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scrollbar without a trough"}, 
        {(1UL << 31) | (1UL << 11),
      & rs_scrollTtyOutput, (char const   */* const  */)"scrollTtyOutput", (char const   */* const  */)((void *)0),
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {((1UL << 31) | (1UL << 30)) | (1UL << 11),
      & rs_scrollTtyOutput, (char const   */* const  */)((void *)0), (char const   */* const  */)"si",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scroll-on-tty-output inhibit"}, 
        {(1UL << 31) | (1UL << 12),
      & rs_scrollKeypress, (char const   */* const  */)"scrollKey", (char const   */* const  */)"sk",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"scroll-on-keypress"}, 
        {0UL,
      & rs_minBufferWidth, (char const   */* const  */)"minBufferWidth", (char const   */* const  */)"mbw",
      (char const   */* const  */)"number", (char const   */* const  */)"minimum number of columns stored in buffer"}, 
        {0UL,
      & rs_saveLines, (char const   */* const  */)"saveLines", (char const   */* const  */)"sl",
      (char const   */* const  */)"number", (char const   */* const  */)"number of scrolled lines to save"}, 
        {(1UL << 31) | (1UL << 6),
      & rs_utmpInhibit, (char const   */* const  */)"utmpInhibit", (char const   */* const  */)"ut",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"utmp inhibit"}, 
        {(1UL << 31) | (1UL << 3),
      & rs_visualBell, (char const   */* const  */)"visualBell", (char const   */* const  */)"vb",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"visual bell"}, 
        {(1UL << 31) | (1UL << 15),
      & rs_cutToBeginningOfLine, (char const   */* const  */)"cutToBeginningOfLine",
      (char const   */* const  */)"cb", (char const   */* const  */)((void *)0), (char const   */* const  */)"cut to beginning of line"}, 
        {(1UL << 31) | (1UL << 4),
      & rs_mapAlert, (char const   */* const  */)"mapAlert", (char const   */* const  */)((void *)0),
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {(1UL << 31) | (1UL << 10),
      & rs_meta8, (char const   */* const  */)"meta8", (char const   */* const  */)((void *)0),
      (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_modifier, (char const   */* const  */)"modifier", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"string", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_backspace_key, (char const   */* const  */)"backspacekey", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"string", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_delete_key, (char const   */* const  */)"deletekey", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"string", (char const   */* const  */)((void *)0)}, 
        {0UL,
      & rs_cutchars, (char const   */* const  */)"cutchars", (char const   */* const  */)((void *)0),
      (char const   */* const  */)"string", (char const   */* const  */)((void *)0)}, 
        {1UL,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"C",
      (char const   */* const  */)((void *)0), (char const   */* const  */)"intercept console messages"}, 
        {0UL,
      (char const   **)((void *)0), (char const   */* const  */)((void *)0), (char const   */* const  */)"e",
      (char const   */* const  */)"command arg ...", (char const   */* const  */)"command to execute"}};
#line 373 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void list_options(void) 
{ 


  {
  {
#line 377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(");
#line 426
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"transparency,");
#line 431
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fading,");
#line 436
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NeXT scrollbar,");
#line 444
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".Xdefaults");
#line 448
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")");
  }
#line 450
  return;
}
}
#line 456 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void version(int type ) 
{ 


  {
  {
#line 460
  if (type == 0) {
#line 460
    goto case_0;
  }
#line 463
  if (type == 1) {
#line 463
    goto case_1;
  }
#line 468
  if (type == 2) {
#line 468
    goto case_2;
  }
#line 459
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 461
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s\n",
          "aterm", "1.00.01");
  }
#line 462
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 464
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s from %s\n",
          "aterm", "1.00.01", "01 August 2007");
#line 465
  list_options();
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 467
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 469
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          "1.00.01");
  }
#line 470
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 472
  exit(1);
  }
}
}
#line 479 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void usage(int type ) 
{ 
  int i ;
  int col ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 484
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage v%s :",
          "1.00.01");
#line 485
  list_options();
#line 486
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s",
          "aterm");
  }
  {
#line 489
  if (type == 0) {
#line 489
    goto case_0;
  }
#line 521
  if (type == 1) {
#line 521
    goto case_1;
  }
#line 539
  if (type == 2) {
#line 539
    goto case_2;
  }
#line 488
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 490
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-help][-V]\n");
#line 491
  col = 3;
#line 492
  i = 0;
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 492
      goto while_break;
    }
#line 493
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 494
      len = 2;
#line 496
      if (! (optList[i].flag & (unsigned long const   )(1UL << 31))) {
#line 497
        if (optList[i].flag) {
#line 497
          len = 0;
        } else {
#line 497
          if (optList[i].arg) {
            {
#line 497
            tmp = strlen((char const   *)optList[i].arg);
#line 497
            tmp___0 = tmp;
            }
          } else {
#line 497
            tmp___0 = (size_t )1;
          }
#line 497
          len = (int )tmp___0;
        }
#line 498
        if (len > 0) {
#line 499
          len ++;
        }
      }
      {
#line 501
      tmp___1 = strlen((char const   *)optList[i].opt);
#line 501
      len = (int )((size_t )len + (4UL + tmp___1));
#line 503
      col += len;
      }
#line 504
      if (col > 79) {
        {
#line 505
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 506
        col = 3 + len;
        }
      }
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-");
      }
#line 509
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
        {
#line 510
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/+");
        }
      }
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              optList[i].opt);
      }
#line 512
      if (optList[i].flag) {
#line 512
        tmp___4 = (size_t )0;
      } else {
#line 512
        if (optList[i].arg) {
          {
#line 512
          tmp___2 = strlen((char const   *)optList[i].arg);
#line 512
          tmp___3 = tmp___2;
          }
        } else {
#line 512
          tmp___3 = (size_t )1;
        }
#line 512
        tmp___4 = tmp___3;
      }
#line 512
      if (tmp___4) {
        {
#line 513
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s]",
                optList[i].arg);
        }
      } else {
        {
#line 515
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
        }
      }
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
  }
#line 519
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 522
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere options include:\n");
#line 526
  i = 0;
  }
  {
#line 526
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 526
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 526
      goto while_break___0;
    }
#line 527
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 528
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 528
        tmp___5 = "turn on/off ";
      } else {
#line 528
        tmp___5 = "";
      }
#line 528
      if (optList[i].arg) {
#line 528
        tmp___6 = optList[i].arg;
      } else {
#line 528
        tmp___6 = (char const   */* const  */)"";
      }
      {
#line 528
      tmp___7 = strlen((char const   *)optList[i].opt);
      }
#line 528
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 528
        tmp___8 = 0;
      } else {
#line 528
        tmp___8 = 2;
      }
#line 528
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 528
        tmp___9 = "-/+";
      } else {
#line 528
        tmp___9 = "-";
      }
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s%s %-*s%s%s\n",
              tmp___9, optList[i].opt, (30UL - tmp___7) + (size_t )tmp___8, tmp___6,
              tmp___5, optList[i].desc);
      }
    }
#line 526
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 536
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    --help to list long-options\n    --version for the version information\n\n");
  }
#line 537
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 540
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere resources (long-options) include:\n");
#line 544
  i = 0;
  }
  {
#line 544
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 544
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 544
      goto while_break___1;
    }
#line 545
    if ((unsigned long )optList[i].kw != (unsigned long )((void *)0)) {
#line 546
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 546
        tmp___10 = (char const   */* const  */)"boolean";
      } else {
#line 546
        tmp___10 = optList[i].arg;
      }
      {
#line 546
      tmp___11 = strlen((char const   *)optList[i].kw);
#line 546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s: %*s\n",
              optList[i].kw, 30UL - tmp___11, tmp___10);
      }
    }
#line 544
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 552
  tmp___12 = strlen("keysym.sym");
#line 552
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    keysym.sym: %*s\n",
          30UL - tmp___12, "keysym");
#line 555
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    -help to list options\n    -version for the version information with options list\n\n");
  }
#line 556
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 558
  exit(1);
  }
}
}
#line 568 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   * const  On  =    (char const   */* const  */)"ON";
#line 569 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
static char const   * const  Off  =    (char const   */* const  */)"OFF";
#line 564 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void get_options(int argc , char **argv ) 
{ 
  int i ;
  int bad_option ;
  int entry ;
  int longopt ;
  char const   *flag ;
  char *opt ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *str ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *str___0 ;
  char const   *msg ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 567
  bad_option = 0;
#line 571
  i = 1;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < argc)) {
#line 571
      goto while_break;
    }
#line 572
    longopt = 0;
#line 574
    opt = *(argv + i);
#line 579
    if ((int )*opt == 45) {
#line 580
      flag = (char const   *)On;
#line 581
      opt ++;
#line 581
      if ((int )*opt == 45) {
#line 582
        tmp = opt;
#line 582
        opt ++;
#line 582
        longopt = (int )*tmp;
      }
    } else
#line 583
    if ((int )*opt == 43) {
#line 584
      flag = (char const   *)Off;
#line 585
      opt ++;
#line 585
      if ((int )*opt == 43) {
#line 586
        tmp___0 = opt;
#line 586
        opt ++;
#line 586
        longopt = (int )*tmp___0;
      }
    } else {
      {
#line 588
      bad_option = 1;
#line 589
      print_error("bad option \"%s\"", opt);
      }
#line 590
      goto __Cont;
    }
    {
#line 593
    tmp___2 = strcmp((char const   *)opt, "help");
    }
#line 593
    if (! tmp___2) {
#line 594
      if (longopt) {
#line 594
        tmp___1 = 2;
      } else {
#line 594
        tmp___1 = 1;
      }
      {
#line 594
      usage(tmp___1);
      }
    }
    {
#line 595
    tmp___3 = strcmp((char const   *)opt, "h");
    }
#line 595
    if (! tmp___3) {
      {
#line 596
      usage(0);
      }
    }
    {
#line 597
    tmp___5 = strcmp((char const   *)opt, "version");
    }
#line 597
    if (! tmp___5) {
#line 598
      if (longopt) {
#line 598
        tmp___4 = 2;
      } else {
#line 598
        tmp___4 = 1;
      }
      {
#line 598
      version(tmp___4);
      }
    }
    {
#line 599
    tmp___6 = strcmp((char const   *)opt, "V");
    }
#line 599
    if (! tmp___6) {
      {
#line 600
      version(0);
      }
    }
#line 603
    entry = 0;
    {
#line 603
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 603
      if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 603
        goto while_break___0;
      }
#line 604
      if (optList[entry].kw) {
        {
#line 604
        tmp___7 = strcmp((char const   *)opt, (char const   *)optList[entry].kw);
        }
#line 604
        if (tmp___7) {
#line 604
          goto _L;
        } else {
#line 607
          goto while_break___0;
        }
      } else
      _L: /* CIL Label */ 
#line 604
      if (! longopt) {
#line 604
        if (optList[entry].opt) {
          {
#line 604
          tmp___8 = strcmp((char const   *)opt, (char const   *)optList[entry].opt);
          }
#line 604
          if (! tmp___8) {
#line 607
            goto while_break___0;
          }
        }
      }
#line 603
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    if ((unsigned long )entry < sizeof(optList) / sizeof(optList[0])) {
#line 610
      if (optList[entry].flag & (unsigned long const   )(1UL << 30)) {
#line 611
        if ((unsigned long )flag == (unsigned long )On) {
#line 611
          flag = (char const   *)Off;
        } else {
#line 611
          flag = (char const   *)On;
        }
      }
#line 612
      if (optList[entry].flag) {
#line 612
        tmp___11 = (size_t )0;
      } else {
#line 612
        if (optList[entry].arg) {
          {
#line 612
          tmp___9 = strlen((char const   *)optList[entry].arg);
#line 612
          tmp___10 = tmp___9;
          }
        } else {
#line 612
          tmp___10 = (size_t )1;
        }
#line 612
        tmp___11 = tmp___10;
      }
#line 612
      if (tmp___11) {
#line 613
        i ++;
#line 613
        str = *(argv + i);
#line 620
        if ((unsigned long )flag == (unsigned long )On) {
#line 620
          if (str) {
#line 620
            if (optList[entry].dp) {
#line 624
              *(optList[entry].dp) = (char const   *)str;
            }
          }
        }
      } else {
#line 640
        if ((unsigned long )flag == (unsigned long )On) {
#line 641
          Options |= (unsigned long )optList[entry].flag;
        } else {
#line 643
          Options &= (unsigned long )(~ optList[entry].flag);
        }
#line 645
        if (optList[entry].dp) {
#line 646
          *(optList[entry].dp) = flag;
        }
      }
    } else {
      {
#line 651
      tmp___14 = Str_match((char const   *)opt, "keysym.");
      }
#line 651
      if (tmp___14) {
#line 652
        i ++;
#line 652
        str___0 = *(argv + i);
#line 657
        if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
          {
#line 658
          parse_keysym(opt + 7, str___0);
          }
        }
      } else {
#line 666
        msg = "bad";
#line 668
        if (longopt) {
#line 669
          opt --;
#line 670
          bad_option = 1;
        } else {
          {
#line 671
          tmp___12 = strcmp((char const   *)opt, "7");
          }
#line 671
          if (tmp___12) {
            {
#line 671
            tmp___13 = strcmp((char const   *)opt, "8");
            }
#line 671
            if (tmp___13) {
#line 679
              bad_option = 1;
            } else {
#line 677
              msg = "obsolete";
            }
          } else {
#line 677
            msg = "obsolete";
          }
        }
        {
#line 681
        opt --;
#line 681
        print_error("%s option \"%s\"", msg, opt);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (bad_option) {
    {
#line 686
    usage(0);
    }
  }
#line 687
  return;
}
}
#line 697 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
int my_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register int c1 ;
  int tmp ;
  register int c2 ;
  int tmp___0 ;

  {
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (*s1) {
#line 700
      if (! *s2) {
#line 700
        goto while_break;
      }
    } else {
#line 700
      goto while_break;
    }
    {
#line 701
    tmp = toupper((int )*s1);
#line 701
    c1 = tmp;
#line 702
    tmp___0 = toupper((int )*s2);
#line 702
    c2 = tmp___0;
    }
#line 704
    if (c1 != c2) {
#line 705
      return (c1 - c2);
    }
#line 700
    s1 ++;
#line 700
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  return ((int )((int const   )*s1 - (int const   )*s2));
}
}
#line 721 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
int define_key(XrmDatabase *database , XrmBindingList bindings , XrmQuarkList quarks ,
               XrmRepresentation *type , XrmValue *value , XPointer closure ) 
{ 
  int last ;
  XrmString tmp ;

  {
#line 726
  last = 0;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! (*(quarks + last) != 0)) {
#line 726
      goto while_break;
    }
#line 726
    last ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  last --;
#line 729
  tmp = XrmQuarkToString(*(quarks + last));
#line 729
  parse_keysym(tmp, value->addr);
  }
#line 730
  return (0);
}
}
#line 742 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
int parse_keysym(char *str , char *arg ) 
{ 
  char *key_string ;
  int n ;
  int sym ;
  int tmp ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  KeySym tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;

  {
#line 748
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 749
    n = Str_match((char const   *)str, "keysym.");
    }
#line 749
    if (n == 0) {
#line 750
      return (0);
    }
#line 751
    str += n;
  }
  {
#line 754
  tmp___7 = __ctype_b_loc();
  }
#line 754
  if ((int const   )*(*tmp___7 + (int )*(str + 0)) & 2048) {
#line 755
    if ((int )*(str + 0) == 48) {
      {
#line 755
      tmp = toupper((int )*(str + 1));
      }
#line 755
      if (tmp == 88) {
#line 756
        str += 2;
      }
    }
#line 757
    if (arg) {
      {
#line 758
      tmp___2 = strchr((char const   *)str, ':');
      }
#line 758
      if (tmp___2) {
#line 758
        tmp___1 = "%x:";
      } else {
#line 758
        tmp___1 = "%x";
      }
      {
#line 758
      tmp___3 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)tmp___1,
                       & sym);
      }
#line 758
      if (tmp___3 != 1) {
#line 759
        return (-1);
      }
    } else {
      {
#line 761
      tmp___4 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%x:",
                       & sym);
      }
#line 761
      if (tmp___4 != 1) {
#line 762
        return (-1);
      }
      {
#line 765
      str = strchr((char const   *)str, ':');
#line 766
      str ++;
#line 767
      arg = Str_trim(str);
      }
#line 768
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 769
        return (-1);
      }
    }
  } else {
#line 775
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
#line 776
      arg = str;
#line 778
      arg = strchr((char const   *)str, ':');
      }
#line 779
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 780
        return (-1);
      }
      {
#line 782
      tmp___5 = arg;
#line 782
      arg ++;
#line 782
      *tmp___5 = (char )'\000';
#line 783
      arg = Str_trim(arg);
      }
#line 784
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 785
        return (-1);
      }
    }
    {
#line 787
    tmp___6 = XStringToKeysym((char const   *)str);
#line 787
    sym = (int )tmp___6;
    }
#line 789
    if ((long )sym == 0L) {
#line 790
      return (-1);
    }
  }
#line 793
  if (sym < 65280) {
#line 794
    return (-1);
  } else
#line 793
  if (sym > 65535) {
#line 794
    return (-1);
  }
#line 795
  sym -= 65280;
#line 797
  if ((unsigned long )KeySym_map[sym] != (unsigned long )((void *)0)) {
#line 798
    return (-1);
  }
  {
#line 800
  tmp___8 = strlen((char const   *)arg);
#line 800
  n = (int )tmp___8;
  }
#line 800
  if (n == 0) {
#line 801
    return (-1);
  }
  {
#line 803
  tmp___9 = malloc((unsigned long )(n + 2) * sizeof(char ));
#line 803
  key_string = (char *)tmp___9;
#line 805
  strcpy((char */* __restrict  */)(key_string + 1), (char const   */* __restrict  */)arg);
#line 807
  n = Str_escaped(key_string + 1);
  }
#line 808
  if (n) {
#line 809
    if (n < 255) {
#line 809
      *(key_string + 0) = (char )n;
    } else {
#line 809
      *(key_string + 0) = (char)-1;
    }
#line 810
    KeySym_map[sym] = (unsigned char const   *)((unsigned char *)key_string);
  } else {
    {
#line 812
    free((void *)key_string);
    }
#line 813
    return (-1);
  }
#line 816
  return (1);
}
}
#line 826 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void get_xdefaults(FILE *stream , char const   *name ) 
{ 
  unsigned int len ;
  char *str ;
  char buffer___0[256] ;
  size_t tmp ;
  unsigned int entry ;
  unsigned int n ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *kw ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int s ;
  char *p ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 832
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 833
    return;
  }
  {
#line 834
  tmp = strlen(name);
#line 834
  len = (unsigned int )tmp;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 835
    str = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0), (FILE */* __restrict  */)stream);
    }
#line 835
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 835
      goto while_break;
    }
    {
#line 838
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 838
      if (*str) {
        {
#line 838
        tmp___0 = __ctype_b_loc();
        }
#line 838
        if (! ((int const   )*(*tmp___0 + (int )*str) & 8192)) {
#line 838
          goto while_break___0;
        }
      } else {
#line 838
        goto while_break___0;
      }
#line 839
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 841
    if ((int )*(str + len) != 42) {
#line 841
      if ((int )*(str + len) != 46) {
#line 843
        goto while_continue;
      } else {
#line 841
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 841
    if (len) {
      {
#line 841
      tmp___1 = strncmp((char const   *)str, name, (size_t )len);
      }
#line 841
      if (tmp___1) {
#line 843
        goto while_continue;
      }
    }
    {
#line 844
    str += len + 1U;
#line 847
    tmp___12 = parse_keysym(str, (char *)((void *)0));
    }
#line 847
    if (! tmp___12) {
#line 849
      entry = 0U;
      {
#line 849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 849
        if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 849
          goto while_break___1;
        }
#line 850
        kw = (char const   *)optList[entry].kw;
#line 852
        if ((unsigned long )kw == (unsigned long )((void *)0)) {
#line 853
          goto __Cont;
        }
        {
#line 854
        tmp___2 = strlen(kw);
#line 854
        n = (unsigned int )tmp___2;
        }
#line 855
        if ((int )*(str + n) == 58) {
          {
#line 855
          tmp___11 = Str_match((char const   *)str, kw);
          }
#line 855
          if (tmp___11) {
            {
#line 857
            str += n + 1U;
#line 858
            str = Str_skip_space(str);
#line 859
            str = Str_trim(str);
            }
#line 860
            if (str) {
              {
#line 860
              tmp___3 = strlen((char const   *)str);
#line 860
              n = (unsigned int )tmp___3;
              }
            } else {
#line 860
              n = 0U;
            }
#line 861
            if (n) {
#line 861
              if ((unsigned long )*(optList[entry].dp) == (unsigned long )((void *)0)) {
                {
#line 864
                tmp___4 = malloc((unsigned long )(n + 1U) * sizeof(char ));
#line 864
                p = (char *)tmp___4;
#line 866
                strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)str);
#line 867
                *(optList[entry].dp) = (char const   *)p;
                }
#line 868
                if (optList[entry].flag & (unsigned long const   )(1UL << 31)) {
                  {
#line 869
                  tmp___5 = my_strcasecmp((char const   *)p, "TRUE");
                  }
#line 869
                  if (tmp___5 == 0) {
#line 869
                    tmp___9 = 1;
                  } else {
                    {
#line 869
                    tmp___6 = my_strcasecmp((char const   *)p, "YES");
                    }
#line 869
                    if (tmp___6 == 0) {
#line 869
                      tmp___9 = 1;
                    } else {
                      {
#line 869
                      tmp___7 = my_strcasecmp((char const   *)p, "ON");
                      }
#line 869
                      if (tmp___7 == 0) {
#line 869
                        tmp___9 = 1;
                      } else {
                        {
#line 869
                        tmp___8 = my_strcasecmp((char const   *)p, "1");
                        }
#line 869
                        if (tmp___8 == 0) {
#line 869
                          tmp___9 = 1;
                        } else {
#line 869
                          tmp___9 = 0;
                        }
                      }
                    }
                  }
#line 869
                  s = tmp___9;
#line 873
                  if (optList[entry].flag & (unsigned long const   )(1UL << 30)) {
#line 874
                    s = ! s;
                  }
#line 875
                  if (s) {
#line 876
                    Options |= (unsigned long )optList[entry].flag;
                  } else {
                    {
#line 878
                    tmp___10 = my_strcasecmp((char const   *)str, "FALSE");
                    }
#line 878
                    if (tmp___10) {
                      {
#line 879
                      print_error("Cannot parse value \"%s\" from resource \"%s\" as boolean",
                                  str, kw);
                      }
                    }
#line 881
                    Options &= (unsigned long )(~ optList[entry].flag);
                  }
                }
              }
            }
#line 885
            goto while_break___1;
          }
        }
        __Cont: /* CIL Label */ 
#line 849
        entry ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 889
  rewind(stream);
  }
#line 890
  return;
}
}
#line 901 "/home/june/collector/temp/aterm-1.0.1/src/xdefaults.c"
void extract_resources(Display *display , char const   *name ) 
{ 
  char const   *fname[2] ;
  FILE *fd ;
  char *home ;
  int i ;
  int len ;
  size_t tmp ;
  char *f ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1006
  fname[0] = ".Xdefaults";
#line 1006
  fname[1] = ".Xresources";
#line 1007
  fd = (FILE *)((void *)0);
#line 1010
  home = getenv("HOME");
  }
#line 1010
  if ((unsigned long )home != (unsigned long )((void *)0)) {
    {
#line 1011
    tmp = strlen((char const   *)home);
#line 1011
    len = (int )(tmp + 2UL);
#line 1012
    f = (char *)((void *)0);
#line 1014
    i = 0;
    }
    {
#line 1014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )i < sizeof(fname) / sizeof(fname[0]))) {
#line 1014
        goto while_break;
      }
#line 1015
      if (f) {
        {
#line 1015
        tmp___0 = strlen(fname[i]);
#line 1015
        tmp___1 = realloc((void *)f, ((size_t )len + tmp___0) * sizeof(char ));
#line 1015
        f = (char *)tmp___1;
        }
      } else {
        {
#line 1015
        tmp___2 = strlen(fname[i]);
#line 1015
        tmp___3 = malloc(((size_t )len + tmp___2) * sizeof(char ));
#line 1015
        f = (char *)tmp___3;
        }
      }
      {
#line 1017
      sprintf((char */* __restrict  */)f, (char const   */* __restrict  */)"%s/%s",
              home, fname[i]);
#line 1019
      fd = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
      }
#line 1019
      if ((unsigned long )fd != (unsigned long )((void *)0)) {
#line 1020
        goto while_break;
      }
#line 1014
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1022
    free((void *)f);
    }
  }
  {
#line 1046
  get_xdefaults(fd, name);
#line 1047
  get_xdefaults(fd, "Aterm");
#line 1060
  get_xdefaults(fd, "XTerm");
#line 1061
  get_xdefaults(fd, "");
  }
#line 1062
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 1063
    fclose(fd);
    }
  }
#line 1093
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 1644 "/usr/include/X11/Xlib.h"
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 1934
extern void XFreeStringList(char ** ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2157
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2187
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2334
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2969
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3546
extern int XWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 745 "/usr/include/X11/Xutil.h"
extern int XmbTextListToTextProperty(Display *display , char **list , int count ,
                                     XICCEncodingStyle style , XTextProperty *text_prop_return ) ;
#line 779
extern int XmbTextPropertyToTextList(Display *display , XTextProperty const   *text_prop ,
                                     char ***list_return , int *count_return ) ;
#line 992 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Colormap Xcmap ;
#line 1005
int TermWin_internalBorders ;
#line 1082
unsigned int colorfgbg ;
#line 1110
Atom aterm_XA_TARGETS ;
#line 1111
Atom aterm_XA_TEXT ;
#line 1112
Atom _XA_COMPAUND_TEXT ;
#line 1113
Atom aterm_XA_UTF8_STRING ;
#line 1114
Atom aterm_XA_CLIPBOARD ;
#line 1115
Atom aterm_XA_VT_SELECTION ;
#line 1116
Atom aterm_XA_INCR ;
#line 116 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
text_t **drawn_text  ;
#line 117 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
rend_t **drawn_rend  ;
#line 118 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
text_t **buf_text  ;
#line 119 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
rend_t **buf_rend  ;
#line 120 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
R_int16_t *buf_tlen  ;
#line 121 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
char *tabs  ;
#line 122 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
screen_t swap  ;
#line 123 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
save_t save  ;
#line 124 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
selection_t selection  ;
#line 125 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
char charsets[4]  ;
#line 126 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
short current_screen  ;
#line 127 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
rend_t rstyle  ;
#line 128 "/home/june/collector/temp/aterm-1.0.1/src/screen.h"
short rvideo  ;
#line 10 "/home/june/collector/temp/aterm-1.0.1/src/graphics.pro"
void Gr_scroll(int count ) ;
#line 11
void Gr_ClearScreen(void) ;
#line 12
void Gr_ChangeScreen(void) ;
#line 15
void Gr_reset(void) ;
#line 16
int Gr_Displayed(void) ;
#line 3 "/home/june/collector/temp/aterm-1.0.1/src/main.pro"
void set_colorfgbg(void) ;
#line 5
void set_cursor_color(void) ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/screen.pro"
void blank_line(text_t *et , rend_t *er , int width , rend_t efs ) ;
#line 2
void make_screen_mem(text_t **tp , rend_t **rp , int row , rend_t rstyle___0 ) ;
#line 3
void scr_reset(void) ;
#line 10
int scroll_text(int row1 , int row2 , int count , int spec ) ;
#line 29
void set_font_style(void) ;
#line 43
void scr_printscreen(int fullhist ) ;
#line 47
void scr_reverse_selection(void) ;
#line 48
void selection_check(int check_more ) ;
#line 49
void PasteIt(unsigned char *data , unsigned int nitems ) ;
#line 55
void selection_start_colrow(int col , int row ) ;
#line 56
void selection_delimit_word(int dirn , row_col_t *mark , row_col_t *ret ) ;
#line 58
void selection_extend_colrow(int col , int row , int button3 , int buttonpress , int clickchange ) ;
#line 62
void mouse_tracking(int report , int x , int y , int firstrow , int lastrow ) ;
#line 63
void debug_PasteIt(unsigned char *data , int nitems ) ;
#line 64
void debug_colors(void) ;
#line 53 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static screen_t screen  ;
#line 56 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
int colors_changed  =    0;
#line 149 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void CLEAR_ROWS(unsigned int row , unsigned int num ) 
{ 
  unsigned int line_h ;
  register unsigned int hy ;
  register unsigned int y ;

  {
#line 151
  line_h = (unsigned int )((int )TermWin.fheight - 1);
#line 152
  hy = (line_h + 1U) * num;
#line 152
  y = row * (unsigned int )TermWin.fheight + (unsigned int )TermWin_internalBorder;
#line 154
  if (! TermWin.bMapped) {
#line 154
    return;
  }
#line 156
  if (y < (unsigned int )TermWin_internalBorder + line_h) {
#line 157
    y = 0U;
#line 157
    hy += (unsigned int )TermWin_internalBorder;
  }
#line 158
  if (y + hy > (unsigned int )((int )TermWin.height + TermWin_internalBorder) - line_h) {
#line 159
    hy = ((unsigned int )TermWin.height - y) + (unsigned int )TermWin_internalBorders;
  }
  {
#line 160
  XClearArea(Xdisplay, TermWin.vt, 0, (int )y, (unsigned int )((int )TermWin.width + TermWin_internalBorders),
             hy, 0);
  }
#line 162
  if (TermWin.tintGC) {
    {
#line 164
    XFillRectangle(Xdisplay, TermWin.vt, TermWin.tintGC, 0, (int )y, (unsigned int )((int )TermWin.width + TermWin_internalBorders),
                   hy);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void CLEAR_CHARS(unsigned int x , unsigned int y , unsigned int num ) 
{ 
  unsigned int char_w ;
  unsigned int line_h ;
  register unsigned int hx ;
  register unsigned int hy ;

  {
#line 172
  char_w = (unsigned int )((int )TermWin.fwidth - 1);
#line 172
  line_h = (unsigned int )((int )TermWin.fheight - 1);
#line 173
  hx = (char_w + 1U) * num;
#line 173
  hy = line_h + 1U;
#line 175
  if (! TermWin.bMapped) {
#line 175
    return;
  }
#line 177
  if (x < (unsigned int )TermWin_internalBorder + char_w) {
#line 177
    x = 0U;
#line 177
    hx += (unsigned int )TermWin_internalBorder;
  }
#line 178
  if (y < (unsigned int )TermWin_internalBorder + line_h) {
#line 178
    y = 0U;
#line 178
    hy += (unsigned int )TermWin_internalBorder;
  }
#line 180
  if (x + hx > (unsigned int )((int )TermWin.width + TermWin_internalBorder) - char_w) {
#line 181
    hx = (unsigned int )(((int )TermWin.width + TermWin_internalBorders) + 1) - x;
  }
#line 182
  if (y + hy > (unsigned int )((int )TermWin.height + TermWin_internalBorder) - line_h) {
#line 183
    hy = (unsigned int )(((int )TermWin.height + TermWin_internalBorders) + 1) - y;
  }
  {
#line 184
  XClearArea(Xdisplay, TermWin.vt, (int )x, (int )y, hx, hy, 0);
  }
#line 186
  if (TermWin.tintGC) {
    {
#line 188
    XFillRectangle(Xdisplay, TermWin.vt, TermWin.tintGC, (int )x, (int )y, hx, hy);
    }
  }
#line 191
  return;
}
}
#line 205 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void blank_line(text_t *et , rend_t *er , int width , rend_t efs ) 
{ 
  rend_t *tmp ;
  int tmp___0 ;

  {
  {
#line 208
  rmemset((void *)et, (unsigned char )' ', (R_int_p_t )width);
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    tmp___0 = width;
#line 209
    width --;
#line 209
    if (! tmp___0) {
#line 209
      goto while_break;
    }
#line 210
    tmp = er;
#line 210
    er ++;
#line 210
    *tmp = efs;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return;
}
}
#line 216 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void make_screen_mem(text_t **tp , rend_t **rp , int row , rend_t rstyle___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 219
  tmp = malloc(sizeof(text_t ) * (unsigned long )TermWin.bcol);
#line 219
  *(tp + row) = (text_t *)tmp;
#line 220
  tmp___0 = malloc(sizeof(rend_t ) * (unsigned long )TermWin.bcol);
#line 220
  *(rp + row) = (rend_t *)tmp___0;
#line 221
  blank_line(*(tp + row), *(rp + row), (int )TermWin.bcol, rstyle___0);
  }
#line 222
  return;
}
}
#line 227 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static int prev_nrow  =    -1;
#line 227 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static int prev_bcol  =    -1;
#line 230 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_reset(void) 
{ 
  int i ;
  int j ;
  int k ;
  int total_rows ;
  int prev_total_rows ;
  rend_t setrstyle ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  R_int16_t tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  void *tmp___43 ;
  void *tmp___44 ;
  void *tmp___45 ;
  void *tmp___46 ;
  void *tmp___47 ;

  {
#line 238
  TermWin.view_start = (R_u_int16_t )0;
#line 241
  if ((int )TermWin.bcol == prev_bcol) {
#line 241
    if ((int )TermWin.nrow == prev_nrow) {
#line 242
      return;
    }
  }
#line 251
  total_rows = (int )TermWin.nrow + (int )TermWin.saveLines;
#line 252
  prev_total_rows = prev_nrow + (int )TermWin.saveLines;
#line 254
  screen.tscroll = (R_int16_t )0;
#line 255
  screen.bscroll = (R_int16_t )((int )TermWin.nrow - 1);
#line 257
  if (prev_nrow == -1) {
    {
#line 262
    tmp = calloc((size_t )total_rows, sizeof(text_t *));
#line 262
    screen.text = (text_t **)tmp;
#line 263
    tmp___0 = calloc((size_t )total_rows, sizeof(R_int16_t ));
#line 263
    screen.tlen = (R_int16_t *)tmp___0;
#line 264
    tmp___1 = calloc((size_t )total_rows, sizeof(text_t *));
#line 264
    buf_text = (text_t **)tmp___1;
#line 265
    tmp___2 = calloc((size_t )total_rows, sizeof(R_int16_t ));
#line 265
    buf_tlen = (R_int16_t *)tmp___2;
#line 266
    tmp___3 = calloc((size_t )TermWin.nrow, sizeof(text_t *));
#line 266
    drawn_text = (text_t **)tmp___3;
#line 267
    tmp___4 = calloc((size_t )TermWin.nrow, sizeof(text_t *));
#line 267
    swap.text = (text_t **)tmp___4;
#line 268
    tmp___5 = calloc((size_t )TermWin.nrow, sizeof(R_int16_t ));
#line 268
    swap.tlen = (R_int16_t *)tmp___5;
#line 270
    tmp___6 = calloc((size_t )total_rows, sizeof(rend_t *));
#line 270
    screen.rend = (rend_t **)tmp___6;
#line 271
    tmp___7 = calloc((size_t )total_rows, sizeof(rend_t *));
#line 271
    buf_rend = (rend_t **)tmp___7;
#line 272
    tmp___8 = calloc((size_t )TermWin.nrow, sizeof(rend_t *));
#line 272
    drawn_rend = (rend_t **)tmp___8;
#line 273
    tmp___9 = calloc((size_t )TermWin.nrow, sizeof(rend_t *));
#line 273
    swap.rend = (rend_t **)tmp___9;
#line 275
    i = 0;
    }
    {
#line 275
    while (1) {
      while_continue: /* CIL Label */ ;
#line 275
      if (! (i < (int )TermWin.nrow)) {
#line 275
        goto while_break;
      }
      {
#line 276
      j = i + (int )TermWin.saveLines;
#line 277
      make_screen_mem(screen.text, screen.rend, j, (rend_t )(1 << 5));
#line 278
      make_screen_mem(swap.text, swap.rend, i, (rend_t )(1 << 5));
#line 279
      make_screen_mem(drawn_text, drawn_rend, i, (rend_t )(1 << 5));
#line 280
      tmp___10 = (R_int16_t )0;
#line 280
      *(swap.tlen + i) = tmp___10;
#line 280
      *(screen.tlen + j) = tmp___10;
#line 275
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 282
    TermWin.nscrolled = (R_u_int16_t )0;
#line 283
    swap.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 283
    screen.flags = swap.flags;
#line 284
    save.cur.col = (R_int16_t )0;
#line 284
    save.cur.row = save.cur.col;
#line 285
    save.charset = (R_int16_t )0;
#line 286
    save.charset_char = (char )'B';
#line 287
    save.rstyle = (rend_t )(1 << 5);
#line 287
    rstyle = save.rstyle;
#line 288
    selection.text = (unsigned char *)((void *)0);
#line 289
    selection.op = (enum __anonenum_op_177 )0;
#line 290
    selection.screen = (short)0;
#line 291
    selection.clicks = (short)0;
#line 292
    selection.end.col = (R_int16_t )0;
#line 292
    selection.end.row = selection.end.col;
#line 292
    selection.mark.col = selection.end.row;
#line 292
    selection.mark.row = selection.mark.col;
#line 292
    selection.beg.col = selection.mark.row;
#line 292
    selection.beg.row = selection.beg.col;
#line 293
    rmemset((void *)(charsets), (unsigned char )'B', (R_int_p_t )sizeof(charsets));
#line 294
    current_screen = (short)0;
#line 295
    rvideo = (short)0;
    }
  } else {
#line 311
    if (rvideo) {
#line 311
      tmp___11 = 4096U;
    } else {
#line 311
      tmp___11 = 0U;
    }
#line 311
    setrstyle = (rend_t )((unsigned int )(1 << 5) | tmp___11);
#line 313
    if ((int )TermWin.nrow < prev_nrow) {
#line 315
      if ((int )TermWin.nscrolled < prev_nrow - (int )TermWin.nrow) {
#line 315
        k = (int )TermWin.nscrolled;
      } else {
#line 315
        k = prev_nrow - (int )TermWin.nrow;
      }
      {
#line 316
      scroll_text(0, prev_nrow - 1, k, 1);
#line 317
      i = (int )TermWin.nrow;
      }
      {
#line 317
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 317
        if (! (i < prev_nrow)) {
#line 317
          goto while_break___0;
        }
#line 318
        j = i + (int )TermWin.saveLines;
#line 319
        if (*(screen.text + j)) {
          {
#line 320
          free((void *)*(screen.text + j));
          }
        }
#line 321
        if (*(screen.rend + j)) {
          {
#line 322
          free((void *)*(screen.rend + j));
          }
        }
#line 323
        if (*(swap.text + i)) {
          {
#line 324
          free((void *)*(swap.text + i));
          }
        }
#line 325
        if (*(swap.rend + i)) {
          {
#line 326
          free((void *)*(swap.rend + i));
          }
        }
        {
#line 327
        free((void *)*(drawn_text + i));
#line 328
        free((void *)*(drawn_rend + i));
#line 317
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 331
      if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 331
        screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
      }
#line 332
      if ((int )TermWin.nrow - 1 < (int )swap.cur.row) {
#line 332
        swap.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
      }
    }
#line 334
    if ((int )TermWin.nrow != prev_nrow) {
#line 335
      if (screen.text) {
        {
#line 335
        tmp___12 = realloc((void *)screen.text, (unsigned long )total_rows * sizeof(text_t *));
#line 335
        screen.text = (text_t **)tmp___12;
        }
      } else {
        {
#line 335
        tmp___13 = malloc((unsigned long )total_rows * sizeof(text_t *));
#line 335
        screen.text = (text_t **)tmp___13;
        }
      }
#line 336
      if (screen.tlen) {
        {
#line 336
        tmp___14 = realloc((void *)screen.tlen, (unsigned long )total_rows * sizeof(R_int16_t ));
#line 336
        screen.tlen = (R_int16_t *)tmp___14;
        }
      } else {
        {
#line 336
        tmp___15 = malloc((unsigned long )total_rows * sizeof(R_int16_t ));
#line 336
        screen.tlen = (R_int16_t *)tmp___15;
        }
      }
#line 337
      if (buf_text) {
        {
#line 337
        tmp___16 = realloc((void *)buf_text, (unsigned long )total_rows * sizeof(text_t *));
#line 337
        buf_text = (text_t **)tmp___16;
        }
      } else {
        {
#line 337
        tmp___17 = malloc((unsigned long )total_rows * sizeof(text_t *));
#line 337
        buf_text = (text_t **)tmp___17;
        }
      }
#line 338
      if (buf_tlen) {
        {
#line 338
        tmp___18 = realloc((void *)buf_tlen, (unsigned long )total_rows * sizeof(R_int16_t ));
#line 338
        buf_tlen = (R_int16_t *)tmp___18;
        }
      } else {
        {
#line 338
        tmp___19 = malloc((unsigned long )total_rows * sizeof(R_int16_t ));
#line 338
        buf_tlen = (R_int16_t *)tmp___19;
        }
      }
#line 339
      if (drawn_text) {
        {
#line 339
        tmp___20 = realloc((void *)drawn_text, (unsigned long )TermWin.nrow * sizeof(text_t *));
#line 339
        drawn_text = (text_t **)tmp___20;
        }
      } else {
        {
#line 339
        tmp___21 = malloc((unsigned long )TermWin.nrow * sizeof(text_t *));
#line 339
        drawn_text = (text_t **)tmp___21;
        }
      }
#line 340
      if (swap.text) {
        {
#line 340
        tmp___22 = realloc((void *)swap.text, (unsigned long )TermWin.nrow * sizeof(text_t *));
#line 340
        swap.text = (text_t **)tmp___22;
        }
      } else {
        {
#line 340
        tmp___23 = malloc((unsigned long )TermWin.nrow * sizeof(text_t *));
#line 340
        swap.text = (text_t **)tmp___23;
        }
      }
#line 341
      if (swap.tlen) {
        {
#line 341
        tmp___24 = realloc((void *)swap.tlen, (unsigned long )total_rows * sizeof(R_int16_t ));
#line 341
        swap.tlen = (R_int16_t *)tmp___24;
        }
      } else {
        {
#line 341
        tmp___25 = malloc((unsigned long )total_rows * sizeof(R_int16_t ));
#line 341
        swap.tlen = (R_int16_t *)tmp___25;
        }
      }
#line 343
      if (screen.rend) {
        {
#line 343
        tmp___26 = realloc((void *)screen.rend, (unsigned long )total_rows * sizeof(rend_t *));
#line 343
        screen.rend = (rend_t **)tmp___26;
        }
      } else {
        {
#line 343
        tmp___27 = malloc((unsigned long )total_rows * sizeof(rend_t *));
#line 343
        screen.rend = (rend_t **)tmp___27;
        }
      }
#line 344
      if (buf_rend) {
        {
#line 344
        tmp___28 = realloc((void *)buf_rend, (unsigned long )total_rows * sizeof(rend_t *));
#line 344
        buf_rend = (rend_t **)tmp___28;
        }
      } else {
        {
#line 344
        tmp___29 = malloc((unsigned long )total_rows * sizeof(rend_t *));
#line 344
        buf_rend = (rend_t **)tmp___29;
        }
      }
#line 345
      if (drawn_rend) {
        {
#line 345
        tmp___30 = realloc((void *)drawn_rend, (unsigned long )TermWin.nrow * sizeof(rend_t *));
#line 345
        drawn_rend = (rend_t **)tmp___30;
        }
      } else {
        {
#line 345
        tmp___31 = malloc((unsigned long )TermWin.nrow * sizeof(rend_t *));
#line 345
        drawn_rend = (rend_t **)tmp___31;
        }
      }
#line 346
      if (swap.rend) {
        {
#line 346
        tmp___32 = realloc((void *)swap.rend, (unsigned long )TermWin.nrow * sizeof(rend_t *));
#line 346
        swap.rend = (rend_t **)tmp___32;
        }
      } else {
        {
#line 346
        tmp___33 = malloc((unsigned long )TermWin.nrow * sizeof(rend_t *));
#line 346
        swap.rend = (rend_t **)tmp___33;
        }
      }
    }
#line 348
    if ((int )TermWin.nrow > prev_nrow) {
#line 350
      if ((int )TermWin.nscrolled < (int )TermWin.nrow - prev_nrow) {
#line 350
        k = (int )TermWin.nscrolled;
      } else {
#line 350
        k = (int )TermWin.nrow - prev_nrow;
      }
#line 351
      i = prev_total_rows;
      {
#line 351
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 351
        if (! (i < total_rows - k)) {
#line 351
          goto while_break___1;
        }
        {
#line 352
        make_screen_mem(screen.text, screen.rend, i, setrstyle);
#line 353
        *(screen.tlen + i) = (R_int16_t )0;
#line 351
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 355
      i = total_rows - k;
      {
#line 355
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 355
        if (! (i < total_rows)) {
#line 355
          goto while_break___2;
        }
#line 356
        *(screen.text + i) = (text_t *)((void *)0);
#line 357
        *(screen.rend + i) = (rend_t *)((void *)0);
#line 358
        *(screen.tlen + i) = (R_int16_t )0;
#line 355
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 360
      i = prev_nrow;
      {
#line 360
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 360
        if (! (i < (int )TermWin.nrow)) {
#line 360
          goto while_break___3;
        }
        {
#line 361
        make_screen_mem(swap.text, swap.rend, i, setrstyle);
#line 362
        make_screen_mem(drawn_text, drawn_rend, i, setrstyle);
#line 363
        *(swap.tlen + i) = (R_int16_t )0;
#line 360
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 366
      if (k > 0) {
        {
#line 367
        scroll_text(0, (int )TermWin.nrow - 1, - k, 1);
#line 368
        screen.cur.row = (R_int16_t )((int )screen.cur.row + k);
#line 369
        TermWin.nscrolled = (R_u_int16_t )((int )TermWin.nscrolled - k);
#line 370
        i = (int )TermWin.saveLines - (int )TermWin.nscrolled;
        }
        {
#line 370
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 370
          tmp___34 = k;
#line 370
          k --;
#line 370
          if (! tmp___34) {
#line 370
            goto while_break___4;
          }
#line 371
          if ((unsigned long )*(screen.text + i) == (unsigned long )((void *)0)) {
            {
#line 372
            make_screen_mem(screen.text, screen.rend, i, setrstyle);
#line 374
            *(screen.tlen + i) = (R_int16_t )0;
            }
          }
#line 370
          i --;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 381
      if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 381
        screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
      }
#line 382
      if ((int )TermWin.nrow - 1 < (int )swap.cur.row) {
#line 382
        swap.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
      }
    }
#line 387
    if ((int )TermWin.bcol != prev_bcol) {
#line 388
      i = 0;
      {
#line 388
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 388
        if (! (i < total_rows)) {
#line 388
          goto while_break___5;
        }
#line 389
        if (*(screen.text + i)) {
#line 390
          if (*(screen.text + i)) {
            {
#line 390
            tmp___35 = realloc((void *)*(screen.text + i), (unsigned long )TermWin.bcol * sizeof(text_t ));
#line 390
            *(screen.text + i) = (text_t *)tmp___35;
            }
          } else {
            {
#line 390
            tmp___36 = malloc((unsigned long )TermWin.bcol * sizeof(text_t ));
#line 390
            *(screen.text + i) = (text_t *)tmp___36;
            }
          }
#line 392
          if (*(screen.rend + i)) {
            {
#line 392
            tmp___37 = realloc((void *)*(screen.rend + i), (unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 392
            *(screen.rend + i) = (rend_t *)tmp___37;
            }
          } else {
            {
#line 392
            tmp___38 = malloc((unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 392
            *(screen.rend + i) = (rend_t *)tmp___38;
            }
          }
#line 394
          if ((int )TermWin.bcol < (int )*(screen.tlen + i)) {
#line 394
            *(screen.tlen + i) = (R_int16_t )TermWin.bcol;
          }
#line 395
          if ((int )TermWin.bcol > prev_bcol) {
            {
#line 396
            blank_line(*(screen.text + i) + prev_bcol, *(screen.rend + i) + prev_bcol,
                       (int )TermWin.bcol - prev_bcol, setrstyle);
            }
          }
        }
#line 388
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 401
      i = 0;
      {
#line 401
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 401
        if (! (i < (int )TermWin.nrow)) {
#line 401
          goto while_break___6;
        }
#line 402
        if (*(drawn_text + i)) {
          {
#line 402
          tmp___39 = realloc((void *)*(drawn_text + i), (unsigned long )TermWin.bcol * sizeof(text_t ));
#line 402
          *(drawn_text + i) = (text_t *)tmp___39;
          }
        } else {
          {
#line 402
          tmp___40 = malloc((unsigned long )TermWin.bcol * sizeof(text_t ));
#line 402
          *(drawn_text + i) = (text_t *)tmp___40;
          }
        }
#line 404
        if (*(drawn_rend + i)) {
          {
#line 404
          tmp___41 = realloc((void *)*(drawn_rend + i), (unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 404
          *(drawn_rend + i) = (rend_t *)tmp___41;
          }
        } else {
          {
#line 404
          tmp___42 = malloc((unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 404
          *(drawn_rend + i) = (rend_t *)tmp___42;
          }
        }
#line 406
        if (*(swap.text + i)) {
#line 407
          if (*(swap.text + i)) {
            {
#line 407
            tmp___43 = realloc((void *)*(swap.text + i), (unsigned long )TermWin.bcol * sizeof(text_t ));
#line 407
            *(swap.text + i) = (text_t *)tmp___43;
            }
          } else {
            {
#line 407
            tmp___44 = malloc((unsigned long )TermWin.bcol * sizeof(text_t ));
#line 407
            *(swap.text + i) = (text_t *)tmp___44;
            }
          }
#line 409
          if (*(swap.rend + i)) {
            {
#line 409
            tmp___45 = realloc((void *)*(swap.rend + i), (unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 409
            *(swap.rend + i) = (rend_t *)tmp___45;
            }
          } else {
            {
#line 409
            tmp___46 = malloc((unsigned long )TermWin.bcol * sizeof(rend_t ));
#line 409
            *(swap.rend + i) = (rend_t *)tmp___46;
            }
          }
#line 411
          if ((int )TermWin.bcol < (int )*(swap.tlen + i)) {
#line 411
            *(swap.tlen + i) = (R_int16_t )TermWin.bcol;
          }
#line 412
          if ((int )TermWin.bcol > prev_bcol) {
            {
#line 413
            blank_line(*(swap.text + i) + prev_bcol, *(swap.rend + i) + prev_bcol,
                       (int )TermWin.bcol - prev_bcol, setrstyle);
            }
          }
        }
#line 417
        if ((int )TermWin.bcol > prev_bcol) {
          {
#line 418
          blank_line(*(drawn_text + i) + prev_bcol, *(drawn_rend + i) + prev_bcol,
                     (int )TermWin.bcol - prev_bcol, setrstyle);
          }
        }
#line 401
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 422
      if ((int )TermWin.bcol - 1 < (int )screen.cur.col) {
#line 422
        screen.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
      }
#line 423
      if ((int )TermWin.bcol - 1 < (int )swap.cur.col) {
#line 423
        swap.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
      }
    }
#line 425
    if (tabs) {
      {
#line 426
      free((void *)tabs);
      }
    }
  }
  {
#line 430
  tmp___47 = malloc((unsigned long )TermWin.bcol * sizeof(char ));
#line 430
  tabs = (char *)tmp___47;
#line 432
  i = 0;
  }
  {
#line 432
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 432
    if (! (i < (int )TermWin.bcol)) {
#line 432
      goto while_break___7;
    }
#line 433
    if (i % 8 == 0) {
#line 433
      *(tabs + i) = (char)1;
    } else {
#line 433
      *(tabs + i) = (char)0;
    }
#line 432
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 435
  prev_nrow = (int )TermWin.nrow;
#line 436
  prev_bcol = (int )TermWin.bcol;
#line 438
  tt_resize();
  }
#line 439
  return;
}
}
#line 446 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_release(void) 
{ 
  int i ;
  int total_rows ;

  {
#line 451
  total_rows = (int )TermWin.nrow + (int )TermWin.saveLines;
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < total_rows)) {
#line 452
      goto while_break;
    }
#line 453
    if (*(screen.text + i)) {
      {
#line 454
      free((void *)*(screen.text + i));
#line 455
      free((void *)*(screen.rend + i));
      }
    }
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  i = 0;
  {
#line 458
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 458
    if (! (i < (int )TermWin.nrow)) {
#line 458
      goto while_break___0;
    }
    {
#line 459
    free((void *)*(drawn_text + i));
#line 460
    free((void *)*(drawn_rend + i));
#line 461
    free((void *)*(swap.text + i));
#line 462
    free((void *)*(swap.rend + i));
#line 458
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 464
  free((void *)screen.text);
#line 465
  free((void *)screen.tlen);
#line 466
  free((void *)screen.rend);
#line 467
  free((void *)drawn_text);
#line 468
  free((void *)drawn_rend);
#line 469
  free((void *)swap.text);
#line 470
  free((void *)swap.tlen);
#line 471
  free((void *)swap.rend);
#line 472
  free((void *)buf_text);
#line 473
  free((void *)buf_tlen);
#line 474
  free((void *)buf_rend);
#line 475
  free((void *)tabs);
#line 478
  swap.text = (text_t **)((void *)0);
#line 478
  drawn_text = swap.text;
#line 478
  screen.text = drawn_text;
#line 479
  swap.rend = (rend_t **)((void *)0);
#line 479
  drawn_rend = swap.rend;
#line 479
  screen.rend = drawn_rend;
#line 480
  buf_tlen = (R_int16_t *)((void *)0);
#line 480
  swap.tlen = buf_tlen;
#line 480
  screen.tlen = swap.tlen;
#line 481
  buf_text = (text_t **)((void *)0);
#line 482
  buf_rend = (rend_t **)((void *)0);
#line 483
  tabs = (char *)((void *)0);
  }
#line 484
  return;
}
}
#line 488 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_poweron(void) 
{ 


  {
  {
#line 493
  rmemset((void *)(charsets), (unsigned char )'B', (R_int_p_t )sizeof(charsets));
#line 494
  rvideo = (short)0;
#line 495
  swap.tscroll = (R_int16_t )0;
#line 496
  swap.bscroll = (R_int16_t )((int )TermWin.nrow - 1);
#line 497
  swap.cur.col = (R_int16_t )0;
#line 497
  swap.cur.row = swap.cur.col;
#line 497
  screen.cur.col = swap.cur.row;
#line 497
  screen.cur.row = screen.cur.col;
#line 498
  swap.charset = (R_int16_t )0;
#line 498
  screen.charset = swap.charset;
#line 499
  swap.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 499
  screen.flags = swap.flags;
#line 501
  scr_cursor('s');
#line 503
  scr_release();
#line 504
  prev_nrow = -1;
#line 505
  prev_bcol = -1;
#line 506
  scr_reset();
#line 508
  scr_clear_tint(1);
#line 509
  scr_refresh(1 << 2);
#line 510
  Gr_reset();
  }
#line 511
  return;
}
}
#line 522 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_cursor(int mode ) 
{ 


  {
  {
#line 528
  if (mode == 115) {
#line 528
    goto case_115;
  }
#line 535
  if (mode == 114) {
#line 535
    goto case_114;
  }
#line 527
  goto switch_break;
  case_115: /* CIL Label */ 
#line 529
  save.cur.row = screen.cur.row;
#line 530
  save.cur.col = screen.cur.col;
#line 531
  save.rstyle = rstyle;
#line 532
  save.charset = screen.charset;
#line 533
  save.charset_char = charsets[screen.charset];
#line 534
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 536
  screen.cur.row = save.cur.row;
#line 537
  screen.cur.col = save.cur.col;
#line 538
  rstyle = save.rstyle;
#line 539
  screen.charset = save.charset;
#line 540
  charsets[screen.charset] = save.charset_char;
#line 541
  set_font_style();
  }
#line 542
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 545
  if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 545
    screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 546
  if ((int )TermWin.bcol - 1 < (int )screen.cur.col) {
#line 546
    screen.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 551
  if (0 > (int )screen.cur.row) {
#line 551
    screen.cur.row = (R_int16_t )0;
  }
#line 552
  if (0 > (int )screen.cur.col) {
#line 552
    screen.cur.col = (R_int16_t )0;
  }
#line 554
  return;
}
}
#line 563 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
int scr_change_screen(int scrn ) 
{ 
  int i ;
  int offset ;
  int tmp ;
  text_t *t0 ;
  rend_t *r0 ;
  R_int16_t l0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 573
  TermWin.view_start = (R_u_int16_t )0;
#line 576
  if ((int )current_screen == scrn) {
#line 577
    return ((int )current_screen);
  }
#line 579
  if (selection.op) {
    {
#line 579
    selection_check(2);
    }
  }
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    tmp = (int )current_screen;
#line 581
    current_screen = (short )scrn;
#line 581
    scrn = tmp;
#line 581
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  offset = (int )TermWin.saveLines;
#line 584
  i = (int )TermWin.nrow;
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    tmp___0 = i;
#line 584
    i --;
#line 584
    if (! tmp___0) {
#line 584
      goto while_break___0;
    }
    {
#line 585
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 585
      t0 = *(screen.text + (i + offset));
#line 585
      *(screen.text + (i + offset)) = *(swap.text + i);
#line 585
      *(swap.text + i) = t0;
#line 585
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 586
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 586
      l0 = *(screen.tlen + (i + offset));
#line 586
      *(screen.tlen + (i + offset)) = *(swap.tlen + i);
#line 586
      *(swap.tlen + i) = l0;
#line 586
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 587
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 587
      r0 = *(screen.rend + (i + offset));
#line 587
      *(screen.rend + (i + offset)) = *(swap.rend + i);
#line 587
      *(swap.rend + i) = r0;
#line 587
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 589
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 589
    l0 = screen.cur.row;
#line 589
    screen.cur.row = swap.cur.row;
#line 589
    swap.cur.row = l0;
#line 589
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 590
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 590
    l0 = screen.cur.col;
#line 590
    screen.cur.col = swap.cur.col;
#line 590
    swap.cur.col = l0;
#line 590
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 597
  if (0 > (int )screen.cur.row) {
#line 597
    screen.cur.row = (R_int16_t )0;
  }
#line 598
  if (0 > (int )screen.cur.col) {
#line 598
    screen.cur.col = (R_int16_t )0;
  }
#line 599
  if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 599
    screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 600
  if ((int )TermWin.bcol - 1 < (int )screen.cur.col) {
#line 600
    screen.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
  {
#line 602
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 602
    l0 = screen.charset;
#line 602
    screen.charset = swap.charset;
#line 602
    swap.charset = l0;
#line 602
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 603
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 603
    tmp = (int )screen.flags;
#line 603
    screen.flags = swap.flags;
#line 603
    swap.flags = (unsigned int )tmp;
#line 603
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 604
  screen.flags |= (unsigned int )(1 << 1);
#line 605
  swap.flags |= (unsigned int )(1 << 1);
#line 607
  tmp___1 = Gr_Displayed();
  }
#line 607
  if (tmp___1) {
    {
#line 608
    Gr_scroll(0);
#line 609
    Gr_ChangeScreen();
    }
  }
#line 626
  return (scrn);
}
}
#line 634 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_color(unsigned int color , unsigned int Intensity ) 
{ 


  {
#line 637
  if (color == 39U) {
#line 638
    color = 0U;
  } else
#line 639
  if (color == 49U) {
#line 640
    color = 1U;
  } else
#line 642
  if (Xdepth <= 2) {
    {
#line 644
    if (Intensity == 1024U) {
#line 644
      goto case_1024;
    }
#line 647
    if (Intensity == 2048U) {
#line 647
      goto case_2048;
    }
#line 643
    goto switch_break;
    case_1024: /* CIL Label */ 
#line 645
    color = 0U;
#line 646
    goto switch_break;
    case_2048: /* CIL Label */ 
#line 648
    color = 1U;
#line 649
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 653
  if ((unsigned int )rstyle & Intensity) {
#line 653
    if (color >= 2U) {
#line 653
      if (color <= 9U) {
#line 654
        color += 8U;
      } else {
#line 653
        goto _L___0;
      }
    } else {
#line 653
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 655
  if (color >= 10U) {
#line 655
    if (color <= 17U) {
#line 656
      if ((unsigned int )rstyle & Intensity) {
#line 657
        return;
      }
#line 658
      color -= 8U;
    }
  }
  {
#line 664
  if (Intensity == 1024U) {
#line 664
    goto case_1024___0;
  }
#line 667
  if (Intensity == 2048U) {
#line 667
    goto case_2048___0;
  }
#line 663
  goto switch_break___0;
  case_1024___0: /* CIL Label */ 
#line 665
  rstyle = (rend_t )(((unsigned int )rstyle & 4294967264U) | color);
#line 666
  goto switch_break___0;
  case_2048___0: /* CIL Label */ 
#line 668
  rstyle = (rend_t )(((unsigned int )rstyle & 4294966303U) | (color << 5));
#line 669
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 671
  return;
}
}
#line 678 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_rendition(int set , int style ) 
{ 
  unsigned int color ;
  rend_t font_attr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 684
  if (set) {
#line 686
    rstyle = (rend_t )((int )rstyle | style);
    {
#line 688
    if (style == 4096) {
#line 688
      goto case_4096;
    }
#line 693
    if (style == 1024) {
#line 693
      goto case_1024;
    }
#line 698
    if (style == 2048) {
#line 698
      goto case_2048;
    }
#line 687
    goto switch_break;
    case_4096: /* CIL Label */ 
#line 689
    if (rvideo) {
#line 690
      rstyle = (rend_t )((unsigned int )rstyle & 4294963199U);
    }
#line 691
    goto switch_break;
    case_1024: /* CIL Label */ 
#line 694
    color = (unsigned int )rstyle & 31U;
#line 695
    if (color == 0U) {
#line 695
      tmp = colorfgbg & 31U;
    } else {
#line 695
      tmp = color;
    }
    {
#line 695
    scr_color(tmp, 1024U);
    }
#line 697
    goto switch_break;
    case_2048: /* CIL Label */ 
#line 699
    color = ((unsigned int )rstyle & 992U) >> 5;
#line 700
    if (color == 1U) {
#line 700
      tmp___0 = (colorfgbg & 992U) >> 5;
    } else {
#line 700
      tmp___0 = color;
    }
    {
#line 700
    scr_color(tmp___0, 2048U);
    }
#line 702
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 707
    font_attr = (rend_t )((unsigned int )rstyle & 49152U);
#line 708
    rstyle = (rend_t )((int )rstyle & ~ style);
    {
#line 711
    if (style == -1) {
#line 711
      goto case_neg_1;
    }
#line 714
    if (style == 4096) {
#line 714
      goto case_4096___0;
    }
#line 719
    if (style == 1024) {
#line 719
      goto case_1024___0;
    }
#line 727
    if (style == 2048) {
#line 727
      goto case_2048___0;
    }
#line 710
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
#line 712
    rstyle = (rend_t )((1 << 5) | (int )font_attr);
    case_4096___0: /* CIL Label */ 
#line 715
    if (rvideo) {
#line 716
      rstyle = (rend_t )((unsigned int )rstyle | 4096U);
    }
#line 717
    goto switch_break___0;
    case_1024___0: /* CIL Label */ 
#line 720
    color = (unsigned int )rstyle & 31U;
#line 721
    if (color >= 10U) {
#line 721
      if (color <= 17U) {
        {
#line 722
        scr_color(color, 1024U);
        }
#line 723
        if (((unsigned int )rstyle & 31U) == (colorfgbg & 31U)) {
          {
#line 724
          scr_color(39U, 1024U);
          }
        }
      }
    }
#line 726
    goto switch_break___0;
    case_2048___0: /* CIL Label */ 
#line 728
    color = ((unsigned int )rstyle & 992U) >> 5;
#line 729
    if (color >= 10U) {
#line 729
      if (color <= 17U) {
        {
#line 730
        scr_color(color, 2048U);
        }
#line 731
        if (((unsigned int )rstyle & 992U) == (colorfgbg & 992U)) {
          {
#line 732
          scr_color(49U, 2048U);
          }
        }
      }
    }
#line 734
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 738
  return;
}
}
#line 748 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
int scroll_text(int row1 , int row2 , int count , int spec ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 755
  if (count == 0) {
#line 756
    return (0);
  } else
#line 755
  if (row1 > row2) {
#line 756
    return (0);
  }
#line 758
  if (count > 0) {
#line 758
    if (row1 == 0) {
#line 758
      if ((int )current_screen == 0) {
#line 759
        if ((int )TermWin.saveLines - (int )TermWin.nscrolled < count) {
#line 760
          TermWin.nscrolled = (R_u_int16_t )((int )TermWin.nscrolled + ((int )TermWin.saveLines - (int )TermWin.nscrolled));
        } else {
#line 762
          TermWin.nscrolled = (R_u_int16_t )((int )TermWin.nscrolled + count);
        }
#line 763
        if ((int )TermWin.saveLines < (int )TermWin.nscrolled) {
#line 763
          TermWin.nscrolled = TermWin.saveLines;
        }
      } else {
#line 758
        goto _L___0;
      }
    } else {
#line 758
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 764
  if (! spec) {
#line 765
    row1 += (int )TermWin.saveLines;
  }
#line 766
  row2 += (int )TermWin.saveLines;
#line 768
  if (selection.op) {
#line 768
    if ((int )current_screen == (int )selection.screen) {
#line 769
      i = (int )selection.beg.row + (int )TermWin.saveLines;
#line 770
      j = (int )selection.end.row + (int )TermWin.saveLines;
#line 771
      if (i < row1) {
#line 771
        if (j > row1) {
#line 771
          goto _L___1;
        } else {
#line 771
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 771
      if (i < row2) {
#line 771
        if (j > row2) {
#line 771
          goto _L___1;
        } else {
#line 771
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 771
      if (i - count < row1) {
#line 771
        if (i >= row1) {
#line 771
          goto _L___1;
        } else {
#line 771
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 771
      if (i - count > row2) {
#line 771
        if (i <= row2) {
#line 771
          goto _L___1;
        } else {
#line 771
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 771
      if (j - count < row1) {
#line 771
        if (j >= row1) {
#line 771
          goto _L___1;
        } else {
#line 771
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 771
      if (j - count > row2) {
#line 771
        if (j <= row2) {
          _L___1: /* CIL Label */ 
#line 777
          selection.end.col = (R_int16_t )0;
#line 777
          selection.end.row = selection.end.col;
#line 777
          selection.mark.col = selection.end.row;
#line 777
          selection.mark.row = selection.mark.col;
#line 777
          selection.beg.col = selection.mark.row;
#line 777
          selection.beg.row = selection.beg.col;
#line 778
          selection.op = (enum __anonenum_op_177 )0;
        } else {
#line 771
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 779
      if (j >= row1) {
#line 779
        if (j <= row2) {
#line 781
          selection.beg.row = (R_int16_t )((int )selection.beg.row - count);
#line 782
          selection.end.row = (R_int16_t )((int )selection.end.row - count);
#line 783
          selection.mark.row = (R_int16_t )((int )selection.mark.row - count);
        }
      }
    }
  }
#line 786
  if (selection.op) {
    {
#line 786
    selection_check(0);
    }
  }
#line 788
  if (count > 0) {
#line 791
    if ((row2 - row1) + 1 < count) {
#line 791
      count = (row2 - row1) + 1;
    }
#line 793
    i = 0;
#line 793
    j = row1;
    {
#line 793
    while (1) {
      while_continue: /* CIL Label */ ;
#line 793
      if (! (i < count)) {
#line 793
        goto while_break;
      }
#line 794
      *(buf_text + i) = *(screen.text + j);
#line 795
      *(buf_tlen + i) = *(screen.tlen + j);
#line 796
      *(buf_rend + i) = *(screen.rend + j);
#line 793
      i ++;
#line 793
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 799
    j = row1;
    {
#line 799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 799
      if (! (j + count <= row2)) {
#line 799
        goto while_break___0;
      }
#line 800
      *(screen.text + j) = *(screen.text + (j + count));
#line 801
      *(screen.tlen + j) = *(screen.tlen + (j + count));
#line 802
      *(screen.rend + j) = *(screen.rend + (j + count));
#line 799
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 805
    i = 0;
    {
#line 805
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 805
      if (! (i < count)) {
#line 805
        goto while_break___1;
      }
#line 806
      *(screen.text + j) = *(buf_text + i);
#line 807
      *(screen.tlen + j) = *(buf_tlen + i);
#line 808
      *(screen.rend + j) = *(buf_rend + i);
#line 805
      i ++;
#line 805
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 810
  if (count < 0) {
#line 813
    if (- count < (row2 - row1) + 1) {
#line 813
      count = - count;
    } else {
#line 813
      count = (row2 - row1) + 1;
    }
#line 815
    i = 0;
#line 815
    j = row2;
    {
#line 815
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 815
      if (! (i < count)) {
#line 815
        goto while_break___2;
      }
#line 816
      *(buf_text + i) = *(screen.text + j);
#line 817
      *(buf_tlen + i) = *(screen.tlen + j);
#line 818
      *(buf_rend + i) = *(screen.rend + j);
#line 815
      i ++;
#line 815
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 821
    j = row2;
    {
#line 821
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 821
      if (! (j - count >= row1)) {
#line 821
        goto while_break___3;
      }
#line 822
      *(screen.text + j) = *(screen.text + (j - count));
#line 823
      *(screen.tlen + j) = *(screen.tlen + (j - count));
#line 824
      *(screen.rend + j) = *(screen.rend + (j - count));
#line 821
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 827
    i = 0;
#line 827
    j = row1;
    {
#line 827
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 827
      if (! (i < count)) {
#line 827
        goto while_break___4;
      }
#line 828
      *(screen.text + j) = *(buf_text + i);
#line 829
      *(screen.tlen + j) = *(buf_tlen + i);
#line 830
      *(screen.rend + j) = *(buf_rend + i);
#line 827
      i ++;
#line 827
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 832
    count = - count;
  }
  {
#line 834
  tmp = Gr_Displayed();
  }
#line 834
  if (tmp) {
    {
#line 835
    Gr_scroll(count);
    }
  }
#line 836
  return (count);
}
}
#line 844 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_add_lines(unsigned char const   *str , int nlines , int len ) 
{ 
  char c ;
  int i ;
  int j ;
  int row ;
  int last_col ;
  int wherecursor ;
  int wrotespecial ;
  text_t *stp ;
  rend_t *srp ;
  int tmp ;
  int tmp___0 ;

  {
#line 852
  if (len <= 0) {
#line 853
    return;
  }
#line 855
  last_col = (int )TermWin.bcol;
#line 858
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 858
    TermWin.view_start = (R_u_int16_t )0;
  }
#line 859
  if (nlines > 0) {
#line 861
    nlines += (int )screen.cur.row - (int )screen.bscroll;
#line 862
    if (nlines > 0) {
#line 862
      if ((int )screen.tscroll == 0) {
#line 862
        if ((int )screen.bscroll == (int )TermWin.nrow - 1) {
          {
#line 864
          scroll_text((int )screen.tscroll, (int )screen.bscroll, nlines, 0);
#line 865
          i = nlines;
#line 865
          j = (int )screen.bscroll + (int )TermWin.saveLines;
          }
          {
#line 865
          while (1) {
            while_continue: /* CIL Label */ ;
#line 865
            tmp = i;
#line 865
            i --;
#line 865
            if (! tmp) {
#line 865
              goto while_break;
            }
#line 867
            if ((unsigned long )*(screen.text + j) == (unsigned long )((void *)0)) {
              {
#line 868
              make_screen_mem(screen.text, screen.rend, j, rstyle);
              }
            } else {
              {
#line 870
              blank_line(*(screen.text + j), *(screen.rend + j), (int )TermWin.bcol,
                         rstyle);
              }
            }
#line 871
            *(screen.tlen + j) = (R_int16_t )0;
#line 865
            j --;
          }
          while_break: /* CIL Label */ ;
          }
#line 873
          screen.cur.row = (R_int16_t )((int )screen.cur.row - nlines);
        }
      }
    }
  }
#line 881
  if (last_col - 1 < (int )screen.cur.col) {
#line 881
    screen.cur.col = (R_int16_t )(last_col - 1);
  }
#line 882
  if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 882
    screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 883
  if (- ((int )TermWin.nscrolled) > (int )screen.cur.row) {
#line 883
    screen.cur.row = (R_int16_t )(- ((int )TermWin.nscrolled));
  }
#line 885
  row = (int )screen.cur.row + (int )TermWin.saveLines;
#line 887
  if ((int )screen.cur.row < (int )selection.beg.row) {
#line 889
    wherecursor = -1;
  } else
#line 887
  if ((int )screen.cur.row == (int )selection.beg.row) {
#line 887
    if ((int )screen.cur.col < (int )selection.beg.col) {
#line 889
      wherecursor = -1;
    } else {
#line 887
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 890
  if ((int )screen.cur.row < (int )selection.end.row) {
#line 892
    wherecursor = 0;
  } else
#line 890
  if ((int )screen.cur.row == (int )selection.end.row) {
#line 890
    if ((int )screen.cur.col < (int )selection.end.col) {
#line 892
      wherecursor = 0;
    } else {
#line 894
      wherecursor = 1;
    }
  } else {
#line 894
    wherecursor = 1;
  }
#line 896
  stp = *(screen.text + row);
#line 897
  srp = *(screen.rend + row);
#line 906
  wrotespecial = len;
#line 906
  i = 0;
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 906
    if (! (i < len)) {
#line 906
      goto while_break___0;
    }
#line 908
    tmp___0 = i;
#line 908
    i ++;
#line 908
    c = (char )*(str + tmp___0);
    {
#line 929
    if ((int )c == 127) {
#line 929
      goto case_127;
    }
#line 932
    if ((int )c == 9) {
#line 932
      goto case_9;
    }
#line 936
    if ((int )c == 10) {
#line 936
      goto case_10;
    }
#line 955
    if ((int )c == 13) {
#line 955
      goto case_13;
    }
#line 962
    goto switch_default;
    case_127: /* CIL Label */ 
#line 930
    wrotespecial --;
#line 931
    goto __Cont;
    case_9: /* CIL Label */ 
    {
#line 933
    wrotespecial --;
#line 934
    scr_tab(1);
    }
#line 935
    goto __Cont;
    case_10: /* CIL Label */ 
#line 937
    wrotespecial --;
#line 938
    if ((int )*(screen.tlen + row) != -1) {
#line 939
      if ((int )screen.cur.col > (int )*(screen.tlen + row)) {
#line 939
        *(screen.tlen + row) = screen.cur.col;
      }
    }
#line 940
    screen.flags &= (unsigned int )(~ (1 << 4));
#line 941
    if ((int )screen.cur.row == (int )screen.bscroll) {
      {
#line 943
      scroll_text((int )screen.tscroll, (int )screen.bscroll, 1, 0);
#line 944
      j = (int )screen.bscroll + (int )TermWin.saveLines;
      }
#line 945
      if ((unsigned long )*(screen.text + j) == (unsigned long )((void *)0)) {
        {
#line 946
        make_screen_mem(screen.text, screen.rend, j, rstyle);
        }
      } else {
        {
#line 948
        blank_line(*(screen.text + j), *(screen.rend + j), (int )TermWin.bcol, rstyle);
        }
      }
#line 949
      *(screen.tlen + j) = (R_int16_t )0;
    } else
#line 950
    if ((int )screen.cur.row < (int )TermWin.nrow - 1) {
#line 951
      screen.cur.row = (R_int16_t )((int )screen.cur.row + 1);
#line 951
      row = (int )screen.cur.row + (int )TermWin.saveLines;
    }
#line 952
    stp = *(screen.text + row);
#line 953
    srp = *(screen.rend + row);
#line 954
    goto __Cont;
    case_13: /* CIL Label */ 
#line 956
    wrotespecial --;
#line 957
    if ((int )*(screen.tlen + row) != -1) {
#line 958
      if ((int )screen.cur.col > (int )*(screen.tlen + row)) {
#line 958
        *(screen.tlen + row) = screen.cur.col;
      }
    }
#line 959
    screen.flags &= (unsigned int )(~ (1 << 4));
#line 960
    screen.cur.col = (R_int16_t )0;
#line 961
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 966
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 972
    if (screen.flags & (unsigned int )(1 << 4)) {
#line 973
      *(screen.tlen + row) = (R_int16_t )-1;
#line 974
      if ((int )screen.cur.row == (int )screen.bscroll) {
        {
#line 975
        scroll_text((int )screen.tscroll, (int )screen.bscroll, 1, 0);
#line 976
        j = (int )screen.bscroll + (int )TermWin.saveLines;
        }
#line 977
        if ((unsigned long )*(screen.text + j) == (unsigned long )((void *)0)) {
          {
#line 978
          make_screen_mem(screen.text, screen.rend, j, rstyle);
          }
        } else {
          {
#line 980
          blank_line(*(screen.text + j), *(screen.rend + j), (int )TermWin.bcol, rstyle);
          }
        }
#line 982
        *(screen.tlen + j) = (R_int16_t )0;
      } else
#line 983
      if ((int )screen.cur.row < (int )TermWin.nrow - 1) {
#line 984
        screen.cur.row = (R_int16_t )((int )screen.cur.row + 1);
#line 984
        row = (int )screen.cur.row + (int )TermWin.saveLines;
      }
#line 985
      stp = *(screen.text + row);
#line 986
      srp = *(screen.rend + row);
#line 987
      screen.cur.col = (R_int16_t )0;
#line 988
      screen.flags &= (unsigned int )(~ (1 << 4));
    }
#line 990
    if (screen.flags & (unsigned int )(1 << 3)) {
      {
#line 991
      scr_insdel_chars(1, -1);
      }
    }
#line 992
    *(stp + screen.cur.col) = (text_t )c;
#line 993
    *(srp + screen.cur.col) = rstyle;
#line 997
    if ((int )screen.cur.col < last_col - 1) {
#line 998
      screen.cur.col = (R_int16_t )((int )screen.cur.col + 1);
    } else {
#line 1000
      *(screen.tlen + row) = (R_int16_t )last_col;
#line 1001
      if (screen.flags & (unsigned int )(1 << 2)) {
#line 1002
        screen.flags |= (unsigned int )(1 << 4);
      } else {
#line 1004
        screen.flags &= (unsigned int )(~ (1 << 4));
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1007
  if ((int )*(screen.tlen + row) != -1) {
#line 1008
    if ((int )screen.cur.col > (int )*(screen.tlen + row)) {
#line 1008
      *(screen.tlen + row) = screen.cur.col;
    }
  }
#line 1015
  if ((int )screen.cur.row < (int )selection.beg.row) {
#line 1017
    i = -1;
  } else
#line 1015
  if ((int )screen.cur.row == (int )selection.beg.row) {
#line 1015
    if ((int )screen.cur.col < (int )selection.beg.col) {
#line 1017
      i = -1;
    } else {
#line 1015
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1018
  if ((int )screen.cur.row < (int )selection.end.row) {
#line 1020
    i = 0;
  } else
#line 1018
  if ((int )screen.cur.row == (int )selection.end.row) {
#line 1018
    if ((int )screen.cur.col < (int )selection.end.col) {
#line 1020
      i = 0;
    } else {
#line 1022
      i = 1;
    }
  } else {
#line 1022
    i = 1;
  }
#line 1023
  if (selection.op) {
#line 1023
    if ((int )current_screen == (int )selection.screen) {
#line 1023
      if (wrotespecial != 0) {
#line 1023
        if (i != wherecursor) {
#line 1025
          selection.end.col = (R_int16_t )0;
#line 1025
          selection.end.row = selection.end.col;
#line 1025
          selection.beg.col = selection.end.row;
#line 1025
          selection.beg.row = selection.beg.col;
        } else
#line 1023
        if (i == 0) {
#line 1025
          selection.end.col = (R_int16_t )0;
#line 1025
          selection.end.row = selection.end.col;
#line 1025
          selection.beg.col = selection.end.row;
#line 1025
          selection.beg.row = selection.beg.col;
        }
      }
    }
  }
#line 1030
  if (0 > (int )screen.cur.row) {
#line 1030
    screen.cur.row = (R_int16_t )0;
  }
#line 1032
  return;
}
}
#line 1040 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_backspace(void) 
{ 


  {
#line 1044
  if ((int )screen.cur.col == 0) {
#line 1044
    if ((int )screen.cur.row > 0) {
#line 1045
      screen.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
#line 1046
      screen.cur.row = (R_int16_t )((int )screen.cur.row - 1);
    } else {
#line 1044
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1047
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1048
    screen.flags &= (unsigned int )(~ (1 << 4));
  } else {
    {
#line 1050
    scr_gotorc(0, -1, 3);
    }
  }
#line 1051
  return;
}
}
#line 1060 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_tab(int count ) 
{ 
  int i ;
  int x ;

  {
#line 1066
  x = (int )screen.cur.col;
#line 1067
  if (count == 0) {
#line 1068
    return;
  } else
#line 1069
  if (count > 0) {
#line 1070
    i = x + 1;
    {
#line 1070
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1070
      if (! (i < (int )TermWin.bcol)) {
#line 1070
        goto while_break;
      }
#line 1071
      if (*(tabs + i)) {
#line 1072
        x = i;
#line 1073
        count --;
#line 1073
        if (! count) {
#line 1074
          goto while_break;
        }
      }
#line 1070
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1077
  if (count < 0) {
#line 1078
    i = x - 1;
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1078
      if (! (i >= 0)) {
#line 1078
        goto while_break___0;
      }
#line 1079
      if (*(tabs + i)) {
#line 1080
        x = i;
#line 1081
        count ++;
#line 1081
        if (! count) {
#line 1082
          goto while_break___0;
        }
      }
#line 1078
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1086
  if (x != (int )screen.cur.col) {
    {
#line 1087
    scr_gotorc(0, x, 2);
    }
  }
#line 1088
  return;
}
}
#line 1095 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_gotorc(int row , int col , int relative ) 
{ 
  int tmp ;

  {
#line 1098
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1098
    TermWin.view_start = (R_u_int16_t )0;
  }
  {
#line 1100
  tmp = Gr_Displayed();
  }
#line 1100
  if (tmp) {
    {
#line 1101
    Gr_scroll(0);
    }
  }
#line 1105
  if (relative & 1) {
#line 1105
    screen.cur.col = (R_int16_t )((int )screen.cur.col + col);
  } else {
#line 1105
    screen.cur.col = (R_int16_t )col;
  }
#line 1106
  if (0 > (int )screen.cur.col) {
#line 1106
    screen.cur.col = (R_int16_t )0;
  }
#line 1107
  if ((int )TermWin.bcol - 1 < (int )screen.cur.col) {
#line 1107
    screen.cur.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 1109
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1110
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
#line 1112
  if (relative & 2) {
#line 1113
    if (row > 0) {
#line 1114
      if ((int )screen.cur.row <= (int )screen.bscroll) {
#line 1114
        if ((int )screen.cur.row + row > (int )screen.bscroll) {
#line 1116
          screen.cur.row = screen.bscroll;
        } else {
#line 1118
          screen.cur.row = (R_int16_t )((int )screen.cur.row + row);
        }
      } else {
#line 1118
        screen.cur.row = (R_int16_t )((int )screen.cur.row + row);
      }
    } else
#line 1119
    if (row < 0) {
#line 1120
      if ((int )screen.cur.row >= (int )screen.tscroll) {
#line 1120
        if ((int )screen.cur.row + row < (int )screen.tscroll) {
#line 1122
          screen.cur.row = screen.tscroll;
        } else {
#line 1124
          screen.cur.row = (R_int16_t )((int )screen.cur.row + row);
        }
      } else {
#line 1124
        screen.cur.row = (R_int16_t )((int )screen.cur.row + row);
      }
    }
  } else
#line 1127
  if (screen.flags & 1U) {
#line 1128
    screen.cur.row = (R_int16_t )(row + (int )screen.tscroll);
#line 1129
    if ((int )screen.bscroll < (int )screen.cur.row) {
#line 1129
      screen.cur.row = screen.bscroll;
    }
  } else {
#line 1131
    screen.cur.row = (R_int16_t )row;
  }
#line 1133
  if (0 > (int )screen.cur.row) {
#line 1133
    screen.cur.row = (R_int16_t )0;
  }
#line 1134
  if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 1134
    screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1135
  return;
}
}
#line 1142 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_index(int direction ) 
{ 
  int dirn ;
  int tmp ;

  {
#line 1147
  if (direction == 0) {
#line 1147
    dirn = 1;
  } else {
#line 1147
    dirn = -1;
  }
#line 1150
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1150
    TermWin.view_start = (R_u_int16_t )0;
  }
  {
#line 1152
  tmp = Gr_Displayed();
  }
#line 1152
  if (tmp) {
    {
#line 1153
    Gr_scroll(0);
    }
  }
#line 1155
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1156
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
#line 1158
  if ((int )screen.cur.row == (int )screen.bscroll) {
#line 1158
    if (direction == 0) {
#line 1158
      goto _L;
    } else {
#line 1158
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1158
  if ((int )screen.cur.row == (int )screen.tscroll) {
#line 1158
    if (direction == 1) {
      _L: /* CIL Label */ 
      {
#line 1160
      scroll_text((int )screen.tscroll, (int )screen.bscroll, dirn, 0);
      }
#line 1161
      if (direction == 0) {
#line 1162
        dirn = (int )screen.bscroll + (int )TermWin.saveLines;
      } else {
#line 1164
        dirn = (int )screen.tscroll + (int )TermWin.saveLines;
      }
#line 1165
      if ((unsigned long )*(screen.text + dirn) == (unsigned long )((void *)0)) {
        {
#line 1166
        make_screen_mem(screen.text, screen.rend, dirn, rstyle);
        }
      } else {
        {
#line 1168
        blank_line(*(screen.text + dirn), *(screen.rend + dirn), (int )TermWin.bcol,
                   rstyle);
        }
      }
#line 1170
      *(screen.tlen + dirn) = (R_int16_t )0;
    } else {
#line 1172
      screen.cur.row = (R_int16_t )((int )screen.cur.row + dirn);
    }
  } else {
#line 1172
    screen.cur.row = (R_int16_t )((int )screen.cur.row + dirn);
  }
#line 1173
  if (0 > (int )screen.cur.row) {
#line 1173
    screen.cur.row = (R_int16_t )0;
  }
#line 1174
  if ((int )TermWin.nrow - 1 < (int )screen.cur.row) {
#line 1174
    screen.cur.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1175
  if (selection.op) {
    {
#line 1175
    selection_check(0);
    }
  }
#line 1176
  return;
}
}
#line 1186 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_erase_line(int mode ) 
{ 
  int row ;
  int col ;
  int num ;
  int tmp ;

  {
#line 1192
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1192
    TermWin.view_start = (R_u_int16_t )0;
  }
  {
#line 1194
  tmp = Gr_Displayed();
  }
#line 1194
  if (tmp) {
    {
#line 1195
    Gr_scroll(0);
    }
  }
#line 1196
  if (selection.op) {
    {
#line 1196
    selection_check(1);
    }
  }
#line 1198
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1199
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
#line 1201
  row = (int )TermWin.saveLines + (int )screen.cur.row;
  {
#line 1203
  if (mode == 0) {
#line 1203
    goto case_0;
  }
#line 1211
  if (mode == 1) {
#line 1211
    goto case_1;
  }
#line 1218
  if (mode == 2) {
#line 1218
    goto case_2;
  }
#line 1226
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1204
  col = (int )screen.cur.col;
#line 1205
  num = (int )TermWin.bcol - col;
#line 1206
  if (col < (int )*(screen.tlen + row)) {
#line 1206
    *(screen.tlen + row) = (R_int16_t )col;
  }
#line 1207
  if ((int )selection.beg.row == (int )screen.cur.row) {
#line 1207
    if ((int )selection.beg.col >= (int )screen.cur.col) {
#line 1209
      selection.end.col = (R_int16_t )0;
#line 1209
      selection.end.row = selection.end.col;
#line 1209
      selection.beg.col = selection.end.row;
#line 1209
      selection.beg.row = selection.beg.col;
    } else {
#line 1207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if ((int )selection.end.row == (int )screen.cur.row) {
#line 1207
    if ((int )selection.end.col >= (int )screen.cur.col) {
#line 1209
      selection.end.col = (R_int16_t )0;
#line 1209
      selection.end.row = selection.end.col;
#line 1209
      selection.beg.col = selection.end.row;
#line 1209
      selection.beg.row = selection.beg.col;
    }
  }
#line 1210
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1212
  col = 0;
#line 1213
  num = (int )screen.cur.col + 1;
#line 1214
  if ((int )selection.beg.row == (int )screen.cur.row) {
#line 1214
    if ((int )selection.beg.col <= (int )screen.cur.col) {
#line 1216
      selection.end.col = (R_int16_t )0;
#line 1216
      selection.end.row = selection.end.col;
#line 1216
      selection.beg.col = selection.end.row;
#line 1216
      selection.beg.row = selection.beg.col;
    } else {
#line 1214
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1214
  if ((int )selection.end.row == (int )screen.cur.row) {
#line 1214
    if ((int )selection.end.col <= (int )screen.cur.col) {
#line 1216
      selection.end.col = (R_int16_t )0;
#line 1216
      selection.end.row = selection.end.col;
#line 1216
      selection.beg.col = selection.end.row;
#line 1216
      selection.beg.row = selection.beg.col;
    }
  }
#line 1217
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1219
  col = 0;
#line 1220
  num = (int )TermWin.bcol;
#line 1221
  *(screen.tlen + row) = (R_int16_t )0;
#line 1222
  if ((int )selection.beg.row <= (int )screen.cur.row) {
#line 1224
    selection.end.col = (R_int16_t )0;
#line 1224
    selection.end.row = selection.end.col;
#line 1224
    selection.beg.col = selection.end.row;
#line 1224
    selection.beg.row = selection.beg.col;
  } else
#line 1222
  if ((int )selection.end.row >= (int )screen.cur.row) {
#line 1224
    selection.end.col = (R_int16_t )0;
#line 1224
    selection.end.row = selection.end.col;
#line 1224
    selection.beg.col = selection.end.row;
#line 1224
    selection.beg.row = selection.beg.col;
  }
#line 1225
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1227
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1229
  blank_line(*(screen.text + row) + col, *(screen.rend + row) + col, num, (rend_t )((unsigned int )rstyle & 4294959103U));
  }
#line 1231
  return;
}
}
#line 1241 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_erase_screen(int mode ) 
{ 
  int row ;
  int num ;
  int row_offset ;
  rend_t ren ;
  long gcmask ;
  XGCValues gcvalue ;
  int tmp ;

  {
#line 1250
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1250
    TermWin.view_start = (R_u_int16_t )0;
  }
#line 1252
  row_offset = (int )TermWin.saveLines;
  {
#line 1255
  if (mode == 0) {
#line 1255
    goto case_0;
  }
#line 1261
  if (mode == 1) {
#line 1261
    goto case_1;
  }
#line 1267
  if (mode == 2) {
#line 1267
    goto case_2;
  }
#line 1273
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1256
  if (selection.op) {
    {
#line 1256
    selection_check(1);
    }
  }
  {
#line 1257
  scr_erase_line(0);
#line 1258
  row = (int )screen.cur.row + 1;
#line 1259
  num = (int )TermWin.nrow - row;
  }
#line 1260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1262
  if (selection.op) {
    {
#line 1262
    selection_check(3);
    }
  }
  {
#line 1263
  scr_erase_line(1);
#line 1264
  row = 0;
#line 1265
  num = (int )screen.cur.row;
  }
#line 1266
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1268
  if (selection.op) {
    {
#line 1268
    selection_check(3);
    }
  }
  {
#line 1269
  Gr_ClearScreen();
#line 1270
  row = 0;
#line 1271
  num = (int )TermWin.nrow;
  }
#line 1272
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1274
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1276
  if (selection.op) {
#line 1276
    if ((int )current_screen == (int )selection.screen) {
#line 1276
      if ((int )selection.beg.row >= row) {
#line 1276
        if ((int )selection.beg.row <= row + num) {
#line 1281
          selection.end.col = (R_int16_t )0;
#line 1281
          selection.end.row = selection.end.col;
#line 1281
          selection.beg.col = selection.end.row;
#line 1281
          selection.beg.row = selection.beg.col;
        } else {
#line 1276
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1276
      if ((int )selection.end.row >= row) {
#line 1276
        if ((int )selection.end.row <= row + num) {
#line 1281
          selection.end.col = (R_int16_t )0;
#line 1281
          selection.end.row = selection.end.col;
#line 1281
          selection.beg.col = selection.end.row;
#line 1281
          selection.beg.row = selection.beg.col;
        }
      }
    }
  }
#line 1282
  if (row >= 0) {
#line 1282
    if (row < (int )TermWin.nrow) {
#line 1283
      if ((int )TermWin.nrow - row < num) {
#line 1283
        num = (int )TermWin.nrow - row;
      }
#line 1284
      if ((unsigned int )rstyle & 12288U) {
#line 1285
        ren = (rend_t )(~ 0);
      } else
#line 1286
      if (((unsigned int )rstyle & 992U) >> 5 == 1U) {
        {
#line 1287
        ren = (rend_t )(1 << 5);
#line 1288
        CLEAR_ROWS((unsigned int )row, (unsigned int )num);
        }
      } else {
        {
#line 1290
        ren = (rend_t )((unsigned int )rstyle & 1023U);
#line 1291
        gcvalue.foreground = *(PixColors + (((unsigned int )ren & 992U) >> 5));
#line 1292
        gcmask = 1L << 2;
#line 1293
        XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
#line 1294
        XFillRectangle(Xdisplay, TermWin.vt, TermWin.gc, TermWin_internalBorder, row * (int )TermWin.fheight + TermWin_internalBorder,
                       (unsigned int )TermWin.width, (unsigned int )(num * (int )TermWin.fheight));
#line 1295
        gcvalue.foreground = *(PixColors + 0);
#line 1296
        XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
        }
      }
      {
#line 1298
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1298
        tmp = num;
#line 1298
        num --;
#line 1298
        if (! tmp) {
#line 1298
          goto while_break;
        }
        {
#line 1299
        blank_line(*(screen.text + (row + row_offset)), *(screen.rend + (row + row_offset)),
                   (int )TermWin.bcol, (rend_t )((unsigned int )rstyle & 4294959103U));
#line 1302
        *(screen.tlen + (row + row_offset)) = (R_int16_t )0;
#line 1303
        blank_line(*(drawn_text + row), *(drawn_rend + row), (int )TermWin.bcol, ren);
#line 1298
        row ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1306
  return;
}
}
#line 1314 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_E(void) 
{ 
  int i ;
  int j ;
  text_t *t ;
  rend_t *r ;
  rend_t fs ;
  text_t *tmp ;
  rend_t *tmp___0 ;

  {
#line 1321
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1321
    TermWin.view_start = (R_u_int16_t )0;
  }
#line 1323
  if (selection.op) {
    {
#line 1323
    selection_check(3);
    }
  }
#line 1325
  fs = rstyle;
#line 1326
  i = (int )TermWin.saveLines;
  {
#line 1326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1326
    if (! (i < (int )TermWin.nrow + (int )TermWin.saveLines)) {
#line 1326
      goto while_break;
    }
#line 1327
    t = *(screen.text + i);
#line 1328
    r = *(screen.rend + i);
#line 1329
    j = 0;
    {
#line 1329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1329
      if (! (j < (int )TermWin.bcol)) {
#line 1329
        goto while_break___0;
      }
#line 1330
      tmp = t;
#line 1330
      t ++;
#line 1330
      *tmp = (text_t )'E';
#line 1331
      tmp___0 = r;
#line 1331
      r ++;
#line 1331
      *tmp___0 = fs;
#line 1329
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1333
    *(screen.tlen + i) = (R_int16_t )TermWin.bcol;
#line 1326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1335
  return;
}
}
#line 1342 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_insdel_lines(int count , int insdel ) 
{ 
  int end ;
  int tmp ;
  int tmp___0 ;

  {
#line 1347
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1347
    TermWin.view_start = (R_u_int16_t )0;
  }
  {
#line 1349
  tmp = Gr_Displayed();
  }
#line 1349
  if (tmp) {
    {
#line 1350
    Gr_scroll(0);
    }
  }
#line 1351
  if (selection.op) {
    {
#line 1351
    selection_check(1);
    }
  }
#line 1353
  if ((int )screen.cur.row > (int )screen.bscroll) {
#line 1354
    return;
  }
#line 1356
  end = ((int )screen.bscroll - (int )screen.cur.row) + 1;
#line 1357
  if (count > end) {
#line 1358
    if (insdel == 1) {
#line 1359
      return;
    } else
#line 1360
    if (insdel == -1) {
#line 1361
      count = end;
    }
  }
#line 1363
  if (screen.flags & (unsigned int )(1 << 4)) {
#line 1364
    screen.flags &= (unsigned int )(~ (1 << 4));
  }
  {
#line 1366
  scroll_text((int )screen.cur.row, (int )screen.bscroll, insdel * count, 0);
  }
#line 1369
  if (insdel == 1) {
#line 1370
    end = (int )screen.bscroll + (int )TermWin.saveLines;
  } else
#line 1371
  if (insdel == -1) {
#line 1372
    end = (((int )screen.cur.row + count) - 1) + (int )TermWin.saveLines;
  }
  {
#line 1374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1374
    tmp___0 = count;
#line 1374
    count --;
#line 1374
    if (! tmp___0) {
#line 1374
      goto while_break;
    }
#line 1375
    if ((unsigned long )*(screen.text + end) == (unsigned long )((void *)0)) {
      {
#line 1376
      make_screen_mem(screen.text, screen.rend, end, rstyle);
      }
    } else {
      {
#line 1378
      blank_line(*(screen.text + end), *(screen.rend + end), (int )TermWin.bcol, rstyle);
      }
    }
#line 1380
    *(screen.tlen + end) = (R_int16_t )0;
#line 1374
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  return;
}
}
#line 1389 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_insdel_chars(int count , int insdel ) 
{ 
  int col ;
  int row ;
  rend_t tr ;
  int tmp ;

  {
#line 1395
  if ((Options & (1UL << 11)) == 1UL << 11) {
#line 1395
    TermWin.view_start = (R_u_int16_t )0;
  }
  {
#line 1397
  tmp = Gr_Displayed();
  }
#line 1397
  if (tmp) {
    {
#line 1398
    Gr_scroll(0);
    }
  }
#line 1400
  if (count <= 0) {
#line 1401
    return;
  }
#line 1402
  if (selection.op) {
    {
#line 1402
    selection_check(1);
    }
  }
#line 1403
  if ((int )TermWin.bcol - (int )screen.cur.col < count) {
#line 1403
    count = (int )TermWin.bcol - (int )screen.cur.col;
  }
#line 1405
  row = (int )screen.cur.row + (int )TermWin.saveLines;
#line 1406
  screen.flags &= (unsigned int )(~ (1 << 4));
  {
#line 1409
  if (insdel == -1) {
#line 1409
    goto case_neg_1;
  }
#line 1433
  if (insdel == 2) {
#line 1433
    goto case_2;
  }
#line 1441
  if (insdel == 1) {
#line 1441
    goto case_1;
  }
#line 1408
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1410
  col = (int )TermWin.bcol - 1;
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1410
    if (! (col - count >= (int )screen.cur.col)) {
#line 1410
      goto while_break;
    }
#line 1411
    *(*(screen.text + row) + col) = *(*(screen.text + row) + (col - count));
#line 1412
    *(*(screen.rend + row) + col) = *(*(screen.rend + row) + (col - count));
#line 1410
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  if ((int )*(screen.tlen + row) != -1) {
#line 1415
    *(screen.tlen + row) = (R_int16_t )((int )*(screen.tlen + row) + count);
#line 1416
    if ((int )TermWin.bcol < (int )*(screen.tlen + row)) {
#line 1416
      *(screen.tlen + row) = (R_int16_t )TermWin.bcol;
    }
  }
#line 1418
  if (selection.op) {
#line 1418
    if ((int )current_screen == (int )selection.screen) {
#line 1418
      if ((int )selection.beg.row == (int )screen.cur.row) {
#line 1418
        if ((int )selection.beg.col >= (int )screen.cur.col) {
#line 1420
          if ((int )selection.end.row != (int )screen.cur.row) {
#line 1422
            selection.end.col = (R_int16_t )0;
#line 1422
            selection.end.row = selection.end.col;
#line 1422
            selection.beg.col = selection.end.row;
#line 1422
            selection.beg.row = selection.beg.col;
          } else
#line 1420
          if ((int )selection.end.col + count >= (int )TermWin.bcol) {
#line 1422
            selection.end.col = (R_int16_t )0;
#line 1422
            selection.end.row = selection.end.col;
#line 1422
            selection.beg.col = selection.end.row;
#line 1422
            selection.beg.row = selection.beg.col;
          } else {
#line 1424
            selection.beg.col = (R_int16_t )((int )selection.beg.col + count);
#line 1425
            selection.mark.col = (R_int16_t )((int )selection.mark.col + count);
#line 1426
            selection.end.col = (R_int16_t )((int )selection.end.col + count);
          }
        }
      }
    }
  }
  {
#line 1429
  blank_line(*(screen.text + row) + screen.cur.col, *(screen.rend + row) + screen.cur.col,
             count, rstyle);
  }
#line 1432
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1434
  screen.cur.col = (R_int16_t )((int )screen.cur.col + count);
#line 1435
  if (selection.op) {
    {
#line 1435
    selection_check(1);
    }
  }
  {
#line 1436
  screen.cur.col = (R_int16_t )((int )screen.cur.col - count);
#line 1437
  blank_line(*(screen.text + row) + screen.cur.col, *(screen.rend + row) + screen.cur.col,
             count, rstyle);
  }
#line 1440
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1442
  tr = (rend_t )((unsigned int )*(*(screen.rend + row) + ((int )TermWin.bcol - 1)) & 16383U);
#line 1444
  col = (int )screen.cur.col;
  {
#line 1444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1444
    if (! (col + count < (int )TermWin.bcol)) {
#line 1444
      goto while_break___0;
    }
#line 1445
    *(*(screen.text + row) + col) = *(*(screen.text + row) + (col + count));
#line 1446
    *(*(screen.rend + row) + col) = *(*(screen.rend + row) + (col + count));
#line 1444
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1448
  blank_line(*(screen.text + row) + ((int )TermWin.bcol - count), *(screen.rend + row) + ((int )TermWin.bcol - count),
             count, tr);
  }
#line 1451
  if ((int )*(screen.tlen + row) == -1) {
#line 1452
    *(screen.tlen + row) = (R_int16_t )TermWin.bcol;
  }
#line 1453
  *(screen.tlen + row) = (R_int16_t )((int )*(screen.tlen + row) - count);
#line 1454
  if (0 > (int )*(screen.tlen + row)) {
#line 1454
    *(screen.tlen + row) = (R_int16_t )0;
  }
#line 1455
  if (selection.op) {
#line 1455
    if ((int )current_screen == (int )selection.screen) {
#line 1455
      if ((int )selection.beg.row == (int )screen.cur.row) {
#line 1455
        if ((int )selection.beg.col >= (int )screen.cur.col) {
#line 1457
          if ((int )selection.end.row != (int )screen.cur.row) {
#line 1460
            selection.end.col = (R_int16_t )0;
#line 1460
            selection.end.row = selection.end.col;
#line 1460
            selection.beg.col = selection.end.row;
#line 1460
            selection.beg.row = selection.beg.col;
          } else
#line 1457
          if ((int )screen.cur.col >= (int )selection.beg.col - count) {
#line 1460
            selection.end.col = (R_int16_t )0;
#line 1460
            selection.end.row = selection.end.col;
#line 1460
            selection.beg.col = selection.end.row;
#line 1460
            selection.beg.row = selection.beg.col;
          } else
#line 1457
          if ((int )selection.end.col >= (int )TermWin.bcol) {
#line 1460
            selection.end.col = (R_int16_t )0;
#line 1460
            selection.end.row = selection.end.col;
#line 1460
            selection.beg.col = selection.end.row;
#line 1460
            selection.beg.row = selection.beg.col;
          } else {
#line 1463
            selection.beg.col = (R_int16_t )((int )selection.beg.col - count);
#line 1464
            selection.mark.col = (R_int16_t )((int )selection.mark.col - count);
#line 1465
            selection.end.col = (R_int16_t )((int )selection.end.col - count);
          }
        }
      }
    }
  }
#line 1468
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1480
  return;
}
}
#line 1488 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_scroll_region(int top , int bot ) 
{ 


  {
#line 1491
  if (0 > top) {
#line 1491
    top = 0;
  }
#line 1492
  if ((int )TermWin.nrow - 1 < bot) {
#line 1492
    bot = (int )TermWin.nrow - 1;
  }
#line 1493
  if (top > bot) {
#line 1494
    return;
  }
  {
#line 1495
  screen.tscroll = (R_int16_t )top;
#line 1496
  screen.bscroll = (R_int16_t )bot;
#line 1497
  scr_gotorc(0, 0, 0);
  }
#line 1498
  return;
}
}
#line 1507 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_cursor_visible(int mode ) 
{ 


  {
#line 1510
  if (mode) {
#line 1511
    screen.flags |= (unsigned int )(1 << 1);
  } else {
#line 1513
    screen.flags &= (unsigned int )(~ (1 << 1));
  }
#line 1514
  return;
}
}
#line 1523 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_autowrap(int mode ) 
{ 


  {
#line 1526
  if (mode) {
#line 1527
    screen.flags |= (unsigned int )(1 << 2);
  } else {
#line 1529
    screen.flags &= (unsigned int )(~ (1 << 2));
  }
#line 1530
  return;
}
}
#line 1543 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_relative_origin(int mode ) 
{ 


  {
#line 1546
  if (mode) {
#line 1547
    screen.flags |= 1U;
  } else {
#line 1549
    screen.flags &= 4294967294U;
  }
  {
#line 1550
  scr_gotorc(0, 0, 0);
  }
#line 1551
  return;
}
}
#line 1560 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_insert_mode(int mode ) 
{ 


  {
#line 1563
  if (mode) {
#line 1564
    screen.flags |= (unsigned int )(1 << 3);
  } else {
#line 1566
    screen.flags &= (unsigned int )(~ (1 << 3));
  }
#line 1567
  return;
}
}
#line 1577 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_set_tab(int mode ) 
{ 


  {
#line 1580
  if (mode < 0) {
    {
#line 1581
    rmemset((void *)tabs, (unsigned char)0, (R_int_p_t )((unsigned long )TermWin.bcol * sizeof(char )));
    }
  } else
#line 1583
  if ((int )screen.cur.col < (int )TermWin.bcol) {
#line 1584
    if (mode) {
#line 1584
      *(tabs + screen.cur.col) = (char)1;
    } else {
#line 1584
      *(tabs + screen.cur.col) = (char)0;
    }
  }
#line 1585
  return;
}
}
#line 1594 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_rvideo_mode(int mode ) 
{ 
  int i ;
  int j ;
  int maxlines ;

  {
#line 1599
  if ((int )rvideo != mode) {
#line 1600
    rvideo = (short )mode;
#line 1601
    rstyle = (rend_t )((unsigned int )rstyle ^ 4096U);
#line 1603
    maxlines = (int )TermWin.saveLines + (int )TermWin.nrow;
#line 1604
    i = (int )TermWin.saveLines;
    {
#line 1604
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1604
      if (! (i < maxlines)) {
#line 1604
        goto while_break;
      }
#line 1605
      j = 0;
      {
#line 1605
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1605
        if (! (j < (int )TermWin.bcol + 1)) {
#line 1605
          goto while_break___0;
        }
#line 1606
        *(*(screen.rend + i) + j) = (rend_t )((unsigned int )*(*(screen.rend + i) + j) ^ 4096U);
#line 1605
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1604
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1607
    scr_refresh(1 << 2);
    }
  }
#line 1609
  return;
}
}
#line 1617 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_report_position(void) 
{ 


  {
  {
#line 1620
  tt_printf((unsigned char const   *)((unsigned char *)"\033[%d;%dR"), (int )screen.cur.row + 1,
            (int )screen.cur.col + 1);
  }
#line 1622
  return;
}
}
#line 1631 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void set_font_style(void) 
{ 


  {
#line 1634
  rstyle = (rend_t )((unsigned int )rstyle & 4294918143U);
  {
#line 1636
  if ((int )charsets[screen.charset] == 48) {
#line 1636
    goto case_48;
  }
#line 1639
  if ((int )charsets[screen.charset] == 65) {
#line 1639
    goto case_65;
  }
#line 1642
  if ((int )charsets[screen.charset] == 66) {
#line 1642
    goto case_66;
  }
#line 1644
  if ((int )charsets[screen.charset] == 60) {
#line 1644
    goto case_60;
  }
#line 1646
  if ((int )charsets[screen.charset] == 53) {
#line 1646
    goto case_53;
  }
#line 1648
  if ((int )charsets[screen.charset] == 67) {
#line 1648
    goto case_67;
  }
#line 1650
  if ((int )charsets[screen.charset] == 75) {
#line 1650
    goto case_75;
  }
#line 1635
  goto switch_break;
  case_48: /* CIL Label */ 
#line 1637
  rstyle = (rend_t )((unsigned int )rstyle | 16384U);
#line 1638
  goto switch_break;
  case_65: /* CIL Label */ 
#line 1640
  rstyle = (rend_t )((unsigned int )rstyle | 32768U);
#line 1641
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1643
  goto switch_break;
  case_60: /* CIL Label */ 
#line 1645
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1647
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1649
  goto switch_break;
  case_75: /* CIL Label */ 
#line 1651
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1653
  return;
}
}
#line 1664 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_charset_choose(int set ) 
{ 


  {
  {
#line 1667
  screen.charset = (R_int16_t )set;
#line 1668
  set_font_style();
  }
#line 1669
  return;
}
}
#line 1681 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_charset_set(int set , unsigned int ch ) 
{ 


  {
  {
#line 1688
  charsets[set] = (char )((unsigned char )ch);
#line 1689
  set_font_style();
  }
#line 1690
  return;
}
}
#line 1787 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_expose(int x , int y , int width , int height ) 
{ 
  int i ;
  row_col_t full_beg ;
  row_col_t full_end ;
  row_col_t part_beg ;
  row_col_t part_end ;

  {
#line 1796
  if ((unsigned long )drawn_text == (unsigned long )((void *)0)) {
#line 1797
    return;
  }
#line 1800
  part_beg.col = (R_int16_t )((x - TermWin_internalBorder) / (int )TermWin.fwidth);
#line 1801
  part_beg.row = (R_int16_t )((y - TermWin_internalBorder) / (int )TermWin.fheight);
#line 1802
  full_end.col = (R_int16_t )((x + width) / (int )TermWin.fwidth);
#line 1803
  full_end.row = (R_int16_t )(((y + height) - TermWin_internalBorder) / (int )TermWin.fheight);
#line 1806
  part_end.col = (R_int16_t )((((x + width) + (int )TermWin.fwidth) - 1) / (int )TermWin.fwidth);
#line 1807
  part_end.row = (R_int16_t )(((((y + height) + (int )TermWin.fheight) - 1) - TermWin_internalBorder) / (int )TermWin.fheight);
#line 1808
  full_beg.col = (R_int16_t )((((x + (int )TermWin.fwidth) - 1) - TermWin_internalBorder) / (int )TermWin.fwidth);
#line 1809
  full_beg.row = (R_int16_t )((((y + (int )TermWin.fheight) - 1) - TermWin_internalBorder) / (int )TermWin.fheight);
#line 1812
  if (0 > (int )part_beg.col) {
#line 1812
    part_beg.col = (R_int16_t )0;
  }
#line 1813
  if (0 > (int )full_beg.col) {
#line 1813
    full_beg.col = (R_int16_t )0;
  }
#line 1814
  if (0 > (int )part_end.col) {
#line 1814
    part_end.col = (R_int16_t )0;
  }
#line 1815
  if (0 > (int )full_end.col) {
#line 1815
    full_end.col = (R_int16_t )0;
  }
#line 1816
  if (0 > (int )part_beg.row) {
#line 1816
    part_beg.row = (R_int16_t )0;
  }
#line 1817
  if (0 > (int )full_beg.row) {
#line 1817
    full_beg.row = (R_int16_t )0;
  }
#line 1818
  if (0 > (int )part_end.row) {
#line 1818
    part_end.row = (R_int16_t )0;
  }
#line 1819
  if (0 > (int )full_end.row) {
#line 1819
    full_end.row = (R_int16_t )0;
  }
#line 1820
  if ((int )TermWin.bcol - 1 < (int )part_beg.col) {
#line 1820
    part_beg.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 1821
  if ((int )TermWin.bcol - 1 < (int )full_beg.col) {
#line 1821
    full_beg.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 1822
  if ((int )TermWin.bcol - 1 < (int )part_end.col) {
#line 1822
    part_end.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 1823
  if ((int )TermWin.bcol - 1 < (int )full_end.col) {
#line 1823
    full_end.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 1824
  if ((int )TermWin.nrow - 1 < (int )part_beg.row) {
#line 1824
    part_beg.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1825
  if ((int )TermWin.nrow - 1 < (int )full_beg.row) {
#line 1825
    full_beg.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1826
  if ((int )TermWin.nrow - 1 < (int )part_end.row) {
#line 1826
    part_end.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1827
  if ((int )TermWin.nrow - 1 < (int )full_end.row) {
#line 1827
    full_end.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 1832
  i = (int )part_beg.row;
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1832
    if (! (i <= (int )part_end.row)) {
#line 1832
      goto while_break;
    }
    {
#line 1833
    rmemset((void *)(*(drawn_text + i) + part_beg.col), (unsigned char)0, (R_int_p_t )(((int )part_end.col - (int )part_beg.col) + 1));
#line 1832
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1860
  scr_refresh(1 << 2);
  }
#line 1861
  return;
}
}
#line 1868 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_touch(void) 
{ 


  {
  {
#line 1871
  scr_expose(0, 0, (int )TermWin.width, (int )TermWin.height);
  }
#line 1872
  return;
}
}
#line 1880 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
int scr_move_to(int y , int len ) 
{ 
  int start ;
  int t ;
  int tmp ;

  {
#line 1885
  start = (int )TermWin.view_start;
#line 1886
  t = ((len - y) * (((int )TermWin.nrow - 1) + (int )TermWin.nscrolled)) / len - ((int )TermWin.nrow - 1);
#line 1890
  if (0 > t) {
#line 1890
    t = 0;
  }
#line 1891
  if ((int )TermWin.nscrolled < t) {
#line 1891
    t = (int )TermWin.nscrolled;
  }
  {
#line 1893
  TermWin.view_start = (R_u_int16_t )t;
#line 1895
  tmp = Gr_Displayed();
  }
#line 1895
  if (tmp) {
    {
#line 1896
    Gr_scroll(0);
    }
  }
#line 1897
  return ((int )TermWin.view_start - start);
}
}
#line 1905 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
int scr_page(int direction , int nlines ) 
{ 
  int start ;
  int dirn ;
  int tmp ;

  {
#line 1912
  if (direction == 0) {
#line 1912
    dirn = 1;
  } else {
#line 1912
    dirn = -1;
  }
#line 1913
  start = (int )TermWin.view_start;
#line 1914
  if (1 > nlines) {
#line 1914
    nlines = 1;
  }
#line 1915
  if ((int )TermWin.nrow < nlines) {
#line 1915
    nlines = (int )TermWin.nrow;
  }
#line 1917
  if (dirn == -1) {
#line 1917
    if ((int )TermWin.view_start < nlines) {
#line 1918
      TermWin.view_start = (R_u_int16_t )0;
    } else {
#line 1920
      TermWin.view_start = (R_u_int16_t )((int )TermWin.view_start + nlines * dirn);
    }
  } else {
#line 1920
    TermWin.view_start = (R_u_int16_t )((int )TermWin.view_start + nlines * dirn);
  }
#line 1922
  if (dirn == 1) {
#line 1922
    if (start > (int )TermWin.view_start) {
#line 1923
      TermWin.view_start = TermWin.nscrolled;
    }
  }
#line 1926
  if ((int )TermWin.nscrolled < (int )TermWin.view_start) {
#line 1926
    TermWin.view_start = TermWin.nscrolled;
  }
  {
#line 1928
  tmp = Gr_Displayed();
  }
#line 1928
  if (tmp) {
    {
#line 1929
    Gr_scroll(0);
    }
  }
#line 1930
  return ((int )TermWin.view_start - start);
}
}
#line 1935 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_bell(void) 
{ 


  {
#line 1940
  if (Options & (1UL << 4)) {
    {
#line 1942
    XMapWindow(Xdisplay, TermWin.parent);
    }
  }
#line 1944
  if (Options & (1UL << 3)) {
    {
#line 1945
    scr_rvideo_mode(! rvideo);
#line 1946
    scr_rvideo_mode(! rvideo);
    }
  } else {
    {
#line 1948
    XBell(Xdisplay, 0);
    }
  }
#line 1949
  return;
}
}
#line 1954 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_printscreen(int fullhist ) 
{ 


  {
#line 1978
  return;
}
}
#line 2017 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static int focus  =    -1;
#line 2033 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static char *buffer  =    (char *)((void *)0);
#line 2034 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static int currmaxcol  =    0;
#line 2038 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static row_col_t oldcursor  =    {(R_int16_t )-1, (R_int16_t )-1};
#line 1997 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_refresh(int type ) 
{ 
  int i ;
  int j ;
  int col ;
  int row ;
  int scrrow ;
  int row_offset ;
  int currow ;
  int boldlast ;
  int len ;
  int wlen ;
  int fprop ;
  int is_cursor ;
  int rvid ;
  int rend ;
  int fore ;
  int back ;
  int wbyte ;
  int morecur ;
  int xpixel ;
  int ypixel ;
  long gcmask ;
  unsigned long ltmp ;
  rend_t rt1 ;
  rend_t rt2 ;
  rend_t ccol1 ;
  rend_t ccol2 ;
  rend_t cc1 ;
  rend_t *drp ;
  rend_t *srp ;
  text_t *dtp ;
  text_t *stp ;
  XGCValues gcvalue ;
  XFontStruct *wf ;
  int bfont ;
  int (*draw_string)() ;
  int (*draw_image_string)() ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int do_stuff ;
  int char_num ;
  rend_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2000
  morecur = 0;
#line 2000
  ypixel = 0;
#line 2022
  cc1 = (rend_t )0;
#line 2047
  bfont = 0;
#line 2052
  if (type == 0) {
#line 2053
    return;
  }
#line 2058
  if (currmaxcol < (int )TermWin.ncol) {
#line 2059
    currmaxcol = (int )TermWin.ncol;
#line 2060
    if (buffer) {
#line 2061
      if (buffer) {
        {
#line 2061
        tmp = realloc((void *)buffer, sizeof(char ) * (unsigned long )(currmaxcol + 1));
#line 2061
        buffer = (char *)tmp;
        }
      } else {
        {
#line 2061
        tmp___0 = malloc(sizeof(char ) * (unsigned long )(currmaxcol + 1));
#line 2061
        buffer = (char *)tmp___0;
        }
      }
    } else {
      {
#line 2063
      tmp___1 = malloc(sizeof(char ) * (unsigned long )(currmaxcol + 1));
#line 2063
      buffer = (char *)tmp___1;
      }
    }
  }
  {
#line 2065
  row_offset = (int )TermWin.saveLines - (int )TermWin.view_start;
#line 2066
  fprop = (int )TermWin.fprop;
#line 2067
  is_cursor = 0;
#line 2068
  gcvalue.foreground = *(PixColors + 0);
#line 2069
  gcvalue.background = *(PixColors + 1);
#line 2070
  stp = (text_t *)((void *)0);
#line 2070
  dtp = stp;
#line 2075
  wbyte = 0;
#line 2076
  XSetFont(Xdisplay, TermWin.gc, (TermWin.font)->fid);
#line 2077
  draw_string = (int (*)())(& XDrawString);
#line 2078
  draw_image_string = (int (*)())(& XDrawImageString);
#line 2079
  boldlast = 0;
#line 2080
  wf = TermWin.font;
#line 2089
  row = 0;
  }
  {
#line 2089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2089
    if (! (row < (int )TermWin.nrow)) {
#line 2089
      goto while_break;
    }
#line 2090
    scrrow = row + row_offset;
#line 2091
    stp = *(screen.text + scrrow);
#line 2092
    srp = *(screen.rend + scrrow);
#line 2093
    dtp = *(drawn_text + row);
#line 2094
    drp = *(drawn_rend + row);
#line 2096
    if ((unsigned long )TermWin.boldFont == (unsigned long )((void *)0)) {
#line 2098
      j = wbyte;
#line 2099
      col = (int )TermWin.ncol - 2;
      {
#line 2099
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2099
        if (! (col >= 0)) {
#line 2099
          goto while_break___0;
        }
#line 2104
        if (! ((unsigned int )*(drp + col) & 3072U)) {
#line 2105
          goto __Cont;
        }
#line 2106
        if ((int )*(dtp + col) == (int )*(stp + col)) {
#line 2106
          if ((int )*(drp + col) == (int )*(srp + col)) {
#line 2108
            goto __Cont;
          }
        }
#line 2109
        if (wbyte) {
#line 2111
          goto __Cont;
        }
#line 2113
        if ((int )*(dtp + col) == 32) {
#line 2114
          goto __Cont;
        }
#line 2117
        if ((unsigned long )wf->per_char == (unsigned long )((void *)0)) {
#line 2118
          do_stuff = 1;
        } else
#line 2119
        if ((unsigned int )*(dtp + col) >= wf->min_char_or_byte2) {
#line 2119
          if ((unsigned int )*(dtp + col) < wf->max_char_or_byte2) {
#line 2122
            char_num = (int )((unsigned int )*(dtp + col) - wf->min_char_or_byte2);
#line 2123
            do_stuff = (int )(wf->per_char + char_num)->width == (int )(wf->per_char + char_num)->rbearing;
          } else {
#line 2126
            do_stuff = 0;
          }
        } else {
#line 2126
          do_stuff = 0;
        }
#line 2128
        if (do_stuff) {
#line 2131
          *(dtp + (col + 1)) = (text_t )0;
        }
        __Cont: /* CIL Label */ 
#line 2099
        col --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2145
      if ((unsigned int )*(srp + ((int )TermWin.ncol - 1)) & 3072U) {
#line 2146
        boldlast = 1;
      }
#line 2147
      wbyte = j;
    }
#line 2089
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2157
  scr_reverse_selection();
#line 2162
  currow = (int )screen.cur.row + (int )TermWin.saveLines;
  }
#line 2163
  if (focus != (int )TermWin.focus) {
#line 2164
    focus = (int )TermWin.focus;
  }
#line 2165
  if (screen.flags & (unsigned int )(1 << 1)) {
#line 2165
    if (focus) {
#line 2167
      srp = *(screen.rend + currow) + screen.cur.col;
#line 2173
      cc1 = (rend_t )((unsigned int )*srp & 1023U);
#line 2174
      if (Xdepth <= 2) {
#line 2175
        ccol1 = (rend_t )0;
      } else
#line 2174
      if (! rs_color[18]) {
#line 2175
        ccol1 = (rend_t )0;
      } else {
#line 2177
        ccol1 = (rend_t )18;
      }
#line 2178
      if (Xdepth <= 2) {
#line 2179
        ccol2 = (rend_t )1;
      } else
#line 2178
      if (! rs_color[19]) {
#line 2179
        ccol2 = (rend_t )1;
      } else {
#line 2181
        ccol2 = (rend_t )19;
      }
#line 2183
      *srp = (rend_t )(((unsigned int )*srp & 4294966303U) | (unsigned int )((int )ccol1 << 5));
#line 2184
      *srp = (rend_t )(((unsigned int )*srp & 4294967264U) | (unsigned int )ccol2);
    }
  }
#line 2210
  i = 0;
#line 2211
  if ((int )oldcursor.row != -1) {
#line 2213
    if ((int )screen.cur.row != (int )oldcursor.row) {
#line 2213
      goto _L;
    } else
#line 2213
    if ((int )screen.cur.col != (int )oldcursor.col) {
      _L: /* CIL Label */ 
#line 2215
      if ((int )oldcursor.row < (int )TermWin.nrow) {
#line 2215
        if ((int )oldcursor.col < (int )TermWin.bcol) {
#line 2216
          *(*(drawn_text + oldcursor.row) + oldcursor.col) = (text_t )0;
        }
      }
#line 2225
      if (focus) {
#line 2226
        oldcursor.row = (R_int16_t )-1;
      } else
#line 2225
      if (! (screen.flags & (unsigned int )(1 << 1))) {
#line 2226
        oldcursor.row = (R_int16_t )-1;
      } else {
#line 2228
        i = 1;
      }
    }
  } else
#line 2230
  if (! focus) {
#line 2231
    i = 1;
  }
#line 2232
  if (i) {
#line 2233
    oldcursor.row = screen.cur.row;
#line 2234
    oldcursor.col = screen.cur.col;
  }
#line 2243
  row = 0;
  {
#line 2243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2243
    if (! (row < (int )TermWin.nrow)) {
#line 2243
      goto while_break___1;
    }
#line 2267
    scrrow = row + row_offset;
#line 2268
    stp = *(screen.text + scrrow);
#line 2269
    srp = *(screen.rend + scrrow);
#line 2270
    dtp = *(drawn_text + row);
#line 2271
    drp = *(drawn_rend + row);
#line 2272
    col = 0;
    {
#line 2272
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2272
      if (! (col < (int )TermWin.ncol)) {
#line 2272
        goto while_break___2;
      }
#line 2274
      rt1 = *(srp + col);
#line 2275
      rt2 = *(drp + col);
#line 2279
      if ((int )*(stp + col) == (int )*(dtp + col)) {
#line 2279
        if ((int )rt1 == (int )rt2) {
#line 2294
          goto __Cont___0;
        } else
#line 2279
        if ((int )*(stp + col) == 32) {
#line 2279
          if (((unsigned int )rt1 & 65504U) == ((unsigned int )rt2 & 65504U)) {
#line 2294
            goto __Cont___0;
          }
        }
      }
#line 2301
      *(dtp + col) = *(stp + col);
#line 2303
      tmp___2 = *(srp + col);
#line 2303
      *(drp + col) = tmp___2;
#line 2303
      rend = (int )tmp___2;
#line 2305
      len = 0;
#line 2306
      tmp___3 = len;
#line 2306
      len ++;
#line 2306
      *(buffer + tmp___3) = (char )*(stp + col);
#line 2307
      ypixel = (TermWin.font)->ascent + (row * (int )TermWin.fheight + TermWin_internalBorder);
#line 2311
      xpixel = col * (int )TermWin.fwidth + TermWin_internalBorder;
#line 2313
      wlen = 1;
#line 2318
      if (fprop == 0) {
        {
#line 2369
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2369
          col ++;
#line 2369
          if (! (col < (int )TermWin.ncol - 1)) {
#line 2369
            goto while_break___3;
          }
#line 2370
          if (rend != (int )*(srp + col)) {
#line 2371
            goto while_break___3;
          }
#line 2372
          if ((int )*(stp + col) == (int )*(dtp + col)) {
#line 2372
            if ((int )*(srp + col) == (int )*(drp + col)) {
#line 2373
              goto while_break___3;
            }
          }
#line 2374
          if (len == currmaxcol) {
#line 2375
            goto while_break___3;
          }
#line 2376
          *(dtp + col) = *(stp + col);
#line 2377
          *(drp + col) = *(srp + col);
#line 2378
          tmp___4 = len;
#line 2378
          len ++;
#line 2378
          *(buffer + tmp___4) = (char )*(stp + col);
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2380
        col --;
#line 2381
        wlen = len;
      }
#line 2386
      *(buffer + len) = (char )'\000';
#line 2391
      fore = (int )((unsigned int )rend & 31U);
#line 2392
      back = (int )(((unsigned int )rend & 992U) >> 5);
#line 2393
      rend = (int )((unsigned int )rend & 64512U);
#line 2394
      gcmask = 0L;
#line 2395
      if ((unsigned int )rend & 4096U) {
#line 2395
        rvid = 1;
      } else {
#line 2395
        rvid = 0;
      }
      {
#line 2398
      if (((unsigned int )rend & 49152U) == 16384U) {
#line 2398
        goto case_16384;
      }
#line 2405
      if (((unsigned int )rend & 49152U) == 32768U) {
#line 2405
        goto case_32768;
      }
#line 2397
      goto switch_break;
      case_16384: /* CIL Label */ 
#line 2399
      i = 0;
      {
#line 2399
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2399
        if (! (i < len)) {
#line 2399
          goto while_break___4;
        }
#line 2400
        if ((int )*(buffer + i) == 95) {
#line 2401
          *(buffer + i) = (char)127;
        } else
#line 2402
        if ((int )*(buffer + i) > 95) {
#line 2402
          if ((int )*(buffer + i) < 127) {
#line 2403
            *(buffer + i) = (char )((int )*(buffer + i) - 95);
          }
        }
#line 2399
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2404
      goto switch_break;
      case_32768: /* CIL Label */ 
#line 2406
      i = 0;
      {
#line 2406
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2406
        if (! (i < len)) {
#line 2406
          goto while_break___5;
        }
#line 2407
        if ((int )*(buffer + i) == 35) {
#line 2408
          *(buffer + i) = (char)30;
        }
#line 2406
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2409
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2411
      if (rvid) {
        {
#line 2412
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2412
          i = fore;
#line 2412
          fore = back;
#line 2412
          back = i;
#line 2412
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 2414
      if (colors_changed) {
#line 2416
        gcvalue.background = *(PixColors + back);
#line 2417
        gcmask |= 1L << 3;
#line 2418
        gcvalue.foreground = *(PixColors + fore);
#line 2419
        gcmask |= 1L << 2;
#line 2420
        colors_changed = 0;
      } else
#line 2421
      if (back != 1) {
#line 2422
        gcvalue.background = *(PixColors + back);
#line 2423
        gcmask |= 1L << 3;
      }
#line 2425
      if (fore != 0) {
#line 2426
        gcvalue.foreground = *(PixColors + fore);
#line 2427
        gcmask |= 1L << 2;
      } else
#line 2430
      if ((unsigned int )rend & 1024U) {
#line 2431
        if (Xdepth > 2) {
#line 2431
          if (rs_color[23]) {
#line 2431
            if (*(PixColors + fore) != *(PixColors + 23)) {
#line 2431
              if (*(PixColors + back) != *(PixColors + 23)) {
#line 2434
                gcvalue.foreground = *(PixColors + 23);
#line 2435
                gcmask |= 1L << 2;
              }
            }
          }
        }
      } else
#line 2440
      if ((unsigned int )rend & 8192U) {
#line 2441
        if (Xdepth > 2) {
#line 2441
          if (rs_color[24]) {
#line 2441
            if (*(PixColors + fore) != *(PixColors + 24)) {
#line 2441
              if (*(PixColors + back) != *(PixColors + 24)) {
#line 2444
                gcvalue.foreground = *(PixColors + 24);
#line 2445
                gcmask |= 1L << 2;
#line 2446
                rend = (int )((unsigned int )rend & 4294959103U);
              }
            }
          }
        }
      }
#line 2451
      if (gcmask) {
        {
#line 2452
        XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
        }
      }
#line 2455
      if (! wbyte) {
#line 2455
        if ((unsigned int )rend & 3072U) {
#line 2455
          if ((unsigned long )TermWin.boldFont != (unsigned long )((void *)0)) {
            {
#line 2456
            bfont = 1;
#line 2457
            XSetFont(Xdisplay, TermWin.gc, (TermWin.boldFont)->fid);
#line 2458
            rend = (int )((unsigned int )rend & 4294966271U);
            }
          } else {
#line 2455
            goto _L___1;
          }
        } else {
#line 2455
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2459
      if (bfont) {
        {
#line 2460
        bfont = 0;
#line 2461
        XSetFont(Xdisplay, TermWin.gc, (TermWin.font)->fid);
        }
      }
#line 2467
      if (fprop) {
#line 2471
        if (rvid) {
          {
#line 2473
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2473
            ltmp = gcvalue.foreground;
#line 2473
            gcvalue.foreground = gcvalue.background;
#line 2473
            gcvalue.background = ltmp;
#line 2473
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 2474
          gcmask |= (1L << 2) | (1L << 3);
#line 2475
          XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
#line 2476
          XFillRectangle(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel - (TermWin.font)->ascent,
                         (unsigned int )((int )TermWin.fwidth), (unsigned int )((int )TermWin.fheight));
          }
          {
#line 2479
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2479
            ltmp = gcvalue.foreground;
#line 2479
            gcvalue.foreground = gcvalue.background;
#line 2479
            gcvalue.background = ltmp;
#line 2479
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 2480
          XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
          }
        } else {
          {
#line 2485
          CLEAR_CHARS((unsigned int )xpixel, (unsigned int )(ypixel - (TermWin.font)->ascent),
                      1U);
          }
        }
        {
#line 2486
        (*draw_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, buffer, 1);
        }
#line 2494
        if ((unsigned int )rend & 3072U) {
          {
#line 2495
          (*draw_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel + 1, ypixel, buffer,
                         1);
          }
        }
      } else
#line 2499
      if (Options & (1UL << 13)) {
#line 2499
        if (back == 1) {
          {
#line 2503
          CLEAR_CHARS((unsigned int )xpixel, (unsigned int )(ypixel - (TermWin.font)->ascent),
                      (unsigned int )len);
#line 2504
          (*draw_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, buffer,
                         wlen);
          }
        } else {
          {
#line 2513
          (*draw_image_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, buffer,
                               wlen);
          }
        }
      } else {
        {
#line 2513
        (*draw_image_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel, buffer,
                             wlen);
        }
      }
#line 2519
      if ((unsigned int )rend & 3072U) {
        {
#line 2520
        (*draw_string)(Xdisplay, TermWin.vt, TermWin.gc, xpixel + 1, ypixel, buffer,
                       wlen);
        }
      }
#line 2522
      if ((unsigned int )rend & 8192U) {
#line 2522
        if ((TermWin.font)->descent > 1) {
          {
#line 2523
          XDrawLine(Xdisplay, TermWin.vt, TermWin.gc, xpixel, ypixel + 1, (xpixel + len * (int )TermWin.fwidth) - 1,
                    ypixel + 1);
          }
        }
      }
#line 2526
      if (gcmask) {
        {
#line 2527
        gcvalue.foreground = *(PixColors + 0);
#line 2528
        gcvalue.background = *(PixColors + 1);
#line 2529
        XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2272
      col ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2243
    row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2556
  if (screen.flags & (unsigned int )(1 << 1)) {
#line 2558
    if (focus) {
#line 2560
      srp = *(screen.rend + currow) + screen.cur.col;
#line 2566
      *srp = (rend_t )(((unsigned int )*srp & 4294966272U) | (unsigned int )cc1);
#line 2568
      if (morecur) {
#line 2569
        srp += morecur;
      }
    } else {
#line 2575
      currow = (int )screen.cur.row - (int )TermWin.view_start;
#line 2576
      col = (int )screen.cur.col + morecur;
#line 2577
      if (morecur) {
#line 2577
        wbyte = 1;
      } else {
#line 2577
        wbyte = 0;
      }
#line 2578
      if (currow >= 0) {
#line 2578
        if (currow < (int )TermWin.nrow) {
#line 2580
          gcmask = 0L;
#line 2581
          if (Xdepth > 2) {
#line 2581
            if (rs_color[18]) {
              {
#line 2582
              gcvalue.foreground = *(PixColors + 18);
#line 2583
              gcmask = 1L << 2;
#line 2584
              XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
#line 2585
              gcvalue.foreground = *(PixColors + 0);
              }
            }
          }
          {
#line 2596
          XDrawRectangle(Xdisplay, TermWin.vt, TermWin.gc, col * (int )TermWin.fwidth + TermWin_internalBorder,
                         currow * (int )TermWin.fheight + TermWin_internalBorder,
                         (unsigned int )((1 + wbyte) * (int )TermWin.fwidth - 1),
                         (unsigned int )((int )TermWin.fheight - 1));
          }
#line 2602
          if (gcmask) {
            {
#line 2603
            XChangeGC(Xdisplay, TermWin.gc, (unsigned long )gcmask, & gcvalue);
            }
          }
        }
      }
    }
  }
  {
#line 2613
  scr_reverse_selection();
  }
#line 2618
  if (boldlast) {
#line 2618
    if (TermWin.bMapped) {
      {
#line 2619
      XClearArea(Xdisplay, TermWin.vt, ((int )TermWin.width + 2 * TermWin_internalBorder) - 2,
                 0, 1U, (unsigned int )(((int )TermWin.height + 2 * TermWin_internalBorder) - 1),
                 0);
      }
    }
  }
#line 2621
  if (type & (1 << 3)) {
    {
#line 2622
    XSync(Xdisplay, 0);
    }
  }
#line 2623
  return;
}
}
#line 2626 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_clear_tint(int bWithTinting ) 
{ 


  {
#line 2629
  if (! TermWin.bMapped) {
#line 2629
    return;
  }
#line 2631
  if (Options & (1UL << 13)) {
    {
#line 2637
    XClearWindow(Xdisplay, TermWin.parent);
    }
  }
  {
#line 2643
  XClearWindow(Xdisplay, TermWin.vt);
  }
#line 2646
  if (TermWin.tintGC) {
#line 2646
    if (bWithTinting) {
      {
#line 2648
      XFillRectangle(Xdisplay, TermWin.vt, TermWin.tintGC, 0, 0, (unsigned int )((int )TermWin.width + TermWin_internalBorders),
                     (unsigned int )((int )TermWin.height + TermWin_internalBorders));
      }
    }
  }
#line 2652
  return;
}
}
#line 2657 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void on_colors_changed(int idx ) 
{ 
  XColor tint ;

  {
#line 2660
  colors_changed = 1;
#line 2661
  if (idx == 1) {
#line 2661
    if (! (Options & (1UL << 13))) {
      {
#line 2667
      XSetWindowBackground(Xdisplay, TermWin.vt, *(PixColors + 1));
      }
    } else {
#line 2661
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2668
  if (idx == 22) {
    {
#line 2671
    tint.pixel = *(PixColors + 22);
#line 2672
    XQueryColor(Xdisplay, Xcmap, & tint);
    }
#line 2673
    if ((int )TermWin.background.Shading.tintColor.red == (int )tint.red) {
#line 2673
      if ((int )TermWin.background.Shading.tintColor.green == (int )tint.green) {
#line 2673
        if ((int )TermWin.background.Shading.tintColor.blue == (int )tint.blue) {
#line 2676
          return;
        }
      }
    }
    {
#line 2678
    TermWin.background.Shading.tintColor = tint;
#line 2679
    RenderPixmap(0);
    }
  }
  {
#line 2685
  set_colorfgbg();
#line 2686
  set_cursor_color();
#line 2688
  scr_clear_tint(1);
#line 2689
  scr_touch();
  }
#line 2690
  return;
}
}
#line 2699 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void scr_reverse_selection(void) 
{ 
  int i ;
  int col ;
  int row ;
  int end_row ;
  rend_t *srp ;

  {
#line 2705
  end_row = (int )TermWin.saveLines - (int )TermWin.view_start;
#line 2706
  if (selection.op) {
#line 2706
    if ((int )current_screen == (int )selection.screen) {
#line 2707
      i = (int )selection.beg.row + (int )TermWin.saveLines;
#line 2708
      row = (int )selection.end.row + (int )TermWin.saveLines;
#line 2709
      if (i >= end_row) {
#line 2710
        col = (int )selection.beg.col;
      } else {
#line 2712
        col = 0;
#line 2713
        i = end_row;
      }
#line 2715
      end_row += (int )TermWin.nrow;
      {
#line 2716
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2716
        if (i < row) {
#line 2716
          if (! (i < end_row)) {
#line 2716
            goto while_break;
          }
        } else {
#line 2716
          goto while_break;
        }
#line 2717
        srp = *(screen.rend + i);
        {
#line 2717
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2717
          if (! (col < (int )TermWin.bcol)) {
#line 2717
            goto while_break___0;
          }
#line 2718
          *(srp + col) = (rend_t )((unsigned int )*(srp + col) ^ 4096U);
#line 2717
          col ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2716
        i ++;
#line 2716
        col = 0;
      }
      while_break: /* CIL Label */ ;
      }
#line 2719
      if (i == row) {
#line 2719
        if (i < end_row) {
#line 2720
          srp = *(screen.rend + i);
          {
#line 2720
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2720
            if (! (col < (int )selection.end.col)) {
#line 2720
              goto while_break___1;
            }
#line 2721
            *(srp + col) = (rend_t )((unsigned int )*(srp + col) ^ 4096U);
#line 2720
            col ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 2723
  return;
}
}
#line 2733 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_check(int check_more ) 
{ 
  row_col_t pos ;

  {
#line 2738
  if ((int )selection.beg.row < - ((int )TermWin.nscrolled)) {
#line 2738
    goto _L;
  } else
#line 2738
  if ((int )selection.beg.row >= (int )TermWin.nrow) {
#line 2738
    goto _L;
  } else
#line 2738
  if ((int )selection.mark.row < - ((int )TermWin.nscrolled)) {
#line 2738
    goto _L;
  } else
#line 2738
  if ((int )selection.mark.row >= (int )TermWin.nrow) {
#line 2738
    goto _L;
  } else
#line 2738
  if ((int )selection.end.row < - ((int )TermWin.nscrolled)) {
#line 2738
    goto _L;
  } else
#line 2738
  if ((int )selection.end.row >= (int )TermWin.nrow) {
    _L: /* CIL Label */ 
#line 2744
    selection.end.col = (R_int16_t )0;
#line 2744
    selection.end.row = selection.end.col;
#line 2744
    selection.mark.col = selection.end.row;
#line 2744
    selection.mark.row = selection.mark.col;
#line 2744
    selection.beg.col = selection.mark.row;
#line 2744
    selection.beg.row = selection.beg.col;
  }
#line 2746
  if (check_more == 1) {
#line 2746
    if ((int )current_screen == (int )selection.screen) {
#line 2748
      pos.row = screen.cur.row;
#line 2749
      pos.col = screen.cur.col;
#line 2750
      if (! ((int )pos.row < (int )selection.beg.row)) {
#line 2750
        if ((int )pos.row == (int )selection.beg.row) {
#line 2750
          if (! ((int )pos.col < (int )selection.beg.col)) {
#line 2750
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2750
        if ((int )pos.row < (int )selection.end.row) {
#line 2752
          selection.end.col = (R_int16_t )0;
#line 2752
          selection.end.row = selection.end.col;
#line 2752
          selection.beg.col = selection.end.row;
#line 2752
          selection.beg.row = selection.beg.col;
        } else
#line 2750
        if ((int )pos.row == (int )selection.end.row) {
#line 2750
          if ((int )pos.col < (int )selection.end.col) {
#line 2752
            selection.end.col = (R_int16_t )0;
#line 2752
            selection.end.row = selection.end.col;
#line 2752
            selection.beg.col = selection.end.row;
#line 2752
            selection.beg.row = selection.beg.col;
          }
        }
      }
    } else {
#line 2746
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2753
  if (check_more == 2) {
#line 2754
    pos.row = (R_int16_t )0;
#line 2755
    pos.col = (R_int16_t )0;
#line 2756
    if ((int )selection.beg.row < (int )pos.row) {
#line 2756
      goto _L___1;
    } else
#line 2756
    if ((int )selection.beg.row == (int )pos.row) {
#line 2756
      if ((int )selection.beg.col < (int )pos.col) {
        _L___1: /* CIL Label */ 
#line 2756
        if ((int )selection.end.row > (int )pos.row) {
#line 2758
          selection.end.col = (R_int16_t )0;
#line 2758
          selection.end.row = selection.end.col;
#line 2758
          selection.beg.col = selection.end.row;
#line 2758
          selection.beg.row = selection.beg.col;
        } else
#line 2756
        if ((int )selection.end.row == (int )pos.row) {
#line 2756
          if ((int )selection.end.col > (int )pos.col) {
#line 2758
            selection.end.col = (R_int16_t )0;
#line 2758
            selection.end.row = selection.end.col;
#line 2758
            selection.beg.col = selection.end.row;
#line 2758
            selection.beg.row = selection.beg.col;
          }
        }
      }
    }
  } else
#line 2759
  if (check_more == 3) {
#line 2760
    pos.row = (R_int16_t )0;
#line 2761
    pos.col = (R_int16_t )0;
#line 2762
    if ((int )selection.end.row > (int )pos.row) {
#line 2763
      selection.end.col = (R_int16_t )0;
#line 2763
      selection.end.row = selection.end.col;
#line 2763
      selection.beg.col = selection.end.row;
#line 2763
      selection.beg.row = selection.beg.col;
    } else
#line 2762
    if ((int )selection.end.row == (int )pos.row) {
#line 2762
      if ((int )selection.end.col > (int )pos.col) {
#line 2763
        selection.end.col = (R_int16_t )0;
#line 2763
        selection.end.row = selection.end.col;
#line 2763
        selection.beg.col = selection.end.row;
#line 2763
        selection.beg.row = selection.beg.col;
      }
    }
  }
#line 2765
  return;
}
}
#line 2772 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void PasteIt(unsigned char *data , unsigned int nitems ) 
{ 
  int num ;
  unsigned char *p ;
  unsigned char cr ;
  unsigned int tmp ;

  {
#line 2778
  cr = (unsigned char )'\r';
#line 2779
  p = data;
#line 2779
  num = 0;
  {
#line 2779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2779
    tmp = nitems;
#line 2779
    nitems --;
#line 2779
    if (! tmp) {
#line 2779
      goto while_break;
    }
#line 2780
    if ((int )*p != 10) {
#line 2781
      num ++;
    } else {
      {
#line 2783
      tt_write((unsigned char const   *)data, num);
#line 2784
      tt_write((unsigned char const   *)(& cr), 1);
#line 2785
      data += num + 1;
#line 2786
      num = 0;
      }
    }
#line 2779
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2788
  if (num) {
    {
#line 2789
    tt_write((unsigned char const   *)data, num);
    }
  }
#line 2790
  return;
}
}
#line 2792 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
static void paste_text_property(XTextProperty *ct ) 
{ 
  int dummy_count ;
  char **cl ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 2797
  tmp___0 = XmbTextPropertyToTextList(Xdisplay, (XTextProperty const   *)ct, & cl,
                                      & dummy_count);
  }
#line 2797
  if (tmp___0 == 0) {
#line 2797
    if (cl) {
      {
#line 2799
      tmp = strlen((char const   *)*(cl + 0));
#line 2799
      PasteIt((unsigned char *)*(cl + 0), (unsigned int )tmp);
#line 2800
      XFreeStringList(cl);
      }
    } else {
      {
#line 2802
      PasteIt(ct->value, (unsigned int )ct->nitems);
      }
    }
  } else {
    {
#line 2802
    PasteIt(ct->value, (unsigned int )ct->nitems);
    }
  }
#line 2803
  return;
}
}
#line 2811 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_paste(Window win , unsigned int prop , int Delete ) 
{ 
  unsigned long bytes_after ;
  XTextProperty ct ;
  XEvent ev ;
  XWindowAttributes wa ;
  int success ;
  int tmp ;
  int tmp___0 ;

  {
#line 2819
  if ((long )prop == 0L) {
#line 2821
    if ((int )selection.type == 0) {
      {
#line 2823
      selection.type = (char )((int )selection.type + 1);
#line 2824
      XConvertSelection(Xdisplay, (Atom )1, aterm_XA_UTF8_STRING, aterm_XA_VT_SELECTION,
                        TermWin.vt, (Time )selection.request_time);
      }
    } else
#line 2825
    if ((int )selection.type == 1) {
      {
#line 2827
      selection.type = (char )((int )selection.type + 1);
#line 2828
      XConvertSelection(Xdisplay, (Atom )1, (Atom )31, aterm_XA_VT_SELECTION, TermWin.vt,
                        (Time )selection.request_time);
      }
    }
#line 2830
    return;
  }
  {
#line 2833
  ct.value = (unsigned char *)((void *)0);
#line 2834
  tmp___0 = XGetWindowProperty(Xdisplay, win, (Atom )prop, 0L, (long )(~ 0), 0, (Atom )0L,
                               & ct.encoding, & ct.format, & ct.nitems, & bytes_after,
                               & ct.value);
  }
#line 2834
  if (tmp___0 == 0) {
#line 2838
    if (ct.encoding == aterm_XA_INCR) {
      {
#line 2840
      success = 1;
#line 2842
      XGetWindowAttributes(Xdisplay, win, & wa);
      }
#line 2843
      if (! (wa.your_event_mask & (1L << 22))) {
        {
#line 2844
        XSelectInput(Xdisplay, win, wa.your_event_mask | (1L << 22));
        }
      }
      {
#line 2846
      XDeleteProperty(Xdisplay, win, (Atom )prop);
      }
      {
#line 2847
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2849
        XWindowEvent(Xdisplay, win, 1L << 22, & ev);
        }
#line 2850
        if (ev.xproperty.state != 0) {
#line 2851
          goto __Cont;
        }
        {
#line 2852
        tmp = XGetWindowProperty(Xdisplay, win, (Atom )prop, 0L, (long )(~ 0), 1,
                                 (Atom )0L, & ct.encoding, & ct.format, & ct.nitems,
                                 & bytes_after, & ct.value);
#line 2852
        success = tmp == 0;
        }
#line 2856
        if (success) {
#line 2856
          if (ct.nitems > 0UL) {
            {
#line 2858
            paste_text_property(& ct);
#line 2859
            XFree((void *)ct.value);
#line 2860
            ct.value = (unsigned char *)((void *)0);
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 2847
        if (success) {
#line 2847
          if (! (ct.nitems > 0UL)) {
#line 2847
            goto while_break;
          }
        } else {
#line 2847
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2864
      if (! (wa.your_event_mask & (1L << 22))) {
        {
#line 2865
        XSelectInput(Xdisplay, win, wa.your_event_mask);
        }
      }
    } else {
#line 2868
      if (Delete) {
        {
#line 2869
        XDeleteProperty(Xdisplay, win, (Atom )prop);
        }
      }
      {
#line 2871
      paste_text_property(& ct);
      }
    }
  }
#line 2874
  if (ct.value) {
    {
#line 2875
    XFree((void *)ct.value);
    }
  }
#line 2876
  return;
}
}
#line 2884 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_request(Time tm , int x , int y ) 
{ 
  Window tmp ;

  {
#line 2887
  selection.request_time = (int )tm;
#line 2888
  if ((unsigned long )selection.text != (unsigned long )((void *)0)) {
    {
#line 2890
    PasteIt(selection.text, (unsigned int )selection.len);
    }
  } else {
    {
#line 2891
    tmp = XGetSelectionOwner(Xdisplay, (Atom )1);
    }
#line 2891
    if (tmp == 0UL) {
      {
#line 2893
      selection_paste((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                      (unsigned int )((Atom )9), 0);
      }
    } else {
      {
#line 2896
      selection.type = (char)1;
#line 2899
      XConvertSelection(Xdisplay, (Atom )1, _XA_COMPAUND_TEXT, aterm_XA_VT_SELECTION,
                        TermWin.vt, tm);
      }
    }
  }
#line 2902
  return;
}
}
#line 2994 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_clear(void) 
{ 


  {
#line 2999
  if (selection.text) {
    {
#line 3000
    free((void *)selection.text);
    }
  }
#line 3001
  selection.text = (unsigned char *)((void *)0);
#line 3002
  selection.len = 0;
#line 3003
  selection.end.col = (R_int16_t )0;
#line 3003
  selection.end.row = selection.end.col;
#line 3003
  selection.beg.col = selection.end.row;
#line 3003
  selection.beg.row = selection.beg.col;
#line 3004
  return;
}
}
#line 3012 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_make(Time tm , unsigned int key_state ) 
{ 
  int i ;
  int col ;
  int end_col ;
  int row ;
  int end_row ;
  unsigned char *new_selection_text ;
  char *str ;
  text_t *t ;
  void *tmp ;
  char *tmp___0 ;
  text_t *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  text_t *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  Window tmp___7 ;

  {
  {
#line 3022
  if ((unsigned int )selection.op == 3U) {
#line 3022
    goto case_3;
  }
#line 3024
  if ((unsigned int )selection.op == 1U) {
#line 3024
    goto case_1;
  }
#line 3027
  if ((unsigned int )selection.op == 2U) {
#line 3027
    goto case_2;
  }
#line 3030
  goto switch_default;
  case_3: /* CIL Label */ 
#line 3023
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3025
  selection.end.col = (R_int16_t )0;
#line 3025
  selection.end.row = selection.end.col;
#line 3025
  selection.beg.col = selection.end.row;
#line 3025
  selection.beg.row = selection.beg.col;
  case_2: /* CIL Label */ 
#line 3028
  selection.op = (enum __anonenum_op_177 )4;
  switch_default: /* CIL Label */ 
#line 3031
  return;
  switch_break: /* CIL Label */ ;
  }
#line 3033
  selection.op = (enum __anonenum_op_177 )4;
#line 3035
  if ((int )selection.clicks == 4) {
#line 3036
    return;
  }
  {
#line 3038
  i = (((int )selection.end.row - (int )selection.beg.row) + 1) * ((int )TermWin.bcol + 1) + 1;
#line 3039
  tmp = malloc((unsigned long )i * sizeof(char ));
#line 3039
  str = (char *)tmp;
#line 3040
  new_selection_text = (unsigned char *)str;
  }
#line 3042
  if ((int )selection.beg.col > 0) {
#line 3042
    col = (int )selection.beg.col;
  } else {
#line 3042
    col = 0;
  }
#line 3043
  row = (int )selection.beg.row + (int )TermWin.saveLines;
#line 3044
  end_row = (int )selection.end.row + (int )TermWin.saveLines;
  {
#line 3048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3048
    if (! (row < end_row)) {
#line 3048
      goto while_break;
    }
#line 3049
    t = *(screen.text + row) + col;
#line 3050
    end_col = (int )*(screen.tlen + row);
#line 3050
    if (end_col == -1) {
#line 3051
      end_col = (int )TermWin.bcol;
    }
    {
#line 3052
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3052
      if (! (col < end_col)) {
#line 3052
        goto while_break___0;
      }
#line 3053
      tmp___0 = str;
#line 3053
      str ++;
#line 3053
      tmp___1 = t;
#line 3053
      t ++;
#line 3053
      *tmp___0 = (char )*tmp___1;
#line 3052
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3054
    col = 0;
#line 3055
    if ((int )*(screen.tlen + row) != -1) {
#line 3056
      tmp___2 = str;
#line 3056
      str ++;
#line 3056
      *tmp___2 = (char )'\n';
    }
#line 3048
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3061
  t = *(screen.text + row) + col;
#line 3062
  end_col = (int )*(screen.tlen + row);
#line 3063
  if (end_col == -1) {
#line 3064
    end_col = (int )selection.end.col;
  } else
#line 3063
  if ((int )selection.end.col <= end_col) {
#line 3064
    end_col = (int )selection.end.col;
  }
#line 3065
  if ((int )TermWin.bcol < end_col) {
#line 3065
    end_col = (int )TermWin.bcol;
  }
  {
#line 3066
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3066
    if (! (col < end_col)) {
#line 3066
      goto while_break___1;
    }
#line 3067
    tmp___3 = str;
#line 3067
    str ++;
#line 3067
    tmp___4 = t;
#line 3067
    t ++;
#line 3067
    *tmp___3 = (char )*tmp___4;
#line 3066
    col ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3068
  if (end_col != (int )selection.end.col) {
#line 3069
    tmp___5 = str;
#line 3069
    str ++;
#line 3069
    *tmp___5 = (char )'\n';
  }
  {
#line 3070
  *str = (char )'\000';
#line 3071
  tmp___6 = strlen((char const   *)((char *)new_selection_text));
#line 3071
  i = (int )tmp___6;
  }
#line 3071
  if (i == 0) {
    {
#line 3072
    free((void *)new_selection_text);
    }
#line 3073
    return;
  }
#line 3075
  selection.len = i;
#line 3076
  if (selection.text) {
    {
#line 3077
    free((void *)selection.text);
    }
  }
#line 3078
  selection.text = new_selection_text;
#line 3081
  if (key_state & (unsigned int )(1 << 3)) {
    {
#line 3082
    XSetSelectionOwner(Xdisplay, aterm_XA_CLIPBOARD, TermWin.vt, tm);
    }
  } else {
    {
#line 3084
    XSetSelectionOwner(Xdisplay, (Atom )1, TermWin.vt, tm);
    }
  }
  {
#line 3087
  tmp___7 = XGetSelectionOwner(Xdisplay, (Atom )1);
  }
#line 3087
  if (tmp___7 != TermWin.vt) {
    {
#line 3088
    print_error("can\'t get primary selection");
    }
  }
  {
#line 3089
  XChangeProperty(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                  (Atom )9, (Atom )31, 8, 0, (unsigned char const   *)selection.text,
                  selection.len);
  }
#line 3092
  return;
}
}
#line 3100 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_click(int clicks , int x , int y ) 
{ 


  {
  {
#line 3109
  clicks = (clicks - 1) % 3 + 1;
#line 3110
  selection.clicks = (short )clicks;
#line 3114
  selection_start_colrow((x - TermWin_internalBorder) / (int )TermWin.fwidth, (y - TermWin_internalBorder) / (int )TermWin.fheight);
  }
#line 3116
  if (clicks == 2) {
    {
#line 3117
    selection_extend_colrow((int )selection.mark.col, (int )selection.mark.row + (int )TermWin.view_start,
                            0, 1, 0);
    }
  } else
#line 3116
  if (clicks == 3) {
    {
#line 3117
    selection_extend_colrow((int )selection.mark.col, (int )selection.mark.row + (int )TermWin.view_start,
                            0, 1, 0);
    }
  }
#line 3122
  return;
}
}
#line 3129 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_start_colrow(int col , int row ) 
{ 


  {
#line 3132
  selection.mark.col = (R_int16_t )col;
#line 3133
  selection.mark.row = (R_int16_t )(row - (int )TermWin.view_start);
#line 3134
  if (- ((int )TermWin.nscrolled) > (int )selection.mark.row) {
#line 3134
    selection.mark.row = (R_int16_t )(- ((int )TermWin.nscrolled));
  }
#line 3135
  if ((int )TermWin.nrow - 1 < (int )selection.mark.row) {
#line 3135
    selection.mark.row = (R_int16_t )((int )TermWin.nrow - 1);
  }
#line 3136
  if (0 > (int )selection.mark.col) {
#line 3136
    selection.mark.col = (R_int16_t )0;
  }
#line 3137
  if ((int )TermWin.bcol - 1 < (int )selection.mark.col) {
#line 3137
    selection.mark.col = (R_int16_t )((int )TermWin.bcol - 1);
  }
#line 3139
  if (selection.op) {
#line 3140
    selection.end.row = selection.mark.row;
#line 3140
    selection.beg.row = selection.end.row;
#line 3141
    selection.end.col = selection.mark.col;
#line 3141
    selection.beg.col = selection.end.col;
  }
#line 3143
  selection.op = (enum __anonenum_op_177 )1;
#line 3144
  selection.screen = current_screen;
#line 3145
  return;
}
}
#line 3163 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_delimit_word(int dirn , row_col_t *mark , row_col_t *ret ) 
{ 
  int col ;
  int row ;
  int dirnadd ;
  int tcol ;
  int trow ;
  int w1 ;
  int w2 ;
  row_col_t bound ;
  text_t *stp ;
  rend_t *srp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 3171
  if ((int )selection.clicks < 2) {
#line 3172
    return;
  }
#line 3174
  if (dirn == 0) {
#line 3175
    bound.row = (R_int16_t )(((int )TermWin.saveLines - (int )TermWin.nscrolled) - 1);
#line 3176
    bound.col = (R_int16_t )0;
#line 3177
    dirnadd = -1;
  } else {
#line 3179
    bound.row = (R_int16_t )((int )TermWin.saveLines + (int )TermWin.nrow);
#line 3180
    bound.col = (R_int16_t )((int )TermWin.bcol - 1);
#line 3181
    dirnadd = 1;
  }
#line 3183
  row = (int )mark->row + (int )TermWin.saveLines;
#line 3184
  col = (int )mark->col;
#line 3185
  if (0 > col) {
#line 3185
    col = 0;
  }
#line 3187
  stp = *(screen.text + row) + col;
#line 3188
  if ((int )*stp == 32) {
#line 3188
    w1 = 2;
  } else
#line 3188
  if ((int )*stp == 9) {
#line 3188
    w1 = 2;
  } else {
    {
#line 3188
    tmp = strchr(rs_cutchars, (int )*stp);
#line 3188
    w1 = (unsigned long )tmp != (unsigned long )((void *)0);
    }
  }
#line 3199
  srp = *(screen.rend + row) + col;
#line 3200
  w2 = 1;
  {
#line 3202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3203
      if (! (col != (int )bound.col)) {
#line 3203
        goto while_break___0;
      }
#line 3204
      stp += dirnadd;
#line 3205
      if ((int )*stp == 32) {
#line 3205
        tmp___1 = 2;
      } else
#line 3205
      if ((int )*stp == 9) {
#line 3205
        tmp___1 = 2;
      } else {
        {
#line 3205
        tmp___0 = strchr(rs_cutchars, (int )*stp);
#line 3205
        tmp___1 = (unsigned long )tmp___0 != (unsigned long )((void *)0);
        }
      }
#line 3205
      if (tmp___1 != w1) {
#line 3206
        goto while_break___0;
      }
#line 3207
      srp += dirnadd;
#line 3208
      if (1 != w2) {
#line 3209
        goto while_break___0;
      }
#line 3203
      col += dirnadd;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3211
    if (col == (int )bound.col) {
#line 3211
      if (row != (int )bound.row) {
#line 3212
        if ((int )*(screen.tlen + (row - (dirn == 0))) == -1) {
#line 3213
          trow = row + dirnadd;
#line 3214
          if (dirn == 0) {
#line 3214
            tcol = (int )TermWin.bcol - 1;
          } else {
#line 3214
            tcol = 0;
          }
#line 3215
          if ((unsigned long )*(screen.text + trow) == (unsigned long )((void *)0)) {
#line 3216
            goto while_break;
          }
#line 3217
          stp = *(screen.text + trow) + tcol;
#line 3218
          srp = *(screen.rend + trow) + tcol;
#line 3219
          if ((int )*stp == 32) {
#line 3219
            tmp___3 = 2;
          } else
#line 3219
          if ((int )*stp == 9) {
#line 3219
            tmp___3 = 2;
          } else {
            {
#line 3219
            tmp___2 = strchr(rs_cutchars, (int )*stp);
#line 3219
            tmp___3 = (unsigned long )tmp___2 != (unsigned long )((void *)0);
            }
          }
#line 3219
          if (tmp___3 != w1) {
#line 3220
            goto while_break;
          } else
#line 3219
          if (1 != w2) {
#line 3220
            goto while_break;
          }
#line 3221
          row = trow;
#line 3222
          col = tcol;
#line 3223
          goto __Cont;
        }
      }
    }
#line 3226
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3233
  if (dirn == 1) {
#line 3234
    col ++;
  }
#line 3237
  ret->row = (R_int16_t )(row - (int )TermWin.saveLines);
#line 3238
  ret->col = (R_int16_t )col;
#line 3239
  return;
}
}
#line 3250 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_extend(int x , int y , int flag ) 
{ 
  int col ;
  int row ;
  int tmp ;

  {
#line 3258
  col = (x - TermWin_internalBorder) / (int )TermWin.fwidth;
#line 3260
  row = (y - TermWin_internalBorder) / (int )TermWin.fheight;
#line 3261
  if (0 > row) {
#line 3261
    row = 0;
  }
#line 3262
  if ((int )TermWin.nrow - 1 < row) {
#line 3262
    row = (int )TermWin.nrow - 1;
  }
#line 3263
  if (0 > col) {
#line 3263
    col = 0;
  }
#line 3264
  if ((int )TermWin.bcol < col) {
#line 3264
    col = (int )TermWin.bcol;
  }
#line 3272
  if ((int )selection.clicks % 3 == 1) {
#line 3272
    if (! flag) {
#line 3272
      if (col == (int )selection.mark.col) {
#line 3272
        if (row == (int )selection.mark.row + (int )TermWin.view_start) {
#line 3276
          selection.end.row = (R_int16_t )0;
#line 3276
          selection.beg.row = selection.end.row;
#line 3277
          selection.end.col = (R_int16_t )0;
#line 3277
          selection.beg.col = selection.end.col;
#line 3278
          selection.clicks = (short)4;
#line 3280
          return;
        }
      }
    }
  }
#line 3283
  if ((int )selection.clicks == 4) {
#line 3284
    selection.clicks = (short)1;
  }
#line 3285
  if (flag == 1) {
#line 3285
    tmp = 1;
  } else {
#line 3285
    tmp = 0;
  }
  {
#line 3285
  selection_extend_colrow(col, row, ! (! flag), tmp, 0);
  }
#line 3289
  return;
}
}
#line 3296 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_extend_colrow(int col , int row , int button3 , int buttonpress , int clickchange ) 
{ 
  int end_col ;
  row_col_t pos ;
  enum __anonenum_closeto_179 closeto ;

  {
#line 3301
  closeto = (enum __anonenum_closeto_179 )1;
  {
#line 3312
  if ((unsigned int )selection.op == 1U) {
#line 3312
    goto case_1;
  }
#line 3316
  if ((unsigned int )selection.op == 2U) {
#line 3316
    goto case_2;
  }
#line 3321
  if ((unsigned int )selection.op == 4U) {
#line 3321
    goto case_4;
  }
#line 3324
  if ((unsigned int )selection.op == 3U) {
#line 3324
    goto case_3;
  }
#line 3326
  if ((unsigned int )selection.op == 0U) {
#line 3326
    goto case_0;
  }
#line 3329
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3313
  selection.end.col = (R_int16_t )0;
#line 3313
  selection.end.row = selection.end.col;
#line 3313
  selection.beg.col = selection.end.row;
#line 3313
  selection.beg.row = selection.beg.col;
#line 3314
  selection.op = (enum __anonenum_op_177 )2;
  case_2: /* CIL Label */ 
#line 3317
  if (row != (int )selection.mark.row) {
#line 3319
    selection.op = (enum __anonenum_op_177 )3;
  } else
#line 3317
  if (col != (int )selection.mark.col) {
#line 3319
    selection.op = (enum __anonenum_op_177 )3;
  } else
#line 3317
  if (! button3) {
#line 3317
    if (buttonpress) {
#line 3319
      selection.op = (enum __anonenum_op_177 )3;
    }
  }
#line 3320
  goto switch_break;
  case_4: /* CIL Label */ 
#line 3322
  selection.op = (enum __anonenum_op_177 )3;
  case_3: /* CIL Label */ 
#line 3325
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 3327
  selection_start_colrow(col, row);
  }
  switch_default: /* CIL Label */ 
#line 3330
  return;
  switch_break: /* CIL Label */ ;
  }
#line 3333
  pos.col = (R_int16_t )col;
#line 3334
  pos.row = (R_int16_t )row;
#line 3336
  pos.row = (R_int16_t )((int )pos.row - (int )TermWin.view_start);
#line 3390
  if (button3) {
#line 3390
    if (buttonpress) {
#line 3394
      if ((int )pos.row < (int )selection.beg.row) {
#line 3400
        closeto = (enum __anonenum_closeto_179 )0;
      } else
#line 3394
      if ((int )pos.row == (int )selection.beg.row) {
#line 3394
        if ((int )pos.col < (int )selection.beg.col) {
#line 3400
          closeto = (enum __anonenum_closeto_179 )0;
        } else {
#line 3394
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3394
      if (! ((int )pos.row > (int )selection.end.row)) {
#line 3394
        if ((int )pos.row == (int )selection.end.row) {
#line 3394
          if (! ((int )pos.col > (int )selection.end.col)) {
#line 3394
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3394
        if (((int )pos.col - (int )selection.beg.col) + ((int )pos.row - (int )selection.beg.row) * (int )TermWin.bcol < ((int )selection.end.col - (int )pos.col) + ((int )selection.end.row - (int )pos.row) * (int )TermWin.bcol) {
#line 3400
          closeto = (enum __anonenum_closeto_179 )0;
        }
      }
#line 3401
      if ((unsigned int )closeto == 0U) {
#line 3402
        selection.beg.row = pos.row;
#line 3403
        selection.beg.col = pos.col;
#line 3404
        selection.mark.row = selection.end.row;
#line 3405
        selection.mark.col = (R_int16_t )((int )selection.end.col - ((int )selection.clicks == 2));
      } else {
#line 3407
        selection.end.row = pos.row;
#line 3408
        selection.end.col = pos.col;
#line 3409
        selection.mark.row = selection.beg.row;
#line 3410
        selection.mark.col = selection.beg.col;
      }
    } else {
#line 3390
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3413
  if ((int )selection.mark.row > (int )pos.row) {
#line 3413
    goto _L___1;
  } else
#line 3413
  if ((int )selection.mark.row == (int )pos.row) {
#line 3413
    if ((int )selection.mark.col > (int )pos.col) {
      _L___1: /* CIL Label */ 
#line 3414
      if ((int )selection.mark.row == (int )selection.end.row) {
#line 3414
        if ((int )selection.mark.col == (int )selection.end.col) {
#line 3414
          if (clickchange) {
#line 3414
            if ((int )selection.clicks == 2) {
#line 3417
              selection.mark.col = (R_int16_t )((int )selection.mark.col - 1);
            }
          }
        }
      }
#line 3418
      selection.beg.row = pos.row;
#line 3419
      selection.beg.col = pos.col;
#line 3420
      selection.end.row = selection.mark.row;
#line 3421
      selection.end.col = (R_int16_t )((int )selection.mark.col + ((int )selection.clicks == 2));
    } else {
#line 3423
      selection.beg.row = selection.mark.row;
#line 3424
      selection.beg.col = selection.mark.col;
#line 3425
      selection.end.row = pos.row;
#line 3426
      selection.end.col = pos.col;
    }
  } else {
#line 3423
    selection.beg.row = selection.mark.row;
#line 3424
    selection.beg.col = selection.mark.col;
#line 3425
    selection.end.row = pos.row;
#line 3426
    selection.end.col = pos.col;
  }
#line 3430
  if ((int )selection.clicks == 1) {
#line 3431
    end_col = (int )*(screen.tlen + ((int )selection.beg.row + (int )TermWin.saveLines));
#line 3432
    if (end_col != -1) {
#line 3432
      if ((int )selection.beg.col > end_col) {
#line 3434
        selection.beg.col = (R_int16_t )TermWin.bcol;
      }
    }
#line 3442
    end_col = (int )*(screen.tlen + ((int )selection.end.row + (int )TermWin.saveLines));
#line 3443
    if (end_col != -1) {
#line 3443
      if ((int )selection.end.col > end_col) {
#line 3444
        selection.end.col = (R_int16_t )TermWin.bcol;
      }
    }
  } else
#line 3462
  if ((int )selection.clicks == 2) {
#line 3463
    if ((int )selection.end.row > (int )selection.beg.row) {
#line 3464
      selection.end.col = (R_int16_t )((int )selection.end.col - 1);
    } else
#line 3463
    if ((int )selection.end.row == (int )selection.beg.row) {
#line 3463
      if ((int )selection.end.col > (int )selection.beg.col) {
#line 3464
        selection.end.col = (R_int16_t )((int )selection.end.col - 1);
      }
    }
    {
#line 3465
    selection_delimit_word(0, & selection.beg, & selection.beg);
#line 3466
    selection_delimit_word(1, & selection.end, & selection.end);
    }
  } else
#line 3467
  if ((int )selection.clicks == 3) {
#line 3468
    if ((int )selection.mark.row > (int )selection.beg.row) {
#line 3469
      selection.mark.col = (R_int16_t )((int )selection.mark.col + 1);
    } else
#line 3468
    if ((int )selection.mark.row == (int )selection.beg.row) {
#line 3468
      if ((int )selection.mark.col > (int )selection.beg.col) {
#line 3469
        selection.mark.col = (R_int16_t )((int )selection.mark.col + 1);
      }
    }
#line 3470
    if (Options & (1UL << 15)) {
      {
#line 3471
      selection_delimit_word(0, & selection.beg, & selection.beg);
      }
    } else {
#line 3473
      selection.beg.col = (R_int16_t )0;
    }
#line 3475
    selection.end.col = (R_int16_t )TermWin.bcol;
  }
#line 3477
  if (button3) {
#line 3477
    if (buttonpress) {
#line 3478
      if ((unsigned int )closeto == 0U) {
#line 3479
        selection.mark.row = selection.end.row;
#line 3480
        selection.mark.col = (R_int16_t )((int )selection.end.col - ((int )selection.clicks == 2));
      } else {
#line 3482
        selection.mark.row = selection.beg.row;
#line 3483
        selection.mark.col = selection.beg.col;
      }
    }
  }
#line 3488
  return;
}
}
#line 3496 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_rotate(int x , int y ) 
{ 


  {
  {
#line 3499
  selection.clicks = (short )((int )selection.clicks % 3 + 1);
#line 3503
  selection_extend_colrow((x - TermWin_internalBorder) / (int )TermWin.fwidth, (y - TermWin_internalBorder) / (int )TermWin.fheight,
                          1, 0, 1);
  }
#line 3505
  return;
}
}
#line 3522 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void selection_send(XSelectionRequestEvent *rq ) 
{ 
  XEvent ev ;
  Atom target_list[4] ;
  Atom target ;
  XTextProperty ct ;
  XICCEncodingStyle style ;
  char *cl[4] ;

  {
#line 3537
  ev.xselection.type = 31;
#line 3538
  ev.xselection.property = (Atom )0L;
#line 3539
  ev.xselection.display = rq->display;
#line 3540
  ev.xselection.requestor = rq->requestor;
#line 3541
  ev.xselection.selection = rq->selection;
#line 3542
  ev.xselection.target = rq->target;
#line 3543
  ev.xselection.time = rq->time;
#line 3545
  if (rq->target == aterm_XA_TARGETS) {
    {
#line 3556
    target_list[0] = aterm_XA_TARGETS;
#line 3557
    target_list[1] = (Atom )31;
#line 3558
    target_list[2] = aterm_XA_TEXT;
#line 3559
    target_list[3] = _XA_COMPAUND_TEXT;
#line 3560
    XChangeProperty(Xdisplay, rq->requestor, rq->property, (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(target_list)),
                    (int )(sizeof(target_list) / sizeof(target_list[0])));
#line 3565
    ev.xselection.property = rq->property;
    }
  } else
#line 3566
  if (rq->target == 31UL) {
#line 3566
    goto _L;
  } else
#line 3566
  if (rq->target == _XA_COMPAUND_TEXT) {
#line 3566
    goto _L;
  } else
#line 3566
  if (rq->target == aterm_XA_TEXT) {
    _L: /* CIL Label */ 
#line 3569
    if (rq->target == 31UL) {
#line 3570
      style = (XICCEncodingStyle )0;
#line 3571
      target = (Atom )31;
    } else {
#line 3573
      target = _XA_COMPAUND_TEXT;
#line 3574
      if (rq->target == _XA_COMPAUND_TEXT) {
#line 3574
        style = (XICCEncodingStyle )1;
      } else {
#line 3574
        style = (XICCEncodingStyle )3;
      }
    }
    {
#line 3577
    cl[0] = (char *)selection.text;
#line 3578
    XmbTextListToTextProperty(Xdisplay, cl, 1, style, & ct);
#line 3579
    XChangeProperty(Xdisplay, rq->requestor, rq->property, target, 8, 0, (unsigned char const   *)ct.value,
                    (int )ct.nitems);
#line 3582
    ev.xselection.property = rq->property;
    }
  }
  {
#line 3584
  XSendEvent(Xdisplay, rq->requestor, 0, 0L, & ev);
  }
#line 3585
  return;
}
}
#line 3595 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void pixel_position(int *x , int *y ) 
{ 


  {
#line 3601
  *x = (*x - TermWin_internalBorder) / (int )TermWin.fwidth;
#line 3604
  *y = (*y - TermWin_internalBorder) / (int )TermWin.fheight;
#line 3606
  return;
}
}
#line 3611 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void mouse_tracking(int report , int x , int y , int firstrow , int lastrow ) 
{ 


  {
#line 3615
  return;
}
}
#line 3622 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void debug_PasteIt(unsigned char *data , int nitems ) 
{ 


  {
#line 3626
  return;
}
}
#line 3630 "/home/june/collector/temp/aterm-1.0.1/src/screen.c"
void debug_colors(void) 
{ 
  int color ;
  char *name[10] ;

  {
  {
#line 3634
  name[0] = (char *)"fg";
#line 3634
  name[1] = (char *)"bg";
#line 3634
  name[2] = (char *)"black";
#line 3634
  name[3] = (char *)"red";
#line 3634
  name[4] = (char *)"green";
#line 3634
  name[5] = (char *)"yellow";
#line 3634
  name[6] = (char *)"blue";
#line 3634
  name[7] = (char *)"magenta";
#line 3634
  name[8] = (char *)"cyan";
#line 3634
  name[9] = (char *)"white";
#line 3638
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Color ( ");
  }
#line 3639
  if ((unsigned int )rstyle & 4096U) {
    {
#line 3640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rvid ");
    }
  }
#line 3641
  if ((unsigned int )rstyle & 1024U) {
    {
#line 3642
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bold ");
    }
  }
#line 3643
  if ((unsigned int )rstyle & 2048U) {
    {
#line 3644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"blink ");
    }
  }
#line 3645
  if ((unsigned int )rstyle & 8192U) {
    {
#line 3646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uline ");
    }
  }
  {
#line 3647
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"): ");
#line 3649
  color = (int )((unsigned int )rstyle & 31U);
  }
#line 3651
  if (color >= 10) {
#line 3651
    if (color <= 17) {
      {
#line 3652
      color -= 8;
#line 3653
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bright ");
      }
    }
  }
  {
#line 3656
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s on ",
          name[color]);
#line 3658
  color = (int )(((unsigned int )rstyle & 992U) >> 5);
  }
#line 3660
  if (color >= 10) {
#line 3660
    if (color <= 17) {
      {
#line 3661
      color -= 8;
#line 3662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bright ");
      }
    }
  }
  {
#line 3665
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          name[color]);
  }
#line 3666
  return;
}
}
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/graphics.pro"
void Gr_NewWindow(int nargs , int *args ) ;
#line 2
void Gr_ClearWindow(grwin_t *grwin ) ;
#line 3
void Gr_Text(grwin_t *grwin , grcmd_t *data ) ;
#line 4
void Gr_Geometry(grwin_t *grwin , grcmd_t *data ) ;
#line 5
void Gr_DestroyWindow(grwin_t *grwin ) ;
#line 6
void Gr_Dispatch(grwin_t *grwin , grcmd_t *data ) ;
#line 7
void Gr_Redraw(grwin_t *grwin ) ;
#line 9
void Gr_do_graphics(int cmd , int nargs , int *args , unsigned char *text ) ;
#line 14
void Gr_Resize(int w , int h ) ;
#line 59 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_NewWindow(int nargs , int *args ) 
{ 


  {
#line 105
  return;
}
}
#line 109 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_ClearWindow(grwin_t *grwin ) 
{ 


  {
#line 125
  return;
}
}
#line 135 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_Text(grwin_t *grwin , grcmd_t *data ) 
{ 


  {
#line 169
  return;
}
}
#line 173 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_Geometry(grwin_t *grwin , grcmd_t *data ) 
{ 


  {
#line 198
  return;
}
}
#line 202 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_DestroyWindow(grwin_t *grwin ) 
{ 


  {
#line 230
  return;
}
}
#line 234 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_Dispatch(grwin_t *grwin , grcmd_t *data ) 
{ 


  {
#line 309
  return;
}
}
#line 313 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_Redraw(grwin_t *grwin ) 
{ 


  {
#line 322
  return;
}
}
#line 329 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_ButtonReport(int but , int x , int y ) 
{ 


  {
#line 349
  return;
}
}
#line 353 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_do_graphics(int cmd , int nargs , int *args , unsigned char *text ) 
{ 


  {
#line 439
  return;
}
}
#line 443 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_scroll(int count ) 
{ 


  {
#line 466
  return;
}
}
#line 469 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_ClearScreen(void) 
{ 


  {
#line 486
  return;
}
}
#line 489 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_ChangeScreen(void) 
{ 


  {
#line 508
  return;
}
}
#line 512 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_expose(Window win ) 
{ 


  {
#line 525
  return;
}
}
#line 529 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_Resize(int w , int h ) 
{ 


  {
#line 545
  return;
}
}
#line 548 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
void Gr_reset(void) 
{ 


  {
#line 561
  return;
}
}
#line 564 "/home/june/collector/temp/aterm-1.0.1/src/graphics.c"
int Gr_Displayed(void) 
{ 


  {
#line 570
  return (0);
}
}
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 9 "/home/june/collector/temp/aterm-1.0.1/src/misc.pro"
void Draw_tl(Window win , GC gc , int x , int y , int w , int h ) ;
#line 10
void Draw_br(Window win , GC gc , int x , int y , int w , int h ) ;
#line 11
void Draw_Shadow(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                 int h ) ;
#line 12
void Draw_Triangle(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                   int type ) ;
#line 29 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
char const   *my_basename(char const   *str ) 
{ 
  char const   *base ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 32
  tmp = strrchr(str, '/');
#line 32
  base = (char const   *)tmp;
  }
#line 34
  if (base) {
#line 34
    tmp___0 = base + 1;
  } else {
#line 34
    tmp___0 = str;
  }
#line 34
  return (tmp___0);
}
}
#line 41 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
void print_error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;

  {
  {
#line 46
  __builtin_va_start(arg_ptr, fmt);
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"aterm: ");
#line 48
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 50
  __builtin_va_end(arg_ptr);
  }
#line 51
  return;
}
}
#line 62 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
int Str_match(char const   *s1 , char const   *s2 ) 
{ 
  int n ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 65
  n = 0;
#line 67
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 68
    return (0);
  } else
#line 67
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 68
    return (0);
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *s2) {
#line 70
      goto while_break;
    }
#line 71
    tmp = s1;
#line 71
    s1 ++;
#line 71
    tmp___0 = s2;
#line 71
    s2 ++;
#line 71
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 72
      return (0);
    }
#line 73
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (n);
}
}
#line 84 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
char *Str_skip_space(char *str ) 
{ 
  unsigned short const   **tmp ;

  {
#line 87
  if (str) {
#line 87
    if (*str) {
      {
#line 88
      while (1) {
        while_continue: /* CIL Label */ ;
#line 88
        if (*str) {
          {
#line 88
          tmp = __ctype_b_loc();
          }
#line 88
          if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 88
            goto while_break;
          }
        } else {
#line 88
          goto while_break;
        }
#line 89
        str ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 91
  return (str);
}
}
#line 95 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
char *Str_trim(char *str ) 
{ 
  char *src ;
  int n ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char *dst ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 98
  if (str) {
#line 98
    if (*str) {
      {
#line 102
      src = Str_skip_space(str);
#line 103
      tmp = strlen((char const   *)src);
#line 103
      n = (int )(tmp - 1UL);
      }
      {
#line 105
      while (1) {
        while_continue: /* CIL Label */ ;
#line 105
        if (n > 0) {
          {
#line 105
          tmp___0 = __ctype_b_loc();
          }
#line 105
          if (! ((int const   )*(*tmp___0 + (int )*(src + n)) & 8192)) {
#line 105
            goto while_break;
          }
        } else {
#line 105
          goto while_break;
        }
#line 106
        n --;
      }
      while_break: /* CIL Label */ ;
      }
#line 107
      *(src + (n + 1)) = (char )'\000';
#line 110
      if ((int )*(src + 0) == 34) {
#line 111
        src ++;
#line 112
        n --;
#line 113
        if ((int )*(src + n) == 34) {
#line 114
          tmp___1 = n;
#line 114
          n --;
#line 114
          *(src + tmp___1) = (char )'\000';
        }
      }
#line 116
      if (n < 0) {
#line 117
        *str = (char )'\000';
      } else
#line 118
      if ((unsigned long )src != (unsigned long )str) {
#line 119
        dst = str;
        {
#line 122
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 123
          tmp___2 = dst;
#line 123
          dst ++;
#line 123
          *tmp___2 = *src;
#line 122
          tmp___3 = src;
#line 122
          src ++;
#line 122
          if (! ((int )*tmp___3 != 0)) {
#line 122
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 128
  return (str);
}
}
#line 146 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
int Str_escaped(char *str ) 
{ 
  register char *p ;
  int i ;
  int len ;
  int n ;
  int append ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  register char ch ;
  char *tmp___4 ;
  int j ;
  int num ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 149
  p = str;
#line 150
  i = 0;
#line 150
  append = 0;
#line 154
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 155
    return (0);
  } else {
    {
#line 154
    tmp = strlen((char const   *)str);
#line 154
    len = (int )tmp;
    }
#line 154
    if (len == 0) {
#line 155
      return (0);
    }
  }
  {
#line 158
  n = Str_match((char const   *)p, "M-");
  }
#line 158
  if (n != 0) {
    {
#line 159
    tmp___0 = i;
#line 159
    i ++;
#line 159
    *(str + tmp___0) = (char )'\033';
#line 160
    len --;
#line 161
    p += n;
#line 162
    tmp___3 = toupper((int )*p);
    }
#line 162
    if (tmp___3 == 88) {
#line 164
      append = '\r';
#line 165
      tmp___1 = i;
#line 165
      i ++;
#line 165
      *(str + tmp___1) = (char )'x';
#line 166
      p ++;
      {
#line 167
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 167
        tmp___2 = __ctype_b_loc();
        }
#line 167
        if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 167
          goto while_break;
        }
#line 168
        p ++;
#line 169
        len --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (i < len)) {
#line 173
      goto while_break___0;
    }
#line 174
    tmp___4 = p;
#line 174
    p ++;
#line 174
    ch = *tmp___4;
#line 176
    if ((int )ch == 92) {
#line 177
      ch = *p;
#line 178
      if ((int )ch >= 48) {
#line 178
        if ((int )ch <= 55) {
#line 179
          num = 0;
#line 181
          j = 0;
          {
#line 181
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 181
            if (j < 3) {
#line 181
              if ((int )ch >= 48) {
#line 181
                if (! ((int )ch <= 55)) {
#line 181
                  goto while_break___1;
                }
              } else {
#line 181
                goto while_break___1;
              }
            } else {
#line 181
              goto while_break___1;
            }
#line 182
            num = num * 8 + ((int )ch - 48);
#line 183
            p ++;
#line 184
            len --;
#line 185
            ch = *p;
#line 181
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 187
          ch = (char )((unsigned char )num);
        } else {
#line 178
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 189
        p ++;
#line 190
        len --;
        {
#line 192
        if ((int )ch == 97) {
#line 192
          goto case_97;
        }
#line 195
        if ((int )ch == 98) {
#line 195
          goto case_98;
        }
#line 199
        if ((int )ch == 101) {
#line 199
          goto case_101;
        }
#line 199
        if ((int )ch == 69) {
#line 199
          goto case_101;
        }
#line 202
        if ((int )ch == 110) {
#line 202
          goto case_110;
        }
#line 205
        if ((int )ch == 114) {
#line 205
          goto case_114;
        }
#line 208
        if ((int )ch == 116) {
#line 208
          goto case_116;
        }
#line 191
        goto switch_break;
        case_97: /* CIL Label */ 
#line 193
        ch = (char)7;
#line 194
        goto switch_break;
        case_98: /* CIL Label */ 
#line 196
        ch = (char )'\b';
#line 197
        goto switch_break;
        case_101: /* CIL Label */ 
        case_69: /* CIL Label */ 
#line 200
        ch = (char)27;
#line 201
        goto switch_break;
        case_110: /* CIL Label */ 
#line 203
        ch = (char )'\n';
#line 204
        goto switch_break;
        case_114: /* CIL Label */ 
#line 206
        ch = (char )'\r';
#line 207
        goto switch_break;
        case_116: /* CIL Label */ 
#line 209
        ch = (char )'\t';
#line 210
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else
#line 213
    if ((int )ch == 94) {
      {
#line 214
      ch = *p;
#line 215
      p ++;
#line 216
      len --;
#line 217
      tmp___5 = toupper((int )ch);
#line 217
      ch = (char )tmp___5;
      }
#line 218
      if ((int )ch == 63) {
#line 218
        ch = (char)127;
      } else {
#line 218
        ch = (char )((int )ch - 64);
      }
    }
#line 220
    *(str + i) = ch;
#line 173
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 224
  if ((int )*(str + 0) == 0) {
#line 224
    if ((int )*(str + 1) == 27) {
#line 224
      if ((int )*(str + 2) == 93) {
#line 225
        append = 7;
      }
    }
  }
#line 228
  if (append) {
#line 228
    if ((int )*(str + (len - 1)) != append) {
#line 229
      tmp___6 = len;
#line 229
      len ++;
#line 229
      *(str + tmp___6) = (char )append;
    }
  }
#line 231
  *(str + len) = (char )'\000';
#line 233
  return (len);
}
}
#line 354 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
void Draw_tl(Window win , GC gc , int x , int y , int w , int h ) 
{ 
  int shadow ;

  {
#line 357
  shadow = 2;
#line 359
  if (w == 0) {
#line 360
    shadow = 1;
  } else
#line 359
  if (h == 0) {
#line 360
    shadow = 1;
  }
#line 362
  w += x - 1;
#line 363
  h += y - 1;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (shadow > 0)) {
#line 365
      goto while_break;
    }
    {
#line 366
    XDrawLine(Xdisplay, win, gc, x, y, w, y);
#line 367
    XDrawLine(Xdisplay, win, gc, x, y, x, h);
#line 365
    shadow --;
#line 365
    x ++;
#line 365
    y ++;
#line 365
    w --;
#line 365
    h --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 375 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
void Draw_br(Window win , GC gc , int x , int y , int w , int h ) 
{ 
  int shadow ;

  {
#line 378
  shadow = 2;
#line 380
  if (w == 0) {
#line 381
    shadow = 1;
  } else
#line 380
  if (h == 0) {
#line 381
    shadow = 1;
  }
#line 383
  w += x - 1;
#line 384
  h += y - 1;
#line 386
  x ++;
#line 387
  y ++;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (shadow > 0)) {
#line 388
      goto while_break;
    }
    {
#line 389
    XDrawLine(Xdisplay, win, gc, w, h, w, y);
#line 390
    XDrawLine(Xdisplay, win, gc, w, h, x, h);
#line 388
    shadow --;
#line 388
    x ++;
#line 388
    y ++;
#line 388
    w --;
#line 388
    h --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 395 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
void Draw_Shadow(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                 int h ) 
{ 


  {
  {
#line 398
  Draw_tl(win, topShadow, x, y, w, h);
#line 399
  Draw_br(win, botShadow, x, y, w, h);
  }
#line 400
  return;
}
}
#line 404 "/home/june/collector/temp/aterm-1.0.1/src/misc.c"
void Draw_Triangle(Window win , GC topShadow , GC botShadow , int x , int y , int w ,
                   int type ) 
{ 


  {
  {
#line 408
  if (type == 114) {
#line 408
    goto case_114;
  }
#line 414
  if (type == 108) {
#line 414
    goto case_108;
  }
#line 420
  if (type == 100) {
#line 420
    goto case_100;
  }
#line 426
  if (type == 117) {
#line 426
    goto case_117;
  }
#line 407
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 409
  XDrawLine(Xdisplay, win, topShadow, x, y, x, y + w);
#line 410
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y + w / 2);
#line 411
  XDrawLine(Xdisplay, win, botShadow, x, y + w, x + w, y + w / 2);
  }
#line 412
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 415
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w, y);
#line 416
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w / 2);
#line 417
  XDrawLine(Xdisplay, win, topShadow, x, y + w / 2, x + w, y);
  }
#line 418
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 421
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w / 2, y + w);
#line 422
  XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y);
#line 423
  XDrawLine(Xdisplay, win, botShadow, x + w, y, x + w / 2, y + w);
  }
#line 424
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 427
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w / 2, y);
#line 428
  XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w);
#line 429
  XDrawLine(Xdisplay, win, topShadow, x, y + w, x + w / 2, y);
  }
#line 430
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 440
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1564
extern Colormap XCreateColormap(Display * , Window  , Visual * , int  ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1827
extern char *XDisplayString(Display * ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2465
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2612
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2644
extern int XGetIconName(Display * , Window  , char ** ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 3072
extern int XRecolorCursor(Display * , Cursor  , XColor * , XColor * ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3257
extern int XSetIconName(Display * , Window  , char const   * ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 542 "/usr/include/X11/Xutil.h"
extern int XMatchVisualInfo(Display * , int  , int  , int  , XVisualInfo * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 665
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 167 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom _XA_MwmAtom ;
#line 168
Atom _XA_NET_WM_PID ;
#line 170
Atom _XA_NET_SUPPORTED ;
#line 174
Atom _XA_NET_WM_STATE_STICKY ;
#line 175
Atom _XA_NET_WM_STATE_SHADED ;
#line 176
Atom _XA_NET_WM_STATE_HIDDEN ;
#line 992 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Colormap Xcmap  ;
#line 993 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int Xdepth  ;
#line 994 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Visual *Xvisual  ;
#line 996 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
TermWin_t TermWin  ;
#line 1003 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int TermWin_internalBorder  ;
#line 1005 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int TermWin_internalBorders  ;
#line 1008 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
scrollBar_t scrollBar  ;
#line 1009 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
menuBar_t menuBar  ;
#line 1010 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Display *Xdisplay  ;
#line 1011 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int XdisplayWidth  ;
#line 1011 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int XdisplayHeight  ;
#line 1027 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
ExtWMSupportData ExtWM  ;
#line 1029 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int wm_supports_desktops  ;
#line 1030 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int wm_current_desktop  ;
#line 1030 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int wm_aterm_desktop  ;
#line 1032 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
unsigned long Options  ;
#line 1033 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int sb_shadow  ;
#line 1034 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
int delay_menu_drawing  ;
#line 1035 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *display_name  ;
#line 1036 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_name  ;
#line 1037 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_term_name  ;
#line 1038 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_color[27]  ;
#line 1039 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Pixel PixColorsFocused[29]  ;
#line 1041 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Pixel PixColorsUnFocused[29]  ;
#line 1046 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Pixel *PixColors  ;
#line 1047 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_title  ;
#line 1048 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_iconName  ;
#line 1049 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_geometry  ;
#line 1050 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_minBufferWidth  ;
#line 1051 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_saveLines  ;
#line 1055 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_borderWidth  ;
#line 1056 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_internal_border  ;
#line 1057 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_cutchars  ;
#line 1059 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_modifier  ;
#line 1062 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_backspace_key  ;
#line 1065 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_delete_key  ;
#line 1067 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_font[5]  ;
#line 1072 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_boldFont  ;
#line 1082 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
unsigned int colorfgbg  ;
#line 1085 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
unsigned char const   *KeySym_map[256]  ;
#line 1091 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_menu  ;
#line 1092 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_path  ;
#line 1099 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_backgroundType  ;
#line 1100 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_tintType  ;
#line 1101 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_shade  ;
#line 1105 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_fade  ;
#line 1108 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
char const   *rs_textType  ;
#line 1110 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_TARGETS  ;
#line 1111 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_TEXT  ;
#line 1112 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom _XA_COMPAUND_TEXT  ;
#line 1113 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_UTF8_STRING  ;
#line 1114 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_CLIPBOARD  ;
#line 1115 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_VT_SELECTION  ;
#line 1116 "/home/june/collector/temp/aterm-1.0.1/src/rxvt.h"
Atom aterm_XA_INCR  ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/main.pro"
XErrorHandler xerror_handler(Display *dpy , XErrorEvent *event ) ;
#line 2
void color_aliases(int idx ) ;
#line 4
void set_terminal_size(unsigned int new_ncol , unsigned int new_nrow ) ;
#line 6
void Create_Windows(int argc , char **argv ) ;
#line 7
int resize_subwindows(int width , int height ) ;
#line 8
void resize(void) ;
#line 9
void resize_window1(unsigned int width , unsigned int height ) ;
#line 12
void set_title(char const   *str ) ;
#line 13
void set_iconName(char const   *str ) ;
#line 14
void set_window_color(int idx , char const   *color ) ;
#line 16
void eterm_seq(int op , char const   *str ) ;
#line 21
int read_32bit_proplist(Window w , Atom property , long estimate , CARD32 **list ,
                        long *nitems ) ;
#line 24
int main(int argc , char **argv ) ;
#line 1 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.pro"
unsigned int GetScrollArrowsHeight(void) ;
#line 2
int scrollbar_mapping(int map ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 44 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Window ParentWin[3]  = {      (Window )0,      (Window )0,      (Window )0};
#line 45 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int ParentWinNum  =    0;
#line 56 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_MwmAtom  =    (Atom )0L;
#line 57 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_PID  =    (Atom )0L;
#line 58 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XROOTPMAP_ID  =    (Atom )0L;
#line 59 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_SUPPORTING_WM_CHECK  =    (Atom )0L;
#line 60 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_SUPPORTED  =    (Atom )0L;
#line 61 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_CURRENT_DESKTOP  =    (Atom )0L;
#line 62 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_DESKTOP  =    (Atom )0L;
#line 63 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_STATE  =    (Atom )0L;
#line 64 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_STATE_STICKY  =    (Atom )0L;
#line 65 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_STATE_SHADED  =    (Atom )0L;
#line 66 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
Atom _XA_NET_WM_STATE_HIDDEN  =    (Atom )0L;
#line 77 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static Cursor TermWin_cursor  ;
#line 79 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static XSizeHints szHint  = 
#line 79
     {(((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9), 0, 0, 80, 24, 1, 1, 0, 0, 1,
    1, {1, 1}, {0, 0}, 0, 0, 1};
#line 92 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char const   *def_colorName[27]  = 
#line 92
  {      "White",      "Black",      "Black",      "Red3", 
        "Green3",      "Yellow3",      "Blue3",      "Magenta3", 
        "Cyan3",      "AntiqueWhite",      "Grey25",      "Red", 
        "Green",      "Yellow",      "Blue",      "Magenta", 
        "Cyan",      "White",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      "#B2B2B2",      "#969696"};
#line 140 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char const   *def_fontName[5]  = {      "7x14",      "6x10",      "6x13",      "8x13", 
        "9x15"};
#line 168 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
XErrorHandler xerror_handler(Display *dpy , XErrorEvent *event ) 
{ 
  char *err_text ;
  void *tmp ;

  {
  {
#line 173
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"aterm has encountered the following problem interacting with X Windows :\n");
  }
#line 174
  if (event) {
#line 174
    if (dpy) {
      {
#line 176
      tmp = malloc((size_t )128);
#line 176
      err_text = (char *)tmp;
#line 177
      strcpy((char */* __restrict  */)err_text, (char const   */* __restrict  */)"unknown error");
#line 178
      XGetErrorText(dpy, (int )event->error_code, err_text, 120);
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Request: %d,    Error: %d(%s)\n",
              (int )event->request_code, (int )event->error_code, err_text);
#line 180
      free((void *)err_text);
#line 181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      in resource: 0x%lX\n",
              event->resourceid);
      }
    }
  }
#line 183
  return ((XErrorHandler )0);
}
}
#line 196 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void color_aliases(int idx ) 
{ 
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 199
  if (rs_color[idx]) {
    {
#line 199
    tmp___0 = __ctype_b_loc();
    }
#line 199
    if ((int const   )*(*tmp___0 + (int )*(rs_color[idx])) & 2048) {
      {
#line 200
      tmp = atoi(rs_color[idx]);
#line 200
      i = tmp;
      }
#line 202
      if (i >= 8) {
#line 202
        if (i <= 15) {
#line 203
          i -= 8;
#line 205
          rs_color[idx] = rs_color[10 + i];
#line 206
          return;
        }
      }
#line 209
      if (i >= 0) {
#line 209
        if (i <= 7) {
#line 210
          rs_color[idx] = rs_color[2 + i];
        }
      }
    }
  }
#line 212
  return;
}
}
#line 223 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char colorfgbg_env[29]  = 
#line 223
  {      (char )'C',      (char )'O',      (char )'L',      (char )'O', 
        (char )'R',      (char )'F',      (char )'G',      (char )'B', 
        (char )'G',      (char )'=',      (char )'d',      (char )'e', 
        (char )'f',      (char )'a',      (char )'u',      (char )'l', 
        (char )'t',      (char )';',      (char )'d',      (char )'e', 
        (char )'f',      (char )'a',      (char )'u',      (char )'l', 
        (char )'t',      (char )';',      (char )'b',      (char )'g', 
        (char )'\000'};
#line 219 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_colorfgbg(void) 
{ 
  unsigned int i ;
  char *p ;
  int fg ;
  int bg ;

  {
#line 225
  fg = -1;
#line 225
  bg = -1;
#line 227
  i = 2U;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i <= 17U)) {
#line 227
      goto while_break;
    }
#line 229
    if (*(PixColors + 0) == *(PixColors + i)) {
#line 230
      fg = (int )(i - 2U);
#line 231
      goto while_break;
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  i = 2U;
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 234
    if (! (i <= 17U)) {
#line 234
      goto while_break___0;
    }
#line 236
    if (*(PixColors + 1) == *(PixColors + i)) {
#line 237
      bg = (int )(i - 2U);
#line 238
      goto while_break___0;
    }
#line 234
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 242
  p = strchr((char const   *)(colorfgbg_env), '=');
#line 243
  p ++;
  }
#line 244
  if (fg >= 0) {
    {
#line 245
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d;", fg);
    }
  } else {
    {
#line 247
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)"default;"));
    }
  }
  {
#line 248
  p = strchr((char const   *)p, '\000');
  }
#line 249
  if (bg >= 0) {
    {
#line 250
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d", bg);
    }
  } else {
    {
#line 252
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)"default"));
    }
  }
  {
#line 254
  putenv(colorfgbg_env);
#line 256
  colorfgbg = (unsigned int )(1 << 5);
#line 257
  i = 2U;
  }
  {
#line 257
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 257
    if (! (i <= 9U)) {
#line 257
      goto while_break___1;
    }
#line 258
    if (*(PixColors + 0) == *(PixColors + i)) {
#line 258
      if (*(PixColors + 0) == *(PixColors + 23)) {
#line 267
        colorfgbg = (colorfgbg & 4294967264U) | i;
      }
    }
#line 268
    if (*(PixColors + 1) == *(PixColors + i)) {
#line 269
      colorfgbg = (colorfgbg & 4294966303U) | (i << 5);
    }
#line 257
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 271
  return;
}
}
#line 278 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_terminal_size(unsigned int new_ncol , unsigned int new_nrow ) 
{ 


  {
#line 281
  if (new_nrow <= 0U) {
#line 281
    new_nrow = 24U;
  }
#line 282
  if (new_ncol <= 0U) {
#line 282
    new_ncol = 80U;
  }
#line 283
  TermWin.ncol = (R_u_int16_t )new_ncol;
#line 284
  TermWin.nrow = (R_u_int16_t )new_nrow;
#line 285
  TermWin.bcol = (R_u_int16_t )new_ncol;
#line 286
  if ((int )TermWin.min_bcol > (int )TermWin.bcol) {
#line 286
    TermWin.bcol = TermWin.min_bcol;
  }
#line 287
  return;
}
}
#line 292 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_cursor_color(void) 
{ 
  XColor fg ;
  XColor bg ;

  {
  {
#line 297
  fg.pixel = PixColorsFocused[20];
#line 298
  XQueryColor(Xdisplay, Xcmap, & fg);
#line 299
  bg.pixel = PixColorsFocused[1];
#line 300
  XQueryColor(Xdisplay, Xcmap, & bg);
#line 301
  XRecolorCursor(Xdisplay, TermWin_cursor, & fg, & bg);
  }
#line 302
  return;
}
}
#line 328 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void SetBackgroundType(char const   *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 334
  TermWin.background.trgType = (enum __anonenum_trgType_164 )1;
#line 337
  if (Options & (1UL << 13)) {
#line 339
    if (TermWin.background.Shading.shading != 100) {
#line 340
      TermWin.background.trgType = (enum __anonenum_trgType_164 )9;
    } else {
#line 342
      TermWin.background.trgType = (enum __anonenum_trgType_164 )10;
    }
  }
#line 345
  if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 346
    return;
  } else
#line 345
  if ((unsigned int )TermWin.background.trgType != 1U) {
#line 346
    return;
  }
  {
#line 348
  tmp___6 = strcmp(type, "center");
  }
#line 348
  if (tmp___6 == 0) {
#line 349
    TermWin.background.trgType = (enum __anonenum_trgType_164 )2;
  } else {
    {
#line 350
    tmp___5 = strcmp(type, "scale");
    }
#line 350
    if (tmp___5 == 0) {
#line 351
      TermWin.background.trgType = (enum __anonenum_trgType_164 )3;
    } else {
      {
#line 352
      tmp___4 = strcmp(type, "scaleh");
      }
#line 352
      if (tmp___4 == 0) {
#line 353
        TermWin.background.trgType = (enum __anonenum_trgType_164 )4;
      } else {
        {
#line 354
        tmp___3 = strcmp(type, "scalev");
        }
#line 354
        if (tmp___3 == 0) {
#line 355
          TermWin.background.trgType = (enum __anonenum_trgType_164 )5;
        } else {
          {
#line 356
          tmp___2 = strcmp(type, "notile");
          }
#line 356
          if (tmp___2 == 0) {
#line 357
            TermWin.background.trgType = (enum __anonenum_trgType_164 )6;
          } else {
            {
#line 358
            tmp___1 = strcmp(type, "notileh");
            }
#line 358
            if (tmp___1 == 0) {
#line 359
              TermWin.background.trgType = (enum __anonenum_trgType_164 )7;
            } else {
              {
#line 360
              tmp___0 = strcmp(type, "notilev");
              }
#line 360
              if (tmp___0 == 0) {
#line 361
                TermWin.background.trgType = (enum __anonenum_trgType_164 )8;
              } else {
                {
#line 362
                tmp = strcmp(type, "cut");
                }
#line 362
                if (tmp == 0) {
#line 363
                  TermWin.background.trgType = (enum __anonenum_trgType_164 )9;
                }
              }
            }
          }
        }
      }
    }
  }
#line 364
  return;
}
}
#line 366 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void InitBackground(void) 
{ 


  {
#line 368
  TermWin.background.srcPixmap = (Pixmap )0L;
#line 369
  TermWin.background.mystyle = (struct MyStyle *)((void *)0);
#line 370
  TermWin.background.user_flags = 0U;
#line 371
  TermWin.background.bMySource = 0;
#line 372
  TermWin.background.trgPixmap = (Pixmap )0L;
#line 373
  TermWin.background.trgPixmapSet = 0;
#line 374
  TermWin.background.Width = 0;
#line 375
  TermWin.background.Height = 0;
#line 376
  TermWin.background.srcWidth = -1;
#line 377
  TermWin.background.srcHeight = -1;
#line 378
  TermWin.background.srcX = -1;
#line 379
  TermWin.background.srcY = -1;
#line 386
  TermWin.background.finWidth = 0;
#line 387
  TermWin.background.finHeight = 0;
#line 388
  TermWin.background.cutX = -1;
#line 389
  TermWin.background.cutY = -1;
#line 392
  TermWin.background.Shading.shading = 100;
#line 392
  TermWin.background.Shading.tintColor.red = (unsigned short)65535;
#line 392
  TermWin.background.Shading.tintColor.green = (unsigned short)65535;
#line 392
  TermWin.background.Shading.tintColor.blue = (unsigned short)65535;
#line 394
  return;
}
}
#line 397 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int ParseGCType(char const   *type , int def_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 399
  if (! type) {
#line 399
    return (def_type);
  }
  {
#line 401
  tmp___10 = strcmp(type, "and");
  }
#line 401
  if (tmp___10 == 0) {
#line 401
    return (1);
  } else {
    {
#line 402
    tmp___9 = strcmp(type, "andReverse");
    }
#line 402
    if (tmp___9 == 0) {
#line 402
      return (2);
    } else {
      {
#line 403
      tmp___8 = strcmp(type, "andInverted");
      }
#line 403
      if (tmp___8 == 0) {
#line 403
        return (4);
      } else {
        {
#line 404
        tmp___7 = strcmp(type, "xor");
        }
#line 404
        if (tmp___7 == 0) {
#line 404
          return (6);
        } else {
          {
#line 405
          tmp___6 = strcmp(type, "or");
          }
#line 405
          if (tmp___6 == 0) {
#line 405
            return (7);
          } else {
            {
#line 406
            tmp___5 = strcmp(type, "nor");
            }
#line 406
            if (tmp___5 == 0) {
#line 406
              return (8);
            } else {
              {
#line 407
              tmp___4 = strcmp(type, "invert");
              }
#line 407
              if (tmp___4 == 0) {
#line 407
                return (10);
              } else {
                {
#line 408
                tmp___3 = strcmp(type, "equiv");
                }
#line 408
                if (tmp___3 == 0) {
#line 408
                  return (9);
                } else {
                  {
#line 409
                  tmp___2 = strcmp(type, "invert");
                  }
#line 409
                  if (tmp___2 == 0) {
#line 409
                    return (10);
                  } else {
                    {
#line 410
                    tmp___1 = strcmp(type, "orReverse");
                    }
#line 410
                    if (tmp___1 == 0) {
#line 410
                      return (11);
                    } else {
                      {
#line 411
                      tmp___0 = strcmp(type, "orInverted");
                      }
#line 411
                      if (tmp___0 == 0) {
#line 411
                        return (13);
                      } else {
                        {
#line 412
                        tmp = strcmp(type, "nand");
                        }
#line 412
                        if (tmp == 0) {
#line 412
                          return (14);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 413
  return (def_type);
}
}
#line 417 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
unsigned long fade_color(unsigned long pixel ) 
{ 
  XColor faded_xcol ;
  int fade ;
  int tmp ;

  {
#line 419
  if (rs_fade) {
    {
#line 422
    fade = 0;
#line 424
    fade = atoi(rs_fade);
#line 425
    faded_xcol.pixel = pixel;
#line 426
    XQueryColor(Xdisplay, Xcmap, & faded_xcol);
#line 427
    faded_xcol.red = (unsigned short )(((int )faded_xcol.red / 100) * fade);
#line 428
    faded_xcol.green = (unsigned short )(((int )faded_xcol.green / 100) * fade);
#line 429
    faded_xcol.blue = (unsigned short )(((int )faded_xcol.blue / 100) * fade);
#line 431
    tmp = XAllocColor(Xdisplay, Xcmap, & faded_xcol);
    }
#line 431
    if (tmp) {
#line 432
      return (faded_xcol.pixel);
    }
  }
#line 434
  return (pixel);
}
}
#line 440 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void Create_Windows(int argc , char **argv ) 
{ 
  Cursor cursor ;
  XClassHint classHint ;
  XWMHints wmHint ;
  MwmHints mwmhints ;
  int i ;
  int x ;
  int y ;
  int flags ;
  unsigned int width ;
  unsigned int height ;
  XSetWindowAttributes attributes ;
  unsigned long attr_mask ;
  XWindowAttributes gattr ;
  XVisualInfo vinfo ;
  int tmp ;
  char const   *msg ;
  XColor xcol ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  XColor xcol___0 ;
  XColor white ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long ldata ;
  __pid_t tmp___10 ;
  XColor fg ;
  XColor bg ;
  Pixmap tmp___11 ;
  XGCValues gcvalue ;
  int tmp___12 ;

  {
#line 454
  Xcmap = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap;
#line 455
  Xvisual = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_visual;
#line 457
  if (Options & (1UL << 13)) {
    {
#line 458
    XGetWindowAttributes(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                         & gattr);
#line 459
    Xdepth = gattr.depth;
    }
  } else {
#line 461
    Xdepth = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth;
#line 465
    if (Xdepth != 24) {
      {
#line 468
      tmp = XMatchVisualInfo(Xdisplay, ((_XPrivDisplay )Xdisplay)->default_screen,
                             24, 4, & vinfo);
      }
#line 468
      if (tmp) {
        {
#line 469
        Xdepth = 24;
#line 470
        Xvisual = vinfo.visual;
#line 471
        Xcmap = XCreateColormap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                Xvisual, 0);
        }
      }
    }
  }
#line 479
  if (Options & (1UL << 16)) {
#line 481
    if (_XA_MwmAtom == 0UL) {
#line 483
      attributes.override_redirect = 1;
#line 484
      mwmhints.flags = (CARD32 )0;
    } else {
#line 487
      mwmhints.flags = (CARD32 )(1L << 1);
#line 488
      mwmhints.decorations = (CARD32 )0;
    }
  } else {
#line 492
    mwmhints.flags = (CARD32 )0;
  }
#line 499
  PixColors = & PixColorsFocused[0];
#line 501
  i = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (Xdepth <= 2) {
#line 501
      tmp___4 = 2;
    } else {
#line 501
      tmp___4 = 27;
    }
#line 501
    if (! (i < tmp___4)) {
#line 501
      goto while_break;
    }
#line 504
    msg = "can\'t load color \"%s\", colorID = %d, (%d)";
#line 507
    if (! rs_color[i]) {
#line 508
      goto __Cont;
    }
    {
#line 510
    tmp___2 = XParseColor(Xdisplay, Xcmap, rs_color[i], & xcol);
    }
#line 510
    if (tmp___2) {
      {
#line 510
      tmp___3 = XAllocColor(Xdisplay, Xcmap, & xcol);
      }
#line 510
      if (! tmp___3) {
        _L___0: /* CIL Label */ 
        {
#line 513
        print_error(msg, rs_color[i], i, 29);
#line 514
        rs_color[i] = def_colorName[i];
        }
#line 515
        if (! rs_color[i]) {
#line 516
          goto __Cont;
        }
        {
#line 517
        tmp___0 = XParseColor(Xdisplay, Xcmap, rs_color[i], & xcol);
        }
#line 517
        if (tmp___0) {
          {
#line 517
          tmp___1 = XAllocColor(Xdisplay, Xcmap, & xcol);
          }
#line 517
          if (! tmp___1) {
            _L: /* CIL Label */ 
            {
#line 520
            print_error(msg, rs_color[i], i, 29);
            }
            {
#line 523
            if (i == 1) {
#line 523
              goto case_1;
            }
#line 523
            if (i == 0) {
#line 523
              goto case_1;
            }
#line 529
            if (i == 18) {
#line 529
              goto case_18;
            }
#line 532
            if (i == 19) {
#line 532
              goto case_19;
            }
#line 536
            if (i == 20) {
#line 536
              goto case_20;
            }
#line 540
            if (i == 22) {
#line 540
              goto case_22;
            }
#line 544
            goto switch_default;
            case_1: /* CIL Label */ 
            case_0: /* CIL Label */ 
            {
#line 525
            print_error("aborting");
#line 526
            exit(1);
            }
#line 527
            goto switch_break;
            case_18: /* CIL Label */ 
#line 530
            xcol.pixel = *(PixColors + 1);
#line 531
            goto switch_break;
            case_19: /* CIL Label */ 
#line 533
            xcol.pixel = *(PixColors + 0);
#line 534
            goto switch_break;
            case_20: /* CIL Label */ 
#line 537
            xcol.pixel = *(PixColors + 0);
#line 538
            goto switch_break;
            case_22: /* CIL Label */ 
#line 541
            xcol.pixel = *(PixColors + 1);
#line 542
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 545
            xcol.pixel = *(PixColors + 1);
#line 546
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
            {
#line 548
            XQueryColor(Xdisplay, Xcmap, & xcol);
            }
          }
        } else {
#line 517
          goto _L;
        }
      }
    } else {
#line 510
      goto _L___0;
    }
    {
#line 551
    *(PixColors + i) = xcol.pixel;
#line 553
    PixColorsUnFocused[i] = fade_color(xcol.pixel);
    }
#line 556
    if (i == 22) {
#line 558
      TermWin.background.Shading.tintColor.pixel = xcol.pixel;
#line 559
      TermWin.background.Shading.tintColor.red = xcol.red;
#line 560
      TermWin.background.Shading.tintColor.green = xcol.green;
#line 561
      TermWin.background.Shading.tintColor.blue = xcol.blue;
#line 562
      TermWin.background.Shading.tintColor.flags = xcol.flags;
    }
    __Cont: /* CIL Label */ 
#line 501
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if (Xdepth <= 2) {
#line 569
    *(PixColors + 20) = *(PixColors + 0);
  } else
#line 568
  if (! rs_color[20]) {
#line 569
    *(PixColors + 20) = *(PixColors + 0);
  }
#line 570
  if (Xdepth <= 2) {
#line 571
    *(PixColors + 21) = *(PixColors + 0);
  } else
#line 570
  if (! rs_color[21]) {
#line 571
    *(PixColors + 21) = *(PixColors + 0);
  }
#line 580
  if (Xdepth <= 2) {
#line 581
    *(PixColors + 25) = *(PixColors + 0);
#line 582
    *(PixColors + 27) = *(PixColors + 1);
#line 583
    *(PixColors + 28) = *(PixColors + 1);
  } else {
    {
#line 588
    xcol___0.pixel = *(PixColors + 25);
#line 589
    XQueryColor(Xdisplay, Xcmap, & xcol___0);
#line 591
    xcol___0.red = (unsigned short )((int )xcol___0.red / 2);
#line 592
    xcol___0.green = (unsigned short )((int )xcol___0.green / 2);
#line 593
    xcol___0.blue = (unsigned short )((int )xcol___0.blue / 2);
#line 595
    tmp___5 = XAllocColor(Xdisplay, Xcmap, & xcol___0);
    }
#line 595
    if (! tmp___5) {
      {
#line 596
      print_error("can\'t allocate %s", "Color_bottomShadow");
#line 597
      xcol___0.pixel = *(PixColors + 2);
      }
    }
    {
#line 599
    *(PixColors + 28) = xcol___0.pixel;
#line 603
    white.blue = (unsigned short )(~ 0);
#line 603
    white.green = white.blue;
#line 603
    white.red = white.green;
#line 604
    XAllocColor(Xdisplay, Xcmap, & white);
#line 611
    xcol___0.pixel = *(PixColors + 25);
#line 612
    XQueryColor(Xdisplay, Xcmap, & xcol___0);
    }
#line 614
    if ((int )white.red / 5 > (int )xcol___0.red) {
#line 614
      xcol___0.red = (unsigned short )((int )white.red / 5);
    } else {
#line 614
      xcol___0.red = (unsigned short )((int )xcol___0.red);
    }
#line 615
    if ((int )white.green / 5 > (int )xcol___0.green) {
#line 615
      xcol___0.green = (unsigned short )((int )white.green / 5);
    } else {
#line 615
      xcol___0.green = (unsigned short )((int )xcol___0.green);
    }
#line 616
    if ((int )white.blue / 5 > (int )xcol___0.blue) {
#line 616
      xcol___0.blue = (unsigned short )((int )white.blue / 5);
    } else {
#line 616
      xcol___0.blue = (unsigned short )((int )xcol___0.blue);
    }
#line 618
    if ((int )white.red < ((int )xcol___0.red * 7) / 5) {
#line 618
      xcol___0.red = (unsigned short )((int )white.red);
    } else {
#line 618
      xcol___0.red = (unsigned short )(((int )xcol___0.red * 7) / 5);
    }
#line 619
    if ((int )white.green < ((int )xcol___0.green * 7) / 5) {
#line 619
      xcol___0.green = (unsigned short )((int )white.green);
    } else {
#line 619
      xcol___0.green = (unsigned short )(((int )xcol___0.green * 7) / 5);
    }
#line 620
    if ((int )white.blue < ((int )xcol___0.blue * 7) / 5) {
#line 620
      xcol___0.blue = (unsigned short )((int )white.blue);
    } else {
#line 620
      xcol___0.blue = (unsigned short )(((int )xcol___0.blue * 7) / 5);
    }
    {
#line 622
    tmp___6 = XAllocColor(Xdisplay, Xcmap, & xcol___0);
    }
#line 622
    if (! tmp___6) {
      {
#line 623
      print_error("can\'t allocate %s", "Color_topShadow");
#line 624
      xcol___0.pixel = *(PixColors + 17);
      }
    }
#line 626
    *(PixColors + 27) = xcol___0.pixel;
  }
#line 630
  if (Options & (1UL << 7)) {
#line 630
    tmp___7 = 17 + 2 * sb_shadow;
  } else {
#line 630
    tmp___7 = 0;
  }
#line 630
  szHint.base_width = 2 * TermWin_internalBorder + tmp___7;
#line 633
  szHint.base_height = 2 * TermWin_internalBorder;
#line 635
  if (rs_geometry) {
    {
#line 635
    tmp___8 = XParseGeometry(rs_geometry, & x, & y, & width, & height);
#line 635
    flags = tmp___8;
    }
  } else {
#line 635
    flags = 0;
  }
#line 638
  if (flags & 4) {
#line 639
    szHint.width = (int )width;
#line 640
    szHint.flags |= 1L << 1;
  }
#line 642
  if (flags & 8) {
#line 643
    szHint.height = (int )height;
#line 644
    szHint.flags |= 1L << 1;
  }
  {
#line 647
  set_terminal_size((unsigned int )szHint.width, (unsigned int )szHint.height);
#line 649
  change_font(1, (char const   *)((void *)0));
  }
#line 652
  if (delay_menu_drawing) {
#line 652
    tmp___9 = 0;
  } else {
#line 652
    tmp___9 = 0;
  }
#line 652
  szHint.base_height += tmp___9;
#line 655
  if (flags & 1) {
#line 656
    if (flags & 16) {
#line 657
      x += (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->width - (szHint.width + TermWin_internalBorder);
#line 659
      szHint.win_gravity = 3;
    }
#line 661
    szHint.x = x;
#line 662
    szHint.flags |= 1L;
  }
#line 664
  if (flags & 2) {
#line 665
    if (flags & 32) {
#line 666
      y += (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->height - (szHint.height + TermWin_internalBorder);
#line 668
      if (szHint.win_gravity == 3) {
#line 668
        szHint.win_gravity = 9;
      } else {
#line 668
        szHint.win_gravity = 7;
      }
    }
#line 671
    szHint.y = y;
#line 672
    szHint.flags |= 1L;
  }
#line 677
  attributes.background_pixel = *(PixColors + 1);
#line 678
  attributes.border_pixel = *(PixColors + 0);
#line 679
  attributes.event_mask = (((1L | (1L << 21)) | (1L << 17)) | (1L << 16)) | (1L << 22);
#line 684
  attributes.colormap = Xcmap;
#line 685
  attributes.background_pixmap = (Pixmap )1L;
#line 686
  attr_mask = (unsigned long )((1L << 3) | (1L << 11));
#line 692
  if (Options & (1UL << 13)) {
#line 693
    attr_mask |= 1UL;
  }
#line 695
  if ((attr_mask & 1UL) == 0UL) {
#line 696
    attr_mask |= (unsigned long )(1L << 1);
  }
  {
#line 708
  attr_mask |= (unsigned long )(1L << 13);
#line 709
  TermWin.parent = XCreateWindow(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                 szHint.x, szHint.y, (unsigned int )szHint.width,
                                 (unsigned int )szHint.height, (unsigned int )TermWin.borderWidth,
                                 Xdepth, 1U, Xvisual, attr_mask, & attributes);
#line 718
  TermWin.bMapped = 0;
#line 719
  ParentWin[0] = TermWin.parent;
#line 720
  ParentWinNum = 1;
#line 722
  xterm_seq(2, rs_title);
#line 723
  xterm_seq(1, rs_iconName);
#line 725
  classHint.res_name = (char *)rs_name;
#line 726
  classHint.res_class = (char *)"XTerm";
#line 727
  wmHint.input = 1;
  }
#line 728
  if (Options & (1UL << 2)) {
#line 728
    wmHint.initial_state = 3;
  } else {
#line 728
    wmHint.initial_state = 1;
  }
  {
#line 729
  wmHint.window_group = TermWin.parent;
#line 730
  wmHint.flags = (1L | (1L << 1)) | (1L << 6);
#line 732
  XSetWMProperties(Xdisplay, TermWin.parent, (XTextProperty *)((void *)0), (XTextProperty *)((void *)0),
                   argv, argc, & szHint, & wmHint, & classHint);
#line 737
  tmp___10 = getpid();
#line 737
  ldata = (long )tmp___10;
#line 738
  XChangeProperty(Xdisplay, TermWin.parent, _XA_NET_WM_PID, (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(& ldata)),
                  1);
  }
#line 743
  if (mwmhints.flags) {
#line 743
    if (_XA_MwmAtom) {
      {
#line 744
      XChangeProperty(Xdisplay, TermWin.parent, _XA_MwmAtom, _XA_MwmAtom, 32, 0, (unsigned char const   *)((unsigned char *)(& mwmhints)),
                      5);
      }
    }
  }
  {
#line 749
  TermWin_cursor = XCreateFontCursor(Xdisplay, 152U);
#line 753
  fg.pixel = *(PixColors + 20);
#line 754
  XQueryColor(Xdisplay, Xcmap, & fg);
#line 755
  bg.pixel = *(PixColors + 1);
#line 756
  XQueryColor(Xdisplay, Xcmap, & bg);
#line 757
  XRecolorCursor(Xdisplay, TermWin_cursor, & fg, & bg);
#line 761
  cursor = XCreateFontCursor(Xdisplay, 68U);
#line 762
  attributes.event_mask = ((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 8)) | (1L << 10);
#line 767
  attributes.cursor = TermWin_cursor;
#line 778
  TermWin.vt = XCreateSimpleWindow(Xdisplay, TermWin.parent, 0, 0, (unsigned int )szHint.width,
                                   (unsigned int )szHint.height, 0U, *(PixColors + 0),
                                   *(PixColors + 1));
#line 784
  XSelectInput(Xdisplay, TermWin.vt, attributes.event_mask);
#line 785
  XDefineCursor(Xdisplay, TermWin.vt, TermWin_cursor);
  }
#line 790
  if (Options & (1UL << 13)) {
#line 791
    if ((unsigned int )TermWin.background.trgType != 10U) {
      {
#line 792
      tmp___11 = GetRootPixmap((Atom )0L);
#line 792
      SetSrcPixmap(tmp___11);
      }
    } else {
      {
#line 794
      XSetWindowBackgroundPixmap(Xdisplay, TermWin.vt, (Pixmap )1L);
      }
    }
  }
#line 800
  if (Options & (1UL << 13)) {
    {
#line 802
    XSelectInput(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                 1L << 22);
    }
  } else
#line 800
  if (Options & (1UL << 14)) {
    {
#line 802
    XSelectInput(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                 1L << 22);
    }
  }
  {
#line 816
  scrollBar.win = XCreateSimpleWindow(Xdisplay, TermWin.parent, 0, 0, 1U, 1U, 0U,
                                      *(PixColors + 0), *(PixColors + 1));
#line 824
  XDefineCursor(Xdisplay, scrollBar.win, cursor);
#line 825
  XSelectInput(Xdisplay, scrollBar.win, (((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 8)) | (1L << 9)) | (1L << 10));
#line 831
  create_menuBar(cursor);
#line 844
  gcvalue.font = (TermWin.font)->fid;
#line 845
  gcvalue.foreground = *(PixColors + 0);
#line 846
  gcvalue.background = *(PixColors + 1);
#line 847
  gcvalue.function = ParseGCType(rs_textType, 3);
#line 848
  gcvalue.graphics_exposures = 0;
#line 856
  TermWin.gc = XCreateGC(Xdisplay, TermWin.vt, (unsigned long )((((1L | (1L << 2)) | (1L << 3)) | (1L << 14)) | (1L << 16)),
                         & gcvalue);
  }
#line 863
  if (rs_color[22]) {
#line 865
    if (rs_tintType) {
      {
#line 867
      tmp___12 = strcmp(rs_tintType, "true");
      }
#line 867
      if (tmp___12 == 0) {
#line 869
        TermWin.tintGC = (GC )0L;
#line 870
        if ((unsigned int )TermWin.background.trgType == 10U) {
#line 871
          TermWin.background.trgType = (enum __anonenum_trgType_164 )9;
        }
      }
    }
#line 875
    if ((unsigned int )TermWin.background.trgType == 10U) {
      {
#line 877
      gcvalue.function = ParseGCType(rs_tintType, 1);
#line 878
      gcvalue.foreground = *(PixColors + 22);
#line 884
      TermWin.tintGC = XCreateGC(Xdisplay, TermWin.vt, (unsigned long )((1L | (1L << 2)) | (1L << 16)),
                                 & gcvalue);
      }
    }
  }
#line 892
  return;
}
}
#line 896 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int resize_subwindows(int width , int height ) 
{ 
  int x ;
  int y ;
  int old_width ;
  int old_height ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 899
  x = 0;
#line 899
  y = 0;
#line 900
  old_width = (int )TermWin.width;
#line 901
  old_height = (int )TermWin.height;
#line 903
  TermWin.width = (R_u_int16_t )((int )TermWin.ncol * (int )TermWin.fwidth);
#line 904
  TermWin.height = (R_u_int16_t )((int )TermWin.nrow * (int )TermWin.fheight);
#line 907
  if (scrollBar.state) {
    {
#line 908
    scrollBar.beg = (short)0;
#line 909
    scrollBar.end = (short )height;
#line 913
    tmp = GetScrollArrowsHeight();
#line 913
    scrollBar.end = (short )((unsigned int )scrollBar.end - tmp);
#line 921
    width -= 17 + 2 * sb_shadow;
    }
#line 922
    if (Options & (1UL << 8)) {
      {
#line 923
      XMoveResizeWindow(Xdisplay, scrollBar.win, width, 0, (unsigned int )(17 + 2 * sb_shadow),
                        (unsigned int )height);
      }
    } else {
      {
#line 926
      XMoveResizeWindow(Xdisplay, scrollBar.win, 0, 0, (unsigned int )(17 + 2 * sb_shadow),
                        (unsigned int )height);
#line 928
      x = 17 + 2 * sb_shadow;
      }
    }
  }
  {
#line 937
  XMoveResizeWindow(Xdisplay, TermWin.vt, x, y, (unsigned int )width, (unsigned int )(height + 1));
#line 939
  request_background_update();
  }
#line 941
  if (old_width) {
    {
#line 942
    Gr_Resize(old_width, old_height);
    }
  }
  {
#line 944
  XSync(Xdisplay, 0);
  }
#line 945
  if (width != old_width) {
#line 945
    tmp___0 = 1;
  } else
#line 945
  if (height != old_height) {
#line 945
    tmp___0 = 1;
  } else {
#line 945
    tmp___0 = 0;
  }
#line 945
  return (tmp___0);
}
}
#line 949 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void resize(void) 
{ 
  int tmp ;

  {
#line 952
  szHint.base_width = 2 * TermWin_internalBorder;
#line 953
  szHint.base_height = 2 * TermWin_internalBorder;
#line 955
  if (scrollBar.state) {
#line 955
    tmp = 17 + 2 * sb_shadow;
  } else {
#line 955
    tmp = 0;
  }
  {
#line 955
  szHint.base_width += tmp;
#line 957
  szHint.base_height = szHint.base_height;
#line 960
  szHint.min_width = szHint.base_width + szHint.width_inc;
#line 961
  szHint.min_height = szHint.base_height + szHint.height_inc;
#line 963
  szHint.width = szHint.base_width + (int )TermWin.width;
#line 964
  szHint.height = szHint.base_height + (int )TermWin.height;
#line 966
  szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
#line 968
  XSetWMNormalHints(Xdisplay, TermWin.parent, & szHint);
#line 969
  XResizeWindow(Xdisplay, TermWin.parent, (unsigned int )szHint.width, (unsigned int )szHint.height);
#line 971
  resize_subwindows(szHint.width, szHint.height);
#line 972
  scr_clear_tint(1);
  }
#line 974
  return;
}
}
#line 983 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static short first_time  =    (short)1;
#line 980 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void resize_window1(unsigned int width , unsigned int height ) 
{ 
  int new_ncol ;
  int new_nrow ;
  int curr_screen ;

  {
#line 984
  new_ncol = (int )((width - (unsigned int )szHint.base_width) / (unsigned int )TermWin.fwidth);
#line 985
  new_nrow = (int )((height - (unsigned int )szHint.base_height) / (unsigned int )TermWin.fheight);
#line 987
  if (first_time) {
#line 987
    goto _L;
  } else
#line 987
  if (new_ncol != (int )TermWin.ncol) {
#line 987
    goto _L;
  } else
#line 987
  if (new_nrow != (int )TermWin.nrow) {
    _L: /* CIL Label */ 
#line 990
    curr_screen = -1;
#line 993
    if (! first_time) {
      {
#line 994
      selection_clear();
#line 995
      curr_screen = scr_change_screen(0);
      }
    }
    {
#line 998
    set_terminal_size((unsigned int )new_ncol, (unsigned int )new_nrow);
#line 1000
    resize_subwindows((int )width, (int )height);
#line 1001
    scr_reset();
    }
#line 1003
    if (curr_screen >= 0) {
      {
#line 1004
      scr_change_screen(curr_screen);
      }
    }
#line 1005
    first_time = (short)0;
  }
#line 1007
  return;
}
}
#line 1013 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_width(unsigned short width ) 
{ 
  unsigned short height ;

  {
#line 1016
  height = TermWin.nrow;
#line 1018
  if ((int )width != (int )TermWin.ncol) {
    {
#line 1019
    width = (unsigned short )(szHint.base_width + (int )width * (int )TermWin.fwidth);
#line 1020
    height = (unsigned short )(szHint.base_height + (int )height * (int )TermWin.fheight);
#line 1022
    XResizeWindow(Xdisplay, TermWin.parent, (unsigned int )width, (unsigned int )height);
#line 1023
    resize_window1((unsigned int )width, (unsigned int )height);
#line 1027
    scr_clear_tint(1);
    }
  }
#line 1029
  return;
}
}
#line 1035 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void resize_window(XEvent *ev ) 
{ 
  int root_x ;
  int root_y ;
  Window wdumm ;
  XConfigureEvent *xconf ;
  int tmp ;
  int cancel ;
  int request ;
  int tmp___0 ;

  {
#line 1038
  root_x = 0;
#line 1038
  root_y = 0;
#line 1040
  xconf = & ev->xconfigure;
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1042
    tmp = XCheckTypedWindowEvent(Xdisplay, TermWin.parent, 22, ev);
    }
#line 1042
    if (! tmp) {
#line 1042
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1044
  resize_window1((unsigned int )xconf->width, (unsigned int )xconf->height);
#line 1046
  XTranslateCoordinates(Xdisplay, TermWin.parent, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                        0, 0, & root_x, & root_y, & wdumm);
#line 1049
  TermWin.root_x = root_x;
#line 1050
  TermWin.root_y = root_y;
#line 1051
  TermWin.root_width = xconf->width;
#line 1052
  TermWin.root_height = xconf->height;
#line 1054
  tmp___0 = TransparentPixmapNeedsUpdate();
  }
#line 1054
  if (tmp___0) {
    {
#line 1055
    request_background_update();
    }
  } else {
#line 1058
    cancel = 1;
#line 1059
    request = 0;
#line 1083
    if (cancel) {
      {
#line 1084
      cancel_background_update();
      }
    } else
#line 1085
    if (request) {
      {
#line 1086
      request_background_update();
      }
    }
  }
  {
#line 1166
  scr_clear_tint(1);
#line 1167
  scr_touch();
  }
#line 1169
  return;
}
}
#line 1174 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_title(char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1179
  tmp = XFetchName(Xdisplay, TermWin.parent, & name);
  }
#line 1179
  if (tmp) {
#line 1180
    name = (char *)((void *)0);
  }
#line 1181
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1182
    XStoreName(Xdisplay, TermWin.parent, str);
    }
  } else {
    {
#line 1181
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 1181
    if (tmp___0) {
      {
#line 1182
      XStoreName(Xdisplay, TermWin.parent, str);
      }
    }
  }
#line 1183
  if (name) {
    {
#line 1184
    XFree((void *)name);
    }
  }
#line 1185
  return;
}
}
#line 1192 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_iconName(char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1197
  tmp = XGetIconName(Xdisplay, TermWin.parent, & name);
  }
#line 1197
  if (tmp) {
#line 1198
    name = (char *)((void *)0);
  }
#line 1199
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1200
    XSetIconName(Xdisplay, TermWin.parent, str);
    }
  } else {
    {
#line 1199
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 1199
    if (tmp___0) {
      {
#line 1200
      XSetIconName(Xdisplay, TermWin.parent, str);
      }
    }
  }
#line 1201
  if (name) {
    {
#line 1202
    XFree((void *)name);
    }
  }
#line 1203
  return;
}
}
#line 1210 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void set_window_color(int idx , char const   *color ) 
{ 
  char const   *msg ;
  XColor xcol ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1213
  msg = "can\'t load color \"%s\"";
#line 1217
  if ((unsigned long )color == (unsigned long )((void *)0)) {
#line 1218
    return;
  } else
#line 1217
  if ((int const   )*color == 0) {
#line 1218
    return;
  }
  {
#line 1221
  tmp = __ctype_b_loc();
  }
#line 1221
  if ((int const   )*(*tmp + (int )*color) & 2048) {
    {
#line 1222
    i = atoi(color);
    }
#line 1223
    if (i >= 8) {
#line 1223
      if (i <= 15) {
#line 1224
        i -= 8;
#line 1226
        PixColorsFocused[idx] = PixColorsFocused[10 + i];
#line 1227
        goto Done;
      }
    }
#line 1230
    if (i >= 0) {
#line 1230
      if (i <= 7) {
#line 1231
        PixColorsFocused[idx] = PixColorsFocused[2 + i];
#line 1232
        goto Done;
      }
    }
  }
  {
#line 1235
  tmp___0 = XParseColor(Xdisplay, Xcmap, color, & xcol);
  }
#line 1235
  if (tmp___0) {
    {
#line 1235
    tmp___1 = XAllocColor(Xdisplay, Xcmap, & xcol);
    }
#line 1235
    if (! tmp___1) {
      {
#line 1237
      print_error(msg, color);
      }
#line 1238
      return;
    }
  } else {
    {
#line 1237
    print_error(msg, color);
    }
#line 1238
    return;
  }
#line 1257
  PixColorsFocused[idx] = xcol.pixel;
  Done: 
  {
#line 1263
  PixColorsUnFocused[idx] = fade_color(PixColorsFocused[idx]);
#line 1265
  on_colors_changed(idx);
  }
#line 1266
  return;
}
}
#line 1291 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void xterm_seq(int op , char const   *str ) 
{ 
  int color ;
  char *buf___0 ;
  char *name ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1297
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 1297
    __assert_fail("str != ((void *)0)", "/home/june/collector/temp/aterm-1.0.1/src/main.c",
                  1297U, "xterm_seq");
    }
  }
  {
#line 1299
  if (op == 0) {
#line 1299
    goto case_0;
  }
#line 1301
  if (op == 1) {
#line 1301
    goto case_1;
  }
#line 1304
  if (op == 2) {
#line 1304
    goto case_2;
  }
#line 1307
  if (op == 4) {
#line 1307
    goto case_4;
  }
#line 1321
  if (op == 12) {
#line 1321
    goto case_12;
  }
#line 1325
  if (op == 13) {
#line 1325
    goto case_13;
  }
#line 1329
  if (op == 18) {
#line 1329
    goto case_18;
  }
#line 1332
  if (op == 19) {
#line 1332
    goto case_19;
  }
#line 1337
  if (op == 6) {
#line 1337
    goto case_6;
  }
#line 1343
  if (op == 10) {
#line 1343
    goto case_10;
  }
#line 1349
  if (op == 20) {
#line 1349
    goto case_20;
  }
#line 1356
  if (op == 39) {
#line 1356
    goto case_39;
  }
#line 1359
  if (op == 49) {
#line 1359
    goto case_49;
  }
#line 1362
  if (op == 46) {
#line 1362
    goto case_46;
  }
#line 1364
  if (op == 50) {
#line 1364
    goto case_50;
  }
#line 1298
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1300
  set_title(str);
  }
  case_1: /* CIL Label */ 
  {
#line 1302
  set_iconName(str);
  }
#line 1303
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1305
  set_title(str);
  }
#line 1306
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1308
  buf___0 = (char *)str;
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1308
    if (buf___0) {
#line 1308
      if (! *buf___0) {
#line 1308
        goto while_break;
      }
    } else {
#line 1308
      goto while_break;
    }
    {
#line 1309
    name = strchr((char const   *)buf___0, ';');
    }
#line 1309
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1310
      goto while_break;
    }
    {
#line 1311
    tmp = name;
#line 1311
    name ++;
#line 1311
    *tmp = (char )'\000';
#line 1312
    color = atoi((char const   *)buf___0);
    }
#line 1313
    if (color < 0) {
#line 1314
      goto while_break;
    } else
#line 1313
    if (color >= 29) {
#line 1314
      goto while_break;
    }
    {
#line 1315
    buf___0 = strchr((char const   *)name, ';');
    }
#line 1315
    if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
#line 1316
      tmp___0 = buf___0;
#line 1316
      buf___0 ++;
#line 1316
      *tmp___0 = (char )'\000';
    }
    {
#line 1317
    set_window_color(color + 2, (char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1319
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1322
  set_window_color(18, str);
  }
#line 1323
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1326
  set_window_color(20, str);
  }
#line 1327
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1330
  set_window_color(23, str);
  }
#line 1331
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1333
  set_window_color(24, str);
  }
#line 1334
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1338
  op = atoi(str);
#line 1339
  tmp___1 = strchr(str, ';');
#line 1339
  str = (char const   *)tmp___1;
  }
#line 1339
  if (! str) {
#line 1340
    goto switch_break;
  }
  {
#line 1341
  eterm_seq(op, str + 1);
  }
#line 1342
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1348
  goto switch_break;
  case_20: /* CIL Label */ 
#line 1354
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 1357
  set_window_color(0, str);
  }
#line 1358
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 1360
  set_window_color(1, str);
  }
#line 1361
  goto switch_break;
  case_46: /* CIL Label */ 
#line 1363
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 1365
  change_font(0, str);
  }
#line 1366
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1368
  return;
}
}
#line 1376 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void eterm_seq(int op , char const   *str ) 
{ 
  char *class ;
  char *value ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1379
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 1379
    __assert_fail("str != ((void *)0)", "/home/june/collector/temp/aterm-1.0.1/src/main.c",
                  1379U, "eterm_seq");
    }
  }
  {
#line 1382
  if (op == 2) {
#line 1382
    goto case_2;
  }
#line 1380
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1384
  tmp___2 = strncmp(str, "tint", (size_t )4);
  }
#line 1384
  if (tmp___2 == 0) {
    {
#line 1388
    class = strchr((char const   *)((char *)str), ';');
    }
#line 1388
    if (! class) {
#line 1389
      goto switch_break;
    }
    {
#line 1390
    tmp = class;
#line 1390
    class ++;
#line 1390
    *tmp = (char )'\000';
#line 1391
    value = strchr((char const   *)class, ';');
    }
#line 1391
    if (value) {
#line 1396
      tmp___0 = value;
#line 1396
      value ++;
#line 1396
      *tmp___0 = (char )'\000';
    } else {
#line 1393
      value = class;
#line 1394
      class = (char *)"bg";
    }
    {
#line 1398
    tmp___1 = strcmp((char const   *)class, "bg");
    }
#line 1398
    if (tmp___1 == 0) {
      {
#line 1399
      set_window_color(22, (char const   *)value);
      }
    }
  }
#line 1402
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1405
  return;
}
}
#line 1409 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
unsigned int get_proportion_font_width(XFontStruct *font ) 
{ 
  int i ;
  int cw ;
  unsigned int fw ;

  {
#line 1412
  fw = 0U;
#line 1413
  if ((unsigned long )font != (unsigned long )((void *)0)) {
#line 1415
    i = (int )(font->max_char_or_byte2 - font->min_char_or_byte2);
    {
#line 1415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1415
      if (! (i >= 0)) {
#line 1415
        goto while_break;
      }
#line 1419
      cw = (int )(font->per_char + i)->width;
#line 1420
      if (cw > 0) {
#line 1421
        if ((unsigned int )cw > fw) {
#line 1421
          fw = (unsigned int )cw;
        }
      }
#line 1415
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1424
  return (fw);
}
}
#line 1439 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char *newfont[5]  ;
#line 1442 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static XFontStruct *boldFont  =    (XFontStruct *)((void *)0);
#line 1445 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static int fnum  =    2;
#line 1434 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void change_font(int init , char const   *fontname ) 
{ 
  char const   *msg ;
  XFontStruct *xfont ;
  int idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *name ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int fh ;
  int fw ;
  unsigned int tmp___10 ;
  int fh___0 ;
  int fw___0 ;
  unsigned int tmp___11 ;
  int tmp___12 ;

  {
#line 1437
  msg = "can\'t load font \"%s\"";
#line 1446
  idx = 0;
#line 1459
  if (! init) {
    {
#line 1461
    if ((int const   )*(fontname + 0) == 0) {
#line 1461
      goto case_0;
    }
#line 1467
    if ((int const   )*(fontname + 0) == 35) {
#line 1467
      goto case_35;
    }
#line 1491
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 1462
    fnum = 2;
#line 1463
    fontname = (char const   *)((void *)0);
#line 1464
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 1468
    idx = atoi(fontname + 1);
    }
    {
#line 1470
    if ((int const   )*(fontname + 1) == 43) {
#line 1470
      goto case_43;
    }
#line 1475
    if ((int const   )*(fontname + 1) == 45) {
#line 1475
      goto case_45;
    }
#line 1480
    goto switch_default;
    case_43: /* CIL Label */ 
#line 1471
    if (idx) {
#line 1471
      tmp = idx;
    } else {
#line 1471
      tmp = 1;
    }
#line 1471
    fnum += tmp;
#line 1472
    if (fnum < 0) {
#line 1472
      fnum = 4;
    } else {
#line 1472
      if (fnum >= 5) {
#line 1472
        tmp___0 = 0;
      } else {
#line 1472
        tmp___0 = fnum;
      }
#line 1472
      fnum = tmp___0;
    }
#line 1473
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 1476
    if (idx) {
#line 1476
      tmp___1 = idx;
    } else {
#line 1476
      tmp___1 = -1;
    }
#line 1476
    fnum += tmp___1;
#line 1477
    if (fnum < 0) {
#line 1477
      fnum = 4;
    } else {
#line 1477
      if (fnum >= 5) {
#line 1477
        tmp___2 = 0;
      } else {
#line 1477
        tmp___2 = fnum;
      }
#line 1477
      fnum = tmp___2;
    }
#line 1478
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1481
    if ((int const   )*(fontname + 1) != 0) {
      {
#line 1481
      tmp___3 = __ctype_b_loc();
      }
#line 1481
      if (! ((int const   )*(*tmp___3 + (int )*(fontname + 1)) & 2048)) {
#line 1482
        return;
      }
    }
#line 1483
    if (idx < 0) {
#line 1484
      return;
    } else
#line 1483
    if (idx >= 5) {
#line 1484
      return;
    }
#line 1485
    if (idx == 0) {
#line 1485
      fnum = 2;
    } else {
#line 1485
      if (idx <= 2) {
#line 1485
        tmp___4 = idx - 1;
      } else {
#line 1485
        tmp___4 = idx;
      }
#line 1485
      fnum = tmp___4;
    }
#line 1486
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1488
    fontname = (char const   *)((void *)0);
#line 1489
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1492
    if ((unsigned long )fontname != (unsigned long )((void *)0)) {
#line 1494
      idx = 0;
      {
#line 1494
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1494
        if (! (idx < 5)) {
#line 1494
          goto while_break;
        }
        {
#line 1495
        tmp___6 = strcmp(rs_font[idx], fontname);
        }
#line 1495
        if (! tmp___6) {
#line 1496
          if (idx == 0) {
#line 1496
            fnum = 2;
          } else {
#line 1496
            if (idx <= 2) {
#line 1496
              tmp___5 = idx - 1;
            } else {
#line 1496
              tmp___5 = idx;
            }
#line 1496
            fnum = tmp___5;
          }
#line 1497
          fontname = (char const   *)((void *)0);
#line 1498
          goto while_break;
        }
#line 1494
        idx ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1502
      return;
    }
#line 1503
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1506
    if (fnum == 2) {
#line 1506
      idx = 0;
    } else {
#line 1506
      if (fnum < 2) {
#line 1506
        tmp___7 = fnum + 1;
      } else {
#line 1506
        tmp___7 = fnum;
      }
#line 1506
      idx = tmp___7;
    }
#line 1508
    if ((unsigned long )fontname != (unsigned long )((void *)0)) {
      {
#line 1511
      xfont = XLoadQueryFont(Xdisplay, fontname);
      }
#line 1512
      if (! xfont) {
#line 1513
        return;
      }
      {
#line 1515
      tmp___8 = strlen(fontname + 1);
#line 1515
      tmp___9 = malloc(tmp___8 * sizeof(char ));
#line 1515
      name = (char *)tmp___9;
      }
#line 1517
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 1518
        XFreeFont(Xdisplay, xfont);
        }
#line 1519
        return;
      }
      {
#line 1521
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)((char *)fontname));
      }
#line 1522
      if ((unsigned long )newfont[idx] != (unsigned long )((void *)0)) {
        {
#line 1523
        free((void *)newfont[idx]);
        }
      }
#line 1524
      newfont[idx] = name;
#line 1525
      rs_font[idx] = (char const   *)newfont[idx];
    }
  }
#line 1528
  if (TermWin.font) {
    {
#line 1529
    XFreeFont(Xdisplay, TermWin.font);
    }
  }
  {
#line 1532
  xfont = XLoadQueryFont(Xdisplay, rs_font[idx]);
  }
#line 1533
  if (! xfont) {
    {
#line 1534
    print_error(msg, rs_font[idx]);
#line 1535
    rs_font[idx] = "fixed";
#line 1536
    xfont = XLoadQueryFont(Xdisplay, rs_font[idx]);
    }
#line 1537
    if (! xfont) {
      {
#line 1538
      print_error(msg, rs_font[idx]);
      }
#line 1539
      goto Abort;
    }
  }
#line 1542
  TermWin.font = xfont;
#line 1546
  if (init) {
#line 1546
    if ((unsigned long )rs_boldFont != (unsigned long )((void *)0)) {
      {
#line 1547
      boldFont = XLoadQueryFont(Xdisplay, rs_boldFont);
      }
    }
  }
#line 1569
  if (! init) {
    {
#line 1570
    XSetFont(Xdisplay, TermWin.gc, (TermWin.font)->fid);
#line 1571
    menubar_expose();
    }
  }
#line 1575
  fw = 0;
#line 1577
  fw = (int )(TermWin.font)->min_bounds.width;
#line 1578
  if (fw > 1000) {
#line 1578
    fw = 0;
  }
#line 1583
  fh = (TermWin.font)->ascent + (TermWin.font)->descent;
#line 1586
  if ((int )(TermWin.font)->min_bounds.width == (int )(TermWin.font)->max_bounds.width) {
#line 1587
    TermWin.fprop = (R_u_int16_t )0;
  } else {
#line 1589
    TermWin.fprop = (R_u_int16_t )1;
  }
#line 1591
  if ((int )TermWin.fprop == 1) {
    {
#line 1592
    tmp___10 = get_proportion_font_width(TermWin.font);
#line 1592
    fw = (int )tmp___10;
    }
  }
#line 1594
  if (fw == (int )TermWin.fwidth) {
#line 1594
    if (fh == (int )TermWin.fheight) {
#line 1595
      return;
    }
  }
#line 1597
  TermWin.fwidth = (R_u_int16_t )fw;
#line 1598
  TermWin.fheight = (R_u_int16_t )fh;
#line 1603
  TermWin.boldFont = (XFontStruct *)((void *)0);
#line 1604
  if ((unsigned long )boldFont != (unsigned long )((void *)0)) {
#line 1605
    fw___0 = 0;
#line 1607
    fw___0 = (int )boldFont->min_bounds.width;
#line 1608
    if (fw___0 > 1000) {
#line 1608
      fw___0 = 0;
    }
#line 1610
    fh___0 = boldFont->ascent + boldFont->descent;
#line 1611
    if ((int )TermWin.fprop == 0) {
#line 1612
      if (fw___0 != (int )boldFont->max_bounds.width) {
#line 1613
        fw___0 = -1;
      }
    } else {
      {
#line 1615
      tmp___11 = get_proportion_font_width(boldFont);
#line 1615
      fw___0 = (int )tmp___11;
      }
    }
#line 1617
    if (fw___0 == (int )TermWin.fwidth) {
#line 1617
      if (fh___0 == (int )TermWin.fheight) {
#line 1618
        TermWin.boldFont = boldFont;
      }
    }
  }
  {
#line 1624
  set_colorfgbg();
#line 1626
  TermWin.width = (R_u_int16_t )((int )TermWin.ncol * (int )TermWin.fwidth);
#line 1627
  TermWin.height = (R_u_int16_t )((int )TermWin.nrow * (int )TermWin.fheight);
#line 1629
  szHint.width_inc = (int )TermWin.fwidth;
#line 1630
  szHint.height_inc = (int )TermWin.fheight;
#line 1632
  szHint.min_width = szHint.base_width + szHint.width_inc;
#line 1633
  szHint.min_height = szHint.base_height + szHint.height_inc;
#line 1635
  szHint.width = szHint.base_width + (int )TermWin.width;
#line 1636
  szHint.height = szHint.base_height + (int )TermWin.height;
  }
#line 1638
  if (delay_menu_drawing) {
#line 1638
    tmp___12 = 0;
  } else {
#line 1638
    tmp___12 = 0;
  }
#line 1638
  szHint.height += tmp___12;
#line 1641
  szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
#line 1643
  if (! init) {
    {
#line 1644
    resize();
    }
  }
#line 1646
  return;
  Abort: 
  {
#line 1648
  print_error("aborting");
#line 1649
  exit(1);
  }
}
}
#line 1830 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int read_32bit_property(Window w , Atom property , CARD32 *trg ) 
{ 
  int res ;
  Atom actual_type ;
  int actual_format ;
  unsigned long bytes_after ;
  union __anonunion_data_337 data ;
  unsigned long nitems ;
  int tmp ;
  int tmp___0 ;

  {
#line 1833
  res = 0;
#line 1835
  if (w != 0UL) {
#line 1835
    if (property != 0UL) {
#line 1835
      if (trg) {
        {
#line 1847
        data.long_ptr = (long *)((void *)0);
#line 1848
        tmp = XGetWindowProperty(Xdisplay, w, property, 0L, 1L, 0, (Atom )0L, & actual_type,
                                 & actual_format, & nitems, & bytes_after, & data.uc_ptr);
#line 1848
        res = tmp == 0;
        }
#line 1854
        if (res) {
#line 1854
          if (nitems > 0UL) {
#line 1854
            if (actual_format == 32) {
#line 1854
              tmp___0 = 1;
            } else {
#line 1854
              tmp___0 = 0;
            }
          } else {
#line 1854
            tmp___0 = 0;
          }
        } else {
#line 1854
          tmp___0 = 0;
        }
#line 1854
        res = tmp___0;
#line 1856
        if (res) {
#line 1857
          *(trg + 0) = (CARD32 )*(data.long_ptr + 0);
        }
#line 1858
        if (data.long_ptr) {
#line 1858
          if (nitems > 0UL) {
            {
#line 1859
            XFree((void *)data.long_ptr);
            }
          }
        }
      }
    }
  }
#line 1861
  return (res);
}
}
#line 1865 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int read_32bit_proplist(Window w , Atom property , long estimate , CARD32 **list ,
                        long *nitems ) 
{ 
  int res ;
  Atom actual_type ;
  int actual_format ;
  unsigned long bytes_after ;
  unsigned long unitems ;
  union __anonunion_buffer_338 buffer___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  register int i ;
  register CARD32 *data32 ;
  void *tmp___3 ;

  {
#line 1868
  res = 0;
#line 1871
  if (w != 0UL) {
#line 1871
    if (property != 0UL) {
#line 1871
      if (list) {
#line 1871
        if (nitems) {
#line 1876
          unitems = 0UL;
#line 1883
          buffer___0.long_ptr = (long *)((void *)0);
#line 1884
          if (estimate <= 0L) {
#line 1885
            estimate = 1L;
          }
          {
#line 1886
          tmp = XGetWindowProperty(Xdisplay, w, property, 0L, estimate, 0, (Atom )0L,
                                   & actual_type, & actual_format, & unitems, & bytes_after,
                                   & buffer___0.uc_ptr);
#line 1886
          res = tmp == 0;
          }
#line 1891
          if (res) {
#line 1891
            if (unitems > 0UL) {
#line 1891
              if (actual_format == 32) {
#line 1891
                tmp___0 = 1;
              } else {
#line 1891
                tmp___0 = 0;
              }
            } else {
#line 1891
              tmp___0 = 0;
            }
          } else {
#line 1891
            tmp___0 = 0;
          }
#line 1891
          res = tmp___0;
#line 1893
          if (bytes_after > 0UL) {
#line 1893
            if (res) {
              {
#line 1895
              XFree((void *)buffer___0.long_ptr);
#line 1896
              tmp___1 = XGetWindowProperty(Xdisplay, w, property, 0L, (long )((unsigned long )estimate + (bytes_after >> 2)),
                                           0, actual_type, & actual_type, & actual_format,
                                           & unitems, & bytes_after, & buffer___0.uc_ptr);
#line 1896
              res = tmp___1 == 0;
              }
#line 1900
              if (res) {
#line 1900
                if (unitems > 0UL) {
#line 1900
                  tmp___2 = 1;
                } else {
#line 1900
                  tmp___2 = 0;
                }
              } else {
#line 1900
                tmp___2 = 0;
              }
#line 1900
              res = tmp___2;
            }
          }
#line 1903
          if (! res) {
#line 1905
            *nitems = 0L;
#line 1906
            *list = (CARD32 *)((void *)0);
          } else {
            {
#line 1909
            i = (int )unitems;
#line 1910
            tmp___3 = malloc(unitems * sizeof(CARD32 ));
#line 1910
            data32 = (CARD32 *)tmp___3;
            }
            {
#line 1911
            while (1) {
              while_continue: /* CIL Label */ ;
#line 1911
              i --;
#line 1911
              if (! (i >= 0)) {
#line 1911
                goto while_break;
              }
#line 1912
              *(data32 + i) = (CARD32 )*(buffer___0.long_ptr + i);
            }
            while_break: /* CIL Label */ ;
            }
#line 1913
            *list = data32;
#line 1914
            *nitems = (long )unitems;
          }
#line 1916
          if (buffer___0.long_ptr) {
            {
#line 1917
            XFree((void *)buffer___0.long_ptr);
            }
          }
        }
      }
    }
  }
#line 1920
  return (res);
}
}
#line 1926 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int check_extended_wm_state(void) 
{ 
  CARD32 *items ;
  long nitems ;
  unsigned long new_state ;
  int changed ;
  int i ;
  int tmp ;

  {
  {
#line 1930
  nitems = 0L;
#line 1931
  new_state = 0UL;
#line 1932
  changed = 0;
#line 1934
  tmp = read_32bit_proplist(TermWin.parent, _XA_NET_WM_STATE, 6L, & items, & nitems);
  }
#line 1934
  if (tmp) {
#line 1937
    i = 0;
    {
#line 1937
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1937
      if (! ((long )i < nitems)) {
#line 1937
        goto while_break;
      }
#line 1939
      if ((Atom )*(items + i) == _XA_NET_WM_STATE_STICKY) {
#line 1940
        new_state |= (unsigned long )(1 << 1);
      } else
#line 1941
      if ((Atom )*(items + i) == _XA_NET_WM_STATE_SHADED) {
#line 1942
        new_state |= (unsigned long )(1 << 2);
      } else
#line 1943
      if ((Atom )*(items + i) == _XA_NET_WM_STATE_HIDDEN) {
#line 1944
        new_state |= (unsigned long )(1 << 3);
      }
#line 1937
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1946
    free((void *)items);
#line 1947
    changed = (ExtWM.flags & (unsigned long )(((1 << 1) | (1 << 2)) | (1 << 3))) != new_state;
#line 1948
    ExtWM.flags &= (unsigned long )(~ (((1 << 1) | (1 << 2)) | (1 << 3)));
#line 1949
    ExtWM.flags |= new_state;
    }
  } else {
#line 1952
    changed = (int )(ExtWM.flags & (unsigned long )(((1 << 1) | (1 << 2)) | (1 << 3)));
#line 1953
    ExtWM.flags &= (unsigned long )(~ (((1 << 1) | (1 << 2)) | (1 << 3)));
  }
#line 1956
  return (changed);
}
}
#line 1960 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
void check_extended_wm_hints_support(void) 
{ 
  Window w ;
  CARD32 *supported_props ;
  long nitems ;
  int curr_desk ;
  int app_desk ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1963
  memset((void *)(& ExtWM), 0, sizeof(ExtWM));
#line 1965
  tmp___2 = read_32bit_property((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                _XA_NET_SUPPORTING_WM_CHECK, (CARD32 *)(& ExtWM.supporting_wm_check));
  }
#line 1965
  if (tmp___2) {
#line 1966
    if (ExtWM.supporting_wm_check != 0UL) {
      {
#line 1969
      tmp___1 = read_32bit_property(ExtWM.supporting_wm_check, _XA_NET_SUPPORTING_WM_CHECK,
                                    (CARD32 *)(& w));
      }
#line 1969
      if (tmp___1) {
#line 1971
        if (w != ExtWM.supporting_wm_check) {
#line 1972
          ExtWM.supporting_wm_check = (Window )0L;
        } else {
          {
#line 1975
          supported_props = (CARD32 *)((void *)0);
#line 1976
          nitems = 0L;
#line 1977
          curr_desk = 0;
#line 1978
          app_desk = 0;
#line 1979
          tmp = read_32bit_proplist((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                    _XA_NET_SUPPORTED, 20L, & supported_props, & nitems);
          }
#line 1979
          if (tmp) {
#line 1982
            i = 0;
            {
#line 1982
            while (1) {
              while_continue: /* CIL Label */ ;
#line 1982
              if (! ((long )i < nitems)) {
#line 1982
                goto while_break;
              }
#line 1984
              if ((Atom )*(supported_props + i) == _XA_NET_CURRENT_DESKTOP) {
#line 1985
                curr_desk = 1;
              } else
#line 1986
              if ((Atom )*(supported_props + i) == _XA_NET_WM_DESKTOP) {
#line 1987
                app_desk = 1;
              }
#line 1982
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
          }
#line 1990
          if (curr_desk) {
#line 1990
            if (app_desk) {
              {
#line 1992
              ExtWM.flags |= (unsigned long )(1 << 4);
#line 1993
              tmp___0 = read_32bit_property((((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                                            _XA_NET_CURRENT_DESKTOP, & ExtWM.current_desktop);
              }
#line 1993
              if (tmp___0) {
#line 1994
                ExtWM.flags |= 1UL;
              }
            }
          }
        }
      } else {
#line 1970
        ExtWM.supporting_wm_check = (Window )0L;
      }
    }
  }
#line 1999
  return;
}
}
#line 2012 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char windowid_string[20]  ;
#line 2012 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char *display_string  ;
#line 2012 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
static char *term_string  ;
#line 2005 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int t ;
  char *val ;
  char **cmd_argv ;
  int saved_argc ;
  char **saved_argv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  XVisualInfo vinfo ;
  int tmp___3 ;
  char const   *name ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 2009
  cmd_argv = (char **)((void *)0);
#line 2015
  saved_argc = argc;
#line 2016
  tmp = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 2016
  saved_argv = (char **)tmp;
#line 2018
  PixColors = & PixColorsFocused[0];
#line 2020
  i = 0;
  }
  {
#line 2020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2020
    if (! (i < argc)) {
#line 2020
      goto while_break;
    }
#line 2021
    *(saved_argv + i) = *(argv + i);
#line 2020
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2022
  *(saved_argv + i) = (char *)((void *)0);
#line 2023
  i = 0;
  {
#line 2023
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2023
    if (! (i < argc)) {
#line 2023
      goto while_break___0;
    }
    {
#line 2024
    tmp___0 = strcmp((char const   *)*(argv + i), "-e");
    }
#line 2024
    if (tmp___0) {
      {
#line 2024
      tmp___1 = strcmp((char const   *)*(argv + i), "-exec");
      }
#line 2024
      if (! tmp___1) {
        _L: /* CIL Label */ 
#line 2025
        argc = i;
#line 2026
        *(argv + argc) = (char *)((void *)0);
#line 2027
        if ((unsigned long )*(argv + (argc + 1)) != (unsigned long )((void *)0)) {
#line 2028
          cmd_argv = (argv + argc) + 1;
        }
#line 2029
        goto while_break___0;
      }
    } else {
#line 2024
      goto _L;
    }
#line 2023
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2040
  privileges('s');
#line 2041
  privileges(0);
#line 2043
  Options = (1UL << 7) | (1UL << 11);
#line 2044
  Xdisplay = (Display *)((void *)0);
#line 2045
  display_name = (char const   *)((void *)0);
#line 2046
  rs_term_name = (char const   *)((void *)0);
#line 2047
  rs_cutchars = (char const   *)((void *)0);
#line 2049
  rs_boldFont = (char const   *)((void *)0);
#line 2054
  rs_title = (char const   *)((void *)0);
#line 2055
  rs_iconName = (char const   *)((void *)0);
#line 2056
  rs_geometry = (char const   *)((void *)0);
#line 2057
  rs_minBufferWidth = (char const   *)((void *)0);
#line 2058
  rs_saveLines = (char const   *)((void *)0);
#line 2062
  rs_borderWidth = (char const   *)((void *)0);
#line 2063
  rs_internal_border = (char const   *)((void *)0);
#line 2064
  rs_modifier = (char const   *)((void *)0);
#line 2071
  rs_menu = (char const   *)((void *)0);
#line 2072
  rs_path = (char const   *)((void *)0);
#line 2078
  rs_backgroundType = (char const   *)((void *)0);
#line 2079
  rs_shade = (char const   *)((void *)0);
#line 2080
  rs_tintType = (char const   *)((void *)0);
#line 2085
  rs_backspace_key = (char const   *)((void *)0);
#line 2088
  rs_delete_key = (char const   *)((void *)0);
#line 2091
  colorfgbg = (unsigned int )(1 << 5);
#line 2094
  rs_name = my_basename((char const   *)*(argv + 0));
  }
#line 2095
  if ((unsigned long )cmd_argv != (unsigned long )((void *)0)) {
#line 2095
    if ((unsigned long )*(cmd_argv + 0) != (unsigned long )((void *)0)) {
      {
#line 2096
      rs_title = my_basename((char const   *)*(cmd_argv + 0));
#line 2096
      rs_iconName = rs_title;
      }
    }
  }
  {
#line 2101
  get_options(argc, argv);
  }
#line 2103
  if ((unsigned long )display_name == (unsigned long )((void *)0)) {
    {
#line 2104
    tmp___2 = getenv("DISPLAY");
#line 2104
    display_name = (char const   *)tmp___2;
    }
#line 2104
    if ((unsigned long )display_name == (unsigned long )((void *)0)) {
#line 2105
      display_name = ":0";
    }
  }
  {
#line 2145
  Xdisplay = XOpenDisplay(display_name);
  }
#line 2147
  if (! Xdisplay) {
    {
#line 2148
    print_error("can\'t open display %s", display_name);
#line 2149
    exit(1);
    }
  }
  {
#line 2152
  _XA_MwmAtom = XInternAtom(Xdisplay, "_MOTIF_WM_HINTS", 1);
#line 2153
  _XA_NET_WM_PID = XInternAtom(Xdisplay, "_NET_WM_PID", 0);
#line 2154
  _XROOTPMAP_ID = XInternAtom(Xdisplay, "_XROOTPMAP_ID", 0);
#line 2155
  _XA_NET_SUPPORTING_WM_CHECK = XInternAtom(Xdisplay, "_NET_SUPPORTING_WM_CHECK",
                                            0);
#line 2156
  _XA_NET_SUPPORTED = XInternAtom(Xdisplay, "_NET_SUPPORTED", 0);
#line 2157
  _XA_NET_CURRENT_DESKTOP = XInternAtom(Xdisplay, "_NET_CURRENT_DESKTOP", 0);
#line 2158
  _XA_NET_WM_DESKTOP = XInternAtom(Xdisplay, "_NET_WM_DESKTOP", 0);
#line 2159
  _XA_NET_WM_STATE = XInternAtom(Xdisplay, "_XA_NET_WM_STATE", 0);
#line 2160
  _XA_NET_WM_STATE_STICKY = XInternAtom(Xdisplay, "_XA_NET_WM_STATE_STICKY", 0);
#line 2161
  _XA_NET_WM_STATE_SHADED = XInternAtom(Xdisplay, "_XA_NET_WM_STATE_SHADED", 0);
#line 2162
  _XA_NET_WM_STATE_HIDDEN = XInternAtom(Xdisplay, "_XA_NET_WM_STATE_HIDDEN", 0);
#line 2164
  Xdepth = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_depth;
#line 2165
  Xcmap = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->cmap;
#line 2166
  Xvisual = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root_visual;
#line 2167
  XdisplayWidth = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->width;
#line 2168
  XdisplayHeight = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->height;
  }
#line 2179
  if (Xdepth != 24) {
    {
#line 2182
    tmp___3 = XMatchVisualInfo(Xdisplay, ((_XPrivDisplay )Xdisplay)->default_screen,
                               24, 4, & vinfo);
    }
#line 2182
    if (tmp___3) {
      {
#line 2184
      Xdepth = 24;
#line 2185
      Xvisual = vinfo.visual;
#line 2186
      Xcmap = XCreateColormap(Xdisplay, (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->root,
                              Xvisual, 0);
      }
    }
  }
  {
#line 2195
  aterm_XA_TARGETS = XInternAtom(Xdisplay, "TARGETS", 0);
#line 2196
  _XA_COMPAUND_TEXT = XInternAtom(Xdisplay, "COMPOUND_TEXT", 0);
#line 2197
  aterm_XA_TEXT = XInternAtom(Xdisplay, "TEXT", 0);
#line 2198
  aterm_XA_UTF8_STRING = XInternAtom(Xdisplay, "UTF8_STRING", 0);
#line 2199
  aterm_XA_CLIPBOARD = XInternAtom(Xdisplay, "CLIPBOARD", 0);
#line 2200
  aterm_XA_VT_SELECTION = XInternAtom(Xdisplay, "VT_SELECTION", 0);
#line 2201
  aterm_XA_INCR = XInternAtom(Xdisplay, "INCR", 0);
#line 2203
  check_extended_wm_hints_support();
#line 2209
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))(& xerror_handler));
#line 2212
  extract_resources(Xdisplay, rs_name);
#line 2216
  InitBackground();
  }
#line 2246
  if (rs_shade) {
    {
#line 2247
    TermWin.background.Shading.shading = atoi(rs_shade);
    }
  }
  {
#line 2248
  SetBackgroundType(rs_backgroundType);
#line 2252
  sb_shadow = 0;
  }
#line 2261
  if (! rs_title) {
#line 2262
    rs_title = rs_name;
  }
#line 2263
  if (! rs_iconName) {
#line 2264
    rs_iconName = rs_title;
  }
#line 2266
  if (! rs_minBufferWidth) {
#line 2267
    TermWin.min_bcol = (R_u_int16_t )1;
  } else {
    {
#line 2266
    t = atoi(rs_minBufferWidth);
    }
#line 2266
    if (t < 0) {
#line 2267
      TermWin.min_bcol = (R_u_int16_t )1;
    } else {
#line 2269
      TermWin.min_bcol = (R_u_int16_t )t;
    }
  }
#line 2271
  if (! rs_saveLines) {
#line 2272
    TermWin.saveLines = (R_u_int16_t )512;
  } else {
    {
#line 2271
    t = atoi(rs_saveLines);
    }
#line 2271
    if (t < 0) {
#line 2272
      TermWin.saveLines = (R_u_int16_t )512;
    } else {
#line 2274
      TermWin.saveLines = (R_u_int16_t )t;
    }
  }
#line 2280
  if (! rs_borderWidth) {
#line 2281
    TermWin.borderWidth = (R_u_int16_t )1;
  } else {
    {
#line 2280
    t = atoi(rs_borderWidth);
    }
#line 2280
    if (t < 0) {
#line 2281
      TermWin.borderWidth = (R_u_int16_t )1;
    } else {
#line 2283
      TermWin.borderWidth = (R_u_int16_t )t;
    }
  }
#line 2285
  if (! rs_internal_border) {
#line 2286
    TermWin_internalBorder = 2;
  } else {
    {
#line 2285
    t = atoi(rs_internal_border);
    }
#line 2285
    if (t < 0) {
#line 2286
      TermWin_internalBorder = 2;
    } else {
#line 2288
      TermWin_internalBorder = t;
    }
  }
#line 2289
  TermWin_internalBorders = 2 * TermWin_internalBorder;
#line 2292
  if (! TermWin.saveLines) {
#line 2293
    Options &= ~ (1UL << 7);
  }
#line 2299
  if (! rs_cutchars) {
#line 2300
    rs_cutchars = "\"&\'()*,;<=>?@[\\]^`{|}~";
  }
#line 2302
  if (! rs_backspace_key) {
#line 2306
    rs_backspace_key = "DEC";
  } else {
    {
#line 2309
    Str_escaped((char *)rs_backspace_key);
    }
  }
#line 2312
  if (! rs_delete_key) {
#line 2316
    rs_delete_key = "\033[3~";
  } else {
    {
#line 2319
    Str_escaped((char *)rs_delete_key);
    }
  }
#line 2322
  if ((unsigned long )rs_font[0] == (unsigned long )((void *)0)) {
#line 2322
    if ((unsigned long )rs_boldFont != (unsigned long )((void *)0)) {
#line 2323
      rs_font[0] = rs_boldFont;
#line 2324
      rs_boldFont = (char const   *)((void *)0);
    }
  }
#line 2327
  i = 0;
  {
#line 2327
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2327
    if (! (i < 5)) {
#line 2327
      goto while_break___1;
    }
#line 2328
    if (! rs_font[i]) {
#line 2329
      rs_font[i] = def_fontName[i];
    }
#line 2327
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2349
  i = 0;
  {
#line 2349
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2349
    if (! (i < 27)) {
#line 2349
      goto while_break___2;
    }
#line 2350
    if (! rs_color[i]) {
#line 2351
      rs_color[i] = def_colorName[i];
    }
#line 2349
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2355
  if (Options & (1UL << 5)) {
#line 2360
    name = rs_color[0];
#line 2361
    rs_color[0] = rs_color[1];
#line 2362
    rs_color[1] = name;
#line 2364
    name = def_colorName[0];
#line 2365
    def_colorName[0] = def_colorName[1];
#line 2366
    def_colorName[1] = name;
  }
  {
#line 2371
  color_aliases(0);
#line 2372
  color_aliases(1);
#line 2374
  color_aliases(18);
#line 2375
  color_aliases(19);
#line 2377
  color_aliases(20);
#line 2378
  color_aliases(21);
#line 2380
  color_aliases(23);
#line 2381
  color_aliases(24);
#line 2386
  delay_menu_drawing = 1;
#line 2387
  menubar_read(rs_menu);
#line 2388
  delay_menu_drawing --;
#line 2391
  Create_Windows(saved_argc, saved_argv);
#line 2392
  scr_reset();
#line 2393
  Gr_reset();
#line 2396
  scrollbar_mapping((int )(Options & (1UL << 7)));
  }
#line 2399
  if (delay_menu_drawing) {
    {
#line 2400
    delay_menu_drawing = 0;
#line 2401
    menubar_mapping(1);
    }
  }
  {
#line 2405
  XMapWindow(Xdisplay, TermWin.vt);
#line 2406
  XMapWindow(Xdisplay, TermWin.parent);
#line 2434
  val = XDisplayString(Xdisplay);
  }
#line 2435
  if ((unsigned long )display_name == (unsigned long )((void *)0)) {
#line 2436
    display_name = (char const   *)val;
  }
  {
#line 2438
  tmp___4 = strlen((char const   *)val);
#line 2438
  i = (int )tmp___4;
#line 2439
  tmp___5 = malloc((unsigned long )(i + 9) * sizeof(char ));
#line 2439
  display_string = (char *)tmp___5;
#line 2441
  sprintf((char */* __restrict  */)display_string, (char const   */* __restrict  */)"DISPLAY=%s",
          val);
#line 2442
  sprintf((char */* __restrict  */)(windowid_string), (char const   */* __restrict  */)"WINDOWID=%u",
          (unsigned int )TermWin.parent);
#line 2450
  putenv(display_string);
#line 2451
  putenv(windowid_string);
  }
#line 2458
  if (Xdepth <= 2) {
    {
#line 2459
    putenv((char *)"COLORTERM=rxvt-mono");
    }
  } else {
    {
#line 2461
    putenv((char *)"COLORTERM=rxvt");
    }
  }
#line 2462
  if ((unsigned long )rs_term_name != (unsigned long )((void *)0)) {
    {
#line 2463
    tmp___6 = strlen(rs_term_name);
#line 2463
    i = (int )tmp___6;
#line 2464
    tmp___7 = malloc((unsigned long )(i + 6) * sizeof(char ));
#line 2464
    term_string = (char *)tmp___7;
#line 2466
    sprintf((char */* __restrict  */)term_string, (char const   */* __restrict  */)"TERM=%s",
            rs_term_name);
#line 2467
    putenv(term_string);
    }
  } else {
    {
#line 2469
    putenv((char *)"TERM=rxvt");
    }
  }
  {
#line 2472
  tmp___8 = setlocale(0, "");
  }
#line 2472
  if (! tmp___8) {
    {
#line 2472
    print_error("Cannot set locale");
    }
  }
  {
#line 2474
  init_command(cmd_argv);
#line 2476
  main_loop();
  }
#line 2477
  return (0);
}
}
#line 2481 "/home/june/collector/temp/aterm-1.0.1/src/main.c"
int trace_XGetGeometry(char *file , int line , Display *dpy , Window w , Window *r ,
                       int *x , int *y , unsigned int *width , unsigned int *height ,
                       unsigned int *bw , unsigned int *depth ) 
{ 
  int res ;

  {
  {
#line 2485
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(%d):XGetGeometry(%lX) = ",
          file, line, w);
#line 2486
  res = XGetGeometry(dpy, w, r, x, y, width, height, bw, depth);
#line 2487
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%ux%u%+d%+d),%d\n",
          *width, *height, *x, *y, res);
  }
#line 2488
  return (res);
}
}
#line 1616 "/usr/include/X11/Xlib.h"
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 2373
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 3172
extern int XSetClipMask(Display * , GC  , Pixmap  ) ;
#line 3178
extern int XSetClipOrigin(Display * , GC  , int  , int  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 37 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static GC paintGC  =    (GC )0L;
#line 38 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static GC grayGC  =    (GC )0L;
#line 39 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static GC stippleGC  =    (GC )0L;
#line 40 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static Pixel blackPixel  ;
#line 40 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static Pixel whitePixel  ;
#line 40 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static Pixel darkPixel  ;
#line 42 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static char *SCROLLER_DIMPLE[6]  = {      (char *)".%###.",      (char *)"%#%%%%",      (char *)"#%%...",      (char *)"#%..  ", 
        (char *)"#%.   ",      (char *)".%.  ."};
#line 56 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static char *SCROLLER_ARROW_UP[13]  = 
#line 56
  {      (char *)".............",      (char *)".............",      (char *)"......%......",      (char *)"......#......", 
        (char *)".....%#%.....",      (char *)".....###.....",      (char *)"....%###%....",      (char *)"....#####....", 
        (char *)"...%#####%...",      (char *)"...#######...",      (char *)"..%#######%..",      (char *)".............", 
        (char *)"............."};
#line 72 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static char *SCROLLER_ARROW_DOWN[13]  = 
#line 72
  {      (char *)".............",      (char *)".............",      (char *)"..%#######%..",      (char *)"...#######...", 
        (char *)"...%#####%...",      (char *)"....#####....",      (char *)"....%###%....",      (char *)".....###.....", 
        (char *)".....%#%.....",      (char *)"......#......",      (char *)"......%......",      (char *)".............", 
        (char *)"............."};
#line 89 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static char *HI_SCROLLER_ARROW_UP[13]  = 
#line 89
  {      (char *)"             ",      (char *)"             ",      (char *)"      %      ",      (char *)"      %      ", 
        (char *)"     %%%     ",      (char *)"     %%%     ",      (char *)"    %%%%%    ",      (char *)"    %%%%%    ", 
        (char *)"   %%%%%%%   ",      (char *)"   %%%%%%%   ",      (char *)"  %%%%%%%%%  ",      (char *)"             ", 
        (char *)"             "};
#line 105 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static char *HI_SCROLLER_ARROW_DOWN[13]  = 
#line 105
  {      (char *)"             ",      (char *)"             ",      (char *)"  %%%%%%%%%  ",      (char *)"   %%%%%%%   ", 
        (char *)"   %%%%%%%   ",      (char *)"    %%%%%    ",      (char *)"    %%%%%    ",      (char *)"     %%%     ", 
        (char *)"     %%%     ",      (char *)"      %      ",      (char *)"      %      ",      (char *)"             ", 
        (char *)"             "};
#line 137 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static Icon dimple  =    {(Pixmap )0L, (Pixmap )0L, 0, 0, 6, 6};
#line 140 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static ScrollArrows NeXTScrollArrows  =    {13U, 13U, 0, {SCROLLER_ARROW_UP, HI_SCROLLER_ARROW_UP, SCROLLER_ARROW_DOWN, HI_SCROLLER_ARROW_DOWN},
    {{0UL, 0UL, 0, 0, 0, 0}, {0UL, 0UL, 0, 0, 0, 0}, {0UL, 0UL, 0, 0, 0, 0}, {0UL,
                                                                              0UL,
                                                                              0, 0,
                                                                              0, 0}}};
#line 177 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static unsigned char stp_bits[8]  = 
#line 177
  {      (unsigned char)85,      (unsigned char)170,      (unsigned char)85,      (unsigned char)170, 
        (unsigned char)85,      (unsigned char)170,      (unsigned char)85,      (unsigned char)170};
#line 195 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void init_scroll_size(void) 
{ 


  {
#line 198
  NeXTScrollArrows.arrow_width = (unsigned int )(14 - (1 << 1));
#line 199
  if (13U < NeXTScrollArrows.arrow_width) {
#line 199
    NeXTScrollArrows.arrow_width = 13U;
  }
#line 202
  NeXTScrollArrows.arrow_height = NeXTScrollArrows.arrow_width;
#line 206
  NeXTScrollArrows.bValid = 1;
#line 207
  return;
}
}
#line 210 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
unsigned int GetScrollArrowsHeight(void) 
{ 


  {
#line 213
  if (! NeXTScrollArrows.bValid) {
    {
#line 213
    init_scroll_size();
    }
  }
#line 214
  return ((3U + NeXTScrollArrows.arrow_height) << 1);
}
}
#line 217 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void CheckIconGC(IconGC *igc , Pixmap icon , Pixmap icon_mask ) 
{ 
  XGCValues values ;
  unsigned long valuemask ;

  {
#line 221
  valuemask = (unsigned long )((1L << 2) | (1L << 16));
#line 223
  values.graphics_exposures = 0;
#line 225
  if ((unsigned long )igc == (unsigned long )((void *)0)) {
#line 225
    return;
  }
#line 226
  if ((unsigned long )igc->maskGC == (unsigned long )((GC )0)) {
    {
#line 228
    values.foreground = 1UL;
#line 229
    igc->maskGC = XCreateGC(Xdisplay, icon_mask, valuemask, & values);
    }
  }
#line 231
  if ((unsigned long )igc->maskGC_0 == (unsigned long )((GC )0)) {
    {
#line 233
    values.foreground = 0UL;
#line 234
    igc->maskGC_0 = XCreateGC(Xdisplay, icon_mask, valuemask, & values);
    }
  }
#line 236
  if ((unsigned long )igc->whiteGC == (unsigned long )((GC )0)) {
    {
#line 238
    values.foreground = whitePixel;
#line 239
    igc->whiteGC = XCreateGC(Xdisplay, icon, valuemask, & values);
    }
  }
#line 241
  if ((unsigned long )igc->darkGC == (unsigned long )((GC )0)) {
    {
#line 243
    values.foreground = darkPixel;
#line 244
    igc->darkGC = XCreateGC(Xdisplay, icon, valuemask, & values);
    }
  }
#line 246
  if ((unsigned long )igc->blackGC == (unsigned long )((GC )0)) {
    {
#line 248
    values.foreground = blackPixel;
#line 249
    igc->blackGC = XCreateGC(Xdisplay, icon, valuemask, & values);
    }
  }
#line 251
  return;
}
}
#line 253 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void FreeIconGC(IconGC *igc ) 
{ 


  {
#line 256
  if (igc) {
#line 258
    if ((unsigned long )igc->maskGC != (unsigned long )((GC )0)) {
      {
#line 260
      XFreeGC(Xdisplay, igc->maskGC);
#line 261
      igc->maskGC = (GC )0L;
      }
    }
#line 263
    if ((unsigned long )igc->maskGC_0 != (unsigned long )((GC )0)) {
      {
#line 265
      XFreeGC(Xdisplay, igc->maskGC_0);
#line 266
      igc->maskGC_0 = (GC )0L;
      }
    }
#line 268
    if ((unsigned long )igc->whiteGC == (unsigned long )((GC )0)) {
      {
#line 270
      XFreeGC(Xdisplay, igc->whiteGC);
#line 271
      igc->whiteGC = (GC )0L;
      }
    }
#line 273
    if ((unsigned long )igc->darkGC == (unsigned long )((GC )0)) {
      {
#line 275
      XFreeGC(Xdisplay, igc->darkGC);
#line 276
      igc->darkGC = (GC )0L;
      }
    }
#line 278
    if ((unsigned long )igc->blackGC != (unsigned long )((GC )0)) {
      {
#line 280
      XFreeGC(Xdisplay, igc->blackGC);
#line 281
      igc->blackGC = (GC )0L;
      }
    }
  }
#line 284
  return;
}
}
#line 286 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void renderIcon(char **data , Icon *pIcon , IconGC *igc ) 
{ 
  Pixmap d ;
  Pixmap mask ;
  register int i ;
  register int k ;
  int x ;
  int y ;
  GC maskgc ;
  GC paintgc ;

  {
  {
#line 294
  d = XCreatePixmap(Xdisplay, scrollBar.win, (unsigned int )pIcon->width, (unsigned int )pIcon->height,
                    (unsigned int )Xdepth);
#line 295
  mask = XCreatePixmap(Xdisplay, scrollBar.win, (unsigned int )pIcon->width, (unsigned int )pIcon->height,
                       1U);
#line 297
  CheckIconGC(igc, d, mask);
#line 298
  y = pIcon->origin_y;
#line 300
  i = 0;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < pIcon->height)) {
#line 300
      goto while_break;
    }
#line 301
    x = pIcon->origin_x;
#line 302
    k = 0;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (k < pIcon->width)) {
#line 302
        goto while_break___0;
      }
#line 303
      maskgc = igc->maskGC;
      {
#line 306
      if ((int )*(*(data + y) + x) == 119) {
#line 306
        goto case_119;
      }
#line 306
      if ((int )*(*(data + y) + x) == 32) {
#line 306
        goto case_119;
      }
#line 308
      if ((int )*(*(data + y) + x) == 100) {
#line 308
        goto case_100;
      }
#line 308
      if ((int )*(*(data + y) + x) == 37) {
#line 308
        goto case_100;
      }
#line 310
      if ((int )*(*(data + y) + x) == 98) {
#line 310
        goto case_98;
      }
#line 310
      if ((int )*(*(data + y) + x) == 35) {
#line 310
        goto case_98;
      }
#line 313
      goto switch_default;
      case_119: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 306
      paintgc = igc->whiteGC;
#line 306
      goto switch_break;
      case_100: /* CIL Label */ 
      case_37: /* CIL Label */ 
#line 308
      paintgc = igc->darkGC;
#line 308
      goto switch_break;
      case_98: /* CIL Label */ 
      case_35: /* CIL Label */ 
#line 310
      paintgc = igc->blackGC;
#line 310
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 313
      paintgc = grayGC;
#line 314
      maskgc = igc->maskGC_0;
#line 315
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 317
      XDrawPoint(Xdisplay, d, paintgc, k, i);
#line 318
      XDrawPoint(Xdisplay, mask, maskgc, k, i);
#line 302
      k ++;
#line 302
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    y ++;
#line 300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  pIcon->icon = d;
#line 323
  pIcon->icon_mask = mask;
#line 324
  return;
}
}
#line 326 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void PlaceIcon(Icon *i , int x , int y , Drawable buffer___0 ) 
{ 


  {
#line 330
  if (Options & (1UL << 14)) {
    {
#line 332
    XSetClipMask(Xdisplay, paintGC, i->icon_mask);
#line 333
    XSetClipOrigin(Xdisplay, paintGC, x, y);
    }
  }
  {
#line 336
  XCopyArea(Xdisplay, i->icon, buffer___0, paintGC, 0, 0, (unsigned int )i->width,
            (unsigned int )i->height, x, y);
  }
#line 339
  return;
}
}
#line 341 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void init_stuff(void) 
{ 
  XGCValues gcvalue ;
  XColor xcol ;
  Pixmap stipple ;
  unsigned long light ;
  unsigned int arrow_x_offset ;
  unsigned int arrow_y_offset ;
  IconGC icongc ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 349
  icongc.blackGC = (GC )0L;
#line 349
  icongc.whiteGC = (GC )0L;
#line 349
  icongc.darkGC = (GC )0L;
#line 349
  icongc.maskGC = (GC )0L;
#line 349
  icongc.maskGC_0 = (struct _XGC *)0;
#line 352
  gcvalue.graphics_exposures = 0;
#line 354
  blackPixel = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->black_pixel;
#line 355
  whitePixel = (((_XPrivDisplay )Xdisplay)->screens + ((_XPrivDisplay )Xdisplay)->default_screen)->white_pixel;
#line 357
  xcol.red = (unsigned short)44730;
#line 358
  xcol.green = (unsigned short)43690;
#line 359
  xcol.blue = (unsigned short)44730;
#line 360
  tmp = XAllocColor(Xdisplay, Xcmap, & xcol);
  }
#line 360
  if (! tmp) {
    {
#line 362
    print_error("can\'t allocate %s", "light gray");
#line 364
    xcol.pixel = *(PixColors + 9);
    }
  }
  {
#line 370
  gcvalue.foreground = xcol.pixel;
#line 370
  light = gcvalue.foreground;
#line 371
  grayGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )((1L << 2) | (1L << 16)),
                     & gcvalue);
#line 374
  xcol.red = (unsigned short)20906;
#line 375
  xcol.green = (unsigned short)21845;
#line 376
  xcol.blue = (unsigned short)20804;
#line 377
  tmp___0 = XAllocColor(Xdisplay, Xcmap, & xcol);
  }
#line 377
  if (! tmp___0) {
    {
#line 379
    print_error("can\'t allocate %s", "dark gray");
#line 381
    xcol.pixel = *(PixColors + 10);
    }
  }
  {
#line 388
  darkPixel = xcol.pixel;
#line 390
  renderIcon(SCROLLER_DIMPLE, & dimple, & icongc);
  }
#line 392
  if (! NeXTScrollArrows.bValid) {
    {
#line 392
    init_scroll_size();
    }
  }
#line 394
  arrow_x_offset = (13U - NeXTScrollArrows.arrow_width) >> 1;
#line 396
  arrow_y_offset = arrow_x_offset;
#line 401
  i = 0;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (i < 4)) {
#line 401
      goto while_break;
    }
    {
#line 403
    NeXTScrollArrows.Arrows[i].origin_x = (int )arrow_x_offset;
#line 404
    NeXTScrollArrows.Arrows[i].origin_y = (int )arrow_y_offset;
#line 405
    NeXTScrollArrows.Arrows[i].width = (int )NeXTScrollArrows.arrow_width;
#line 406
    NeXTScrollArrows.Arrows[i].height = (int )NeXTScrollArrows.arrow_height;
#line 407
    renderIcon(NeXTScrollArrows.Data[i], & NeXTScrollArrows.Arrows[i], & icongc);
#line 401
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  FreeIconGC(& icongc);
#line 412
  gcvalue.foreground = whitePixel;
#line 413
  paintGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )((1L << 2) | (1L << 16)),
                      & gcvalue);
#line 416
  stipple = XCreateBitmapFromData(Xdisplay, scrollBar.win, (char const   *)(stp_bits),
                                  8U, 8U);
#line 418
  gcvalue.foreground = darkPixel;
#line 419
  gcvalue.background = light;
#line 420
  gcvalue.fill_style = 2;
#line 421
  gcvalue.stipple = stipple;
#line 423
  stippleGC = XCreateGC(Xdisplay, scrollBar.win, (unsigned long )(((((1L << 2) | (1L << 3)) | (1L << 11)) | (1L << 8)) | (1L << 16)),
                        & gcvalue);
#line 427
  scrollbar_show(1);
  }
#line 428
  return;
}
}
#line 432 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static void drawBevel(Drawable d , int x , int y , int w , int h ) 
{ 


  {
  {
#line 435
  XSetForeground(Xdisplay, paintGC, whitePixel);
#line 436
  XDrawLine(Xdisplay, d, paintGC, x, y, (x + w) - 1, y);
#line 437
  XDrawLine(Xdisplay, d, paintGC, x, y, x, (y + h) - 1);
#line 439
  XSetForeground(Xdisplay, paintGC, blackPixel);
#line 440
  XDrawLine(Xdisplay, d, paintGC, (x + w) - 1, y, (x + w) - 1, (y + h) - 1);
#line 441
  XDrawLine(Xdisplay, d, paintGC, x, (y + h) - 1, (x + w) - 1, (y + h) - 1);
#line 444
  XSetForeground(Xdisplay, paintGC, darkPixel);
#line 445
  XDrawLine(Xdisplay, d, paintGC, x + 1, (y + h) - 2, (x + w) - 2, (y + h) - 2);
#line 446
  XDrawLine(Xdisplay, d, paintGC, (x + w) - 2, y + 1, (x + w) - 2, (y + h) - 2);
  }
#line 448
  return;
}
}
#line 453 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
int scrollbar_mapping(int map ) 
{ 
  int change ;

  {
#line 456
  change = 0;
#line 458
  if (map) {
#line 458
    if (! scrollBar.state) {
      {
#line 459
      scrollBar.state = (short)1;
#line 460
      XMapWindow(Xdisplay, scrollBar.win);
#line 461
      change = 1;
      }
    } else {
#line 458
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 462
  if (! map) {
#line 462
    if (scrollBar.state) {
      {
#line 463
      scrollBar.state = (short)0;
#line 464
      XUnmapWindow(Xdisplay, scrollBar.win);
#line 465
      change = 1;
      }
    }
  }
#line 467
  return (change);
}
}
#line 485
Pixmap scrollbar_fill_back(unsigned int height , int check_cache ) ;
#line 485 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static TransparencyCache tCache  =    {(Pixmap )0L, 4294967295U, 4294967295U, 0U, (Pixmap )0L};
#line 480 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
Pixmap scrollbar_fill_back(unsigned int height , int check_cache ) 
{ 
  Pixmap buffer___0 ;
  Pixmap root_pmap ;
  unsigned int root_width ;
  unsigned int root_height ;
  int cache_valid ;
  int my_x ;
  int my_y ;
  int tmp ;

  {
  {
#line 483
  buffer___0 = (Pixmap )0L;
#line 489
  buffer___0 = XCreatePixmap(Xdisplay, scrollBar.win, 18U, height, (unsigned int )Xdepth);
  }
#line 492
  if (Options & (1UL << 14)) {
#line 492
    if (scrollBar.state) {
#line 494
      root_pmap = (Pixmap )0L;
#line 495
      root_width = 0U;
#line 495
      root_height = 0U;
#line 496
      if (check_cache == 1) {
        {
#line 498
        cache_valid = 0;
#line 499
        root_pmap = ValidatePixmap(root_pmap, 1, 1, & root_width, & root_height);
        }
#line 500
        if (height == tCache.height) {
#line 500
          if (root_pmap == tCache.root) {
            {
#line 503
            tmp = GetWinPosition(scrollBar.win, & my_x, & my_y);
            }
#line 503
            if (tmp) {
#line 505
              if ((unsigned int )my_x == tCache.x) {
#line 505
                if ((unsigned int )my_y == tCache.y) {
#line 505
                  cache_valid = 1;
                } else {
#line 506
                  tCache.x = (unsigned int )my_x;
#line 506
                  tCache.y = (unsigned int )my_y;
                }
              } else {
#line 506
                tCache.x = (unsigned int )my_x;
#line 506
                tCache.y = (unsigned int )my_y;
              }
            } else {
#line 507
              cache_valid = 1;
            }
          } else {
#line 508
            tCache.root = root_pmap;
#line 508
            tCache.height = height;
          }
        } else {
#line 508
          tCache.root = root_pmap;
#line 508
          tCache.height = height;
        }
#line 509
        if (cache_valid == 0) {
#line 511
          if (tCache.cache) {
            {
#line 511
            XFreePixmap(Xdisplay, tCache.cache);
            }
          }
          {
#line 512
          tCache.cache = CutWinPixmap(scrollBar.win, root_pmap, (int )root_width,
                                      (int )root_height, 18, (int )height, grayGC,
                                      & TermWin.background.Shading);
          }
        }
      }
#line 515
      if (tCache.cache != 0UL) {
        {
#line 517
        FillPixmapWithTile(buffer___0, tCache.cache, 0, 0, 18, (int )height, 0, 0);
        }
#line 518
        if (TermWin.tintGC) {
          {
#line 519
          XFillRectangle(Xdisplay, buffer___0, TermWin.tintGC, 0, 0, 17U, height - 1U);
          }
        }
#line 520
        return (buffer___0);
      }
    }
  }
  {
#line 526
  XFillRectangle(Xdisplay, buffer___0, grayGC, 0, 0, 18U, height);
#line 528
  XSetForeground(Xdisplay, paintGC, blackPixel);
#line 529
  XDrawRectangle(Xdisplay, buffer___0, paintGC, 0, 0, 17U, height);
  }
#line 531
  if ((int )TermWin.nscrolled > 0) {
    {
#line 533
    XFillRectangle(Xdisplay, buffer___0, stippleGC, 2, 1, (unsigned int )(17 - (1 << 1)),
                   height - ((3U + NeXTScrollArrows.arrow_height) << 1));
    }
  } else {
    {
#line 539
    XFillRectangle(Xdisplay, buffer___0, stippleGC, 2, 1, (unsigned int )(17 - (1 << 1)),
                   height - (unsigned int )(1 << 1));
    }
  }
#line 544
  return (buffer___0);
}
}
#line 552 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static int last_top  ;
#line 552 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static int last_bot  ;
#line 552 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static int last_len  ;
#line 553 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
static int scrollbar_len  ;
#line 548 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
int scrollbar_show_cached(int update , int check_cache ) 
{ 
  Pixmap buffer___0 ;
  int height ;
  int top ;
  int bot ;
  int len ;
  int tmp ;
  Icon *tmp___0 ;
  Icon *tmp___1 ;

  {
#line 555
  height = (int )(((unsigned int )scrollBar.end + ((3U + NeXTScrollArrows.arrow_height) << 1)) + (unsigned int )sb_shadow);
#line 557
  if ((unsigned long )paintGC == (unsigned long )((GC )0)) {
    {
#line 558
    init_stuff();
    }
  }
#line 560
  if (update) {
#line 562
    top = (int )TermWin.nscrolled - (int )TermWin.view_start;
#line 563
    bot = top + ((int )TermWin.nrow - 1);
#line 564
    if ((int )TermWin.nscrolled + ((int )TermWin.nrow - 1) > 1) {
#line 564
      tmp = (int )TermWin.nscrolled + ((int )TermWin.nrow - 1);
    } else {
#line 564
      tmp = 1;
    }
#line 564
    len = tmp;
#line 567
    scrollBar.top = (short )((int )scrollBar.beg + (top * ((((int )scrollBar.end - (int )scrollBar.beg) - (1 << 1)) - 9)) / len);
#line 569
    scrollBar.bot = (short )(((int )scrollBar.beg + 9) + (bot * ((((int )scrollBar.end - (int )scrollBar.beg) - (1 << 1)) - 9)) / len);
#line 572
    scrollbar_len = (int )scrollBar.bot - (int )scrollBar.top;
#line 574
    if ((int )scrollBar.top == last_top) {
#line 574
      if ((int )scrollBar.bot == last_bot) {
#line 575
        return (0);
      }
    }
  }
  {
#line 579
  last_top = (int )scrollBar.top;
#line 580
  last_bot = (int )scrollBar.bot;
#line 581
  last_len = scrollbar_len;
#line 583
  buffer___0 = scrollbar_fill_back((unsigned int )height, check_cache);
  }
#line 584
  if ((int )TermWin.nscrolled > 0) {
#line 587
    if (! (Options & (1UL << 14))) {
      {
#line 589
      XFillRectangle(Xdisplay, buffer___0, grayGC, 2, ((int )scrollBar.top + 1) + 1,
                     14U, (unsigned int )scrollbar_len);
      }
    }
    {
#line 595
    drawBevel(buffer___0, 2, ((int )scrollBar.top + 1) + 1, 17 - (1 << 1), scrollbar_len);
#line 600
    drawBevel(buffer___0, 2, (int )((((unsigned int )height - ((3U + NeXTScrollArrows.arrow_height) << 1)) + 1U) - 1U),
              17 - (1 << 1), (int )(3U + NeXTScrollArrows.arrow_height));
#line 604
    drawBevel(buffer___0, 2, (int )((((unsigned int )height - (3U + NeXTScrollArrows.arrow_height)) + 1U) - 1U),
              17 - (1 << 1), (int )(3U + NeXTScrollArrows.arrow_height));
#line 609
    PlaceIcon(& dimple, ((17 >> 1) - (6 >> 1)) + 1, (((int )scrollBar.top + 1) + 1) + ((scrollbar_len - 6) >> 1),
              buffer___0);
    }
#line 615
    if ((int )scrollBar.state == 85) {
#line 615
      tmp___0 = & NeXTScrollArrows.Arrows[1];
    } else {
#line 615
      tmp___0 = & NeXTScrollArrows.Arrows[0];
    }
    {
#line 615
    PlaceIcon(tmp___0, (int )(((unsigned int )(17 >> 1) - (NeXTScrollArrows.arrow_width >> 1)) + 1U),
              (int )(((((unsigned int )height - ((3U + NeXTScrollArrows.arrow_height) << 1)) + 1U) + 1U) - 1U),
              buffer___0);
    }
#line 620
    if ((int )scrollBar.state == 68) {
#line 620
      tmp___1 = & NeXTScrollArrows.Arrows[3];
    } else {
#line 620
      tmp___1 = & NeXTScrollArrows.Arrows[2];
    }
    {
#line 620
    PlaceIcon(tmp___1, (int )(((unsigned int )(17 >> 1) - (NeXTScrollArrows.arrow_width >> 1)) + 1U),
              (int )(((((unsigned int )height - (3U + NeXTScrollArrows.arrow_height)) + 1U) + 1U) - 1U),
              buffer___0);
    }
#line 626
    if (Options & (1UL << 14)) {
      {
#line 627
      XSetClipMask(Xdisplay, paintGC, (Pixmap )0L);
      }
    }
  }
#line 632
  if (Options & (1UL << 8)) {
    {
#line 633
    XCopyArea(Xdisplay, buffer___0, scrollBar.win, paintGC, 0, 0, 18U, (unsigned int )height,
              0, 0);
    }
  } else {
    {
#line 636
    XCopyArea(Xdisplay, buffer___0, scrollBar.win, paintGC, 0, 0, 18U, (unsigned int )height,
              -1, 0);
    }
  }
  {
#line 639
  XFreePixmap(Xdisplay, buffer___0);
  }
#line 641
  return (1);
}
}
#line 645 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
int scrollbar_show(int update ) 
{ 
  int tmp ;

  {
  {
#line 648
  tmp = scrollbar_show_cached(update, 0);
  }
#line 648
  return (tmp);
}
}
#line 653 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
void refresh_transparent_scrollbar(void) 
{ 


  {
#line 657
  if (Options & (1UL << 14)) {
    {
#line 657
    scrollbar_show_cached(0, 1);
    }
  }
#line 659
  return;
}
}
#line 663 "/home/june/collector/temp/aterm-1.0.1/src/scrollbar.c"
void map_scrollBar(int map ) 
{ 
  int tmp ;

  {
  {
#line 666
  tmp = scrollbar_mapping(map);
  }
#line 666
  if (tmp) {
    {
#line 667
    resize();
#line 668
    scr_touch();
    }
  }
#line 670
  return;
}
}
