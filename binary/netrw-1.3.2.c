/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 54 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.h"
enum send_mode {
    SM_LATER = 0,
    SM_IMMEDIATELY = 1
} ;
#line 32 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto_types.h"
struct proto_params {
   int checksum ;
   int keepalive ;
};
#line 51 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.h"
enum party {
    PARTY_NETREAD = 1,
    PARTY_NETWRITE = -1
} ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 37 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.h"
enum ip_mode {
    IM_ANY = 0,
    IM_HOST = 1
} ;
#line 42
enum connection_mode {
    CM_READER = 0,
    CM_READER_FW = 1,
    CM_WRITER = 2,
    CM_WRITER_FW = 3
} ;
#line 49
enum transport_protocol {
    TP_UDP = 0,
    TP_TCP = 1
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 10 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.h"
typedef unsigned int word32;
#line 12 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.h"
struct MD5Context {
   word32 buf[4] ;
   word32 bits[2] ;
   unsigned char in[64] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 134 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.h"
void print(int verbose_level , char *msg  , ...) ;
#line 151
char *get_word(char **line ) ;
#line 166
int line_header(char **line , char *header ) ;
#line 183
int strmatch(char const   *s1 , char const   *s2 ) ;
#line 280 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.h"
char *control_read(void) ;
#line 297
int control_write(enum send_mode mode , char *line ) ;
#line 312
int control_writef(enum send_mode mode , char *fmt  , ...) ;
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS[1]  = {      (char *)"md5"};
#line 43 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum_proto.h"
void checksum_proto_param_options(char *options , struct proto_params *req_params___1 ,
                                  struct proto_params *params ) ;
#line 59
void checksum_proto_check(struct proto_params *req_params___1 , struct proto_params *params ) ;
#line 76
int checksum_proto_accept_option(char *option , struct proto_params *req_params___1 ,
                                 struct proto_params *params ) ;
#line 55 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.h"
void keepalive_proto_check(struct proto_params *req_params___1 , struct proto_params *params ) ;
#line 42 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.h"
static char *PARAMS[2]  = {      (char *)"checksum",      (char *)"keepalive"};
#line 69
void params_initialize(struct proto_params *params ) ;
#line 83
void params_clear(struct proto_params *params ) ;
#line 97
int proto_initialize(enum party who ) ;
#line 110
void proto_finalize(void) ;
#line 124
int proto_complete_init(struct proto_params *params ) ;
#line 138
int proto_init_step(struct proto_params *params ) ;
#line 63 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static char str[1024]  ;
#line 64 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static int state  =    0;
#line 67
static void get_params(struct proto_params *params , char *line ) ;
#line 68
static void param_options(int param , char *options , struct proto_params *req_params___1 ,
                          struct proto_params *params ) ;
#line 72
static int accept_option(int param , char *options , struct proto_params *req_params___1 ,
                         struct proto_params *params ) ;
#line 78 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
void params_initialize(struct proto_params *params ) 
{ 


  {
#line 81
  params->checksum = 0;
#line 85
  params->keepalive = 1;
#line 86
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
void params_clear(struct proto_params *params ) 
{ 


  {
#line 90
  if (params->checksum != -1) {
    {
#line 91
    print(1, (char *)"checksum disabled\n");
#line 92
    params->checksum = -1;
    }
  }
#line 95
  params->keepalive = 0;
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
int proto_initialize(enum party who ) 
{ 


  {
#line 100
  if (state != 0) {
    {
#line 102
    print(-2, (char *)"Invalid protocol state in proto_initialize()\n");
    }
#line 103
    return (-1);
  } else
#line 100
  if ((int )who != -1) {
#line 100
    if ((int )who != 1) {
      {
#line 102
      print(-2, (char *)"Invalid protocol state in proto_initialize()\n");
      }
#line 103
      return (-1);
    }
  }
#line 106
  if ((int )who == 1) {
#line 107
    state = 1;
  } else
#line 108
  if ((int )who == -1) {
#line 109
    state = -1;
  }
#line 111
  return (0);
}
}
#line 114 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
void proto_finalize(void) 
{ 


  {
#line 116
  state = 0;
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
int proto_complete_init(struct proto_params *params ) 
{ 
  int tmp ;

  {
#line 121
  if ((unsigned long )params == (unsigned long )((void *)0)) {
#line 122
    return (-1);
  }
#line 124
  if (params->checksum != -1) {
    {
#line 125
    print(1, (char *)"trying to use %s checksum\n", CHECKSUMS[params->checksum]);
    }
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (state < 100)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp = proto_init_step(params);
    }
#line 130
    if (tmp == -1) {
#line 131
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (0);
}
}
#line 141 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static struct proto_params req_params  =    {0, 0};
#line 137 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
int proto_init_step(struct proto_params *params ) 
{ 
  int i ;
  int len ;
  char *line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 140
  len = 0;
  {
#line 148
  if (state == 1) {
#line 148
    goto case_1;
  }
#line 156
  if (state == 2) {
#line 156
    goto case_2;
  }
#line 178
  if (state == 3) {
#line 178
    goto case_3;
  }
#line 199
  if (state == 4) {
#line 199
    goto case_4;
  }
#line 207
  if (state == -1) {
#line 207
    goto case_neg_1;
  }
#line 218
  if (state == -2) {
#line 218
    goto case_neg_2;
  }
#line 230
  if (state == -3) {
#line 230
    goto case_neg_3;
  }
#line 255
  if (state == -4) {
#line 255
    goto case_neg_4;
  }
#line 279
  if (state == 5) {
#line 279
    goto case_5;
  }
#line 316
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 150
  tmp = control_write((enum send_mode )0, (char *)"netrw control protocol");
  }
#line 150
  if (tmp == -1) {
#line 151
    return (-1);
  }
#line 153
  state = 2;
#line 154
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 158
  len = snprintf((char */* __restrict  */)(str), (size_t )1024, (char const   */* __restrict  */)"requested params:");
  }
#line 160
  if (params->checksum != -1) {
    {
#line 161
    req_params.checksum = 1;
#line 162
    tmp___0 = snprintf((char */* __restrict  */)(str + len), (size_t )(1024 - len),
                       (char const   */* __restrict  */)" checksum");
#line 162
    len += tmp___0;
    }
  }
#line 165
  if (params->keepalive == 1) {
    {
#line 166
    req_params.keepalive = 1;
#line 167
    tmp___1 = snprintf((char */* __restrict  */)(str + len), (size_t )(1024 - len),
                       (char const   */* __restrict  */)" keepalive");
#line 167
    len += tmp___1;
    }
  }
  {
#line 170
  str[len] = (char )'\000';
#line 172
  tmp___2 = control_write((enum send_mode )0, str);
  }
#line 172
  if (tmp___2 == -1) {
#line 173
    return (-1);
  }
#line 175
  state = 3;
#line 176
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 180
  len = snprintf((char */* __restrict  */)(str), (size_t )1024, (char const   */* __restrict  */)"checksum:");
  }
#line 182
  if (params->checksum != -1) {
    {
#line 183
    tmp___3 = snprintf((char */* __restrict  */)(str + len), (size_t )(1024 - len),
                       (char const   */* __restrict  */)" %s", CHECKSUMS[params->checksum]);
#line 183
    len += tmp___3;
    }
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )i < sizeof(CHECKSUMS) / sizeof(char *))) {
#line 187
      goto while_break;
    }
#line 188
    if (i == params->checksum) {
#line 189
      goto __Cont;
    }
    {
#line 190
    tmp___4 = snprintf((char */* __restrict  */)(str + len), (size_t )(1024 - len),
                       (char const   */* __restrict  */)" %s", CHECKSUMS[i]);
#line 190
    len += tmp___4;
    }
    __Cont: /* CIL Label */ 
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp___5 = control_write((enum send_mode )0, str);
  }
#line 193
  if (tmp___5 == -1) {
#line 194
    return (-1);
  }
#line 196
  state = 4;
#line 197
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 201
  tmp___6 = control_write((enum send_mode )1, (char *)"");
  }
#line 201
  if (tmp___6 == -1) {
#line 202
    return (-1);
  }
#line 204
  state = 5;
#line 205
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 209
  line = control_read();
#line 209
  tmp___7 = strmatch((char const   *)line, "netrw control protocol");
  }
#line 209
  if (! tmp___7) {
#line 210
    if ((unsigned long )line != (unsigned long )((void *)0)) {
      {
#line 211
      print(-2, (char *)"Invalid protocol header: ``%s\'\'\n", line);
      }
    }
#line 212
    return (-1);
  }
#line 215
  state = -2;
#line 216
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 220
  line = control_read();
  }
#line 220
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 222
    print(-2, (char *)"Missing connection parameters\n");
    }
#line 223
    return (-1);
  } else {
    {
#line 220
    tmp___8 = line_header(& line, (char *)"requested params");
    }
#line 220
    if (tmp___8 == -1) {
      {
#line 222
      print(-2, (char *)"Missing connection parameters\n");
      }
#line 223
      return (-1);
    }
  }
  {
#line 225
  get_params(& req_params, line);
#line 227
  state = -3;
  }
#line 228
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 232
    line = control_read();
    }
#line 232
    if ((unsigned long )line != (unsigned long )((void *)0)) {
#line 232
      if (! ((int )*(line + 0) != 0)) {
#line 232
        goto while_break___0;
      }
    } else {
#line 232
      goto while_break___0;
    }
#line 234
    i = 0;
    {
#line 234
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 234
      if (! ((unsigned long )i < sizeof(PARAMS) / sizeof(char *))) {
#line 234
        goto while_break___1;
      }
      {
#line 235
      tmp___9 = line_header(& line, PARAMS[i]);
      }
#line 235
      if (tmp___9 == 0) {
#line 236
        goto while_break___1;
      }
#line 234
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 238
    if ((unsigned long )i == sizeof(PARAMS) / sizeof(char *)) {
      {
#line 239
      print(-1, (char *)"Unknown connection parameter: ``%s\'\'; ignored\n", line);
      }
#line 241
      goto while_continue___0;
    }
    {
#line 244
    param_options(i, line, & req_params, params);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 246
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 247
    return (-1);
  }
  {
#line 249
  checksum_proto_check(& req_params, params);
#line 250
  keepalive_proto_check(& req_params, params);
#line 252
  state = -4;
  }
#line 253
  goto switch_break;
  case_neg_4: /* CIL Label */ 
  {
#line 257
  tmp___10 = control_write((enum send_mode )0, (char *)"netrw control protocol");
  }
#line 257
  if (tmp___10 == -1) {
#line 258
    return (-1);
  }
#line 261
  if (params->checksum != -1) {
    {
#line 262
    tmp___11 = control_writef((enum send_mode )0, (char *)"%s: %s", "checksum", CHECKSUMS[params->checksum]);
    }
#line 262
    if (tmp___11 == -1) {
#line 264
      return (-1);
    }
  }
#line 266
  if (params->keepalive == 1) {
    {
#line 267
    tmp___12 = control_writef((enum send_mode )0, (char *)"%s: on", "keepalive");
    }
#line 267
    if (tmp___12 == -1) {
#line 269
      return (-1);
    }
  }
  {
#line 273
  tmp___13 = control_write((enum send_mode )1, (char *)"");
  }
#line 273
  if (tmp___13 == -1) {
#line 274
    return (-1);
  }
#line 276
  state = 100;
#line 277
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 281
  line = control_read();
#line 281
  tmp___14 = strmatch((char const   *)line, "netrw control protocol");
  }
#line 281
  if (! tmp___14) {
#line 282
    if ((unsigned long )line != (unsigned long )((void *)0)) {
      {
#line 283
      print(-2, (char *)"Invalid protocol header: ``%s\'\'\n", line);
      }
    }
#line 284
    return (-1);
  }
#line 288
  params->checksum = -1;
#line 289
  req_params.checksum = 0;
#line 290
  params->keepalive = 0;
#line 291
  req_params.keepalive = 0;
  {
#line 294
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 294
    line = control_read();
    }
#line 294
    if ((unsigned long )line != (unsigned long )((void *)0)) {
#line 294
      if (! ((int )*(line + 0) != 0)) {
#line 294
        goto while_break___2;
      }
    } else {
#line 294
      goto while_break___2;
    }
#line 296
    i = 0;
    {
#line 296
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 296
      if (! ((unsigned long )i < sizeof(PARAMS) / sizeof(char *))) {
#line 296
        goto while_break___3;
      }
      {
#line 297
      tmp___15 = line_header(& line, PARAMS[i]);
      }
#line 297
      if (tmp___15 == 0) {
#line 298
        goto while_break___3;
      }
#line 296
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 300
    if ((unsigned long )i == sizeof(PARAMS) / sizeof(char *)) {
      {
#line 301
      print(-2, (char *)"Unknown connection parameter: ``%s\'\'\n", line);
      }
#line 302
      return (-1);
    }
    {
#line 305
    tmp___16 = accept_option(i, line, & req_params, params);
    }
#line 305
    if (tmp___16 == -1) {
#line 306
      return (-1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 308
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 309
    return (-1);
  }
  {
#line 311
  keepalive_proto_check(& req_params, params);
#line 313
  state = 100;
  }
#line 314
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 317
  print(-2, (char *)"Invalid protocol state in proto_init_step(): %d\n", state);
  }
#line 318
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 325 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static void get_params(struct proto_params *params , char *line ) 
{ 
  char *word ;
  int i ;
  int tmp ;

  {
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 330
    word = get_word(& line);
    }
#line 330
    if (! ((unsigned long )word != (unsigned long )((void *)0))) {
#line 330
      goto while_break;
    }
#line 331
    i = 0;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! ((unsigned long )i < sizeof(PARAMS) / sizeof(char *))) {
#line 331
        goto while_break___0;
      }
      {
#line 332
      tmp = strmatch((char const   *)word, (char const   *)PARAMS[i]);
      }
#line 332
      if (tmp) {
#line 333
        goto while_break___0;
      }
#line 331
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    if (i == 0) {
#line 337
      goto case_0;
    }
#line 341
    if (i == 1) {
#line 341
      goto case_1;
    }
#line 345
    goto switch_default;
    case_0: /* CIL Label */ 
#line 338
    params->checksum = 1;
#line 339
    goto switch_break;
    case_1: /* CIL Label */ 
#line 342
    params->keepalive = 1;
#line 343
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 346
    print(-1, (char *)"Unknown connection parameter requested: ``%s\'\'; ignored\n",
          word);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 352 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static void param_options(int param , char *options , struct proto_params *req_params___1 ,
                          struct proto_params *params ) 
{ 


  {
  {
#line 358
  if (param == 0) {
#line 358
    goto case_0;
  }
#line 357
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 359
  checksum_proto_param_options(options, req_params___1, params);
  }
#line 360
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static int accept_option(int param , char *options , struct proto_params *req_params___1 ,
                         struct proto_params *params ) 
{ 
  char *option ;
  int tmp ;

  {
  {
#line 371
  option = get_word(& options);
  }
  {
#line 374
  if (param == 0) {
#line 374
    goto case_0;
  }
#line 377
  if (param == 1) {
#line 377
    goto case_1;
  }
#line 373
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 375
  tmp = checksum_proto_accept_option(option, req_params___1, params);
  }
#line 375
  return (tmp);
  case_1: /* CIL Label */ 
#line 378
  req_params___1->keepalive = 1;
#line 379
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 382
  return (-1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 95
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 76 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.h"
int set_host(char *host ) ;
#line 90
int set_service(char *service , enum transport_protocol tp ) ;
#line 108
int in_addr(struct sockaddr_in *sin , enum ip_mode mode ) ;
#line 128
int create_data_socket(enum connection_mode mode ) ;
#line 142
int close_data_socket(void) ;
#line 156
int have_data_socket(void) ;
#line 174
int create_control_socket(void) ;
#line 189
int close_control_socket(void) ;
#line 203
int have_control_socket(void) ;
#line 222
int data_wait(void) ;
#line 236
ssize_t data_read(void *buf , size_t count , struct sockaddr_in *from , socklen_t *fromlen ) ;
#line 251
ssize_t data_write(void const   *buf , size_t count ) ;
#line 264
int control_check_read(void) ;
#line 86 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static enum connection_mode conn_mode  ;
#line 87 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static enum transport_protocol trans_protocol  ;
#line 88 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *tp_str  =    (char *)((void *)0);
#line 89 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static unsigned short port  =    (unsigned short)0;
#line 90 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static struct in_addr ip  ;
#line 93 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_listen  =    -1;
#line 94 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_control  =    -1;
#line 95 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_data  =    -1;
#line 98 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *r_buf  ;
#line 99 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *r_tmp  ;
#line 100 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int r_bufpos  =    0;
#line 101 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int r_buflen  =    0;
#line 102 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *w_buf  ;
#line 103 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *w_tmp  ;
#line 104 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int w_buflen  =    0;
#line 111 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int set_host(char *host ) 
{ 
  struct hostent *he ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 115
  he = gethostbyname((char const   *)host);
  }
#line 115
  if (! he) {
    {
#line 116
    tmp = __h_errno_location();
#line 116
    tmp___0 = hstrerror(*tmp);
#line 116
    print(-2, (char *)"Cannot resolve host name (%s): %s\n", host, tmp___0);
    }
#line 118
    return (-1);
  }
  {
#line 121
  ip = *(*((struct in_addr **)he->h_addr_list));
#line 123
  tmp___1 = inet_ntoa(ip);
#line 123
  print(2, (char *)"host IP address: %s\n", tmp___1);
  }
#line 125
  return (0);
}
}
#line 128 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int set_service(char *service , enum transport_protocol tp ) 
{ 
  unsigned short p ;
  struct servent *se ;
  char *endptr ;
  long i ;
  uint16_t tmp ;

  {
#line 133
  trans_protocol = tp;
  {
#line 135
  if ((unsigned int )tp == 0U) {
#line 135
    goto case_0;
  }
#line 138
  if ((unsigned int )tp == 1U) {
#line 138
    goto case_1;
  }
#line 134
  goto switch_break;
  case_0: /* CIL Label */ 
#line 136
  tp_str = (char *)"udp";
#line 137
  goto switch_break;
  case_1: /* CIL Label */ 
#line 139
  tp_str = (char *)"tcp";
#line 140
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 143
  se = getservbyname((char const   *)service, (char const   *)tp_str);
  }
#line 143
  if (se) {
#line 144
    p = (unsigned short )se->s_port;
  } else {
    {
#line 147
    endptr = (char *)((void *)0);
#line 150
    i = strtol((char const   */* __restrict  */)service, (char **/* __restrict  */)(& endptr),
               0);
    }
#line 151
    if ((int )*service == 0) {
      {
#line 153
      print(-2, (char *)"No such service: %s/%s\n", service, tp_str);
      }
#line 154
      return (-1);
    } else
#line 151
    if ((int )*endptr != 0) {
      {
#line 153
      print(-2, (char *)"No such service: %s/%s\n", service, tp_str);
      }
#line 154
      return (-1);
    } else
#line 151
    if (i <= 0L) {
      {
#line 153
      print(-2, (char *)"No such service: %s/%s\n", service, tp_str);
      }
#line 154
      return (-1);
    } else
#line 151
    if (i > 65535L) {
      {
#line 153
      print(-2, (char *)"No such service: %s/%s\n", service, tp_str);
      }
#line 154
      return (-1);
    } else {
      {
#line 157
      p = htons((uint16_t )i);
      }
    }
  }
  {
#line 160
  port = p;
#line 162
  tmp = ntohs(port);
#line 162
  print(2, (char *)"port number: %d/%s\n", (int )tmp, tp_str);
  }
#line 164
  return (0);
}
}
#line 167 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int in_addr(struct sockaddr_in *sin , enum ip_mode mode ) 
{ 


  {
#line 169
  if ((unsigned long )sin == (unsigned long )((void *)0)) {
#line 170
    return (-1);
  } else
#line 169
  if ((int )port == 0) {
#line 170
    return (-1);
  }
  {
#line 172
  memset((void *)sin, '\000', sizeof(struct sockaddr_in ));
#line 174
  sin->sin_family = (sa_family_t )2;
#line 175
  sin->sin_port = port;
  }
  {
#line 178
  if ((unsigned int )mode == 0U) {
#line 178
    goto case_0;
  }
#line 182
  if ((unsigned int )mode == 1U) {
#line 182
    goto case_1;
  }
#line 177
  goto switch_break;
  case_0: /* CIL Label */ 
#line 179
  sin->sin_addr.s_addr = (in_addr_t )0;
#line 180
  goto switch_break;
  case_1: /* CIL Label */ 
#line 183
  sin->sin_addr = ip;
#line 184
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 187
  return (0);
}
}
#line 195 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int create_data_socket(enum connection_mode mode ) 
{ 
  int s ;
  unsigned int size ;
  struct sockaddr_in sin ;
  int reuse_addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  uint16_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  uint16_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  uint16_t tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  uint16_t tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  uint16_t tmp___30 ;
  int tmp___31 ;
  uint16_t tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  uint16_t tmp___35 ;
  char *tmp___36 ;

  {
  {
#line 200
  reuse_addr = 1;
#line 202
  conn_mode = mode;
#line 204
  print(2, (char *)"creating data socket\n");
  }
  {
#line 207
  if ((unsigned int )trans_protocol == 0U) {
#line 207
    goto case_0;
  }
#line 226
  if ((unsigned int )trans_protocol == 1U) {
#line 226
    goto case_1;
  }
#line 300
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 208
  s = socket(2, 2, 0);
  }
#line 208
  if (s == -1) {
    {
#line 209
    tmp = __errno_location();
#line 209
    tmp___0 = strerror(*tmp);
#line 209
    print(-2, (char *)"Cannot create data socket: %s\n", tmp___0);
    }
#line 210
    return (-1);
  }
#line 213
  if ((unsigned int )mode == 0U) {
    {
#line 214
    tmp___1 = in_addr(& sin, (enum ip_mode )0);
    }
#line 214
    if (tmp___1 == -1) {
#line 215
      return (-1);
    }
    {
#line 217
    tmp___6 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), (socklen_t )sizeof(sin));
    }
#line 217
    if (tmp___6) {
      {
#line 218
      tmp___2 = __errno_location();
#line 218
      tmp___3 = strerror(*tmp___2);
#line 218
      tmp___4 = ntohs(sin.sin_port);
#line 218
      tmp___5 = inet_ntoa(sin.sin_addr);
#line 218
      print(-2, (char *)"Cannot bind socket to %s:%d: %s\n", tmp___5, (int )tmp___4,
            tmp___3);
      }
#line 221
      return (-1);
    }
  }
#line 224
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 229
  if ((unsigned int )mode == 1U) {
#line 229
    goto case_1___0;
  }
#line 229
  if ((unsigned int )mode == 2U) {
#line 229
    goto case_1___0;
  }
#line 251
  if ((unsigned int )mode == 3U) {
#line 251
    goto case_3;
  }
#line 251
  if ((unsigned int )mode == 0U) {
#line 251
    goto case_3;
  }
#line 295
  goto switch_default;
  case_1___0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 230
  s = socket(2, 1, 0);
  }
#line 230
  if (s == -1) {
    {
#line 231
    tmp___7 = __errno_location();
#line 231
    tmp___8 = strerror(*tmp___7);
#line 231
    print(-2, (char *)"Cannot create data socket: %s\n", tmp___8);
    }
#line 233
    return (-1);
  }
  {
#line 236
  tmp___9 = in_addr(& sin, (enum ip_mode )1);
  }
#line 236
  if (tmp___9 == -1) {
#line 237
    return (-1);
  }
  {
#line 239
  tmp___14 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), (socklen_t )sizeof(sin));
  }
#line 239
  if (tmp___14) {
    {
#line 240
    tmp___10 = __errno_location();
#line 240
    tmp___11 = strerror(*tmp___10);
#line 240
    tmp___12 = ntohs(sin.sin_port);
#line 240
    tmp___13 = inet_ntoa(sin.sin_addr);
#line 240
    print(-2, (char *)"Cannot connect to %s:%d: %s\n", tmp___13, (int )tmp___12, tmp___11);
    }
#line 243
    return (-1);
  }
  {
#line 246
  tmp___15 = ntohs(sin.sin_port);
#line 246
  tmp___16 = inet_ntoa(sin.sin_addr);
#line 246
  print(1, (char *)"connected to %s:%d\n", tmp___16, (int )tmp___15);
  }
#line 248
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 252
  s_listen = socket(2, 1, 0);
  }
#line 252
  if (s_listen == -1) {
    {
#line 253
    tmp___17 = __errno_location();
#line 253
    tmp___18 = strerror(*tmp___17);
#line 253
    print(-2, (char *)"Cannot create listening socket: %s\n", tmp___18);
    }
#line 255
    return (-1);
  }
  {
#line 258
  tmp___21 = setsockopt(s_listen, 1, 2, (void const   *)((void *)(& reuse_addr)),
                        (socklen_t )sizeof(reuse_addr));
  }
#line 258
  if (tmp___21) {
    {
#line 260
    tmp___19 = __errno_location();
#line 260
    tmp___20 = strerror(*tmp___19);
#line 260
    print(-1, (char *)"Cannot set SO_REUSEADDR option: %s\n", tmp___20);
    }
  }
  {
#line 264
  tmp___22 = in_addr(& sin, (enum ip_mode )0);
  }
#line 264
  if (tmp___22 == -1) {
#line 265
    return (-1);
  }
  {
#line 267
  tmp___27 = bind(s_listen, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                  (socklen_t )sizeof(sin));
  }
#line 267
  if (tmp___27) {
    {
#line 268
    tmp___23 = __errno_location();
#line 268
    tmp___24 = strerror(*tmp___23);
#line 268
    tmp___25 = ntohs(sin.sin_port);
#line 268
    tmp___26 = inet_ntoa(sin.sin_addr);
#line 268
    print(-2, (char *)"Cannot bind socket to %s:%d: %s\n", tmp___26, (int )tmp___25,
          tmp___24);
    }
#line 271
    return (-1);
  }
  {
#line 274
  tmp___31 = listen(s_listen, 2);
  }
#line 274
  if (tmp___31) {
    {
#line 275
    tmp___28 = __errno_location();
#line 275
    tmp___29 = strerror(*tmp___28);
#line 275
    tmp___30 = ntohs(sin.sin_port);
#line 275
    print(-2, (char *)"Cannot listen on %d: %s\n", (int )tmp___30, tmp___29);
    }
#line 277
    return (-1);
  }
  {
#line 280
  print(2, (char *)"listening socket created\n");
#line 281
  tmp___32 = ntohs(port);
#line 281
  print(1, (char *)"listening on %d\n", (int )tmp___32);
#line 283
  size = (unsigned int )sizeof(sin);
#line 284
  s = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
             (socklen_t */* __restrict  */)(& size));
  }
#line 284
  if (s == -1) {
    {
#line 286
    tmp___33 = __errno_location();
#line 286
    tmp___34 = strerror(*tmp___33);
#line 286
    print(-2, (char *)"Cannot accept data connection: %s\n", tmp___34);
    }
#line 288
    return (-1);
  }
  {
#line 291
  tmp___35 = ntohs(sin.sin_port);
#line 291
  tmp___36 = inet_ntoa(sin.sin_addr);
#line 291
  print(1, (char *)"accepted data connection from %s:%d\n", tmp___36, (int )tmp___35);
  }
#line 293
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 296
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 298
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 301
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 304
  s_data = s;
#line 306
  print(2, (char *)"%s data socket created\n", tp_str);
  }
#line 308
  return (0);
}
}
#line 311 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int close_data_socket(void) 
{ 
  int ret ;

  {
#line 315
  if ((unsigned int )trans_protocol == 1U) {
    {
#line 316
    shutdown(s_data, 2);
    }
  }
  {
#line 318
  ret = close(s_data);
#line 319
  s_data = -1;
  }
#line 321
  if (ret) {
#line 322
    return (0);
  } else {
#line 324
    return (-1);
  }
}
}
#line 327 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int have_data_socket(void) 
{ 


  {
#line 329
  return (s_data > -1);
}
}
#line 332 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int create_control_socket(void) 
{ 
  int n ;
  int s ;
  unsigned int size ;
  struct sockaddr_in sin ;
  fd_set rfds ;
  fd_set efds ;
  struct timeval timeout ;
  struct timeval *t_out ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  uint16_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  char *tmp___8 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  uint16_t tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 343
  print(2, (char *)"creating control socket\n");
  }
  {
#line 346
  if ((unsigned int )trans_protocol == 0U) {
#line 346
    goto case_0;
  }
#line 349
  if ((unsigned int )trans_protocol == 1U) {
#line 349
    goto case_1;
  }
#line 432
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 347
  return (-1);
  case_1: /* CIL Label */ 
  {
#line 352
  if ((unsigned int )conn_mode == 1U) {
#line 352
    goto case_1___0;
  }
#line 352
  if ((unsigned int )conn_mode == 2U) {
#line 352
    goto case_1___0;
  }
#line 374
  if ((unsigned int )conn_mode == 3U) {
#line 374
    goto case_3;
  }
#line 374
  if ((unsigned int )conn_mode == 0U) {
#line 374
    goto case_3;
  }
#line 427
  goto switch_default;
  case_1___0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 353
  s = socket(2, 1, 0);
  }
#line 353
  if (s == -1) {
    {
#line 354
    tmp = __errno_location();
#line 354
    tmp___0 = strerror(*tmp);
#line 354
    print(-2, (char *)"Cannot create control socket: %s\n", tmp___0);
    }
#line 356
    return (-1);
  }
  {
#line 359
  tmp___1 = in_addr(& sin, (enum ip_mode )1);
  }
#line 359
  if (tmp___1 == -1) {
#line 360
    return (-1);
  }
  {
#line 362
  tmp___6 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), (socklen_t )sizeof(sin));
  }
#line 362
  if (tmp___6) {
    {
#line 363
    tmp___2 = __errno_location();
#line 363
    tmp___3 = strerror(*tmp___2);
#line 363
    tmp___4 = ntohs(sin.sin_port);
#line 363
    tmp___5 = inet_ntoa(sin.sin_addr);
#line 363
    print(-2, (char *)"Cannot connect to %s:%d: %s\n", tmp___5, (int )tmp___4, tmp___3);
    }
#line 366
    return (-1);
  }
  {
#line 369
  tmp___7 = ntohs(sin.sin_port);
#line 369
  tmp___8 = inet_ntoa(sin.sin_addr);
#line 369
  print(1, (char *)"connected to %s:%d\n", tmp___8, (int )tmp___7);
  }
#line 371
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 375
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& efds.__fds_bits[0]): "memory");
#line 376
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 377
  rfds.__fds_bits[s_listen / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_listen % (8 * (int )sizeof(__fd_mask ));
#line 378
  efds.__fds_bits[s_listen / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_listen % (8 * (int )sizeof(__fd_mask ));
#line 379
  if ((unsigned int )conn_mode == 0U) {
#line 380
    rfds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_data % (8 * (int )sizeof(__fd_mask ));
#line 381
    efds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_data % (8 * (int )sizeof(__fd_mask ));
#line 382
    if (s_listen > s_data) {
#line 382
      tmp___9 = s_listen;
    } else {
#line 382
      tmp___9 = s_data;
    }
#line 382
    n = tmp___9 + 1;
#line 383
    t_out = (struct timeval *)((void *)0);
  } else {
#line 386
    n = s_listen + 1;
#line 387
    timeout.tv_sec = (__time_t )10;
#line 388
    timeout.tv_usec = (__suseconds_t )0;
#line 389
    t_out = & timeout;
  }
  {
#line 392
  tmp___16 = select(n, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& efds), (struct timeval */* __restrict  */)t_out);
  }
#line 392
  if (tmp___16 >= 0) {
#line 393
    if ((rfds.__fds_bits[s_listen / (8 * (int )sizeof(__fd_mask ))] & (1L << s_listen % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 393
      if (! ((rfds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] & (1L << s_data % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
        {
#line 394
        size = (unsigned int )sizeof(sin);
#line 395
        s = accept(s_listen, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
                   (socklen_t */* __restrict  */)(& size));
        }
#line 395
        if (s == -1) {
          {
#line 397
          tmp___10 = __errno_location();
#line 397
          tmp___11 = strerror(*tmp___10);
#line 397
          print(-2, (char *)"Cannot accept control connection: %s\n", tmp___11);
#line 399
          close(s_listen);
#line 400
          s_listen = -1;
          }
#line 401
          return (-1);
        }
        {
#line 404
        tmp___12 = ntohs(sin.sin_port);
#line 404
        tmp___13 = inet_ntoa(sin.sin_addr);
#line 404
        print(1, (char *)"accepted control connection from %s:%d\n", tmp___13, (int )tmp___12);
        }
      } else {
        {
#line 408
        print(-2, (char *)"Cannot create control socket: remote party does not support control connection\n");
#line 410
        close(s_listen);
#line 411
        s_listen = -1;
        }
#line 412
        return (-1);
      }
    } else {
      {
#line 408
      print(-2, (char *)"Cannot create control socket: remote party does not support control connection\n");
#line 410
      close(s_listen);
#line 411
      s_listen = -1;
      }
#line 412
      return (-1);
    }
  } else {
    {
#line 416
    tmp___14 = __errno_location();
#line 416
    tmp___15 = strerror(*tmp___14);
#line 416
    print(-2, (char *)"Cannot create control socket: select() failed: %s\n", tmp___15);
#line 418
    close(s_listen);
#line 419
    s_listen = -1;
    }
#line 420
    return (-1);
  }
  {
#line 423
  close(s_listen);
#line 424
  s_listen = -1;
  }
#line 425
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 428
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 430
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 433
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 437
  tmp___19 = malloc((size_t )(1 << 14));
#line 437
  r_buf = (char *)tmp___19;
  }
#line 437
  if ((unsigned long )r_buf == (unsigned long )((void *)0)) {
    {
#line 441
    tmp___17 = __errno_location();
#line 441
    tmp___18 = strerror(*tmp___17);
#line 441
    print(-2, (char *)"Cannot allocate control connection IO buffers: %s\n", tmp___18);
    }
#line 443
    return (-1);
  } else {
    {
#line 437
    tmp___20 = malloc((size_t )(1 << 14));
#line 437
    w_buf = (char *)tmp___20;
    }
#line 437
    if ((unsigned long )w_buf == (unsigned long )((void *)0)) {
      {
#line 441
      tmp___17 = __errno_location();
#line 441
      tmp___18 = strerror(*tmp___17);
#line 441
      print(-2, (char *)"Cannot allocate control connection IO buffers: %s\n", tmp___18);
      }
#line 443
      return (-1);
    } else {
      {
#line 437
      tmp___21 = malloc((size_t )(1 << 14));
#line 437
      r_tmp = (char *)tmp___21;
      }
#line 437
      if ((unsigned long )r_tmp == (unsigned long )((void *)0)) {
        {
#line 441
        tmp___17 = __errno_location();
#line 441
        tmp___18 = strerror(*tmp___17);
#line 441
        print(-2, (char *)"Cannot allocate control connection IO buffers: %s\n", tmp___18);
        }
#line 443
        return (-1);
      } else {
        {
#line 437
        tmp___22 = malloc((size_t )(1 << 14));
#line 437
        w_tmp = (char *)tmp___22;
        }
#line 437
        if ((unsigned long )w_tmp == (unsigned long )((void *)0)) {
          {
#line 441
          tmp___17 = __errno_location();
#line 441
          tmp___18 = strerror(*tmp___17);
#line 441
          print(-2, (char *)"Cannot allocate control connection IO buffers: %s\n",
                tmp___18);
          }
#line 443
          return (-1);
        }
      }
    }
  }
  {
#line 445
  *(r_buf + 0) = (char )'\000';
#line 446
  *(w_buf + 0) = (char )'\000';
#line 447
  *(r_tmp + 0) = (char )'\000';
#line 448
  *(w_tmp + 0) = (char )'\000';
#line 450
  s_control = s;
#line 452
  print(2, (char *)"control socket created\n");
  }
#line 454
  return (0);
}
}
#line 457 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int close_control_socket(void) 
{ 
  int ret ;

  {
  {
#line 462
  free((void *)r_buf);
#line 463
  r_buf = (char *)((void *)0);
#line 464
  free((void *)w_buf);
#line 465
  w_buf = (char *)((void *)0);
#line 466
  free((void *)r_tmp);
#line 467
  r_tmp = (char *)((void *)0);
  }
#line 469
  if ((unsigned int )trans_protocol == 1U) {
    {
#line 470
    shutdown(s_control, 2);
    }
  }
  {
#line 471
  ret = close(s_control);
#line 472
  s_control = -1;
  }
#line 474
  if (ret) {
#line 475
    return (0);
  } else {
#line 477
    return (-1);
  }
}
}
#line 480 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int have_control_socket(void) 
{ 


  {
#line 482
  return (s_control > -1);
}
}
#line 490 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int data_wait(void) 
{ 
  fd_set e_fds ;
  fd_set r_fds ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& e_fds.__fds_bits[0]): "memory");
#line 495
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  e_fds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_data % (8 * (int )sizeof(__fd_mask ));
  {
#line 498
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 498
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& r_fds.__fds_bits[0]): "memory");
#line 498
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 499
  r_fds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_data % (8 * (int )sizeof(__fd_mask ));
#line 501
  tmp___1 = select(s_data + 1, (fd_set */* __restrict  */)(& r_fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)(& e_fds), (struct timeval */* __restrict  */)((void *)0));
  }
#line 501
  if (tmp___1 > 0) {
#line 502
    if ((r_fds.__fds_bits[s_data / (8 * (int )sizeof(__fd_mask ))] & (1L << s_data % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 503
      return (0);
    }
  } else {
    {
#line 506
    tmp = __errno_location();
#line 506
    tmp___0 = strerror(*tmp);
#line 506
    print(-2, (char *)"select() failed: %s\n", tmp___0);
    }
  }
#line 508
  return (-1);
}
}
#line 511 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
ssize_t data_read(void *buf , size_t count , struct sockaddr_in *from , socklen_t *fromlen ) 
{ 
  ssize_t ret ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 514
  ret = (ssize_t )0;
  {
#line 517
  if ((unsigned int )trans_protocol == 0U) {
#line 517
    goto case_0;
  }
#line 522
  if ((unsigned int )trans_protocol == 1U) {
#line 522
    goto case_1;
  }
#line 516
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 518
  ret = recvfrom(s_data, (void */* __restrict  */)buf, count, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)from),
                 (socklen_t */* __restrict  */)fromlen);
  }
#line 520
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 523
  ret = read(s_data, buf, count);
  }
#line 524
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 527
  if (ret < 0L) {
    {
#line 528
    tmp = __errno_location();
#line 528
    tmp___0 = strerror(*tmp);
#line 528
    print(-2, (char *)"Cannot read data: %s\n", tmp___0);
    }
  }
#line 530
  return (ret);
}
}
#line 533 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
ssize_t data_write(void const   *buf , size_t count ) 
{ 
  ssize_t ret ;
  struct sockaddr_in to ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 535
  ret = (ssize_t )0;
  {
#line 539
  if ((unsigned int )trans_protocol == 0U) {
#line 539
    goto case_0;
  }
#line 545
  if ((unsigned int )trans_protocol == 1U) {
#line 545
    goto case_1;
  }
#line 538
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 540
  in_addr(& to, (enum ip_mode )1);
#line 541
  ret = sendto(s_data, buf, count, 0, (struct sockaddr  const  *)((struct sockaddr *)(& to)),
               (socklen_t )sizeof(to));
  }
#line 543
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 546
  ret = write(s_data, buf, count);
  }
#line 547
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 550
  if (ret < 0L) {
    {
#line 551
    tmp = __errno_location();
#line 551
    tmp___0 = strerror(*tmp);
#line 551
    print(-2, (char *)"Cannot write data: %s\n", tmp___0);
    }
  }
#line 553
  return (ret);
}
}
#line 561 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int control_check_read(void) 
{ 
  struct timeval timeout ;
  fd_set rfds ;
  fd_set efds ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___0 ;

  {
  {
#line 563
  timeout.tv_sec = (__time_t )0;
#line 563
  timeout.tv_usec = (__suseconds_t )0;
#line 567
  tmp = have_control_socket();
  }
#line 567
  if (! tmp) {
#line 568
    return (-1);
  }
#line 570
  if (r_bufpos < r_buflen) {
#line 571
    return (0);
  }
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 573
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 574
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& efds.__fds_bits[0]): "memory");
#line 574
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 575
  rfds.__fds_bits[s_control / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_control % (8 * (int )sizeof(__fd_mask ));
#line 576
  efds.__fds_bits[s_control / (8 * (int )sizeof(__fd_mask ))] |= 1L << s_control % (8 * (int )sizeof(__fd_mask ));
#line 578
  tmp___0 = select(s_control + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)(& efds), (struct timeval */* __restrict  */)(& timeout));
  }
#line 578
  if (tmp___0 > 0) {
#line 578
    if ((rfds.__fds_bits[s_control / (8 * (int )sizeof(__fd_mask ))] & (1L << s_control % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 580
      return (0);
    } else
#line 578
    if ((efds.__fds_bits[s_control / (8 * (int )sizeof(__fd_mask ))] & (1L << s_control % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 580
      return (0);
    } else {
#line 582
      return (-1);
    }
  } else {
#line 582
    return (-1);
  }
}
}
#line 587 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int closed  =    0;
#line 585 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
char *control_read(void) 
{ 
  int ignoring ;
  int linepos ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 588
  ignoring = 0;
#line 589
  linepos = 0;
#line 591
  if (closed) {
#line 592
    return ((char *)((void *)0));
  }
#line 594
  *(r_buf + r_buflen) = (char )'\000';
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! ((int )*(r_buf + r_bufpos) != 10)) {
#line 596
      if (! ignoring) {
#line 596
        goto while_break;
      }
    }
#line 597
    if (ignoring) {
#line 597
      if ((int )*(r_buf + r_bufpos) == 10) {
#line 599
        ignoring = 0;
#line 600
        r_bufpos ++;
#line 601
        goto while_continue;
      }
    }
#line 604
    if (r_bufpos == r_buflen) {
      {
#line 606
      tmp___1 = read(s_control, (void *)r_buf, (size_t )((1 << 14) - 1));
#line 606
      r_buflen = (int )tmp___1;
      }
#line 606
      if (r_buflen < 0) {
        {
#line 607
        tmp = __errno_location();
#line 607
        tmp___0 = strerror(*tmp);
#line 607
        print(-2, (char *)"Cannot read data from control connection: %s\n", tmp___0);
#line 609
        r_buflen = r_bufpos;
        }
#line 610
        return ((char *)((void *)0));
      } else
#line 612
      if (r_buflen == 0) {
        {
#line 613
        print(-2, (char *)"Control connection closed by foreign host\n");
#line 614
        r_bufpos = 0;
#line 615
        closed = 1;
        }
#line 616
        return ((char *)((void *)0));
      }
#line 619
      *(r_buf + r_buflen) = (char )'\000';
#line 620
      r_bufpos = 0;
#line 621
      goto while_continue;
    }
#line 624
    if (linepos == (1 << 14) - 1) {
      {
#line 627
      print(-1, (char *)"Line too long, will be ignored\n");
#line 628
      linepos = 0;
#line 629
      ignoring = 1;
      }
    }
#line 632
    if (! ignoring) {
#line 633
      *(r_tmp + linepos) = *(r_buf + r_bufpos);
#line 634
      linepos ++;
    }
#line 636
    r_bufpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (linepos > 0) {
#line 640
    if ((int )*(r_tmp + (linepos - 1)) == 13) {
#line 641
      linepos --;
    }
  }
#line 643
  *(r_tmp + linepos) = (char )'\000';
#line 644
  r_bufpos ++;
#line 646
  return (r_tmp);
}
}
#line 649 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int control_write(enum send_mode mode , char *line ) 
{ 
  int len ;
  int wr ;
  char *p ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 655
  tmp = strlen((char const   *)line);
#line 655
  len = (int )tmp;
  }
#line 655
  if (len + 1 > 1 << 14) {
    {
#line 656
    print(-2, (char *)"Line too long, would be ignored on receive\n");
    }
#line 657
    return (-1);
  }
#line 662
  if ((w_buflen + len) + 1 >= 1 << 14) {
#line 663
    p = w_buf;
    {
#line 663
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 663
      tmp___0 = write(s_control, (void const   *)p, (size_t )w_buflen);
#line 663
      wr = (int )tmp___0;
      }
#line 663
      if (! (wr > 0)) {
#line 663
        goto while_break;
      }
#line 664
      w_buflen -= wr;
#line 664
      if (w_buflen == 0) {
#line 665
        goto while_break;
      }
#line 663
      p += wr;
    }
    while_break: /* CIL Label */ ;
    }
#line 667
    w_buflen = 0;
#line 669
    if (wr < 0) {
      {
#line 670
      tmp___1 = __errno_location();
#line 670
      tmp___2 = strerror(*tmp___1);
#line 670
      print(-2, (char *)"Cannot write data to control connection: %s\n", tmp___2);
      }
#line 672
      return (-1);
    }
  }
  {
#line 677
  memcpy((void */* __restrict  */)(w_buf + w_buflen), (void const   */* __restrict  */)line,
         (size_t )len);
#line 678
  w_buflen += len;
#line 679
  tmp___3 = w_buflen;
#line 679
  w_buflen ++;
#line 679
  *(w_buf + tmp___3) = (char )'\n';
  }
#line 681
  if ((unsigned int )mode == 1U) {
#line 682
    p = w_buf;
    {
#line 682
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 682
      tmp___4 = write(s_control, (void const   *)p, (size_t )w_buflen);
#line 682
      wr = (int )tmp___4;
      }
#line 682
      if (! (wr > 0)) {
#line 682
        goto while_break___0;
      }
#line 683
      w_buflen -= wr;
#line 683
      if (w_buflen == 0) {
#line 684
        goto while_break___0;
      }
#line 682
      p += wr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    w_buflen = 0;
#line 688
    if (wr < 0) {
      {
#line 689
      tmp___5 = __errno_location();
#line 689
      tmp___6 = strerror(*tmp___5);
#line 689
      print(-2, (char *)"Cannot write data to control connection: %s\n", tmp___6);
      }
#line 691
      return (-1);
    }
  }
#line 695
  return (0);
}
}
#line 698 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
int control_writef(enum send_mode mode , char *fmt  , ...) 
{ 
  va_list args ;
  int len ;
  int tmp ;

  {
  {
#line 703
  __builtin_va_start(args, fmt);
#line 704
  len = vsnprintf((char */* __restrict  */)w_tmp, (size_t )(1 << 14), (char const   */* __restrict  */)fmt,
                  args);
#line 705
  __builtin_va_end(args);
  }
#line 707
  if (len + 1 > 1 << 14) {
    {
#line 708
    print(-2, (char *)"Line too long, would be ignored\n");
    }
#line 709
    return (-1);
  }
  {
#line 712
  tmp = control_write(mode, w_tmp);
  }
#line 712
  return (tmp);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 119 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.h"
int can_print(int verbose_level ) ;
#line 65 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.h"
void progress_speed_bps(void) ;
#line 78
void progress_hash_after(unsigned long bytes___1 ) ;
#line 92
void progress_data(unsigned long transferred_bytes ) ;
#line 105
void progress_summary(void) ;
#line 49 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static int bps  =    0;
#line 50 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static char unit  =    (char )'B';
#line 51 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long after  =    10737418UL;
#line 52 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long hashes  =    0ULL;
#line 53 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long bytes  =    0ULL;
#line 54 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long bytes_line  =    0ULL;
#line 55 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static struct timeval start  ;
#line 56 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static struct timeval start_line  ;
#line 60
static void print_bytes(unsigned long long bytes___1 ) ;
#line 61
static double print_speed(int line ) ;
#line 64 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
void progress_speed_bps(void) 
{ 


  {
#line 66
  bps = 1;
#line 67
  unit = (char )'b';
#line 68
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
void progress_hash_after(unsigned long bytes___1 ) 
{ 


  {
#line 72
  if (bytes___1 == 0UL) {
#line 72
    after = 10737418UL;
  } else {
#line 72
    after = bytes___1;
  }
#line 73
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
void progress_data(unsigned long transferred_bytes ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = can_print(0);
  }
#line 77
  if (! tmp) {
#line 78
    return;
  }
#line 80
  if (bytes == 0ULL) {
    {
#line 81
    gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((void *)0));
#line 82
    start_line = start;
    }
  }
#line 85
  bytes += (unsigned long long )transferred_bytes;
#line 86
  bytes_line += (unsigned long long )transferred_bytes;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (bytes / (unsigned long long )after >= hashes + 1ULL)) {
#line 87
      goto while_break;
    }
    {
#line 88
    hashes ++;
#line 89
    print(0, (char *)"#");
    }
#line 90
    if (hashes % 50ULL == 0ULL) {
      {
#line 91
      print(0, (char *)" ");
#line 92
      print_bytes(hashes * (unsigned long long )after);
#line 93
      print(0, (char *)" ");
#line 94
      print_speed(1);
#line 95
      print(0, (char *)"\n");
#line 97
      bytes_line = 0ULL;
#line 98
      gettimeofday((struct timeval */* __restrict  */)(& start_line), (__timezone_ptr_t )((void *)0));
      }
    } else
#line 100
    if (hashes % 10ULL == 0ULL) {
      {
#line 101
      print(0, (char *)" ");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  fflush(stderr);
  }
#line 105
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
void progress_summary(void) 
{ 
  unsigned long diff_long ;
  double diff ;
  unsigned long h ;
  unsigned long m ;
  unsigned long s ;
  int tmp ;

  {
  {
#line 113
  tmp = can_print(0);
  }
#line 113
  if (! tmp) {
#line 114
    return;
  }
#line 116
  if (bytes == 0ULL) {
    {
#line 117
    print(0, (char *)"\nno data transferred\n");
    }
#line 118
    return;
  }
  {
#line 121
  print(0, (char *)"\n ");
#line 122
  print_bytes(bytes);
#line 123
  print(0, (char *)" (%llu B) transferred at ", bytes);
#line 124
  diff = print_speed(0);
#line 126
  diff_long = (unsigned long )diff;
#line 127
  h = diff_long / 3600UL;
#line 128
  diff_long %= 3600UL;
#line 129
  m = diff_long / 60UL;
#line 130
  diff_long %= 60UL;
#line 130
  s = diff_long;
#line 131
  print(0, (char *)" (%lu:%02lu:%02lu.%02lu)\n", h, m, s, (unsigned long )((diff - (double )((unsigned long )diff)) * (double )100));
  }
#line 133
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static void print_bytes(unsigned long long bytes___1 ) 
{ 


  {
#line 139
  if (bytes___1 >= 1152921504606846976ULL) {
    {
#line 140
    print(0, (char *)"%7.2f EiB", (double )bytes___1 / (1.0 * (double )1152921504606846976ULL));
    }
  } else
#line 141
  if (bytes___1 >= 1125899906842624ULL) {
    {
#line 142
    print(0, (char *)"%7.2f PiB", (double )bytes___1 / (1.0 * (double )1125899906842624ULL));
    }
  } else
#line 143
  if (bytes___1 >= 1099511627776ULL) {
    {
#line 144
    print(0, (char *)"%7.2f TiB", (double )bytes___1 / (1.0 * (double )1099511627776ULL));
    }
  } else
#line 147
  if (bytes___1 >= 1073741824ULL) {
    {
#line 148
    print(0, (char *)"%7.2f GiB", (double )bytes___1 / (1.0 * (double )1073741824ULL));
    }
  } else
#line 149
  if (bytes___1 >= 1048576ULL) {
    {
#line 150
    print(0, (char *)"%7.2f MiB", (double )bytes___1 / (1.0 * (double )1048576ULL));
    }
  } else
#line 151
  if (bytes___1 >= 1024ULL) {
    {
#line 152
    print(0, (char *)"%7.2f KiB", (double )bytes___1 / (1.0 * (double )1024ULL));
    }
  } else {
    {
#line 154
    print(0, (char *)"%7d B", (int )bytes___1);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static double print_speed(int line ) 
{ 
  double speed ;
  double diff ;
  struct timeval tv ;
  struct timeval now ;
  unsigned long long tmp ;
  int tmp___0 ;

  {
#line 164
  if (line) {
#line 164
    tv = start_line;
  } else {
#line 164
    tv = start;
  }
  {
#line 165
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 166
  diff = ((double )now.tv_sec + (double )now.tv_usec / 1000000.0) - ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
  }
#line 168
  if (diff == (double )0) {
#line 168
    diff = 0.001;
  } else {
#line 168
    diff = diff;
  }
#line 170
  if (line) {
#line 170
    tmp = bytes_line;
  } else {
#line 170
    tmp = bytes;
  }
#line 170
  if (bps) {
#line 170
    tmp___0 = 8;
  } else {
#line 170
    tmp___0 = 1;
  }
#line 170
  speed = (double )tmp / (diff / (double )tmp___0);
#line 173
  if (speed > (double )1152921504606846976ULL) {
    {
#line 174
    print(0, (char *)"%6.1f Ei%c/s", speed / (1.0 * (double )1152921504606846976ULL),
          (int )unit);
    }
  } else
#line 175
  if (speed > (double )1125899906842624ULL) {
    {
#line 176
    print(0, (char *)"%6.1f Pi%c/s", speed / (1.0 * (double )1125899906842624ULL),
          (int )unit);
    }
  } else
#line 177
  if (speed > (double )1099511627776ULL) {
    {
#line 178
    print(0, (char *)"%6.1f Ti%c/s", speed / (1.0 * (double )1099511627776ULL), (int )unit);
    }
  } else
#line 181
  if (speed > (double )1073741824ULL) {
    {
#line 182
    print(0, (char *)"%6.1f Gi%c/s", speed / (1.0 * (double )1073741824ULL), (int )unit);
    }
  } else
#line 183
  if (speed > (double )1048576ULL) {
    {
#line 184
    print(0, (char *)"%6.1f Mi%c/s", speed / (1.0 * (double )1048576ULL), (int )unit);
    }
  } else
#line 185
  if (speed > (double )1024ULL) {
    {
#line 186
    print(0, (char *)"%6.1f Ki%c/s", speed / (1.0 * (double )1024ULL), (int )unit);
    }
  } else {
    {
#line 188
    print(0, (char *)"%6.1f %c/s", speed, (int )unit);
    }
  }
#line 190
  return (diff);
}
}
#line 18 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.h"
void MD5Init(struct MD5Context *ctx___1 ) ;
#line 20
void MD5Update(struct MD5Context *ctx___1 , unsigned char const   *buf , unsigned int len ) ;
#line 23
void MD5Final(struct MD5Context *ctx___1 , unsigned char *digest ) ;
#line 25
void MD5String(unsigned char const   *digest , char *str___1 ) ;
#line 33 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
static char HEXDIGIT[16]  = 
#line 33 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f'};
#line 35
static void MD5Transform(word32 *buf , word32 const   *in ) ;
#line 61 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
void MD5Init(struct MD5Context *ctx___1 ) 
{ 


  {
#line 63
  ctx___1->buf[0] = (word32 )1732584193;
#line 64
  ctx___1->buf[1] = 4023233417U;
#line 65
  ctx___1->buf[2] = 2562383102U;
#line 66
  ctx___1->buf[3] = (word32 )271733878;
#line 68
  ctx___1->bits[0] = (word32 )0;
#line 69
  ctx___1->bits[1] = (word32 )0;
#line 70
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
void MD5Update(struct MD5Context *ctx___1 , unsigned char const   *buf , unsigned int len ) 
{ 
  register word32 t ;
  word32 tmp ;
  unsigned char *p ;

  {
#line 82
  t = ctx___1->bits[0];
#line 83
  tmp = t + (len << 3);
#line 83
  ctx___1->bits[0] = tmp;
#line 83
  if (tmp < t) {
#line 84
    (ctx___1->bits[1]) ++;
  }
#line 85
  ctx___1->bits[1] += len >> 29;
#line 87
  t = (t >> 3) & 63U;
#line 91
  if (t) {
#line 92
    p = ctx___1->in + t;
#line 94
    t = 64U - t;
#line 95
    if (len < t) {
      {
#line 96
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, (size_t )len);
      }
#line 97
      return;
    }
    {
#line 99
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, (size_t )t);
#line 101
    MD5Transform((word32 *)(ctx___1->buf), (word32 const   *)((word32 *)(ctx___1->in)));
#line 102
    buf += t;
#line 103
    len -= t;
    }
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (len >= 64U)) {
#line 107
      goto while_break;
    }
    {
#line 108
    memcpy((void */* __restrict  */)(ctx___1->in), (void const   */* __restrict  */)buf,
           (size_t )64);
#line 110
    MD5Transform((word32 *)(ctx___1->buf), (word32 const   *)((word32 *)(ctx___1->in)));
#line 111
    buf += 64;
#line 112
    len -= 64U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  memcpy((void */* __restrict  */)(ctx___1->in), (void const   */* __restrict  */)buf,
         (size_t )len);
  }
#line 118
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
void MD5Final(struct MD5Context *ctx___1 , unsigned char *digest ) 
{ 
  unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 130
  count = (ctx___1->bits[0] >> 3) & 63U;
#line 134
  p = ctx___1->in + count;
#line 135
  tmp = p;
#line 135
  p ++;
#line 135
  *tmp = (unsigned char)128;
#line 138
  count = 63U - count;
#line 141
  if (count < 8U) {
    {
#line 143
    memset((void *)p, 0, (size_t )count);
#line 145
    MD5Transform((word32 *)(ctx___1->buf), (word32 const   *)((word32 *)(ctx___1->in)));
#line 148
    memset((void *)(ctx___1->in), 0, (size_t )56);
    }
  } else {
    {
#line 151
    memset((void *)p, 0, (size_t )(count - 8U));
    }
  }
  {
#line 156
  *((word32 *)(ctx___1->in) + 14) = ctx___1->bits[0];
#line 157
  *((word32 *)(ctx___1->in) + 15) = ctx___1->bits[1];
#line 159
  MD5Transform((word32 *)(ctx___1->buf), (word32 const   *)((word32 *)(ctx___1->in)));
  }
#line 162
  if ((unsigned long )digest != (unsigned long )((void *)0)) {
    {
#line 163
    memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx___1->buf),
           (size_t )16);
    }
  }
  {
#line 164
  memset((void *)ctx___1, 0, sizeof(ctx___1));
  }
#line 165
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
void MD5String(unsigned char const   *digest , char *str___1 ) 
{ 
  unsigned char const   *pd ;
  unsigned char const   *end ;
  char *ps ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 173
  end = digest + 16;
#line 174
  pd = digest;
#line 174
  ps = str___1;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )pd != (unsigned long )end)) {
#line 174
      goto while_break;
    }
#line 175
    tmp = ps;
#line 175
    ps ++;
#line 175
    *tmp = HEXDIGIT[(int const   )*pd / 16];
#line 176
    tmp___0 = ps;
#line 176
    ps ++;
#line 176
    *tmp___0 = HEXDIGIT[(int const   )*pd % 16];
#line 174
    pd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  *ps = (char )'\000';
#line 179
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
static void MD5Transform(word32 *buf , word32 const   *in ) 
{ 
  register word32 a ;
  register word32 b ;
  register word32 c ;
  register word32 d ;

  {
#line 203
  a = *(buf + 0);
#line 204
  b = *(buf + 1);
#line 205
  c = *(buf + 2);
#line 206
  d = *(buf + 3);
#line 208
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 0)) + 3614090360U;
#line 208
  a = (a << 7) | (a >> 25);
#line 208
  a += b;
#line 209
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 1)) + 3905402710U;
#line 209
  d = (d << 12) | (d >> 20);
#line 209
  d += a;
#line 210
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 2)) + 606105819U;
#line 210
  c = (c << 17) | (c >> 15);
#line 210
  c += d;
#line 211
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 3)) + 3250441966U;
#line 211
  b = (b << 22) | (b >> 10);
#line 211
  b += c;
#line 212
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 4)) + 4118548399U;
#line 212
  a = (a << 7) | (a >> 25);
#line 212
  a += b;
#line 213
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 5)) + 1200080426U;
#line 213
  d = (d << 12) | (d >> 20);
#line 213
  d += a;
#line 214
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 6)) + 2821735955U;
#line 214
  c = (c << 17) | (c >> 15);
#line 214
  c += d;
#line 215
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 7)) + 4249261313U;
#line 215
  b = (b << 22) | (b >> 10);
#line 215
  b += c;
#line 216
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 8)) + 1770035416U;
#line 216
  a = (a << 7) | (a >> 25);
#line 216
  a += b;
#line 217
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 9)) + 2336552879U;
#line 217
  d = (d << 12) | (d >> 20);
#line 217
  d += a;
#line 218
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 10)) + 4294925233U;
#line 218
  c = (c << 17) | (c >> 15);
#line 218
  c += d;
#line 219
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 11)) + 2304563134U;
#line 219
  b = (b << 22) | (b >> 10);
#line 219
  b += c;
#line 220
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 12)) + 1804603682U;
#line 220
  a = (a << 7) | (a >> 25);
#line 220
  a += b;
#line 221
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 13)) + 4254626195U;
#line 221
  d = (d << 12) | (d >> 20);
#line 221
  d += a;
#line 222
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 14)) + 2792965006U;
#line 222
  c = (c << 17) | (c >> 15);
#line 222
  c += d;
#line 223
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 15)) + 1236535329U;
#line 223
  b = (b << 22) | (b >> 10);
#line 223
  b += c;
#line 225
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 1)) + 4129170786U;
#line 225
  a = (a << 5) | (a >> 27);
#line 225
  a += b;
#line 226
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 6)) + 3225465664U;
#line 226
  d = (d << 9) | (d >> 23);
#line 226
  d += a;
#line 227
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 11)) + 643717713U;
#line 227
  c = (c << 14) | (c >> 18);
#line 227
  c += d;
#line 228
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 0)) + 3921069994U;
#line 228
  b = (b << 20) | (b >> 12);
#line 228
  b += c;
#line 229
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 5)) + 3593408605U;
#line 229
  a = (a << 5) | (a >> 27);
#line 229
  a += b;
#line 230
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 10)) + 38016083U;
#line 230
  d = (d << 9) | (d >> 23);
#line 230
  d += a;
#line 231
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 15)) + 3634488961U;
#line 231
  c = (c << 14) | (c >> 18);
#line 231
  c += d;
#line 232
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 4)) + 3889429448U;
#line 232
  b = (b << 20) | (b >> 12);
#line 232
  b += c;
#line 233
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 9)) + 568446438U;
#line 233
  a = (a << 5) | (a >> 27);
#line 233
  a += b;
#line 234
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 14)) + 3275163606U;
#line 234
  d = (d << 9) | (d >> 23);
#line 234
  d += a;
#line 235
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 3)) + 4107603335U;
#line 235
  c = (c << 14) | (c >> 18);
#line 235
  c += d;
#line 236
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 8)) + 1163531501U;
#line 236
  b = (b << 20) | (b >> 12);
#line 236
  b += c;
#line 237
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 13)) + 2850285829U;
#line 237
  a = (a << 5) | (a >> 27);
#line 237
  a += b;
#line 238
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 2)) + 4243563512U;
#line 238
  d = (d << 9) | (d >> 23);
#line 238
  d += a;
#line 239
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 7)) + 1735328473U;
#line 239
  c = (c << 14) | (c >> 18);
#line 239
  c += d;
#line 240
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 12)) + 2368359562U;
#line 240
  b = (b << 20) | (b >> 12);
#line 240
  b += c;
#line 242
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 5)) + 4294588738U;
#line 242
  a = (a << 4) | (a >> 28);
#line 242
  a += b;
#line 243
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 8)) + 2272392833U;
#line 243
  d = (d << 11) | (d >> 21);
#line 243
  d += a;
#line 244
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 11)) + 1839030562U;
#line 244
  c = (c << 16) | (c >> 16);
#line 244
  c += d;
#line 245
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 14)) + 4259657740U;
#line 245
  b = (b << 23) | (b >> 9);
#line 245
  b += c;
#line 246
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 1)) + 2763975236U;
#line 246
  a = (a << 4) | (a >> 28);
#line 246
  a += b;
#line 247
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 4)) + 1272893353U;
#line 247
  d = (d << 11) | (d >> 21);
#line 247
  d += a;
#line 248
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 7)) + 4139469664U;
#line 248
  c = (c << 16) | (c >> 16);
#line 248
  c += d;
#line 249
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 10)) + 3200236656U;
#line 249
  b = (b << 23) | (b >> 9);
#line 249
  b += c;
#line 250
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 13)) + 681279174U;
#line 250
  a = (a << 4) | (a >> 28);
#line 250
  a += b;
#line 251
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 0)) + 3936430074U;
#line 251
  d = (d << 11) | (d >> 21);
#line 251
  d += a;
#line 252
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 3)) + 3572445317U;
#line 252
  c = (c << 16) | (c >> 16);
#line 252
  c += d;
#line 253
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 6)) + 76029189U;
#line 253
  b = (b << 23) | (b >> 9);
#line 253
  b += c;
#line 254
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 9)) + 3654602809U;
#line 254
  a = (a << 4) | (a >> 28);
#line 254
  a += b;
#line 255
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 12)) + 3873151461U;
#line 255
  d = (d << 11) | (d >> 21);
#line 255
  d += a;
#line 256
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 15)) + 530742520U;
#line 256
  c = (c << 16) | (c >> 16);
#line 256
  c += d;
#line 257
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 2)) + 3299628645U;
#line 257
  b = (b << 23) | (b >> 9);
#line 257
  b += c;
#line 259
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 0)) + 4096336452U;
#line 259
  a = (a << 6) | (a >> 26);
#line 259
  a += b;
#line 260
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 7)) + 1126891415U;
#line 260
  d = (d << 10) | (d >> 22);
#line 260
  d += a;
#line 261
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 14)) + 2878612391U;
#line 261
  c = (c << 15) | (c >> 17);
#line 261
  c += d;
#line 262
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 5)) + 4237533241U;
#line 262
  b = (b << 21) | (b >> 11);
#line 262
  b += c;
#line 263
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 12)) + 1700485571U;
#line 263
  a = (a << 6) | (a >> 26);
#line 263
  a += b;
#line 264
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 3)) + 2399980690U;
#line 264
  d = (d << 10) | (d >> 22);
#line 264
  d += a;
#line 265
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 10)) + 4293915773U;
#line 265
  c = (c << 15) | (c >> 17);
#line 265
  c += d;
#line 266
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 1)) + 2240044497U;
#line 266
  b = (b << 21) | (b >> 11);
#line 266
  b += c;
#line 267
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 8)) + 1873313359U;
#line 267
  a = (a << 6) | (a >> 26);
#line 267
  a += b;
#line 268
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 15)) + 4264355552U;
#line 268
  d = (d << 10) | (d >> 22);
#line 268
  d += a;
#line 269
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 6)) + 2734768916U;
#line 269
  c = (c << 15) | (c >> 17);
#line 269
  c += d;
#line 270
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 13)) + 1309151649U;
#line 270
  b = (b << 21) | (b >> 11);
#line 270
  b += c;
#line 271
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 4)) + 4149444226U;
#line 271
  a = (a << 6) | (a >> 26);
#line 271
  a += b;
#line 272
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 11)) + 3174756917U;
#line 272
  d = (d << 10) | (d >> 22);
#line 272
  d += a;
#line 273
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 2)) + 718787259U;
#line 273
  c = (c << 15) | (c >> 17);
#line 273
  c += d;
#line 274
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 9)) + 3951481745U;
#line 274
  b = (b << 21) | (b >> 11);
#line 274
  b += c;
#line 276
  *(buf + 0) += a;
#line 277
  *(buf + 1) += b;
#line 278
  *(buf + 2) += c;
#line 279
  *(buf + 3) += d;
#line 280
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 47 "./getopt.h"
extern char *optarg ;
#line 61
extern int optind ;
#line 145
extern int getopt(int ___argc , char * const  *___argv , char const   *__shortopts ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 104 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.h"
void set_verbosity(int v ) ;
#line 60 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.h"
void keepalive_write(void) ;
#line 63
void keepalive_write_finish(void) ;
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS___0[1]  = {      (char *)"md5"};
#line 144
void checksum_init(struct proto_params  const  *params ) ;
#line 157
void checksum_process(void const   *buffer , unsigned int const   len ) ;
#line 171
char *checksum_finish(void) ;
#line 186
char *checksum_exchange(void) ;
#line 200
int checksum_validate(void) ;
#line 68 "/home/wheatley/newnew/temp/netrw-1.3.2/src/netwrite.c"
static void usage(char *prog_name ) 
{ 


  {
  {
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage\n  %s [udp] <options> <host> <port>\n\nDefault TCP protocol can be changed to UDP by ``udp\'\' argument.\nUDP options\n  currently none\nTCP options\n  -f               firewall mode, connection is initiated by netread.\n                   Host specification is ignored and can be omited.\n  -c               ignored. Transmission checksum is activated by\n                   default.\n  -C algorithm     use the specified algorithm for checksum. This\n                   option also implies -c.\n                   Supported algorithms (the first is default):\n                       md5 none\ngeneral options\n  -i <file>        read data from file instead of stdin.\n  -b               print speed in b/s instead of B/s\n  -h <n>           print `#\' after each n KiB transferred (def. 10485.76).\n  -H <n>           print `#\' after each n MiB transferred (def. 10.24).\n  -q               be quiet.\n  -v               be verbose.\n  -vv              be very verbose.\n  -V               show version.\n  -vV              show verbose version.\nreturn values\n  0                no errors.\n  1                some error occured.\n  2                checksum validation failed.\n",
          prog_name);
#line 89
  exit(1);
  }
}
}
#line 92 "/home/wheatley/newnew/temp/netrw-1.3.2/src/netwrite.c"
int main(int argc , char **argv ) 
{ 
  int udp ;
  int opt ;
  int firewall ;
  char *host ;
  char *service ;
  char buf[1 << 14] ;
  ssize_t count ;
  struct proto_params params ;
  int fd ;
  char const   *file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int index___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int wr ;
  char *p ;
  ssize_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *sum ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 94
  udp = 0;
#line 96
  firewall = 0;
#line 97
  host = (char *)((void *)0);
#line 98
  service = (char *)((void *)0);
#line 102
  fd = 0;
#line 103
  file = (char const   *)((void *)0);
#line 105
  if (argc < 2) {
    {
#line 106
    usage(*(argv + 0));
    }
  }
  {
#line 108
  tmp = strmatch((char const   *)*(argv + 1), "udp");
  }
#line 108
  if (tmp) {
#line 109
    udp = 1;
#line 110
    *(argv + 1) = *(argv + 0);
  }
  {
#line 113
  params_initialize(& params);
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    opt = getopt(argc - udp, (char * const  *)(argv + udp), "fi:VbH:h:qvcC:");
    }
#line 115
    if (! (opt != -1)) {
#line 115
      goto while_break;
    }
    {
#line 119
    if (opt == 102) {
#line 119
      goto case_102;
    }
#line 125
    if (opt == 105) {
#line 125
      goto case_105;
    }
#line 129
    if (opt == 86) {
#line 129
      goto case_86;
    }
#line 130
    if (opt == 98) {
#line 130
      goto case_98;
    }
#line 131
    if (opt == 72) {
#line 131
      goto case_72;
    }
#line 131
    if (opt == 104) {
#line 131
      goto case_104;
    }
#line 132
    if (opt == 113) {
#line 132
      goto case_113;
    }
#line 132
    if (opt == 118) {
#line 132
      goto case_118;
    }
#line 133
    if (opt == 99) {
#line 133
      goto case_99;
    }
#line 133
    if (opt == 67) {
#line 133
      goto case_67;
    }
#line 135
    if (opt == 63) {
#line 135
      goto case_63;
    }
#line 118
    goto switch_break;
    case_102: /* CIL Label */ 
#line 120
    if (udp) {
      {
#line 121
      usage(*(argv + 0));
      }
    }
#line 122
    firewall = 1;
#line 123
    goto switch_break;
    case_105: /* CIL Label */ 
#line 126
    file = (char const   *)optarg;
#line 127
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 129
    puts("netrw tools version 1.3.2 (2006/08/15 20:32 UTC)\nCopyright (C) 2002--2006 Jiri Denemark\n\nbuilt by root@GLaDOS (2016/03/04 06:09 UTC)\nbuilt-in extensions:\n  checksum (built-in; activated by default):\n    md5");
#line 129
    print(1, (char *)"\nConfigure info:\n%s\n\nConfigure command:\n%s\n", "  target      x86_64-unknown-linux-gnu\n  byte order  little-endian\n  prefix      /usr/local\n  CPPFLAGS\n  CFLAGS      -O3 -g\n  LIBS\n  LDFLAGS",
          "  \'./configure\'");
    }
#line 129
    return (0);
#line 129
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 130
    progress_speed_bps();
    }
#line 130
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 131
    tmp___0 = atoi((char const   *)optarg);
#line 131
    progress_hash_after((unsigned long )((tmp___0 * 1024) * 1024));
    }
#line 131
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 131
    tmp___1 = atoi((char const   *)optarg);
#line 131
    progress_hash_after((unsigned long )(tmp___1 * 1024));
    }
#line 131
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 132
    set_verbosity(-2);
    }
#line 132
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 132
    set_verbosity(1);
    }
#line 132
    goto switch_break;
    case_99: /* CIL Label */ 
#line 133
    goto switch_break;
    case_67: /* CIL Label */ 
#line 133
    if (udp) {
      {
#line 133
      usage(*(argv + 0));
      }
    }
#line 133
    index___0 = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! ((unsigned long )index___0 < sizeof(CHECKSUMS___0) / sizeof(char *))) {
#line 133
        goto while_break___0;
      }
      {
#line 133
      tmp___2 = strmatch((char const   *)optarg, (char const   *)CHECKSUMS___0[index___0]);
      }
#line 133
      if (tmp___2) {
#line 133
        params.checksum = index___0;
#line 133
        goto while_break___0;
      }
#line 133
      index___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    if ((unsigned long )index___0 == sizeof(CHECKSUMS___0) / sizeof(char *)) {
      {
#line 133
      tmp___3 = strmatch((char const   *)optarg, "none");
      }
#line 133
      if (tmp___3) {
#line 133
        params.checksum = -1;
      } else {
        {
#line 133
        params.checksum = 0;
#line 133
        print(-1, (char *)"unknown checksum algorithm ``%s\'\', using ``%s\'\'\n",
              optarg, CHECKSUMS___0[0]);
        }
      }
    }
#line 133
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 136
    usage(*(argv + 0));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (optind + udp >= argc) {
    {
#line 141
    usage(*(argv + 0));
    }
  }
#line 143
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
#line 143
    fd = open(file, 0);
    }
#line 143
    if (fd == -1) {
      {
#line 144
      tmp___4 = __errno_location();
#line 144
      tmp___5 = strerror(*tmp___4);
#line 144
      print(-2, (char *)"Cannot open input file: %s: %s\n", tmp___5, file);
      }
#line 146
      return (1);
    }
  }
#line 149
  if (firewall) {
#line 150
    if ((optind + udp) + 1 < argc) {
#line 151
      service = *(argv + ((optind + udp) + 1));
    } else {
#line 153
      service = *(argv + (optind + udp));
    }
#line 154
    if ((unsigned long )service == (unsigned long )((void *)0)) {
      {
#line 155
      usage(*(argv + 0));
      }
    }
  } else {
#line 158
    if ((optind + udp) + 1 >= argc) {
      {
#line 161
      usage(*(argv + 0));
      }
    } else {
#line 158
      host = *(argv + (optind + udp));
#line 158
      if ((unsigned long )host == (unsigned long )((void *)0)) {
        {
#line 161
        usage(*(argv + 0));
        }
      } else {
#line 158
        service = *(argv + ((optind + udp) + 1));
#line 158
        if ((unsigned long )service == (unsigned long )((void *)0)) {
          {
#line 161
          usage(*(argv + 0));
          }
        }
      }
    }
    {
#line 163
    tmp___6 = set_host(host);
    }
#line 163
    if (tmp___6 == -1) {
#line 164
      return (1);
    }
  }
#line 167
  if (udp) {
#line 167
    tmp___7 = 0;
  } else {
#line 167
    tmp___7 = 1;
  }
  {
#line 167
  tmp___8 = set_service(service, (enum transport_protocol )tmp___7);
  }
#line 167
  if (tmp___8 == -1) {
#line 168
    return (1);
  }
#line 171
  if (udp) {
    {
#line 172
    tmp___9 = create_data_socket((enum connection_mode )2);
    }
#line 172
    if (tmp___9 == -1) {
#line 173
      return (1);
    }
    {
#line 175
    print(1, (char *)"UDP protocol requested\n");
#line 176
    params_clear(& params);
    }
  } else
#line 178
  if (firewall) {
    {
#line 179
    tmp___10 = create_data_socket((enum connection_mode )3);
    }
#line 179
    if (tmp___10 == -1) {
#line 180
      return (1);
    }
  } else {
    {
#line 183
    tmp___11 = create_data_socket((enum connection_mode )2);
    }
#line 183
    if (tmp___11 == -1) {
#line 184
      return (1);
    }
  }
#line 187
  if (! udp) {
    {
#line 188
    tmp___13 = create_control_socket();
    }
#line 188
    if (tmp___13 == -1) {
#line 188
      goto _L;
    } else {
      {
#line 188
      tmp___14 = proto_initialize((enum party )-1);
      }
#line 188
      if (tmp___14 == -1) {
#line 188
        goto _L;
      } else {
        {
#line 188
        tmp___15 = proto_complete_init(& params);
        }
#line 188
        if (tmp___15 == -1) {
          _L: /* CIL Label */ 
          {
#line 191
          tmp___12 = have_control_socket();
          }
#line 191
          if (tmp___12) {
            {
#line 192
            proto_finalize();
#line 193
            print(-2, (char *)"Closing control connection\n");
#line 194
            close_control_socket();
            }
          }
          {
#line 197
          params_clear(& params);
          }
        }
      }
    }
  }
#line 201
  if (params.checksum != -1) {
    {
#line 202
    checksum_init((struct proto_params  const  *)(& params));
    }
  }
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 204
    count = read(fd, (void *)(buf), (size_t )(1 << 14));
    }
#line 204
    if (! (count > 0L)) {
#line 204
      goto while_break___1;
    }
#line 208
    if (params.checksum != -1) {
      {
#line 209
      checksum_process((void const   *)((void *)(buf)), (unsigned int const   )count);
      }
    }
#line 211
    p = buf;
    {
#line 211
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 211
      tmp___16 = data_write((void const   *)p, (size_t )count);
#line 211
      wr = (int )tmp___16;
      }
#line 211
      if (! (wr > 0)) {
#line 211
        goto while_break___2;
      }
      {
#line 212
      progress_data((unsigned long )wr);
#line 214
      count -= (ssize_t )wr;
      }
#line 214
      if (! count) {
#line 215
        goto while_break___2;
      }
#line 211
      p += wr;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    if (wr < 0) {
      {
#line 218
      progress_summary();
      }
#line 219
      return (1);
    }
#line 222
    if (params.keepalive == 1) {
      {
#line 223
      keepalive_write();
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 226
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
#line 227
    close(fd);
    }
  }
  {
#line 229
  progress_summary();
  }
#line 231
  if (count < 0L) {
    {
#line 232
    tmp___17 = __errno_location();
#line 232
    tmp___18 = strerror(*tmp___17);
#line 232
    print(-2, (char *)"Cannot read data: %s\n", tmp___18);
    }
#line 233
    return (1);
  }
#line 236
  if (params.keepalive == 1) {
    {
#line 237
    keepalive_write_finish();
    }
  }
  {
#line 239
  close_data_socket();
  }
#line 241
  if (params.checksum != -1) {
    {
#line 244
    print(0, (char *)"\n");
#line 245
    sum = checksum_finish();
    }
#line 245
    if ((unsigned long )sum == (unsigned long )((void *)0)) {
#line 246
      sum = (char *)"failed";
    }
    {
#line 247
    print(1, (char *)"transmission checksum: %s\n", sum);
#line 248
    sum = checksum_exchange();
    }
#line 248
    if ((unsigned long )sum == (unsigned long )((void *)0)) {
#line 249
      sum = (char *)"failed";
    }
    {
#line 250
    print(1, (char *)"remote party checksum: %s\n", sum);
#line 252
    tmp___19 = checksum_validate();
    }
#line 252
    if (tmp___19 == 0) {
      {
#line 253
      print(0, (char *)"%s checksum validation successful\n", CHECKSUMS___0[params.checksum]);
      }
    } else {
      {
#line 257
      print(-1, (char *)"%s checksum validation failed\n", CHECKSUMS___0[params.checksum]);
      }
#line 259
      return (2);
    }
  }
  {
#line 263
  tmp___20 = have_control_socket();
  }
#line 263
  if (tmp___20) {
    {
#line 264
    proto_finalize();
#line 265
    close_control_socket();
    }
  }
#line 268
  return (0);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 43 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
static int verbosity  =    0;
#line 45 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
void set_verbosity(int v ) 
{ 


  {
  {
#line 48
  if (v == -2) {
#line 48
    goto case_neg_2;
  }
#line 51
  if (v == 1) {
#line 51
    goto case_1;
  }
#line 47
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 49
  verbosity = -2;
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 52
  verbosity ++;
#line 53
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
int can_print(int verbose_level ) 
{ 


  {
#line 59
  return (verbosity >= verbose_level);
}
}
#line 62 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
void print(int verbose_level , char *msg  , ...) 
{ 
  va_list args ;
  int tmp ;

  {
#line 66
  if (! msg) {
#line 67
    return;
  } else {
    {
#line 66
    tmp = can_print(verbose_level);
    }
#line 66
    if (! tmp) {
#line 67
      return;
    }
  }
  {
#line 70
  if (verbose_level == -2) {
#line 70
    goto case_neg_2;
  }
#line 73
  if (verbose_level == -1) {
#line 73
    goto case_neg_1;
  }
#line 69
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: ");
  }
#line 72
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: ");
  }
#line 75
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 82
  __builtin_va_start(args, msg);
#line 83
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 84
  __builtin_va_end(args);
#line 86
  fflush(stderr);
  }
#line 87
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
char *get_word(char **line ) 
{ 
  char *word ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((int )*(*line) == 32)) {
#line 98
      goto while_break;
    }
#line 99
    (*line) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  word = *line;
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if ((int )*(*line) != 32) {
#line 102
      if (! ((int )*(*line) != 0)) {
#line 102
        goto while_break___0;
      }
    } else {
#line 102
      goto while_break___0;
    }
#line 103
    (*line) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  if ((int )*(*line) == 32) {
#line 105
    *(*line) = (char )'\000';
#line 106
    (*line) ++;
  }
#line 109
  if ((int )*(word + 0) == 0) {
#line 110
    return ((char *)((void *)0));
  } else {
#line 112
    return (word);
  }
}
}
#line 115 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
int line_header(char **line , char *header ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 117
  tmp = strlen((char const   *)header);
#line 117
  len = (int )tmp;
#line 119
  tmp___0 = strncmp((char const   *)*line, (char const   *)header, (size_t )len);
  }
#line 119
  if (tmp___0 != 0) {
#line 122
    return (-1);
  } else {
    {
#line 119
    tmp___1 = strlen((char const   *)*line);
    }
#line 119
    if (tmp___1 <= (size_t )len) {
#line 122
      return (-1);
    } else
#line 119
    if ((int )*(*line + len) != 58) {
#line 122
      return (-1);
    } else {
#line 124
      *line += len + 1;
#line 125
      return (0);
    }
  }
}
}
#line 130 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
int strmatch(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
#line 132
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 133
    return (0);
  } else
#line 132
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 133
    return (0);
  } else {
    {
#line 135
    tmp = strcmp(s1, s2);
    }
#line 135
    return (tmp == 0);
  }
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS___1[1]  = {      (char *)"md5"};
#line 43 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static int type  =    -1;
#line 46 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char HEXDIGIT___0[16]  = 
#line 46
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f'};
#line 48 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static void checksum_hash_to_string(unsigned char *hash , char *checksum___1 , int len ) 
{ 
  unsigned char const   *src ;
  unsigned char const   *end ;
  char *dst ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 56
  end = (unsigned char const   *)(hash + len);
#line 57
  src = (unsigned char const   *)hash;
#line 57
  dst = checksum___1;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )src != (unsigned long )end)) {
#line 57
      goto while_break;
    }
#line 58
    tmp = dst;
#line 58
    dst ++;
#line 58
    *tmp = HEXDIGIT___0[(int const   )*src / 16];
#line 59
    tmp___0 = dst;
#line 59
    dst ++;
#line 59
    *tmp___0 = HEXDIGIT___0[(int const   )*src % 16];
#line 57
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  *dst = (char )'\000';
#line 62
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static struct MD5Context ctx  ;
#line 153 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char checksum[33]  ;
#line 154 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char remote_sum[33]  ;
#line 160 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
void checksum_init(struct proto_params  const  *params ) 
{ 


  {
  {
#line 162
  type = (int )params->checksum;
#line 164
  memset((void *)(checksum), '\000', sizeof(checksum));
#line 165
  memset((void *)(remote_sum), '\000', sizeof(remote_sum));
#line 174
  MD5Init(& ctx);
  }
#line 176
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
void checksum_process(void const   *buffer , unsigned int const   len ) 
{ 


  {
  {
#line 187
  MD5Update(& ctx, (unsigned char const   *)buffer, (unsigned int )len);
  }
#line 189
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
char *checksum_finish(void) 
{ 
  unsigned char sig[16] ;

  {
  {
#line 205
  MD5Final(& ctx, sig);
#line 206
  checksum_hash_to_string(sig, checksum, 16);
  }
#line 209
  return (checksum);
}
}
#line 212 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
char *checksum_exchange(void) 
{ 
  char header[100] ;
  char *line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 217
  tmp = have_control_socket();
  }
#line 217
  if (! tmp) {
#line 218
    return ((char *)((void *)0));
  }
  {
#line 220
  snprintf((char */* __restrict  */)(header), (size_t )100, (char const   */* __restrict  */)"%s(%s)",
           "checksum", CHECKSUMS___1[type]);
#line 222
  tmp___0 = control_writef((enum send_mode )1, (char *)"%s: %s", header, checksum);
  }
#line 222
  if (tmp___0 == -1) {
    {
#line 224
    print(-2, (char *)"Cannot send %s checksum\n", CHECKSUMS___1[type]);
    }
#line 225
    return ((char *)((void *)0));
  }
  {
#line 228
  line = control_read();
  }
#line 228
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 229
    print(-2, (char *)"Cannot read %s checksum\n", CHECKSUMS___1[type]);
    }
#line 230
    return ((char *)((void *)0));
  }
  {
#line 233
  tmp___1 = line_header(& line, header);
  }
#line 233
  if (tmp___1 == -1) {
    {
#line 236
    print(-2, (char *)"Invalid checksum specification: ``%s\'\'\n", line);
    }
#line 237
    return ((char *)((void *)0));
  } else
#line 233
  if ((int )*line != 32) {
    {
#line 236
    print(-2, (char *)"Invalid checksum specification: ``%s\'\'\n", line);
    }
#line 237
    return ((char *)((void *)0));
  } else {
    {
#line 233
    line ++;
#line 233
    tmp___2 = strlen((char const   *)line);
    }
#line 233
    if (tmp___2 != 32UL) {
      {
#line 236
      print(-2, (char *)"Invalid checksum specification: ``%s\'\'\n", line);
      }
#line 237
      return ((char *)((void *)0));
    }
  }
  {
#line 240
  strncpy((char */* __restrict  */)(remote_sum), (char const   */* __restrict  */)line,
          (size_t )32);
  }
#line 242
  return (remote_sum);
}
}
#line 245 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
int checksum_validate(void) 
{ 
  int tmp ;

  {
  {
#line 247
  tmp = memcmp((void const   *)((void *)(checksum)), (void const   *)((void *)(remote_sum)),
               (size_t )32);
  }
#line 247
  if (tmp == 0) {
#line 248
    return (0);
  } else {
#line 250
    return (-1);
  }
}
}
#line 254 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
void checksum_proto_param_options(char *options , struct proto_params *req_params___1 ,
                                  struct proto_params *params ) 
{ 
  int i ;
  int opt ;
  char *option ;
  int tmp ;

  {
#line 259
  opt = -1;
#line 263
  if (req_params___1->checksum == 0) {
#line 263
    if (params->checksum == -1) {
#line 265
      return;
    }
  }
#line 268
  if (req_params___1->checksum == 2) {
    {
#line 270
    req_params___1->checksum = 3;
#line 271
    print(-1, (char *)"Checksum parameter redefined; ignored\n");
    }
#line 272
    return;
  } else
#line 268
  if (req_params___1->checksum == 3) {
    {
#line 270
    req_params___1->checksum = 3;
#line 271
    print(-1, (char *)"Checksum parameter redefined; ignored\n");
    }
#line 272
    return;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 275
    option = get_word(& options);
    }
#line 275
    if (! ((unsigned long )option != (unsigned long )((void *)0))) {
#line 275
      goto while_break;
    }
#line 276
    i = 0;
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      if (! ((unsigned long )i < sizeof(CHECKSUMS___1) / sizeof(char *))) {
#line 276
        goto while_break___0;
      }
      {
#line 277
      tmp = strmatch((char const   *)option, (char const   *)CHECKSUMS___1[i]);
      }
#line 277
      if (tmp) {
#line 278
        goto while_break___0;
      }
#line 276
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    if ((unsigned long )i == sizeof(CHECKSUMS___1) / sizeof(char *)) {
#line 281
      goto while_continue;
    }
#line 283
    if (opt == -1) {
#line 284
      opt = i;
    } else
#line 283
    if (params->checksum == i) {
#line 284
      opt = i;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if (opt > -1) {
    {
#line 288
    print(1, (char *)"negotiated checksum algorithm: %s\n", CHECKSUMS___1[opt]);
#line 289
    params->checksum = opt;
    }
  } else {
    {
#line 292
    print(-1, (char *)"Your party doesn\'t offer any suitable checksum algorithm; checksum disabled\n");
#line 294
    params->checksum = -1;
    }
  }
#line 297
  req_params___1->checksum = 2;
#line 298
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
void checksum_proto_check(struct proto_params *req_params___1 , struct proto_params *params ) 
{ 


  {
#line 303
  if (req_params___1->checksum == 1) {
    {
#line 304
    print(-1, (char *)"Your party requires checksum but doesn\'t support any checksum algorithm; checksum disabled\n");
#line 306
    params->checksum = -1;
    }
  } else
#line 308
  if (req_params___1->checksum == 0) {
#line 308
    if (params->checksum != -1) {
      {
#line 310
      print(-1, (char *)"Your party doesn\'t know anything about checksum parameter you have requested; checksum disabled\n");
#line 312
      params->checksum = -1;
      }
    }
  }
#line 314
  return;
}
}
#line 316 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
int checksum_proto_accept_option(char *option , struct proto_params *req_params___1 ,
                                 struct proto_params *params ) 
{ 
  int i ;
  int tmp ;

  {
#line 323
  if (req_params___1->checksum == 2) {
    {
#line 325
    req_params___1->checksum = 3;
#line 326
    print(-1, (char *)"Checksum parameter redefined; ignored\n");
    }
#line 327
    return (0);
  } else
#line 323
  if (req_params___1->checksum == 3) {
    {
#line 325
    req_params___1->checksum = 3;
#line 326
    print(-1, (char *)"Checksum parameter redefined; ignored\n");
    }
#line 327
    return (0);
  }
#line 330
  if ((unsigned long )option != (unsigned long )((void *)0)) {
#line 331
    i = 0;
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! ((unsigned long )i < sizeof(CHECKSUMS___1) / sizeof(char *))) {
#line 331
        goto while_break;
      }
      {
#line 332
      tmp = strmatch((char const   *)option, (char const   *)CHECKSUMS___1[i]);
      }
#line 332
      if (tmp) {
#line 333
        params->checksum = i;
#line 334
        goto while_break;
      }
#line 331
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 339
  if (params->checksum == -1) {
    {
#line 340
    print(-2, (char *)"Checksum algorithm negotiation failed\n");
    }
#line 341
    return (-1);
  } else {
    {
#line 344
    print(1, (char *)"negotiated checksum algorithm: %s\n", CHECKSUMS___1[params->checksum]);
    }
  }
#line 348
  return (0);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 66 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.h"
void keepalive_read(void) ;
#line 69
void keepalive_read_finish(void) ;
#line 62 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
static time_t last  =    (time_t )0;
#line 63 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
static int finished  =    0;
#line 66 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
void keepalive_proto_check(struct proto_params *req_params___1 , struct proto_params *params ) 
{ 


  {
#line 69
  if (req_params___1->keepalive == 1) {
    {
#line 70
    params->keepalive = 1;
#line 71
    print(1, (char *)"will send keep-alive packets through control connection\n");
    }
  } else {
    {
#line 75
    params->keepalive = 0;
#line 76
    print(-1, (char *)"Remote party has no support for keep-alive packets\n");
#line 77
    print(-1, (char *)"Expect problems with control connection and stupid firewalls\n");
    }
  }
#line 80
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
void keepalive_write(void) 
{ 
  time_t now ;
  time_t tmp ;

  {
  {
#line 85
  tmp = time((time_t *)((void *)0));
#line 85
  now = tmp;
  }
#line 87
  if (last + 60L <= now) {
    {
#line 88
    last = now;
#line 89
    control_writef((enum send_mode )1, (char *)"%s: %ld", "keepalive", last);
    }
  }
#line 91
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
void keepalive_write_finish(void) 
{ 


  {
  {
#line 96
  control_writef((enum send_mode )1, (char *)"%s: %s\n", "keepalive", "finished");
  }
#line 98
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
void keepalive_read(void) 
{ 
  char *line ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 105
  if (finished) {
#line 106
    return;
  } else {
    {
#line 105
    tmp = control_check_read();
    }
#line 105
    if (tmp == -1) {
#line 106
      return;
    }
  }
  {
#line 108
  line = control_read();
  }
#line 108
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 109
    finished = 1;
#line 110
    return;
  }
  {
#line 113
  tmp___0 = line_header(& line, (char *)"keepalive");
  }
#line 113
  if (tmp___0 == -1) {
    {
#line 114
    print(-1, (char *)"Keep-alive packet expected: ``%s\'\'\n", line);
    }
#line 115
    return;
  }
  {
#line 118
  tmp___1 = get_word(& line);
#line 118
  tmp___2 = strmatch((char const   *)tmp___1, "finished");
  }
#line 118
  if (tmp___2) {
#line 119
    finished = 1;
  }
#line 120
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
void keepalive_read_finish(void) 
{ 
  char *line ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (! finished)) {
#line 127
      goto while_break;
    }
    {
#line 128
    keepalive_read();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  line = control_read();
  }
#line 131
  if ((unsigned long )line != (unsigned long )((void *)0)) {
#line 131
    if ((int )*line != 0) {
      {
#line 132
      print(-1, (char *)"Empty line expected: ``%s\'\'\n", line);
      }
    }
  }
#line 133
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS___2[1]  = {      (char *)"md5"};
#line 42 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.h"
static char *PARAMS___0[2]  = {      (char *)"checksum",      (char *)"keepalive"};
#line 63 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static char str___0[1024]  ;
#line 64 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static int state___0  =    0;
#line 67
static void get_params___0(struct proto_params *params , char *line ) ;
#line 68
static void param_options___0(int param , char *options , struct proto_params *req_params___1 ,
                              struct proto_params *params ) ;
#line 72
static int accept_option___0(int param , char *options , struct proto_params *req_params___1 ,
                             struct proto_params *params ) ;
#line 141 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static struct proto_params req_params___0  =    {0, 0};
#line 325 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static void get_params___0(struct proto_params *params , char *line ) 
{ 
  char *word ;
  int i ;
  int tmp ;

  {
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 330
    word = get_word(& line);
    }
#line 330
    if (! ((unsigned long )word != (unsigned long )((void *)0))) {
#line 330
      goto while_break;
    }
#line 331
    i = 0;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! ((unsigned long )i < sizeof(PARAMS___0) / sizeof(char *))) {
#line 331
        goto while_break___0;
      }
      {
#line 332
      tmp = strmatch((char const   *)word, (char const   *)PARAMS___0[i]);
      }
#line 332
      if (tmp) {
#line 333
        goto while_break___0;
      }
#line 331
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    if (i == 0) {
#line 337
      goto case_0;
    }
#line 341
    if (i == 1) {
#line 341
      goto case_1;
    }
#line 345
    goto switch_default;
    case_0: /* CIL Label */ 
#line 338
    params->checksum = 1;
#line 339
    goto switch_break;
    case_1: /* CIL Label */ 
#line 342
    params->keepalive = 1;
#line 343
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 346
    print(-1, (char *)"Unknown connection parameter requested: ``%s\'\'; ignored\n",
          word);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 352 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static void param_options___0(int param , char *options , struct proto_params *req_params___1 ,
                              struct proto_params *params ) 
{ 


  {
  {
#line 358
  if (param == 0) {
#line 358
    goto case_0;
  }
#line 357
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 359
  checksum_proto_param_options(options, req_params___1, params);
  }
#line 360
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/netrw-1.3.2/src/proto.c"
static int accept_option___0(int param , char *options , struct proto_params *req_params___1 ,
                             struct proto_params *params ) 
{ 
  char *option ;
  int tmp ;

  {
  {
#line 371
  option = get_word(& options);
  }
  {
#line 374
  if (param == 0) {
#line 374
    goto case_0;
  }
#line 377
  if (param == 1) {
#line 377
    goto case_1;
  }
#line 373
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 375
  tmp = checksum_proto_accept_option(option, req_params___1, params);
  }
#line 375
  return (tmp);
  case_1: /* CIL Label */ 
#line 378
  req_params___1->keepalive = 1;
#line 379
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 382
  return (-1);
}
}
#line 86 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static enum connection_mode conn_mode___0  ;
#line 87 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static enum transport_protocol trans_protocol___0  ;
#line 88 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *tp_str___0  =    (char *)((void *)0);
#line 89 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static unsigned short port___0  =    (unsigned short)0;
#line 90 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static struct in_addr ip___0  ;
#line 93 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_listen___0  =    -1;
#line 94 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_control___0  =    -1;
#line 95 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int s_data___0  =    -1;
#line 98 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *r_buf___0  ;
#line 99 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *r_tmp___0  ;
#line 100 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int r_bufpos___0  =    0;
#line 101 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int r_buflen___0  =    0;
#line 102 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *w_buf___0  ;
#line 103 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static char *w_tmp___0  ;
#line 104 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int w_buflen___0  =    0;
#line 587 "/home/wheatley/newnew/temp/netrw-1.3.2/src/net.c"
static int closed___0  =    0;
#line 49 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static int bps___0  =    0;
#line 50 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static char unit___0  =    (char )'B';
#line 51 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long after___0  =    10737418UL;
#line 52 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long hashes___0  =    0ULL;
#line 53 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long bytes___0  =    0ULL;
#line 54 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static unsigned long long bytes_line___0  =    0ULL;
#line 55 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static struct timeval start___0  ;
#line 56 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static struct timeval start_line___0  ;
#line 60
static void print_bytes___0(unsigned long long bytes___1 ) ;
#line 61
static double print_speed___0(int line ) ;
#line 136 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static void print_bytes___0(unsigned long long bytes___1 ) 
{ 


  {
#line 139
  if (bytes___1 >= 1152921504606846976ULL) {
    {
#line 140
    print(0, (char *)"%7.2f EiB", (double )bytes___1 / (1.0 * (double )1152921504606846976ULL));
    }
  } else
#line 141
  if (bytes___1 >= 1125899906842624ULL) {
    {
#line 142
    print(0, (char *)"%7.2f PiB", (double )bytes___1 / (1.0 * (double )1125899906842624ULL));
    }
  } else
#line 143
  if (bytes___1 >= 1099511627776ULL) {
    {
#line 144
    print(0, (char *)"%7.2f TiB", (double )bytes___1 / (1.0 * (double )1099511627776ULL));
    }
  } else
#line 147
  if (bytes___1 >= 1073741824ULL) {
    {
#line 148
    print(0, (char *)"%7.2f GiB", (double )bytes___1 / (1.0 * (double )1073741824ULL));
    }
  } else
#line 149
  if (bytes___1 >= 1048576ULL) {
    {
#line 150
    print(0, (char *)"%7.2f MiB", (double )bytes___1 / (1.0 * (double )1048576ULL));
    }
  } else
#line 151
  if (bytes___1 >= 1024ULL) {
    {
#line 152
    print(0, (char *)"%7.2f KiB", (double )bytes___1 / (1.0 * (double )1024ULL));
    }
  } else {
    {
#line 154
    print(0, (char *)"%7d B", (int )bytes___1);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/netrw-1.3.2/src/progress.c"
static double print_speed___0(int line ) 
{ 
  double speed ;
  double diff ;
  struct timeval tv ;
  struct timeval now ;
  unsigned long long tmp ;
  int tmp___0 ;

  {
#line 164
  if (line) {
#line 164
    tv = start_line___0;
  } else {
#line 164
    tv = start___0;
  }
  {
#line 165
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 166
  diff = ((double )now.tv_sec + (double )now.tv_usec / 1000000.0) - ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
  }
#line 168
  if (diff == (double )0) {
#line 168
    diff = 0.001;
  } else {
#line 168
    diff = diff;
  }
#line 170
  if (line) {
#line 170
    tmp = bytes_line___0;
  } else {
#line 170
    tmp = bytes___0;
  }
#line 170
  if (bps___0) {
#line 170
    tmp___0 = 8;
  } else {
#line 170
    tmp___0 = 1;
  }
#line 170
  speed = (double )tmp / (diff / (double )tmp___0);
#line 173
  if (speed > (double )1152921504606846976ULL) {
    {
#line 174
    print(0, (char *)"%6.1f Ei%c/s", speed / (1.0 * (double )1152921504606846976ULL),
          (int )unit___0);
    }
  } else
#line 175
  if (speed > (double )1125899906842624ULL) {
    {
#line 176
    print(0, (char *)"%6.1f Pi%c/s", speed / (1.0 * (double )1125899906842624ULL),
          (int )unit___0);
    }
  } else
#line 177
  if (speed > (double )1099511627776ULL) {
    {
#line 178
    print(0, (char *)"%6.1f Ti%c/s", speed / (1.0 * (double )1099511627776ULL), (int )unit___0);
    }
  } else
#line 181
  if (speed > (double )1073741824ULL) {
    {
#line 182
    print(0, (char *)"%6.1f Gi%c/s", speed / (1.0 * (double )1073741824ULL), (int )unit___0);
    }
  } else
#line 183
  if (speed > (double )1048576ULL) {
    {
#line 184
    print(0, (char *)"%6.1f Mi%c/s", speed / (1.0 * (double )1048576ULL), (int )unit___0);
    }
  } else
#line 185
  if (speed > (double )1024ULL) {
    {
#line 186
    print(0, (char *)"%6.1f Ki%c/s", speed / (1.0 * (double )1024ULL), (int )unit___0);
    }
  } else {
    {
#line 188
    print(0, (char *)"%6.1f %c/s", speed, (int )unit___0);
    }
  }
#line 190
  return (diff);
}
}
#line 33 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
static char HEXDIGIT___1[16]  = 
#line 33 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f'};
#line 35
static void MD5Transform___0(word32 *buf , word32 const   *in ) ;
#line 199 "/home/wheatley/newnew/temp/netrw-1.3.2/src/md5.c"
static void MD5Transform___0(word32 *buf , word32 const   *in ) 
{ 
  register word32 a ;
  register word32 b ;
  register word32 c ;
  register word32 d ;

  {
#line 203
  a = *(buf + 0);
#line 204
  b = *(buf + 1);
#line 205
  c = *(buf + 2);
#line 206
  d = *(buf + 3);
#line 208
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 0)) + 3614090360U;
#line 208
  a = (a << 7) | (a >> 25);
#line 208
  a += b;
#line 209
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 1)) + 3905402710U;
#line 209
  d = (d << 12) | (d >> 20);
#line 209
  d += a;
#line 210
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 2)) + 606105819U;
#line 210
  c = (c << 17) | (c >> 15);
#line 210
  c += d;
#line 211
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 3)) + 3250441966U;
#line 211
  b = (b << 22) | (b >> 10);
#line 211
  b += c;
#line 212
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 4)) + 4118548399U;
#line 212
  a = (a << 7) | (a >> 25);
#line 212
  a += b;
#line 213
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 5)) + 1200080426U;
#line 213
  d = (d << 12) | (d >> 20);
#line 213
  d += a;
#line 214
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 6)) + 2821735955U;
#line 214
  c = (c << 17) | (c >> 15);
#line 214
  c += d;
#line 215
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 7)) + 4249261313U;
#line 215
  b = (b << 22) | (b >> 10);
#line 215
  b += c;
#line 216
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 8)) + 1770035416U;
#line 216
  a = (a << 7) | (a >> 25);
#line 216
  a += b;
#line 217
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 9)) + 2336552879U;
#line 217
  d = (d << 12) | (d >> 20);
#line 217
  d += a;
#line 218
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 10)) + 4294925233U;
#line 218
  c = (c << 17) | (c >> 15);
#line 218
  c += d;
#line 219
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 11)) + 2304563134U;
#line 219
  b = (b << 22) | (b >> 10);
#line 219
  b += c;
#line 220
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 12)) + 1804603682U;
#line 220
  a = (a << 7) | (a >> 25);
#line 220
  a += b;
#line 221
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 13)) + 4254626195U;
#line 221
  d = (d << 12) | (d >> 20);
#line 221
  d += a;
#line 222
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 14)) + 2792965006U;
#line 222
  c = (c << 17) | (c >> 15);
#line 222
  c += d;
#line 223
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 15)) + 1236535329U;
#line 223
  b = (b << 22) | (b >> 10);
#line 223
  b += c;
#line 225
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 1)) + 4129170786U;
#line 225
  a = (a << 5) | (a >> 27);
#line 225
  a += b;
#line 226
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 6)) + 3225465664U;
#line 226
  d = (d << 9) | (d >> 23);
#line 226
  d += a;
#line 227
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 11)) + 643717713U;
#line 227
  c = (c << 14) | (c >> 18);
#line 227
  c += d;
#line 228
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 0)) + 3921069994U;
#line 228
  b = (b << 20) | (b >> 12);
#line 228
  b += c;
#line 229
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 5)) + 3593408605U;
#line 229
  a = (a << 5) | (a >> 27);
#line 229
  a += b;
#line 230
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 10)) + 38016083U;
#line 230
  d = (d << 9) | (d >> 23);
#line 230
  d += a;
#line 231
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 15)) + 3634488961U;
#line 231
  c = (c << 14) | (c >> 18);
#line 231
  c += d;
#line 232
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 4)) + 3889429448U;
#line 232
  b = (b << 20) | (b >> 12);
#line 232
  b += c;
#line 233
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 9)) + 568446438U;
#line 233
  a = (a << 5) | (a >> 27);
#line 233
  a += b;
#line 234
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 14)) + 3275163606U;
#line 234
  d = (d << 9) | (d >> 23);
#line 234
  d += a;
#line 235
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 3)) + 4107603335U;
#line 235
  c = (c << 14) | (c >> 18);
#line 235
  c += d;
#line 236
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 8)) + 1163531501U;
#line 236
  b = (b << 20) | (b >> 12);
#line 236
  b += c;
#line 237
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 13)) + 2850285829U;
#line 237
  a = (a << 5) | (a >> 27);
#line 237
  a += b;
#line 238
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 2)) + 4243563512U;
#line 238
  d = (d << 9) | (d >> 23);
#line 238
  d += a;
#line 239
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 7)) + 1735328473U;
#line 239
  c = (c << 14) | (c >> 18);
#line 239
  c += d;
#line 240
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 12)) + 2368359562U;
#line 240
  b = (b << 20) | (b >> 12);
#line 240
  b += c;
#line 242
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 5)) + 4294588738U;
#line 242
  a = (a << 4) | (a >> 28);
#line 242
  a += b;
#line 243
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 8)) + 2272392833U;
#line 243
  d = (d << 11) | (d >> 21);
#line 243
  d += a;
#line 244
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 11)) + 1839030562U;
#line 244
  c = (c << 16) | (c >> 16);
#line 244
  c += d;
#line 245
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 14)) + 4259657740U;
#line 245
  b = (b << 23) | (b >> 9);
#line 245
  b += c;
#line 246
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 1)) + 2763975236U;
#line 246
  a = (a << 4) | (a >> 28);
#line 246
  a += b;
#line 247
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 4)) + 1272893353U;
#line 247
  d = (d << 11) | (d >> 21);
#line 247
  d += a;
#line 248
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 7)) + 4139469664U;
#line 248
  c = (c << 16) | (c >> 16);
#line 248
  c += d;
#line 249
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 10)) + 3200236656U;
#line 249
  b = (b << 23) | (b >> 9);
#line 249
  b += c;
#line 250
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 13)) + 681279174U;
#line 250
  a = (a << 4) | (a >> 28);
#line 250
  a += b;
#line 251
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 0)) + 3936430074U;
#line 251
  d = (d << 11) | (d >> 21);
#line 251
  d += a;
#line 252
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 3)) + 3572445317U;
#line 252
  c = (c << 16) | (c >> 16);
#line 252
  c += d;
#line 253
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 6)) + 76029189U;
#line 253
  b = (b << 23) | (b >> 9);
#line 253
  b += c;
#line 254
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 9)) + 3654602809U;
#line 254
  a = (a << 4) | (a >> 28);
#line 254
  a += b;
#line 255
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 12)) + 3873151461U;
#line 255
  d = (d << 11) | (d >> 21);
#line 255
  d += a;
#line 256
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 15)) + 530742520U;
#line 256
  c = (c << 16) | (c >> 16);
#line 256
  c += d;
#line 257
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 2)) + 3299628645U;
#line 257
  b = (b << 23) | (b >> 9);
#line 257
  b += c;
#line 259
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 0)) + 4096336452U;
#line 259
  a = (a << 6) | (a >> 26);
#line 259
  a += b;
#line 260
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 7)) + 1126891415U;
#line 260
  d = (d << 10) | (d >> 22);
#line 260
  d += a;
#line 261
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 14)) + 2878612391U;
#line 261
  c = (c << 15) | (c >> 17);
#line 261
  c += d;
#line 262
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 5)) + 4237533241U;
#line 262
  b = (b << 21) | (b >> 11);
#line 262
  b += c;
#line 263
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 12)) + 1700485571U;
#line 263
  a = (a << 6) | (a >> 26);
#line 263
  a += b;
#line 264
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 3)) + 2399980690U;
#line 264
  d = (d << 10) | (d >> 22);
#line 264
  d += a;
#line 265
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 10)) + 4293915773U;
#line 265
  c = (c << 15) | (c >> 17);
#line 265
  c += d;
#line 266
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 1)) + 2240044497U;
#line 266
  b = (b << 21) | (b >> 11);
#line 266
  b += c;
#line 267
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 8)) + 1873313359U;
#line 267
  a = (a << 6) | (a >> 26);
#line 267
  a += b;
#line 268
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 15)) + 4264355552U;
#line 268
  d = (d << 10) | (d >> 22);
#line 268
  d += a;
#line 269
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 6)) + 2734768916U;
#line 269
  c = (c << 15) | (c >> 17);
#line 269
  c += d;
#line 270
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 13)) + 1309151649U;
#line 270
  b = (b << 21) | (b >> 11);
#line 270
  b += c;
#line 271
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 4)) + 4149444226U;
#line 271
  a = (a << 6) | (a >> 26);
#line 271
  a += b;
#line 272
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 11)) + 3174756917U;
#line 272
  d = (d << 10) | (d >> 22);
#line 272
  d += a;
#line 273
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 2)) + 718787259U;
#line 273
  c = (c << 15) | (c >> 17);
#line 273
  c += d;
#line 274
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 9)) + 3951481745U;
#line 274
  b = (b << 21) | (b >> 11);
#line 274
  b += c;
#line 276
  *(buf + 0) += a;
#line 277
  *(buf + 1) += b;
#line 278
  *(buf + 2) += c;
#line 279
  *(buf + 3) += d;
#line 280
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/netrw-1.3.2/src/common.c"
static int verbosity___0  =    0;
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS___3[1]  = {      (char *)"md5"};
#line 43 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static int type___0  =    -1;
#line 46 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char HEXDIGIT___2[16]  = 
#line 46
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f'};
#line 48 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static void checksum_hash_to_string___0(unsigned char *hash , char *checksum___1 ,
                                        int len ) 
{ 
  unsigned char const   *src ;
  unsigned char const   *end ;
  char *dst ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 56
  end = (unsigned char const   *)(hash + len);
#line 57
  src = (unsigned char const   *)hash;
#line 57
  dst = checksum___1;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )src != (unsigned long )end)) {
#line 57
      goto while_break;
    }
#line 58
    tmp = dst;
#line 58
    dst ++;
#line 58
    *tmp = HEXDIGIT___2[(int const   )*src / 16];
#line 59
    tmp___0 = dst;
#line 59
    dst ++;
#line 59
    *tmp___0 = HEXDIGIT___2[(int const   )*src % 16];
#line 57
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  *dst = (char )'\000';
#line 62
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static struct MD5Context ctx___0  ;
#line 153 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char checksum___0[33]  ;
#line 154 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.c"
static char remote_sum___0[33]  ;
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/checksum.h"
static char *CHECKSUMS___4[1]  = {      (char *)"md5"};
#line 67 "/home/wheatley/newnew/temp/netrw-1.3.2/src/netread.c"
static void usage___0(char *prog_name ) 
{ 


  {
  {
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage\n  %s [udp] <options> <port>\n\nDefault TCP protocol can be changed to UDP by ``udp\'\' argument.\nUDP options\n  currently none\nTCP options\n  -f <host>        firewall mode, connection is initiated by netread.\n  -c               ignored. Transmission checksum is activated by\n                   default.\n  -C algorithm     use the specified algorithm for checksum. This\n                   option also implies -c.\n                   Supported algorithms (the first is default):\n                       md5 none\ngeneral options\n  -o <file>        write data to file instead of stdout.\n  -s               in case -o option is specified, open the file for\n                   synchronous I/O. Otherwise, this option has no effect.\n  -b               print speed in b/s instead of B/s\n  -h <n>           print `#\' after each n KiB transferred (def. 10485.76).\n  -H <n>           print `#\' after each n MiB transferred (def. 10.24).\n  -q               be quiet.\n  -v               be verbose.\n  -vv              be very verbose.\n  -V               show version.\n  -vV              show verbose version.\nreturn values\n  0                no errors.\n  1                some error occured.\n  2                checksum validation failed.\n",
          prog_name);
#line 89
  exit(1);
  }
}
}
#line 62 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
static time_t last___0  =    (time_t )0;
#line 63 "/home/wheatley/newnew/temp/netrw-1.3.2/src/keepalive.c"
static int finished___0  =    0;
