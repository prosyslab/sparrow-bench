/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 175 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
struct _ip_addresses {
   char ip[16] ;
   char dev[16] ;
   struct _ip_addresses *prev ;
   struct _ip_addresses *next ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_37 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_38 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_37 ifr_ifrn ;
   union __anonunion_ifr_ifru_38 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_39 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_39 ifc_ifcu ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 297
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 363
extern struct protoent *getprotobynumber(int __proto ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 45 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.h"
int get_protocol(char *line , char *protocol ) ;
#line 46
int get_connection_state(char *line , char *state ) ;
#line 47
void process_entry(char *line ) ;
#line 48
void check_src_dst(char *protocol , char *src_ip , char *dst_ip , char *src_port ,
                   char *dst_port , char *nathostip , char *nathostport , char *status ) ;
#line 49
void store_data(char *protocol , char *src_ip , char *dst_ip , char *src_port , char *dst_port ,
                char *nathostip , char *nathostport , char *status ) ;
#line 50
void extract_ip(char *gen_buffer ) ;
#line 51
void display_help(void) ;
#line 52
int lookup_hostname(char **r_host ) ;
#line 53
int lookup_ip(char *hostname , size_t hostname_size ) ;
#line 55
int check_if_source(char *host ) ;
#line 56
int check_if_destination(char *host ) ;
#line 57
void lookup_portname(char **port , char *proto ) ;
#line 59
static void *xrealloc(void *oldbuf , size_t newbufsize ) ;
#line 60
static void *xcalloc(size_t bufsize ) ;
#line 61
void get_protocol_name(char *protocol_name , int protocol_nr ) ;
#line 62
char *xstrdup(char const   *dup___0 ) ;
#line 63
void ip_addresses_add(struct _ip_addresses **list , char const   *dev , char const   *ip ) ;
#line 64
int ip_addresses_search(struct _ip_addresses *list , char const   *ip ) ;
#line 65
void ip_addresses_free(struct _ip_addresses **node ) ;
#line 185 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
char SRC_IP[50]  ;
#line 186 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
char DST_IP[50]  ;
#line 187 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int SNAT  =    1;
#line 188 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int DNAT  =    1;
#line 189 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int LOCAL  =    0;
#line 190 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int ROUTED  =    0;
#line 191 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static char PROTOCOL[4]  ;
#line 192 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int connection_index  =    0;
#line 193 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
char ***connection_table  ;
#line 194 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
struct _ip_addresses *IpAddresses  =    (struct _ip_addresses *)((void *)0);
#line 200
int main(int argc , char **argv ) ;
#line 200 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static int SORT_ROW  =    1;
#line 201
int main(int argc , char **argv ) ;
#line 201 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static int EXT_VIEW  =    0;
#line 202
int main(int argc , char **argv ) ;
#line 202 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static int RESOLVE  =    1;
#line 203
int main(int argc , char **argv ) ;
#line 203 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static int no_hdr  =    0;
#line 204
int main(int argc , char **argv ) ;
#line 204 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static int NAT_HOP  =    0;
#line 197 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int main(int argc , char **argv ) 
{ 
  char const   *args ;
  FILE *f ;
  char line[350] ;
  char src[50] ;
  char dst[50] ;
  char host[50] ;
  char buf[100] ;
  char buf2[100] ;
  char from[50] ;
  unsigned int tmp ;
  char nathost[50] ;
  unsigned int tmp___0 ;
  char dest[50] ;
  unsigned int tmp___1 ;
  char *ret ;
  char ***pa ;
  char *store ;
  int index___0 ;
  int a ;
  int b ;
  int c ;
  int j ;
  int r ;
  struct ifconf ifc ;
  struct ifreq *req ;
  struct sockaddr_in *ipaddr ;
  char *ifbuf ;
  char *ptr ;
  int lastlen ;
  int len ;
  int sock ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 199
  args = "hnp:s:d:SDxor:L?vNR";
#line 212
  from[0] = (char )'N';
#line 212
  from[1] = (char )'A';
#line 212
  from[2] = (char )'T';
#line 212
  from[3] = (char )'e';
#line 212
  from[4] = (char )'d';
#line 212
  from[5] = (char )' ';
#line 212
  from[6] = (char )'A';
#line 212
  from[7] = (char )'d';
#line 212
  from[8] = (char )'d';
#line 212
  from[9] = (char )'r';
#line 212
  from[10] = (char )'e';
#line 212
  from[11] = (char )'s';
#line 212
  from[12] = (char )'s';
#line 212
  from[13] = (char )'\000';
#line 212
  tmp = 14U;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (tmp >= 50U) {
#line 212
      goto while_break;
    }
#line 212
    from[tmp] = (char)0;
#line 212
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  nathost[0] = (char )'N';
#line 213
  nathost[1] = (char )'A';
#line 213
  nathost[2] = (char )'T';
#line 213
  nathost[3] = (char )'-';
#line 213
  nathost[4] = (char )'h';
#line 213
  nathost[5] = (char )'o';
#line 213
  nathost[6] = (char )'s';
#line 213
  nathost[7] = (char )'t';
#line 213
  nathost[8] = (char )' ';
#line 213
  nathost[9] = (char )'A';
#line 213
  nathost[10] = (char )'d';
#line 213
  nathost[11] = (char )'d';
#line 213
  nathost[12] = (char )'r';
#line 213
  nathost[13] = (char )'e';
#line 213
  nathost[14] = (char )'s';
#line 213
  nathost[15] = (char )'s';
#line 213
  nathost[16] = (char )'\000';
#line 213
  tmp___0 = 17U;
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (tmp___0 >= 50U) {
#line 213
      goto while_break___0;
    }
#line 213
    nathost[tmp___0] = (char)0;
#line 213
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  dest[0] = (char )'D';
#line 214
  dest[1] = (char )'e';
#line 214
  dest[2] = (char )'s';
#line 214
  dest[3] = (char )'t';
#line 214
  dest[4] = (char )'i';
#line 214
  dest[5] = (char )'n';
#line 214
  dest[6] = (char )'a';
#line 214
  dest[7] = (char )'t';
#line 214
  dest[8] = (char )'i';
#line 214
  dest[9] = (char )'o';
#line 214
  dest[10] = (char )'n';
#line 214
  dest[11] = (char )' ';
#line 214
  dest[12] = (char )'A';
#line 214
  dest[13] = (char )'d';
#line 214
  dest[14] = (char )'d';
#line 214
  dest[15] = (char )'r';
#line 214
  dest[16] = (char )'e';
#line 214
  dest[17] = (char )'s';
#line 214
  dest[18] = (char )'s';
#line 214
  dest[19] = (char )'\000';
#line 214
  tmp___1 = 20U;
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 214
    if (tmp___1 >= 50U) {
#line 214
      goto while_break___1;
    }
#line 214
    dest[tmp___1] = (char)0;
#line 214
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 230
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 230
    c = getopt(argc, (char * const  *)argv, args);
    }
#line 230
    if (! (c != -1)) {
#line 230
      goto while_break___2;
    }
    {
#line 232
    if (c == 104) {
#line 232
      goto case_104;
    }
#line 235
    if (c == 63) {
#line 235
      goto case_63;
    }
#line 238
    if (c == 118) {
#line 238
      goto case_118;
    }
#line 241
    if (c == 110) {
#line 241
      goto case_110;
    }
#line 244
    if (c == 112) {
#line 244
      goto case_112;
    }
#line 247
    if (c == 115) {
#line 247
      goto case_115;
    }
#line 251
    if (c == 100) {
#line 251
      goto case_100;
    }
#line 255
    if (c == 83) {
#line 255
      goto case_83;
    }
#line 258
    if (c == 68) {
#line 258
      goto case_68;
    }
#line 261
    if (c == 76) {
#line 261
      goto case_76;
    }
#line 267
    if (c == 82) {
#line 267
      goto case_82;
    }
#line 273
    if (c == 120) {
#line 273
      goto case_120;
    }
#line 276
    if (c == 111) {
#line 276
      goto case_111;
    }
#line 279
    if (c == 78) {
#line 279
      goto case_78;
    }
#line 282
    if (c == 114) {
#line 282
      goto case_114;
    }
#line 231
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 233
    display_help();
    }
#line 234
    return (1);
    case_63: /* CIL Label */ 
    {
#line 236
    display_help();
    }
#line 237
    return (1);
    case_118: /* CIL Label */ 
    {
#line 239
    printf((char const   */* __restrict  */)"Version %s\n", "1.4.10");
    }
#line 240
    return (0);
    case_110: /* CIL Label */ 
#line 242
    RESOLVE = 0;
#line 243
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 245
    strncpy((char */* __restrict  */)(PROTOCOL), (char const   */* __restrict  */)optarg,
            sizeof(PROTOCOL) - 1UL);
    }
#line 246
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 248
    strncpy((char */* __restrict  */)(SRC_IP), (char const   */* __restrict  */)optarg,
            sizeof(SRC_IP) - 1UL);
#line 249
    lookup_ip(SRC_IP, sizeof(SRC_IP));
    }
#line 250
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 252
    strncpy((char */* __restrict  */)(DST_IP), (char const   */* __restrict  */)optarg,
            sizeof(DST_IP) - 1UL);
#line 253
    lookup_ip(DST_IP, sizeof(DST_IP));
    }
#line 254
    goto switch_break;
    case_83: /* CIL Label */ 
#line 256
    DNAT = 0;
#line 257
    goto switch_break;
    case_68: /* CIL Label */ 
#line 259
    SNAT = 0;
#line 260
    goto switch_break;
    case_76: /* CIL Label */ 
#line 262
    SNAT = 0;
#line 263
    DNAT = 0;
#line 264
    LOCAL = 1;
#line 265
    ROUTED = 0;
#line 266
    goto switch_break;
    case_82: /* CIL Label */ 
#line 268
    SNAT = 0;
#line 269
    DNAT = 0;
#line 270
    LOCAL = 0;
#line 271
    ROUTED = 1;
#line 272
    goto switch_break;
    case_120: /* CIL Label */ 
#line 274
    EXT_VIEW = 1;
#line 275
    goto switch_break;
    case_111: /* CIL Label */ 
#line 277
    no_hdr = 1;
#line 278
    goto switch_break;
    case_78: /* CIL Label */ 
#line 280
    NAT_HOP = 1;
#line 281
    goto switch_break;
    case_114: /* CIL Label */ 
#line 283
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 284
      display_help();
      }
#line 285
      return (1);
    } else
#line 283
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
      {
#line 284
      display_help();
      }
#line 285
      return (1);
    }
    {
#line 287
    tmp___2 = strcmp((char const   *)optarg, "scr");
    }
#line 287
    if (tmp___2 == 0) {
#line 287
      SORT_ROW = 1;
    }
    {
#line 288
    tmp___3 = strcmp((char const   *)optarg, "dst");
    }
#line 288
    if (tmp___3 == 0) {
#line 288
      SORT_ROW = 2;
    }
    {
#line 289
    tmp___4 = strcmp((char const   *)optarg, "src-port");
    }
#line 289
    if (tmp___4 == 0) {
#line 289
      SORT_ROW = 3;
    }
    {
#line 290
    tmp___5 = strcmp((char const   *)optarg, "dst-port");
    }
#line 290
    if (tmp___5 == 0) {
#line 290
      SORT_ROW = 4;
    }
    {
#line 291
    tmp___6 = strcmp((char const   *)optarg, "state");
    }
#line 291
    if (tmp___6 == 0) {
#line 291
      SORT_ROW = 5;
    }
#line 292
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 296
  if (LOCAL == 1) {
#line 297
    SNAT = 0;
#line 298
    DNAT = 0;
#line 299
    NAT_HOP = 0;
  } else
#line 296
  if (ROUTED == 1) {
#line 297
    SNAT = 0;
#line 298
    DNAT = 0;
#line 299
    NAT_HOP = 0;
  }
#line 302
  if (ROUTED) {
#line 302
    goto _L;
  } else
#line 302
  if (LOCAL) {
    _L: /* CIL Label */ 
    {
#line 305
    sock = socket(2, 2, 0);
#line 306
    lastlen = 0;
#line 307
    len = (int )(100UL * sizeof(struct ifreq ));
    }
    {
#line 308
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 309
      tmp___7 = malloc((size_t )len);
#line 309
      ifbuf = (char *)tmp___7;
      }
#line 309
      if ((unsigned long )ifbuf == (unsigned long )((void *)0)) {
        {
#line 310
        perror("malloc");
#line 311
        exit(1);
        }
      }
      {
#line 313
      ifc.ifc_ifcu.ifcu_buf = ifbuf;
#line 314
      ifc.ifc_len = len;
#line 316
      tmp___9 = ioctl(sock, 35090UL, & ifc);
      }
#line 316
      if (tmp___9 < 0) {
        {
#line 317
        tmp___8 = __errno_location();
        }
#line 317
        if (*tmp___8 != 22) {
          {
#line 318
          perror("ioctl:SIOCGIFCONF");
#line 319
          exit(1);
          }
        } else
#line 317
        if (lastlen != 0) {
          {
#line 318
          perror("ioctl:SIOCGIFCONF");
#line 319
          exit(1);
          }
        }
      } else {
#line 322
        if (ifc.ifc_len == lastlen) {
#line 324
          goto while_break___3;
        }
#line 325
        lastlen = ifc.ifc_len;
      }
      {
#line 328
      len = (int )((unsigned long )len + 10UL * sizeof(struct ifreq ));
#line 329
      free((void *)ifbuf);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 332
    ptr = ifbuf;
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! ((unsigned long )ptr < (unsigned long )(ifbuf + ifc.ifc_len))) {
#line 332
        goto while_break___4;
      }
      {
#line 333
      req = (struct ifreq *)ptr;
#line 334
      ipaddr = (struct sockaddr_in *)(& req->ifr_ifru.ifru_addr);
#line 336
      tmp___10 = inet_ntoa(ipaddr->sin_addr);
#line 336
      ip_addresses_add(& IpAddresses, (char const   *)(req->ifr_ifrn.ifrn_name), (char const   *)tmp___10);
#line 337
      ptr += sizeof(struct ifreq );
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 339
    if (ifbuf) {
      {
#line 340
      free((void *)ifbuf);
      }
    }
  }
  {
#line 344
  tmp___11 = xcalloc(sizeof(char **));
#line 344
  connection_table = (char ***)tmp___11;
#line 346
  f = fopen((char const   */* __restrict  */)"/proc/net/nf_conntrack", (char const   */* __restrict  */)"r");
  }
#line 346
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 347
    f = fopen((char const   */* __restrict  */)"/proc/net/ip_conntrack", (char const   */* __restrict  */)"r");
    }
#line 347
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 348
      printf((char const   */* __restrict  */)"Could not read info about connections from the kernel, make sure netfilter is enabled in kernel or by modules.\n");
      }
#line 349
      return (1);
    }
  }
#line 354
  if (! no_hdr) {
#line 355
    if (LOCAL) {
      {
#line 356
      strncpy((char */* __restrict  */)(from), (char const   */* __restrict  */)"Source Address",
              sizeof(from) - 1UL);
#line 357
      strncpy((char */* __restrict  */)(dest), (char const   */* __restrict  */)"Destination Address",
              sizeof(dest) - 1UL);
      }
    } else
#line 355
    if (ROUTED) {
      {
#line 356
      strncpy((char */* __restrict  */)(from), (char const   */* __restrict  */)"Source Address",
              sizeof(from) - 1UL);
#line 357
      strncpy((char */* __restrict  */)(dest), (char const   */* __restrict  */)"Destination Address",
              sizeof(dest) - 1UL);
      }
    }
#line 359
    if (! EXT_VIEW) {
      {
#line 360
      printf((char const   */* __restrict  */)"%-6s%-31s", "Proto", from);
      }
#line 361
      if (NAT_HOP) {
#line 361
        if (! LOCAL) {
          {
#line 362
          printf((char const   */* __restrict  */)"%-31s", nathost);
          }
        }
      }
      {
#line 364
      printf((char const   */* __restrict  */)"%-31s%-6s", dest, "State");
#line 365
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 367
      printf((char const   */* __restrict  */)"%-6s%-41s", "Proto", from);
      }
#line 368
      if (NAT_HOP) {
#line 368
        if (! LOCAL) {
          {
#line 369
          printf((char const   */* __restrict  */)"%-41s", nathost);
          }
        }
      }
      {
#line 371
      printf((char const   */* __restrict  */)"%-41s%-6s", dest, "State");
#line 372
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 377
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 377
    tmp___13 = feof(f);
    }
#line 377
    if (tmp___13) {
#line 377
      goto while_break___5;
    }
    {
#line 379
    ret = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)f);
#line 380
    tmp___12 = strlen((char const   *)(line));
    }
#line 380
    if (tmp___12 > 0UL) {
      {
#line 381
      process_entry(line);
      }
    }
    {
#line 383
    memset((void *)(line), 0, sizeof(line));
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 385
  fclose(f);
  }
#line 388
  if (connection_index == 0) {
    {
#line 390
    free((void *)connection_table);
#line 391
    ip_addresses_free(& IpAddresses);
    }
#line 392
    return (0);
  }
  {
#line 395
  tmp___14 = xcalloc((unsigned long )connection_index * sizeof(char **));
#line 395
  pa = (char ***)tmp___14;
#line 397
  index___0 = 0;
  }
  {
#line 397
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 397
    if (! (index___0 < connection_index)) {
#line 397
      goto while_break___6;
    }
    {
#line 398
    tmp___15 = xcalloc(8UL * sizeof(char *));
#line 398
    *(pa + index___0) = (char **)tmp___15;
#line 400
    j = 0;
    }
    {
#line 400
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 400
      if (! (j < 8)) {
#line 400
        goto while_break___7;
      }
#line 401
      *(*(pa + index___0) + j) = *(*(connection_table + index___0) + j) + 0;
#line 400
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 397
    index___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 405
  a = 0;
  {
#line 405
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 405
    if (! (a < connection_index - 1)) {
#line 405
      goto while_break___8;
    }
#line 406
    b = a + 1;
    {
#line 406
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 406
      if (! (b < connection_index)) {
#line 406
        goto while_break___9;
      }
      {
#line 407
      r = strcmp((char const   *)*(*(pa + a) + 0), (char const   *)*(*(pa + b) + 0));
      }
#line 408
      if (r > 0) {
#line 409
        j = 0;
        {
#line 409
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 409
          if (! (j < 8)) {
#line 409
            goto while_break___10;
          }
#line 410
          store = *(*(pa + a) + j);
#line 411
          *(*(pa + a) + j) = *(*(pa + b) + j);
#line 412
          *(*(pa + b) + j) = store;
#line 409
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 415
      if (r == 0) {
        {
#line 416
        tmp___16 = strcmp((char const   *)*(*(pa + a) + SORT_ROW), (char const   *)*(*(pa + b) + SORT_ROW));
        }
#line 416
        if (tmp___16 > 0) {
#line 417
          j = 0;
          {
#line 417
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 417
            if (! (j < 8)) {
#line 417
              goto while_break___11;
            }
#line 418
            store = *(*(pa + a) + j);
#line 419
            *(*(pa + a) + j) = *(*(pa + b) + j);
#line 420
            *(*(pa + b) + j) = store;
#line 417
            j ++;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
#line 406
      b ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 405
    a ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 428
  index___0 = 0;
  {
#line 428
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 428
    if (! (index___0 < connection_index)) {
#line 428
      goto while_break___12;
    }
#line 429
    if (RESOLVE) {
      {
#line 430
      lookup_hostname(*(pa + index___0) + 1);
#line 431
      lookup_hostname(*(pa + index___0) + 2);
#line 432
      lookup_hostname(*(pa + index___0) + 6);
#line 433
      tmp___17 = strlen((char const   *)*(*(pa + index___0) + 3));
      }
#line 433
      if (tmp___17 > 0UL) {
        {
#line 434
        lookup_portname(*(pa + index___0) + 3, *(*(pa + index___0) + 0));
#line 435
        lookup_portname(*(pa + index___0) + 4, *(*(pa + index___0) + 0));
#line 436
        lookup_portname(*(pa + index___0) + 7, *(*(pa + index___0) + 0));
        }
      } else {
        {
#line 433
        tmp___18 = strlen((char const   *)*(*(pa + index___0) + 4));
        }
#line 433
        if (tmp___18 > 0UL) {
          {
#line 434
          lookup_portname(*(pa + index___0) + 3, *(*(pa + index___0) + 0));
#line 435
          lookup_portname(*(pa + index___0) + 4, *(*(pa + index___0) + 0));
#line 436
          lookup_portname(*(pa + index___0) + 7, *(*(pa + index___0) + 0));
          }
        } else {
          {
#line 433
          tmp___19 = strlen((char const   *)*(*(pa + index___0) + 7));
          }
#line 433
          if (tmp___19 > 0UL) {
            {
#line 434
            lookup_portname(*(pa + index___0) + 3, *(*(pa + index___0) + 0));
#line 435
            lookup_portname(*(pa + index___0) + 4, *(*(pa + index___0) + 0));
#line 436
            lookup_portname(*(pa + index___0) + 7, *(*(pa + index___0) + 0));
            }
          }
        }
      }
    }
#line 439
    if (! EXT_VIEW) {
      {
#line 440
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
              sizeof(buf) - 1UL);
#line 441
      tmp___20 = strlen((char const   *)*(*(pa + index___0) + 3));
#line 441
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 1),
              29UL - tmp___20);
#line 442
      tmp___21 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
      }
#line 442
      if (tmp___21) {
        {
#line 442
        tmp___22 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
        }
#line 442
        if (tmp___22) {
          {
#line 446
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   buf);
          }
        } else {
          {
#line 443
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 3));
          }
        }
      } else {
        {
#line 443
        snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                 buf, *(*(pa + index___0) + 3));
        }
      }
      {
#line 448
      snprintf((char */* __restrict  */)(src), sizeof(src), (char const   */* __restrict  */)"%-31s",
               buf2);
#line 449
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
              sizeof(buf) - 1UL);
#line 450
      tmp___23 = strlen((char const   *)*(*(pa + index___0) + 4));
#line 450
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 2),
              29UL - tmp___23);
#line 451
      tmp___24 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
      }
#line 451
      if (tmp___24) {
        {
#line 451
        tmp___25 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
        }
#line 451
        if (tmp___25) {
          {
#line 455
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   buf);
          }
        } else {
          {
#line 452
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 4));
          }
        }
      } else {
        {
#line 452
        snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                 buf, *(*(pa + index___0) + 4));
        }
      }
      {
#line 457
      snprintf((char */* __restrict  */)(dst), sizeof(dst), (char const   */* __restrict  */)"%-31s",
               buf2);
      }
#line 458
      if (NAT_HOP) {
        {
#line 459
        strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
                sizeof(buf) - 1UL);
#line 460
        tmp___26 = strlen((char const   *)*(*(pa + index___0) + 7));
#line 460
        strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 6),
                29UL - tmp___26);
#line 461
        tmp___27 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
        }
#line 461
        if (tmp___27) {
          {
#line 461
          tmp___28 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
          }
#line 461
          if (tmp___28) {
            {
#line 465
            snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                     buf);
            }
          } else {
            {
#line 462
            snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                     buf, *(*(pa + index___0) + 7));
            }
          }
        } else {
          {
#line 462
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 7));
          }
        }
        {
#line 467
        snprintf((char */* __restrict  */)(host), sizeof(dst), (char const   */* __restrict  */)"%-31s",
                 buf2);
        }
      }
    } else {
      {
#line 470
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
              sizeof(buf) - 1UL);
#line 471
      tmp___29 = strlen((char const   *)*(*(pa + index___0) + 3));
#line 471
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 1),
              39UL - tmp___29);
#line 472
      tmp___30 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
      }
#line 472
      if (tmp___30) {
        {
#line 472
        tmp___31 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
        }
#line 472
        if (tmp___31) {
          {
#line 476
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   buf);
          }
        } else {
          {
#line 473
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 3));
          }
        }
      } else {
        {
#line 473
        snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                 buf, *(*(pa + index___0) + 3));
        }
      }
      {
#line 478
      snprintf((char */* __restrict  */)(src), sizeof(src), (char const   */* __restrict  */)"%-41s",
               buf2);
#line 479
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
              sizeof(buf) - 1UL);
#line 480
      tmp___32 = strlen((char const   *)*(*(pa + index___0) + 4));
#line 480
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 2),
              39UL - tmp___32);
#line 481
      tmp___33 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
      }
#line 481
      if (tmp___33) {
        {
#line 481
        tmp___34 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
        }
#line 481
        if (tmp___34) {
          {
#line 485
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   buf);
          }
        } else {
          {
#line 482
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 4));
          }
        }
      } else {
        {
#line 482
        snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                 buf, *(*(pa + index___0) + 4));
        }
      }
      {
#line 487
      snprintf((char */* __restrict  */)(dst), sizeof(dst), (char const   */* __restrict  */)"%-41s",
               buf2);
      }
#line 488
      if (NAT_HOP) {
        {
#line 489
        strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"",
                sizeof(buf) - 1UL);
#line 490
        tmp___35 = strlen((char const   *)*(*(pa + index___0) + 7));
#line 490
        strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(*(pa + index___0) + 6),
                39UL - tmp___35);
#line 491
        tmp___36 = strcmp((char const   *)*(*(pa + index___0) + 0), "tcp");
        }
#line 491
        if (tmp___36) {
          {
#line 491
          tmp___37 = strcmp((char const   *)*(*(pa + index___0) + 0), "udp");
          }
#line 491
          if (tmp___37) {
            {
#line 495
            snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                     buf);
            }
          } else {
            {
#line 492
            snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                     buf, *(*(pa + index___0) + 7));
            }
          }
        } else {
          {
#line 492
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s:%s",
                   buf, *(*(pa + index___0) + 7));
          }
        }
        {
#line 497
        snprintf((char */* __restrict  */)(host), sizeof(dst), (char const   */* __restrict  */)"%-41s",
                 buf2);
        }
      }
    }
    {
#line 500
    printf((char const   */* __restrict  */)"%-6s%s", *(*(pa + index___0) + 0), src);
    }
#line 501
    if (NAT_HOP) {
      {
#line 502
      printf((char const   */* __restrict  */)"%s", host);
      }
    }
    {
#line 504
    printf((char const   */* __restrict  */)"%s%-11s", dst, *(*(pa + index___0) + 5));
#line 505
    printf((char const   */* __restrict  */)"\n");
#line 428
    index___0 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 509
  ip_addresses_free(& IpAddresses);
#line 511
  a = 0;
  }
  {
#line 511
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 511
    if (! (a < connection_index)) {
#line 511
      goto while_break___13;
    }
#line 512
    j = 0;
    {
#line 512
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 512
      if (! (j < 8)) {
#line 512
        goto while_break___14;
      }
#line 513
      if ((unsigned long )*(*(connection_table + a) + j) != (unsigned long )((void *)0)) {
        {
#line 513
        free((void *)*(*(connection_table + a) + j));
        }
      }
#line 512
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 515
    free((void *)*(connection_table + a));
#line 516
    free((void *)*(pa + a));
#line 511
    a ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 518
  free((void *)connection_table);
#line 519
  free((void *)pa);
  }
#line 520
  return (0);
}
}
#line 536
int string_search(char *string , char *search ) ;
#line 524 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int get_protocol(char *line , char *protocol ) 
{ 
  int i ;
  int j ;
  int protocol_nr ;
  char protocol_name[11] ;
  unsigned int tmp ;
  char protocol_raw[6] ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 527
  protocol_name[0] = (char )'\000';
#line 527
  tmp = 1U;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (tmp >= 11U) {
#line 527
      goto while_break;
    }
#line 527
    protocol_name[tmp] = (char)0;
#line 527
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  protocol_raw[0] = (char )'\000';
#line 528
  tmp___0 = 1U;
  {
#line 528
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 528
    if (tmp___0 >= 6U) {
#line 528
      goto while_break___0;
    }
#line 528
    protocol_raw[tmp___0] = (char)0;
#line 528
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 530
  tmp___6 = string_search(line, "tcp");
  }
#line 530
  if (tmp___6) {
    {
#line 531
    memcpy((void */* __restrict  */)protocol, (void const   */* __restrict  */)"tcp",
           (size_t )3);
    }
  } else {
    {
#line 533
    tmp___5 = string_search(line, "udp");
    }
#line 533
    if (tmp___5) {
      {
#line 534
      memcpy((void */* __restrict  */)protocol, (void const   */* __restrict  */)"udp",
             (size_t )3);
      }
    } else {
      {
#line 536
      tmp___4 = string_search(line, "icmp");
      }
#line 536
      if (tmp___4) {
        {
#line 537
        memcpy((void */* __restrict  */)protocol, (void const   */* __restrict  */)"icmp",
               (size_t )4);
        }
      } else {
#line 541
        i = 0;
        {
#line 541
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 541
          tmp___3 = strlen((char const   *)line);
          }
#line 541
          if (! ((size_t )i < tmp___3)) {
#line 541
            goto while_break___1;
          }
          {
#line 542
          tmp___2 = strncmp((char const   *)(line + i), "unknown  ", (size_t )9);
          }
#line 542
          if (! tmp___2) {
#line 543
            i += 9;
#line 544
            j = i;
            {
#line 544
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 544
              tmp___1 = strlen((char const   *)line);
              }
#line 544
              if (! ((size_t )j < tmp___1)) {
#line 544
                goto while_break___2;
              }
#line 545
              if ((int )*(line + j) == 32) {
#line 546
                goto while_break___2;
              }
              {
#line 548
              strncat((char */* __restrict  */)(protocol_raw), (char const   */* __restrict  */)(line + j),
                      (size_t )1);
#line 544
              j ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 550
            protocol_nr = atoi((char const   *)(protocol_raw));
#line 551
            get_protocol_name(protocol_name, protocol_nr);
#line 552
            memcpy((void */* __restrict  */)protocol, (void const   */* __restrict  */)(protocol_name),
                   (size_t )5);
            }
#line 553
            goto while_break___1;
          }
#line 541
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 559
  return (0);
}
}
#line 563 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int get_connection_state(char *line , char *state ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 565
  tmp___7 = string_search(line, "ESTABLISHED");
  }
#line 565
  if (tmp___7) {
    {
#line 566
    memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"ESTABLISHED",
           (size_t )11);
    }
  } else {
    {
#line 568
    tmp___6 = string_search(line, "TIME_WAIT");
    }
#line 568
    if (tmp___6) {
      {
#line 569
      memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"TIME_WAIT",
             (size_t )9);
      }
    } else {
      {
#line 571
      tmp___5 = string_search(line, "FIN_WAIT");
      }
#line 571
      if (tmp___5) {
        {
#line 572
        memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"FIN_WAIT",
               (size_t )8);
        }
      } else {
        {
#line 574
        tmp___4 = string_search(line, "SYN_RECV");
        }
#line 574
        if (tmp___4) {
          {
#line 575
          memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"SYN_RECV",
                 (size_t )8);
          }
        } else {
          {
#line 577
          tmp___3 = string_search(line, "SYN_SENT");
          }
#line 577
          if (tmp___3) {
            {
#line 578
            memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"SYN_SENT",
                   (size_t )8);
            }
          } else {
            {
#line 580
            tmp___2 = string_search(line, "UNREPLIED");
            }
#line 580
            if (tmp___2) {
              {
#line 581
              memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"UNREPLIED",
                     (size_t )9);
              }
            } else {
              {
#line 583
              tmp___1 = string_search(line, "CLOSE");
              }
#line 583
              if (tmp___1) {
                {
#line 584
                memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"CLOSE",
                       (size_t )5);
                }
              } else {
                {
#line 586
                tmp___0 = string_search(line, "ASSURED");
                }
#line 586
                if (tmp___0) {
                  {
#line 587
                  memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"ASSURED",
                         (size_t )7);
                  }
                } else {
                  {
#line 590
                  tmp = string_search(line, "udp");
                  }
#line 590
                  if (tmp) {
                    {
#line 591
                    memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)"UNREPLIED",
                           (size_t )9);
                    }
                  } else {
                    {
#line 594
                    memcpy((void */* __restrict  */)state, (void const   */* __restrict  */)" ",
                           (size_t )1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 598
  return (0);
}
}
#line 615
int search_first_hit(char *search , char *line , char *ret ) ;
#line 617
int search_sec_hit(char *search , char *line , char *ret ) ;
#line 601 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void process_entry(char *line ) 
{ 
  int count ;
  char srcip_f[16] ;
  unsigned int tmp ;
  char dstip_f[16] ;
  unsigned int tmp___0 ;
  char srcip_s[16] ;
  unsigned int tmp___1 ;
  char dstip_s[16] ;
  unsigned int tmp___2 ;
  char srcport[6] ;
  unsigned int tmp___3 ;
  char dstport[6] ;
  unsigned int tmp___4 ;
  char srcport_s[6] ;
  unsigned int tmp___5 ;
  char dstport_s[6] ;
  unsigned int tmp___6 ;
  char protocol[5] ;
  unsigned int tmp___7 ;
  char state[12] ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 603
  count = 0;
#line 604
  srcip_f[0] = (char )'\000';
#line 604
  tmp = 1U;
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (tmp >= 16U) {
#line 604
      goto while_break;
    }
#line 604
    srcip_f[tmp] = (char)0;
#line 604
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  dstip_f[0] = (char )'\000';
#line 605
  tmp___0 = 1U;
  {
#line 605
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 605
    if (tmp___0 >= 16U) {
#line 605
      goto while_break___0;
    }
#line 605
    dstip_f[tmp___0] = (char)0;
#line 605
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 606
  srcip_s[0] = (char )'\000';
#line 606
  tmp___1 = 1U;
  {
#line 606
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 606
    if (tmp___1 >= 16U) {
#line 606
      goto while_break___1;
    }
#line 606
    srcip_s[tmp___1] = (char)0;
#line 606
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 607
  dstip_s[0] = (char )'\000';
#line 607
  tmp___2 = 1U;
  {
#line 607
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 607
    if (tmp___2 >= 16U) {
#line 607
      goto while_break___2;
    }
#line 607
    dstip_s[tmp___2] = (char)0;
#line 607
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 608
  srcport[0] = (char )'\000';
#line 608
  tmp___3 = 1U;
  {
#line 608
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 608
    if (tmp___3 >= 6U) {
#line 608
      goto while_break___3;
    }
#line 608
    srcport[tmp___3] = (char)0;
#line 608
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 609
  dstport[0] = (char )'\000';
#line 609
  tmp___4 = 1U;
  {
#line 609
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 609
    if (tmp___4 >= 6U) {
#line 609
      goto while_break___4;
    }
#line 609
    dstport[tmp___4] = (char)0;
#line 609
    tmp___4 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 610
  srcport_s[0] = (char )'\000';
#line 610
  tmp___5 = 1U;
  {
#line 610
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 610
    if (tmp___5 >= 6U) {
#line 610
      goto while_break___5;
    }
#line 610
    srcport_s[tmp___5] = (char)0;
#line 610
    tmp___5 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 611
  dstport_s[0] = (char )'\000';
#line 611
  tmp___6 = 1U;
  {
#line 611
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 611
    if (tmp___6 >= 6U) {
#line 611
      goto while_break___6;
    }
#line 611
    dstport_s[tmp___6] = (char)0;
#line 611
    tmp___6 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 612
  protocol[0] = (char )'\000';
#line 612
  tmp___7 = 1U;
  {
#line 612
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 612
    if (tmp___7 >= 5U) {
#line 612
      goto while_break___7;
    }
#line 612
    protocol[tmp___7] = (char)0;
#line 612
    tmp___7 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 613
  state[0] = (char )'\000';
#line 613
  tmp___8 = 1U;
  {
#line 613
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 613
    if (tmp___8 >= 12U) {
#line 613
      goto while_break___8;
    }
#line 613
    state[tmp___8] = (char)0;
#line 613
    tmp___8 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 615
  search_first_hit("src=", line, srcip_f);
#line 616
  search_first_hit("dst=", line, dstip_f);
#line 617
  search_sec_hit("src=", line, srcip_s);
#line 618
  search_sec_hit("dst=", line, dstip_s);
#line 619
  search_first_hit("sport=", line, srcport);
#line 620
  search_first_hit("dport=", line, dstport);
#line 621
  search_sec_hit("sport=", line, srcport_s);
#line 622
  search_sec_hit("dport=", line, dstport_s);
#line 624
  get_protocol(line, protocol);
#line 625
  tmp___10 = strcmp((char const   *)(PROTOCOL), "");
  }
#line 625
  if (tmp___10) {
    {
#line 626
    tmp___9 = strncmp((char const   *)(PROTOCOL), (char const   *)(protocol), (size_t )3);
    }
#line 626
    if (tmp___9) {
#line 628
      return;
    }
  }
  {
#line 631
  get_connection_state(line, state);
  }
#line 632
  if (SNAT) {
    {
#line 633
    tmp___11 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
    }
#line 633
    if (tmp___11) {
#line 633
      tmp___12 = 0;
    } else {
#line 633
      tmp___12 = 1;
    }
#line 633
    if (tmp___12 == 0) {
      {
#line 633
      tmp___13 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
      }
#line 633
      if (tmp___13 == 0) {
        {
#line 634
        check_src_dst(protocol, srcip_f, dstip_f, srcport, dstport, dstip_s, dstport_s,
                      state);
        }
      }
    }
  }
#line 637
  if (DNAT) {
    {
#line 638
    tmp___14 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
    }
#line 638
    if (tmp___14 == 0) {
      {
#line 638
      tmp___15 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
      }
#line 638
      if (tmp___15) {
#line 638
        tmp___16 = 0;
      } else {
#line 638
        tmp___16 = 1;
      }
#line 638
      if (tmp___16 == 0) {
        {
#line 639
        check_src_dst(protocol, srcip_f, srcip_s, srcport, srcport_s, dstip_f, dstport_s,
                      state);
        }
      }
    }
  }
#line 643
  if (DNAT) {
#line 643
    goto _L;
  } else
#line 643
  if (SNAT) {
    _L: /* CIL Label */ 
    {
#line 644
    tmp___17 = strcmp((char const   *)(srcip_f), (char const   *)(srcip_s));
    }
#line 644
    if (tmp___17) {
#line 644
      tmp___18 = 0;
    } else {
#line 644
      tmp___18 = 1;
    }
#line 644
    if (tmp___18 == 0) {
      {
#line 644
      tmp___19 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
      }
#line 644
      if (tmp___19) {
#line 644
        tmp___20 = 0;
      } else {
#line 644
        tmp___20 = 1;
      }
#line 644
      if (tmp___20 == 0) {
        {
#line 644
        tmp___21 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
        }
#line 644
        if (tmp___21) {
#line 644
          tmp___22 = 0;
        } else {
#line 644
          tmp___22 = 1;
        }
#line 644
        if (tmp___22 == 0) {
          {
#line 644
          tmp___23 = strcmp((char const   *)(dstip_f), (char const   *)(dstip_s));
          }
#line 644
          if (tmp___23) {
#line 644
            tmp___24 = 0;
          } else {
#line 644
            tmp___24 = 1;
          }
#line 644
          if (tmp___24 == 0) {
            {
#line 645
            check_src_dst(protocol, srcip_f, srcip_s, srcport, srcport_s, dstip_s,
                          dstport_s, state);
            }
          }
        }
      }
    }
  }
#line 649
  if (DNAT) {
    {
#line 650
    tmp___25 = strcmp((char const   *)(srcip_f), (char const   *)(srcip_s));
    }
#line 650
    if (tmp___25) {
#line 650
      tmp___26 = 0;
    } else {
#line 650
      tmp___26 = 1;
    }
#line 650
    if (tmp___26 == 0) {
      {
#line 650
      tmp___27 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
      }
#line 650
      if (tmp___27) {
#line 650
        tmp___28 = 0;
      } else {
#line 650
        tmp___28 = 1;
      }
#line 650
      if (tmp___28 == 0) {
        {
#line 650
        tmp___29 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
        }
#line 650
        if (tmp___29) {
#line 650
          tmp___30 = 0;
        } else {
#line 650
          tmp___30 = 1;
        }
#line 650
        if (tmp___30 == 0) {
          {
#line 650
          tmp___31 = strcmp((char const   *)(dstip_f), (char const   *)(dstip_s));
          }
#line 650
          if (tmp___31 == 0) {
            {
#line 651
            check_src_dst(protocol, srcip_f, srcip_s, srcport, srcport_s, dstip_s,
                          dstport_s, state);
            }
          }
        }
      }
    }
  }
#line 654
  if (LOCAL) {
    {
#line 655
    tmp___32 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
    }
#line 655
    if (tmp___32 == 0) {
      {
#line 655
      tmp___33 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
      }
#line 655
      if (tmp___33 == 0) {
        {
#line 655
        tmp___34 = ip_addresses_search(IpAddresses, (char const   *)(srcip_f));
        }
#line 655
        if (tmp___34 == 1) {
          {
#line 658
          check_src_dst(protocol, srcip_f, srcip_s, srcport, dstport, (char *)"",
                        (char *)"", state);
          }
        } else {
          {
#line 655
          tmp___35 = ip_addresses_search(IpAddresses, (char const   *)(srcip_s));
          }
#line 655
          if (tmp___35 == 1) {
            {
#line 658
            check_src_dst(protocol, srcip_f, srcip_s, srcport, dstport, (char *)"",
                          (char *)"", state);
            }
          } else {
            {
#line 655
            tmp___36 = ip_addresses_search(IpAddresses, (char const   *)(dstip_f));
            }
#line 655
            if (tmp___36 == 1) {
              {
#line 658
              check_src_dst(protocol, srcip_f, srcip_s, srcport, dstport, (char *)"",
                            (char *)"", state);
              }
            } else {
              {
#line 655
              tmp___37 = ip_addresses_search(IpAddresses, (char const   *)(dstip_s));
              }
#line 655
              if (tmp___37 == 1) {
                {
#line 658
                check_src_dst(protocol, srcip_f, srcip_s, srcport, dstport, (char *)"",
                              (char *)"", state);
                }
              }
            }
          }
        }
      }
    }
  }
#line 661
  if (ROUTED) {
    {
#line 662
    tmp___38 = strcmp((char const   *)(srcip_f), (char const   *)(dstip_s));
    }
#line 662
    if (tmp___38 == 0) {
      {
#line 662
      tmp___39 = strcmp((char const   *)(dstip_f), (char const   *)(srcip_s));
      }
#line 662
      if (tmp___39 == 0) {
        {
#line 662
        tmp___40 = ip_addresses_search(IpAddresses, (char const   *)(srcip_f));
        }
#line 662
        if (tmp___40 == 0) {
          {
#line 662
          tmp___41 = ip_addresses_search(IpAddresses, (char const   *)(srcip_s));
          }
#line 662
          if (tmp___41 == 0) {
            {
#line 662
            tmp___42 = ip_addresses_search(IpAddresses, (char const   *)(dstip_f));
            }
#line 662
            if (tmp___42 == 0) {
              {
#line 662
              tmp___43 = ip_addresses_search(IpAddresses, (char const   *)(dstip_s));
              }
#line 662
              if (tmp___43 == 0) {
                {
#line 665
                check_src_dst(protocol, srcip_f, srcip_s, srcport, dstport, (char *)"",
                              (char *)"", state);
                }
              }
            }
          }
        }
      }
    }
  }
#line 669
  return;
}
}
#line 674 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void check_src_dst(char *protocol , char *src_ip , char *dst_ip , char *src_port ,
                   char *dst_port , char *nathostip , char *nathostport , char *status ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 676
  tmp___3 = check_if_source(src_ip);
  }
#line 676
  if (tmp___3) {
    {
#line 676
    tmp___4 = strcmp((char const   *)(DST_IP), "");
    }
#line 676
    if (tmp___4 == 0) {
      {
#line 677
      store_data(protocol, src_ip, dst_ip, src_port, dst_port, nathostip, nathostport,
                 status);
      }
    } else {
#line 676
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 679
    tmp___1 = check_if_destination(dst_ip);
    }
#line 679
    if (tmp___1) {
      {
#line 679
      tmp___2 = strcmp((char const   *)(SRC_IP), "");
      }
#line 679
      if (tmp___2 == 0) {
        {
#line 680
        store_data(protocol, src_ip, dst_ip, src_port, dst_port, nathostip, nathostport,
                   status);
        }
      } else {
#line 679
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 682
      tmp = check_if_destination(dst_ip);
      }
#line 682
      if (tmp) {
        {
#line 682
        tmp___0 = check_if_source(src_ip);
        }
#line 682
        if (tmp___0) {
          {
#line 683
          store_data(protocol, src_ip, dst_ip, src_port, dst_port, nathostip, nathostport,
                     status);
          }
        }
      }
    }
  }
#line 685
  return;
}
}
#line 687 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void store_data(char *protocol , char *src_ip , char *dst_ip , char *src_port , char *dst_port ,
                char *nathostip , char *nathostport , char *status ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 690
  tmp = xrealloc((void *)connection_table, (unsigned long )(connection_index + 1) * sizeof(char **));
#line 690
  connection_table = (char ***)tmp;
#line 691
  tmp___0 = xcalloc(200UL * sizeof(char *));
#line 691
  *(connection_table + connection_index) = (char **)tmp___0;
#line 692
  tmp___1 = xcalloc((size_t )10);
#line 692
  *(*(connection_table + connection_index) + 0) = (char *)tmp___1;
#line 693
  tmp___2 = xcalloc((size_t )60);
#line 693
  *(*(connection_table + connection_index) + 1) = (char *)tmp___2;
#line 694
  tmp___3 = xcalloc((size_t )60);
#line 694
  *(*(connection_table + connection_index) + 2) = (char *)tmp___3;
#line 695
  tmp___4 = xcalloc((size_t )20);
#line 695
  *(*(connection_table + connection_index) + 3) = (char *)tmp___4;
#line 696
  tmp___5 = xcalloc((size_t )20);
#line 696
  *(*(connection_table + connection_index) + 4) = (char *)tmp___5;
#line 697
  tmp___6 = xcalloc((size_t )15);
#line 697
  *(*(connection_table + connection_index) + 5) = (char *)tmp___6;
#line 698
  tmp___7 = xcalloc((size_t )60);
#line 698
  *(*(connection_table + connection_index) + 6) = (char *)tmp___7;
#line 699
  tmp___8 = xcalloc((size_t )20);
#line 699
  *(*(connection_table + connection_index) + 7) = (char *)tmp___8;
#line 701
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 3),
          (char const   */* __restrict  */)src_port, (size_t )19);
#line 702
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 4),
          (char const   */* __restrict  */)dst_port, (size_t )19);
#line 703
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 1),
          (char const   */* __restrict  */)src_ip, (size_t )59);
#line 704
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 2),
          (char const   */* __restrict  */)dst_ip, (size_t )59);
#line 705
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 0),
          (char const   */* __restrict  */)protocol, (size_t )9);
#line 706
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 5),
          (char const   */* __restrict  */)status, (size_t )14);
#line 707
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 6),
          (char const   */* __restrict  */)nathostip, (size_t )59);
#line 708
  strncpy((char */* __restrict  */)*(*(connection_table + connection_index) + 7),
          (char const   */* __restrict  */)nathostport, (size_t )19);
#line 709
  connection_index ++;
  }
#line 710
  return;
}
}
#line 712 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void lookup_portname(char **port , char *proto ) 
{ 
  char buf_port[10] ;
  int portnr ;
  struct servent *service ;
  int tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 719
  strncpy((char */* __restrict  */)(buf_port), (char const   */* __restrict  */)*port,
          sizeof(buf_port) - 1UL);
#line 720
  tmp = atoi((char const   *)(buf_port));
#line 720
  tmp___0 = htons((uint16_t )tmp);
#line 720
  portnr = (int )tmp___0;
#line 722
  service = getservbyport(portnr, (char const   *)proto);
  }
#line 722
  if (service) {
    {
#line 725
    strncpy((char */* __restrict  */)*port, (char const   */* __restrict  */)service->s_name,
            (size_t )19);
    }
  }
#line 727
  return;
}
}
#line 729 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void extract_ip(char *gen_buffer ) 
{ 
  char *split ;

  {
  {
#line 732
  split = strtok((char */* __restrict  */)gen_buffer, (char const   */* __restrict  */)"=");
#line 733
  split = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
#line 734
  strcpy((char */* __restrict  */)gen_buffer, (char const   */* __restrict  */)split);
  }
#line 735
  return;
}
}
#line 737 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int lookup_hostname(char **r_host ) 
{ 
  int addr ;
  struct hostent *hp ;
  char **p ;
  in_addr_t tmp ;
  struct in_addr in ;

  {
  {
#line 744
  tmp = inet_addr((char const   *)*r_host);
#line 744
  addr = (int )tmp;
#line 745
  hp = gethostbyaddr((void const   *)((char *)(& addr)), (__socklen_t )sizeof(addr),
                     2);
  }
#line 745
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 746
    return (0);
  }
#line 748
  p = hp->h_addr_list;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! ((unsigned long )*p != (unsigned long )((char *)0))) {
#line 748
      goto while_break;
    }
    {
#line 750
    memcpy((void */* __restrict  */)(& in.s_addr), (void const   */* __restrict  */)*p,
           sizeof(in.s_addr));
#line 753
    strncpy((char */* __restrict  */)*r_host, (char const   */* __restrict  */)hp->h_name,
            (size_t )59);
#line 748
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  return (0);
}
}
#line 759 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int lookup_ip(char *hostname , size_t hostname_size ) 
{ 
  char *ip ;
  struct hostent *hp ;
  struct in_addr ip_addr ;

  {
  {
#line 765
  hp = gethostbyname((char const   *)hostname);
  }
#line 765
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 766
    printf((char const   */* __restrict  */)"Unknown host: %s\n", hostname);
#line 767
    exit(-1);
    }
  }
  {
#line 770
  ip_addr = *((struct in_addr *)*(hp->h_addr_list + 0));
#line 771
  ip = inet_ntoa(*((struct in_addr *)*(hp->h_addr_list + 0)));
#line 772
  strncpy((char */* __restrict  */)hostname, (char const   */* __restrict  */)ip,
          hostname_size - 1UL);
  }
#line 773
  return (1);
}
}
#line 800 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int check_if_source(char *host ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 802
  tmp = strcmp((char const   *)host, (char const   *)(SRC_IP));
  }
#line 802
  if (tmp == 0) {
#line 803
    return (1);
  } else {
    {
#line 802
    tmp___0 = strcmp((char const   *)(SRC_IP), "");
    }
#line 802
    if (tmp___0 == 0) {
#line 803
      return (1);
    }
  }
#line 805
  return (0);
}
}
#line 808 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int check_if_destination(char *host ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 810
  tmp = strcmp((char const   *)host, (char const   *)(DST_IP));
  }
#line 810
  if (tmp == 0) {
#line 811
    return (1);
  } else {
    {
#line 810
    tmp___0 = strcmp((char const   *)(DST_IP), "");
    }
#line 810
    if (tmp___0 == 0) {
#line 811
      return (1);
    }
  }
#line 813
  return (0);
}
}
#line 817 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static void *xcalloc(size_t bufsize ) 
{ 
  void *buf ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 821
  buf = calloc((size_t )1, bufsize);
  }
#line 821
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 822
    return (buf);
  } else {
    {
#line 824
    tmp = __errno_location();
#line 824
    tmp___0 = strerror(*tmp);
#line 824
    printf((char const   */* __restrict  */)"Could not allocate memory (%i bytes); %s.\n -- Exiting.\n",
           bufsize, tmp___0);
#line 825
    exit(1);
    }
  }
}
}
#line 830 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
static void *xrealloc(void *oldbuf , size_t newbufsize ) 
{ 
  void *newbuf ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 834
  newbuf = realloc(oldbuf, newbufsize);
  }
#line 834
  if ((unsigned long )newbuf != (unsigned long )((void *)0)) {
#line 835
    return (newbuf);
  } else {
    {
#line 837
    tmp = __errno_location();
#line 837
    tmp___0 = strerror(*tmp);
#line 837
    printf((char const   */* __restrict  */)"Could not allocate memory (%i bytes); %s.\n -- Exiting.\n",
           newbufsize, tmp___0);
#line 838
    exit(1);
    }
  }
}
}
#line 842 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
char *xstrdup(char const   *dup___0 ) 
{ 
  char *ret ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 845
  ret = strdup(dup___0);
  }
#line 845
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 846
    tmp = __errno_location();
#line 846
    tmp___0 = strerror(*tmp);
#line 846
    printf((char const   */* __restrict  */)"Could not set value into struct (%s); %s.\n -- Exiting.\n",
           dup___0, tmp___0);
#line 847
    exit(1);
    }
  }
#line 849
  return (ret);
}
}
#line 852 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void ip_addresses_add(struct _ip_addresses **list , char const   *dev , char const   *ip ) 
{ 
  struct _ip_addresses *new ;
  void *tmp ;
  struct _ip_addresses *tail ;

  {
  {
#line 854
  tmp = malloc(sizeof(*new));
#line 854
  new = (struct _ip_addresses *)tmp;
  }
#line 855
  if ((unsigned long )new != (unsigned long )((void *)0)) {
    {
#line 856
    strncpy((char */* __restrict  */)(new->ip), (char const   */* __restrict  */)ip,
            (size_t )15);
#line 857
    strncpy((char */* __restrict  */)(new->dev), (char const   */* __restrict  */)dev,
            (size_t )15);
#line 858
    new->next = (struct _ip_addresses *)((void *)0);
    }
#line 859
    if ((unsigned long )*list == (unsigned long )((void *)0)) {
#line 860
      *list = new;
    } else {
#line 863
      tail = *list;
      {
#line 864
      while (1) {
        while_continue: /* CIL Label */ ;
#line 864
        if (! ((unsigned long )tail->next != (unsigned long )((void *)0))) {
#line 864
          goto while_break;
        }
#line 866
        tail = tail->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 868
      tail->next = new;
    }
  }
#line 871
  return;
}
}
#line 873 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int ip_addresses_search(struct _ip_addresses *list , char const   *ip ) 
{ 
  struct _ip_addresses *akt ;
  int tmp ;

  {
#line 875
  akt = list;
#line 876
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 876
    return (0);
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! ((unsigned long )akt != (unsigned long )((void *)0))) {
#line 877
      goto while_break;
    }
    {
#line 879
    tmp = strcmp((char const   *)(akt->ip), ip);
    }
#line 879
    if (tmp == 0) {
#line 880
      return (1);
    }
#line 882
    akt = akt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  return (0);
}
}
#line 887 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void ip_addresses_free(struct _ip_addresses **node ) 
{ 
  struct _ip_addresses *this ;
  struct _ip_addresses *temp ;

  {
#line 889
  this = *node;
  {
#line 891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 891
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 891
      goto while_break;
    }
    {
#line 893
    temp = this->next;
#line 894
    free((void *)this);
#line 895
    this = temp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 897
  *node = (struct _ip_addresses *)((void *)0);
#line 898
  return;
}
}
#line 900 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int string_search(char *string , char *search ) 
{ 
  int searchLen ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 904
  tmp = strlen((char const   *)search);
#line 904
  searchLen = (int )tmp;
#line 905
  tmp___0 = strlen((char const   *)string);
  }
#line 905
  if ((size_t )searchLen > tmp___0) {
#line 906
    return (0);
  }
#line 908
  i = 0;
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 908
    tmp___2 = strlen((char const   *)string);
    }
#line 908
    if (! ((size_t )i < (tmp___2 - (size_t )searchLen) + 1UL)) {
#line 908
      goto while_break;
    }
    {
#line 909
    tmp___1 = strncasecmp((char const   *)(string + i), (char const   *)search, (size_t )searchLen);
    }
#line 909
    if (! tmp___1) {
#line 910
      return (1);
    }
#line 908
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  return (0);
}
}
#line 917 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int search_first_hit(char *search , char *line , char *ret ) 
{ 
  unsigned int searchLen ;
  unsigned int i ;
  unsigned int j ;
  unsigned int lineLen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 924
  tmp = strlen((char const   *)line);
#line 924
  lineLen = (unsigned int )tmp;
#line 925
  tmp___0 = strlen((char const   *)search);
#line 925
  searchLen = (unsigned int )tmp___0;
  }
#line 927
  if (searchLen > lineLen) {
#line 928
    return (1);
  }
#line 930
  i = 0U;
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (i < (lineLen - searchLen) + 1U)) {
#line 930
      goto while_break;
    }
    {
#line 931
    tmp___1 = strncasecmp((char const   *)(line + i), (char const   *)search, (size_t )searchLen);
    }
#line 931
    if (! tmp___1) {
#line 932
      goto while_break;
    }
#line 930
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  j = i + searchLen;
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 935
    if (! (j < (i + 15U) + searchLen)) {
#line 935
      goto while_break___0;
    }
#line 936
    if (j > lineLen) {
#line 937
      return (1);
    }
#line 939
    if ((int )*(line + j) == 32) {
#line 940
      goto while_break___0;
    }
#line 935
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 943
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)(line + (i + searchLen)),
         (size_t )((j - i) - searchLen));
  }
#line 944
  return (0);
}
}
#line 948 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
int search_sec_hit(char *search , char *line , char *ret ) 
{ 
  unsigned int searchLen ;
  unsigned int i ;
  unsigned int j ;
  unsigned int got_first ;
  unsigned int lineLen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 953
  got_first = 0U;
#line 956
  tmp = strlen((char const   *)line);
#line 956
  lineLen = (unsigned int )tmp;
#line 957
  tmp___0 = strlen((char const   *)search);
#line 957
  searchLen = (unsigned int )tmp___0;
  }
#line 959
  if (searchLen > lineLen) {
#line 960
    return (1);
  }
#line 962
  i = 0U;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! (i < (lineLen - searchLen) + 1U)) {
#line 962
      goto while_break;
    }
    {
#line 963
    tmp___1 = strncasecmp((char const   *)(line + i), (char const   *)search, (size_t )searchLen);
    }
#line 963
    if (! tmp___1) {
#line 964
      if (got_first) {
#line 965
        goto while_break;
      }
#line 967
      got_first = 1U;
    }
#line 962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  j = i + searchLen;
  {
#line 970
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 970
    if (! (j < (i + 15U) + searchLen)) {
#line 970
      goto while_break___0;
    }
#line 971
    if (j > lineLen) {
#line 972
      return (1);
    }
#line 974
    if ((int )*(line + j) == 32) {
#line 975
      goto while_break___0;
    }
#line 970
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 978
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)(line + (i + searchLen)),
         (size_t )((j - i) - searchLen));
  }
#line 979
  return (0);
}
}
#line 983 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void get_protocol_name(char *protocol_name , int protocol_nr ) 
{ 
  struct protoent *proto_struct ;
  char strconvers[10] ;
  unsigned int tmp ;

  {
#line 986
  strconvers[0] = (char )'\000';
#line 986
  tmp = 1U;
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 986
    if (tmp >= 10U) {
#line 986
      goto while_break;
    }
#line 986
    strconvers[tmp] = (char)0;
#line 986
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  proto_struct = getprotobynumber(protocol_nr);
  }
#line 988
  if ((unsigned long )proto_struct != (unsigned long )((void *)0)) {
    {
#line 989
    memcpy((void */* __restrict  */)protocol_name, (void const   */* __restrict  */)proto_struct->p_name,
           (size_t )5);
    }
  } else {
    {
#line 992
    snprintf((char */* __restrict  */)(strconvers), (size_t )6, (char const   */* __restrict  */)"%d",
             protocol_nr);
#line 993
    memcpy((void */* __restrict  */)protocol_name, (void const   */* __restrict  */)(strconvers),
           (size_t )5);
    }
  }
#line 995
  return;
}
}
#line 998 "/home/wheatley/newnew/temp/netstat-nat-1.4.10/netstat-nat.c"
void display_help(void) 
{ 


  {
  {
#line 1000
  printf((char const   */* __restrict  */)"args: -h: displays this help\n");
#line 1001
  printf((char const   */* __restrict  */)"      -n: don\'t resolve host/portnames\n");
#line 1002
  printf((char const   */* __restrict  */)"      -p <protocol>        : display connections by protocol\n");
#line 1003
  printf((char const   */* __restrict  */)"      -s <source-host>     : display connections by source\n");
#line 1004
  printf((char const   */* __restrict  */)"      -d <destination-host>: display connections by destination\n");
#line 1005
  printf((char const   */* __restrict  */)"      -S: display SNAT connections\n");
#line 1006
  printf((char const   */* __restrict  */)"      -D: display DNAT connections (default: SNAT & DNAT)\n");
#line 1007
  printf((char const   */* __restrict  */)"      -L: display only connections to NAT box itself (doesn\'t show SNAT & DNAT)\n");
#line 1008
  printf((char const   */* __restrict  */)"      -R: display only connections routed through the NAT box (doesn\'t show SNAT & DNAT)\n");
#line 1009
  printf((char const   */* __restrict  */)"      -x: extended hostnames view\n");
#line 1010
  printf((char const   */* __restrict  */)"      -r src | dst | src-port | dst-port | state : sort connections\n");
#line 1011
  printf((char const   */* __restrict  */)"      -o: strip output header\n");
#line 1012
  printf((char const   */* __restrict  */)"      -N: display NAT box connection information (only valid with SNAT & DNAT)\n");
#line 1013
  printf((char const   */* __restrict  */)"      -v: print version\n");
#line 1014
  printf((char const   */* __restrict  */)"\n");
#line 1015
  printf((char const   */* __restrict  */)"      netstat-nat [-S|-D|-L|-R] [-no]\n");
#line 1016
  printf((char const   */* __restrict  */)"      netstat-nat [-nxo]\n");
  }
#line 1017
  return;
}
}
