/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "../src/cmph_types.h"
typedef unsigned int cmph_uint32;
#line 37
enum __anonenum_CMPH_ALGO_26 {
    CMPH_BMZ = 0,
    CMPH_BMZ8 = 1,
    CMPH_CHM = 2,
    CMPH_BRZ = 3,
    CMPH_FCH = 4,
    CMPH_BDZ = 5,
    CMPH_BDZ_PH = 6,
    CMPH_CHD_PH = 7,
    CMPH_CHD = 8,
    CMPH_COUNT = 9
} ;
#line 37 "../src/cmph_types.h"
typedef enum __anonenum_CMPH_ALGO_26 CMPH_ALGO;
#line 14 "../src/cmph.h"
struct __config_t;
#line 14 "../src/cmph.h"
typedef struct __config_t cmph_config_t;
#line 15
struct __cmph_t;
#line 15 "../src/cmph.h"
typedef struct __cmph_t cmph_t;
#line 17 "../src/cmph.h"
struct __anonstruct_cmph_io_adapter_t_27 {
   void *data ;
   cmph_uint32 nkeys ;
   int (*read)(void * , char ** , cmph_uint32 * ) ;
   void (*dispose)(void * , char * , cmph_uint32  ) ;
   void (*rewind)(void * ) ;
};
#line 17 "../src/cmph.h"
typedef struct __anonstruct_cmph_io_adapter_t_27 cmph_io_adapter_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_types.h"
typedef unsigned char cmph_uint8;
#line 35
enum __anonenum_CMPH_HASH_1 {
    CMPH_HASH_JENKINS = 0,
    CMPH_HASH_COUNT = 1
} ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_types.h"
typedef enum __anonenum_CMPH_HASH_1 CMPH_HASH;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
struct __graph_t;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
typedef struct __graph_t graph_t;
#line 10
struct __graph_iterator_t;
#line 10 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
typedef struct __graph_iterator_t graph_iterator_t;
#line 11 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
struct __graph_iterator_t {
   cmph_uint32 vertex ;
   cmph_uint32 edge ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.h"
struct __bmz8_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.h"
typedef struct __bmz8_data_t bmz8_data_t;
#line 7
struct __bmz8_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.h"
typedef struct __bmz8_config_data_t bmz8_config_data_t;
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.h"
struct __config_t {
   CMPH_ALGO algo ;
   cmph_io_adapter_t *key_source ;
   cmph_uint32 verbosity ;
   double c ;
   void *data ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.h"
struct __cmph_t {
   CMPH_ALGO algo ;
   cmph_uint32 size ;
   cmph_io_adapter_t *key_source ;
   void *data ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.h"
union __hash_state_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.h"
typedef union __hash_state_t hash_state_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.h"
struct __jenkins_state_t {
   CMPH_HASH hashfunc ;
   cmph_uint32 seed ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.h"
typedef struct __jenkins_state_t jenkins_state_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash_state.h"
union __hash_state_t {
   CMPH_HASH hashfunc ;
   jenkins_state_t jenkins ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8_structs.h"
struct __bmz8_data_t {
   cmph_uint8 m ;
   cmph_uint8 n ;
   cmph_uint8 *g ;
   hash_state_t **hashes ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8_structs.h"
struct __bmz8_config_data_t {
   CMPH_HASH hashfuncs[2] ;
   cmph_uint8 m ;
   cmph_uint8 n ;
   graph_t *graph ;
   cmph_uint8 *g ;
   hash_state_t **hashes ;
};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.h"
struct __vqueue_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.h"
typedef struct __vqueue_t vqueue_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.h"
struct __buffer_manager_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.h"
typedef struct __buffer_manager_t buffer_manager_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.h"
struct __buffer_entry_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.h"
typedef struct __buffer_entry_t buffer_entry_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c"
struct __buffer_manager_t {
   cmph_uint32 memory_avail ;
   buffer_entry_t **buffer_entries ;
   cmph_uint32 nentries ;
   cmph_uint32 *memory_avail_list ;
   int pos_avail_list ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.h"
struct _select_t {
   cmph_uint32 n ;
   cmph_uint32 m ;
   cmph_uint32 *bits_vec ;
   cmph_uint32 *select_table ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.h"
typedef struct _select_t select_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.h"
struct __vstack_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.h"
typedef struct __vstack_t vstack_t;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
struct __vstack_t {
   cmph_uint32 pointer ;
   cmph_uint32 *values ;
   cmph_uint32 capacity ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.h"
struct __chm_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.h"
typedef struct __chm_data_t chm_data_t;
#line 7
struct __chm_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.h"
typedef struct __chm_config_data_t chm_config_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm_structs.h"
struct __chm_data_t {
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 *g ;
   hash_state_t **hashes ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm_structs.h"
struct __chm_config_data_t {
   CMPH_HASH hashfuncs[2] ;
   cmph_uint32 m ;
   cmph_uint32 n ;
   graph_t *graph ;
   cmph_uint32 *g ;
   hash_state_t **hashes ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.h"
struct _compressed_seq_t {
   cmph_uint32 n ;
   cmph_uint32 rem_r ;
   cmph_uint32 total_length ;
   select_t sel ;
   cmph_uint32 *length_rems ;
   cmph_uint32 *store_table ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.h"
typedef struct _compressed_seq_t compressed_seq_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_structs_ph.h"
struct __chd_ph_config_data_t {
   CMPH_HASH hashfunc ;
   compressed_seq_t *cs ;
   cmph_uint32 nbuckets ;
   cmph_uint32 n ;
   hash_state_t *hl ;
   cmph_uint32 m ;
   cmph_uint8 use_h ;
   cmph_uint32 keys_per_bin ;
   cmph_uint32 keys_per_bucket ;
   cmph_uint8 *occup_table ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.h"
typedef struct __chd_ph_config_data_t chd_ph_config_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.h"
struct _compressed_rank_t {
   cmph_uint32 max_val ;
   cmph_uint32 n ;
   cmph_uint32 rem_r ;
   select_t sel ;
   cmph_uint32 *vals_rems ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.h"
typedef struct _compressed_rank_t compressed_rank_t;
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_structs.h"
struct __chd_data_t {
   cmph_uint32 packed_cr_size ;
   cmph_uint8 *packed_cr ;
   cmph_uint32 packed_chd_phf_size ;
   cmph_uint8 *packed_chd_phf ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_structs.h"
struct __chd_config_data_t {
   cmph_config_t *chd_ph ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.h"
typedef struct __chd_data_t chd_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.h"
typedef struct __chd_config_data_t chd_config_data_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.h"
struct __fch_buckets_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.h"
typedef struct __fch_buckets_t fch_buckets_t;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
struct __fch_bucket_entry_t {
   char *value ;
   cmph_uint32 length ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
typedef struct __fch_bucket_entry_t fch_bucket_entry_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
struct __fch_bucket_t {
   fch_bucket_entry_t *entries ;
   cmph_uint32 capacity ;
   cmph_uint32 size ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
typedef struct __fch_bucket_t fch_bucket_t;
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
struct __fch_buckets_t {
   fch_bucket_t *values ;
   cmph_uint32 nbuckets ;
   cmph_uint32 max_size ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
struct __graph_t {
   cmph_uint32 nnodes ;
   cmph_uint32 nedges ;
   cmph_uint32 *edges ;
   cmph_uint32 *first ;
   cmph_uint32 *next ;
   cmph_uint8 *critical_nodes ;
   cmph_uint32 ncritical_nodes ;
   cmph_uint32 cedges ;
   int shrinking ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
struct __buffer_entry_t {
   FILE *fd ;
   cmph_uint8 *buff ;
   cmph_uint32 capacity ;
   cmph_uint32 nbytes ;
   cmph_uint32 pos ;
   cmph_uint8 eof ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_types.h"
typedef unsigned long cmph_uint64;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
struct __fch_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
typedef struct __fch_data_t fch_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_structs.h"
struct __fch_data_t {
   cmph_uint32 m ;
   double c ;
   cmph_uint32 b ;
   double p1 ;
   double p2 ;
   cmph_uint32 *g ;
   hash_state_t *h1 ;
   hash_state_t *h2 ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.h"
struct __brz_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.h"
typedef struct __brz_data_t brz_data_t;
#line 7
struct __brz_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.h"
typedef struct __brz_config_data_t brz_config_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz_structs.h"
struct __brz_data_t {
   CMPH_ALGO algo ;
   cmph_uint32 m ;
   double c ;
   cmph_uint8 *size ;
   cmph_uint32 *offset ;
   cmph_uint8 **g ;
   cmph_uint32 k ;
   hash_state_t **h1 ;
   hash_state_t **h2 ;
   hash_state_t *h0 ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz_structs.h"
struct __brz_config_data_t {
   CMPH_HASH hashfuncs[3] ;
   CMPH_ALGO algo ;
   double c ;
   cmph_uint32 m ;
   cmph_uint8 *size ;
   cmph_uint32 *offset ;
   cmph_uint8 **g ;
   cmph_uint8 b ;
   cmph_uint32 k ;
   hash_state_t **h1 ;
   hash_state_t **h2 ;
   hash_state_t *h0 ;
   cmph_uint32 memory_availability ;
   cmph_uint8 *tmp_dir ;
   FILE *mphf_fd ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.h"
struct __bmz_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.h"
typedef struct __bmz_data_t bmz_data_t;
#line 7
struct __bmz_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.h"
typedef struct __bmz_config_data_t bmz_config_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz_structs.h"
struct __bmz_data_t {
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 *g ;
   hash_state_t **hashes ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz_structs.h"
struct __bmz_config_data_t {
   CMPH_HASH hashfuncs[2] ;
   cmph_uint32 m ;
   cmph_uint32 n ;
   graph_t *graph ;
   cmph_uint32 *g ;
   hash_state_t **hashes ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
struct __fch_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
typedef struct __fch_config_data_t fch_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.h"
struct __bdz_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.h"
typedef struct __bdz_config_data_t bdz_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.h"
struct __bdz_ph_config_data_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.h"
typedef struct __bdz_ph_config_data_t bdz_ph_config_data_t;
#line 21 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
struct __anonstruct_cmph_vector_t_42 {
   void *vector ;
   cmph_uint32 position ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
typedef struct __anonstruct_cmph_vector_t_42 cmph_vector_t;
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
struct __anonstruct_cmph_struct_vector_t_43 {
   void *vector ;
   cmph_uint32 position ;
   cmph_uint32 struct_size ;
   cmph_uint32 key_offset ;
   cmph_uint32 key_len ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
typedef struct __anonstruct_cmph_struct_vector_t_43 cmph_struct_vector_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.h"
struct __bdz_ph_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.h"
typedef struct __bdz_ph_data_t bdz_ph_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_structs_ph.h"
struct __bdz_ph_data_t {
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 r ;
   cmph_uint8 *g ;
   hash_state_t *hl ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_structs_ph.h"
struct __bdz_ph_config_data_t {
   CMPH_HASH hashfunc ;
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 r ;
   cmph_uint8 *g ;
   hash_state_t *hl ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
struct __anonstruct_bdz_ph_edge_t_44 {
   cmph_uint32 vertices[3] ;
   cmph_uint32 next_edges[3] ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
typedef struct __anonstruct_bdz_ph_edge_t_44 bdz_ph_edge_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
typedef cmph_uint32 *bdz_ph_queue_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
struct __anonstruct_bdz_ph_graph3_t_45 {
   cmph_uint32 nedges ;
   bdz_ph_edge_t *edges ;
   cmph_uint32 *first_edge ;
   cmph_uint8 *vert_degree ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
typedef struct __anonstruct_bdz_ph_graph3_t_45 bdz_ph_graph3_t;
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_structs.h"
struct __fch_config_data_t {
   CMPH_HASH hashfuncs[2] ;
   cmph_uint32 m ;
   double c ;
   cmph_uint32 b ;
   double p1 ;
   double p2 ;
   cmph_uint32 *g ;
   hash_state_t *h1 ;
   hash_state_t *h2 ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_structs_ph.h"
struct __chd_ph_data_t {
   compressed_seq_t *cs ;
   cmph_uint32 nbuckets ;
   cmph_uint32 n ;
   hash_state_t *hl ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.h"
typedef struct __chd_ph_data_t chd_ph_data_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
struct _chd_ph_item_t {
   cmph_uint32 f ;
   cmph_uint32 h ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
typedef struct _chd_ph_item_t chd_ph_item_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
struct _chd_ph_map_item_t {
   cmph_uint32 f ;
   cmph_uint32 h ;
   cmph_uint32 bucket_num ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
typedef struct _chd_ph_map_item_t chd_ph_map_item_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
union __anonunion____missing_field_name_44 {
   cmph_uint32 size ;
   cmph_uint32 bucket_id ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
struct _chd_ph_bucket_t {
   cmph_uint32 items_list ;
   union __anonunion____missing_field_name_44 __annonCompField15 ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
typedef struct _chd_ph_bucket_t chd_ph_bucket_t;
#line 54 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
struct _chd_ph_sorted_list_t {
   cmph_uint32 buckets_list ;
   cmph_uint32 size ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
typedef struct _chd_ph_sorted_list_t chd_ph_sorted_list_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.h"
struct __bdz_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.h"
typedef struct __bdz_data_t bdz_data_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_structs.h"
struct __bdz_data_t {
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 r ;
   cmph_uint8 *g ;
   hash_state_t *hl ;
   cmph_uint32 k ;
   cmph_uint8 b ;
   cmph_uint32 ranktablesize ;
   cmph_uint32 *ranktable ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_structs.h"
struct __bdz_config_data_t {
   cmph_uint32 m ;
   cmph_uint32 n ;
   cmph_uint32 r ;
   cmph_uint8 *g ;
   hash_state_t *hl ;
   cmph_uint32 k ;
   cmph_uint8 b ;
   cmph_uint32 ranktablesize ;
   cmph_uint32 *ranktable ;
   CMPH_HASH hashfunc ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
struct __anonstruct_bdz_edge_t_44 {
   cmph_uint32 vertices[3] ;
   cmph_uint32 next_edges[3] ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
typedef struct __anonstruct_bdz_edge_t_44 bdz_edge_t;
#line 46 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
typedef cmph_uint32 *bdz_queue_t;
#line 57 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
struct __anonstruct_bdz_graph3_t_45 {
   cmph_uint32 nedges ;
   bdz_edge_t *edges ;
   cmph_uint32 *first_edge ;
   cmph_uint8 *vert_degree ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
typedef struct __anonstruct_bdz_graph3_t_45 bdz_graph3_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
struct __vqueue_t {
   cmph_uint32 *values ;
   cmph_uint32 beg ;
   cmph_uint32 end ;
   cmph_uint32 capacity ;
};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/examples/struct_vector_adapter_ex3.c"
#pragma pack(1)
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/examples/struct_vector_adapter_ex3.c"
struct __anonstruct_rec_t_42 {
   cmph_uint32 id ;
   char key[11] ;
   cmph_uint32 year ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/examples/struct_vector_adapter_ex3.c"
typedef struct __anonstruct_rec_t_42 rec_t;
#line 11
#pragma pack(0)
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 34 "../src/cmph.h"
cmph_io_adapter_t *cmph_io_vector_adapter(char **vector , cmph_uint32 nkeys ) ;
#line 35
void cmph_io_vector_adapter_destroy(cmph_io_adapter_t *key_source ) ;
#line 49
cmph_config_t *cmph_config_new(cmph_io_adapter_t *key_source ) ;
#line 53
void cmph_config_set_algo(cmph_config_t *mph , CMPH_ALGO algo ) ;
#line 55
void cmph_config_set_mphf_fd(cmph_config_t *mph , FILE *mphf_fd ) ;
#line 59
void cmph_config_destroy(cmph_config_t *mph ) ;
#line 62
cmph_t *cmph_new(cmph_config_t *mph ) ;
#line 71
cmph_uint32 cmph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 74
void cmph_destroy(cmph_t *mphf ) ;
#line 77
int cmph_dump(cmph_t *mphf , FILE *f ) ;
#line 78
cmph_t *cmph_load(FILE *f ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/examples/vector_adapter_ex1.c"
int main(int argc , char **argv ) 
{ 
  unsigned int i ;
  char const   *vector[10] ;
  unsigned int nkeys ;
  FILE *mphf_fd ;
  FILE *tmp ;
  cmph_io_adapter_t *source ;
  cmph_io_adapter_t *tmp___0 ;
  cmph_config_t *config ;
  cmph_config_t *tmp___1 ;
  cmph_t *hash___0 ;
  cmph_t *tmp___2 ;
  char const   *key ;
  unsigned int id ;
  size_t tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 8
  i = 0U;
#line 9
  vector[0] = "aaaaaaaaaa";
#line 9
  vector[1] = "bbbbbbbbbb";
#line 9
  vector[2] = "cccccccccc";
#line 9
  vector[3] = "dddddddddd";
#line 9
  vector[4] = "eeeeeeeeee";
#line 9
  vector[5] = "ffffffffff";
#line 9
  vector[6] = "gggggggggg";
#line 9
  vector[7] = "hhhhhhhhhh";
#line 9
  vector[8] = "iiiiiiiiii";
#line 9
  vector[9] = "jjjjjjjjjj";
#line 11
  nkeys = 10U;
#line 12
  tmp = fopen((char const   */* __restrict  */)"temp.mph", (char const   */* __restrict  */)"w");
#line 12
  mphf_fd = tmp;
#line 14
  tmp___0 = cmph_io_vector_adapter((char **)(vector), nkeys);
#line 14
  source = tmp___0;
#line 17
  tmp___1 = cmph_config_new(source);
#line 17
  config = tmp___1;
#line 18
  cmph_config_set_algo(config, (CMPH_ALGO )3);
#line 19
  cmph_config_set_mphf_fd(config, mphf_fd);
#line 20
  tmp___2 = cmph_new(config);
#line 20
  hash___0 = tmp___2;
#line 21
  cmph_config_destroy(config);
#line 22
  cmph_dump(hash___0, mphf_fd);
#line 23
  cmph_destroy(hash___0);
#line 24
  fclose(mphf_fd);
#line 27
  mphf_fd = fopen((char const   */* __restrict  */)"temp.mph", (char const   */* __restrict  */)"r");
#line 28
  hash___0 = cmph_load(mphf_fd);
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (i < nkeys)) {
#line 29
      goto while_break;
    }
    {
#line 30
    key = vector[i];
#line 31
    tmp___3 = strlen(key);
#line 31
    tmp___4 = cmph_search(hash___0, key, (cmph_uint32 )tmp___3);
#line 31
    id = tmp___4;
#line 32
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"key:%s -- hash:%u\n",
            key, id);
#line 33
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 37
  cmph_destroy(hash___0);
#line 38
  cmph_io_vector_adapter_destroy(source);
#line 39
  fclose(mphf_fd);
  }
#line 40
  return (0);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
graph_t *graph_new(cmph_uint32 nnodes , cmph_uint32 nedges ) ;
#line 20
void graph_destroy(graph_t *graph ) ;
#line 22
void graph_add_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) ;
#line 24
void graph_clear_edges(graph_t *g ) ;
#line 26
cmph_uint8 graph_contains_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) ;
#line 28
graph_iterator_t graph_neighbors_it(graph_t *g , cmph_uint32 v ) ;
#line 29
cmph_uint32 graph_next_neighbor(graph_t *g , graph_iterator_t *it ) ;
#line 31
void graph_obtain_critical_nodes(graph_t *g ) ;
#line 32
cmph_uint8 graph_node_is_critical(graph_t *g , cmph_uint32 v ) ;
#line 33
cmph_uint32 graph_ncritical_nodes(graph_t *g ) ;
#line 34
cmph_uint32 graph_vertex_id(graph_t *g , cmph_uint32 e , cmph_uint32 id ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.h"
bmz8_config_data_t *bmz8_config_new(void) ;
#line 10
void bmz8_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void bmz8_config_destroy(cmph_config_t *mph ) ;
#line 12
cmph_t *bmz8_new(cmph_config_t *mph , double c ) ;
#line 14
void bmz8_load(FILE *f , cmph_t *mphf ) ;
#line 15
int bmz8_dump(cmph_t *mphf , FILE *fd ) ;
#line 16
void bmz8_destroy(cmph_t *mphf ) ;
#line 17
cmph_uint8 bmz8_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 24
void bmz8_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 31
cmph_uint32 bmz8_packed_size(cmph_t *mphf ) ;
#line 40
cmph_uint8 bmz8_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.h"
void __cmph_dump(cmph_t *mphf , FILE *fd ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.h"
hash_state_t *hash_state_new(CMPH_HASH hashfunc , cmph_uint32 hashsize ) ;
#line 16
cmph_uint32 hash(hash_state_t *state , char const   *key , cmph_uint32 keylen ) ;
#line 26
void hash_state_dump(hash_state_t *state , char **buf , cmph_uint32 *buflen ) ;
#line 30
hash_state_t *hash_state_load(char const   *buf , cmph_uint32 buflen ) ;
#line 32
void hash_state_destroy(hash_state_t *state ) ;
#line 42
void hash_state_pack(hash_state_t *state , void *hash_packed___0 ) ;
#line 51
cmph_uint32 hash_packed(void *hash_packed___0 , CMPH_HASH hashfunc , char const   *k ,
                        cmph_uint32 keylen ) ;
#line 58
cmph_uint32 hash_state_packed_size(CMPH_HASH hashfunc ) ;
#line 74
CMPH_HASH hash_get_type(hash_state_t *state ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.h"
vqueue_t *vqueue_new(cmph_uint32 capacity ) ;
#line 9
cmph_uint8 vqueue_is_empty(vqueue_t *q ) ;
#line 11
void vqueue_insert(vqueue_t *q , cmph_uint32 val ) ;
#line 13
cmph_uint32 vqueue_remove(vqueue_t *q ) ;
#line 17
void vqueue_destroy(vqueue_t *q ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                               cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                               cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic(bmz8_config_data_t *bmz8 ,
                                                         cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                         cmph_uint8 *biggest_edge_value ,
                                                         cmph_uint8 *used_edges ,
                                                         cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                             cmph_uint8 *visited ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
bmz8_config_data_t *bmz8_config_new(void) 
{ 
  bmz8_config_data_t *bmz8 ;
  void *tmp ;

  {
  {
#line 25
  tmp = malloc(sizeof(bmz8_config_data_t ));
#line 25
  bmz8 = (bmz8_config_data_t *)tmp;
  }
#line 26
  if (! bmz8) {
    {
#line 26
    __assert_fail("bmz8", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                  26U, "bmz8_config_new");
    }
  }
  {
#line 27
  memset((void *)bmz8, 0, sizeof(bmz8_config_data_t ));
#line 28
  bmz8->hashfuncs[0] = (CMPH_HASH )0;
#line 29
  bmz8->hashfuncs[1] = (CMPH_HASH )0;
#line 30
  bmz8->g = (cmph_uint8 *)((void *)0);
#line 31
  bmz8->graph = (graph_t *)((void *)0);
#line 32
  bmz8->hashes = (hash_state_t **)((void *)0);
  }
#line 33
  return (bmz8);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
void bmz8_config_destroy(cmph_config_t *mph ) 
{ 
  bmz8_config_data_t *data ;

  {
  {
#line 38
  data = (bmz8_config_data_t *)mph->data;
#line 40
  free((void *)data);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
void bmz8_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  bmz8_config_data_t *bmz8 ;
  CMPH_HASH *hashptr ;
  cmph_uint8 i ;

  {
#line 45
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 46
  hashptr = hashfuncs;
#line 47
  i = (cmph_uint8 )0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! ((unsigned int )*hashptr != 1U)) {
#line 48
      goto while_break;
    }
#line 50
    if ((int )i >= 2) {
#line 50
      goto while_break;
    }
#line 51
    bmz8->hashfuncs[i] = *hashptr;
#line 52
    i = (cmph_uint8 )((int )i + 1);
#line 52
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
cmph_t *bmz8_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  bmz8_data_t *bmz8f ;
  cmph_uint8 i ;
  cmph_uint8 iterations ;
  cmph_uint8 iterations_map ;
  cmph_uint8 *used_edges ;
  cmph_uint8 restart_mapping ;
  cmph_uint8 *visited ;
  bmz8_config_data_t *bmz8 ;
  double tmp ;
  void *tmp___0 ;
  cmph_uint8 biggest_g_value ;
  cmph_uint8 biggest_edge_value ;
  int ok ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 58
  mphf = (cmph_t *)((void *)0);
#line 59
  bmz8f = (bmz8_data_t *)((void *)0);
#line 62
  iterations_map = (cmph_uint8 )20;
#line 63
  used_edges = (cmph_uint8 *)((void *)0);
#line 64
  restart_mapping = (cmph_uint8 )0;
#line 65
  visited = (cmph_uint8 *)((void *)0);
#line 66
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 68
  if ((mph->key_source)->nkeys >= 256U) {
#line 70
    if (mph->verbosity) {
      {
#line 70
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The number of keys in BMZ8 must be lower than 256.\n");
      }
    }
#line 71
    return ((cmph_t *)((void *)0));
  }
#line 73
  if (c == (double )0) {
#line 73
    c = 1.15;
  }
  {
#line 75
  bmz8->m = (cmph_uint8 )(mph->key_source)->nkeys;
#line 76
  tmp = ceil(c * (double )(mph->key_source)->nkeys);
#line 76
  bmz8->n = (cmph_uint8 )tmp;
#line 78
  bmz8->graph = graph_new((cmph_uint32 )bmz8->n, (cmph_uint32 )bmz8->m);
#line 81
  tmp___0 = malloc(sizeof(hash_state_t *) * 3UL);
#line 81
  bmz8->hashes = (hash_state_t **)tmp___0;
#line 82
  i = (cmph_uint8 )0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((int )i < 3)) {
#line 82
      goto while_break;
    }
#line 82
    *(bmz8->hashes + i) = (hash_state_t *)((void *)0);
#line 82
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    biggest_g_value = (cmph_uint8 )0;
#line 88
    biggest_edge_value = (cmph_uint8 )1;
#line 89
    iterations = (cmph_uint8 )100;
#line 90
    if (mph->verbosity) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys with graph sized %u\n",
              (int )bmz8->m, (int )bmz8->n);
      }
    }
    {
#line 94
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 98
      *(bmz8->hashes + 0) = hash_state_new(bmz8->hashfuncs[0], (cmph_uint32 )bmz8->n);
#line 100
      *(bmz8->hashes + 1) = hash_state_new(bmz8->hashfuncs[1], (cmph_uint32 )bmz8->n);
#line 102
      ok = bmz8_gen_edges(mph);
      }
#line 103
      if (! ok) {
        {
#line 105
        iterations = (cmph_uint8 )((int )iterations - 1);
#line 106
        hash_state_destroy(*(bmz8->hashes + 0));
#line 107
        *(bmz8->hashes + 0) = (hash_state_t *)((void *)0);
#line 108
        hash_state_destroy(*(bmz8->hashes + 1));
#line 109
        *(bmz8->hashes + 1) = (hash_state_t *)((void *)0);
        }
#line 111
        if (mph->verbosity) {
          {
#line 113
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simple graph creation failure - %u iterations remaining\n",
                  (int )iterations);
          }
        }
#line 115
        if ((int )iterations == 0) {
#line 115
          goto while_break___1;
        }
      } else {
#line 117
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 119
    if ((int )iterations == 0) {
      {
#line 121
      graph_destroy(bmz8->graph);
      }
#line 122
      return ((cmph_t *)((void *)0));
    }
#line 126
    if (mph->verbosity) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting ordering step\n");
      }
    }
    {
#line 131
    graph_obtain_critical_nodes(bmz8->graph);
    }
#line 134
    if (mph->verbosity) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting Searching step.\n");
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tTraversing critical vertices.\n");
      }
    }
    {
#line 140
    tmp___1 = malloc((size_t )bmz8->n / 8UL + 1UL);
#line 140
    visited = (cmph_uint8 *)tmp___1;
#line 141
    memset((void *)visited, 0, (size_t )bmz8->n / 8UL + 1UL);
#line 142
    tmp___2 = malloc((size_t )bmz8->m / 8UL + 1UL);
#line 142
    used_edges = (cmph_uint8 *)tmp___2;
#line 143
    memset((void *)used_edges, 0, (size_t )bmz8->m / 8UL + 1UL);
#line 144
    free((void *)bmz8->g);
#line 145
    tmp___3 = calloc((size_t )bmz8->n, sizeof(cmph_uint8 ));
#line 145
    bmz8->g = (cmph_uint8 *)tmp___3;
    }
#line 146
    if (! bmz8->g) {
      {
#line 146
      __assert_fail("bmz8->g", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    146U, "bmz8_new");
      }
    }
#line 147
    i = (cmph_uint8 )0;
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 147
      if (! ((int )i < (int )bmz8->n)) {
#line 147
        goto while_break___2;
      }
      {
#line 149
      tmp___4 = graph_node_is_critical(bmz8->graph, (cmph_uint32 )i);
      }
#line 149
      if (tmp___4) {
#line 149
        if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask[(int )i & 7]) >> ((int )i & 7))) {
#line 151
          if (c > 1.14) {
            {
#line 151
            restart_mapping = bmz8_traverse_critical_nodes(bmz8, (cmph_uint32 )i,
                                                           & biggest_g_value, & biggest_edge_value,
                                                           used_edges, visited);
            }
          } else {
            {
#line 152
            restart_mapping = bmz8_traverse_critical_nodes_heuristic(bmz8, (cmph_uint32 )i,
                                                                     & biggest_g_value,
                                                                     & biggest_edge_value,
                                                                     used_edges, visited);
            }
          }
#line 153
          if (restart_mapping) {
#line 153
            goto while_break___2;
          }
        }
      }
#line 147
      i = (cmph_uint8 )((int )i + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 156
    if (! restart_mapping) {
#line 158
      if (mph->verbosity) {
        {
#line 160
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tTraversing non critical vertices.\n");
        }
      }
      {
#line 162
      bmz8_traverse_non_critical_nodes(bmz8, used_edges, visited);
      }
    } else {
#line 166
      iterations_map = (cmph_uint8 )((int )iterations_map - 1);
#line 167
      if (mph->verbosity) {
        {
#line 167
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Restarting mapping step. %u iterations remaining.\n",
                (int )iterations_map);
        }
      }
    }
    {
#line 170
    free((void *)used_edges);
#line 171
    free((void *)visited);
    }
#line 84
    if (restart_mapping) {
#line 84
      if (! ((int )iterations_map > 0)) {
#line 84
        goto while_break___0;
      }
    } else {
#line 84
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  graph_destroy(bmz8->graph);
#line 175
  bmz8->graph = (graph_t *)((void *)0);
  }
#line 176
  if ((int )iterations_map == 0) {
#line 178
    return ((cmph_t *)((void *)0));
  }
  {
#line 180
  tmp___5 = malloc(sizeof(cmph_t ));
#line 180
  mphf = (cmph_t *)tmp___5;
#line 181
  mphf->algo = mph->algo;
#line 182
  tmp___6 = malloc(sizeof(bmz8_data_t ));
#line 182
  bmz8f = (bmz8_data_t *)tmp___6;
#line 183
  bmz8f->g = bmz8->g;
#line 184
  bmz8->g = (cmph_uint8 *)((void *)0);
#line 185
  bmz8f->hashes = bmz8->hashes;
#line 186
  bmz8->hashes = (hash_state_t **)((void *)0);
#line 187
  bmz8f->n = bmz8->n;
#line 188
  bmz8f->m = bmz8->m;
#line 189
  mphf->data = (void *)bmz8f;
#line 190
  mphf->size = (cmph_uint32 )bmz8->m;
  }
#line 192
  if (mph->verbosity) {
    {
#line 194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 196
  return (mphf);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                               cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                               cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic(bmz8_config_data_t *bmz8 ,
                                                         cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                         cmph_uint8 *biggest_edge_value ,
                                                         cmph_uint8 *used_edges ,
                                                         cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                   cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges , cmph_uint32 v ,
                          cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask[(int )i & 7]);
#line 416
      bmz8_traverse(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
int bmz8_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint8 two ;
  bmz8_data_t *data ;
  register size_t nbytes ;

  {
  {
#line 460
  buf = (char *)((void *)0);
#line 462
  two = (cmph_uint8 )2;
#line 463
  data = (bmz8_data_t *)mphf->data;
#line 465
  __cmph_dump(mphf, fd);
#line 467
  nbytes = fwrite((void const   */* __restrict  */)(& two), sizeof(cmph_uint8 ), (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 469
  hash_state_dump(*(data->hashes + 0), & buf, & buflen);
#line 471
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 472
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 473
  free((void *)buf);
#line 475
  hash_state_dump(*(data->hashes + 1), & buf, & buflen);
#line 477
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 478
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 479
  free((void *)buf);
#line 481
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint8 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 482
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint8 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 484
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )data->n,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 490
  return (1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
void bmz8_load(FILE *f , cmph_t *mphf ) 
{ 
  cmph_uint8 nhashes ;
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint8 i ;
  register size_t nbytes ;
  bmz8_data_t *bmz8 ;
  void *tmp ;
  void *tmp___0 ;
  hash_state_t *state ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 496
  buf = (char *)((void *)0);
#line 500
  tmp = malloc(sizeof(bmz8_data_t ));
#line 500
  bmz8 = (bmz8_data_t *)tmp;
#line 503
  mphf->data = (void *)bmz8;
#line 504
  nbytes = fread((void */* __restrict  */)(& nhashes), sizeof(cmph_uint8 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 505
  tmp___0 = malloc(sizeof(hash_state_t *) * (size_t )((int )nhashes + 1));
#line 505
  bmz8->hashes = (hash_state_t **)tmp___0;
#line 506
  *(bmz8->hashes + nhashes) = (hash_state_t *)((void *)0);
#line 508
  i = (cmph_uint8 )0;
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! ((int )i < (int )nhashes)) {
#line 508
      goto while_break;
    }
    {
#line 510
    state = (hash_state_t *)((void *)0);
#line 511
    nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                   (FILE */* __restrict  */)f);
#line 513
    tmp___1 = malloc((size_t )buflen);
#line 513
    buf = (char *)tmp___1;
#line 514
    nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 515
    state = hash_state_load((char const   *)buf, buflen);
#line 516
    *(bmz8->hashes + i) = state;
#line 517
    free((void *)buf);
#line 508
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 521
  nbytes = fread((void */* __restrict  */)(& bmz8->n), sizeof(cmph_uint8 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 522
  nbytes = fread((void */* __restrict  */)(& bmz8->m), sizeof(cmph_uint8 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 524
  tmp___2 = malloc(sizeof(cmph_uint8 ) * (unsigned long )bmz8->n);
#line 524
  bmz8->g = (cmph_uint8 *)tmp___2;
#line 525
  nbytes = fread((void */* __restrict  */)bmz8->g, (unsigned long )bmz8->n * sizeof(cmph_uint8 ),
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 531
  return;
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
cmph_uint8 bmz8_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  bmz8_data_t *bmz8 ;
  cmph_uint8 h1 ;
  cmph_uint32 tmp ;
  cmph_uint8 h2 ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 537
  bmz8 = (bmz8_data_t *)mphf->data;
#line 538
  tmp = hash(*(bmz8->hashes + 0), key, keylen);
#line 538
  h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 539
  tmp___0 = hash(*(bmz8->hashes + 1), key, keylen);
#line 539
  h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
  }
#line 541
  if ((int )h1 == (int )h2) {
#line 541
    h2 = (cmph_uint8 )((int )h2 + 1);
#line 541
    if ((int )h2 > (int )bmz8->n) {
#line 541
      h2 = (cmph_uint8 )0;
    }
  }
#line 543
  return ((cmph_uint8 )((int )*(bmz8->g + h1) + (int )*(bmz8->g + h2)));
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
void bmz8_destroy(cmph_t *mphf ) 
{ 
  bmz8_data_t *data ;

  {
  {
#line 547
  data = (bmz8_data_t *)mphf->data;
#line 548
  free((void *)data->g);
#line 549
  hash_state_destroy(*(data->hashes + 0));
#line 550
  hash_state_destroy(*(data->hashes + 1));
#line 551
  free((void *)data->hashes);
#line 552
  free((void *)data);
#line 553
  free((void *)mphf);
  }
#line 554
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
void bmz8_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  bmz8_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint8 *tmp___3 ;

  {
  {
#line 563
  data = (bmz8_data_t *)mphf->data;
#line 564
  ptr = (cmph_uint8 *)packed_mphf;
#line 567
  tmp = hash_get_type(*(data->hashes + 0));
#line 567
  h1_type = tmp;
#line 568
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h1_type;
#line 569
  ptr += sizeof(cmph_uint32 );
#line 572
  hash_state_pack(*(data->hashes + 0), (void *)ptr);
#line 573
  tmp___0 = hash_state_packed_size(h1_type);
#line 573
  ptr += tmp___0;
#line 576
  tmp___1 = hash_get_type(*(data->hashes + 1));
#line 576
  h2_type = tmp___1;
#line 577
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h2_type;
#line 578
  ptr += sizeof(cmph_uint32 );
#line 581
  hash_state_pack(*(data->hashes + 1), (void *)ptr);
#line 582
  tmp___2 = hash_state_packed_size(h2_type);
#line 582
  ptr += tmp___2;
#line 585
  tmp___3 = ptr;
#line 585
  ptr ++;
#line 585
  *tmp___3 = data->n;
#line 588
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )data->n);
  }
#line 589
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
cmph_uint32 bmz8_packed_size(cmph_t *mphf ) 
{ 
  bmz8_data_t *data ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 598
  data = (bmz8_data_t *)mphf->data;
#line 599
  tmp = hash_get_type(*(data->hashes + 0));
#line 599
  h1_type = tmp;
#line 600
  tmp___0 = hash_get_type(*(data->hashes + 1));
#line 600
  h2_type = tmp___0;
#line 602
  tmp___1 = hash_state_packed_size(h1_type);
#line 602
  tmp___2 = hash_state_packed_size(h2_type);
  }
#line 602
  return ((cmph_uint32 )(((((sizeof(CMPH_ALGO ) + (unsigned long )tmp___1) + (unsigned long )tmp___2) + 2UL * sizeof(cmph_uint32 )) + sizeof(cmph_uint8 )) + sizeof(cmph_uint8 ) * (unsigned long )data->n));
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
cmph_uint8 bmz8_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint8 *h1_ptr ;
  register CMPH_HASH h1_type ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp ;
  register CMPH_HASH h2_type ;
  register cmph_uint8 *g_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint8 n ;
  cmph_uint8 *tmp___1 ;
  register cmph_uint8 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint8 h2 ;
  cmph_uint32 tmp___3 ;

  {
  {
#line 615
  h1_ptr = (cmph_uint8 *)packed_mphf;
#line 616
  h1_type = (CMPH_HASH )*((cmph_uint32 *)h1_ptr);
#line 617
  h1_ptr += 4;
#line 619
  tmp = hash_state_packed_size(h1_type);
#line 619
  h2_ptr = h1_ptr + tmp;
#line 620
  h2_type = (CMPH_HASH )*((cmph_uint32 *)h2_ptr);
#line 621
  h2_ptr += 4;
#line 623
  tmp___0 = hash_state_packed_size(h2_type);
#line 623
  g_ptr = h2_ptr + tmp___0;
#line 625
  tmp___1 = g_ptr;
#line 625
  g_ptr ++;
#line 625
  n = *tmp___1;
#line 627
  tmp___2 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 627
  h1 = (cmph_uint8 )(tmp___2 % (unsigned int )n);
#line 628
  tmp___3 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 628
  h2 = (cmph_uint8 )(tmp___3 % (unsigned int )n);
  }
#line 630
  if ((int )h1 == (int )h2) {
#line 630
    h2 = (cmph_uint8 )((int )h2 + 1);
#line 630
    if ((int )h2 > (int )n) {
#line 630
      h2 = (cmph_uint8 )0;
    }
  }
#line 631
  return ((cmph_uint8 )((int )*(g_ptr + h1) + (int )*(g_ptr + h2)));
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.h"
buffer_manager_t *buffer_manager_new(cmph_uint32 memory_avail , cmph_uint32 nentries ) ;
#line 9
void buffer_manager_open(buffer_manager_t *buffer_manager , cmph_uint32 index , char *filename ) ;
#line 10
cmph_uint8 *buffer_manager_read_key(buffer_manager_t *buffer_manager , cmph_uint32 index ,
                                    cmph_uint32 *keylen ) ;
#line 11
void buffer_manager_destroy(buffer_manager_t *buffer_manager ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.h"
buffer_entry_t *buffer_entry_new(cmph_uint32 capacity ) ;
#line 9
void buffer_entry_set_capacity(buffer_entry_t *buffer_entry , cmph_uint32 capacity ) ;
#line 10
cmph_uint32 buffer_entry_get_capacity(buffer_entry_t *buffer_entry ) ;
#line 11
void buffer_entry_open(buffer_entry_t *buffer_entry , char *filename ) ;
#line 12
cmph_uint8 *buffer_entry_read_key(buffer_entry_t *buffer_entry , cmph_uint32 *keylen ) ;
#line 13
void buffer_entry_destroy(buffer_entry_t *buffer_entry ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c"
buffer_manager_t *buffer_manager_new(cmph_uint32 memory_avail , cmph_uint32 nentries ) 
{ 
  cmph_uint32 memory_avail_entry ;
  cmph_uint32 i ;
  buffer_manager_t *buff_manager ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 18
  tmp = malloc(sizeof(buffer_manager_t ));
#line 18
  buff_manager = (buffer_manager_t *)tmp;
  }
#line 19
  if (! buff_manager) {
    {
#line 19
    __assert_fail("buff_manager", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c",
                  19U, "buffer_manager_new");
    }
  }
  {
#line 20
  buff_manager->memory_avail = memory_avail;
#line 21
  tmp___0 = calloc((size_t )nentries, sizeof(buffer_entry_t *));
#line 21
  buff_manager->buffer_entries = (buffer_entry_t **)tmp___0;
#line 22
  tmp___1 = calloc((size_t )nentries, sizeof(cmph_uint32 ));
#line 22
  buff_manager->memory_avail_list = (cmph_uint32 *)tmp___1;
#line 23
  buff_manager->pos_avail_list = -1;
#line 24
  buff_manager->nentries = nentries;
#line 25
  memory_avail_entry = buff_manager->memory_avail / buff_manager->nentries + 1U;
#line 26
  i = (cmph_uint32 )0;
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (i < buff_manager->nentries)) {
#line 26
      goto while_break;
    }
    {
#line 28
    *(buff_manager->buffer_entries + i) = buffer_entry_new(memory_avail_entry);
#line 26
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return (buff_manager);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c"
void buffer_manager_open(buffer_manager_t *buffer_manager , cmph_uint32 index , char *filename ) 
{ 


  {
  {
#line 35
  buffer_entry_open(*(buffer_manager->buffer_entries + index), filename);
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c"
cmph_uint8 *buffer_manager_read_key(buffer_manager_t *buffer_manager , cmph_uint32 index ,
                                    cmph_uint32 *keylen ) 
{ 
  cmph_uint8 *key ;
  cmph_uint32 new_capacity ;
  cmph_uint32 tmp ;
  int tmp___0 ;

  {
#line 40
  key = (cmph_uint8 *)((void *)0);
#line 41
  if (buffer_manager->pos_avail_list >= 0) {
    {
#line 43
    tmp = buffer_entry_get_capacity(*(buffer_manager->buffer_entries + index));
#line 43
    tmp___0 = buffer_manager->pos_avail_list;
#line 43
    (buffer_manager->pos_avail_list) --;
#line 43
    new_capacity = tmp + *(buffer_manager->memory_avail_list + tmp___0);
#line 44
    buffer_entry_set_capacity(*(buffer_manager->buffer_entries + index), new_capacity);
    }
  }
  {
#line 46
  key = buffer_entry_read_key(*(buffer_manager->buffer_entries + index), keylen);
  }
#line 47
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 49
    (buffer_manager->pos_avail_list) ++;
#line 49
    *(buffer_manager->memory_avail_list + buffer_manager->pos_avail_list) = buffer_entry_get_capacity(*(buffer_manager->buffer_entries + index));
    }
  }
#line 51
  return (key);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_manager.c"
void buffer_manager_destroy(buffer_manager_t *buffer_manager ) 
{ 
  cmph_uint32 i ;

  {
#line 57
  i = (cmph_uint32 )0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < buffer_manager->nentries)) {
#line 57
      goto while_break;
    }
    {
#line 59
    buffer_entry_destroy(*(buffer_manager->buffer_entries + i));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  free((void *)buffer_manager->memory_avail_list);
#line 62
  free((void *)buffer_manager->buffer_entries);
#line 63
  free((void *)buffer_manager);
  }
#line 64
  return;
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.h"
void select_init(select_t *sel ) ;
#line 17
void select_destroy(select_t *sel ) ;
#line 19
void select_generate(select_t *sel , cmph_uint32 *keys_vec , cmph_uint32 n , cmph_uint32 m ) ;
#line 21
cmph_uint32 select_query(select_t *sel , cmph_uint32 one_idx ) ;
#line 23
cmph_uint32 select_next_query(select_t *sel , cmph_uint32 vec_bit_idx ) ;
#line 25
cmph_uint32 select_get_space_usage(select_t *sel ) ;
#line 27
void select_dump(select_t *sel , char **buf , cmph_uint32 *buflen ) ;
#line 29
void select_load(select_t *sel , char const   *buf , cmph_uint32 buflen ) ;
#line 37
void select_pack(select_t *sel , void *sel_packed ) ;
#line 43
cmph_uint32 select_packed_size(select_t *sel ) ;
#line 51
cmph_uint32 select_query_packed(void *sel_packed , cmph_uint32 one_idx ) ;
#line 59
cmph_uint32 select_next_query_packed(void *sel_packed , cmph_uint32 vec_bit_idx ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_insert_0(cmph_uint32 *buffer ) 
{ 


  {
#line 26
  *buffer >>= 1;
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_insert_1(cmph_uint32 *buffer ) 
{ 


  {
#line 31
  *buffer >>= 1;
#line 32
  *buffer |= 2147483648U;
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_init(select_t *sel ) 
{ 


  {
#line 37
  sel->n = (cmph_uint32 )0;
#line 38
  sel->m = (cmph_uint32 )0;
#line 39
  sel->bits_vec = (cmph_uint32 *)0;
#line 40
  sel->select_table = (cmph_uint32 *)0;
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_get_space_usage(select_t *sel ) 
{ 
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint32 sel_table_size ;
  register cmph_uint32 space_usage ;

  {
#line 50
  nbits = sel->n + sel->m;
#line 51
  vec_size = (nbits + 31U) >> 5;
#line 52
  sel_table_size = (sel->n >> 7) + 1U;
#line 54
  space_usage = (cmph_uint32 )((2UL * sizeof(cmph_uint32 )) * 8UL);
#line 55
  space_usage += (vec_size * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
#line 56
  space_usage += (sel_table_size * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
#line 57
  return (space_usage);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_destroy(select_t *sel ) 
{ 


  {
  {
#line 62
  free((void *)sel->bits_vec);
#line 63
  free((void *)sel->select_table);
#line 64
  sel->bits_vec = (cmph_uint32 *)0;
#line 65
  sel->select_table = (cmph_uint32 *)0;
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_generate(select_t *sel , cmph_uint32 *keys_vec , cmph_uint32 n , cmph_uint32 m ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 idx ;
  cmph_uint32 buffer ;
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint32 sel_table_size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 97
  buffer = (cmph_uint32 )0;
#line 102
  sel->n = n;
#line 103
  sel->m = m;
#line 105
  nbits = sel->n + sel->m;
#line 106
  vec_size = (nbits + 31U) >> 5;
#line 108
  sel_table_size = (sel->n >> 7) + 1U;
#line 110
  if (sel->bits_vec) {
    {
#line 112
    free((void *)sel->bits_vec);
    }
  }
  {
#line 114
  tmp = calloc((size_t )vec_size, sizeof(cmph_uint32 ));
#line 114
  sel->bits_vec = (cmph_uint32 *)tmp;
  }
#line 116
  if (sel->select_table) {
    {
#line 118
    free((void *)sel->select_table);
    }
  }
  {
#line 120
  tmp___0 = calloc((size_t )sel_table_size, sizeof(cmph_uint32 ));
#line 120
  sel->select_table = (cmph_uint32 *)tmp___0;
#line 124
  j = (cmph_uint32 )0;
#line 124
  i = j;
#line 124
  idx = i;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! (*(keys_vec + j) == i)) {
#line 128
        goto while_break___0;
      }
      {
#line 130
      select_insert_1(& buffer);
#line 131
      idx ++;
      }
#line 133
      if ((idx & 31U) == 0U) {
#line 134
        *(sel->bits_vec + ((idx >> 5) - 1U)) = buffer;
      }
#line 135
      j ++;
#line 137
      if (j == sel->n) {
#line 138
        goto loop_end;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    if (i == sel->m) {
#line 144
      goto while_break;
    }
    {
#line 146
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 146
      if (! (*(keys_vec + j) > i)) {
#line 146
        goto while_break___1;
      }
      {
#line 148
      select_insert_0(& buffer);
#line 149
      idx ++;
      }
#line 151
      if ((idx & 31U) == 0U) {
#line 152
        *(sel->bits_vec + ((idx >> 5) - 1U)) = buffer;
      }
#line 153
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  loop_end: 
#line 158
  if ((idx & 31U) != 0U) {
#line 160
    buffer >>= 32U - (idx & 31U);
#line 161
    *(sel->bits_vec + ((idx - 1U) >> 5)) = buffer;
  }
  {
#line 164
  select_generate_sel_table(sel);
  }
#line 165
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                          cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_query(select_t *sel , cmph_uint32 one_idx ) 
{ 
  cmph_uint32 tmp ;

  {
  {
#line 192
  tmp = _select_query((cmph_uint8 *)sel->bits_vec, sel->select_table, one_idx);
  }
#line 192
  return (tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_next_query(select_t *sel , cmph_uint32 vec_bit_idx ) 
{ 
  cmph_uint32 tmp ;

  {
  {
#line 219
  tmp = _select_next_query((cmph_uint8 *)sel->bits_vec, vec_bit_idx);
  }
#line 219
  return (tmp);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_dump(select_t *sel , char **buf , cmph_uint32 *buflen ) 
{ 
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint32 sel_table_size ;
  register cmph_uint32 pos ;
  void *tmp ;

  {
  {
#line 224
  nbits = sel->n + sel->m;
#line 225
  vec_size = ((nbits + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 226
  sel_table_size = ((sel->n >> 7) + 1U) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 227
  pos = (cmph_uint32 )0;
#line 229
  *buflen = (2U * (cmph_uint32 )sizeof(cmph_uint32 ) + vec_size) + sel_table_size;
#line 231
  tmp = calloc((size_t )*buflen, sizeof(char ));
#line 231
  *buf = (char *)tmp;
  }
#line 233
  if (! *buf) {
#line 235
    *buflen = 4294967295U;
#line 236
    return;
  }
  {
#line 239
  memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)(& sel->n),
         sizeof(cmph_uint32 ));
#line 240
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 241
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& sel->m),
         sizeof(cmph_uint32 ));
#line 242
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 243
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)sel->bits_vec,
         (size_t )vec_size);
#line 244
  pos += vec_size;
#line 245
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)sel->select_table,
         (size_t )sel_table_size);
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_load(select_t *sel , char const   *buf , cmph_uint32 buflen ) 
{ 
  register cmph_uint32 pos ;
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint32 sel_table_size ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 252
  pos = (cmph_uint32 )0;
#line 253
  nbits = (cmph_uint32 )0;
#line 254
  vec_size = (cmph_uint32 )0;
#line 255
  sel_table_size = (cmph_uint32 )0;
#line 257
  memcpy((void */* __restrict  */)(& sel->n), (void const   */* __restrict  */)buf,
         sizeof(cmph_uint32 ));
#line 258
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 259
  memcpy((void */* __restrict  */)(& sel->m), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 260
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 262
  nbits = sel->n + sel->m;
#line 263
  vec_size = ((nbits + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 264
  sel_table_size = ((sel->n >> 7) + 1U) * (cmph_uint32 )sizeof(cmph_uint32 );
  }
#line 266
  if (sel->bits_vec) {
    {
#line 268
    free((void *)sel->bits_vec);
    }
  }
  {
#line 270
  tmp = calloc((unsigned long )vec_size / sizeof(cmph_uint32 ), sizeof(cmph_uint32 ));
#line 270
  sel->bits_vec = (cmph_uint32 *)tmp;
  }
#line 272
  if (sel->select_table) {
    {
#line 274
    free((void *)sel->select_table);
    }
  }
  {
#line 276
  tmp___0 = calloc((unsigned long )sel_table_size / sizeof(cmph_uint32 ), sizeof(cmph_uint32 ));
#line 276
  sel->select_table = (cmph_uint32 *)tmp___0;
#line 278
  memcpy((void */* __restrict  */)sel->bits_vec, (void const   */* __restrict  */)(buf + pos),
         (size_t )vec_size);
#line 279
  pos += vec_size;
#line 280
  memcpy((void */* __restrict  */)sel->select_table, (void const   */* __restrict  */)(buf + pos),
         (size_t )sel_table_size);
  }
#line 283
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
void select_pack(select_t *sel , void *sel_packed ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;

  {
#line 293
  if (sel) {
#line 293
    if (sel_packed) {
      {
#line 295
      buf = (char *)((void *)0);
#line 296
      buflen = (cmph_uint32 )0;
#line 297
      select_dump(sel, & buf, & buflen);
#line 298
      memcpy((void */* __restrict  */)sel_packed, (void const   */* __restrict  */)buf,
             (size_t )buflen);
#line 299
      free((void *)buf);
      }
    }
  }
#line 301
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_packed_size(select_t *sel ) 
{ 
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint32 sel_table_size ;

  {
#line 310
  nbits = sel->n + sel->m;
#line 311
  vec_size = ((nbits + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 312
  sel_table_size = ((sel->n >> 7) + 1U) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 313
  return ((2U * (cmph_uint32 )sizeof(cmph_uint32 ) + vec_size) + sel_table_size);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_query_packed(void *sel_packed , cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 *ptr ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp ;
  register cmph_uint32 m ;
  cmph_uint32 *tmp___0 ;
  register cmph_uint32 nbits ;
  register cmph_uint32 vec_size ;
  register cmph_uint8 *bits_vec ;
  register cmph_uint32 *select_table ;
  cmph_uint32 tmp___1 ;

  {
  {
#line 320
  ptr = (cmph_uint32 *)sel_packed;
#line 321
  tmp = ptr;
#line 321
  ptr ++;
#line 321
  n = *tmp;
#line 322
  tmp___0 = ptr;
#line 322
  ptr ++;
#line 322
  m = *tmp___0;
#line 323
  nbits = n + m;
#line 324
  vec_size = (nbits + 31U) >> 5;
#line 325
  bits_vec = (cmph_uint8 *)ptr;
#line 326
  select_table = ptr + vec_size;
#line 328
  tmp___1 = _select_query(bits_vec, select_table, one_idx);
  }
#line 328
  return (tmp___1);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
cmph_uint32 select_next_query_packed(void *sel_packed , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint8 *bits_vec ;
  cmph_uint32 tmp ;

  {
  {
#line 334
  bits_vec = (cmph_uint8 *)sel_packed;
#line 335
  bits_vec += 8;
#line 336
  tmp = _select_next_query(bits_vec, vec_bit_idx);
  }
#line 336
  return (tmp);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.h"
vstack_t *vstack_new(void) ;
#line 8
void vstack_destroy(vstack_t *stack ) ;
#line 10
void vstack_push(vstack_t *stack , cmph_uint32 val ) ;
#line 11
cmph_uint32 vstack_top(vstack_t *stack ) ;
#line 12
void vstack_pop(vstack_t *stack ) ;
#line 13
int vstack_empty(vstack_t *stack ) ;
#line 14
cmph_uint32 vstack_size(vstack_t *stack ) ;
#line 16
void vstack_reserve(vstack_t *stack , cmph_uint32 size ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
vstack_t *vstack_new(void) 
{ 
  vstack_t *stack ;
  void *tmp ;

  {
  {
#line 18
  tmp = malloc(sizeof(vstack_t ));
#line 18
  stack = (vstack_t *)tmp;
  }
#line 19
  if (! stack) {
    {
#line 19
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  19U, "vstack_new");
    }
  }
#line 20
  stack->pointer = (cmph_uint32 )0;
#line 21
  stack->values = (cmph_uint32 *)((void *)0);
#line 22
  stack->capacity = (cmph_uint32 )0;
#line 23
  return (stack);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
void vstack_destroy(vstack_t *stack ) 
{ 


  {
#line 28
  if (! stack) {
    {
#line 28
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  28U, "vstack_destroy");
    }
  }
  {
#line 29
  free((void *)stack->values);
#line 30
  free((void *)stack);
  }
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
void vstack_push(vstack_t *stack , cmph_uint32 val ) 
{ 


  {
#line 35
  if (! stack) {
    {
#line 35
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  35U, "vstack_push");
    }
  }
  {
#line 36
  vstack_reserve(stack, stack->pointer + 1U);
#line 37
  *(stack->values + stack->pointer) = val;
#line 38
  (stack->pointer) ++;
  }
#line 39
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
void vstack_pop(vstack_t *stack ) 
{ 


  {
#line 42
  if (! stack) {
    {
#line 42
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  42U, "vstack_pop");
    }
  }
#line 43
  if (! (stack->pointer > 0U)) {
    {
#line 43
    __assert_fail("stack->pointer > 0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  43U, "vstack_pop");
    }
  }
#line 44
  (stack->pointer) --;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
cmph_uint32 vstack_top(vstack_t *stack ) 
{ 


  {
#line 49
  if (! stack) {
    {
#line 49
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  49U, "vstack_top");
    }
  }
#line 50
  if (! (stack->pointer > 0U)) {
    {
#line 50
    __assert_fail("stack->pointer > 0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  50U, "vstack_top");
    }
  }
#line 51
  return (*(stack->values + (stack->pointer - 1U)));
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
int vstack_empty(vstack_t *stack ) 
{ 


  {
#line 55
  if (! stack) {
    {
#line 55
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  55U, "vstack_empty");
    }
  }
#line 56
  return (stack->pointer == 0U);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
cmph_uint32 vstack_size(vstack_t *stack ) 
{ 


  {
#line 60
  return (stack->pointer);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c"
void vstack_reserve(vstack_t *stack , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 64
  if (! stack) {
    {
#line 64
    __assert_fail("stack", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                  64U, "vstack_reserve");
    }
  }
#line 65
  if (stack->capacity < size) {
#line 67
    new_capacity = stack->capacity + 1U;
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      if (! (new_capacity < size)) {
#line 69
        goto while_break;
      }
#line 71
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 73
    tmp = realloc((void *)stack->values, sizeof(cmph_uint32 ) * (unsigned long )new_capacity);
#line 73
    stack->values = (cmph_uint32 *)tmp;
    }
#line 74
    if (! stack->values) {
      {
#line 74
      __assert_fail("stack->values", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vstack.c",
                    74U, "vstack_reserve");
      }
    }
#line 75
    stack->capacity = new_capacity;
  }
#line 78
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
cmph_uint32 graph_edge_id(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) ;
#line 36
int graph_is_cyclic(graph_t *g ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.h"
chm_config_data_t *chm_config_new(void) ;
#line 10
void chm_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void chm_config_destroy(cmph_config_t *mph ) ;
#line 12
cmph_t *chm_new(cmph_config_t *mph , double c ) ;
#line 14
void chm_load(FILE *f , cmph_t *mphf ) ;
#line 15
int chm_dump(cmph_t *mphf , FILE *fd ) ;
#line 16
void chm_destroy(cmph_t *mphf ) ;
#line 17
cmph_uint32 chm_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 24
void chm_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 31
cmph_uint32 chm_packed_size(cmph_t *mphf ) ;
#line 40
cmph_uint32 chm_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___0[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges(cmph_config_t *mph ) ;
#line 18
static void chm_traverse(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
chm_config_data_t *chm_config_new(void) 
{ 
  chm_config_data_t *chm ;
  void *tmp ;

  {
  {
#line 22
  chm = (chm_config_data_t *)((void *)0);
#line 23
  tmp = malloc(sizeof(chm_config_data_t ));
#line 23
  chm = (chm_config_data_t *)tmp;
  }
#line 24
  if (! chm) {
    {
#line 24
    __assert_fail("chm", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c",
                  24U, "chm_config_new");
    }
  }
  {
#line 25
  memset((void *)chm, 0, sizeof(chm_config_data_t ));
#line 26
  chm->hashfuncs[0] = (CMPH_HASH )0;
#line 27
  chm->hashfuncs[1] = (CMPH_HASH )0;
#line 28
  chm->g = (cmph_uint32 *)((void *)0);
#line 29
  chm->graph = (graph_t *)((void *)0);
#line 30
  chm->hashes = (hash_state_t **)((void *)0);
  }
#line 31
  return (chm);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
void chm_config_destroy(cmph_config_t *mph ) 
{ 
  chm_config_data_t *data ;

  {
  {
#line 35
  data = (chm_config_data_t *)mph->data;
#line 37
  free((void *)data);
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
void chm_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  chm_config_data_t *chm ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 42
  chm = (chm_config_data_t *)mph->data;
#line 43
  hashptr = hashfuncs;
#line 44
  i = (cmph_uint32 )0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned int )*hashptr != 1U)) {
#line 45
      goto while_break;
    }
#line 47
    if (i >= 2U) {
#line 47
      goto while_break;
    }
#line 48
    chm->hashfuncs[i] = *hashptr;
#line 49
    i ++;
#line 49
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
cmph_t *chm_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  chm_data_t *chmf ;
  cmph_uint32 i ;
  cmph_uint32 iterations ;
  cmph_uint8 *visited ;
  chm_config_data_t *chm ;
  double tmp ;
  void *tmp___0 ;
  int ok ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 55
  mphf = (cmph_t *)((void *)0);
#line 56
  chmf = (chm_data_t *)((void *)0);
#line 59
  iterations = (cmph_uint32 )20;
#line 60
  visited = (cmph_uint8 *)((void *)0);
#line 61
  chm = (chm_config_data_t *)mph->data;
#line 62
  chm->m = (mph->key_source)->nkeys;
#line 63
  if (c == (double )0) {
#line 63
    c = 2.09;
  }
  {
#line 64
  tmp = ceil(c * (double )(mph->key_source)->nkeys);
#line 64
  chm->n = (cmph_uint32 )tmp;
#line 66
  chm->graph = graph_new(chm->n, chm->m);
#line 69
  tmp___0 = malloc(sizeof(hash_state_t *) * 3UL);
#line 69
  chm->hashes = (hash_state_t **)tmp___0;
#line 70
  i = (cmph_uint32 )0;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < 3U)) {
#line 70
      goto while_break;
    }
#line 70
    *(chm->hashes + i) = (hash_state_t *)((void *)0);
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (mph->verbosity) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys with graph sized %u\n",
            chm->m, chm->n);
    }
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 79
    *(chm->hashes + 0) = hash_state_new(chm->hashfuncs[0], chm->n);
#line 80
    *(chm->hashes + 1) = hash_state_new(chm->hashfuncs[1], chm->n);
#line 81
    ok = chm_gen_edges(mph);
    }
#line 82
    if (! ok) {
      {
#line 84
      iterations --;
#line 85
      hash_state_destroy(*(chm->hashes + 0));
#line 86
      *(chm->hashes + 0) = (hash_state_t *)((void *)0);
#line 87
      hash_state_destroy(*(chm->hashes + 1));
#line 88
      *(chm->hashes + 1) = (hash_state_t *)((void *)0);
      }
#line 90
      if (mph->verbosity) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Acyclic graph creation failure - %u iterations remaining\n",
                iterations);
        }
      }
#line 94
      if (iterations == 0U) {
#line 94
        goto while_break___0;
      }
    } else {
#line 96
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 98
  if (iterations == 0U) {
    {
#line 100
    graph_destroy(chm->graph);
    }
#line 101
    return ((cmph_t *)((void *)0));
  }
#line 105
  if (mph->verbosity) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting assignment step\n");
    }
  }
  {
#line 110
  tmp___1 = malloc((size_t )(chm->n / 8U + 1U));
#line 110
  visited = (cmph_uint8 *)tmp___1;
#line 111
  memset((void *)visited, 0, (size_t )(chm->n / 8U + 1U));
#line 112
  free((void *)chm->g);
#line 113
  tmp___2 = malloc((unsigned long )chm->n * sizeof(cmph_uint32 ));
#line 113
  chm->g = (cmph_uint32 *)tmp___2;
  }
#line 114
  if (! chm->g) {
    {
#line 114
    __assert_fail("chm->g", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c",
                  114U, "chm_new");
    }
  }
#line 115
  i = (cmph_uint32 )0;
  {
#line 115
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 115
    if (! (i < chm->n)) {
#line 115
      goto while_break___1;
    }
#line 117
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___0[i & 7U]) >> (i & 7U))) {
      {
#line 119
      *(chm->g + i) = (cmph_uint32 )0;
#line 120
      chm_traverse(chm, visited, i);
      }
    }
#line 115
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 123
  graph_destroy(chm->graph);
#line 124
  free((void *)visited);
#line 125
  chm->graph = (graph_t *)((void *)0);
#line 127
  tmp___3 = malloc(sizeof(cmph_t ));
#line 127
  mphf = (cmph_t *)tmp___3;
#line 128
  mphf->algo = mph->algo;
#line 129
  tmp___4 = malloc(sizeof(chm_data_t ));
#line 129
  chmf = (chm_data_t *)tmp___4;
#line 130
  chmf->g = chm->g;
#line 131
  chm->g = (cmph_uint32 *)((void *)0);
#line 132
  chmf->hashes = chm->hashes;
#line 133
  chm->hashes = (hash_state_t **)((void *)0);
#line 134
  chmf->n = chm->n;
#line 135
  chmf->m = chm->m;
#line 136
  mphf->data = (void *)chmf;
#line 137
  mphf->size = chm->m;
  }
#line 139
  if (mph->verbosity) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 143
  return (mphf);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___0[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___0[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
int chm_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 two ;
  chm_data_t *data ;
  register size_t nbytes ;

  {
  {
#line 203
  buf = (char *)((void *)0);
#line 205
  two = (cmph_uint32 )2;
#line 206
  data = (chm_data_t *)mphf->data;
#line 209
  __cmph_dump(mphf, fd);
#line 211
  nbytes = fwrite((void const   */* __restrict  */)(& two), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 212
  hash_state_dump(*(data->hashes + 0), & buf, & buflen);
#line 214
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 215
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 216
  free((void *)buf);
#line 218
  hash_state_dump(*(data->hashes + 1), & buf, & buflen);
#line 220
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 221
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 222
  free((void *)buf);
#line 224
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 225
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 227
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->n,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 233
  return (1);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
void chm_load(FILE *f , cmph_t *mphf ) 
{ 
  cmph_uint32 nhashes ;
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 i ;
  chm_data_t *chm ;
  void *tmp ;
  register size_t nbytes ;
  void *tmp___0 ;
  hash_state_t *state ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 239
  buf = (char *)((void *)0);
#line 242
  tmp = malloc(sizeof(chm_data_t ));
#line 242
  chm = (chm_data_t *)tmp;
#line 245
  mphf->data = (void *)chm;
#line 246
  nbytes = fread((void */* __restrict  */)(& nhashes), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 247
  tmp___0 = malloc(sizeof(hash_state_t *) * (unsigned long )(nhashes + 1U));
#line 247
  chm->hashes = (hash_state_t **)tmp___0;
#line 248
  *(chm->hashes + nhashes) = (hash_state_t *)((void *)0);
#line 250
  i = (cmph_uint32 )0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < nhashes)) {
#line 250
      goto while_break;
    }
    {
#line 252
    state = (hash_state_t *)((void *)0);
#line 253
    nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                   (FILE */* __restrict  */)f);
#line 255
    tmp___1 = malloc((size_t )buflen);
#line 255
    buf = (char *)tmp___1;
#line 256
    nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 257
    state = hash_state_load((char const   *)buf, buflen);
#line 258
    *(chm->hashes + i) = state;
#line 259
    free((void *)buf);
#line 250
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  nbytes = fread((void */* __restrict  */)(& chm->n), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 264
  nbytes = fread((void */* __restrict  */)(& chm->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 266
  tmp___2 = malloc(sizeof(cmph_uint32 ) * (unsigned long )chm->n);
#line 266
  chm->g = (cmph_uint32 *)tmp___2;
#line 267
  nbytes = fread((void */* __restrict  */)chm->g, (unsigned long )chm->n * sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 273
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
cmph_uint32 chm_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  chm_data_t *chm ;
  cmph_uint32 h1 ;
  cmph_uint32 tmp ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 279
  chm = (chm_data_t *)mphf->data;
#line 280
  tmp = hash(*(chm->hashes + 0), key, keylen);
#line 280
  h1 = tmp % chm->n;
#line 281
  tmp___0 = hash(*(chm->hashes + 1), key, keylen);
#line 281
  h2 = tmp___0 % chm->n;
  }
#line 283
  if (h1 == h2) {
#line 283
    h2 ++;
#line 283
    if (h2 >= chm->n) {
#line 283
      h2 = (cmph_uint32 )0;
    }
  }
#line 285
  return ((*(chm->g + h1) + *(chm->g + h2)) % chm->m);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
void chm_destroy(cmph_t *mphf ) 
{ 
  chm_data_t *data ;

  {
  {
#line 289
  data = (chm_data_t *)mphf->data;
#line 290
  free((void *)data->g);
#line 291
  hash_state_destroy(*(data->hashes + 0));
#line 292
  hash_state_destroy(*(data->hashes + 1));
#line 293
  free((void *)data->hashes);
#line 294
  free((void *)data);
#line 295
  free((void *)mphf);
  }
#line 296
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
void chm_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  chm_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 305
  data = (chm_data_t *)mphf->data;
#line 306
  ptr = (cmph_uint8 *)packed_mphf;
#line 309
  tmp = hash_get_type(*(data->hashes + 0));
#line 309
  h1_type = tmp;
#line 310
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h1_type;
#line 311
  ptr += sizeof(cmph_uint32 );
#line 314
  hash_state_pack(*(data->hashes + 0), (void *)ptr);
#line 315
  tmp___0 = hash_state_packed_size(h1_type);
#line 315
  ptr += tmp___0;
#line 318
  tmp___1 = hash_get_type(*(data->hashes + 1));
#line 318
  h2_type = tmp___1;
#line 319
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h2_type;
#line 320
  ptr += sizeof(cmph_uint32 );
#line 323
  hash_state_pack(*(data->hashes + 1), (void *)ptr);
#line 324
  tmp___2 = hash_state_packed_size(h2_type);
#line 324
  ptr += tmp___2;
#line 327
  *((cmph_uint32 *)ptr) = data->n;
#line 328
  ptr += sizeof(data->n);
#line 331
  *((cmph_uint32 *)ptr) = data->m;
#line 332
  ptr += sizeof(data->m);
#line 335
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->n);
  }
#line 336
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
cmph_uint32 chm_packed_size(cmph_t *mphf ) 
{ 
  chm_data_t *data ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 345
  data = (chm_data_t *)mphf->data;
#line 346
  tmp = hash_get_type(*(data->hashes + 0));
#line 346
  h1_type = tmp;
#line 347
  tmp___0 = hash_get_type(*(data->hashes + 1));
#line 347
  h2_type = tmp___0;
#line 349
  tmp___1 = hash_state_packed_size(h1_type);
#line 349
  tmp___2 = hash_state_packed_size(h2_type);
  }
#line 349
  return ((cmph_uint32 )((((sizeof(CMPH_ALGO ) + (unsigned long )tmp___1) + (unsigned long )tmp___2) + 4UL * sizeof(cmph_uint32 )) + sizeof(cmph_uint32 ) * (unsigned long )data->n));
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
cmph_uint32 chm_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint8 *h1_ptr ;
  register CMPH_HASH h1_type ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp ;
  register CMPH_HASH h2_type ;
  register cmph_uint32 *g_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint32 m ;
  cmph_uint32 *tmp___2 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 362
  h1_ptr = (cmph_uint8 *)packed_mphf;
#line 363
  h1_type = (CMPH_HASH )*((cmph_uint32 *)h1_ptr);
#line 364
  h1_ptr += 4;
#line 366
  tmp = hash_state_packed_size(h1_type);
#line 366
  h2_ptr = h1_ptr + tmp;
#line 367
  h2_type = (CMPH_HASH )*((cmph_uint32 *)h2_ptr);
#line 368
  h2_ptr += 4;
#line 370
  tmp___0 = hash_state_packed_size(h2_type);
#line 370
  g_ptr = (cmph_uint32 *)(h2_ptr + tmp___0);
#line 372
  tmp___1 = g_ptr;
#line 372
  g_ptr ++;
#line 372
  n = *tmp___1;
#line 373
  tmp___2 = g_ptr;
#line 373
  g_ptr ++;
#line 373
  m = *tmp___2;
#line 375
  tmp___3 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 375
  h1 = tmp___3 % n;
#line 376
  tmp___4 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 376
  h2 = tmp___4 % n;
  }
#line 378
  if (h1 == h2) {
#line 378
    h2 ++;
#line 378
    if (h2 >= n) {
#line 378
      h2 = (cmph_uint32 )0;
    }
  }
#line 380
  return ((*(g_ptr + h1) + *(g_ptr + h2)) % m);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.h"
void cmph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 51
void cmph_config_set_verbosity(cmph_config_t *mph , cmph_uint32 verbosity ) ;
#line 52
void cmph_config_set_graphsize(cmph_config_t *mph , double c ) ;
#line 56
void cmph_config_set_b(cmph_config_t *mph , cmph_uint32 b ) ;
#line 57
void cmph_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) ;
#line 86
void cmph_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 93
cmph_uint32 cmph_packed_size(cmph_t *mphf ) ;
#line 102
cmph_uint32 cmph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.h"
void compressed_rank_init(compressed_rank_t *cr ) ;
#line 21
void compressed_rank_destroy(compressed_rank_t *cr ) ;
#line 23
void compressed_rank_generate(compressed_rank_t *cr , cmph_uint32 *vals_table , cmph_uint32 n ) ;
#line 39
void compressed_rank_pack(compressed_rank_t *cr , void *cr_packed ) ;
#line 45
cmph_uint32 compressed_rank_packed_size(compressed_rank_t *cr ) ;
#line 53
cmph_uint32 compressed_rank_query_packed(void *cr_packed , cmph_uint32 idx ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.h"
chd_config_data_t *chd_config_new(cmph_config_t *mph ) ;
#line 11
void chd_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 18
void chd_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) ;
#line 25
void chd_config_set_b(cmph_config_t *mph , cmph_uint32 keys_per_bucket ) ;
#line 26
void chd_config_destroy(cmph_config_t *mph ) ;
#line 30
cmph_t *chd_new(cmph_config_t *mph , double c ) ;
#line 31
void chd_load(FILE *fd , cmph_t *mphf ) ;
#line 32
int chd_dump(cmph_t *mphf , FILE *fd ) ;
#line 33
void chd_destroy(cmph_t *mphf ) ;
#line 34
cmph_uint32 chd_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 41
void chd_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 48
cmph_uint32 chd_packed_size(cmph_t *mphf ) ;
#line 57
cmph_uint32 chd_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
chd_config_data_t *chd_config_new(cmph_config_t *mph ) 
{ 
  cmph_io_adapter_t *key_source ;
  chd_config_data_t *chd ;
  void *tmp ;

  {
  {
#line 18
  key_source = mph->key_source;
#line 20
  tmp = malloc(sizeof(chd_config_data_t ));
#line 20
  chd = (chd_config_data_t *)tmp;
  }
#line 21
  if (! chd) {
    {
#line 21
    __assert_fail("chd", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c",
                  21U, "chd_config_new");
    }
  }
  {
#line 22
  memset((void *)chd, 0, sizeof(chd_config_data_t ));
#line 24
  chd->chd_ph = cmph_config_new(key_source);
#line 25
  cmph_config_set_algo(chd->chd_ph, (CMPH_ALGO )7);
  }
#line 27
  return (chd);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_config_destroy(cmph_config_t *mph ) 
{ 
  chd_config_data_t *data ;

  {
#line 32
  data = (chd_config_data_t *)mph->data;
#line 34
  if (data->chd_ph) {
    {
#line 36
    cmph_config_destroy(data->chd_ph);
#line 37
    data->chd_ph = (cmph_config_t *)((void *)0);
    }
  }
  {
#line 39
  free((void *)data);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  chd_config_data_t *data ;

  {
  {
#line 45
  data = (chd_config_data_t *)mph->data;
#line 46
  cmph_config_set_hashfuncs(data->chd_ph, hashfuncs);
  }
#line 47
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_config_set_b(cmph_config_t *mph , cmph_uint32 keys_per_bucket ) 
{ 
  chd_config_data_t *data ;

  {
  {
#line 52
  data = (chd_config_data_t *)mph->data;
#line 53
  cmph_config_set_b(data->chd_ph, keys_per_bucket);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) 
{ 
  chd_config_data_t *data ;

  {
  {
#line 59
  data = (chd_config_data_t *)mph->data;
#line 60
  cmph_config_set_keys_per_bin(data->chd_ph, keys_per_bin);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
cmph_t *chd_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  chd_data_t *chdf ;
  chd_config_data_t *chd ;
  chd_ph_config_data_t *chd_ph ;
  compressed_rank_t cr ;
  register cmph_t *chd_phf ;
  register cmph_uint32 packed_chd_phf_size ;
  cmph_uint8 *packed_chd_phf ;
  register cmph_uint32 packed_cr_size ;
  cmph_uint8 *packed_cr ;
  register cmph_uint32 i ;
  register cmph_uint32 idx ;
  register cmph_uint32 nkeys ;
  register cmph_uint32 nvals ;
  register cmph_uint32 nbins ;
  cmph_uint32 *vals_table ;
  register cmph_uint32 *occup_table ;
  void *tmp ;
  void *tmp___0 ;
  cmph_uint32 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 66
  mphf = (cmph_t *)((void *)0);
#line 67
  chdf = (chd_data_t *)((void *)0);
#line 68
  chd = (chd_config_data_t *)mph->data;
#line 69
  chd_ph = (chd_ph_config_data_t *)(chd->chd_ph)->data;
#line 72
  chd_phf = (cmph_t *)((void *)0);
#line 73
  packed_chd_phf_size = (cmph_uint32 )0;
#line 74
  packed_chd_phf = (cmph_uint8 *)((void *)0);
#line 76
  packed_cr_size = (cmph_uint32 )0;
#line 77
  packed_cr = (cmph_uint8 *)((void *)0);
#line 80
  vals_table = (cmph_uint32 *)((void *)0);
#line 81
  occup_table = (cmph_uint32 *)((void *)0);
#line 88
  cmph_config_set_verbosity(chd->chd_ph, mph->verbosity);
#line 89
  cmph_config_set_graphsize(chd->chd_ph, c);
  }
#line 91
  if (mph->verbosity) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Generating a CHD_PH perfect hash function with a load factor equal to %.3f\n",
            c);
    }
  }
  {
#line 96
  chd_phf = cmph_new(chd->chd_ph);
  }
#line 98
  if ((unsigned long )chd_phf == (unsigned long )((void *)0)) {
#line 100
    return ((cmph_t *)((void *)0));
  }
  {
#line 103
  packed_chd_phf_size = cmph_packed_size(chd_phf);
#line 107
  tmp = calloc((size_t )packed_chd_phf_size, (size_t )1);
#line 107
  packed_chd_phf = (cmph_uint8 *)tmp;
#line 110
  cmph_pack(chd_phf, (void *)packed_chd_phf);
#line 112
  cmph_destroy(chd_phf);
  }
#line 115
  if (mph->verbosity) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compressing the range of the resulting CHD_PH perfect hash function\n");
    }
  }
  {
#line 120
  compressed_rank_init(& cr);
#line 121
  nbins = chd_ph->n;
#line 122
  nkeys = chd_ph->m;
#line 123
  nvals = nbins - nkeys;
#line 125
  tmp___0 = calloc((size_t )nvals, sizeof(cmph_uint32 ));
#line 125
  vals_table = (cmph_uint32 *)tmp___0;
#line 126
  occup_table = (cmph_uint32 *)chd_ph->occup_table;
#line 128
  i = (cmph_uint32 )0;
#line 128
  idx = (cmph_uint32 )0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < nbins)) {
#line 128
      goto while_break;
    }
#line 130
    if (! (*(occup_table + (i >> 5)) & (unsigned int )bitmask32[i & 31U])) {
#line 132
      tmp___1 = idx;
#line 132
      idx ++;
#line 132
      *(vals_table + tmp___1) = i;
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  compressed_rank_generate(& cr, vals_table, nvals);
#line 137
  free((void *)vals_table);
#line 139
  packed_cr_size = compressed_rank_packed_size(& cr);
#line 140
  tmp___2 = calloc((size_t )packed_cr_size, sizeof(cmph_uint8 ));
#line 140
  packed_cr = (cmph_uint8 *)tmp___2;
#line 141
  compressed_rank_pack(& cr, (void *)packed_cr);
#line 142
  compressed_rank_destroy(& cr);
#line 144
  tmp___3 = malloc(sizeof(cmph_t ));
#line 144
  mphf = (cmph_t *)tmp___3;
#line 145
  mphf->algo = mph->algo;
#line 146
  tmp___4 = malloc(sizeof(chd_data_t ));
#line 146
  chdf = (chd_data_t *)tmp___4;
#line 148
  chdf->packed_cr = packed_cr;
#line 149
  packed_cr = (cmph_uint8 *)((void *)0);
#line 151
  chdf->packed_chd_phf = packed_chd_phf;
#line 152
  packed_chd_phf = (cmph_uint8 *)((void *)0);
#line 154
  chdf->packed_chd_phf_size = packed_chd_phf_size;
#line 155
  chdf->packed_cr_size = packed_cr_size;
#line 157
  mphf->data = (void *)chdf;
#line 158
  mphf->size = nkeys;
  }
#line 161
  if (mph->verbosity) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 172
  return (mphf);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_load(FILE *fd , cmph_t *mphf ) 
{ 
  register size_t nbytes ;
  chd_data_t *chd ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 178
  tmp = malloc(sizeof(chd_data_t ));
#line 178
  chd = (chd_data_t *)tmp;
#line 181
  mphf->data = (void *)chd;
#line 183
  nbytes = fread((void */* __restrict  */)(& chd->packed_chd_phf_size), sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)fd);
#line 185
  tmp___0 = calloc((size_t )chd->packed_chd_phf_size, (size_t )1);
#line 185
  chd->packed_chd_phf = (cmph_uint8 *)tmp___0;
#line 186
  nbytes = fread((void */* __restrict  */)chd->packed_chd_phf, (size_t )chd->packed_chd_phf_size,
                 (size_t )1, (FILE */* __restrict  */)fd);
#line 188
  nbytes = fread((void */* __restrict  */)(& chd->packed_cr_size), sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)fd);
#line 190
  tmp___1 = calloc((size_t )chd->packed_cr_size, (size_t )1);
#line 190
  chd->packed_cr = (cmph_uint8 *)tmp___1;
#line 191
  nbytes = fread((void */* __restrict  */)chd->packed_cr, (size_t )chd->packed_cr_size,
                 (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
int chd_dump(cmph_t *mphf , FILE *fd ) 
{ 
  register size_t nbytes ;
  chd_data_t *data ;

  {
  {
#line 197
  data = (chd_data_t *)mphf->data;
#line 199
  __cmph_dump(mphf, fd);
#line 203
  nbytes = fwrite((void const   */* __restrict  */)(& data->packed_chd_phf_size),
                  sizeof(cmph_uint32 ), (size_t )1, (FILE */* __restrict  */)fd);
#line 204
  nbytes = fwrite((void const   */* __restrict  */)data->packed_chd_phf, (size_t )data->packed_chd_phf_size,
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 207
  nbytes = fwrite((void const   */* __restrict  */)(& data->packed_cr_size), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 208
  nbytes = fwrite((void const   */* __restrict  */)data->packed_cr, (size_t )data->packed_cr_size,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 210
  return (1);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_destroy(cmph_t *mphf ) 
{ 
  chd_data_t *data ;

  {
  {
#line 215
  data = (chd_data_t *)mphf->data;
#line 216
  free((void *)data->packed_chd_phf);
#line 217
  free((void *)data->packed_cr);
#line 218
  free((void *)data);
#line 219
  free((void *)mphf);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
__inline static cmph_uint32 _chd_search(void *packed_chd_phf , void *packed_cr , char const   *key ,
                                        cmph_uint32 keylen ) 
{ 
  register cmph_uint32 bin_idx ;
  cmph_uint32 tmp ;
  register cmph_uint32 rank___0 ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 224
  tmp = cmph_search_packed(packed_chd_phf, key, keylen);
#line 224
  bin_idx = tmp;
#line 225
  tmp___0 = compressed_rank_query_packed(packed_cr, bin_idx);
#line 225
  rank___0 = tmp___0;
  }
#line 226
  return (bin_idx - rank___0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
cmph_uint32 chd_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register chd_data_t *chd ;
  cmph_uint32 tmp ;

  {
  {
#line 231
  chd = (chd_data_t *)mphf->data;
#line 232
  tmp = _chd_search((void *)chd->packed_chd_phf, (void *)chd->packed_cr, key, keylen);
  }
#line 232
  return (tmp);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
void chd_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  chd_data_t *data ;
  cmph_uint32 *ptr ;
  cmph_uint8 *ptr8 ;

  {
  {
#line 237
  data = (chd_data_t *)mphf->data;
#line 238
  ptr = (cmph_uint32 *)packed_mphf;
#line 242
  *ptr = data->packed_cr_size;
#line 243
  ptr8 = (cmph_uint8 *)(ptr + 1);
#line 245
  memcpy((void */* __restrict  */)ptr8, (void const   */* __restrict  */)data->packed_cr,
         (size_t )data->packed_cr_size);
#line 246
  ptr8 += data->packed_cr_size;
#line 248
  ptr = (cmph_uint32 *)ptr8;
#line 249
  *ptr = data->packed_chd_phf_size;
#line 251
  ptr8 = (cmph_uint8 *)(ptr + 1);
#line 252
  memcpy((void */* __restrict  */)ptr8, (void const   */* __restrict  */)data->packed_chd_phf,
         (size_t )data->packed_chd_phf_size);
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
cmph_uint32 chd_packed_size(cmph_t *mphf ) 
{ 
  register chd_data_t *data ;

  {
#line 257
  data = (chd_data_t *)mphf->data;
#line 258
  return ((cmph_uint32 )(((sizeof(CMPH_ALGO ) + 2UL * sizeof(cmph_uint32 )) + (unsigned long )data->packed_cr_size) + (unsigned long )data->packed_chd_phf_size));
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd.c"
cmph_uint32 chd_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint32 *ptr ;
  register cmph_uint32 packed_cr_size ;
  cmph_uint32 *tmp ;
  register cmph_uint8 *packed_chd_phf ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 265
  ptr = (cmph_uint32 *)packed_mphf;
#line 266
  tmp = ptr;
#line 266
  ptr ++;
#line 266
  packed_cr_size = *tmp;
#line 267
  packed_chd_phf = ((cmph_uint8 *)ptr + packed_cr_size) + sizeof(cmph_uint32 );
#line 268
  tmp___0 = _chd_search((void *)packed_chd_phf, (void *)ptr, key, keylen);
  }
#line 268
  return (tmp___0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.h"
void compressed_seq_init(compressed_seq_t *cs ) ;
#line 30
void compressed_seq_destroy(compressed_seq_t *cs ) ;
#line 38
void compressed_seq_generate(compressed_seq_t *cs , cmph_uint32 *vals_table , cmph_uint32 n ) ;
#line 47
cmph_uint32 compressed_seq_query(compressed_seq_t *cs , cmph_uint32 idx ) ;
#line 55
cmph_uint32 compressed_seq_get_space_usage(compressed_seq_t *cs ) ;
#line 57
void compressed_seq_dump(compressed_seq_t *cs , char **buf , cmph_uint32 *buflen ) ;
#line 59
void compressed_seq_load(compressed_seq_t *cs , char const   *buf , cmph_uint32 buflen ) ;
#line 67
void compressed_seq_pack(compressed_seq_t *cs , void *cs_packed ) ;
#line 73
cmph_uint32 compressed_seq_packed_size(compressed_seq_t *cs ) ;
#line 82
cmph_uint32 compressed_seq_query_packed(void *cs_packed , cmph_uint32 idx ) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
__inline static void set_bits_value(cmph_uint32 *bits_table , cmph_uint32 index___0 ,
                                    cmph_uint32 bits_string , cmph_uint32 string_length ,
                                    cmph_uint32 string_mask ) 
{ 
  register cmph_uint32 bit_idx ;
  register cmph_uint32 word_idx ;
  register cmph_uint32 shift1 ;
  register cmph_uint32 shift2 ;

  {
#line 116
  bit_idx = index___0 * string_length;
#line 117
  word_idx = bit_idx >> 5;
#line 118
  shift1 = bit_idx & 31U;
#line 119
  shift2 = 32U - shift1;
#line 121
  *(bits_table + word_idx) &= ~ (string_mask << shift1);
#line 122
  *(bits_table + word_idx) |= bits_string << shift1;
#line 124
  if (shift2 < string_length) {
#line 126
    *(bits_table + (word_idx + 1U)) &= ~ (string_mask >> shift2);
#line 127
    *(bits_table + (word_idx + 1U)) |= bits_string >> shift2;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
__inline static cmph_uint32 get_bits_value(cmph_uint32 *bits_table , cmph_uint32 index___0 ,
                                           cmph_uint32 string_length , cmph_uint32 string_mask ) 
{ 
  register cmph_uint32 bit_idx ;
  register cmph_uint32 word_idx ;
  register cmph_uint32 shift1 ;
  register cmph_uint32 shift2 ;
  register cmph_uint32 bits_string ;

  {
#line 133
  bit_idx = index___0 * string_length;
#line 134
  word_idx = bit_idx >> 5;
#line 135
  shift1 = bit_idx & 31U;
#line 136
  shift2 = 32U - shift1;
#line 139
  bits_string = (*(bits_table + word_idx) >> shift1) & string_mask;
#line 141
  if (shift2 < string_length) {
#line 142
    bits_string |= (*(bits_table + (word_idx + 1U)) << shift2) & string_mask;
  }
#line 144
  return (bits_string);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
__inline static void set_bits_at_pos(cmph_uint32 *bits_table , cmph_uint32 pos , cmph_uint32 bits_string ,
                                     cmph_uint32 string_length ) 
{ 
  register cmph_uint32 word_idx ;
  register cmph_uint32 shift1 ;
  register cmph_uint32 shift2 ;
  register cmph_uint32 string_mask ;

  {
#line 149
  word_idx = pos >> 5;
#line 150
  shift1 = pos & 31U;
#line 151
  shift2 = 32U - shift1;
#line 152
  string_mask = (1U << string_length) - 1U;
#line 154
  *(bits_table + word_idx) &= ~ (string_mask << shift1);
#line 155
  *(bits_table + word_idx) |= bits_string << shift1;
#line 156
  if (shift2 < string_length) {
#line 158
    *(bits_table + (word_idx + 1U)) &= ~ (string_mask >> shift2);
#line 159
    *(bits_table + (word_idx + 1U)) |= bits_string >> shift2;
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
__inline static cmph_uint32 get_bits_at_pos(cmph_uint32 *bits_table , cmph_uint32 pos ,
                                            cmph_uint32 string_length ) 
{ 
  register cmph_uint32 word_idx ;
  register cmph_uint32 shift1 ;
  register cmph_uint32 shift2 ;
  register cmph_uint32 string_mask ;
  register cmph_uint32 bits_string ;

  {
#line 165
  word_idx = pos >> 5;
#line 166
  shift1 = pos & 31U;
#line 167
  shift2 = 32U - shift1;
#line 168
  string_mask = (1U << string_length) - 1U;
#line 171
  bits_string = (*(bits_table + word_idx) >> shift1) & string_mask;
#line 173
  if (shift2 < string_length) {
#line 174
    bits_string |= (*(bits_table + (word_idx + 1U)) << shift2) & string_mask;
  }
#line 175
  return (bits_string);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
__inline static cmph_uint32 compressed_seq_i_log2(cmph_uint32 x ) 
{ 
  register cmph_uint32 res ;

  {
#line 15
  res = (cmph_uint32 )0;
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if (! (x > 1U)) {
#line 17
      goto while_break;
    }
#line 19
    x >>= 1;
#line 20
    res ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (res);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_init(compressed_seq_t *cs ) 
{ 


  {
  {
#line 27
  select_init(& cs->sel);
#line 28
  cs->n = (cmph_uint32 )0;
#line 29
  cs->rem_r = (cmph_uint32 )0;
#line 30
  cs->length_rems = (cmph_uint32 *)0;
#line 31
  cs->total_length = (cmph_uint32 )0;
#line 32
  cs->store_table = (cmph_uint32 *)0;
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_destroy(compressed_seq_t *cs ) 
{ 


  {
  {
#line 37
  free((void *)cs->store_table);
#line 38
  cs->store_table = (cmph_uint32 *)0;
#line 39
  free((void *)cs->length_rems);
#line 40
  cs->length_rems = (cmph_uint32 *)0;
#line 41
  select_destroy(& cs->sel);
  }
#line 42
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_generate(compressed_seq_t *cs , cmph_uint32 *vals_table , cmph_uint32 n ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 *lengths ;
  void *tmp ;
  register cmph_uint32 rems_mask ;
  register cmph_uint32 stored_value ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 49
  tmp = calloc((size_t )n, sizeof(cmph_uint32 ));
#line 49
  lengths = (cmph_uint32 *)tmp;
#line 53
  cs->n = n;
#line 54
  cs->total_length = (cmph_uint32 )0;
#line 56
  i = (cmph_uint32 )0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < cs->n)) {
#line 56
      goto while_break;
    }
#line 58
    if (*(vals_table + i) == 0U) {
#line 60
      *(lengths + i) = (cmph_uint32 )0;
    } else {
      {
#line 64
      *(lengths + i) = compressed_seq_i_log2(*(vals_table + i) + 1U);
#line 65
      cs->total_length += *(lengths + i);
      }
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (cs->store_table) {
    {
#line 71
    free((void *)cs->store_table);
    }
  }
  {
#line 73
  tmp___0 = calloc((size_t )((cs->total_length + 31U) >> 5), sizeof(cmph_uint32 ));
#line 73
  cs->store_table = (cmph_uint32 *)tmp___0;
#line 74
  cs->total_length = (cmph_uint32 )0;
#line 76
  i = (cmph_uint32 )0;
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! (i < cs->n)) {
#line 76
      goto while_break___0;
    }
#line 78
    if (*(vals_table + i) == 0U) {
#line 79
      goto __Cont;
    }
    {
#line 80
    stored_value = *(vals_table + i) - ((1U << *(lengths + i)) - 1U);
#line 81
    set_bits_at_pos(cs->store_table, cs->total_length, stored_value, *(lengths + i));
#line 82
    cs->total_length += *(lengths + i);
    }
    __Cont: /* CIL Label */ 
#line 76
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  cs->rem_r = compressed_seq_i_log2(cs->total_length / cs->n);
  }
#line 87
  if (cs->rem_r == 0U) {
#line 89
    cs->rem_r = (cmph_uint32 )1;
  }
#line 92
  if (cs->length_rems) {
    {
#line 94
    free((void *)cs->length_rems);
    }
  }
  {
#line 97
  tmp___1 = calloc((size_t )((cs->n * cs->rem_r + 31U) >> 5), sizeof(cmph_uint32 ));
#line 97
  cs->length_rems = (cmph_uint32 *)tmp___1;
#line 99
  rems_mask = (1U << cs->rem_r) - 1U;
#line 100
  cs->total_length = (cmph_uint32 )0;
#line 102
  i = (cmph_uint32 )0;
  }
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (! (i < cs->n)) {
#line 102
      goto while_break___1;
    }
    {
#line 104
    cs->total_length += *(lengths + i);
#line 105
    set_bits_value(cs->length_rems, i, cs->total_length & rems_mask, cs->rem_r, rems_mask);
#line 106
    *(lengths + i) = cs->total_length >> cs->rem_r;
#line 102
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 109
  select_init(& cs->sel);
#line 113
  select_generate(& cs->sel, lengths, cs->n, cs->total_length >> cs->rem_r);
#line 115
  free((void *)lengths);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
cmph_uint32 compressed_seq_get_space_usage(compressed_seq_t *cs ) 
{ 
  register cmph_uint32 space_usage ;
  cmph_uint32 tmp ;

  {
  {
#line 120
  tmp = select_get_space_usage(& cs->sel);
#line 120
  space_usage = tmp;
#line 121
  space_usage += (((cs->total_length + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
#line 122
  space_usage += (((cs->n * cs->rem_r + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
  }
#line 123
  return ((4U * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U + space_usage);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
cmph_uint32 compressed_seq_query(compressed_seq_t *cs , cmph_uint32 idx ) 
{ 
  register cmph_uint32 enc_idx ;
  register cmph_uint32 enc_length ;
  register cmph_uint32 rems_mask ;
  register cmph_uint32 stored_value ;
  register cmph_uint32 sel_res ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 133
  if (! (idx < cs->n)) {
    {
#line 133
    __assert_fail("idx < cs->n", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c",
                  133U, "compressed_seq_query");
    }
  }
#line 135
  rems_mask = (1U << cs->rem_r) - 1U;
#line 137
  if (idx == 0U) {
    {
#line 139
    enc_idx = (cmph_uint32 )0;
#line 140
    sel_res = select_query(& cs->sel, idx);
    }
  } else {
    {
#line 144
    sel_res = select_query(& cs->sel, idx - 1U);
#line 146
    enc_idx = (sel_res - (idx - 1U)) << cs->rem_r;
#line 147
    tmp = get_bits_value(cs->length_rems, idx - 1U, cs->rem_r, rems_mask);
#line 147
    enc_idx += tmp;
#line 149
    sel_res = select_next_query(& cs->sel, sel_res);
    }
  }
  {
#line 152
  enc_length = (sel_res - idx) << cs->rem_r;
#line 153
  tmp___0 = get_bits_value(cs->length_rems, idx, cs->rem_r, rems_mask);
#line 153
  enc_length += tmp___0;
#line 154
  enc_length -= enc_idx;
  }
#line 155
  if (enc_length == 0U) {
#line 156
    return ((cmph_uint32 )0);
  }
  {
#line 158
  stored_value = get_bits_at_pos(cs->store_table, enc_idx, enc_length);
  }
#line 159
  return (stored_value + ((1U << enc_length) - 1U));
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_dump(compressed_seq_t *cs , char **buf , cmph_uint32 *buflen ) 
{ 
  register cmph_uint32 sel_size ;
  cmph_uint32 tmp ;
  register cmph_uint32 length_rems_size ;
  register cmph_uint32 store_table_size ;
  register cmph_uint32 pos ;
  char *buf_sel ;
  cmph_uint32 buflen_sel ;
  void *tmp___0 ;

  {
  {
#line 164
  tmp = select_packed_size(& cs->sel);
#line 164
  sel_size = tmp;
#line 165
  length_rems_size = ((cs->n * cs->rem_r + 31U) >> 5) * 4U;
#line 166
  store_table_size = ((cs->total_length + 31U) >> 5) * 4U;
#line 167
  pos = (cmph_uint32 )0;
#line 168
  buf_sel = (char *)0;
#line 169
  buflen_sel = (cmph_uint32 )0;
#line 171
  *buflen = ((4U * (cmph_uint32 )sizeof(cmph_uint32 ) + sel_size) + length_rems_size) + store_table_size;
#line 176
  tmp___0 = calloc((size_t )*buflen, sizeof(char ));
#line 176
  *buf = (char *)tmp___0;
  }
#line 178
  if (! *buf) {
#line 180
    *buflen = 4294967295U;
#line 181
    return;
  }
  {
#line 185
  memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)(& cs->n),
         sizeof(cmph_uint32 ));
#line 186
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 189
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& cs->rem_r),
         sizeof(cmph_uint32 ));
#line 190
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 193
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& cs->total_length),
         sizeof(cmph_uint32 ));
#line 194
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 199
  select_dump(& cs->sel, & buf_sel, & buflen_sel);
#line 200
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& buflen_sel),
         sizeof(cmph_uint32 ));
#line 201
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 204
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)buf_sel,
         (size_t )buflen_sel);
#line 212
  pos += buflen_sel;
#line 214
  free((void *)buf_sel);
#line 217
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)cs->length_rems,
         (size_t )length_rems_size);
#line 224
  pos += length_rems_size;
#line 227
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)cs->store_table,
         (size_t )store_table_size);
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_load(compressed_seq_t *cs , char const   *buf , cmph_uint32 buflen ) 
{ 
  register cmph_uint32 pos ;
  cmph_uint32 buflen_sel ;
  register cmph_uint32 length_rems_size ;
  register cmph_uint32 store_table_size ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 240
  pos = (cmph_uint32 )0;
#line 241
  buflen_sel = (cmph_uint32 )0;
#line 242
  length_rems_size = (cmph_uint32 )0;
#line 243
  store_table_size = (cmph_uint32 )0;
#line 246
  memcpy((void */* __restrict  */)(& cs->n), (void const   */* __restrict  */)buf,
         sizeof(cmph_uint32 ));
#line 247
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 250
  memcpy((void */* __restrict  */)(& cs->rem_r), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 251
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 254
  memcpy((void */* __restrict  */)(& cs->total_length), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 255
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 259
  memcpy((void */* __restrict  */)(& buflen_sel), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 260
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 263
  select_load(& cs->sel, buf + pos, buflen_sel);
#line 271
  pos += buflen_sel;
  }
#line 274
  if (cs->length_rems) {
    {
#line 276
    free((void *)cs->length_rems);
    }
  }
  {
#line 278
  length_rems_size = (cs->n * cs->rem_r + 31U) >> 5;
#line 279
  tmp = calloc((size_t )length_rems_size, sizeof(cmph_uint32 ));
#line 279
  cs->length_rems = (cmph_uint32 *)tmp;
#line 280
  length_rems_size *= 4U;
#line 281
  memcpy((void */* __restrict  */)cs->length_rems, (void const   */* __restrict  */)(buf + pos),
         (size_t )length_rems_size);
#line 289
  pos += length_rems_size;
#line 292
  store_table_size = (cs->total_length + 31U) >> 5;
  }
#line 293
  if (cs->store_table) {
    {
#line 295
    free((void *)cs->store_table);
    }
  }
  {
#line 297
  tmp___0 = calloc((size_t )store_table_size, sizeof(cmph_uint32 ));
#line 297
  cs->store_table = (cmph_uint32 *)tmp___0;
#line 298
  store_table_size *= 4U;
#line 299
  memcpy((void */* __restrict  */)cs->store_table, (void const   */* __restrict  */)(buf + pos),
         (size_t )store_table_size);
  }
#line 309
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
void compressed_seq_pack(compressed_seq_t *cs , void *cs_packed ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;

  {
#line 313
  if (cs) {
#line 313
    if (cs_packed) {
      {
#line 315
      buf = (char *)((void *)0);
#line 316
      buflen = (cmph_uint32 )0;
#line 317
      compressed_seq_dump(cs, & buf, & buflen);
#line 318
      memcpy((void */* __restrict  */)cs_packed, (void const   */* __restrict  */)buf,
             (size_t )buflen);
#line 319
      free((void *)buf);
      }
    }
  }
#line 322
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
cmph_uint32 compressed_seq_packed_size(compressed_seq_t *cs ) 
{ 
  register cmph_uint32 sel_size ;
  cmph_uint32 tmp ;
  register cmph_uint32 store_table_size ;
  register cmph_uint32 length_rems_size ;

  {
  {
#line 326
  tmp = select_packed_size(& cs->sel);
#line 326
  sel_size = tmp;
#line 327
  store_table_size = ((cs->total_length + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 328
  length_rems_size = ((cs->n * cs->rem_r + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
  }
#line 329
  return (((4U * (cmph_uint32 )sizeof(cmph_uint32 ) + sel_size) + store_table_size) + length_rems_size);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_seq.c"
cmph_uint32 compressed_seq_query_packed(void *cs_packed , cmph_uint32 idx ) 
{ 
  register cmph_uint32 *ptr ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp ;
  register cmph_uint32 rem_r ;
  cmph_uint32 *tmp___0 ;
  register cmph_uint32 buflen_sel ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint32 *sel_packed ;
  register cmph_uint32 *length_rems ;
  register cmph_uint32 length_rems_size ;
  register cmph_uint32 *store_table ;
  register cmph_uint32 enc_idx ;
  register cmph_uint32 enc_length ;
  register cmph_uint32 rems_mask ;
  register cmph_uint32 stored_value ;
  register cmph_uint32 sel_res ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;

  {
#line 336
  ptr = (cmph_uint32 *)cs_packed;
#line 337
  tmp = ptr;
#line 337
  ptr ++;
#line 337
  n = *tmp;
#line 338
  tmp___0 = ptr;
#line 338
  ptr ++;
#line 338
  rem_r = *tmp___0;
#line 339
  ptr ++;
#line 341
  tmp___1 = ptr;
#line 341
  ptr ++;
#line 341
  buflen_sel = *tmp___1;
#line 342
  sel_packed = ptr;
#line 343
  ptr += buflen_sel >> 2;
#line 343
  length_rems = ptr;
#line 344
  length_rems_size = (n * rem_r + 31U) >> 5;
#line 345
  ptr += length_rems_size;
#line 345
  store_table = ptr;
#line 353
  rems_mask = (1U << rem_r) - 1U;
#line 355
  if (idx == 0U) {
    {
#line 357
    enc_idx = (cmph_uint32 )0;
#line 358
    sel_res = select_query_packed((void *)sel_packed, idx);
    }
  } else {
    {
#line 362
    sel_res = select_query_packed((void *)sel_packed, idx - 1U);
#line 364
    enc_idx = (sel_res - (idx - 1U)) << rem_r;
#line 365
    tmp___2 = get_bits_value(length_rems, idx - 1U, rem_r, rems_mask);
#line 365
    enc_idx += tmp___2;
#line 367
    sel_res = select_next_query_packed((void *)sel_packed, sel_res);
    }
  }
  {
#line 370
  enc_length = (sel_res - idx) << rem_r;
#line 371
  tmp___3 = get_bits_value(length_rems, idx, rem_r, rems_mask);
#line 371
  enc_length += tmp___3;
#line 372
  enc_length -= enc_idx;
  }
#line 373
  if (enc_length == 0U) {
#line 374
    return ((cmph_uint32 )0);
  }
  {
#line 376
  stored_value = get_bits_at_pos(store_table, enc_idx, enc_length);
  }
#line 377
  return (stored_value + ((1U << enc_length) - 1U));
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.h"
fch_buckets_t *fch_buckets_new(cmph_uint32 nbuckets ) ;
#line 9
cmph_uint8 fch_buckets_is_empty(fch_buckets_t *buckets , cmph_uint32 index ) ;
#line 11
void fch_buckets_insert(fch_buckets_t *buckets , cmph_uint32 index , char *key , cmph_uint32 length ) ;
#line 13
cmph_uint32 fch_buckets_get_size(fch_buckets_t *buckets , cmph_uint32 index ) ;
#line 15
char *fch_buckets_get_key(fch_buckets_t *buckets , cmph_uint32 index , cmph_uint32 index_key ) ;
#line 17
cmph_uint32 fch_buckets_get_keylength(fch_buckets_t *buckets , cmph_uint32 index ,
                                      cmph_uint32 index_key ) ;
#line 20
cmph_uint32 fch_buckets_get_max_size(fch_buckets_t *buckets ) ;
#line 23
cmph_uint32 fch_buckets_get_nbuckets(fch_buckets_t *buckets ) ;
#line 25
cmph_uint32 *fch_buckets_get_indexes_sorted_by_size(fch_buckets_t *buckets ) ;
#line 27
void fch_buckets_print(fch_buckets_t *buckets ) ;
#line 29
void fch_buckets_destroy(fch_buckets_t *buckets ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
fch_buckets_t *fch_buckets_new(cmph_uint32 nbuckets ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 118
  tmp = malloc(sizeof(fch_buckets_t ));
#line 118
  buckets = (fch_buckets_t *)tmp;
  }
#line 119
  if (! buckets) {
    {
#line 119
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  119U, "fch_buckets_new");
    }
  }
  {
#line 120
  tmp___0 = calloc((size_t )nbuckets, sizeof(fch_bucket_t ));
#line 120
  buckets->values = (fch_bucket_t *)tmp___0;
#line 121
  i = (cmph_uint32 )0;
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < nbuckets)) {
#line 121
      goto while_break;
    }
    {
#line 121
    fch_bucket_new(buckets->values + i);
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (! buckets->values) {
    {
#line 122
    __assert_fail("buckets->values", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  122U, "fch_buckets_new");
    }
  }
#line 123
  buckets->nbuckets = nbuckets;
#line 124
  buckets->max_size = (cmph_uint32 )0;
#line 125
  return (buckets);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint8 fch_buckets_is_empty(fch_buckets_t *buckets , cmph_uint32 index ) 
{ 
  cmph_uint8 tmp ;

  {
#line 130
  if (! (index < buckets->nbuckets)) {
    {
#line 130
    __assert_fail("index < buckets->nbuckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  130U, "fch_buckets_is_empty");
    }
  }
  {
#line 131
  tmp = fch_bucket_is_empty(buckets->values + index);
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
void fch_buckets_insert(fch_buckets_t *buckets , cmph_uint32 index , char *key , cmph_uint32 length ) 
{ 
  cmph_uint32 tmp ;

  {
#line 136
  if (! (index < buckets->nbuckets)) {
    {
#line 136
    __assert_fail("index < buckets->nbuckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  136U, "fch_buckets_insert");
    }
  }
  {
#line 137
  fch_bucket_insert(buckets->values + index, key, length);
#line 138
  tmp = fch_bucket_size(buckets->values + index);
  }
#line 138
  if (tmp > buckets->max_size) {
    {
#line 140
    buckets->max_size = fch_bucket_size(buckets->values + index);
    }
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint32 fch_buckets_get_size(fch_buckets_t *buckets , cmph_uint32 index ) 
{ 
  cmph_uint32 tmp ;

  {
#line 146
  if (! (index < buckets->nbuckets)) {
    {
#line 146
    __assert_fail("index < buckets->nbuckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  146U, "fch_buckets_get_size");
    }
  }
  {
#line 147
  tmp = fch_bucket_size(buckets->values + index);
  }
#line 147
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
char *fch_buckets_get_key(fch_buckets_t *buckets , cmph_uint32 index , cmph_uint32 index_key ) 
{ 
  char *tmp ;

  {
#line 153
  if (! (index < buckets->nbuckets)) {
    {
#line 153
    __assert_fail("index < buckets->nbuckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  153U, "fch_buckets_get_key");
    }
  }
  {
#line 154
  tmp = fch_bucket_get_key(buckets->values + index, index_key);
  }
#line 154
  return (tmp);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint32 fch_buckets_get_keylength(fch_buckets_t *buckets , cmph_uint32 index ,
                                      cmph_uint32 index_key ) 
{ 
  cmph_uint32 tmp ;

  {
#line 159
  if (! (index < buckets->nbuckets)) {
    {
#line 159
    __assert_fail("index < buckets->nbuckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  159U, "fch_buckets_get_keylength");
    }
  }
  {
#line 160
  tmp = fch_bucket_get_length(buckets->values + index, index_key);
  }
#line 160
  return (tmp);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint32 fch_buckets_get_max_size(fch_buckets_t *buckets ) 
{ 


  {
#line 165
  return (buckets->max_size);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint32 fch_buckets_get_nbuckets(fch_buckets_t *buckets ) 
{ 


  {
#line 170
  return (buckets->nbuckets);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
cmph_uint32 *fch_buckets_get_indexes_sorted_by_size(fch_buckets_t *buckets ) 
{ 
  int i ;
  cmph_uint32 sum ;
  cmph_uint32 value ;
  cmph_uint32 *nbuckets_size ;
  void *tmp ;
  cmph_uint32 *sorted_indexes ;
  void *tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;

  {
  {
#line 175
  i = 0;
#line 176
  sum = (cmph_uint32 )0;
#line 177
  tmp = calloc((size_t )buckets->max_size + 1UL, sizeof(cmph_uint32 ));
#line 177
  nbuckets_size = (cmph_uint32 *)tmp;
#line 178
  tmp___0 = calloc((size_t )buckets->nbuckets, sizeof(cmph_uint32 ));
#line 178
  sorted_indexes = (cmph_uint32 *)tmp___0;
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((cmph_uint32 )i < buckets->nbuckets)) {
#line 181
      goto while_break;
    }
    {
#line 181
    tmp___1 = fch_bucket_size(buckets->values + i);
#line 181
    (*(nbuckets_size + tmp___1)) ++;
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  value = *(nbuckets_size + buckets->max_size);
#line 185
  *(nbuckets_size + buckets->max_size) = sum;
#line 186
  i = (int )buckets->max_size - 1;
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (i >= 0)) {
#line 186
      goto while_break___0;
    }
#line 188
    sum += value;
#line 189
    value = *(nbuckets_size + i);
#line 190
    *(nbuckets_size + i) = sum;
#line 186
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 193
    if (! ((cmph_uint32 )i < buckets->nbuckets)) {
#line 193
      goto while_break___1;
    }
    {
#line 195
    tmp___2 = fch_bucket_size(buckets->values + i);
#line 195
    *(sorted_indexes + *(nbuckets_size + tmp___2)) = (cmph_uint32 )i;
#line 196
    tmp___3 = fch_bucket_size(buckets->values + i);
#line 196
    (*(nbuckets_size + tmp___3)) ++;
#line 193
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 198
  free((void *)nbuckets_size);
  }
#line 199
  return (sorted_indexes);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
void fch_buckets_print(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 i ;

  {
#line 205
  i = (cmph_uint32 )0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < buckets->nbuckets)) {
#line 205
      goto while_break;
    }
    {
#line 205
    fch_bucket_print(buckets->values + i, i);
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
void fch_buckets_destroy(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 i ;

  {
#line 211
  i = (cmph_uint32 )0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < buckets->nbuckets)) {
#line 211
      goto while_break;
    }
    {
#line 211
    fch_bucket_destroy(buckets->values + i);
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  free((void *)buckets->values);
#line 213
  free((void *)buckets);
  }
#line 214
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.h"
void graph_del_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) ;
#line 38
void graph_print(graph_t *g ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___1[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY  =    4294967295U;
#line 36 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
graph_t *graph_new(cmph_uint32 nnodes , cmph_uint32 nedges ) 
{ 
  graph_t *graph ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 38
  tmp = malloc(sizeof(graph_t ));
#line 38
  graph = (graph_t *)tmp;
  }
#line 39
  if (! graph) {
#line 39
    return ((graph_t *)((void *)0));
  }
  {
#line 41
  tmp___0 = malloc((sizeof(cmph_uint32 ) * 2UL) * (unsigned long )nedges);
#line 41
  graph->edges = (cmph_uint32 *)tmp___0;
#line 42
  tmp___1 = malloc((sizeof(cmph_uint32 ) * 2UL) * (unsigned long )nedges);
#line 42
  graph->next = (cmph_uint32 *)tmp___1;
#line 43
  tmp___2 = malloc(sizeof(cmph_uint32 ) * (unsigned long )nnodes);
#line 43
  graph->first = (cmph_uint32 *)tmp___2;
#line 44
  graph->critical_nodes = (cmph_uint8 *)((void *)0);
#line 45
  graph->ncritical_nodes = (cmph_uint32 )0;
#line 46
  graph->nnodes = nnodes;
#line 47
  graph->nedges = nedges;
#line 49
  graph_clear_edges(graph);
  }
#line 50
  return (graph);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_destroy(graph_t *graph ) 
{ 


  {
  {
#line 57
  free((void *)graph->edges);
#line 58
  free((void *)graph->first);
#line 59
  free((void *)graph->next);
#line 60
  free((void *)graph->critical_nodes);
#line 61
  free((void *)graph);
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_print(graph_t *g ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;

  {
#line 68
  i = (cmph_uint32 )0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < g->nnodes)) {
#line 68
      goto while_break;
    }
#line 71
    e = *(g->first + i);
#line 72
    if (e != EMPTY) {
      {
#line 74
      printf((char const   */* __restrict  */)"%u -> %u\n", *(g->edges + e % g->nedges),
             *(g->edges + (e % g->nedges + g->nedges)));
      }
      {
#line 75
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 75
        e = *(g->next + e);
#line 75
        if (! (e != EMPTY)) {
#line 75
          goto while_break___0;
        }
        {
#line 77
        printf((char const   */* __restrict  */)"%u -> %u\n", *(g->edges + e % g->nedges),
               *(g->edges + (e % g->nedges + g->nedges)));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_add_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;

  {
#line 87
  e = g->cedges;
#line 89
  if (! (v1 < g->nnodes)) {
    {
#line 89
    __assert_fail("v1 < g->nnodes", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                  89U, "graph_add_edge");
    }
  }
#line 90
  if (! (v2 < g->nnodes)) {
    {
#line 90
    __assert_fail("v2 < g->nnodes", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                  90U, "graph_add_edge");
    }
  }
#line 91
  if (! (e < g->nedges)) {
    {
#line 91
    __assert_fail("e < g->nedges", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                  91U, "graph_add_edge");
    }
  }
#line 92
  if (! (! g->shrinking)) {
    {
#line 92
    __assert_fail("!g->shrinking", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                  92U, "graph_add_edge");
    }
  }
#line 94
  *(g->next + e) = *(g->first + v1);
#line 95
  *(g->first + v1) = e;
#line 96
  *(g->edges + e) = v2;
#line 98
  *(g->next + (e + g->nedges)) = *(g->first + v2);
#line 99
  *(g->first + v2) = e + g->nedges;
#line 100
  *(g->edges + (e + g->nedges)) = v1;
#line 102
  (g->cedges) ++;
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint32 graph_edge_id(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  int tmp ;
  int tmp___0 ;

  {
#line 116
  e = *(g->first + v1);
#line 117
  if (! (e != EMPTY)) {
    {
#line 117
    __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                  117U, "graph_edge_id");
    }
  }
  {
#line 118
  tmp = check_edge(g, e, v1, v2);
  }
#line 118
  if (tmp) {
#line 118
    return (e % g->nedges);
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    e = *(g->next + e);
#line 122
    if (! (e != EMPTY)) {
      {
#line 122
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    122U, "graph_edge_id");
      }
    }
    {
#line 119
    tmp___0 = check_edge(g, e, v1, v2);
    }
#line 119
    if (tmp___0) {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (e % g->nedges);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_del_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
  {
#line 157
  g->shrinking = 1;
#line 158
  del_edge_point(g, v1, v2);
#line 159
  del_edge_point(g, v2, v1);
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_clear_edges(graph_t *g ) 
{ 
  cmph_uint32 i ;

  {
#line 165
  i = (cmph_uint32 )0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < g->nnodes)) {
#line 165
      goto while_break;
    }
#line 165
    *(g->first + i) = EMPTY;
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  i = (cmph_uint32 )0;
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! (i < g->nedges * 2U)) {
#line 166
      goto while_break___0;
    }
#line 168
    *(g->edges + i) = EMPTY;
#line 169
    *(g->next + i) = EMPTY;
#line 166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 171
  g->cedges = (cmph_uint32 )0;
#line 172
  g->shrinking = 0;
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                    cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___1[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___1[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___1[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
int graph_is_cyclic(graph_t *g ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v ;
  cmph_uint8 *deleted ;
  void *tmp ;
  size_t deleted_len ;

  {
  {
#line 232
  tmp = malloc(((unsigned long )g->nedges * sizeof(cmph_uint8 )) / 8UL + 1UL);
#line 232
  deleted = (cmph_uint8 *)tmp;
#line 233
  deleted_len = (size_t )(g->nedges / 8U + 1U);
#line 234
  memset((void *)deleted, 0, deleted_len);
#line 237
  v = (cmph_uint32 )0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (v < g->nnodes)) {
#line 237
      goto while_break;
    }
    {
#line 239
    cyclic_del_edge(g, v, deleted);
#line 237
    v ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  i = (cmph_uint32 )0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (i < g->nedges)) {
#line 241
      goto while_break___0;
    }
#line 243
    if (! (((int )*(deleted + (i >> 3)) & (int )bitmask___1[i & 7U]) >> (i & 7U))) {
      {
#line 246
      free((void *)deleted);
      }
#line 247
      return (1);
    }
#line 241
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 250
  free((void *)deleted);
  }
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint8 graph_node_is_critical(graph_t *g , cmph_uint32 v ) 
{ 


  {
#line 256
  return ((cmph_uint8 )(((int )*(g->critical_nodes + (v >> 3)) & (int )bitmask___1[v & 7U]) >> (v & 7U)));
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
void graph_obtain_critical_nodes(graph_t *g ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v ;
  cmph_uint8 *deleted ;
  void *tmp ;
  size_t deleted_len ;
  void *tmp___0 ;

  {
  {
#line 263
  tmp = malloc(((unsigned long )g->nedges * sizeof(cmph_uint8 )) / 8UL + 1UL);
#line 263
  deleted = (cmph_uint8 *)tmp;
#line 264
  deleted_len = (size_t )(g->nedges / 8U + 1U);
#line 265
  memset((void *)deleted, 0, deleted_len);
#line 266
  free((void *)g->critical_nodes);
#line 267
  tmp___0 = malloc(((unsigned long )g->nnodes * sizeof(cmph_uint8 )) / 8UL + 1UL);
#line 267
  g->critical_nodes = (cmph_uint8 *)tmp___0;
#line 268
  g->ncritical_nodes = (cmph_uint32 )0;
#line 269
  memset((void *)g->critical_nodes, 0, ((unsigned long )g->nnodes * sizeof(cmph_uint8 )) / 8UL + 1UL);
#line 271
  v = (cmph_uint32 )0;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (v < g->nnodes)) {
#line 271
      goto while_break;
    }
    {
#line 273
    cyclic_del_edge(g, v, deleted);
#line 271
    v ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  i = (cmph_uint32 )0;
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! (i < g->nedges)) {
#line 276
      goto while_break___0;
    }
#line 278
    if (! (((int )*(deleted + (i >> 3)) & (int )bitmask___1[i & 7U]) >> (i & 7U))) {
#line 281
      if (! (((int )*(g->critical_nodes + (*(g->edges + i) >> 3)) & (int )bitmask___1[*(g->edges + i) & 7U]) >> (*(g->edges + i) & 7U))) {
#line 283
        (g->ncritical_nodes) ++;
#line 284
        *(g->critical_nodes + (*(g->edges + i) >> 3)) = (cmph_uint8 )((int )*(g->critical_nodes + (*(g->edges + i) >> 3)) | (int )bitmask___1[*(g->edges + i) & 7U]);
      }
#line 286
      if (! (((int )*(g->critical_nodes + (*(g->edges + (i + g->nedges)) >> 3)) & (int )bitmask___1[*(g->edges + (i + g->nedges)) & 7U]) >> (*(g->edges + (i + g->nedges)) & 7U))) {
#line 288
        (g->ncritical_nodes) ++;
#line 289
        *(g->critical_nodes + (*(g->edges + (i + g->nedges)) >> 3)) = (cmph_uint8 )((int )*(g->critical_nodes + (*(g->edges + (i + g->nedges)) >> 3)) | (int )bitmask___1[*(g->edges + (i + g->nedges)) & 7U]);
      }
    }
#line 276
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 293
  free((void *)deleted);
  }
#line 294
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint8 graph_contains_edge(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  int tmp ;
  int tmp___0 ;

  {
#line 299
  e = *(g->first + v1);
#line 300
  if (e == EMPTY) {
#line 300
    return ((cmph_uint8 )0);
  }
  {
#line 301
  tmp = check_edge(g, e, v1, v2);
  }
#line 301
  if (tmp) {
#line 301
    return ((cmph_uint8 )1);
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    e = *(g->next + e);
#line 305
    if (e == EMPTY) {
#line 305
      return ((cmph_uint8 )0);
    }
    {
#line 302
    tmp___0 = check_edge(g, e, v1, v2);
    }
#line 302
    if (tmp___0) {
#line 302
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return ((cmph_uint8 )1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint32 graph_vertex_id(graph_t *g , cmph_uint32 e , cmph_uint32 id ) 
{ 


  {
#line 313
  return (*(g->edges + (e + id * g->nedges)));
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint32 graph_ncritical_nodes(graph_t *g ) 
{ 


  {
#line 318
  return (g->ncritical_nodes);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
graph_iterator_t graph_neighbors_it(graph_t *g , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;

  {
#line 324
  it.vertex = v;
#line 325
  it.edge = *(g->first + v);
#line 326
  return (it);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
cmph_uint32 graph_next_neighbor(graph_t *g , graph_iterator_t *it ) 
{ 
  cmph_uint32 ret ;

  {
#line 331
  if (it->edge == EMPTY) {
#line 331
    return (4294967295U);
  }
#line 332
  if (*(g->edges + it->edge) == it->vertex) {
#line 332
    ret = *(g->edges + (it->edge + g->nedges));
  } else {
#line 333
    ret = *(g->edges + it->edge);
  }
#line 334
  it->edge = *(g->next + it->edge);
#line 335
  return (ret);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
buffer_entry_t *buffer_entry_new(cmph_uint32 capacity ) 
{ 
  buffer_entry_t *buff_entry ;
  void *tmp ;

  {
  {
#line 19
  tmp = malloc(sizeof(buffer_entry_t ));
#line 19
  buff_entry = (buffer_entry_t *)tmp;
  }
#line 20
  if (! buff_entry) {
    {
#line 20
    __assert_fail("buff_entry", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c",
                  20U, "buffer_entry_new");
    }
  }
#line 21
  buff_entry->fd = (FILE *)((void *)0);
#line 22
  buff_entry->buff = (cmph_uint8 *)((void *)0);
#line 23
  buff_entry->capacity = capacity;
#line 24
  buff_entry->nbytes = capacity;
#line 25
  buff_entry->pos = capacity;
#line 26
  buff_entry->eof = (cmph_uint8 )0;
#line 27
  return (buff_entry);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
void buffer_entry_open(buffer_entry_t *buffer_entry , char *filename ) 
{ 


  {
  {
#line 32
  buffer_entry->fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
void buffer_entry_set_capacity(buffer_entry_t *buffer_entry , cmph_uint32 capacity ) 
{ 


  {
#line 37
  buffer_entry->capacity = capacity;
#line 38
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
cmph_uint32 buffer_entry_get_capacity(buffer_entry_t *buffer_entry ) 
{ 


  {
#line 43
  return (buffer_entry->capacity);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
void buffer_entry_load(buffer_entry_t *buffer_entry ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 48
  free((void *)buffer_entry->buff);
#line 49
  tmp = calloc((size_t )buffer_entry->capacity, sizeof(cmph_uint8 ));
#line 49
  buffer_entry->buff = (cmph_uint8 *)tmp;
#line 50
  tmp___0 = fread((void */* __restrict  */)buffer_entry->buff, (size_t )1, (size_t )buffer_entry->capacity,
                  (FILE */* __restrict  */)buffer_entry->fd);
#line 50
  buffer_entry->nbytes = (cmph_uint32 )tmp___0;
  }
#line 51
  if (buffer_entry->nbytes != buffer_entry->capacity) {
#line 51
    buffer_entry->eof = (cmph_uint8 )1;
  }
#line 52
  buffer_entry->pos = (cmph_uint32 )0;
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
cmph_uint8 *buffer_entry_read_key(buffer_entry_t *buffer_entry , cmph_uint32 *keylen ) 
{ 
  cmph_uint8 *buf ;
  cmph_uint32 lacked_bytes ;
  cmph_uint32 copied_bytes ;
  void *tmp ;

  {
#line 57
  buf = (cmph_uint8 *)((void *)0);
#line 58
  lacked_bytes = (cmph_uint32 )sizeof(*keylen);
#line 59
  copied_bytes = (cmph_uint32 )0;
#line 60
  if (buffer_entry->eof) {
#line 60
    if (buffer_entry->pos == buffer_entry->nbytes) {
      {
#line 62
      free((void *)buf);
      }
#line 63
      return ((cmph_uint8 *)((void *)0));
    }
  }
#line 65
  if (buffer_entry->pos + lacked_bytes > buffer_entry->nbytes) {
#line 67
    copied_bytes = buffer_entry->nbytes - buffer_entry->pos;
#line 68
    lacked_bytes = (buffer_entry->pos + lacked_bytes) - buffer_entry->nbytes;
#line 69
    if (copied_bytes != 0U) {
      {
#line 69
      memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)(buffer_entry->buff + buffer_entry->pos),
             (size_t )copied_bytes);
      }
    }
    {
#line 70
    buffer_entry_load(buffer_entry);
    }
  }
  {
#line 72
  memcpy((void */* __restrict  */)(keylen + copied_bytes), (void const   */* __restrict  */)(buffer_entry->buff + buffer_entry->pos),
         (size_t )lacked_bytes);
#line 73
  buffer_entry->pos += lacked_bytes;
#line 75
  lacked_bytes = *keylen;
#line 76
  copied_bytes = (cmph_uint32 )0;
#line 77
  tmp = malloc((unsigned long )*keylen + sizeof(*keylen));
#line 77
  buf = (cmph_uint8 *)tmp;
#line 78
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)keylen, sizeof(*keylen));
  }
#line 79
  if (buffer_entry->pos + lacked_bytes > buffer_entry->nbytes) {
#line 80
    copied_bytes = buffer_entry->nbytes - buffer_entry->pos;
#line 81
    lacked_bytes = (buffer_entry->pos + lacked_bytes) - buffer_entry->nbytes;
#line 82
    if (copied_bytes != 0U) {
      {
#line 83
      memcpy((void */* __restrict  */)(buf + sizeof(*keylen)), (void const   */* __restrict  */)(buffer_entry->buff + buffer_entry->pos),
             (size_t )copied_bytes);
      }
    }
    {
#line 85
    buffer_entry_load(buffer_entry);
    }
  }
  {
#line 87
  memcpy((void */* __restrict  */)((buf + sizeof(*keylen)) + copied_bytes), (void const   */* __restrict  */)(buffer_entry->buff + buffer_entry->pos),
         (size_t )lacked_bytes);
#line 88
  buffer_entry->pos += lacked_bytes;
  }
#line 89
  return (buf);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/buffer_entry.c"
void buffer_entry_destroy(buffer_entry_t *buffer_entry ) 
{ 


  {
  {
#line 94
  fclose(buffer_entry->fd);
#line 95
  buffer_entry->fd = (FILE *)((void *)0);
#line 96
  free((void *)buffer_entry->buff);
#line 97
  buffer_entry->buff = (cmph_uint8 *)((void *)0);
#line 98
  buffer_entry->capacity = (cmph_uint32 )0;
#line 99
  buffer_entry->nbytes = (cmph_uint32 )0;
#line 100
  buffer_entry->pos = (cmph_uint32 )0;
#line 101
  buffer_entry->eof = (cmph_uint8 )0;
#line 102
  free((void *)buffer_entry);
  }
#line 103
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_types.h"
char const   *cmph_names[10] ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.h"
cmph_io_adapter_t *cmph_io_byte_vector_adapter(cmph_uint8 **vector , cmph_uint32 nkeys ) ;
#line 38
void cmph_io_byte_vector_adapter_destroy(cmph_io_adapter_t *key_source ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
cmph_uint32 fch_calc_b(double c , cmph_uint32 m ) ;
#line 11
double fch_calc_p1(cmph_uint32 m ) ;
#line 12
double fch_calc_p2(cmph_uint32 b ) ;
#line 13
cmph_uint32 mixh10h11h12(cmph_uint32 b , double p1 , double p2 , cmph_uint32 initial_index ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.h"
void hash_vector(hash_state_t *state , char const   *key , cmph_uint32 keylen , cmph_uint32 *hashes ) ;
#line 67
void hash_vector_packed(void *hash_packed___0 , CMPH_HASH hashfunc , char const   *k ,
                        cmph_uint32 keylen , cmph_uint32 *hashes ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.h"
brz_config_data_t *brz_config_new(void) ;
#line 10
void brz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void brz_config_set_tmp_dir(cmph_config_t *mph , cmph_uint8 *tmp_dir ) ;
#line 12
void brz_config_set_mphf_fd(cmph_config_t *mph , FILE *mphf_fd ) ;
#line 13
void brz_config_set_b(cmph_config_t *mph , cmph_uint32 b ) ;
#line 14
void brz_config_set_algo(cmph_config_t *mph , CMPH_ALGO algo ) ;
#line 15
void brz_config_set_memory_availability(cmph_config_t *mph , cmph_uint32 memory_availability ) ;
#line 16
void brz_config_destroy(cmph_config_t *mph ) ;
#line 17
cmph_t *brz_new(cmph_config_t *mph , double c ) ;
#line 19
void brz_load(FILE *f , cmph_t *mphf ) ;
#line 20
int brz_dump(cmph_t *mphf , FILE *fd ) ;
#line 21
void brz_destroy(cmph_t *mphf ) ;
#line 22
cmph_uint32 brz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 29
void brz_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 36
cmph_uint32 brz_packed_size(cmph_t *mphf ) ;
#line 45
cmph_uint32 brz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf(brz_config_data_t *brz , fch_data_t *fchf ,
                                       cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                        cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
brz_config_data_t *brz_config_new(void) 
{ 
  brz_config_data_t *brz ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 29
  brz = (brz_config_data_t *)((void *)0);
#line 30
  tmp = malloc(sizeof(brz_config_data_t ));
#line 30
  brz = (brz_config_data_t *)tmp;
#line 31
  brz->algo = (CMPH_ALGO )4;
#line 32
  brz->b = (cmph_uint8 )128;
#line 33
  brz->hashfuncs[0] = (CMPH_HASH )0;
#line 34
  brz->hashfuncs[1] = (CMPH_HASH )0;
#line 35
  brz->hashfuncs[2] = (CMPH_HASH )0;
#line 36
  brz->size = (cmph_uint8 *)((void *)0);
#line 37
  brz->offset = (cmph_uint32 *)((void *)0);
#line 38
  brz->g = (cmph_uint8 **)((void *)0);
#line 39
  brz->h1 = (hash_state_t **)((void *)0);
#line 40
  brz->h2 = (hash_state_t **)((void *)0);
#line 41
  brz->h0 = (hash_state_t *)((void *)0);
#line 42
  brz->memory_availability = (cmph_uint32 )1048576;
#line 43
  tmp___0 = calloc((size_t )10, sizeof(cmph_uint8 ));
#line 43
  brz->tmp_dir = (cmph_uint8 *)tmp___0;
#line 44
  brz->mphf_fd = (FILE *)((void *)0);
#line 45
  strcpy((char */* __restrict  */)((char *)brz->tmp_dir), (char const   */* __restrict  */)"/var/tmp/");
  }
#line 46
  if (! brz) {
    {
#line 46
    __assert_fail("brz", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                  46U, "brz_config_new");
    }
  }
#line 47
  return (brz);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_destroy(cmph_config_t *mph ) 
{ 
  brz_config_data_t *data ;

  {
  {
#line 52
  data = (brz_config_data_t *)mph->data;
#line 53
  free((void *)data->tmp_dir);
#line 55
  free((void *)data);
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  brz_config_data_t *brz ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 60
  brz = (brz_config_data_t *)mph->data;
#line 61
  hashptr = hashfuncs;
#line 62
  i = (cmph_uint32 )0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((unsigned int )*hashptr != 1U)) {
#line 63
      goto while_break;
    }
#line 65
    if (i >= 3U) {
#line 65
      goto while_break;
    }
#line 66
    brz->hashfuncs[i] = *hashptr;
#line 67
    i ++;
#line 67
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_memory_availability(cmph_config_t *mph , cmph_uint32 memory_availability ) 
{ 
  brz_config_data_t *brz ;

  {
#line 73
  brz = (brz_config_data_t *)mph->data;
#line 74
  if (memory_availability > 0U) {
#line 74
    brz->memory_availability = (memory_availability * 1024U) * 1024U;
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_tmp_dir(cmph_config_t *mph , cmph_uint8 *tmp_dir ) 
{ 
  brz_config_data_t *brz ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 79
  brz = (brz_config_data_t *)mph->data;
#line 80
  if (tmp_dir) {
    {
#line 82
    tmp = strlen((char const   *)((char *)tmp_dir));
#line 82
    len = tmp;
#line 83
    free((void *)brz->tmp_dir);
    }
#line 84
    if ((int )*(tmp_dir + (len - 1UL)) != 47) {
      {
#line 86
      tmp___0 = calloc(len + 2UL, sizeof(cmph_uint8 ));
#line 86
      brz->tmp_dir = (cmph_uint8 *)tmp___0;
#line 87
      sprintf((char */* __restrict  */)((char *)brz->tmp_dir), (char const   */* __restrict  */)"%s/",
              (char *)tmp_dir);
      }
    } else {
      {
#line 91
      tmp___1 = calloc(len + 1UL, sizeof(cmph_uint8 ));
#line 91
      brz->tmp_dir = (cmph_uint8 *)tmp___1;
#line 92
      sprintf((char */* __restrict  */)((char *)brz->tmp_dir), (char const   */* __restrict  */)"%s",
              (char *)tmp_dir);
      }
    }
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_mphf_fd(cmph_config_t *mph , FILE *mphf_fd ) 
{ 
  brz_config_data_t *brz ;

  {
#line 100
  brz = (brz_config_data_t *)mph->data;
#line 101
  brz->mphf_fd = mphf_fd;
#line 102
  if (! brz->mphf_fd) {
    {
#line 102
    __assert_fail("brz->mphf_fd", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                  102U, "brz_config_set_mphf_fd");
    }
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_b(cmph_config_t *mph , cmph_uint32 b ) 
{ 
  brz_config_data_t *brz ;

  {
#line 107
  brz = (brz_config_data_t *)mph->data;
#line 108
  if (b <= 64U) {
#line 110
    b = (cmph_uint32 )128;
  } else
#line 108
  if (b >= 175U) {
#line 110
    b = (cmph_uint32 )128;
  }
#line 112
  brz->b = (cmph_uint8 )b;
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_config_set_algo(cmph_config_t *mph , CMPH_ALGO algo ) 
{ 
  brz_config_data_t *brz ;

  {
#line 117
  if ((unsigned int )algo == 1U) {
#line 119
    brz = (brz_config_data_t *)mph->data;
#line 120
    brz->algo = algo;
  } else
#line 117
  if ((unsigned int )algo == 4U) {
#line 119
    brz = (brz_config_data_t *)mph->data;
#line 120
    brz->algo = algo;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
cmph_t *brz_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  brz_data_t *brzf ;
  cmph_uint32 i ;
  cmph_uint32 iterations ;
  brz_config_data_t *brz ;
  double tmp ;
  void *tmp___0 ;
  int ok ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 126
  mphf = (cmph_t *)((void *)0);
#line 127
  brzf = (brz_data_t *)((void *)0);
#line 129
  iterations = (cmph_uint32 )20;
#line 132
  brz = (brz_config_data_t *)mph->data;
  {
#line 135
  if ((unsigned int )brz->algo == 1U) {
#line 135
    goto case_1;
  }
#line 138
  if ((unsigned int )brz->algo == 4U) {
#line 138
    goto case_4;
  }
#line 141
  goto switch_default;
  case_1: /* CIL Label */ 
#line 136
  if (c == (double )0) {
#line 136
    c = (double )1;
  } else
#line 136
  if (c >= 2.0) {
#line 136
    c = (double )1;
  }
#line 137
  goto switch_break;
  case_4: /* CIL Label */ 
#line 139
  if (c <= 2.0) {
#line 139
    c = 2.6;
  }
#line 140
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 142
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                142U, "brz_new");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 144
  brz->c = c;
#line 145
  brz->m = (mph->key_source)->nkeys;
#line 147
  tmp = ceil((double )brz->m / (double )brz->b);
#line 147
  brz->k = (cmph_uint32 )tmp;
#line 149
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint8 ));
#line 149
  brz->size = (cmph_uint8 *)tmp___0;
  }
#line 152
  if (mph->verbosity) {
    {
#line 154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Partioning the set of keys.\n");
    }
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    brz->h0 = hash_state_new(brz->hashfuncs[2], brz->k);
#line 163
    ok = brz_gen_mphf(mph);
    }
#line 164
    if (! ok) {
      {
#line 166
      iterations --;
#line 167
      hash_state_destroy(brz->h0);
#line 168
      brz->h0 = (hash_state_t *)((void *)0);
      }
#line 170
      if (mph->verbosity) {
        {
#line 172
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failure: A graph with more than 255 keys was created - %u iterations remaining\n",
                iterations);
        }
      }
#line 174
      if (iterations == 0U) {
#line 174
        goto while_break;
      }
    } else {
#line 176
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if (iterations == 0U) {
    {
#line 181
    free((void *)brz->size);
    }
#line 182
    return ((cmph_t *)((void *)0));
  }
  {
#line 186
  tmp___1 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 186
  brz->offset = (cmph_uint32 *)tmp___1;
#line 187
  i = (cmph_uint32 )1;
  }
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i < brz->k)) {
#line 187
      goto while_break___0;
    }
#line 189
    *(brz->offset + i) = (cmph_uint32 )*(brz->size + (i - 1U)) + *(brz->offset + (i - 1U));
#line 187
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 192
  tmp___2 = malloc(sizeof(cmph_t ));
#line 192
  mphf = (cmph_t *)tmp___2;
#line 193
  mphf->algo = mph->algo;
#line 194
  tmp___3 = malloc(sizeof(brz_data_t ));
#line 194
  brzf = (brz_data_t *)tmp___3;
#line 195
  brzf->g = brz->g;
#line 196
  brz->g = (cmph_uint8 **)((void *)0);
#line 197
  brzf->h1 = brz->h1;
#line 198
  brz->h1 = (hash_state_t **)((void *)0);
#line 199
  brzf->h2 = brz->h2;
#line 200
  brz->h2 = (hash_state_t **)((void *)0);
#line 201
  brzf->h0 = brz->h0;
#line 202
  brz->h0 = (hash_state_t *)((void *)0);
#line 203
  brzf->size = brz->size;
#line 204
  brz->size = (cmph_uint8 *)((void *)0);
#line 205
  brzf->offset = brz->offset;
#line 206
  brz->offset = (cmph_uint32 *)((void *)0);
#line 207
  brzf->k = brz->k;
#line 208
  brzf->c = brz->c;
#line 209
  brzf->m = brz->m;
#line 210
  brzf->algo = brz->algo;
#line 211
  mphf->data = (void *)brzf;
#line 212
  mphf->size = brz->m;
  }
#line 214
  if (mph->verbosity) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 218
  return (mphf);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf(brz_config_data_t *brz , fch_data_t *fchf ,
                                       cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                        cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
int brz_dump(cmph_t *mphf , FILE *fd ) 
{ 
  brz_data_t *data ;
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;

  {
  {
#line 562
  data = (brz_data_t *)mphf->data;
#line 563
  buf = (char *)((void *)0);
#line 569
  hash_state_dump(data->h0, & buf, & buflen);
#line 571
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 572
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 573
  free((void *)buf);
#line 575
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 576
  nbytes = fwrite((void const   */* __restrict  */)data->offset, sizeof(cmph_uint32 ) * (unsigned long )data->k,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 577
  return (1);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_load(FILE *f , cmph_t *mphf ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  cmph_uint32 i ;
  cmph_uint32 n ;
  brz_data_t *brz ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 582
  buf = (char *)((void *)0);
#line 586
  tmp = malloc(sizeof(brz_data_t ));
#line 586
  brz = (brz_data_t *)tmp;
#line 589
  mphf->data = (void *)brz;
#line 590
  nbytes = fread((void */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 591
  nbytes = fread((void */* __restrict  */)(& brz->algo), sizeof(brz->algo), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 592
  nbytes = fread((void */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 593
  tmp___0 = malloc(sizeof(cmph_uint8 ) * (unsigned long )brz->k);
#line 593
  brz->size = (cmph_uint8 *)tmp___0;
#line 594
  nbytes = fread((void */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                 (size_t )1, (FILE */* __restrict  */)f);
#line 595
  tmp___1 = malloc(sizeof(hash_state_t *) * (unsigned long )brz->k);
#line 595
  brz->h1 = (hash_state_t **)tmp___1;
#line 596
  tmp___2 = malloc(sizeof(hash_state_t *) * (unsigned long )brz->k);
#line 596
  brz->h2 = (hash_state_t **)tmp___2;
#line 597
  tmp___3 = calloc((size_t )brz->k, sizeof(cmph_uint8 *));
#line 597
  brz->g = (cmph_uint8 **)tmp___3;
#line 600
  i = (cmph_uint32 )0;
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < brz->k)) {
#line 600
      goto while_break;
    }
    {
#line 603
    nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                   (FILE */* __restrict  */)f);
#line 605
    tmp___4 = malloc((size_t )buflen);
#line 605
    buf = (char *)tmp___4;
#line 606
    nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 607
    *(brz->h1 + i) = hash_state_load((char const   *)buf, buflen);
#line 608
    free((void *)buf);
#line 610
    nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                   (FILE */* __restrict  */)f);
#line 612
    tmp___5 = malloc((size_t )buflen);
#line 612
    buf = (char *)tmp___5;
#line 613
    nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 614
    *(brz->h2 + i) = hash_state_load((char const   *)buf, buflen);
#line 615
    free((void *)buf);
    }
    {
#line 618
    if ((unsigned int )brz->algo == 4U) {
#line 618
      goto case_4;
    }
#line 621
    if ((unsigned int )brz->algo == 1U) {
#line 621
      goto case_1;
    }
#line 624
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 619
    n = fch_calc_b(brz->c, (cmph_uint32 )*(brz->size + i));
    }
#line 620
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 622
    tmp___6 = ceil(brz->c * (double )*(brz->size + i));
#line 622
    n = (cmph_uint32 )tmp___6;
    }
#line 623
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 624
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                  624U, "brz_load");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 627
    tmp___7 = calloc((size_t )n, sizeof(cmph_uint8 ));
#line 627
    *(brz->g + i) = (cmph_uint8 *)tmp___7;
#line 628
    nbytes = fread((void */* __restrict  */)*(brz->g + i), sizeof(cmph_uint8 ) * (unsigned long )n,
                   (size_t )1, (FILE */* __restrict  */)f);
#line 600
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 631
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 633
  tmp___8 = malloc((size_t )buflen);
#line 633
  buf = (char *)tmp___8;
#line 634
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 635
  brz->h0 = hash_state_load((char const   *)buf, buflen);
#line 636
  free((void *)buf);
#line 639
  nbytes = fread((void */* __restrict  */)(& brz->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 640
  tmp___9 = malloc(sizeof(cmph_uint32 ) * (unsigned long )brz->k);
#line 640
  brz->offset = (cmph_uint32 *)tmp___9;
#line 641
  nbytes = fread((void */* __restrict  */)brz->offset, sizeof(cmph_uint32 ) * (unsigned long )brz->k,
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 642
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                   cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                  cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
cmph_uint32 brz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  brz_data_t *brz ;
  cmph_uint32 fingerprint[3] ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 687
  brz = (brz_data_t *)mphf->data;
  {
#line 691
  if ((unsigned int )brz->algo == 4U) {
#line 691
    goto case_4;
  }
#line 693
  if ((unsigned int )brz->algo == 1U) {
#line 693
    goto case_1;
  }
#line 695
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 692
  tmp = brz_fch_search(brz, key, keylen, fingerprint);
  }
#line 692
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 694
  tmp___0 = brz_bmz8_search(brz, key, keylen, fingerprint);
  }
#line 694
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 695
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                695U, "brz_search");
  }
  switch_break: /* CIL Label */ ;
  }
#line 697
  return ((cmph_uint32 )0);
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_destroy(cmph_t *mphf ) 
{ 
  cmph_uint32 i ;
  brz_data_t *data ;

  {
#line 702
  data = (brz_data_t *)mphf->data;
#line 703
  if (data->g) {
#line 705
    i = (cmph_uint32 )0;
    {
#line 705
    while (1) {
      while_continue: /* CIL Label */ ;
#line 705
      if (! (i < data->k)) {
#line 705
        goto while_break;
      }
      {
#line 707
      free((void *)*(data->g + i));
#line 708
      hash_state_destroy(*(data->h1 + i));
#line 709
      hash_state_destroy(*(data->h2 + i));
#line 705
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 711
    free((void *)data->g);
#line 712
    free((void *)data->h1);
#line 713
    free((void *)data->h2);
    }
  }
  {
#line 715
  hash_state_destroy(data->h0);
#line 716
  free((void *)data->size);
#line 717
  free((void *)data->offset);
#line 718
  free((void *)data);
#line 719
  free((void *)mphf);
  }
#line 720
  return;
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
void brz_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  brz_data_t *data ;
  cmph_uint8 *ptr ;
  cmph_uint32 i ;
  cmph_uint32 n ;
  CMPH_HASH h0_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp___1 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___2 ;
  cmph_uint64 *g_is_ptr ;
  cmph_uint8 *g_i ;
  cmph_uint64 *tmp___3 ;
  cmph_uint32 tmp___4 ;
  cmph_uint32 tmp___5 ;
  double tmp___6 ;

  {
  {
#line 729
  data = (brz_data_t *)mphf->data;
#line 730
  ptr = (cmph_uint8 *)packed_mphf;
#line 734
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& data->algo),
         sizeof(data->algo));
#line 735
  ptr += sizeof(data->algo);
#line 738
  tmp = hash_get_type(data->h0);
#line 738
  h0_type = tmp;
#line 739
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& h0_type),
         sizeof(h0_type));
#line 740
  ptr += sizeof(h0_type);
#line 743
  hash_state_pack(data->h0, (void *)ptr);
#line 744
  tmp___0 = hash_state_packed_size(h0_type);
#line 744
  ptr += tmp___0;
#line 747
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& data->k),
         sizeof(data->k));
#line 748
  ptr += sizeof(data->k);
#line 751
  *((cmph_uint64 *)ptr) = (cmph_uint64 )data->c;
#line 752
  ptr += sizeof(data->c);
#line 755
  tmp___1 = hash_get_type(*(data->h1 + 0));
#line 755
  h1_type = tmp___1;
#line 756
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& h1_type),
         sizeof(h1_type));
#line 757
  ptr += sizeof(h1_type);
#line 760
  tmp___2 = hash_get_type(*(data->h2 + 0));
#line 760
  h2_type = tmp___2;
#line 761
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(& h2_type),
         sizeof(h2_type));
#line 762
  ptr += sizeof(h2_type);
#line 765
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->size,
         sizeof(cmph_uint8 ) * (unsigned long )data->k);
#line 766
  ptr += data->k;
#line 769
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->offset,
         sizeof(cmph_uint32 ) * (unsigned long )data->k);
#line 770
  ptr += sizeof(cmph_uint32 ) * (unsigned long )data->k;
#line 773
  g_is_ptr = (cmph_uint64 *)ptr;
#line 778
  g_i = (cmph_uint8 *)(g_is_ptr + data->k);
#line 780
  i = (cmph_uint32 )0;
  }
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! (i < data->k)) {
#line 780
      goto while_break;
    }
    {
#line 783
    tmp___3 = g_is_ptr;
#line 783
    g_is_ptr ++;
#line 783
    *tmp___3 = (cmph_uint64 )g_i;
#line 788
    hash_state_pack(*(data->h1 + i), (void *)g_i);
#line 789
    tmp___4 = hash_state_packed_size(h1_type);
#line 789
    g_i += tmp___4;
#line 792
    hash_state_pack(*(data->h2 + i), (void *)g_i);
#line 793
    tmp___5 = hash_state_packed_size(h2_type);
#line 793
    g_i += tmp___5;
    }
    {
#line 798
    if ((unsigned int )data->algo == 4U) {
#line 798
      goto case_4;
    }
#line 801
    if ((unsigned int )data->algo == 1U) {
#line 801
      goto case_1;
    }
#line 804
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 799
    n = fch_calc_b(data->c, (cmph_uint32 )*(data->size + i));
    }
#line 800
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 802
    tmp___6 = ceil(data->c * (double )*(data->size + i));
#line 802
    n = (cmph_uint32 )tmp___6;
    }
#line 803
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 804
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                  804U, "brz_pack");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 806
    memcpy((void */* __restrict  */)g_i, (void const   */* __restrict  */)*(data->g + i),
           sizeof(cmph_uint8 ) * (unsigned long )n);
#line 807
    g_i += n;
#line 780
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
cmph_uint32 brz_packed_size(cmph_t *mphf ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 size ;
  brz_data_t *data ;
  CMPH_HASH h0_type ;
  CMPH_HASH tmp ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp___0 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;
  cmph_uint32 n ;
  double tmp___5 ;

  {
  {
#line 821
  size = (cmph_uint32 )0;
#line 822
  data = (brz_data_t *)mphf->data;
#line 823
  tmp = hash_get_type(data->h0);
#line 823
  h0_type = tmp;
#line 824
  tmp___0 = hash_get_type(*(data->h1 + 0));
#line 824
  h1_type = tmp___0;
#line 825
  tmp___1 = hash_get_type(*(data->h2 + 0));
#line 825
  h2_type = tmp___1;
#line 826
  tmp___2 = hash_state_packed_size(h0_type);
#line 826
  size = (cmph_uint32 )((((((2UL * sizeof(CMPH_ALGO ) + 3UL * sizeof(CMPH_HASH )) + (unsigned long )tmp___2) + sizeof(cmph_uint32 )) + sizeof(double )) + sizeof(cmph_uint8 ) * (unsigned long )data->k) + sizeof(cmph_uint32 ) * (unsigned long )data->k);
#line 830
  size += (cmph_uint32 )sizeof(cmph_uint64 ) * data->k;
#line 835
  tmp___3 = hash_state_packed_size(h1_type);
#line 835
  size += tmp___3 * data->k;
#line 836
  tmp___4 = hash_state_packed_size(h2_type);
#line 836
  size += tmp___4 * data->k;
#line 838
  n = (cmph_uint32 )0;
#line 839
  i = (cmph_uint32 )0;
  }
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! (i < data->k)) {
#line 839
      goto while_break;
    }
    {
#line 843
    if ((unsigned int )data->algo == 4U) {
#line 843
      goto case_4;
    }
#line 846
    if ((unsigned int )data->algo == 1U) {
#line 846
      goto case_1;
    }
#line 849
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 844
    n = fch_calc_b(data->c, (cmph_uint32 )*(data->size + i));
    }
#line 845
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 847
    tmp___5 = ceil(data->c * (double )*(data->size + i));
#line 847
    n = (cmph_uint32 )tmp___5;
    }
#line 848
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 849
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                  849U, "brz_packed_size");
    }
    switch_break: /* CIL Label */ ;
    }
#line 851
    size += n;
#line 839
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  return (size);
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed(cmph_uint32 *packed_mphf , char const   *key ,
                                          cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed(cmph_uint32 *packed_mphf , char const   *key ,
                                         cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
cmph_uint32 brz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint32 *ptr ;
  register CMPH_ALGO algo ;
  cmph_uint32 *tmp ;
  cmph_uint32 fingerprint[3] ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;

  {
#line 973
  ptr = (cmph_uint32 *)packed_mphf;
#line 974
  tmp = ptr;
#line 974
  ptr ++;
#line 974
  algo = (CMPH_ALGO )*tmp;
  {
#line 978
  if ((unsigned int )algo == 4U) {
#line 978
    goto case_4;
  }
#line 980
  if ((unsigned int )algo == 1U) {
#line 980
    goto case_1;
  }
#line 982
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 979
  tmp___0 = brz_fch_search_packed(ptr, key, keylen, fingerprint);
  }
#line 979
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 981
  tmp___1 = brz_bmz8_search_packed(ptr, key, keylen, fingerprint);
  }
#line 981
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 982
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                982U, "brz_search_packed");
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/miller_rabin.h"
cmph_uint8 check_primality(cmph_uint64 n ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/miller_rabin.c"
__inline static cmph_uint64 int_pow(cmph_uint64 a , cmph_uint64 d , cmph_uint64 n ) 
{ 
  cmph_uint64 a_pow ;
  cmph_uint64 res ;

  {
#line 5
  a_pow = a;
#line 6
  res = (cmph_uint64 )1;
  {
#line 7
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7
    if (! (d > 0UL)) {
#line 7
      goto while_break;
    }
#line 9
    if ((d & 1UL) == 1UL) {
#line 10
      res = (res * a_pow) % n;
    }
#line 11
    a_pow = (a_pow * a_pow) % n;
#line 12
    d /= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return (res);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/miller_rabin.c"
__inline static cmph_uint8 check_witness(cmph_uint64 a_exp_d , cmph_uint64 n , cmph_uint64 s ) 
{ 
  cmph_uint64 i ;
  cmph_uint64 a_exp ;

  {
#line 20
  a_exp = a_exp_d;
#line 21
  if (a_exp == 1UL) {
#line 22
    return ((cmph_uint8 )1);
  } else
#line 21
  if (a_exp == n - 1UL) {
#line 22
    return ((cmph_uint8 )1);
  }
#line 23
  i = (cmph_uint64 )1;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i < s)) {
#line 23
      goto while_break;
    }
#line 25
    a_exp = (a_exp * a_exp) % n;
#line 26
    if (a_exp == n - 1UL) {
#line 27
      return ((cmph_uint8 )1);
    }
#line 23
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return ((cmph_uint8 )0);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/miller_rabin.c"
cmph_uint8 check_primality(cmph_uint64 n ) 
{ 
  cmph_uint64 a ;
  cmph_uint64 d ;
  cmph_uint64 s ;
  cmph_uint64 a_exp_d ;
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;
  cmph_uint8 tmp___1 ;

  {
#line 35
  if (n % 2UL == 0UL) {
#line 36
    return ((cmph_uint8 )0);
  }
#line 37
  if (n % 3UL == 0UL) {
#line 38
    return ((cmph_uint8 )0);
  }
#line 39
  if (n % 5UL == 0UL) {
#line 40
    return ((cmph_uint8 )0);
  }
#line 41
  if (n % 7UL == 0UL) {
#line 42
    return ((cmph_uint8 )0);
  }
#line 44
  s = (cmph_uint64 )0;
#line 45
  d = n - 1UL;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    s ++;
#line 49
    d /= 2UL;
#line 46
    if (! (d % 2UL == 0UL)) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  a = (cmph_uint64 )2;
#line 53
  a_exp_d = int_pow(a, d, n);
#line 54
  tmp = check_witness(a_exp_d, n, s);
  }
#line 54
  if ((int )tmp == 0) {
#line 55
    return ((cmph_uint8 )0);
  }
  {
#line 56
  a = (cmph_uint64 )7;
#line 57
  a_exp_d = int_pow(a, d, n);
#line 58
  tmp___0 = check_witness(a_exp_d, n, s);
  }
#line 58
  if ((int )tmp___0 == 0) {
#line 59
    return ((cmph_uint8 )0);
  }
  {
#line 60
  a = (cmph_uint64 )61;
#line 61
  a_exp_d = int_pow(a, d, n);
#line 62
  tmp___1 = check_witness(a_exp_d, n, s);
  }
#line 62
  if ((int )tmp___1 == 0) {
#line 63
    return ((cmph_uint8 )0);
  }
#line 64
  return ((cmph_uint8 )1);
}
}
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.h"
bmz_config_data_t *bmz_config_new(void) ;
#line 10
void bmz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void bmz_config_destroy(cmph_config_t *mph ) ;
#line 12
cmph_t *bmz_new(cmph_config_t *mph , double c ) ;
#line 14
void bmz_load(FILE *f , cmph_t *mphf ) ;
#line 15
int bmz_dump(cmph_t *mphf , FILE *fd ) ;
#line 16
void bmz_destroy(cmph_t *mphf ) ;
#line 17
cmph_uint32 bmz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 24
void bmz_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 31
cmph_uint32 bmz_packed_size(cmph_t *mphf ) ;
#line 40
cmph_uint32 bmz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___2[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes(bmz_config_data_t *bmz , cmph_uint32 v ,
                                              cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                              cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                        cmph_uint32 *biggest_g_value ,
                                                        cmph_uint32 *biggest_edge_value ,
                                                        cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                            cmph_uint8 *visited ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
bmz_config_data_t *bmz_config_new(void) 
{ 
  bmz_config_data_t *bmz ;
  void *tmp ;

  {
  {
#line 25
  bmz = (bmz_config_data_t *)((void *)0);
#line 26
  tmp = malloc(sizeof(bmz_config_data_t ));
#line 26
  bmz = (bmz_config_data_t *)tmp;
  }
#line 27
  if (! bmz) {
    {
#line 27
    __assert_fail("bmz", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                  27U, "bmz_config_new");
    }
  }
  {
#line 28
  memset((void *)bmz, 0, sizeof(bmz_config_data_t ));
#line 29
  bmz->hashfuncs[0] = (CMPH_HASH )0;
#line 30
  bmz->hashfuncs[1] = (CMPH_HASH )0;
#line 31
  bmz->g = (cmph_uint32 *)((void *)0);
#line 32
  bmz->graph = (graph_t *)((void *)0);
#line 33
  bmz->hashes = (hash_state_t **)((void *)0);
  }
#line 34
  return (bmz);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
void bmz_config_destroy(cmph_config_t *mph ) 
{ 
  bmz_config_data_t *data ;

  {
  {
#line 39
  data = (bmz_config_data_t *)mph->data;
#line 41
  free((void *)data);
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
void bmz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  bmz_config_data_t *bmz ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 46
  bmz = (bmz_config_data_t *)mph->data;
#line 47
  hashptr = hashfuncs;
#line 48
  i = (cmph_uint32 )0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned int )*hashptr != 1U)) {
#line 49
      goto while_break;
    }
#line 51
    if (i >= 2U) {
#line 51
      goto while_break;
    }
#line 52
    bmz->hashfuncs[i] = *hashptr;
#line 53
    i ++;
#line 53
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
cmph_t *bmz_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  bmz_data_t *bmzf ;
  cmph_uint32 i ;
  cmph_uint32 iterations ;
  cmph_uint32 iterations_map ;
  cmph_uint8 *used_edges ;
  cmph_uint8 restart_mapping ;
  cmph_uint8 *visited ;
  bmz_config_data_t *bmz ;
  double tmp ;
  void *tmp___0 ;
  cmph_uint32 biggest_g_value ;
  cmph_uint32 biggest_edge_value ;
  int ok ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 59
  mphf = (cmph_t *)((void *)0);
#line 60
  bmzf = (bmz_data_t *)((void *)0);
#line 63
  iterations_map = (cmph_uint32 )20;
#line 64
  used_edges = (cmph_uint8 *)((void *)0);
#line 65
  restart_mapping = (cmph_uint8 )0;
#line 66
  visited = (cmph_uint8 *)((void *)0);
#line 68
  bmz = (bmz_config_data_t *)mph->data;
#line 69
  if (c == (double )0) {
#line 69
    c = 1.15;
  }
  {
#line 71
  bmz->m = (mph->key_source)->nkeys;
#line 72
  tmp = ceil(c * (double )(mph->key_source)->nkeys);
#line 72
  bmz->n = (cmph_uint32 )tmp;
#line 74
  bmz->graph = graph_new(bmz->n, bmz->m);
#line 77
  tmp___0 = malloc(sizeof(hash_state_t *) * 3UL);
#line 77
  bmz->hashes = (hash_state_t **)tmp___0;
#line 78
  i = (cmph_uint32 )0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < 3U)) {
#line 78
      goto while_break;
    }
#line 78
    *(bmz->hashes + i) = (hash_state_t *)((void *)0);
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    biggest_g_value = (cmph_uint32 )0;
#line 84
    biggest_edge_value = (cmph_uint32 )1;
#line 85
    iterations = (cmph_uint32 )100;
#line 86
    if (mph->verbosity) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys with graph sized %u\n",
              bmz->m, bmz->n);
      }
    }
    {
#line 90
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 94
      *(bmz->hashes + 0) = hash_state_new(bmz->hashfuncs[0], bmz->n);
#line 96
      *(bmz->hashes + 1) = hash_state_new(bmz->hashfuncs[1], bmz->n);
#line 98
      ok = bmz_gen_edges(mph);
      }
#line 99
      if (! ok) {
        {
#line 101
        iterations --;
#line 102
        hash_state_destroy(*(bmz->hashes + 0));
#line 103
        *(bmz->hashes + 0) = (hash_state_t *)((void *)0);
#line 104
        hash_state_destroy(*(bmz->hashes + 1));
#line 105
        *(bmz->hashes + 1) = (hash_state_t *)((void *)0);
        }
#line 107
        if (mph->verbosity) {
          {
#line 109
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simple graph creation failure - %u iterations remaining\n",
                  iterations);
          }
        }
#line 111
        if (iterations == 0U) {
#line 111
          goto while_break___1;
        }
      } else {
#line 113
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 115
    if (iterations == 0U) {
      {
#line 117
      graph_destroy(bmz->graph);
      }
#line 118
      return ((cmph_t *)((void *)0));
    }
#line 121
    if (mph->verbosity) {
      {
#line 123
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting ordering step\n");
      }
    }
    {
#line 125
    graph_obtain_critical_nodes(bmz->graph);
    }
#line 128
    if (mph->verbosity) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting Searching step.\n");
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tTraversing critical vertices.\n");
      }
    }
    {
#line 134
    tmp___1 = malloc((size_t )bmz->n / 8UL + 1UL);
#line 134
    visited = (cmph_uint8 *)tmp___1;
#line 135
    memset((void *)visited, 0, (size_t )bmz->n / 8UL + 1UL);
#line 136
    tmp___2 = malloc((size_t )bmz->m / 8UL + 1UL);
#line 136
    used_edges = (cmph_uint8 *)tmp___2;
#line 137
    memset((void *)used_edges, 0, (size_t )bmz->m / 8UL + 1UL);
#line 138
    free((void *)bmz->g);
#line 139
    tmp___3 = calloc((size_t )bmz->n, sizeof(cmph_uint32 ));
#line 139
    bmz->g = (cmph_uint32 *)tmp___3;
    }
#line 140
    if (! bmz->g) {
      {
#line 140
      __assert_fail("bmz->g", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    140U, "bmz_new");
      }
    }
#line 141
    i = (cmph_uint32 )0;
    {
#line 141
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 141
      if (! (i < bmz->n)) {
#line 141
        goto while_break___2;
      }
      {
#line 143
      tmp___4 = graph_node_is_critical(bmz->graph, i);
      }
#line 143
      if (tmp___4) {
#line 143
        if (! (((int )*(visited + (i >> 3)) & (int )bitmask___2[i & 7U]) >> (i & 7U))) {
#line 145
          if (c > 1.14) {
            {
#line 145
            restart_mapping = bmz_traverse_critical_nodes(bmz, i, & biggest_g_value,
                                                          & biggest_edge_value, used_edges,
                                                          visited);
            }
          } else {
            {
#line 146
            restart_mapping = bmz_traverse_critical_nodes_heuristic(bmz, i, & biggest_g_value,
                                                                    & biggest_edge_value,
                                                                    used_edges, visited);
            }
          }
#line 147
          if (restart_mapping) {
#line 147
            goto while_break___2;
          }
        }
      }
#line 141
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 150
    if (! restart_mapping) {
#line 152
      if (mph->verbosity) {
        {
#line 154
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tTraversing non critical vertices.\n");
        }
      }
      {
#line 156
      bmz_traverse_non_critical_nodes(bmz, used_edges, visited);
      }
    } else {
#line 160
      iterations_map --;
#line 161
      if (mph->verbosity) {
        {
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Restarting mapping step. %u iterations remaining.\n",
                iterations_map);
        }
      }
    }
    {
#line 163
    free((void *)used_edges);
#line 164
    free((void *)visited);
    }
#line 80
    if (restart_mapping) {
#line 80
      if (! (iterations_map > 0U)) {
#line 80
        goto while_break___0;
      }
    } else {
#line 80
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 166
  graph_destroy(bmz->graph);
#line 167
  bmz->graph = (graph_t *)((void *)0);
  }
#line 168
  if (iterations_map == 0U) {
#line 170
    return ((cmph_t *)((void *)0));
  }
  {
#line 172
  tmp___5 = malloc(sizeof(cmph_t ));
#line 172
  mphf = (cmph_t *)tmp___5;
#line 173
  mphf->algo = mph->algo;
#line 174
  tmp___6 = malloc(sizeof(bmz_data_t ));
#line 174
  bmzf = (bmz_data_t *)tmp___6;
#line 175
  bmzf->g = bmz->g;
#line 176
  bmz->g = (cmph_uint32 *)((void *)0);
#line 177
  bmzf->hashes = bmz->hashes;
#line 178
  bmz->hashes = (hash_state_t **)((void *)0);
#line 179
  bmzf->n = bmz->n;
#line 180
  bmzf->m = bmz->m;
#line 181
  mphf->data = (void *)bmzf;
#line 182
  mphf->size = bmz->m;
  }
#line 185
  if (mph->verbosity) {
    {
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 189
  return (mphf);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes(bmz_config_data_t *bmz , cmph_uint32 v ,
                                              cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                              cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___2[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___2[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___2[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___2[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___2[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___2[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___2[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                        cmph_uint32 *biggest_g_value ,
                                                        cmph_uint32 *biggest_edge_value ,
                                                        cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___2[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___2[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___2[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___2[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___2[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___2[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___2[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___0(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___2[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                         cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___2[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___0(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___2[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___2[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___2[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___2[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___2[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___2[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___2[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___2[i & 7U]);
#line 403
      bmz_traverse(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
int bmz_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 two ;
  bmz_data_t *data ;
  register size_t nbytes ;

  {
  {
#line 447
  buf = (char *)((void *)0);
#line 449
  two = (cmph_uint32 )2;
#line 450
  data = (bmz_data_t *)mphf->data;
#line 452
  __cmph_dump(mphf, fd);
#line 454
  nbytes = fwrite((void const   */* __restrict  */)(& two), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 456
  hash_state_dump(*(data->hashes + 0), & buf, & buflen);
#line 458
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 459
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 460
  free((void *)buf);
#line 462
  hash_state_dump(*(data->hashes + 1), & buf, & buflen);
#line 464
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 465
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 466
  free((void *)buf);
#line 468
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 469
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 471
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->n,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 478
  return (1);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
void bmz_load(FILE *f , cmph_t *mphf ) 
{ 
  cmph_uint32 nhashes ;
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 i ;
  bmz_data_t *bmz ;
  void *tmp ;
  register size_t nbytes ;
  void *tmp___0 ;
  hash_state_t *state ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 484
  buf = (char *)((void *)0);
#line 487
  tmp = malloc(sizeof(bmz_data_t ));
#line 487
  bmz = (bmz_data_t *)tmp;
#line 490
  mphf->data = (void *)bmz;
#line 491
  nbytes = fread((void */* __restrict  */)(& nhashes), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 492
  tmp___0 = malloc(sizeof(hash_state_t *) * (unsigned long )(nhashes + 1U));
#line 492
  bmz->hashes = (hash_state_t **)tmp___0;
#line 493
  *(bmz->hashes + nhashes) = (hash_state_t *)((void *)0);
#line 495
  i = (cmph_uint32 )0;
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (i < nhashes)) {
#line 495
      goto while_break;
    }
    {
#line 497
    state = (hash_state_t *)((void *)0);
#line 498
    nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                   (FILE */* __restrict  */)f);
#line 500
    tmp___1 = malloc((size_t )buflen);
#line 500
    buf = (char *)tmp___1;
#line 501
    nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 502
    state = hash_state_load((char const   *)buf, buflen);
#line 503
    *(bmz->hashes + i) = state;
#line 504
    free((void *)buf);
#line 495
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 508
  nbytes = fread((void */* __restrict  */)(& bmz->n), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 509
  nbytes = fread((void */* __restrict  */)(& bmz->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 511
  tmp___2 = malloc(sizeof(cmph_uint32 ) * (unsigned long )bmz->n);
#line 511
  bmz->g = (cmph_uint32 *)tmp___2;
#line 512
  nbytes = fread((void */* __restrict  */)bmz->g, (unsigned long )bmz->n * sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 518
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
cmph_uint32 bmz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  bmz_data_t *bmz ;
  cmph_uint32 h1 ;
  cmph_uint32 tmp ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 524
  bmz = (bmz_data_t *)mphf->data;
#line 525
  tmp = hash(*(bmz->hashes + 0), key, keylen);
#line 525
  h1 = tmp % bmz->n;
#line 526
  tmp___0 = hash(*(bmz->hashes + 1), key, keylen);
#line 526
  h2 = tmp___0 % bmz->n;
  }
#line 528
  if (h1 == h2) {
#line 528
    h2 ++;
#line 528
    if (h2 > bmz->n) {
#line 528
      h2 = (cmph_uint32 )0;
    }
  }
#line 530
  return (*(bmz->g + h1) + *(bmz->g + h2));
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
void bmz_destroy(cmph_t *mphf ) 
{ 
  bmz_data_t *data ;

  {
  {
#line 534
  data = (bmz_data_t *)mphf->data;
#line 535
  free((void *)data->g);
#line 536
  hash_state_destroy(*(data->hashes + 0));
#line 537
  hash_state_destroy(*(data->hashes + 1));
#line 538
  free((void *)data->hashes);
#line 539
  free((void *)data);
#line 540
  free((void *)mphf);
  }
#line 541
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
void bmz_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  bmz_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 551
  data = (bmz_data_t *)mphf->data;
#line 552
  ptr = (cmph_uint8 *)packed_mphf;
#line 555
  tmp = hash_get_type(*(data->hashes + 0));
#line 555
  h1_type = tmp;
#line 556
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h1_type;
#line 557
  ptr += sizeof(cmph_uint32 );
#line 560
  hash_state_pack(*(data->hashes + 0), (void *)ptr);
#line 561
  tmp___0 = hash_state_packed_size(h1_type);
#line 561
  ptr += tmp___0;
#line 564
  tmp___1 = hash_get_type(*(data->hashes + 1));
#line 564
  h2_type = tmp___1;
#line 565
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h2_type;
#line 566
  ptr += sizeof(cmph_uint32 );
#line 569
  hash_state_pack(*(data->hashes + 1), (void *)ptr);
#line 570
  tmp___2 = hash_state_packed_size(h2_type);
#line 570
  ptr += tmp___2;
#line 573
  *((cmph_uint32 *)ptr) = data->n;
#line 574
  ptr += sizeof(data->n);
#line 577
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->n);
  }
#line 578
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
cmph_uint32 bmz_packed_size(cmph_t *mphf ) 
{ 
  bmz_data_t *data ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 587
  data = (bmz_data_t *)mphf->data;
#line 588
  tmp = hash_get_type(*(data->hashes + 0));
#line 588
  h1_type = tmp;
#line 589
  tmp___0 = hash_get_type(*(data->hashes + 1));
#line 589
  h2_type = tmp___0;
#line 591
  tmp___1 = hash_state_packed_size(h1_type);
#line 591
  tmp___2 = hash_state_packed_size(h2_type);
  }
#line 591
  return ((cmph_uint32 )((((sizeof(CMPH_ALGO ) + (unsigned long )tmp___1) + (unsigned long )tmp___2) + 3UL * sizeof(cmph_uint32 )) + sizeof(cmph_uint32 ) * (unsigned long )data->n));
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
cmph_uint32 bmz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint8 *h1_ptr ;
  register CMPH_HASH h1_type ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp ;
  register CMPH_HASH h2_type ;
  register cmph_uint32 *g_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;

  {
  {
#line 604
  h1_ptr = (cmph_uint8 *)packed_mphf;
#line 605
  h1_type = (CMPH_HASH )*((cmph_uint32 *)h1_ptr);
#line 606
  h1_ptr += 4;
#line 608
  tmp = hash_state_packed_size(h1_type);
#line 608
  h2_ptr = h1_ptr + tmp;
#line 609
  h2_type = (CMPH_HASH )*((cmph_uint32 *)h2_ptr);
#line 610
  h2_ptr += 4;
#line 612
  tmp___0 = hash_state_packed_size(h2_type);
#line 612
  g_ptr = (cmph_uint32 *)(h2_ptr + tmp___0);
#line 614
  tmp___1 = g_ptr;
#line 614
  g_ptr ++;
#line 614
  n = *tmp___1;
#line 616
  tmp___2 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 616
  h1 = tmp___2 % n;
#line 617
  tmp___3 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 617
  h2 = tmp___3 % n;
  }
#line 618
  if (h1 == h2) {
#line 618
    h2 ++;
#line 618
    if (h2 > n) {
#line 618
      h2 = (cmph_uint32 )0;
    }
  }
#line 619
  return (*(g_ptr + h1) + *(g_ptr + h2));
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.h"
cmph_io_adapter_t *cmph_io_nlfile_adapter(FILE *keys_fd ) ;
#line 29
void cmph_io_nlfile_adapter_destroy(cmph_io_adapter_t *key_source ) ;
#line 31
cmph_io_adapter_t *cmph_io_nlnkfile_adapter(FILE *keys_fd , cmph_uint32 nkeys ) ;
#line 32
void cmph_io_nlnkfile_adapter_destroy(cmph_io_adapter_t *key_source ) ;
#line 40
cmph_io_adapter_t *cmph_io_struct_vector_adapter(void *vector , cmph_uint32 struct_size ,
                                                 cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                 cmph_uint32 nkeys ) ;
#line 46
void cmph_io_struct_vector_adapter_destroy(cmph_io_adapter_t *key_source ) ;
#line 54
void cmph_config_set_tmp_dir(cmph_config_t *mph , cmph_uint8 *tmp_dir ) ;
#line 58
void cmph_config_set_memory_availability(cmph_config_t *mph , cmph_uint32 memory_availability ) ;
#line 73
cmph_uint32 cmph_size(cmph_t *mphf ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.h"
cmph_config_t *__config_new(cmph_io_adapter_t *key_source ) ;
#line 28
void __config_destroy(cmph_config_t *mph ) ;
#line 30
cmph_t *__cmph_load(FILE *f ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.h"
fch_config_data_t *fch_config_new(void) ;
#line 16
void fch_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 17
void fch_config_destroy(cmph_config_t *mph ) ;
#line 18
cmph_t *fch_new(cmph_config_t *mph , double c ) ;
#line 20
void fch_load(FILE *f , cmph_t *mphf ) ;
#line 21
int fch_dump(cmph_t *mphf , FILE *fd ) ;
#line 22
void fch_destroy(cmph_t *mphf ) ;
#line 23
cmph_uint32 fch_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 30
void fch_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 37
cmph_uint32 fch_packed_size(cmph_t *mphf ) ;
#line 46
cmph_uint32 fch_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.h"
bdz_config_data_t *bdz_config_new(void) ;
#line 10
void bdz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void bdz_config_destroy(cmph_config_t *mph ) ;
#line 12
void bdz_config_set_b(cmph_config_t *mph , cmph_uint32 b ) ;
#line 13
cmph_t *bdz_new(cmph_config_t *mph , double c ) ;
#line 15
void bdz_load(FILE *f , cmph_t *mphf ) ;
#line 16
int bdz_dump(cmph_t *mphf , FILE *fd ) ;
#line 17
void bdz_destroy(cmph_t *mphf ) ;
#line 18
cmph_uint32 bdz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 25
void bdz_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 32
cmph_uint32 bdz_packed_size(cmph_t *mphf ) ;
#line 41
cmph_uint32 bdz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.h"
bdz_ph_config_data_t *bdz_ph_config_new(void) ;
#line 10
void bdz_ph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 11
void bdz_ph_config_destroy(cmph_config_t *mph ) ;
#line 12
cmph_t *bdz_ph_new(cmph_config_t *mph , double c ) ;
#line 14
void bdz_ph_load(FILE *f , cmph_t *mphf ) ;
#line 15
int bdz_ph_dump(cmph_t *mphf , FILE *fd ) ;
#line 16
void bdz_ph_destroy(cmph_t *mphf ) ;
#line 17
cmph_uint32 bdz_ph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 24
void bdz_ph_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 31
cmph_uint32 bdz_ph_packed_size(cmph_t *mphf ) ;
#line 40
cmph_uint32 bdz_ph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.h"
chd_ph_config_data_t *chd_ph_config_new(void) ;
#line 11
void chd_ph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) ;
#line 18
void chd_ph_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) ;
#line 25
void chd_ph_config_set_b(cmph_config_t *mph , cmph_uint32 keys_per_bucket ) ;
#line 26
void chd_ph_config_destroy(cmph_config_t *mph ) ;
#line 30
cmph_t *chd_ph_new(cmph_config_t *mph , double c ) ;
#line 31
void chd_ph_load(FILE *fd , cmph_t *mphf ) ;
#line 32
int chd_ph_dump(cmph_t *mphf , FILE *fd ) ;
#line 33
void chd_ph_destroy(cmph_t *mphf ) ;
#line 34
cmph_uint32 chd_ph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) ;
#line 41
void chd_ph_pack(cmph_t *mphf , void *packed_mphf ) ;
#line 48
cmph_uint32 chd_ph_packed_size(cmph_t *mphf ) ;
#line 57
cmph_uint32 chd_ph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
char const   *cmph_names[10]  = 
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
  {      "bmz",      "bmz8",      "chm",      "brz", 
        "fch",      "bdz",      "bdz_ph",      "chd_ph", 
        "chd",      (char const   *)((void *)0)};
#line 50
static cmph_io_adapter_t *cmph_io_vector_new(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new(void *vector , cmph_uint32 struct_size ,
                                                    cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                    cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_io_adapter_t *cmph_io_nlfile_adapter(FILE *keys_fd ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;

  {
  {
#line 170
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 170
  key_source = (cmph_io_adapter_t *)tmp;
  }
#line 171
  if (! key_source) {
    {
#line 171
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  171U, "cmph_io_nlfile_adapter");
    }
  }
  {
#line 172
  key_source->data = (void *)keys_fd;
#line 173
  key_source->nkeys = count_nlfile_keys(keys_fd);
#line 174
  key_source->read = & key_nlfile_read;
#line 175
  key_source->dispose = & key_nlfile_dispose;
#line 176
  key_source->rewind = & key_nlfile_rewind;
  }
#line 177
  return (key_source);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_io_nlfile_adapter_destroy(cmph_io_adapter_t *key_source ) 
{ 


  {
  {
#line 182
  free((void *)key_source);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_io_adapter_t *cmph_io_nlnkfile_adapter(FILE *keys_fd , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;

  {
  {
#line 187
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 187
  key_source = (cmph_io_adapter_t *)tmp;
  }
#line 188
  if (! key_source) {
    {
#line 188
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  188U, "cmph_io_nlnkfile_adapter");
    }
  }
#line 189
  key_source->data = (void *)keys_fd;
#line 190
  key_source->nkeys = nkeys;
#line 191
  key_source->read = & key_nlfile_read;
#line 192
  key_source->dispose = & key_nlfile_dispose;
#line 193
  key_source->rewind = & key_nlfile_rewind;
#line 194
  return (key_source);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_io_nlnkfile_adapter_destroy(cmph_io_adapter_t *key_source ) 
{ 


  {
  {
#line 199
  free((void *)key_source);
  }
#line 200
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new(void *vector , cmph_uint32 struct_size ,
                                                    cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                    cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_io_adapter_t *cmph_io_byte_vector_adapter(cmph_uint8 **vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  cmph_io_adapter_t *tmp ;

  {
  {
#line 250
  tmp = cmph_io_vector_new((void *)vector, nkeys);
#line 250
  key_source = tmp;
#line 251
  key_source->read = & key_byte_vector_read;
#line 252
  key_source->dispose = & key_vector_dispose;
#line 253
  key_source->rewind = & key_vector_rewind;
  }
#line 254
  return (key_source);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_io_byte_vector_adapter_destroy(cmph_io_adapter_t *key_source ) 
{ 


  {
  {
#line 258
  cmph_io_vector_destroy(key_source);
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_io_adapter_t *cmph_io_struct_vector_adapter(void *vector , cmph_uint32 struct_size ,
                                                 cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                 cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  cmph_io_adapter_t *tmp ;

  {
  {
#line 263
  tmp = cmph_io_struct_vector_new(vector, struct_size, key_offset, key_len, nkeys);
#line 263
  key_source = tmp;
#line 264
  key_source->read = & key_struct_vector_read;
#line 265
  key_source->dispose = & key_vector_dispose;
#line 266
  key_source->rewind = & key_struct_vector_rewind;
  }
#line 267
  return (key_source);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_io_struct_vector_adapter_destroy(cmph_io_adapter_t *key_source ) 
{ 


  {
  {
#line 272
  cmph_io_struct_vector_destroy(key_source);
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_io_adapter_t *cmph_io_vector_adapter(char **vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  cmph_io_adapter_t *tmp ;

  {
  {
#line 277
  tmp = cmph_io_vector_new((void *)vector, nkeys);
#line 277
  key_source = tmp;
#line 278
  key_source->read = & key_vector_read;
#line 279
  key_source->dispose = & key_vector_dispose;
#line 280
  key_source->rewind = & key_vector_rewind;
  }
#line 281
  return (key_source);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_io_vector_adapter_destroy(cmph_io_adapter_t *key_source ) 
{ 


  {
  {
#line 286
  cmph_io_vector_destroy(key_source);
  }
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_config_t *cmph_config_new(cmph_io_adapter_t *key_source ) 
{ 
  cmph_config_t *mph ;
  chm_config_data_t *tmp ;

  {
  {
#line 291
  mph = (cmph_config_t *)((void *)0);
#line 292
  mph = __config_new(key_source);
  }
#line 293
  if (! mph) {
    {
#line 293
    __assert_fail("mph", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  293U, "cmph_config_new");
    }
  }
  {
#line 294
  mph->algo = (CMPH_ALGO )2;
#line 295
  tmp = chm_config_new();
#line 295
  mph->data = (void *)tmp;
  }
#line 296
  return (mph);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_algo(cmph_config_t *mph , CMPH_ALGO algo ) 
{ 
  chm_config_data_t *tmp ;
  bmz_config_data_t *tmp___0 ;
  bmz8_config_data_t *tmp___1 ;
  brz_config_data_t *tmp___2 ;
  fch_config_data_t *tmp___3 ;
  bdz_config_data_t *tmp___4 ;
  bdz_ph_config_data_t *tmp___5 ;
  chd_ph_config_data_t *tmp___6 ;
  chd_config_data_t *tmp___7 ;

  {
#line 301
  if ((unsigned int )algo != (unsigned int )mph->algo) {
    {
#line 305
    if ((unsigned int )mph->algo == 2U) {
#line 305
      goto case_2;
    }
#line 308
    if ((unsigned int )mph->algo == 0U) {
#line 308
      goto case_0;
    }
#line 311
    if ((unsigned int )mph->algo == 1U) {
#line 311
      goto case_1;
    }
#line 314
    if ((unsigned int )mph->algo == 3U) {
#line 314
      goto case_3;
    }
#line 317
    if ((unsigned int )mph->algo == 4U) {
#line 317
      goto case_4;
    }
#line 320
    if ((unsigned int )mph->algo == 5U) {
#line 320
      goto case_5;
    }
#line 323
    if ((unsigned int )mph->algo == 6U) {
#line 323
      goto case_6;
    }
#line 326
    if ((unsigned int )mph->algo == 7U) {
#line 326
      goto case_7;
    }
#line 329
    if ((unsigned int )mph->algo == 8U) {
#line 329
      goto case_8;
    }
#line 332
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 306
    chm_config_destroy(mph);
    }
#line 307
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 309
    bmz_config_destroy(mph);
    }
#line 310
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 312
    bmz8_config_destroy(mph);
    }
#line 313
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 315
    brz_config_destroy(mph);
    }
#line 316
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 318
    fch_config_destroy(mph);
    }
#line 319
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 321
    bdz_config_destroy(mph);
    }
#line 322
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 324
    bdz_ph_config_destroy(mph);
    }
#line 325
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 327
    chd_ph_config_destroy(mph);
    }
#line 328
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 330
    chd_config_destroy(mph);
    }
#line 331
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 333
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  333U, "cmph_config_set_algo");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 337
    if ((unsigned int )algo == 2U) {
#line 337
      goto case_2___0;
    }
#line 340
    if ((unsigned int )algo == 0U) {
#line 340
      goto case_0___0;
    }
#line 343
    if ((unsigned int )algo == 1U) {
#line 343
      goto case_1___0;
    }
#line 346
    if ((unsigned int )algo == 3U) {
#line 346
      goto case_3___0;
    }
#line 349
    if ((unsigned int )algo == 4U) {
#line 349
      goto case_4___0;
    }
#line 352
    if ((unsigned int )algo == 5U) {
#line 352
      goto case_5___0;
    }
#line 355
    if ((unsigned int )algo == 6U) {
#line 355
      goto case_6___0;
    }
#line 358
    if ((unsigned int )algo == 7U) {
#line 358
      goto case_7___0;
    }
#line 361
    if ((unsigned int )algo == 8U) {
#line 361
      goto case_8___0;
    }
#line 364
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    {
#line 338
    tmp = chm_config_new();
#line 338
    mph->data = (void *)tmp;
    }
#line 339
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 341
    tmp___0 = bmz_config_new();
#line 341
    mph->data = (void *)tmp___0;
    }
#line 342
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 344
    tmp___1 = bmz8_config_new();
#line 344
    mph->data = (void *)tmp___1;
    }
#line 345
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 347
    tmp___2 = brz_config_new();
#line 347
    mph->data = (void *)tmp___2;
    }
#line 348
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 350
    tmp___3 = fch_config_new();
#line 350
    mph->data = (void *)tmp___3;
    }
#line 351
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 353
    tmp___4 = bdz_config_new();
#line 353
    mph->data = (void *)tmp___4;
    }
#line 354
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 356
    tmp___5 = bdz_ph_config_new();
#line 356
    mph->data = (void *)tmp___5;
    }
#line 357
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
    {
#line 359
    tmp___6 = chd_ph_config_new();
#line 359
    mph->data = (void *)tmp___6;
    }
#line 360
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
    {
#line 362
    tmp___7 = chd_config_new(mph);
#line 362
    mph->data = (void *)tmp___7;
    }
#line 363
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 365
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  365U, "cmph_config_set_algo");
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 368
  mph->algo = algo;
#line 369
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_tmp_dir(cmph_config_t *mph , cmph_uint8 *tmp_dir ) 
{ 


  {
#line 373
  if ((unsigned int )mph->algo == 3U) {
    {
#line 375
    brz_config_set_tmp_dir(mph, tmp_dir);
    }
  }
#line 377
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_mphf_fd(cmph_config_t *mph , FILE *mphf_fd ) 
{ 


  {
#line 382
  if ((unsigned int )mph->algo == 3U) {
    {
#line 384
    brz_config_set_mphf_fd(mph, mphf_fd);
    }
  }
#line 386
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_b(cmph_config_t *mph , cmph_uint32 b ) 
{ 


  {
#line 390
  if ((unsigned int )mph->algo == 3U) {
    {
#line 392
    brz_config_set_b(mph, b);
    }
  } else
#line 394
  if ((unsigned int )mph->algo == 5U) {
    {
#line 396
    bdz_config_set_b(mph, b);
    }
  } else
#line 398
  if ((unsigned int )mph->algo == 7U) {
    {
#line 400
    chd_ph_config_set_b(mph, b);
    }
  } else
#line 402
  if ((unsigned int )mph->algo == 8U) {
    {
#line 404
    chd_config_set_b(mph, b);
    }
  }
#line 406
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) 
{ 


  {
#line 410
  if ((unsigned int )mph->algo == 7U) {
    {
#line 412
    chd_ph_config_set_keys_per_bin(mph, keys_per_bin);
    }
  } else
#line 414
  if ((unsigned int )mph->algo == 8U) {
    {
#line 416
    chd_config_set_keys_per_bin(mph, keys_per_bin);
    }
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_memory_availability(cmph_config_t *mph , cmph_uint32 memory_availability ) 
{ 


  {
#line 422
  if ((unsigned int )mph->algo == 3U) {
    {
#line 424
    brz_config_set_memory_availability(mph, memory_availability);
    }
  }
#line 426
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_destroy(cmph_config_t *mph ) 
{ 


  {
#line 430
  if (mph) {
    {
#line 435
    if ((unsigned int )mph->algo == 2U) {
#line 435
      goto case_2;
    }
#line 438
    if ((unsigned int )mph->algo == 0U) {
#line 438
      goto case_0;
    }
#line 441
    if ((unsigned int )mph->algo == 1U) {
#line 441
      goto case_1;
    }
#line 444
    if ((unsigned int )mph->algo == 3U) {
#line 444
      goto case_3;
    }
#line 447
    if ((unsigned int )mph->algo == 4U) {
#line 447
      goto case_4;
    }
#line 450
    if ((unsigned int )mph->algo == 5U) {
#line 450
      goto case_5;
    }
#line 453
    if ((unsigned int )mph->algo == 6U) {
#line 453
      goto case_6;
    }
#line 456
    if ((unsigned int )mph->algo == 7U) {
#line 456
      goto case_7;
    }
#line 459
    if ((unsigned int )mph->algo == 8U) {
#line 459
      goto case_8;
    }
#line 462
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 436
    chm_config_destroy(mph);
    }
#line 437
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 439
    bmz_config_destroy(mph);
    }
#line 440
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 442
    bmz8_config_destroy(mph);
    }
#line 443
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 445
    brz_config_destroy(mph);
    }
#line 446
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 448
    fch_config_destroy(mph);
    }
#line 449
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 451
    bdz_config_destroy(mph);
    }
#line 452
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 454
    bdz_ph_config_destroy(mph);
    }
#line 455
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 457
    chd_ph_config_destroy(mph);
    }
#line 458
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 460
    chd_config_destroy(mph);
    }
#line 461
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 463
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  463U, "cmph_config_destroy");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 465
    __config_destroy(mph);
    }
  }
#line 467
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_verbosity(cmph_config_t *mph , cmph_uint32 verbosity ) 
{ 


  {
#line 471
  mph->verbosity = verbosity;
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 


  {
  {
#line 478
  if ((unsigned int )mph->algo == 2U) {
#line 478
    goto case_2;
  }
#line 481
  if ((unsigned int )mph->algo == 0U) {
#line 481
    goto case_0;
  }
#line 484
  if ((unsigned int )mph->algo == 1U) {
#line 484
    goto case_1;
  }
#line 487
  if ((unsigned int )mph->algo == 3U) {
#line 487
    goto case_3;
  }
#line 490
  if ((unsigned int )mph->algo == 4U) {
#line 490
    goto case_4;
  }
#line 493
  if ((unsigned int )mph->algo == 5U) {
#line 493
    goto case_5;
  }
#line 496
  if ((unsigned int )mph->algo == 6U) {
#line 496
    goto case_6;
  }
#line 499
  if ((unsigned int )mph->algo == 7U) {
#line 499
    goto case_7;
  }
#line 502
  if ((unsigned int )mph->algo == 8U) {
#line 502
    goto case_8;
  }
#line 505
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 479
  chm_config_set_hashfuncs(mph, hashfuncs);
  }
#line 480
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 482
  bmz_config_set_hashfuncs(mph, hashfuncs);
  }
#line 483
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 485
  bmz8_config_set_hashfuncs(mph, hashfuncs);
  }
#line 486
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 488
  brz_config_set_hashfuncs(mph, hashfuncs);
  }
#line 489
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 491
  fch_config_set_hashfuncs(mph, hashfuncs);
  }
#line 492
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 494
  bdz_config_set_hashfuncs(mph, hashfuncs);
  }
#line 495
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 497
  bdz_ph_config_set_hashfuncs(mph, hashfuncs);
  }
#line 498
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 500
  chd_ph_config_set_hashfuncs(mph, hashfuncs);
  }
#line 501
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 503
  chd_config_set_hashfuncs(mph, hashfuncs);
  }
#line 504
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 506
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_config_set_graphsize(cmph_config_t *mph , double c ) 
{ 


  {
#line 512
  mph->c = c;
#line 513
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_t *cmph_new(cmph_config_t *mph ) 
{ 
  cmph_t *mphf ;
  double c ;

  {
#line 518
  mphf = (cmph_t *)((void *)0);
#line 519
  c = mph->c;
  {
#line 524
  if ((unsigned int )mph->algo == 2U) {
#line 524
    goto case_2;
  }
#line 528
  if ((unsigned int )mph->algo == 0U) {
#line 528
    goto case_0;
  }
#line 532
  if ((unsigned int )mph->algo == 1U) {
#line 532
    goto case_1;
  }
#line 536
  if ((unsigned int )mph->algo == 3U) {
#line 536
    goto case_3;
  }
#line 542
  if ((unsigned int )mph->algo == 4U) {
#line 542
    goto case_4;
  }
#line 546
  if ((unsigned int )mph->algo == 5U) {
#line 546
    goto case_5;
  }
#line 550
  if ((unsigned int )mph->algo == 6U) {
#line 550
    goto case_6;
  }
#line 554
  if ((unsigned int )mph->algo == 7U) {
#line 554
    goto case_7;
  }
#line 558
  if ((unsigned int )mph->algo == 8U) {
#line 558
    goto case_8;
  }
#line 562
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 526
  mphf = chm_new(mph, c);
  }
#line 527
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 530
  mphf = bmz_new(mph, c);
  }
#line 531
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 534
  mphf = bmz8_new(mph, c);
  }
#line 535
  goto switch_break;
  case_3: /* CIL Label */ ;
#line 538
  if (c >= 2.0) {
    {
#line 538
    brz_config_set_algo(mph, (CMPH_ALGO )4);
    }
  } else {
    {
#line 539
    brz_config_set_algo(mph, (CMPH_ALGO )1);
    }
  }
  {
#line 540
  mphf = brz_new(mph, c);
  }
#line 541
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 544
  mphf = fch_new(mph, c);
  }
#line 545
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 548
  mphf = bdz_new(mph, c);
  }
#line 549
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 552
  mphf = bdz_ph_new(mph, c);
  }
#line 553
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 556
  mphf = chd_ph_new(mph, c);
  }
#line 557
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 560
  mphf = chd_new(mph, c);
  }
#line 561
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 563
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                563U, "cmph_new");
  }
  switch_break: /* CIL Label */ ;
  }
#line 565
  return (mphf);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
int cmph_dump(cmph_t *mphf , FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 572
  if ((unsigned int )mphf->algo == 2U) {
#line 572
    goto case_2;
  }
#line 574
  if ((unsigned int )mphf->algo == 0U) {
#line 574
    goto case_0;
  }
#line 576
  if ((unsigned int )mphf->algo == 1U) {
#line 576
    goto case_1;
  }
#line 578
  if ((unsigned int )mphf->algo == 3U) {
#line 578
    goto case_3;
  }
#line 580
  if ((unsigned int )mphf->algo == 4U) {
#line 580
    goto case_4;
  }
#line 582
  if ((unsigned int )mphf->algo == 5U) {
#line 582
    goto case_5;
  }
#line 584
  if ((unsigned int )mphf->algo == 6U) {
#line 584
    goto case_6;
  }
#line 586
  if ((unsigned int )mphf->algo == 7U) {
#line 586
    goto case_7;
  }
#line 588
  if ((unsigned int )mphf->algo == 8U) {
#line 588
    goto case_8;
  }
#line 590
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 573
  tmp = chm_dump(mphf, f);
  }
#line 573
  return (tmp);
  case_0: /* CIL Label */ 
  {
#line 575
  tmp___0 = bmz_dump(mphf, f);
  }
#line 575
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 577
  tmp___1 = bmz8_dump(mphf, f);
  }
#line 577
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 579
  tmp___2 = brz_dump(mphf, f);
  }
#line 579
  return (tmp___2);
  case_4: /* CIL Label */ 
  {
#line 581
  tmp___3 = fch_dump(mphf, f);
  }
#line 581
  return (tmp___3);
  case_5: /* CIL Label */ 
  {
#line 583
  tmp___4 = bdz_dump(mphf, f);
  }
#line 583
  return (tmp___4);
  case_6: /* CIL Label */ 
  {
#line 585
  tmp___5 = bdz_ph_dump(mphf, f);
  }
#line 585
  return (tmp___5);
  case_7: /* CIL Label */ 
  {
#line 587
  tmp___6 = chd_ph_dump(mphf, f);
  }
#line 587
  return (tmp___6);
  case_8: /* CIL Label */ 
  {
#line 589
  tmp___7 = chd_dump(mphf, f);
  }
#line 589
  return (tmp___7);
  switch_default: /* CIL Label */ 
  {
#line 591
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                591U, "cmph_dump");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 593
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                593U, "cmph_dump");
  }
#line 594
  return (0);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_t *cmph_load(FILE *f ) 
{ 
  cmph_t *mphf ;

  {
  {
#line 598
  mphf = (cmph_t *)((void *)0);
#line 600
  mphf = __cmph_load(f);
  }
#line 601
  if ((unsigned long )mphf == (unsigned long )((void *)0)) {
#line 601
    return ((cmph_t *)((void *)0));
  }
  {
#line 606
  if ((unsigned int )mphf->algo == 2U) {
#line 606
    goto case_2;
  }
#line 609
  if ((unsigned int )mphf->algo == 0U) {
#line 609
    goto case_0;
  }
#line 613
  if ((unsigned int )mphf->algo == 1U) {
#line 613
    goto case_1;
  }
#line 617
  if ((unsigned int )mphf->algo == 3U) {
#line 617
    goto case_3;
  }
#line 621
  if ((unsigned int )mphf->algo == 4U) {
#line 621
    goto case_4;
  }
#line 625
  if ((unsigned int )mphf->algo == 5U) {
#line 625
    goto case_5;
  }
#line 629
  if ((unsigned int )mphf->algo == 6U) {
#line 629
    goto case_6;
  }
#line 633
  if ((unsigned int )mphf->algo == 7U) {
#line 633
    goto case_7;
  }
#line 637
  if ((unsigned int )mphf->algo == 8U) {
#line 637
    goto case_8;
  }
#line 641
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 607
  chm_load(f, mphf);
  }
#line 608
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 611
  bmz_load(f, mphf);
  }
#line 612
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 615
  bmz8_load(f, mphf);
  }
#line 616
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 619
  brz_load(f, mphf);
  }
#line 620
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 623
  fch_load(f, mphf);
  }
#line 624
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 627
  bdz_load(f, mphf);
  }
#line 628
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 631
  bdz_ph_load(f, mphf);
  }
#line 632
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 635
  chd_ph_load(f, mphf);
  }
#line 636
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 639
  chd_load(f, mphf);
  }
#line 640
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 642
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                642U, "cmph_load");
  }
  switch_break: /* CIL Label */ ;
  }
#line 645
  return (mphf);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_uint32 cmph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint8 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 tmp___7 ;

  {
  {
#line 654
  if ((unsigned int )mphf->algo == 2U) {
#line 654
    goto case_2;
  }
#line 656
  if ((unsigned int )mphf->algo == 0U) {
#line 656
    goto case_0;
  }
#line 659
  if ((unsigned int )mphf->algo == 1U) {
#line 659
    goto case_1;
  }
#line 662
  if ((unsigned int )mphf->algo == 3U) {
#line 662
    goto case_3;
  }
#line 665
  if ((unsigned int )mphf->algo == 4U) {
#line 665
    goto case_4;
  }
#line 668
  if ((unsigned int )mphf->algo == 5U) {
#line 668
    goto case_5;
  }
#line 671
  if ((unsigned int )mphf->algo == 6U) {
#line 671
    goto case_6;
  }
#line 674
  if ((unsigned int )mphf->algo == 7U) {
#line 674
    goto case_7;
  }
#line 677
  if ((unsigned int )mphf->algo == 8U) {
#line 677
    goto case_8;
  }
#line 680
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 655
  tmp = chm_search(mphf, key, keylen);
  }
#line 655
  return (tmp);
  case_0: /* CIL Label */ 
  {
#line 658
  tmp___0 = bmz_search(mphf, key, keylen);
  }
#line 658
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 661
  tmp___1 = bmz8_search(mphf, key, keylen);
  }
#line 661
  return ((cmph_uint32 )tmp___1);
  case_3: /* CIL Label */ 
  {
#line 664
  tmp___2 = brz_search(mphf, key, keylen);
  }
#line 664
  return (tmp___2);
  case_4: /* CIL Label */ 
  {
#line 667
  tmp___3 = fch_search(mphf, key, keylen);
  }
#line 667
  return (tmp___3);
  case_5: /* CIL Label */ 
  {
#line 670
  tmp___4 = bdz_search(mphf, key, keylen);
  }
#line 670
  return (tmp___4);
  case_6: /* CIL Label */ 
  {
#line 673
  tmp___5 = bdz_ph_search(mphf, key, keylen);
  }
#line 673
  return (tmp___5);
  case_7: /* CIL Label */ 
  {
#line 676
  tmp___6 = chd_ph_search(mphf, key, keylen);
  }
#line 676
  return (tmp___6);
  case_8: /* CIL Label */ 
  {
#line 679
  tmp___7 = chd_search(mphf, key, keylen);
  }
#line 679
  return (tmp___7);
  switch_default: /* CIL Label */ 
  {
#line 681
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                681U, "cmph_search");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 683
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                683U, "cmph_search");
  }
#line 684
  return ((cmph_uint32 )0);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_uint32 cmph_size(cmph_t *mphf ) 
{ 


  {
#line 689
  return (mphf->size);
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_destroy(cmph_t *mphf ) 
{ 


  {
  {
#line 696
  if ((unsigned int )mphf->algo == 2U) {
#line 696
    goto case_2;
  }
#line 699
  if ((unsigned int )mphf->algo == 0U) {
#line 699
    goto case_0;
  }
#line 702
  if ((unsigned int )mphf->algo == 1U) {
#line 702
    goto case_1;
  }
#line 705
  if ((unsigned int )mphf->algo == 3U) {
#line 705
    goto case_3;
  }
#line 708
  if ((unsigned int )mphf->algo == 4U) {
#line 708
    goto case_4;
  }
#line 711
  if ((unsigned int )mphf->algo == 5U) {
#line 711
    goto case_5;
  }
#line 714
  if ((unsigned int )mphf->algo == 6U) {
#line 714
    goto case_6;
  }
#line 717
  if ((unsigned int )mphf->algo == 7U) {
#line 717
    goto case_7;
  }
#line 720
  if ((unsigned int )mphf->algo == 8U) {
#line 720
    goto case_8;
  }
#line 723
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 697
  chm_destroy(mphf);
  }
#line 698
  return;
  case_0: /* CIL Label */ 
  {
#line 700
  bmz_destroy(mphf);
  }
#line 701
  return;
  case_1: /* CIL Label */ 
  {
#line 703
  bmz8_destroy(mphf);
  }
#line 704
  return;
  case_3: /* CIL Label */ 
  {
#line 706
  brz_destroy(mphf);
  }
#line 707
  return;
  case_4: /* CIL Label */ 
  {
#line 709
  fch_destroy(mphf);
  }
#line 710
  return;
  case_5: /* CIL Label */ 
  {
#line 712
  bdz_destroy(mphf);
  }
#line 713
  return;
  case_6: /* CIL Label */ 
  {
#line 715
  bdz_ph_destroy(mphf);
  }
#line 716
  return;
  case_7: /* CIL Label */ 
  {
#line 718
  chd_ph_destroy(mphf);
  }
#line 719
  return;
  case_8: /* CIL Label */ 
  {
#line 721
  chd_destroy(mphf);
  }
#line 722
  return;
  switch_default: /* CIL Label */ 
  {
#line 724
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                724U, "cmph_destroy");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 726
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                726U, "cmph_destroy");
  }
#line 727
  return;
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
void cmph_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  cmph_uint32 *ptr ;
  cmph_uint32 *tmp ;

  {
#line 739
  ptr = (cmph_uint32 *)packed_mphf;
#line 740
  tmp = ptr;
#line 740
  ptr ++;
#line 740
  *tmp = (cmph_uint32 )mphf->algo;
  {
#line 744
  if ((unsigned int )mphf->algo == 2U) {
#line 744
    goto case_2;
  }
#line 747
  if ((unsigned int )mphf->algo == 0U) {
#line 747
    goto case_0;
  }
#line 750
  if ((unsigned int )mphf->algo == 1U) {
#line 750
    goto case_1;
  }
#line 753
  if ((unsigned int )mphf->algo == 3U) {
#line 753
    goto case_3;
  }
#line 756
  if ((unsigned int )mphf->algo == 4U) {
#line 756
    goto case_4;
  }
#line 759
  if ((unsigned int )mphf->algo == 5U) {
#line 759
    goto case_5;
  }
#line 762
  if ((unsigned int )mphf->algo == 6U) {
#line 762
    goto case_6;
  }
#line 765
  if ((unsigned int )mphf->algo == 7U) {
#line 765
    goto case_7;
  }
#line 768
  if ((unsigned int )mphf->algo == 8U) {
#line 768
    goto case_8;
  }
#line 771
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 745
  chm_pack(mphf, (void *)ptr);
  }
#line 746
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 748
  bmz_pack(mphf, (void *)ptr);
  }
#line 749
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 751
  bmz8_pack(mphf, (void *)ptr);
  }
#line 752
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 754
  brz_pack(mphf, (void *)ptr);
  }
#line 755
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 757
  fch_pack(mphf, (void *)ptr);
  }
#line 758
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 760
  bdz_pack(mphf, (void *)ptr);
  }
#line 761
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 763
  bdz_ph_pack(mphf, (void *)ptr);
  }
#line 764
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 766
  chd_ph_pack(mphf, (void *)ptr);
  }
#line 767
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 769
  chd_pack(mphf, (void *)ptr);
  }
#line 770
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 772
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                772U, "cmph_pack");
  }
  switch_break: /* CIL Label */ ;
  }
#line 774
  return;
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_uint32 cmph_packed_size(cmph_t *mphf ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 tmp___7 ;

  {
  {
#line 786
  if ((unsigned int )mphf->algo == 2U) {
#line 786
    goto case_2;
  }
#line 788
  if ((unsigned int )mphf->algo == 0U) {
#line 788
    goto case_0;
  }
#line 790
  if ((unsigned int )mphf->algo == 1U) {
#line 790
    goto case_1;
  }
#line 792
  if ((unsigned int )mphf->algo == 3U) {
#line 792
    goto case_3;
  }
#line 794
  if ((unsigned int )mphf->algo == 4U) {
#line 794
    goto case_4;
  }
#line 796
  if ((unsigned int )mphf->algo == 5U) {
#line 796
    goto case_5;
  }
#line 798
  if ((unsigned int )mphf->algo == 6U) {
#line 798
    goto case_6;
  }
#line 800
  if ((unsigned int )mphf->algo == 7U) {
#line 800
    goto case_7;
  }
#line 802
  if ((unsigned int )mphf->algo == 8U) {
#line 802
    goto case_8;
  }
#line 804
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 787
  tmp = chm_packed_size(mphf);
  }
#line 787
  return (tmp);
  case_0: /* CIL Label */ 
  {
#line 789
  tmp___0 = bmz_packed_size(mphf);
  }
#line 789
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 791
  tmp___1 = bmz8_packed_size(mphf);
  }
#line 791
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 793
  tmp___2 = brz_packed_size(mphf);
  }
#line 793
  return (tmp___2);
  case_4: /* CIL Label */ 
  {
#line 795
  tmp___3 = fch_packed_size(mphf);
  }
#line 795
  return (tmp___3);
  case_5: /* CIL Label */ 
  {
#line 797
  tmp___4 = bdz_packed_size(mphf);
  }
#line 797
  return (tmp___4);
  case_6: /* CIL Label */ 
  {
#line 799
  tmp___5 = bdz_ph_packed_size(mphf);
  }
#line 799
  return (tmp___5);
  case_7: /* CIL Label */ 
  {
#line 801
  tmp___6 = chd_ph_packed_size(mphf);
  }
#line 801
  return (tmp___6);
  case_8: /* CIL Label */ 
  {
#line 803
  tmp___7 = chd_packed_size(mphf);
  }
#line 803
  return (tmp___7);
  switch_default: /* CIL Label */ 
  {
#line 805
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                805U, "cmph_packed_size");
  }
  switch_break: /* CIL Label */ ;
  }
#line 807
  return ((cmph_uint32 )0);
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
cmph_uint32 cmph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  cmph_uint32 *ptr ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint8 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 tmp___7 ;

  {
#line 819
  ptr = (cmph_uint32 *)packed_mphf;
  {
#line 823
  if (*ptr == 2U) {
#line 823
    goto case_2;
  }
#line 825
  if (*ptr == 0U) {
#line 825
    goto case_0;
  }
#line 827
  if (*ptr == 1U) {
#line 827
    goto case_1;
  }
#line 829
  if (*ptr == 3U) {
#line 829
    goto case_3;
  }
#line 831
  if (*ptr == 4U) {
#line 831
    goto case_4;
  }
#line 833
  if (*ptr == 5U) {
#line 833
    goto case_5;
  }
#line 835
  if (*ptr == 6U) {
#line 835
    goto case_6;
  }
#line 837
  if (*ptr == 7U) {
#line 837
    goto case_7;
  }
#line 839
  if (*ptr == 8U) {
#line 839
    goto case_8;
  }
#line 841
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 824
  ptr ++;
#line 824
  tmp = chm_search_packed((void *)ptr, key, keylen);
  }
#line 824
  return (tmp);
  case_0: /* CIL Label */ 
  {
#line 826
  ptr ++;
#line 826
  tmp___0 = bmz_search_packed((void *)ptr, key, keylen);
  }
#line 826
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 828
  ptr ++;
#line 828
  tmp___1 = bmz8_search_packed((void *)ptr, key, keylen);
  }
#line 828
  return ((cmph_uint32 )tmp___1);
  case_3: /* CIL Label */ 
  {
#line 830
  ptr ++;
#line 830
  tmp___2 = brz_search_packed((void *)ptr, key, keylen);
  }
#line 830
  return (tmp___2);
  case_4: /* CIL Label */ 
  {
#line 832
  ptr ++;
#line 832
  tmp___3 = fch_search_packed((void *)ptr, key, keylen);
  }
#line 832
  return (tmp___3);
  case_5: /* CIL Label */ 
  {
#line 834
  ptr ++;
#line 834
  tmp___4 = bdz_search_packed((void *)ptr, key, keylen);
  }
#line 834
  return (tmp___4);
  case_6: /* CIL Label */ 
  {
#line 836
  ptr ++;
#line 836
  tmp___5 = bdz_ph_search_packed((void *)ptr, key, keylen);
  }
#line 836
  return (tmp___5);
  case_7: /* CIL Label */ 
  {
#line 838
  ptr ++;
#line 838
  tmp___6 = chd_ph_search_packed((void *)ptr, key, keylen);
  }
#line 838
  return (tmp___6);
  case_8: /* CIL Label */ 
  {
#line 840
  ptr ++;
#line 840
  tmp___7 = chd_search_packed((void *)ptr, key, keylen);
  }
#line 840
  return (tmp___7);
  switch_default: /* CIL Label */ 
  {
#line 842
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                842U, "cmph_search_packed");
  }
  switch_break: /* CIL Label */ ;
  }
#line 844
  return ((cmph_uint32 )0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.h"
cmph_uint32 compressed_rank_query(compressed_rank_t *cr , cmph_uint32 idx ) ;
#line 27
cmph_uint32 compressed_rank_get_space_usage(compressed_rank_t *cr ) ;
#line 29
void compressed_rank_dump(compressed_rank_t *cr , char **buf , cmph_uint32 *buflen ) ;
#line 31
void compressed_rank_load(compressed_rank_t *cr , char const   *buf , cmph_uint32 buflen ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___0[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 21 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_init(compressed_rank_t *cr ) 
{ 


  {
  {
#line 23
  cr->max_val = (cmph_uint32 )0;
#line 24
  cr->n = (cmph_uint32 )0;
#line 25
  cr->rem_r = (cmph_uint32 )0;
#line 26
  select_init(& cr->sel);
#line 27
  cr->vals_rems = (cmph_uint32 *)0;
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_destroy(compressed_rank_t *cr ) 
{ 


  {
  {
#line 32
  free((void *)cr->vals_rems);
#line 33
  cr->vals_rems = (cmph_uint32 *)0;
#line 34
  select_destroy(& cr->sel);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_generate(compressed_rank_t *cr , cmph_uint32 *vals_table , cmph_uint32 n ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 rems_mask ;
  register cmph_uint32 *select_vec ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 41
  select_vec = (cmph_uint32 *)0;
#line 42
  cr->n = n;
#line 43
  cr->max_val = *(vals_table + (cr->n - 1U));
#line 44
  cr->rem_r = compressed_seq_i_log2(cr->max_val / cr->n);
  }
#line 45
  if (cr->rem_r == 0U) {
#line 47
    cr->rem_r = (cmph_uint32 )1;
  }
  {
#line 49
  tmp = calloc((size_t )(cr->max_val >> cr->rem_r), sizeof(cmph_uint32 ));
#line 49
  select_vec = (cmph_uint32 *)tmp;
#line 50
  tmp___0 = calloc((size_t )((cr->n * cr->rem_r + 31U) >> 5), sizeof(cmph_uint32 ));
#line 50
  cr->vals_rems = (cmph_uint32 *)tmp___0;
#line 51
  rems_mask = (1U << cr->rem_r) - 1U;
#line 53
  i = (cmph_uint32 )0;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < cr->n)) {
#line 53
      goto while_break;
    }
    {
#line 55
    set_bits_value(cr->vals_rems, i, *(vals_table + i) & rems_mask, cr->rem_r, rems_mask);
#line 53
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  i = (cmph_uint32 )1;
#line 58
  j = (cmph_uint32 )0;
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! (i <= cr->max_val >> cr->rem_r)) {
#line 58
      goto while_break___0;
    }
    {
#line 60
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 60
      if (! (i > *(vals_table + j) >> cr->rem_r)) {
#line 60
        goto while_break___1;
      }
#line 62
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 64
    *(select_vec + (i - 1U)) = j;
#line 58
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 70
  select_generate(& cr->sel, select_vec, cr->max_val >> cr->rem_r, cr->n);
#line 72
  free((void *)select_vec);
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
cmph_uint32 compressed_rank_query(compressed_rank_t *cr , cmph_uint32 idx ) 
{ 
  register cmph_uint32 rems_mask ;
  register cmph_uint32 val_quot ;
  register cmph_uint32 val_rem ;
  register cmph_uint32 sel_res ;
  register cmph_uint32 rank___0 ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 81
  if (idx > cr->max_val) {
#line 83
    return (cr->n);
  }
#line 86
  val_quot = idx >> cr->rem_r;
#line 87
  rems_mask = (1U << cr->rem_r) - 1U;
#line 88
  val_rem = idx & rems_mask;
#line 89
  if (val_quot == 0U) {
#line 91
    sel_res = (cmph_uint32 )0;
#line 91
    rank___0 = sel_res;
  } else {
    {
#line 95
    tmp = select_query(& cr->sel, val_quot - 1U);
#line 95
    sel_res = tmp + 1U;
#line 96
    rank___0 = sel_res - val_quot;
    }
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (*(cr->sel.bits_vec + (sel_res >> 5)) & (unsigned int )bitmask32___0[sel_res & 31U]) {
#line 103
      goto while_break;
    }
    {
#line 105
    tmp___0 = get_bits_value(cr->vals_rems, rank___0, cr->rem_r, rems_mask);
    }
#line 105
    if (tmp___0 >= val_rem) {
#line 107
      goto while_break;
    }
#line 109
    sel_res ++;
#line 110
    rank___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (rank___0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
cmph_uint32 compressed_rank_get_space_usage(compressed_rank_t *cr ) 
{ 
  register cmph_uint32 space_usage ;
  cmph_uint32 tmp ;

  {
  {
#line 118
  tmp = select_get_space_usage(& cr->sel);
#line 118
  space_usage = tmp;
#line 119
  space_usage += (((cr->n * cr->rem_r + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
#line 120
  space_usage += (3U * (cmph_uint32 )sizeof(cmph_uint32 )) * 8U;
  }
#line 121
  return (space_usage);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_dump(compressed_rank_t *cr , char **buf , cmph_uint32 *buflen ) 
{ 
  register cmph_uint32 sel_size ;
  cmph_uint32 tmp ;
  register cmph_uint32 vals_rems_size ;
  register cmph_uint32 pos ;
  char *buf_sel ;
  cmph_uint32 buflen_sel ;
  void *tmp___0 ;

  {
  {
#line 126
  tmp = select_packed_size(& cr->sel);
#line 126
  sel_size = tmp;
#line 127
  vals_rems_size = ((cr->n * cr->rem_r + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
#line 128
  pos = (cmph_uint32 )0;
#line 129
  buf_sel = (char *)0;
#line 130
  buflen_sel = (cmph_uint32 )0;
#line 132
  *buflen = (4U * (cmph_uint32 )sizeof(cmph_uint32 ) + sel_size) + vals_rems_size;
#line 137
  tmp___0 = calloc((size_t )*buflen, sizeof(char ));
#line 137
  *buf = (char *)tmp___0;
  }
#line 139
  if (! *buf) {
#line 141
    *buflen = 4294967295U;
#line 142
    return;
  }
  {
#line 146
  memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)(& cr->max_val),
         sizeof(cmph_uint32 ));
#line 147
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 150
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& cr->n),
         sizeof(cmph_uint32 ));
#line 151
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 154
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& cr->rem_r),
         sizeof(cmph_uint32 ));
#line 155
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 159
  select_dump(& cr->sel, & buf_sel, & buflen_sel);
#line 160
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)(& buflen_sel),
         sizeof(cmph_uint32 ));
#line 161
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 164
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)buf_sel,
         (size_t )buflen_sel);
#line 173
  pos += buflen_sel;
#line 175
  free((void *)buf_sel);
#line 178
  memcpy((void */* __restrict  */)(*buf + pos), (void const   */* __restrict  */)cr->vals_rems,
         (size_t )vals_rems_size);
#line 185
  pos += vals_rems_size;
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_load(compressed_rank_t *cr , char const   *buf , cmph_uint32 buflen ) 
{ 
  register cmph_uint32 pos ;
  cmph_uint32 buflen_sel ;
  register cmph_uint32 vals_rems_size ;
  void *tmp ;

  {
  {
#line 192
  pos = (cmph_uint32 )0;
#line 193
  buflen_sel = (cmph_uint32 )0;
#line 194
  vals_rems_size = (cmph_uint32 )0;
#line 197
  memcpy((void */* __restrict  */)(& cr->max_val), (void const   */* __restrict  */)buf,
         sizeof(cmph_uint32 ));
#line 198
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 201
  memcpy((void */* __restrict  */)(& cr->n), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 202
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 205
  memcpy((void */* __restrict  */)(& cr->rem_r), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 206
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 210
  memcpy((void */* __restrict  */)(& buflen_sel), (void const   */* __restrict  */)(buf + pos),
         sizeof(cmph_uint32 ));
#line 211
  pos += (cmph_uint32 )sizeof(cmph_uint32 );
#line 214
  select_load(& cr->sel, buf + pos, buflen_sel);
#line 222
  pos += buflen_sel;
  }
#line 225
  if (cr->vals_rems) {
    {
#line 227
    free((void *)cr->vals_rems);
    }
  }
  {
#line 229
  vals_rems_size = (cr->n * cr->rem_r + 31U) >> 5;
#line 230
  tmp = calloc((size_t )vals_rems_size, sizeof(cmph_uint32 ));
#line 230
  cr->vals_rems = (cmph_uint32 *)tmp;
#line 231
  vals_rems_size *= 4U;
#line 232
  memcpy((void */* __restrict  */)cr->vals_rems, (void const   */* __restrict  */)(buf + pos),
         (size_t )vals_rems_size);
#line 240
  pos += vals_rems_size;
  }
#line 243
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
void compressed_rank_pack(compressed_rank_t *cr , void *cr_packed ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;

  {
#line 249
  if (cr) {
#line 249
    if (cr_packed) {
      {
#line 251
      buf = (char *)((void *)0);
#line 252
      buflen = (cmph_uint32 )0;
#line 253
      compressed_rank_dump(cr, & buf, & buflen);
#line 254
      memcpy((void */* __restrict  */)cr_packed, (void const   */* __restrict  */)buf,
             (size_t )buflen);
#line 255
      free((void *)buf);
      }
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
cmph_uint32 compressed_rank_packed_size(compressed_rank_t *cr ) 
{ 
  register cmph_uint32 sel_size ;
  cmph_uint32 tmp ;
  register cmph_uint32 vals_rems_size ;

  {
  {
#line 261
  tmp = select_packed_size(& cr->sel);
#line 261
  sel_size = tmp;
#line 262
  vals_rems_size = ((cr->n * cr->rem_r + 31U) >> 5) * (cmph_uint32 )sizeof(cmph_uint32 );
  }
#line 263
  return ((4U * (cmph_uint32 )sizeof(cmph_uint32 ) + sel_size) + vals_rems_size);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/compressed_rank.c"
cmph_uint32 compressed_rank_query_packed(void *cr_packed , cmph_uint32 idx ) 
{ 
  register cmph_uint32 *ptr ;
  register cmph_uint32 max_val ;
  cmph_uint32 *tmp ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp___0 ;
  register cmph_uint32 rem_r ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint32 buflen_sel ;
  cmph_uint32 *tmp___2 ;
  register cmph_uint32 *sel_packed ;
  register cmph_uint32 *bits_vec ;
  register cmph_uint32 *vals_rems ;
  register cmph_uint32 rems_mask ;
  register cmph_uint32 val_quot ;
  register cmph_uint32 val_rem ;
  register cmph_uint32 sel_res ;
  register cmph_uint32 rank___0 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
#line 269
  ptr = (cmph_uint32 *)cr_packed;
#line 270
  tmp = ptr;
#line 270
  ptr ++;
#line 270
  max_val = *tmp;
#line 271
  tmp___0 = ptr;
#line 271
  ptr ++;
#line 271
  n = *tmp___0;
#line 272
  tmp___1 = ptr;
#line 272
  ptr ++;
#line 272
  rem_r = *tmp___1;
#line 273
  tmp___2 = ptr;
#line 273
  ptr ++;
#line 273
  buflen_sel = *tmp___2;
#line 274
  sel_packed = ptr;
#line 276
  bits_vec = sel_packed + 2;
#line 278
  ptr += buflen_sel >> 2;
#line 278
  vals_rems = ptr;
#line 285
  if (idx > max_val) {
#line 287
    return (n);
  }
#line 290
  val_quot = idx >> rem_r;
#line 291
  rems_mask = (1U << rem_r) - 1U;
#line 292
  val_rem = idx & rems_mask;
#line 293
  if (val_quot == 0U) {
#line 295
    sel_res = (cmph_uint32 )0;
#line 295
    rank___0 = sel_res;
  } else {
    {
#line 299
    tmp___3 = select_query_packed((void *)sel_packed, val_quot - 1U);
#line 299
    sel_res = tmp___3 + 1U;
#line 300
    rank___0 = sel_res - val_quot;
    }
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (*(bits_vec + (sel_res >> 5)) & (unsigned int )bitmask32___0[sel_res & 31U]) {
#line 307
      goto while_break;
    }
    {
#line 309
    tmp___4 = get_bits_value(vals_rems, rank___0, rem_r, rems_mask);
    }
#line 309
    if (tmp___4 >= val_rem) {
#line 311
      goto while_break;
    }
#line 313
    sel_res ++;
#line 314
    rank___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (rank___0);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.h"
jenkins_state_t *jenkins_state_new(cmph_uint32 size ) ;
#line 20
cmph_uint32 jenkins_hash(jenkins_state_t *state , char const   *k , cmph_uint32 keylen ) ;
#line 28
void jenkins_hash_vector_(jenkins_state_t *state , char const   *k , cmph_uint32 keylen ,
                          cmph_uint32 *hashes ) ;
#line 30
void jenkins_state_dump(jenkins_state_t *state , char **buf , cmph_uint32 *buflen ) ;
#line 31
jenkins_state_t *jenkins_state_copy(jenkins_state_t *src_state ) ;
#line 32
jenkins_state_t *jenkins_state_load(char const   *buf , cmph_uint32 buflen ) ;
#line 33
void jenkins_state_destroy(jenkins_state_t *state ) ;
#line 40
void jenkins_state_pack(jenkins_state_t *state , void *jenkins_packed ) ;
#line 46
cmph_uint32 jenkins_state_packed_size(void) ;
#line 55
cmph_uint32 jenkins_hash_packed(void *jenkins_packed , char const   *k , cmph_uint32 keylen ) ;
#line 63
void jenkins_hash_vector_packed(void *jenkins_packed , char const   *k , cmph_uint32 keylen ,
                                cmph_uint32 *hashes ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
jenkins_state_t *jenkins_state_new(cmph_uint32 size ) 
{ 
  jenkins_state_t *state ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  tmp = malloc(sizeof(jenkins_state_t ));
#line 89
  state = (jenkins_state_t *)tmp;
#line 91
  tmp___0 = rand();
#line 91
  state->seed = (cmph_uint32 )tmp___0 % size;
  }
#line 92
  return (state);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
void jenkins_state_destroy(jenkins_state_t *state ) 
{ 


  {
  {
#line 96
  free((void *)state);
  }
#line 97
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
__inline void __jenkins_hash_vector(cmph_uint32 seed , char const   *k , cmph_uint32 keylen ,
                                    cmph_uint32 *hashes ) 
{ 
  register cmph_uint32 len ;
  register cmph_uint32 length ;
  cmph_uint32 tmp ;

  {
#line 105
  length = keylen;
#line 106
  len = length;
#line 107
  tmp = 2654435769U;
#line 107
  *(hashes + 1) = tmp;
#line 107
  *(hashes + 0) = tmp;
#line 108
  *(hashes + 2) = seed;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (len >= 12U)) {
#line 111
      goto while_break;
    }
#line 113
    *(hashes + 0) += (((cmph_uint32 )*(k + 0) + ((cmph_uint32 )*(k + 1) << 8)) + ((cmph_uint32 )*(k + 2) << 16)) + ((cmph_uint32 )*(k + 3) << 24);
#line 114
    *(hashes + 1) += (((cmph_uint32 )*(k + 4) + ((cmph_uint32 )*(k + 5) << 8)) + ((cmph_uint32 )*(k + 6) << 16)) + ((cmph_uint32 )*(k + 7) << 24);
#line 115
    *(hashes + 2) += (((cmph_uint32 )*(k + 8) + ((cmph_uint32 )*(k + 9) << 8)) + ((cmph_uint32 )*(k + 10) << 16)) + ((cmph_uint32 )*(k + 11) << 24);
#line 116
    *(hashes + 0) -= *(hashes + 1);
#line 116
    *(hashes + 0) -= *(hashes + 2);
#line 116
    *(hashes + 0) ^= *(hashes + 2) >> 13;
#line 116
    *(hashes + 1) -= *(hashes + 2);
#line 116
    *(hashes + 1) -= *(hashes + 0);
#line 116
    *(hashes + 1) ^= *(hashes + 0) << 8;
#line 116
    *(hashes + 2) -= *(hashes + 0);
#line 116
    *(hashes + 2) -= *(hashes + 1);
#line 116
    *(hashes + 2) ^= *(hashes + 1) >> 13;
#line 116
    *(hashes + 0) -= *(hashes + 1);
#line 116
    *(hashes + 0) -= *(hashes + 2);
#line 116
    *(hashes + 0) ^= *(hashes + 2) >> 12;
#line 116
    *(hashes + 1) -= *(hashes + 2);
#line 116
    *(hashes + 1) -= *(hashes + 0);
#line 116
    *(hashes + 1) ^= *(hashes + 0) << 16;
#line 116
    *(hashes + 2) -= *(hashes + 0);
#line 116
    *(hashes + 2) -= *(hashes + 1);
#line 116
    *(hashes + 2) ^= *(hashes + 1) >> 5;
#line 116
    *(hashes + 0) -= *(hashes + 1);
#line 116
    *(hashes + 0) -= *(hashes + 2);
#line 116
    *(hashes + 0) ^= *(hashes + 2) >> 3;
#line 116
    *(hashes + 1) -= *(hashes + 2);
#line 116
    *(hashes + 1) -= *(hashes + 0);
#line 116
    *(hashes + 1) ^= *(hashes + 0) << 10;
#line 116
    *(hashes + 2) -= *(hashes + 0);
#line 116
    *(hashes + 2) -= *(hashes + 1);
#line 116
    *(hashes + 2) ^= *(hashes + 1) >> 15;
#line 117
    k += 12;
#line 117
    len -= 12U;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  *(hashes + 2) += length;
  {
#line 124
  if (len == 11U) {
#line 124
    goto case_11;
  }
#line 126
  if (len == 10U) {
#line 126
    goto case_10;
  }
#line 128
  if (len == 9U) {
#line 128
    goto case_9;
  }
#line 131
  if (len == 8U) {
#line 131
    goto case_8;
  }
#line 133
  if (len == 7U) {
#line 133
    goto case_7;
  }
#line 135
  if (len == 6U) {
#line 135
    goto case_6;
  }
#line 137
  if (len == 5U) {
#line 137
    goto case_5;
  }
#line 139
  if (len == 4U) {
#line 139
    goto case_4;
  }
#line 141
  if (len == 3U) {
#line 141
    goto case_3;
  }
#line 143
  if (len == 2U) {
#line 143
    goto case_2;
  }
#line 145
  if (len == 1U) {
#line 145
    goto case_1;
  }
#line 122
  goto switch_break;
  case_11: /* CIL Label */ 
#line 125
  *(hashes + 2) += (cmph_uint32 )*(k + 10) << 24;
  case_10: /* CIL Label */ 
#line 127
  *(hashes + 2) += (cmph_uint32 )*(k + 9) << 16;
  case_9: /* CIL Label */ 
#line 129
  *(hashes + 2) += (cmph_uint32 )*(k + 8) << 8;
  case_8: /* CIL Label */ 
#line 132
  *(hashes + 1) += (cmph_uint32 )*(k + 7) << 24;
  case_7: /* CIL Label */ 
#line 134
  *(hashes + 1) += (cmph_uint32 )*(k + 6) << 16;
  case_6: /* CIL Label */ 
#line 136
  *(hashes + 1) += (cmph_uint32 )*(k + 5) << 8;
  case_5: /* CIL Label */ 
#line 138
  *(hashes + 1) += (cmph_uint32 )((cmph_uint8 )*(k + 4));
  case_4: /* CIL Label */ 
#line 140
  *(hashes + 0) += (cmph_uint32 )*(k + 3) << 24;
  case_3: /* CIL Label */ 
#line 142
  *(hashes + 0) += (cmph_uint32 )*(k + 2) << 16;
  case_2: /* CIL Label */ 
#line 144
  *(hashes + 0) += (cmph_uint32 )*(k + 1) << 8;
  case_1: /* CIL Label */ 
#line 146
  *(hashes + 0) += (cmph_uint32 )((cmph_uint8 )*(k + 0));
  switch_break: /* CIL Label */ ;
  }
#line 150
  *(hashes + 0) -= *(hashes + 1);
#line 150
  *(hashes + 0) -= *(hashes + 2);
#line 150
  *(hashes + 0) ^= *(hashes + 2) >> 13;
#line 150
  *(hashes + 1) -= *(hashes + 2);
#line 150
  *(hashes + 1) -= *(hashes + 0);
#line 150
  *(hashes + 1) ^= *(hashes + 0) << 8;
#line 150
  *(hashes + 2) -= *(hashes + 0);
#line 150
  *(hashes + 2) -= *(hashes + 1);
#line 150
  *(hashes + 2) ^= *(hashes + 1) >> 13;
#line 150
  *(hashes + 0) -= *(hashes + 1);
#line 150
  *(hashes + 0) -= *(hashes + 2);
#line 150
  *(hashes + 0) ^= *(hashes + 2) >> 12;
#line 150
  *(hashes + 1) -= *(hashes + 2);
#line 150
  *(hashes + 1) -= *(hashes + 0);
#line 150
  *(hashes + 1) ^= *(hashes + 0) << 16;
#line 150
  *(hashes + 2) -= *(hashes + 0);
#line 150
  *(hashes + 2) -= *(hashes + 1);
#line 150
  *(hashes + 2) ^= *(hashes + 1) >> 5;
#line 150
  *(hashes + 0) -= *(hashes + 1);
#line 150
  *(hashes + 0) -= *(hashes + 2);
#line 150
  *(hashes + 0) ^= *(hashes + 2) >> 3;
#line 150
  *(hashes + 1) -= *(hashes + 2);
#line 150
  *(hashes + 1) -= *(hashes + 0);
#line 150
  *(hashes + 1) ^= *(hashes + 0) << 10;
#line 150
  *(hashes + 2) -= *(hashes + 0);
#line 150
  *(hashes + 2) -= *(hashes + 1);
#line 150
  *(hashes + 2) ^= *(hashes + 1) >> 15;
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
cmph_uint32 jenkins_hash(jenkins_state_t *state , char const   *k , cmph_uint32 keylen ) 
{ 
  cmph_uint32 hashes[3] ;

  {
  {
#line 156
  __jenkins_hash_vector(state->seed, k, keylen, hashes);
  }
#line 157
  return (hashes[2]);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
void jenkins_hash_vector_(jenkins_state_t *state , char const   *k , cmph_uint32 keylen ,
                          cmph_uint32 *hashes ) 
{ 


  {
  {
#line 217
  __jenkins_hash_vector(state->seed, k, keylen, hashes);
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
void jenkins_state_dump(jenkins_state_t *state , char **buf , cmph_uint32 *buflen ) 
{ 
  void *tmp ;

  {
  {
#line 222
  *buflen = (cmph_uint32 )sizeof(cmph_uint32 );
#line 223
  tmp = malloc(sizeof(cmph_uint32 ));
#line 223
  *buf = (char *)tmp;
  }
#line 224
  if (! *buf) {
#line 226
    *buflen = 4294967295U;
#line 227
    return;
  }
  {
#line 229
  memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)(& state->seed),
         sizeof(cmph_uint32 ));
  }
#line 231
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
jenkins_state_t *jenkins_state_copy(jenkins_state_t *src_state ) 
{ 
  jenkins_state_t *dest_state ;
  void *tmp ;

  {
  {
#line 236
  tmp = malloc(sizeof(jenkins_state_t ));
#line 236
  dest_state = (jenkins_state_t *)tmp;
#line 237
  dest_state->hashfunc = src_state->hashfunc;
#line 238
  dest_state->seed = src_state->seed;
  }
#line 239
  return (dest_state);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
jenkins_state_t *jenkins_state_load(char const   *buf , cmph_uint32 buflen ) 
{ 
  jenkins_state_t *state ;
  void *tmp ;

  {
  {
#line 244
  tmp = malloc(sizeof(jenkins_state_t ));
#line 244
  state = (jenkins_state_t *)tmp;
#line 245
  state->seed = *((cmph_uint32 *)buf);
#line 246
  state->hashfunc = (CMPH_HASH )0;
  }
#line 248
  return (state);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
void jenkins_state_pack(jenkins_state_t *state , void *jenkins_packed ) 
{ 


  {
#line 259
  if (state) {
#line 259
    if (jenkins_packed) {
      {
#line 261
      memcpy((void */* __restrict  */)jenkins_packed, (void const   */* __restrict  */)(& state->seed),
             sizeof(cmph_uint32 ));
      }
    }
  }
#line 263
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
cmph_uint32 jenkins_state_packed_size(void) 
{ 


  {
#line 271
  return ((cmph_uint32 )sizeof(cmph_uint32 ));
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
cmph_uint32 jenkins_hash_packed(void *jenkins_packed , char const   *k , cmph_uint32 keylen ) 
{ 
  cmph_uint32 hashes[3] ;

  {
  {
#line 284
  __jenkins_hash_vector(*((cmph_uint32 *)jenkins_packed), k, keylen, hashes);
  }
#line 285
  return (hashes[2]);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/jenkins_hash.c"
void jenkins_hash_vector_packed(void *jenkins_packed , char const   *k , cmph_uint32 keylen ,
                                cmph_uint32 *hashes ) 
{ 


  {
  {
#line 296
  __jenkins_hash_vector(*((cmph_uint32 *)jenkins_packed), k, keylen, hashes);
  }
#line 297
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___3[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                            cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_ph_queue_t queue ,
                                 bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___3[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___3[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___3[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___3[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___3[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___3[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___3[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___3[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization(bdz_ph_config_data_t *bdz_ph ) ;
#line 205 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
bdz_ph_config_data_t *bdz_ph_config_new(void) 
{ 
  bdz_ph_config_data_t *bdz_ph ;
  void *tmp ;

  {
  {
#line 208
  tmp = malloc(sizeof(bdz_ph_config_data_t ));
#line 208
  bdz_ph = (bdz_ph_config_data_t *)tmp;
  }
#line 209
  if (! bdz_ph) {
    {
#line 209
    __assert_fail("bdz_ph", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c",
                  209U, "bdz_ph_config_new");
    }
  }
  {
#line 210
  memset((void *)bdz_ph, 0, sizeof(bdz_ph_config_data_t ));
#line 211
  bdz_ph->hashfunc = (CMPH_HASH )0;
#line 212
  bdz_ph->g = (cmph_uint8 *)((void *)0);
#line 213
  bdz_ph->hl = (hash_state_t *)((void *)0);
  }
#line 214
  return (bdz_ph);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
void bdz_ph_config_destroy(cmph_config_t *mph ) 
{ 
  bdz_ph_config_data_t *data ;

  {
  {
#line 219
  data = (bdz_ph_config_data_t *)mph->data;
#line 221
  free((void *)data);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
void bdz_ph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  bdz_ph_config_data_t *bdz_ph ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 226
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 227
  hashptr = hashfuncs;
#line 228
  i = (cmph_uint32 )0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! ((unsigned int )*hashptr != 1U)) {
#line 229
      goto while_break;
    }
#line 231
    if (i >= 1U) {
#line 231
      goto while_break;
    }
#line 232
    bdz_ph->hashfunc = *hashptr;
#line 233
    i ++;
#line 233
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
cmph_t *bdz_ph_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  bdz_ph_data_t *bdz_phf ;
  cmph_uint32 iterations ;
  bdz_ph_queue_t edges ;
  bdz_ph_graph3_t graph3 ;
  bdz_ph_config_data_t *bdz_ph ;
  double tmp ;
  int ok ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 239
  mphf = (cmph_t *)((void *)0);
#line 240
  bdz_phf = (bdz_ph_data_t *)((void *)0);
#line 244
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 252
  if (c == (double )0) {
#line 252
    c = 1.23;
  }
  {
#line 254
  bdz_ph->m = (mph->key_source)->nkeys;
#line 255
  tmp = ceil((c * (double )(mph->key_source)->nkeys) / (double )3);
#line 255
  bdz_ph->r = (cmph_uint32 )tmp;
  }
#line 256
  if (bdz_ph->r % 2U == 0U) {
#line 256
    (bdz_ph->r) ++;
  }
  {
#line 257
  bdz_ph->n = 3U * bdz_ph->r;
#line 260
  bdz_ph_alloc_graph3(& graph3, bdz_ph->m, bdz_ph->n);
#line 261
  bdz_ph_alloc_queue(& edges, bdz_ph->m);
#line 267
  iterations = (cmph_uint32 )100;
  }
#line 268
  if (mph->verbosity) {
    {
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys with graph sized %u\n",
            bdz_ph->m, bdz_ph->n);
    }
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    bdz_ph->hl = hash_state_new(bdz_ph->hashfunc, (cmph_uint32 )15);
#line 278
    ok = bdz_ph_mapping(mph, & graph3, edges);
    }
#line 279
    if (! ok) {
      {
#line 281
      iterations --;
#line 282
      hash_state_destroy(bdz_ph->hl);
#line 283
      bdz_ph->hl = (hash_state_t *)((void *)0);
      }
#line 285
      if (mph->verbosity) {
        {
#line 287
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"acyclic graph creation failure - %u iterations remaining\n",
                iterations);
        }
      }
#line 289
      if (iterations == 0U) {
#line 289
        goto while_break;
      }
    } else {
#line 291
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (iterations == 0U) {
    {
#line 297
    bdz_ph_free_queue(& edges);
#line 298
    bdz_ph_free_graph3(& graph3);
    }
#line 299
    return ((cmph_t *)((void *)0));
  }
  {
#line 301
  bdz_ph_partial_free_graph3(& graph3);
  }
#line 303
  if (mph->verbosity) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering assigning step for mph creation of %u keys with graph sized %u\n",
            bdz_ph->m, bdz_ph->n);
    }
  }
  {
#line 307
  assigning(bdz_ph, & graph3, edges);
#line 309
  bdz_ph_free_queue(& edges);
#line 310
  bdz_ph_free_graph3(& graph3);
  }
#line 312
  if (mph->verbosity) {
    {
#line 314
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting optimization step\n");
    }
  }
  {
#line 317
  bdz_ph_optimization(bdz_ph);
#line 322
  tmp___0 = malloc(sizeof(cmph_t ));
#line 322
  mphf = (cmph_t *)tmp___0;
#line 323
  mphf->algo = mph->algo;
#line 324
  tmp___1 = malloc(sizeof(bdz_ph_data_t ));
#line 324
  bdz_phf = (bdz_ph_data_t *)tmp___1;
#line 325
  bdz_phf->g = bdz_ph->g;
#line 326
  bdz_ph->g = (cmph_uint8 *)((void *)0);
#line 327
  bdz_phf->hl = bdz_ph->hl;
#line 328
  bdz_ph->hl = (hash_state_t *)((void *)0);
#line 329
  bdz_phf->n = bdz_ph->n;
#line 330
  bdz_phf->m = bdz_ph->m;
#line 331
  bdz_phf->r = bdz_ph->r;
#line 332
  mphf->data = (void *)bdz_phf;
#line 333
  mphf->size = bdz_ph->n;
  }
#line 336
  if (mph->verbosity) {
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 348
  return (mphf);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___3[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___3[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___3[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___3[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___3[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___3[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___3[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___3[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___3[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___3[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___3[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
int bdz_ph_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 sizeg ;
  register size_t nbytes ;
  bdz_ph_data_t *data ;
  double tmp ;

  {
  {
#line 449
  buf = (char *)((void *)0);
#line 451
  sizeg = (cmph_uint32 )0;
#line 453
  data = (bdz_ph_data_t *)mphf->data;
#line 454
  __cmph_dump(mphf, fd);
#line 456
  hash_state_dump(data->hl, & buf, & buflen);
#line 458
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 459
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 460
  free((void *)buf);
#line 462
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 463
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 464
  nbytes = fwrite((void const   */* __restrict  */)(& data->r), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 465
  tmp = ceil((double )data->n / 5.0);
#line 465
  sizeg = (cmph_uint32 )tmp;
#line 466
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )sizeg,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 474
  return (1);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
void bdz_ph_load(FILE *f , cmph_t *mphf ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 sizeg ;
  register size_t nbytes ;
  bdz_ph_data_t *bdz_ph ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 479
  buf = (char *)((void *)0);
#line 481
  sizeg = (cmph_uint32 )0;
#line 483
  tmp = malloc(sizeof(bdz_ph_data_t ));
#line 483
  bdz_ph = (bdz_ph_data_t *)tmp;
#line 486
  mphf->data = (void *)bdz_ph;
#line 488
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 490
  tmp___0 = malloc((size_t )buflen);
#line 490
  buf = (char *)tmp___0;
#line 491
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 492
  bdz_ph->hl = hash_state_load((char const   *)buf, buflen);
#line 493
  free((void *)buf);
#line 497
  nbytes = fread((void */* __restrict  */)(& bdz_ph->n), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 498
  nbytes = fread((void */* __restrict  */)(& bdz_ph->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 499
  nbytes = fread((void */* __restrict  */)(& bdz_ph->r), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 500
  tmp___1 = ceil((double )bdz_ph->n / 5.0);
#line 500
  sizeg = (cmph_uint32 )tmp___1;
#line 501
  tmp___2 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 501
  bdz_ph->g = (cmph_uint8 *)tmp___2;
#line 502
  nbytes = fread((void */* __restrict  */)bdz_ph->g, (unsigned long )sizeg * sizeof(cmph_uint8 ),
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 504
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
cmph_uint32 bdz_ph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register bdz_ph_data_t *bdz_ph ;
  cmph_uint32 hl[3] ;
  register cmph_uint8 byte0 ;
  register cmph_uint8 byte1 ;
  register cmph_uint8 byte2 ;
  register cmph_uint32 vertex ;

  {
  {
#line 510
  bdz_ph = (bdz_ph_data_t *)mphf->data;
#line 515
  hash_vector(bdz_ph->hl, key, keylen, hl);
#line 516
  hl[0] %= bdz_ph->r;
#line 517
  hl[1] = hl[1] % bdz_ph->r + bdz_ph->r;
#line 518
  hl[2] = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 520
  byte0 = *(bdz_ph->g + hl[0] / 5U);
#line 521
  byte1 = *(bdz_ph->g + hl[1] / 5U);
#line 522
  byte2 = *(bdz_ph->g + hl[2] / 5U);
#line 524
  byte0 = lookup_table[hl[0] % 5U][byte0];
#line 525
  byte1 = lookup_table[hl[1] % 5U][byte1];
#line 526
  byte2 = lookup_table[hl[2] % 5U][byte2];
#line 527
  vertex = hl[(((int )byte0 + (int )byte1) + (int )byte2) % 3];
  }
#line 529
  return (vertex);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
void bdz_ph_destroy(cmph_t *mphf ) 
{ 
  bdz_ph_data_t *data ;

  {
  {
#line 535
  data = (bdz_ph_data_t *)mphf->data;
#line 536
  free((void *)data->g);
#line 537
  hash_state_destroy(data->hl);
#line 538
  free((void *)data);
#line 539
  free((void *)mphf);
  }
#line 540
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
void bdz_ph_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  bdz_ph_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 sizeg ;
  double tmp___1 ;

  {
  {
#line 549
  data = (bdz_ph_data_t *)mphf->data;
#line 550
  ptr = (cmph_uint8 *)packed_mphf;
#line 553
  tmp = hash_get_type(data->hl);
#line 553
  hl_type = tmp;
#line 554
  *((cmph_uint32 *)ptr) = (cmph_uint32 )hl_type;
#line 555
  ptr += sizeof(cmph_uint32 );
#line 558
  hash_state_pack(data->hl, (void *)ptr);
#line 559
  tmp___0 = hash_state_packed_size(hl_type);
#line 559
  ptr += tmp___0;
#line 562
  *((cmph_uint32 *)ptr) = data->r;
#line 563
  ptr += sizeof(data->r);
#line 566
  tmp___1 = ceil((double )data->n / 5.0);
#line 566
  sizeg = (cmph_uint32 )tmp___1;
#line 567
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )sizeg);
  }
#line 568
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
cmph_uint32 bdz_ph_packed_size(cmph_t *mphf ) 
{ 
  bdz_ph_data_t *data ;
  CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  cmph_uint32 tmp___1 ;

  {
  {
#line 577
  data = (bdz_ph_data_t *)mphf->data;
#line 578
  tmp = hash_get_type(data->hl);
#line 578
  hl_type = tmp;
#line 579
  tmp___0 = ceil((double )data->n / 5.0);
#line 579
  sizeg = (cmph_uint32 )tmp___0;
#line 580
  tmp___1 = hash_state_packed_size(hl_type);
  }
#line 580
  return ((cmph_uint32 )(((sizeof(CMPH_ALGO ) + (unsigned long )tmp___1) + 2UL * sizeof(cmph_uint32 )) + sizeof(cmph_uint8 ) * (unsigned long )sizeg));
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
cmph_uint32 bdz_ph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register CMPH_HASH hl_type ;
  register cmph_uint8 *hl_ptr ;
  register cmph_uint8 *ptr ;
  cmph_uint32 tmp ;
  register cmph_uint32 r ;
  register cmph_uint8 *g ;
  cmph_uint32 hl[3] ;
  register cmph_uint8 byte0 ;
  register cmph_uint8 byte1 ;
  register cmph_uint8 byte2 ;
  register cmph_uint32 vertex ;

  {
  {
#line 593
  hl_type = (CMPH_HASH )*((cmph_uint32 *)packed_mphf);
#line 594
  hl_ptr = (cmph_uint8 *)packed_mphf + 4;
#line 596
  tmp = hash_state_packed_size(hl_type);
#line 596
  ptr = hl_ptr + tmp;
#line 598
  r = *((cmph_uint32 *)ptr);
#line 599
  g = ptr + 4;
#line 605
  hash_vector_packed((void *)hl_ptr, hl_type, key, keylen, hl);
#line 607
  hl[0] %= r;
#line 608
  hl[1] = hl[1] % r + r;
#line 609
  hl[2] = hl[2] % r + (r << 1);
#line 611
  byte0 = *(g + hl[0] / 5U);
#line 612
  byte1 = *(g + hl[1] / 5U);
#line 613
  byte2 = *(g + hl[2] / 5U);
#line 615
  byte0 = lookup_table[hl[0] % 5U][byte0];
#line 616
  byte1 = lookup_table[hl[1] % 5U][byte1];
#line 617
  byte2 = lookup_table[hl[2] % 5U][byte2];
#line 618
  vertex = hl[(((int )byte0 + (int )byte1) + (int )byte2) % 3];
  }
#line 620
  return (vertex);
}
}
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                          cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching(fch_config_data_t *fch , fch_buckets_t *buckets , cmph_uint32 *sorted_indexes ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
fch_config_data_t *fch_config_new(void) 
{ 
  fch_config_data_t *fch ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 25
  tmp = malloc(sizeof(fch_config_data_t ));
#line 25
  fch = (fch_config_data_t *)tmp;
  }
#line 26
  if (! fch) {
    {
#line 26
    __assert_fail("fch", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c",
                  26U, "fch_config_new");
    }
  }
  {
#line 27
  memset((void *)fch, 0, sizeof(fch_config_data_t ));
#line 28
  fch->hashfuncs[0] = (CMPH_HASH )0;
#line 29
  fch->hashfuncs[1] = (CMPH_HASH )0;
#line 30
  tmp___0 = (cmph_uint32 )0;
#line 30
  fch->b = tmp___0;
#line 30
  fch->m = tmp___0;
#line 31
  tmp___2 = 0.0;
#line 31
  fch->p2 = tmp___2;
#line 31
  tmp___1 = tmp___2;
#line 31
  fch->p1 = tmp___1;
#line 31
  fch->c = tmp___1;
#line 32
  fch->g = (cmph_uint32 *)((void *)0);
#line 33
  fch->h1 = (hash_state_t *)((void *)0);
#line 34
  fch->h2 = (hash_state_t *)((void *)0);
  }
#line 35
  return (fch);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
void fch_config_destroy(cmph_config_t *mph ) 
{ 
  fch_config_data_t *data ;

  {
  {
#line 40
  data = (fch_config_data_t *)mph->data;
#line 42
  free((void *)data);
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
void fch_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  fch_config_data_t *fch ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 47
  fch = (fch_config_data_t *)mph->data;
#line 48
  hashptr = hashfuncs;
#line 49
  i = (cmph_uint32 )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! ((unsigned int )*hashptr != 1U)) {
#line 50
      goto while_break;
    }
#line 52
    if (i >= 2U) {
#line 52
      goto while_break;
    }
#line 53
    fch->hashfuncs[i] = *hashptr;
#line 54
    i ++;
#line 54
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_uint32 mixh10h11h12(cmph_uint32 b , double p1 , double p2 , cmph_uint32 initial_index ) 
{ 
  register cmph_uint32 int_p2 ;

  {
#line 60
  int_p2 = (cmph_uint32 )p2;
#line 61
  if ((double )initial_index < p1) {
#line 61
    initial_index %= int_p2;
  } else {
#line 63
    initial_index %= b;
#line 64
    if ((double )initial_index < p2) {
#line 64
      initial_index += int_p2;
    }
  }
#line 66
  return (initial_index);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_uint32 fch_calc_b(double c , cmph_uint32 m ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 72
  tmp = log((double )m);
#line 72
  tmp___0 = log(2.0);
#line 72
  tmp___1 = ceil((c * (double )m) / (tmp / tmp___0 + (double )1));
  }
#line 72
  return ((cmph_uint32 )tmp___1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
double fch_calc_p1(cmph_uint32 m ) 
{ 
  double tmp ;

  {
  {
#line 77
  tmp = ceil(0.55 * (double )m);
  }
#line 77
  return (tmp);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
double fch_calc_p2(cmph_uint32 b ) 
{ 
  double tmp ;

  {
  {
#line 82
  tmp = ceil(0.3 * (double )b);
  }
#line 82
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                          cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching(fch_config_data_t *fch , fch_buckets_t *buckets , cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_t *fch_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  fch_data_t *fchf ;
  cmph_uint32 iterations ;
  cmph_uint8 restart_mapping ;
  fch_buckets_t *buckets ;
  cmph_uint32 *sorted_indexes ;
  fch_config_data_t *fch ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 251
  mphf = (cmph_t *)((void *)0);
#line 252
  fchf = (fch_data_t *)((void *)0);
#line 253
  iterations = (cmph_uint32 )100;
#line 254
  restart_mapping = (cmph_uint8 )0;
#line 255
  buckets = (fch_buckets_t *)((void *)0);
#line 256
  sorted_indexes = (cmph_uint32 *)((void *)0);
#line 257
  fch = (fch_config_data_t *)mph->data;
#line 258
  fch->m = (mph->key_source)->nkeys;
#line 260
  if (c <= (double )2) {
#line 260
    c = 2.6;
  }
#line 261
  fch->c = c;
#line 263
  fch->h1 = (hash_state_t *)((void *)0);
#line 264
  fch->h2 = (hash_state_t *)((void *)0);
#line 265
  fch->g = (cmph_uint32 *)((void *)0);
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (mph->verbosity) {
      {
#line 270
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys\n",
              fch->m);
      }
    }
#line 272
    if (buckets) {
      {
#line 272
      fch_buckets_destroy(buckets);
      }
    }
    {
#line 273
    buckets = mapping(mph);
    }
#line 274
    if (mph->verbosity) {
      {
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting ordering step\n");
      }
    }
#line 278
    if (sorted_indexes) {
      {
#line 278
      free((void *)sorted_indexes);
      }
    }
    {
#line 279
    sorted_indexes = ordering(buckets);
    }
#line 280
    if (mph->verbosity) {
      {
#line 282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting searching step.\n");
      }
    }
    {
#line 284
    restart_mapping = searching(fch, buckets, sorted_indexes);
#line 285
    iterations --;
    }
#line 266
    if (restart_mapping) {
#line 266
      if (! (iterations > 0U)) {
#line 266
        goto while_break;
      }
    } else {
#line 266
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (buckets) {
    {
#line 288
    fch_buckets_destroy(buckets);
    }
  }
#line 289
  if (sorted_indexes) {
    {
#line 289
    free((void *)sorted_indexes);
    }
  }
#line 290
  if (iterations == 0U) {
#line 290
    return ((cmph_t *)((void *)0));
  }
  {
#line 291
  tmp = malloc(sizeof(cmph_t ));
#line 291
  mphf = (cmph_t *)tmp;
#line 292
  mphf->algo = mph->algo;
#line 293
  tmp___0 = malloc(sizeof(fch_data_t ));
#line 293
  fchf = (fch_data_t *)tmp___0;
#line 294
  fchf->g = fch->g;
#line 295
  fch->g = (cmph_uint32 *)((void *)0);
#line 296
  fchf->h1 = fch->h1;
#line 297
  fch->h1 = (hash_state_t *)((void *)0);
#line 298
  fchf->h2 = fch->h2;
#line 299
  fch->h2 = (hash_state_t *)((void *)0);
#line 300
  fchf->p2 = fch->p2;
#line 301
  fchf->p1 = fch->p1;
#line 302
  fchf->b = fch->b;
#line 303
  fchf->c = fch->c;
#line 304
  fchf->m = fch->m;
#line 305
  mphf->data = (void *)fchf;
#line 306
  mphf->size = fch->m;
  }
#line 308
  if (mph->verbosity) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 312
  return (mphf);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
int fch_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  fch_data_t *data ;

  {
  {
#line 317
  buf = (char *)((void *)0);
#line 321
  data = (fch_data_t *)mphf->data;
#line 322
  __cmph_dump(mphf, fd);
#line 324
  hash_state_dump(data->h1, & buf, & buflen);
#line 326
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 327
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 328
  free((void *)buf);
#line 330
  hash_state_dump(data->h2, & buf, & buflen);
#line 332
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 333
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 334
  free((void *)buf);
#line 336
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 337
  nbytes = fwrite((void const   */* __restrict  */)(& data->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 338
  nbytes = fwrite((void const   */* __restrict  */)(& data->b), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 339
  nbytes = fwrite((void const   */* __restrict  */)(& data->p1), sizeof(double ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 340
  nbytes = fwrite((void const   */* __restrict  */)(& data->p2), sizeof(double ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 341
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->b,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 348
  return (1);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
void fch_load(FILE *f , cmph_t *mphf ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  fch_data_t *fch ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 353
  buf = (char *)((void *)0);
#line 356
  tmp = malloc(sizeof(fch_data_t ));
#line 356
  fch = (fch_data_t *)tmp;
#line 359
  mphf->data = (void *)fch;
#line 361
  fch->h1 = (hash_state_t *)((void *)0);
#line 362
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 364
  tmp___0 = malloc((size_t )buflen);
#line 364
  buf = (char *)tmp___0;
#line 365
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 366
  fch->h1 = hash_state_load((char const   *)buf, buflen);
#line 367
  free((void *)buf);
#line 370
  mphf->data = (void *)fch;
#line 372
  fch->h2 = (hash_state_t *)((void *)0);
#line 373
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 375
  tmp___1 = malloc((size_t )buflen);
#line 375
  buf = (char *)tmp___1;
#line 376
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 377
  fch->h2 = hash_state_load((char const   *)buf, buflen);
#line 378
  free((void *)buf);
#line 382
  nbytes = fread((void */* __restrict  */)(& fch->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 383
  nbytes = fread((void */* __restrict  */)(& fch->c), sizeof(double ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 384
  nbytes = fread((void */* __restrict  */)(& fch->b), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 385
  nbytes = fread((void */* __restrict  */)(& fch->p1), sizeof(double ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 386
  nbytes = fread((void */* __restrict  */)(& fch->p2), sizeof(double ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 388
  tmp___2 = malloc(sizeof(cmph_uint32 ) * (unsigned long )fch->b);
#line 388
  fch->g = (cmph_uint32 *)tmp___2;
#line 389
  nbytes = fread((void */* __restrict  */)fch->g, (unsigned long )fch->b * sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 396
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_uint32 fch_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  fch_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 tmp ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 401
  fch = (fch_data_t *)mphf->data;
#line 402
  tmp = hash(fch->h1, key, keylen);
#line 402
  h1 = tmp % fch->m;
#line 403
  tmp___0 = hash(fch->h2, key, keylen);
#line 403
  h2 = tmp___0 % fch->m;
#line 404
  h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
  }
#line 406
  return ((h2 + *(fch->g + h1)) % fch->m);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
void fch_destroy(cmph_t *mphf ) 
{ 
  fch_data_t *data ;

  {
  {
#line 410
  data = (fch_data_t *)mphf->data;
#line 411
  free((void *)data->g);
#line 412
  hash_state_destroy(data->h1);
#line 413
  hash_state_destroy(data->h2);
#line 414
  free((void *)data);
#line 415
  free((void *)mphf);
  }
#line 416
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
void fch_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  fch_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 425
  data = (fch_data_t *)mphf->data;
#line 426
  ptr = (cmph_uint8 *)packed_mphf;
#line 429
  tmp = hash_get_type(data->h1);
#line 429
  h1_type = tmp;
#line 430
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h1_type;
#line 431
  ptr += sizeof(cmph_uint32 );
#line 434
  hash_state_pack(data->h1, (void *)ptr);
#line 435
  tmp___0 = hash_state_packed_size(h1_type);
#line 435
  ptr += tmp___0;
#line 438
  tmp___1 = hash_get_type(data->h2);
#line 438
  h2_type = tmp___1;
#line 439
  *((cmph_uint32 *)ptr) = (cmph_uint32 )h2_type;
#line 440
  ptr += sizeof(cmph_uint32 );
#line 443
  hash_state_pack(data->h2, (void *)ptr);
#line 444
  tmp___2 = hash_state_packed_size(h2_type);
#line 444
  ptr += tmp___2;
#line 447
  *((cmph_uint32 *)ptr) = data->m;
#line 448
  ptr += sizeof(data->m);
#line 451
  *((cmph_uint32 *)ptr) = data->b;
#line 452
  ptr += sizeof(data->b);
#line 455
  *((cmph_uint64 *)ptr) = (cmph_uint64 )data->p1;
#line 456
  ptr += sizeof(data->p1);
#line 459
  *((cmph_uint64 *)ptr) = (cmph_uint64 )data->p2;
#line 460
  ptr += sizeof(data->p2);
#line 463
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint32 ) * (unsigned long )data->b);
  }
#line 464
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_uint32 fch_packed_size(cmph_t *mphf ) 
{ 
  fch_data_t *data ;
  CMPH_HASH h1_type ;
  CMPH_HASH tmp ;
  CMPH_HASH h2_type ;
  CMPH_HASH tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;

  {
  {
#line 473
  data = (fch_data_t *)mphf->data;
#line 474
  tmp = hash_get_type(data->h1);
#line 474
  h1_type = tmp;
#line 475
  tmp___0 = hash_get_type(data->h2);
#line 475
  h2_type = tmp___0;
#line 477
  tmp___1 = hash_state_packed_size(h1_type);
#line 477
  tmp___2 = hash_state_packed_size(h2_type);
  }
#line 477
  return ((cmph_uint32 )(((((sizeof(CMPH_ALGO ) + (unsigned long )tmp___1) + (unsigned long )tmp___2) + 4UL * sizeof(cmph_uint32 )) + 2UL * sizeof(double )) + sizeof(cmph_uint32 ) * (unsigned long )data->b));
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
cmph_uint32 fch_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint8 *h1_ptr ;
  register CMPH_HASH h1_type ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp ;
  register CMPH_HASH h2_type ;
  register cmph_uint32 *g_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 m ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint32 b ;
  cmph_uint32 *tmp___2 ;
  register double p1 ;
  register double p2 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 491
  h1_ptr = (cmph_uint8 *)packed_mphf;
#line 492
  h1_type = (CMPH_HASH )*((cmph_uint32 *)h1_ptr);
#line 493
  h1_ptr += 4;
#line 495
  tmp = hash_state_packed_size(h1_type);
#line 495
  h2_ptr = h1_ptr + tmp;
#line 496
  h2_type = (CMPH_HASH )*((cmph_uint32 *)h2_ptr);
#line 497
  h2_ptr += 4;
#line 499
  tmp___0 = hash_state_packed_size(h2_type);
#line 499
  g_ptr = (cmph_uint32 *)(h2_ptr + tmp___0);
#line 501
  tmp___1 = g_ptr;
#line 501
  g_ptr ++;
#line 501
  m = *tmp___1;
#line 503
  tmp___2 = g_ptr;
#line 503
  g_ptr ++;
#line 503
  b = *tmp___2;
#line 505
  p1 = (double )*((cmph_uint64 *)g_ptr);
#line 506
  g_ptr += 2;
#line 508
  p2 = (double )*((cmph_uint64 *)g_ptr);
#line 509
  g_ptr += 2;
#line 511
  tmp___3 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 511
  h1 = tmp___3 % m;
#line 512
  tmp___4 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 512
  h2 = tmp___4 % m;
#line 514
  h1 = mixh10h11h12(b, p1, p2, h1);
  }
#line 515
  return ((h2 + *(g_ptr + h1)) % m);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___1[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
cmph_uint8 chd_ph_bucket_insert(chd_ph_bucket_t *buckets , chd_ph_map_item_t *map_items ,
                                chd_ph_item_t *items , cmph_uint32 nbuckets , cmph_uint32 item_idx ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *tmp_item ;
  register chd_ph_map_item_t *tmp_map_item ;
  register chd_ph_bucket_t *bucket ;

  {
#line 83
  i = (cmph_uint32 )0;
#line 85
  tmp_map_item = map_items + item_idx;
#line 86
  bucket = buckets + tmp_map_item->bucket_num;
#line 87
  tmp_item = items + bucket->items_list;
#line 89
  i = (cmph_uint32 )0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < bucket->__annonCompField15.size)) {
#line 89
      goto while_break;
    }
#line 91
    if (tmp_item->f == tmp_map_item->f) {
#line 91
      if (tmp_item->h == tmp_map_item->h) {
#line 94
        return ((cmph_uint8 )0);
      }
    }
#line 96
    tmp_item ++;
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  tmp_item->f = tmp_map_item->f;
#line 99
  tmp_item->h = tmp_map_item->h;
#line 100
  (bucket->__annonCompField15.size) ++;
#line 101
  return ((cmph_uint8 )1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping(cmph_config_t *mph , chd_ph_bucket_t *buckets , chd_ph_item_t *items ,
                                 cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                             cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                             cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                   chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                   chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                   cmph_uint32 *disp_table ) ;
#line 117 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static double chd_ph_space_lower_bound(cmph_uint32 _n , cmph_uint32 _r ) 
{ 
  double r ;
  double n ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 119
  r = (double )_r;
#line 119
  n = (double )_n;
#line 120
  tmp = log((double )1 - n / r);
#line 120
  tmp___0 = log((double )2);
  }
#line 120
  return (((double )1 + ((r / n - 1.0) + 1.0 / (2.0 * n)) * tmp) / tmp___0);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
chd_ph_config_data_t *chd_ph_config_new(void) 
{ 
  chd_ph_config_data_t *chd_ph ;
  void *tmp ;

  {
  {
#line 147
  tmp = malloc(sizeof(chd_ph_config_data_t ));
#line 147
  chd_ph = (chd_ph_config_data_t *)tmp;
  }
#line 148
  if (! chd_ph) {
    {
#line 148
    __assert_fail("chd_ph", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  148U, "chd_ph_config_new");
    }
  }
  {
#line 149
  memset((void *)chd_ph, 0, sizeof(chd_ph_config_data_t ));
#line 151
  chd_ph->hashfunc = (CMPH_HASH )0;
#line 152
  chd_ph->cs = (compressed_seq_t *)((void *)0);
#line 153
  chd_ph->nbuckets = (cmph_uint32 )0;
#line 154
  chd_ph->n = (cmph_uint32 )0;
#line 155
  chd_ph->hl = (hash_state_t *)((void *)0);
#line 157
  chd_ph->m = (cmph_uint32 )0;
#line 158
  chd_ph->use_h = (cmph_uint8 )1;
#line 159
  chd_ph->keys_per_bin = (cmph_uint32 )1;
#line 160
  chd_ph->keys_per_bucket = (cmph_uint32 )4;
#line 161
  chd_ph->occup_table = (cmph_uint8 *)0;
  }
#line 163
  return (chd_ph);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_config_destroy(cmph_config_t *mph ) 
{ 
  chd_ph_config_data_t *data ;

  {
#line 168
  data = (chd_ph_config_data_t *)mph->data;
#line 170
  if (data->occup_table) {
    {
#line 172
    free((void *)data->occup_table);
#line 173
    data->occup_table = (cmph_uint8 *)((void *)0);
    }
  }
  {
#line 175
  free((void *)data);
  }
#line 176
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  chd_ph_config_data_t *chd_ph ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 181
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 182
  hashptr = hashfuncs;
#line 183
  i = (cmph_uint32 )0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! ((unsigned int )*hashptr != 1U)) {
#line 184
      goto while_break;
    }
#line 186
    if (i >= 1U) {
#line 186
      goto while_break;
    }
#line 187
    chd_ph->hashfunc = *hashptr;
#line 188
    i ++;
#line 188
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_config_set_b(cmph_config_t *mph , cmph_uint32 keys_per_bucket ) 
{ 
  chd_ph_config_data_t *chd_ph ;

  {
#line 195
  if (! mph) {
    {
#line 195
    __assert_fail("mph", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  195U, "chd_ph_config_set_b");
    }
  }
#line 196
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 197
  if (keys_per_bucket < 1U) {
#line 199
    keys_per_bucket = (cmph_uint32 )4;
  } else
#line 197
  if (keys_per_bucket >= 15U) {
#line 199
    keys_per_bucket = (cmph_uint32 )4;
  }
#line 201
  chd_ph->keys_per_bucket = keys_per_bucket;
#line 202
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_config_set_keys_per_bin(cmph_config_t *mph , cmph_uint32 keys_per_bin ) 
{ 
  chd_ph_config_data_t *chd_ph ;

  {
#line 207
  if (! mph) {
    {
#line 207
    __assert_fail("mph", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  207U, "chd_ph_config_set_keys_per_bin");
    }
  }
#line 208
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 209
  if (keys_per_bin <= 1U) {
#line 211
    keys_per_bin = (cmph_uint32 )1;
  } else
#line 209
  if (keys_per_bin >= 128U) {
#line 211
    keys_per_bin = (cmph_uint32 )1;
  }
#line 213
  chd_ph->keys_per_bin = keys_per_bin;
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping(cmph_config_t *mph , chd_ph_bucket_t *buckets , chd_ph_item_t *items ,
                                 cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                             cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                             cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                              cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                              cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___1[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___1[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___1[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                        chd_ph_item_t *items , cmph_uint32 max_probes ,
                                        cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                        cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                             size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                          chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                          chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                          cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                         i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                          chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                          chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                          cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe(chd_ph, buckets, items, probe0_num, probe1_num, curr_bucket,
                                 i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                   chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                   chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                   cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2(chd_ph, buckets, items, max_bucket_size, sorted_lists, max_probes,
                         disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
cmph_t *chd_ph_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  chd_ph_data_t *chd_phf ;
  chd_ph_config_data_t *chd_ph ;
  register double load_factor ;
  register cmph_uint8 searching_success ;
  register cmph_uint32 max_probes ;
  register cmph_uint32 iterations ;
  chd_ph_bucket_t *buckets ;
  chd_ph_item_t *items ;
  register cmph_uint8 failure ;
  cmph_uint32 max_bucket_size ;
  chd_ph_sorted_list_t *sorted_lists ;
  cmph_uint32 *disp_table ;
  register double space_lower_bound ;
  cmph_uint8 tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 624
  mphf = (cmph_t *)((void *)0);
#line 625
  chd_phf = (chd_ph_data_t *)((void *)0);
#line 626
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 628
  load_factor = c;
#line 629
  searching_success = (cmph_uint8 )0;
#line 630
  max_probes = (cmph_uint32 )(1 << 20);
#line 631
  iterations = (cmph_uint32 )100;
#line 632
  buckets = (chd_ph_bucket_t *)((void *)0);
#line 633
  items = (chd_ph_item_t *)((void *)0);
#line 634
  failure = (cmph_uint8 )0;
#line 635
  max_bucket_size = (cmph_uint32 )0;
#line 636
  sorted_lists = (chd_ph_sorted_list_t *)((void *)0);
#line 637
  disp_table = (cmph_uint32 *)((void *)0);
#line 638
  space_lower_bound = (double )0;
#line 646
  chd_ph->m = (mph->key_source)->nkeys;
#line 649
  chd_ph->nbuckets = chd_ph->m / chd_ph->keys_per_bucket + 1U;
#line 652
  if (load_factor < 0.5) {
#line 654
    load_factor = 0.5;
  }
#line 657
  if (load_factor >= 0.99) {
#line 659
    load_factor = 0.99;
  }
#line 664
  chd_ph->n = (cmph_uint32 )((double )chd_ph->m / ((double )chd_ph->keys_per_bin * load_factor)) + 1U;
#line 667
  if (chd_ph->n % 2U == 0U) {
#line 667
    (chd_ph->n) ++;
  }
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 670
    tmp = check_primality((cmph_uint64 )chd_ph->n);
    }
#line 670
    if ((int )tmp == 1) {
#line 671
      goto while_break;
    }
#line 672
    chd_ph->n += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  if (chd_ph->keys_per_bin == 1U) {
    {
#line 679
    space_lower_bound = chd_ph_space_lower_bound(chd_ph->m, chd_ph->n);
    }
  }
#line 682
  if (mph->verbosity) {
    {
#line 684
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"space lower bound is %.3f bits per key\n",
            space_lower_bound);
    }
  }
  {
#line 688
  buckets = chd_ph_bucket_new(chd_ph->nbuckets);
#line 689
  tmp___0 = calloc((size_t )chd_ph->m, sizeof(chd_ph_item_t ));
#line 689
  items = (chd_ph_item_t *)tmp___0;
#line 691
  tmp___1 = log((double )chd_ph->m);
#line 691
  tmp___2 = log((double )2);
#line 691
  max_probes = (cmph_uint32 )(((tmp___1 / tmp___2) / (double )20) * (double )max_probes);
  }
#line 693
  if (chd_ph->keys_per_bin == 1U) {
    {
#line 694
    tmp___3 = calloc((size_t )((chd_ph->n + 31U) / 32U), sizeof(cmph_uint32 ));
#line 694
    chd_ph->occup_table = (cmph_uint8 *)tmp___3;
    }
  } else {
    {
#line 696
    tmp___4 = calloc((size_t )chd_ph->n, sizeof(cmph_uint8 ));
#line 696
    chd_ph->occup_table = (cmph_uint8 *)tmp___4;
    }
  }
  {
#line 698
  tmp___5 = calloc((size_t )chd_ph->nbuckets, sizeof(cmph_uint32 ));
#line 698
  disp_table = (cmph_uint32 *)tmp___5;
  }
  {
#line 702
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 704
    iterations --;
#line 705
    if (mph->verbosity) {
      {
#line 707
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting mapping step for mph creation of %u keys with %u bins\n",
              chd_ph->m, chd_ph->n);
      }
    }
    {
#line 710
    tmp___6 = chd_ph_mapping(mph, buckets, items, & max_bucket_size);
    }
#line 710
    if (! tmp___6) {
#line 712
      if (mph->verbosity) {
        {
#line 714
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failure in mapping step\n");
        }
      }
#line 716
      failure = (cmph_uint8 )1;
#line 717
      goto cleanup;
    }
#line 720
    if (mph->verbosity) {
      {
#line 722
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting ordering step\n");
      }
    }
#line 724
    if (sorted_lists) {
      {
#line 726
      free((void *)sorted_lists);
      }
    }
    {
#line 729
    sorted_lists = chd_ph_ordering(& buckets, & items, chd_ph->nbuckets, chd_ph->m,
                                   max_bucket_size);
    }
#line 731
    if (mph->verbosity) {
      {
#line 733
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting searching step\n");
      }
    }
    {
#line 736
    searching_success = chd_ph_searching(chd_ph, buckets, items, max_bucket_size,
                                         sorted_lists, max_probes, disp_table);
    }
#line 737
    if (searching_success) {
#line 737
      goto while_break___0;
    }
#line 740
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 741
      memset((void *)chd_ph->occup_table, 0, (size_t )chd_ph->n);
      }
    } else {
      {
#line 743
      memset((void *)chd_ph->occup_table, 0, (unsigned long )((chd_ph->n + 31U) / 32U) * sizeof(cmph_uint32 ));
      }
    }
#line 744
    if (iterations == 0U) {
#line 747
      if (mph->verbosity) {
        {
#line 749
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failure because the max trials was exceeded\n");
        }
      }
#line 751
      failure = (cmph_uint8 )1;
#line 752
      goto cleanup;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 768
  if (mph->verbosity) {
    {
#line 770
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting compressing step\n");
    }
  }
#line 773
  if (chd_ph->cs) {
    {
#line 775
    free((void *)chd_ph->cs);
    }
  }
  {
#line 777
  tmp___7 = calloc((size_t )1, sizeof(compressed_seq_t ));
#line 777
  chd_ph->cs = (compressed_seq_t *)tmp___7;
#line 778
  compressed_seq_init(chd_ph->cs);
#line 779
  compressed_seq_generate(chd_ph->cs, disp_table, chd_ph->nbuckets);
  }
  cleanup: 
  {
#line 788
  chd_ph_bucket_destroy(buckets);
#line 789
  free((void *)items);
#line 790
  free((void *)sorted_lists);
#line 791
  free((void *)disp_table);
  }
#line 792
  if (failure) {
#line 794
    if (chd_ph->hl) {
      {
#line 796
      hash_state_destroy(chd_ph->hl);
      }
    }
#line 798
    chd_ph->hl = (hash_state_t *)((void *)0);
#line 799
    return ((cmph_t *)((void *)0));
  }
  {
#line 802
  tmp___8 = malloc(sizeof(cmph_t ));
#line 802
  mphf = (cmph_t *)tmp___8;
#line 803
  mphf->algo = mph->algo;
#line 804
  tmp___9 = malloc(sizeof(chd_ph_data_t ));
#line 804
  chd_phf = (chd_ph_data_t *)tmp___9;
#line 806
  chd_phf->cs = chd_ph->cs;
#line 807
  chd_ph->cs = (compressed_seq_t *)((void *)0);
#line 808
  chd_phf->hl = chd_ph->hl;
#line 809
  chd_ph->hl = (hash_state_t *)((void *)0);
#line 810
  chd_phf->n = chd_ph->n;
#line 811
  chd_phf->nbuckets = chd_ph->nbuckets;
#line 813
  mphf->data = (void *)chd_phf;
#line 814
  mphf->size = chd_ph->n;
  }
#line 817
  if (mph->verbosity) {
    {
#line 819
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 828
  return (mphf);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_load(FILE *fd , cmph_t *mphf ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  chd_ph_data_t *chd_ph ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 835
  buf = (char *)((void *)0);
#line 838
  tmp = malloc(sizeof(chd_ph_data_t ));
#line 838
  chd_ph = (chd_ph_data_t *)tmp;
#line 841
  mphf->data = (void *)chd_ph;
#line 843
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)fd);
#line 845
  tmp___0 = malloc((size_t )buflen);
#line 845
  buf = (char *)tmp___0;
#line 846
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)fd);
#line 847
  chd_ph->hl = hash_state_load((char const   *)buf, buflen);
#line 848
  free((void *)buf);
#line 850
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)fd);
#line 852
  tmp___1 = malloc((size_t )buflen);
#line 852
  buf = (char *)tmp___1;
#line 853
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)fd);
#line 854
  tmp___2 = calloc((size_t )1, sizeof(compressed_seq_t ));
#line 854
  chd_ph->cs = (compressed_seq_t *)tmp___2;
#line 855
  compressed_seq_load(chd_ph->cs, (char const   *)buf, buflen);
#line 856
  free((void *)buf);
#line 860
  nbytes = fread((void */* __restrict  */)(& chd_ph->n), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)fd);
#line 861
  nbytes = fread((void */* __restrict  */)(& chd_ph->nbuckets), sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 862
  return;
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
int chd_ph_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  chd_ph_data_t *data ;

  {
  {
#line 866
  buf = (char *)((void *)0);
#line 869
  data = (chd_ph_data_t *)mphf->data;
#line 871
  __cmph_dump(mphf, fd);
#line 873
  hash_state_dump(data->hl, & buf, & buflen);
#line 875
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 876
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 877
  free((void *)buf);
#line 879
  compressed_seq_dump(data->cs, & buf, & buflen);
#line 881
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 882
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 883
  free((void *)buf);
#line 886
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 887
  nbytes = fwrite((void const   */* __restrict  */)(& data->nbuckets), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 888
  return (1);
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_destroy(cmph_t *mphf ) 
{ 
  chd_ph_data_t *data ;

  {
  {
#line 893
  data = (chd_ph_data_t *)mphf->data;
#line 894
  compressed_seq_destroy(data->cs);
#line 895
  free((void *)data->cs);
#line 896
  hash_state_destroy(data->hl);
#line 897
  free((void *)data);
#line 898
  free((void *)mphf);
  }
#line 900
  return;
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
cmph_uint32 chd_ph_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register chd_ph_data_t *chd_ph ;
  cmph_uint32 hl[3] ;
  register cmph_uint32 disp ;
  register cmph_uint32 position ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 f ;
  register cmph_uint32 g ;
  register cmph_uint32 h ;

  {
  {
#line 904
  chd_ph = (chd_ph_data_t *)mphf->data;
#line 909
  hash_vector(chd_ph->hl, key, keylen, hl);
#line 910
  g = hl[0] % chd_ph->nbuckets;
#line 911
  f = hl[1] % chd_ph->n;
#line 912
  h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 914
  disp = compressed_seq_query(chd_ph->cs, g);
#line 915
  probe0_num = disp % chd_ph->n;
#line 916
  probe1_num = disp / chd_ph->n;
#line 917
  position = (cmph_uint32 )((((cmph_uint64 )f + (cmph_uint64 )h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
  }
#line 918
  return (position);
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
void chd_ph_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  chd_ph_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 923
  data = (chd_ph_data_t *)mphf->data;
#line 924
  ptr = (cmph_uint8 *)packed_mphf;
#line 927
  tmp = hash_get_type(data->hl);
#line 927
  hl_type = tmp;
#line 928
  *((cmph_uint32 *)ptr) = (cmph_uint32 )hl_type;
#line 929
  ptr += sizeof(cmph_uint32 );
#line 932
  hash_state_pack(data->hl, (void *)ptr);
#line 933
  tmp___0 = hash_state_packed_size(hl_type);
#line 933
  ptr += tmp___0;
#line 936
  *((cmph_uint32 *)ptr) = data->n;
#line 937
  ptr += sizeof(data->n);
#line 940
  *((cmph_uint32 *)ptr) = data->nbuckets;
#line 941
  ptr += sizeof(data->nbuckets);
#line 944
  compressed_seq_pack(data->cs, (void *)ptr);
  }
#line 947
  return;
}
}
#line 949 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
cmph_uint32 chd_ph_packed_size(cmph_t *mphf ) 
{ 
  register chd_ph_data_t *data ;
  register CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  register cmph_uint32 hash_state_pack_size ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 cs_pack_size ;
  cmph_uint32 tmp___1 ;

  {
  {
#line 951
  data = (chd_ph_data_t *)mphf->data;
#line 952
  tmp = hash_get_type(data->hl);
#line 952
  hl_type = tmp;
#line 953
  tmp___0 = hash_state_packed_size(hl_type);
#line 953
  hash_state_pack_size = tmp___0;
#line 954
  tmp___1 = compressed_seq_packed_size(data->cs);
#line 954
  cs_pack_size = tmp___1;
  }
#line 956
  return ((cmph_uint32 )(((sizeof(CMPH_ALGO ) + (unsigned long )hash_state_pack_size) + (unsigned long )cs_pack_size) + 3UL * sizeof(cmph_uint32 )));
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
cmph_uint32 chd_ph_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register CMPH_HASH hl_type ;
  register cmph_uint8 *hl_ptr ;
  register cmph_uint32 *ptr ;
  cmph_uint32 tmp ;
  register cmph_uint32 n ;
  cmph_uint32 *tmp___0 ;
  register cmph_uint32 nbuckets ;
  cmph_uint32 *tmp___1 ;
  cmph_uint32 hl[3] ;
  register cmph_uint32 disp ;
  register cmph_uint32 position ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 f ;
  register cmph_uint32 g ;
  register cmph_uint32 h ;

  {
  {
#line 962
  hl_type = (CMPH_HASH )*((cmph_uint32 *)packed_mphf);
#line 963
  hl_ptr = (cmph_uint8 *)packed_mphf + 4;
#line 965
  tmp = hash_state_packed_size(hl_type);
#line 965
  ptr = (cmph_uint32 *)(hl_ptr + tmp);
#line 966
  tmp___0 = ptr;
#line 966
  ptr ++;
#line 966
  n = *tmp___0;
#line 967
  tmp___1 = ptr;
#line 967
  ptr ++;
#line 967
  nbuckets = *tmp___1;
#line 974
  hash_vector_packed((void *)hl_ptr, hl_type, key, keylen, hl);
#line 976
  g = hl[0] % nbuckets;
#line 977
  f = hl[1] % n;
#line 978
  h = hl[2] % (n - 1U) + 1U;
#line 980
  disp = compressed_seq_query_packed((void *)ptr, g);
#line 981
  probe0_num = disp % n;
#line 982
  probe1_num = disp / n;
#line 983
  position = (cmph_uint32 )((((cmph_uint64 )f + (cmph_uint64 )h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )n);
  }
#line 984
  return (position);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_types.h"
char const   *cmph_hash_names[2] ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.h"
hash_state_t *hash_state_copy(hash_state_t *src_state ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
char const   *cmph_hash_names[2]  = {      "jenkins",      (char const   *)((void *)0)};
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
hash_state_t *hash_state_new(CMPH_HASH hashfunc , cmph_uint32 hashsize ) 
{ 
  hash_state_t *state ;
  jenkins_state_t *tmp ;

  {
#line 14
  state = (hash_state_t *)((void *)0);
  {
#line 17
  if ((unsigned int )hashfunc == 0U) {
#line 17
    goto case_0;
  }
#line 22
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 19
  tmp = jenkins_state_new(hashsize);
#line 19
  state = (hash_state_t *)tmp;
  }
#line 21
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 23
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                23U, "hash_state_new");
  }
  switch_break: /* CIL Label */ ;
  }
#line 25
  state->hashfunc = hashfunc;
#line 26
  return (state);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
cmph_uint32 hash(hash_state_t *state , char const   *key , cmph_uint32 keylen ) 
{ 
  cmph_uint32 tmp ;

  {
  {
#line 32
  if ((unsigned int )state->hashfunc == 0U) {
#line 32
    goto case_0;
  }
#line 34
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 33
  tmp = jenkins_hash((jenkins_state_t *)state, key, keylen);
  }
#line 33
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 35
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                35U, "hash");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 37
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                37U, "hash");
  }
#line 38
  return ((cmph_uint32 )0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
void hash_vector(hash_state_t *state , char const   *key , cmph_uint32 keylen , cmph_uint32 *hashes ) 
{ 


  {
  {
#line 45
  if ((unsigned int )state->hashfunc == 0U) {
#line 45
    goto case_0;
  }
#line 48
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 46
  jenkins_hash_vector_((jenkins_state_t *)state, key, keylen, hashes);
  }
#line 47
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 49
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                49U, "hash_vector");
  }
  switch_break: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
void hash_state_dump(hash_state_t *state , char **buf , cmph_uint32 *buflen ) 
{ 
  char *algobuf ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 60
  if ((unsigned int )state->hashfunc == 0U) {
#line 60
    goto case_0;
  }
#line 64
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 61
  jenkins_state_dump((jenkins_state_t *)state, & algobuf, buflen);
  }
#line 62
  if (*buflen == 4294967295U) {
#line 62
    return;
  }
#line 63
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 65
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                65U, "hash_state_dump");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp = strlen(cmph_hash_names[state->hashfunc]);
#line 67
  tmp___0 = malloc((tmp + 1UL) + (size_t )*buflen);
#line 67
  *buf = (char *)tmp___0;
#line 68
  tmp___1 = strlen(cmph_hash_names[state->hashfunc]);
#line 68
  memcpy((void */* __restrict  */)*buf, (void const   */* __restrict  */)cmph_hash_names[state->hashfunc],
         tmp___1 + 1UL);
#line 70
  len = (size_t )*buflen;
#line 71
  tmp___2 = strlen(cmph_hash_names[state->hashfunc]);
#line 71
  memcpy((void */* __restrict  */)((*buf + tmp___2) + 1), (void const   */* __restrict  */)algobuf,
         len);
#line 72
  tmp___3 = strlen(cmph_hash_names[state->hashfunc]);
#line 72
  *buflen = ((cmph_uint32 )tmp___3 + 1U) + *buflen;
#line 73
  free((void *)algobuf);
  }
#line 74
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
hash_state_t *hash_state_copy(hash_state_t *src_state ) 
{ 
  hash_state_t *dest_state ;
  jenkins_state_t *tmp ;

  {
#line 79
  dest_state = (hash_state_t *)((void *)0);
  {
#line 82
  if ((unsigned int )src_state->hashfunc == 0U) {
#line 82
    goto case_0;
  }
#line 85
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 83
  tmp = jenkins_state_copy((jenkins_state_t *)src_state);
#line 83
  dest_state = (hash_state_t *)tmp;
  }
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 86
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                86U, "hash_state_copy");
  }
  switch_break: /* CIL Label */ ;
  }
#line 88
  dest_state->hashfunc = src_state->hashfunc;
#line 89
  return (dest_state);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
hash_state_t *hash_state_load(char const   *buf , cmph_uint32 buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 offset ;
  CMPH_HASH hashfunc ;
  int tmp ;
  size_t tmp___0 ;
  jenkins_state_t *tmp___1 ;

  {
#line 96
  hashfunc = (CMPH_HASH )1;
#line 97
  i = (cmph_uint32 )0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 1U)) {
#line 97
      goto while_break;
    }
    {
#line 99
    tmp = strcmp(buf, cmph_hash_names[i]);
    }
#line 99
    if (tmp == 0) {
#line 101
      hashfunc = (CMPH_HASH )i;
#line 102
      goto while_break;
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if ((unsigned int )hashfunc == 1U) {
#line 105
    return ((hash_state_t *)((void *)0));
  }
  {
#line 106
  tmp___0 = strlen(cmph_hash_names[hashfunc]);
#line 106
  offset = (cmph_uint32 )tmp___0 + 1U;
  }
  {
#line 109
  if ((unsigned int )hashfunc == 0U) {
#line 109
    goto case_0;
  }
#line 111
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 110
  tmp___1 = jenkins_state_load(buf + offset, buflen - offset);
  }
#line 110
  return ((hash_state_t *)tmp___1);
  switch_default: /* CIL Label */ 
#line 112
  return ((hash_state_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 114
  return ((hash_state_t *)((void *)0));
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
void hash_state_destroy(hash_state_t *state ) 
{ 


  {
  {
#line 120
  if ((unsigned int )state->hashfunc == 0U) {
#line 120
    goto case_0;
  }
#line 123
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 121
  jenkins_state_destroy((jenkins_state_t *)state);
  }
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 124
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                124U, "hash_state_destroy");
  }
  switch_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
void hash_state_pack(hash_state_t *state , void *hash_packed___0 ) 
{ 


  {
  {
#line 141
  if ((unsigned int )state->hashfunc == 0U) {
#line 141
    goto case_0;
  }
#line 145
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 143
  jenkins_state_pack((jenkins_state_t *)state, hash_packed___0);
  }
#line 144
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 146
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                146U, "hash_state_pack");
  }
  switch_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
cmph_uint32 hash_state_packed_size(CMPH_HASH hashfunc ) 
{ 
  cmph_uint32 size ;
  cmph_uint32 tmp ;

  {
#line 158
  size = (cmph_uint32 )0;
  {
#line 161
  if ((unsigned int )hashfunc == 0U) {
#line 161
    goto case_0;
  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 162
  tmp = jenkins_state_packed_size();
#line 162
  size += tmp;
  }
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 165
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                165U, "hash_state_packed_size");
  }
  switch_break: /* CIL Label */ ;
  }
#line 167
  return (size);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
cmph_uint32 hash_packed(void *hash_packed___0 , CMPH_HASH hashfunc , char const   *k ,
                        cmph_uint32 keylen ) 
{ 
  cmph_uint32 tmp ;

  {
  {
#line 181
  if ((unsigned int )hashfunc == 0U) {
#line 181
    goto case_0;
  }
#line 183
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 182
  tmp = jenkins_hash_packed(hash_packed___0, k, keylen);
  }
#line 182
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 184
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                184U, "hash_packed");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 186
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                186U, "hash_packed");
  }
#line 187
  return ((cmph_uint32 )0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
void hash_vector_packed(void *hash_packed___0 , CMPH_HASH hashfunc , char const   *k ,
                        cmph_uint32 keylen , cmph_uint32 *hashes ) 
{ 


  {
  {
#line 200
  if ((unsigned int )hashfunc == 0U) {
#line 200
    goto case_0;
  }
#line 203
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 201
  jenkins_hash_vector_packed(hash_packed___0, k, keylen, hashes);
  }
#line 202
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 204
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c",
                204U, "hash_vector_packed");
  }
  switch_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/hash.c"
CMPH_HASH hash_get_type(hash_state_t *state ) 
{ 


  {
#line 215
  return (state->hashfunc);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___4[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 20 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_uint8 const   bdz_lookup_table[256]  = 
#line 20 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
  {      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )4,      (cmph_uint8 const   )3, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )3,      (cmph_uint8 const   )2, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )2,      (cmph_uint8 const   )1, 
        (cmph_uint8 const   )1,      (cmph_uint8 const   )1,      (cmph_uint8 const   )1,      (cmph_uint8 const   )0};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                         cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                              bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___4[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___4[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___4[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___4[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___4[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___4[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___4[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___4[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___0(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
bdz_config_data_t *bdz_config_new(void) 
{ 
  bdz_config_data_t *bdz ;
  void *tmp ;

  {
  {
#line 222
  tmp = malloc(sizeof(bdz_config_data_t ));
#line 222
  bdz = (bdz_config_data_t *)tmp;
  }
#line 223
  if (! bdz) {
    {
#line 223
    __assert_fail("bdz", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c",
                  223U, "bdz_config_new");
    }
  }
  {
#line 224
  memset((void *)bdz, 0, sizeof(bdz_config_data_t ));
#line 225
  bdz->hashfunc = (CMPH_HASH )0;
#line 226
  bdz->g = (cmph_uint8 *)((void *)0);
#line 227
  bdz->hl = (hash_state_t *)((void *)0);
#line 228
  bdz->k = (cmph_uint32 )0;
#line 229
  bdz->b = (cmph_uint8 )7;
#line 230
  bdz->ranktablesize = (cmph_uint32 )0;
#line 231
  bdz->ranktable = (cmph_uint32 *)((void *)0);
  }
#line 232
  return (bdz);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_config_destroy(cmph_config_t *mph ) 
{ 
  bdz_config_data_t *data ;

  {
  {
#line 237
  data = (bdz_config_data_t *)mph->data;
#line 239
  free((void *)data);
  }
#line 240
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_config_set_b(cmph_config_t *mph , cmph_uint32 b ) 
{ 
  bdz_config_data_t *bdz ;

  {
#line 244
  bdz = (bdz_config_data_t *)mph->data;
#line 245
  if (b <= 2U) {
#line 245
    b = (cmph_uint32 )7;
  } else
#line 245
  if (b > 10U) {
#line 245
    b = (cmph_uint32 )7;
  }
#line 246
  bdz->b = (cmph_uint8 )b;
#line 249
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_config_set_hashfuncs(cmph_config_t *mph , CMPH_HASH *hashfuncs ) 
{ 
  bdz_config_data_t *bdz ;
  CMPH_HASH *hashptr ;
  cmph_uint32 i ;

  {
#line 253
  bdz = (bdz_config_data_t *)mph->data;
#line 254
  hashptr = hashfuncs;
#line 255
  i = (cmph_uint32 )0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned int )*hashptr != 1U)) {
#line 256
      goto while_break;
    }
#line 258
    if (i >= 1U) {
#line 258
      goto while_break;
    }
#line 259
    bdz->hashfunc = *hashptr;
#line 260
    i ++;
#line 260
    hashptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_t *bdz_new(cmph_config_t *mph , double c ) 
{ 
  cmph_t *mphf ;
  bdz_data_t *bdzf ;
  cmph_uint32 iterations ;
  bdz_queue_t edges ;
  bdz_graph3_t graph3 ;
  bdz_config_data_t *bdz ;
  double tmp ;
  double tmp___0 ;
  int ok ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 266
  mphf = (cmph_t *)((void *)0);
#line 267
  bdzf = (bdz_data_t *)((void *)0);
#line 271
  bdz = (bdz_config_data_t *)mph->data;
#line 279
  if (c == (double )0) {
#line 279
    c = 1.23;
  }
  {
#line 281
  bdz->m = (mph->key_source)->nkeys;
#line 282
  tmp = ceil((c * (double )(mph->key_source)->nkeys) / (double )3);
#line 282
  bdz->r = (cmph_uint32 )tmp;
  }
#line 283
  if (bdz->r % 2U == 0U) {
#line 283
    (bdz->r) ++;
  }
  {
#line 284
  bdz->n = 3U * bdz->r;
#line 286
  bdz->k = 1U << (int )bdz->b;
#line 289
  tmp___0 = ceil((double )bdz->n / (double )bdz->k);
#line 289
  bdz->ranktablesize = (cmph_uint32 )tmp___0;
#line 293
  bdz_alloc_graph3(& graph3, bdz->m, bdz->n);
#line 294
  bdz_alloc_queue(& edges, bdz->m);
#line 300
  iterations = (cmph_uint32 )1000;
  }
#line 301
  if (mph->verbosity) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering mapping step for mph creation of %u keys with graph sized %u\n",
            bdz->m, bdz->n);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 309
    bdz->hl = hash_state_new(bdz->hashfunc, (cmph_uint32 )15);
#line 311
    ok = bdz_mapping(mph, & graph3, edges);
    }
#line 313
    if (! ok) {
      {
#line 315
      iterations --;
#line 316
      hash_state_destroy(bdz->hl);
#line 317
      bdz->hl = (hash_state_t *)((void *)0);
      }
#line 319
      if (mph->verbosity) {
        {
#line 321
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"acyclic graph creation failure - %u iterations remaining\n",
                iterations);
        }
      }
#line 323
      if (iterations == 0U) {
#line 323
        goto while_break;
      }
    } else {
#line 325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  if (iterations == 0U) {
    {
#line 330
    bdz_free_queue(& edges);
#line 331
    bdz_free_graph3(& graph3);
    }
#line 332
    return ((cmph_t *)((void *)0));
  }
  {
#line 334
  bdz_partial_free_graph3(& graph3);
  }
#line 336
  if (mph->verbosity) {
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering assigning step for mph creation of %u keys with graph sized %u\n",
            bdz->m, bdz->n);
    }
  }
  {
#line 340
  assigning___0(bdz, & graph3, edges);
#line 342
  bdz_free_queue(& edges);
#line 343
  bdz_free_graph3(& graph3);
  }
#line 344
  if (mph->verbosity) {
    {
#line 346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering ranking step for mph creation of %u keys with graph sized %u\n",
            bdz->m, bdz->n);
    }
  }
  {
#line 348
  ranking(bdz);
#line 352
  tmp___1 = malloc(sizeof(cmph_t ));
#line 352
  mphf = (cmph_t *)tmp___1;
#line 353
  mphf->algo = mph->algo;
#line 354
  tmp___2 = malloc(sizeof(bdz_data_t ));
#line 354
  bdzf = (bdz_data_t *)tmp___2;
#line 355
  bdzf->g = bdz->g;
#line 356
  bdz->g = (cmph_uint8 *)((void *)0);
#line 357
  bdzf->hl = bdz->hl;
#line 358
  bdz->hl = (hash_state_t *)((void *)0);
#line 359
  bdzf->ranktable = bdz->ranktable;
#line 360
  bdz->ranktable = (cmph_uint32 *)((void *)0);
#line 361
  bdzf->ranktablesize = bdz->ranktablesize;
#line 362
  bdzf->k = bdz->k;
#line 363
  bdzf->b = bdz->b;
#line 364
  bdzf->n = bdz->n;
#line 365
  bdzf->m = bdz->m;
#line 366
  bdzf->r = bdz->r;
#line 367
  mphf->data = (void *)bdzf;
#line 368
  mphf->size = bdz->m;
  }
#line 371
  if (mph->verbosity) {
    {
#line 373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully generated minimal perfect hash function\n");
    }
  }
#line 384
  return (mphf);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___0(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___4[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___4[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___4[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___4[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___4[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___4[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___4[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___4[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___4[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___4[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___4[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
int bdz_dump(cmph_t *mphf , FILE *fd ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  register size_t nbytes ;
  bdz_data_t *data ;
  cmph_uint32 sizeg ;
  double tmp ;

  {
  {
#line 487
  buf = (char *)((void *)0);
#line 490
  data = (bdz_data_t *)mphf->data;
#line 491
  __cmph_dump(mphf, fd);
#line 493
  hash_state_dump(data->hl, & buf, & buflen);
#line 495
  nbytes = fwrite((void const   */* __restrict  */)(& buflen), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 496
  nbytes = fwrite((void const   */* __restrict  */)buf, (size_t )buflen, (size_t )1,
                  (FILE */* __restrict  */)fd);
#line 497
  free((void *)buf);
#line 499
  nbytes = fwrite((void const   */* __restrict  */)(& data->n), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 500
  nbytes = fwrite((void const   */* __restrict  */)(& data->m), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 501
  nbytes = fwrite((void const   */* __restrict  */)(& data->r), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 503
  tmp = ceil((double )data->n / 4.0);
#line 503
  sizeg = (cmph_uint32 )tmp;
#line 504
  nbytes = fwrite((void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )sizeg,
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 506
  nbytes = fwrite((void const   */* __restrict  */)(& data->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 507
  nbytes = fwrite((void const   */* __restrict  */)(& data->b), sizeof(cmph_uint8 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 508
  nbytes = fwrite((void const   */* __restrict  */)(& data->ranktablesize), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 510
  nbytes = fwrite((void const   */* __restrict  */)data->ranktable, sizeof(cmph_uint32 ) * (unsigned long )data->ranktablesize,
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 517
  return (1);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_load(FILE *f , cmph_t *mphf ) 
{ 
  char *buf ;
  cmph_uint32 buflen ;
  cmph_uint32 sizeg ;
  register size_t nbytes ;
  bdz_data_t *bdz ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 522
  buf = (char *)((void *)0);
#line 525
  tmp = malloc(sizeof(bdz_data_t ));
#line 525
  bdz = (bdz_data_t *)tmp;
#line 528
  mphf->data = (void *)bdz;
#line 530
  nbytes = fread((void */* __restrict  */)(& buflen), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 532
  tmp___0 = malloc((size_t )buflen);
#line 532
  buf = (char *)tmp___0;
#line 533
  nbytes = fread((void */* __restrict  */)buf, (size_t )buflen, (size_t )1, (FILE */* __restrict  */)f);
#line 534
  bdz->hl = hash_state_load((char const   *)buf, buflen);
#line 535
  free((void *)buf);
#line 539
  nbytes = fread((void */* __restrict  */)(& bdz->n), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 540
  nbytes = fread((void */* __restrict  */)(& bdz->m), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 541
  nbytes = fread((void */* __restrict  */)(& bdz->r), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 542
  tmp___1 = ceil((double )bdz->n / 4.0);
#line 542
  sizeg = (cmph_uint32 )tmp___1;
#line 543
  tmp___2 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 543
  bdz->g = (cmph_uint8 *)tmp___2;
#line 544
  nbytes = fread((void */* __restrict  */)bdz->g, (unsigned long )sizeg * sizeof(cmph_uint8 ),
                 (size_t )1, (FILE */* __restrict  */)f);
#line 546
  nbytes = fread((void */* __restrict  */)(& bdz->k), sizeof(cmph_uint32 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 547
  nbytes = fread((void */* __restrict  */)(& bdz->b), sizeof(cmph_uint8 ), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 548
  nbytes = fread((void */* __restrict  */)(& bdz->ranktablesize), sizeof(cmph_uint32 ),
                 (size_t )1, (FILE */* __restrict  */)f);
#line 550
  tmp___3 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 550
  bdz->ranktable = (cmph_uint32 *)tmp___3;
#line 551
  nbytes = fread((void */* __restrict  */)bdz->ranktable, sizeof(cmph_uint32 ) * (unsigned long )bdz->ranktablesize,
                 (size_t )1, (FILE */* __restrict  */)f);
  }
#line 559
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_uint32 bdz_search_ph(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  bdz_data_t *bdz ;
  cmph_uint32 hl[3] ;
  cmph_uint32 vertex ;

  {
  {
#line 565
  bdz = (bdz_data_t *)mphf->data;
#line 567
  hash_vector(bdz->hl, key, keylen, hl);
#line 569
  hl[0] %= bdz->r;
#line 570
  hl[1] = hl[1] % bdz->r + bdz->r;
#line 571
  hl[2] = hl[2] % bdz->r + (bdz->r << 1);
#line 572
  vertex = hl[(((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[0] >> 2)) >> ((hl[0] & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[1] >> 2)) >> ((hl[1] & 3U) << 1U)) & 3U))) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[2] >> 2)) >> ((hl[2] & 3U) << 1U)) & 3U))) % 3];
  }
#line 573
  return (vertex);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) 
{ 
  register cmph_uint32 index___0 ;
  register cmph_uint32 base_rank ;
  register cmph_uint32 beg_idx_v ;
  register cmph_uint32 beg_idx_b ;
  register cmph_uint32 end_idx_b ;
  cmph_uint32 tmp ;

  {
#line 578
  index___0 = vertex >> b;
#line 579
  base_rank = *(ranktable + index___0);
#line 580
  beg_idx_v = index___0 << b;
#line 581
  beg_idx_b = beg_idx_v >> 2;
#line 582
  end_idx_b = vertex >> 2;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (beg_idx_b < end_idx_b)) {
#line 583
      goto while_break;
    }
#line 585
    tmp = beg_idx_b;
#line 585
    beg_idx_b ++;
#line 585
    base_rank += (cmph_uint32 )bdz_lookup_table[*(g + tmp)];
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  beg_idx_v = beg_idx_b << 2;
  {
#line 589
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 589
    if (! (beg_idx_v < vertex)) {
#line 589
      goto while_break___0;
    }
#line 591
    if ((unsigned int )((cmph_uint8 )((unsigned int )((int )*(g + (beg_idx_v >> 2)) >> ((beg_idx_v & 3U) << 1U)) & 3U)) != 3U) {
#line 591
      base_rank ++;
    }
#line 592
    beg_idx_v ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 595
  return (base_rank);
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_uint32 bdz_search(cmph_t *mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint32 vertex ;
  register bdz_data_t *bdz ;
  cmph_uint32 hl[3] ;
  cmph_uint32 tmp ;

  {
  {
#line 601
  bdz = (bdz_data_t *)mphf->data;
#line 603
  hash_vector(bdz->hl, key, keylen, hl);
#line 604
  hl[0] %= bdz->r;
#line 605
  hl[1] = hl[1] % bdz->r + bdz->r;
#line 606
  hl[2] = hl[2] % bdz->r + (bdz->r << 1);
#line 607
  vertex = hl[(((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[0] >> 2)) >> ((hl[0] & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[1] >> 2)) >> ((hl[1] & 3U) << 1U)) & 3U))) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (hl[2] >> 2)) >> ((hl[2] & 3U) << 1U)) & 3U))) % 3];
#line 608
  tmp = rank((cmph_uint32 )bdz->b, bdz->ranktable, bdz->g, vertex);
  }
#line 608
  return (tmp);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_destroy(cmph_t *mphf ) 
{ 
  bdz_data_t *data ;

  {
  {
#line 614
  data = (bdz_data_t *)mphf->data;
#line 615
  free((void *)data->g);
#line 616
  hash_state_destroy(data->hl);
#line 617
  free((void *)data->ranktable);
#line 618
  free((void *)data);
#line 619
  free((void *)mphf);
  }
#line 620
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
void bdz_pack(cmph_t *mphf , void *packed_mphf ) 
{ 
  bdz_data_t *data ;
  cmph_uint8 *ptr ;
  CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint8 *tmp___1 ;
  cmph_uint32 sizeg ;
  double tmp___2 ;

  {
  {
#line 629
  data = (bdz_data_t *)mphf->data;
#line 630
  ptr = (cmph_uint8 *)packed_mphf;
#line 633
  tmp = hash_get_type(data->hl);
#line 633
  hl_type = tmp;
#line 634
  *((cmph_uint32 *)ptr) = (cmph_uint32 )hl_type;
#line 635
  ptr += sizeof(cmph_uint32 );
#line 638
  hash_state_pack(data->hl, (void *)ptr);
#line 639
  tmp___0 = hash_state_packed_size(hl_type);
#line 639
  ptr += tmp___0;
#line 642
  *((cmph_uint32 *)ptr) = data->r;
#line 643
  ptr += sizeof(data->r);
#line 646
  *((cmph_uint32 *)ptr) = data->ranktablesize;
#line 647
  ptr += sizeof(data->ranktablesize);
#line 650
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->ranktable,
         sizeof(cmph_uint32 ) * (unsigned long )data->ranktablesize);
#line 651
  ptr += sizeof(cmph_uint32 ) * (unsigned long )data->ranktablesize;
#line 654
  tmp___1 = ptr;
#line 654
  ptr ++;
#line 654
  *tmp___1 = data->b;
#line 657
  tmp___2 = ceil((double )data->n / 4.0);
#line 657
  sizeg = (cmph_uint32 )tmp___2;
#line 658
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)data->g, sizeof(cmph_uint8 ) * (unsigned long )sizeg);
  }
#line 659
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_uint32 bdz_packed_size(cmph_t *mphf ) 
{ 
  bdz_data_t *data ;
  CMPH_HASH hl_type ;
  CMPH_HASH tmp ;
  cmph_uint32 tmp___0 ;
  double tmp___1 ;

  {
  {
#line 668
  data = (bdz_data_t *)mphf->data;
#line 670
  tmp = hash_get_type(data->hl);
#line 670
  hl_type = tmp;
#line 672
  tmp___0 = hash_state_packed_size(hl_type);
#line 672
  tmp___1 = ceil((double )data->n / 4.0);
  }
#line 672
  return ((cmph_uint32 )(((((sizeof(CMPH_ALGO ) + (unsigned long )tmp___0) + 3UL * sizeof(cmph_uint32 )) + sizeof(cmph_uint32 ) * (unsigned long )data->ranktablesize) + sizeof(cmph_uint8 )) + sizeof(cmph_uint8 ) * (unsigned long )((cmph_uint32 )tmp___1)));
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
cmph_uint32 bdz_search_packed(void *packed_mphf , char const   *key , cmph_uint32 keylen ) 
{ 
  register cmph_uint32 vertex ;
  register CMPH_HASH hl_type ;
  register cmph_uint8 *hl_ptr ;
  register cmph_uint32 *ranktable ;
  cmph_uint32 tmp ;
  register cmph_uint32 r ;
  cmph_uint32 *tmp___0 ;
  register cmph_uint32 ranktablesize ;
  cmph_uint32 *tmp___1 ;
  register cmph_uint8 *g ;
  register cmph_uint8 b ;
  cmph_uint8 *tmp___2 ;
  cmph_uint32 hl[3] ;
  cmph_uint32 tmp___3 ;

  {
  {
#line 686
  hl_type = (CMPH_HASH )*((cmph_uint32 *)packed_mphf);
#line 687
  hl_ptr = (cmph_uint8 *)packed_mphf + 4;
#line 689
  tmp = hash_state_packed_size(hl_type);
#line 689
  ranktable = (cmph_uint32 *)(hl_ptr + tmp);
#line 691
  tmp___0 = ranktable;
#line 691
  ranktable ++;
#line 691
  r = *tmp___0;
#line 692
  tmp___1 = ranktable;
#line 692
  ranktable ++;
#line 692
  ranktablesize = *tmp___1;
#line 693
  g = (cmph_uint8 *)(ranktable + ranktablesize);
#line 694
  tmp___2 = g;
#line 694
  g ++;
#line 694
  b = *tmp___2;
#line 697
  hash_vector_packed((void *)hl_ptr, hl_type, key, keylen, hl);
#line 698
  hl[0] %= r;
#line 699
  hl[1] = hl[1] % r + r;
#line 700
  hl[2] = hl[2] % r + (r << 1);
#line 701
  vertex = hl[(((int )((cmph_uint8 )((unsigned int )((int )*(g + (hl[0] >> 2)) >> ((hl[0] & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(g + (hl[1] >> 2)) >> ((hl[1] & 3U) << 1U)) & 3U))) + (int )((cmph_uint8 )((unsigned int )((int )*(g + (hl[2] >> 2)) >> ((hl[2] & 3U) << 1U)) & 3U))) % 3];
#line 702
  tmp___3 = rank((cmph_uint32 )b, ranktable, g, vertex);
  }
#line 702
  return (tmp___3);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.c"
cmph_config_t *__config_new(cmph_io_adapter_t *key_source ) 
{ 
  cmph_config_t *mph ;
  void *tmp ;

  {
  {
#line 10
  tmp = malloc(sizeof(cmph_config_t ));
#line 10
  mph = (cmph_config_t *)tmp;
#line 11
  memset((void *)mph, 0, sizeof(cmph_config_t ));
  }
#line 12
  if ((unsigned long )mph == (unsigned long )((void *)0)) {
#line 12
    return ((cmph_config_t *)((void *)0));
  }
#line 13
  mph->key_source = key_source;
#line 14
  mph->verbosity = (cmph_uint32 )0;
#line 15
  mph->data = (void *)0;
#line 16
  mph->c = (double )0;
#line 17
  return (mph);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.c"
void __config_destroy(cmph_config_t *mph ) 
{ 


  {
  {
#line 22
  free((void *)mph);
  }
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.c"
void __cmph_dump(cmph_t *mphf , FILE *fd ) 
{ 
  register size_t nbytes ;
  size_t tmp ;

  {
  {
#line 28
  tmp = strlen(cmph_names[mphf->algo]);
#line 28
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[mphf->algo], tmp + 1UL,
                  (size_t )1, (FILE */* __restrict  */)fd);
#line 29
  nbytes = fwrite((void const   */* __restrict  */)(& mphf->size), sizeof(mphf->size),
                  (size_t )1, (FILE */* __restrict  */)fd);
  }
#line 30
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph_structs.c"
cmph_t *__cmph_load(FILE *f ) 
{ 
  cmph_t *mphf ;
  cmph_uint32 i ;
  char algo_name[8192] ;
  char *ptr ;
  CMPH_ALGO algo ;
  register size_t nbytes ;
  size_t c ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 33
  mphf = (cmph_t *)((void *)0);
#line 36
  ptr = algo_name;
#line 37
  algo = (CMPH_ALGO )9;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    tmp = fread((void */* __restrict  */)ptr, (size_t )1, (size_t )1, (FILE */* __restrict  */)f);
#line 43
    c = tmp;
    }
#line 44
    if (c != 1UL) {
#line 44
      return ((cmph_t *)((void *)0));
    }
#line 45
    if ((int )*ptr == 0) {
#line 45
      goto while_break;
    }
#line 46
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  i = (cmph_uint32 )0;
  {
#line 48
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 48
    if (! (i < 9U)) {
#line 48
      goto while_break___0;
    }
    {
#line 50
    tmp___0 = strcmp((char const   *)(algo_name), cmph_names[i]);
    }
#line 50
    if (tmp___0 == 0) {
#line 52
      algo = (CMPH_ALGO )i;
    }
#line 48
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  if ((unsigned int )algo == 9U) {
#line 58
    return ((cmph_t *)((void *)0));
  }
  {
#line 60
  tmp___1 = malloc(sizeof(cmph_t ));
#line 60
  mphf = (cmph_t *)tmp___1;
#line 61
  mphf->algo = algo;
#line 62
  nbytes = fread((void */* __restrict  */)(& mphf->size), sizeof(mphf->size), (size_t )1,
                 (FILE */* __restrict  */)f);
#line 63
  mphf->data = (void *)0;
  }
#line 66
  return (mphf);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.h"
void vqueue_print(vqueue_t *q ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
vqueue_t *vqueue_new(cmph_uint32 capacity ) 
{ 
  size_t capacity_plus_one ;
  vqueue_t *q ;
  void *tmp ;
  void *tmp___0 ;
  cmph_uint32 tmp___1 ;

  {
  {
#line 13
  capacity_plus_one = (size_t )(capacity + 1U);
#line 14
  tmp = malloc(sizeof(vqueue_t ));
#line 14
  q = (vqueue_t *)tmp;
  }
#line 15
  if (! q) {
    {
#line 15
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c",
                  15U, "vqueue_new");
    }
  }
  {
#line 16
  tmp___0 = calloc(capacity_plus_one, sizeof(cmph_uint32 ));
#line 16
  q->values = (cmph_uint32 *)tmp___0;
#line 17
  tmp___1 = (cmph_uint32 )0;
#line 17
  q->end = tmp___1;
#line 17
  q->beg = tmp___1;
#line 18
  q->capacity = (cmph_uint32 )capacity_plus_one;
  }
#line 19
  return (q);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
cmph_uint8 vqueue_is_empty(vqueue_t *q ) 
{ 


  {
#line 24
  return ((cmph_uint8 )(q->beg == q->end));
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
void vqueue_insert(vqueue_t *q , cmph_uint32 val ) 
{ 


  {
#line 29
  if (! ((q->end + 1U) % q->capacity != q->beg)) {
    {
#line 29
    __assert_fail("(q->end + 1)%q->capacity != q->beg", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c",
                  29U, "vqueue_insert");
    }
  }
#line 30
  q->end = (q->end + 1U) % q->capacity;
#line 31
  *(q->values + q->end) = val;
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
cmph_uint32 vqueue_remove(vqueue_t *q ) 
{ 
  cmph_uint8 tmp ;

  {
  {
#line 36
  tmp = vqueue_is_empty(q);
  }
#line 36
  if (tmp) {
    {
#line 36
    __assert_fail("!vqueue_is_empty(q)", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c",
                  36U, "vqueue_remove");
    }
  }
#line 37
  q->beg = (q->beg + 1U) % q->capacity;
#line 38
  return (*(q->values + q->beg));
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
void vqueue_print(vqueue_t *q ) 
{ 
  cmph_uint32 i ;

  {
#line 44
  i = q->beg;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i != q->end)) {
#line 44
      goto while_break;
    }
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u\n",
            *(q->values + (i + 1U) % q->capacity));
#line 44
    i = (i + 1U) % q->capacity;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/vqueue.c"
void vqueue_destroy(vqueue_t *q ) 
{ 


  {
  {
#line 50
  free((void *)q->values);
#line 50
  q->values = (cmph_uint32 *)((void *)0);
#line 50
  free((void *)q);
  }
#line 51
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___5[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___0(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___0(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___0(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___0(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___0(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___5[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___5[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___5[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___5[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___5[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___5[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___5[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___0(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___5[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___5[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___5[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___5[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___5[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___5[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___5[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___1(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                       cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___5[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___0(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___5[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___1(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___5[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___0(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___0(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___5[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___5[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___5[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___5[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___5[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___0(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___0(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___5[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___5[(int )i & 7]);
#line 416
      bmz8_traverse___0(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___0(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___0[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___0[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___0(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___0[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___0[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___0(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___0[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___0[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___0[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___0(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___0[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___0[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___0[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___6[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___0(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___0(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___0(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___6[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___6[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___0(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___0(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___2[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___0(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___0(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___0(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___0(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___0(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___0(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___0(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___0(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___0(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___0(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___7[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___0  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___0(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___0(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___0(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___0)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___0(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___0(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___0) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___7[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___0) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___7[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___0(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___0(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___7[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___0(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___0(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___0(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___0(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___0(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___0(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___0(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___0(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___0(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___0(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___0(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___0(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___0(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___0(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___0(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___0(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___0(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___0(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___0(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___0(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___8[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___0(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___0(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___0(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___0(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___0(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___8[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___8[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___8[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___8[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___8[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___8[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___8[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___0(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___8[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___8[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___8[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___8[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___8[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___8[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___8[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___2(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___8[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___0(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___8[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___2(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___8[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___0(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___0(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___8[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___8[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___8[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___8[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___8[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___0(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___0(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___8[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___8[i & 7U]);
#line 403
      bmz_traverse___0(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___0(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___0(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___0(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___0(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___0(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___0(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___0(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___0(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___0(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___0(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___0(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___0(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___0(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___0(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___0(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___0(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___0(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___0(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___0(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___3[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___9[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___0[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___0[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___0(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___0(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___0(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___0(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___0(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___0(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___0(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___0(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___0(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___0(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___0(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___9[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___9[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___0(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___9[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___9[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___9[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___9[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___9[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___9[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___0(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___1(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___0(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___0(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___0(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___0(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___0(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___1(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___9[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___9[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___9[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___9[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___9[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___9[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___9[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___9[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___9[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___9[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___9[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___0(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___0[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___0(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___0(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___0(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___0(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___0(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___0(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___0(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___0(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___0(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___0(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___0(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___0(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___4[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___0(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___0(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___0(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___0(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___0(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___0(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___0(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___0(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___0(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___0(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___0(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___4[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___4[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___4[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___0(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___0(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___0(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___0(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___0(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___0(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___10[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___0[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___0(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___0(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___0(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___0(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___0(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___0(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___0(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___0(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___0(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___0(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___0(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___10[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___10[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___0(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___10[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___10[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___10[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___10[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___10[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___10[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___0(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___2(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___0(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___0(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___0(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___0(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___0(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___2(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___10[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___10[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___0[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___10[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___10[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___0[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___10[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___0[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___10[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___10[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___10[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___0[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___10[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___0[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___10[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___0[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___10[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___0(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___11[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___1(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___1(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___1(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___1(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___1(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___11[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___11[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___11[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___11[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___11[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___11[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___11[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___1(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___11[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___11[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___11[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___11[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___11[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___11[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___11[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___3(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                       cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___11[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___1(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___11[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___3(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___11[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___1(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___1(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___11[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___11[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___11[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___11[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___11[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___1(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___1(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___11[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___11[(int )i & 7]);
#line 416
      bmz8_traverse___1(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___1(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___1[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___1[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___1(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___1[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___1[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___1(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___1[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___1[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___1[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___1(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___1[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___1[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___1[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___12[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___1(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___1(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___1(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___12[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___12[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___1(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___1(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___5[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___1(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___1(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___1(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___1(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___1(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___1(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___1(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___1(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___1(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___1(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___13[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___1  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___1(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___1(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___1(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___1)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___1(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___1(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___1) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___13[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___1) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___13[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___1(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___1(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___13[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___1(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___1(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___1(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___1(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___1(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___1(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___1(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___1(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___1(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___1(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___1(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___1(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___1(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___1(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___1(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___1(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___1(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___1(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___1(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___1(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___14[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___1(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___1(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___1(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___1(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___1(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___14[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___14[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___14[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___14[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___14[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___14[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___14[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___1(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___14[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___14[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___14[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___14[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___14[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___14[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___14[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___4(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___14[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___1(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___14[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___4(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___14[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___1(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___1(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___14[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___14[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___14[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___14[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___14[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___1(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___1(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___14[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___14[i & 7U]);
#line 403
      bmz_traverse___1(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___1(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___1(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___1(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___1(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___1(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___1(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___1(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___1(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___1(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___1(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___1(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___1(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___1(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___1(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___1(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___1(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___1(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___1(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___1(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___6[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___15[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___1[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___1[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___1(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___1(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___1(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___1(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___1(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___1(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___1(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___1(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___1(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___1(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___1(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___15[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___15[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___1(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___15[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___15[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___15[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___15[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___15[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___15[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___1(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___3(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___1(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___1(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___1(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___1(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___1(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___3(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___15[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___15[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___15[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___15[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___15[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___15[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___15[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___15[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___15[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___15[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___15[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___1(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___1[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___1(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___1(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___1(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___1(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___1(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___1(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___1(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___1(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___1(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___1(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___1(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___1(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___7[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___1(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___1(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___1(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___1(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___1(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___1(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___1(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___1(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___1(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___1(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___1(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___7[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___7[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___7[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___1(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___1(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___1(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___1(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___1(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___1(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___16[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___1[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___1(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___1(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___1(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___1(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___1(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___1(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___1(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___1(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___1(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___1(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___1(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___16[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___16[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___1(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___16[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___16[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___16[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___16[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___16[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___16[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___1(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___4(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___1(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___1(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___1(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___1(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___1(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___4(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___16[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___16[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___1[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___16[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___16[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___1[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___16[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___1[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___16[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___16[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___16[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___1[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___16[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___1[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___16[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___1[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___16[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___1(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___17[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___2(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___2(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___2(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___2(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___2(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___17[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___17[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___17[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___17[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___17[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___17[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___17[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___2(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___17[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___17[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___17[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___17[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___17[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___17[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___17[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___5(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                       cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___17[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___2(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___17[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___5(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___17[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___2(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___2(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___17[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___17[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___17[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___17[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___17[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___2(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___2(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___17[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___17[(int )i & 7]);
#line 416
      bmz8_traverse___2(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___2(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___2[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___2[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___2(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___2[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___2[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___2(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___2[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___2[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___2[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___2(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___2[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___2[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___2[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___18[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___2(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___2(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___2(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___18[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___18[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___2(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___2(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___8[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___2(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___2(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___2(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___2(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___2(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___2(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___2(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___2(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___2(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___2(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___19[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___2  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___2(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___2(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___2(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___2)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___2(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___2(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___2) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___19[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___2) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___19[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___2(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___2(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___19[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___2(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___2(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___2(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___2(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___2(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___2(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___2(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___2(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___2(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___2(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___2(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___2(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___2(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___2(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___2(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___2(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___2(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___2(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___2(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___2(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___20[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___2(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___2(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___2(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___2(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___2(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___20[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___20[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___20[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___20[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___20[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___20[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___20[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___2(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___20[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___20[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___20[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___20[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___20[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___20[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___20[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___6(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___20[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___2(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___20[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___6(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___20[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___2(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___2(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___20[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___20[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___20[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___20[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___20[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___2(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___2(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___20[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___20[i & 7U]);
#line 403
      bmz_traverse___2(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___2(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___2(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___2(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___2(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___2(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___2(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___2(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___2(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___2(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___2(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___2(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___2(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___2(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___2(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___2(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___2(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___2(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___2(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___2(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___9[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___21[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___2[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___2[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___2(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___2(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___2(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___2(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___2(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___2(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___2(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___2(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___2(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___2(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___2(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___21[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___21[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___2(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___21[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___21[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___21[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___21[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___21[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___21[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___2(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___5(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___2(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___2(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___2(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___2(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___2(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___5(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___21[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___21[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___21[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___21[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___21[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___21[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___21[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___21[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___21[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___21[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___21[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___2(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___2[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___2(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___2(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___2(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___2(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___2(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___2(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___2(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___2(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___2(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___10[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___2(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___2(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___2(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___2(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___2(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___2(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___2(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___2(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___2(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___2(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___2(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___10[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___10[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___10[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___2(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___2(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___2(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___2(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___2(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___2(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___22[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___2[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___2(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___2(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___2(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___2(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___2(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___2(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___2(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___2(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___2(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___2(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___2(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___22[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___22[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___2(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___22[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___22[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___22[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___22[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___22[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___22[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___2(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___6(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___2(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___2(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___2(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___2(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___2(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___6(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___22[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___22[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___2[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___22[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___22[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___2[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___22[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___2[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___22[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___22[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___22[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___2[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___22[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___2[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___22[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___2[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___22[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___2(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___23[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___3(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___3(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___3(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___3(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___3(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___23[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___23[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___23[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___23[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___23[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___23[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___23[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___3(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___23[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___23[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___23[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___23[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___23[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___23[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___23[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___7(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                       cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___23[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___3(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___23[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___7(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___23[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___3(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___3(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___23[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___23[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___23[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___23[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___23[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___3(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___3(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___23[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___23[(int )i & 7]);
#line 416
      bmz8_traverse___3(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___3(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___3[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___3[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___3(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___3[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___3[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___3(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___3[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___3[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___3[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___3(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___3[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___3[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___3[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___24[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___3(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___3(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___3(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___24[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___24[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___3(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___3(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___11[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___3(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___3(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___3(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___3(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___3(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___3(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___3(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___3(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___3(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___3(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/compressed_seq_tests.c"
__inline static void print_values(compressed_seq_t *cs , cmph_uint32 idx ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 11
  index = compressed_seq_query(cs, idx);
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[%u]\t= %u\n",
          idx, index);
  }
#line 13
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/compressed_seq_tests.c"
__inline static void print_values_packed(char *cs_packed , cmph_uint32 idx ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 20
  index = compressed_seq_query_packed((void *)cs_packed, idx);
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[%u]\t= %u\n",
          idx, index);
  }
#line 22
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___25[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___3  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___3(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___3(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___3(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___3)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___3(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___3(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___3) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___25[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___3) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___25[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___3(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___3(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___25[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___3(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___3(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___3(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___3(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___3(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___3(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___3(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___3(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___3(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___3(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___3(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___3(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___3(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___3(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___3(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___3(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___3(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___3(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___3(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___3(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___26[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___3(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___3(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___3(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___3(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___3(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___26[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___26[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___26[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___26[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___26[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___26[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___26[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___3(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___26[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___26[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___26[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___26[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___26[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___26[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___26[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___8(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___26[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___3(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___26[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___8(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___26[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___3(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___3(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___26[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___26[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___26[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___26[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___26[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___3(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___3(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___26[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___26[i & 7U]);
#line 403
      bmz_traverse___3(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___3(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___3(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___3(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___3(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___3(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___3(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___3(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___3(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___3(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___3(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___3(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___3(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___3(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___3(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___3(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___3(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___3(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___3(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___3(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___12[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___27[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___3[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___3[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___3(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___3(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___3(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___3(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___3(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___3(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___3(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___3(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___3(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___3(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___3(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___27[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___27[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___3(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___27[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___27[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___27[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___27[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___27[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___27[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___3(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___7(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___3(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___3(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___3(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___3(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___3(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___7(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___27[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___27[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___27[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___27[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___27[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___27[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___27[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___27[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___27[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___27[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___27[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___3(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___3[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___3(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___3(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___3(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___3(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___3(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___3(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___3(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___3(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___3(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___3(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___3(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___3(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___13[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___3(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___3(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___3(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___3(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___3(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___3(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___3(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___3(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___3(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___3(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___3(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___13[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___13[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___13[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___3(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___3(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___3(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___3(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___3(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___3(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___28[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___3[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___3(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___3(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___3(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___3(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___3(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___3(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___3(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___3(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___3(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___3(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___3(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___28[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___28[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___3(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___28[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___28[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___28[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___28[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___28[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___28[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___3(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___8(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___3(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___3(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___3(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___3(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___3(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___8(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___28[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___28[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___3[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___28[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___28[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___3[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___28[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___3[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___28[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___28[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___28[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___3[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___28[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___3[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___28[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___3[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___28[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___3(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___29[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___4(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___4(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___4(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___4(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___4(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___29[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___29[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___29[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___29[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___29[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___29[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___29[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___4(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___29[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___29[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___29[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___29[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___29[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___29[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___29[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___9(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                       cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___29[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___4(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___29[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___9(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___29[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___4(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___4(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___29[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___29[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___29[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___29[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___29[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___4(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___4(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___29[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___29[(int )i & 7]);
#line 416
      bmz8_traverse___4(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___4(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___4[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___4[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___4(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___4[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___4[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___4(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___4[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___4[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___4[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___4(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___4[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___4[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___4[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___30[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___4(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___4(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___4(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___30[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___30[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___4(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___4(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___14[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___4(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___4(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___4(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___4(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___4(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___4(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___4(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___4(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___4(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___4(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___31[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___4  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___4(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___4(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___4(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___4)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___4(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___4(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___4) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___31[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___4) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___31[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___4(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___4(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___31[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___4(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___4(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___4(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___4(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___4(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___4(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___4(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___4(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___4(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___4(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___4(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___4(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___4(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___4(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___4(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___4(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___4(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___4(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___4(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___4(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___32[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___4(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___4(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___4(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___4(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___4(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___32[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___32[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___32[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___32[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___32[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___32[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___32[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___4(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___32[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___32[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___32[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___32[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___32[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___32[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___32[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___10(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___32[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___4(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___32[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___10(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___32[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___4(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___4(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___32[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___32[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___32[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___32[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___32[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___4(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___4(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___32[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___32[i & 7U]);
#line 403
      bmz_traverse___4(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___4(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___4(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___4(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___4(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___4(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___4(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___4(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___4(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___4(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___4(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___4(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___4(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___4(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___4(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___4(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___4(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___4(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___4(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___4(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___15[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___33[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___4[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___4[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___4(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___4(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___4(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___4(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___4(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___4(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___4(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___4(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___4(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___4(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___4(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___33[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___33[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___4(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___33[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___33[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___33[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___33[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___33[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___33[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___4(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___9(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___4(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___4(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___4(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___4(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___4(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___9(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                          bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___33[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___33[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___33[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___33[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___33[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___33[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___33[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___33[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___33[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___33[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___33[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___4(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___4[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___4(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___4(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___4(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___4(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___4(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___4(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___4(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___4(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___4(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___4(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___4(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___4(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___16[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___4(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___4(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___4(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___4(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___4(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___4(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___4(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___4(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___4(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___4(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___4(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___16[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___16[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___16[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___4(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___4(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___4(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___4(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___4(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___4(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___34[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___4[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___4(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___4(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___4(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___4(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___4(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___4(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___4(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___4(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___4(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___4(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___4(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___34[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___34[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___4(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___34[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___34[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___34[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___34[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___34[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___34[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___4(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___10(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___4(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___4(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___4(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___4(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___4(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___10(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___34[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___34[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___4[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___34[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___34[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___4[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___34[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___4[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___34[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___34[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___34[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___4[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___34[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___4[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___34[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___4[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___34[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___4(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/compressed_rank_tests.c"
__inline static void print_values___0(compressed_rank_t *cr , cmph_uint32 idx ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 11
  index = compressed_rank_query(cr, idx);
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[%u]\t= %u\n",
          idx, index);
  }
#line 13
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/compressed_rank_tests.c"
__inline static void print_values_packed___0(char *cr_packed , cmph_uint32 idx ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 20
  index = compressed_rank_query_packed((void *)cr_packed, idx);
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[%u]\t= %u\n",
          idx, index);
  }
#line 22
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___35[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___5(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___5(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___5(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___5(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___5(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___35[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___35[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___35[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___35[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___35[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___35[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___35[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___5(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___35[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___35[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___35[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___35[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___35[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___35[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___35[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___11(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___35[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___5(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___35[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___11(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___35[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___5(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___5(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___35[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___35[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___35[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___35[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___35[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___5(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___5(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___35[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___35[(int )i & 7]);
#line 416
      bmz8_traverse___5(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___5(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___5[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___5[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___5(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___5[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___5[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___5(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___5[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___5[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___5[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___5(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___5[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___5[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___5[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___36[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___5(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___5(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___5(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___36[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___36[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___5(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___5(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___17[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___5(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___5(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___5(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___5(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___5(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___5(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___5(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___5(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___5(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___5(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___37[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___5  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___5(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___5(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___5(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___5)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___5(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___5(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___5) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___37[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___5) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___37[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___5(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___5(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___37[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___5(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___5(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___5(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___5(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___5(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___5(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___5(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___5(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___5(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___5(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___5(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___5(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___5(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___5(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___5(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___5(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___5(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___5(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___5(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___5(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___38[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___5(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___5(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___5(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___5(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___5(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___38[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___38[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___38[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___38[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___38[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___38[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___38[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___5(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___38[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___38[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___38[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___38[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___38[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___38[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___38[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___12(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___38[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___5(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___38[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___12(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___38[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___5(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___5(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___38[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___38[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___38[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___38[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___38[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___5(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___5(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___38[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___38[i & 7U]);
#line 403
      bmz_traverse___5(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___5(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___5(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___5(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___5(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___5(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___5(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___5(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___5(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___5(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___5(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___5(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___5(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___5(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___5(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___5(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___5(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___5(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___5(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___5(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___18[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___39[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___5[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___5[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___5(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___5(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___5(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___5(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___5(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___5(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___5(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___5(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___5(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___5(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___5(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___39[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___39[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___5(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___39[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___39[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___39[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___39[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___39[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___39[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___5(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___11(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___5(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___5(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___5(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___5(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___5(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___11(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___39[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___39[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___39[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___39[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___39[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___39[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___39[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___39[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___39[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___39[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___39[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___5(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___5[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___5(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___5(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___5(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___5(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___5(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___5(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___5(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___5(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___5(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___5(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___5(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___5(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___19[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___5(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___5(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___5(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___5(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___5(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___5(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___5(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___5(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___5(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___5(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___5(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___19[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___19[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___19[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___5(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___5(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___5(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___5(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___5(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___5(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___40[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___5[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___5(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___5(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___5(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___5(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___5(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___5(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___5(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___5(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___5(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___5(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___5(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___40[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___40[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___5(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___40[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___40[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___40[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___40[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___40[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___40[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___5(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___12(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___5(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___5(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___5(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___5(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___5(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___12(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___40[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___40[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___5[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___40[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___40[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___5[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___40[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___5[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___40[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___40[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___40[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___5[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___40[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___5[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___40[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___5[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___40[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___5(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/select_tests.c"
__inline static void print_values___1(select_t *sel ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 11
  index = select_query(sel, (cmph_uint32 )0);
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[0]\t= %u\n",
          index);
#line 14
  index = select_next_query(sel, index);
#line 15
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 17
  index = select_query(sel, (cmph_uint32 )1);
#line 18
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[1]\t= %u\n",
          index - 1U);
#line 20
  index = select_next_query(sel, index);
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 23
  index = select_query(sel, (cmph_uint32 )2);
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[2]\t= %u\n",
          index - 2U);
#line 26
  index = select_next_query(sel, index);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 29
  index = select_query(sel, (cmph_uint32 )3);
#line 30
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[3]\t= %u\n",
          index - 3U);
  }
#line 31
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/select_tests.c"
__inline static void print_values_packed___1(char *sel_packed ) 
{ 
  register cmph_uint32 index ;

  {
  {
#line 38
  index = select_query_packed((void *)sel_packed, (cmph_uint32 )0);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[0]\t= %u\n",
          index);
#line 41
  index = select_next_query_packed((void *)sel_packed, index);
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 44
  index = select_query_packed((void *)sel_packed, (cmph_uint32 )1);
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[1]\t= %u\n",
          index - 1U);
#line 47
  index = select_next_query_packed((void *)sel_packed, index);
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 50
  index = select_query_packed((void *)sel_packed, (cmph_uint32 )2);
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[2]\t= %u\n",
          index - 2U);
#line 53
  index = select_next_query_packed((void *)sel_packed, index);
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next Index\t= %u\n",
          index);
#line 56
  index = select_query_packed((void *)sel_packed, (cmph_uint32 )3);
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index[3]\t= %u\n",
          index - 3U);
  }
#line 58
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___41[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___6(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___6(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___6(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___6(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___6(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___41[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___41[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___41[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___41[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___41[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___41[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___41[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___6(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___41[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___41[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___41[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___41[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___41[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___41[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___41[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___13(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___41[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___6(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___41[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___13(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___41[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___6(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___6(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___41[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___41[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___41[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___41[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___41[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___6(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___6(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___41[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___41[(int )i & 7]);
#line 416
      bmz8_traverse___6(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___6(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___6[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___6[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___6(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___6[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___6[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___6(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___6[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___6[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___6[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___6(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___6[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___6[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___6[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___42[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___6(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___6(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___6(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___42[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___42[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___6(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___6(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___20[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___6(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___6(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___6(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___6(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___6(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___6(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___6(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___6(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___6(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___6(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___43[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___6  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___6(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___6(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___6(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___6)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___6(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___6(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___6) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___43[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___6) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___43[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___6(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___6(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___43[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___6(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___6(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___6(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___6(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___6(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___6(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___6(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___6(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___6(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___6(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___6(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___6(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___6(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___6(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___6(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___6(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___6(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___6(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___6(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___6(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___44[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___6(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___6(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___6(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___6(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___6(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___44[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___44[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___44[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___44[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___44[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___44[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___44[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___6(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___44[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___44[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___44[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___44[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___44[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___44[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___44[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___14(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___44[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___6(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___44[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___14(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___44[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___6(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___6(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___44[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___44[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___44[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___44[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___44[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___6(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___6(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___44[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___44[i & 7U]);
#line 403
      bmz_traverse___6(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___6(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___6(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___6(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___6(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___6(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___6(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___6(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___6(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___6(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___6(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___6(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___6(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___6(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___6(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___6(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___6(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___6(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___6(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___6(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___21[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___45[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___6[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___6[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___6(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___6(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___6(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___6(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___6(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___6(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___6(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___6(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___6(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___6(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___6(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___45[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___45[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___6(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___45[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___45[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___45[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___45[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___45[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___45[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___6(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___13(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___6(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___6(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___6(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___6(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___6(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___13(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___45[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___45[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___45[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___45[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___45[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___45[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___45[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___45[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___45[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___45[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___45[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___6(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___6[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___6(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___6(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___6(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___6(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___6(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___6(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___6(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___6(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___6(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___6(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___6(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___6(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___22[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___6(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___6(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___6(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___6(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___6(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___6(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___6(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___6(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___6(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___6(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___6(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___22[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___22[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___22[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___6(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___6(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___6(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___6(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___6(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___6(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/packed_mphf_tests.c"
void usage(char const   *prg ) 
{ 


  {
  {
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-v] [-h] [-V] [-t keys_per_bin] [-k nkeys] [-m file.mph]  keysfile\n",
          prg);
  }
#line 26
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/tests/packed_mphf_tests.c"
void usage_long(char const   *prg ) 
{ 


  {
  {
#line 29
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-v] [-h] [-V] [-t keys_per_bin] [-k nkeys] [-m file.mph] keysfile\n",
          prg);
#line 30
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Packed MPHFs testing tool\n\n");
#line 31
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h\t print this help message\n");
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V\t print version number and exit\n");
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v\t increase verbosity (may be used multiple times)\n");
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t\t set the number of keys per bin for a t-perfect hashing function.\n");
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    \t A t-perfect hashing function allows at most t collisions in a given bin.\n");
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -k\t number of keys\n");
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m\t minimum perfect hash function file \n");
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  keysfile\t line separated file with keys\n");
  }
#line 39
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___46[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___6[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___6(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___6(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___6(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___6(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___6(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___6(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___6(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___6(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___6(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___6(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___6(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___46[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___46[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___6(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___46[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___46[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___46[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___46[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___46[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___46[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___6(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___14(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___6(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___6(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___6(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___6(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___6(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___14(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___46[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___46[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___6[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___46[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___46[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___6[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___46[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___6[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___46[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___46[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___46[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___6[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___46[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___6[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___46[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___6[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___46[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___6(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___47[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___7(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___7(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___7(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___7(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___7(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___47[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___47[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___47[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___47[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___47[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___47[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___47[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___7(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___47[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___47[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___47[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___47[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___47[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___47[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___47[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___15(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___47[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___7(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___47[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___15(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___47[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___7(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___7(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___47[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___47[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___47[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___47[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___47[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___7(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___7(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___47[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___47[(int )i & 7]);
#line 416
      bmz8_traverse___7(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___7(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___7[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___7[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___7(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___7[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___7[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___7(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___7[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___7[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___7[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___7(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___7[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___7[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___7[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___48[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___7(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___7(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___7(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___48[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___48[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___7(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___7(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___23[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___7(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___7(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___7(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___7(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___7(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___7(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___7(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___7(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___7(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___7(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___49[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___7  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___7(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___7(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___7(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___7)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___7(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___7(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___7) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___49[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___7) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___49[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___7(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___7(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___49[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___7(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___7(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___7(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___7(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___7(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___7(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___7(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___7(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___7(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___7(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___7(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___7(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___7(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___7(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___7(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___7(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___7(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___7(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___7(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___7(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___50[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___7(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___7(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___7(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___7(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___7(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___50[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___50[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___50[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___50[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___50[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___50[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___50[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___7(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___50[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___50[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___50[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___50[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___50[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___50[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___50[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___16(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___50[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___7(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___50[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___16(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___50[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___7(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___7(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___50[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___50[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___50[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___50[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___50[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___7(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___7(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___50[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___50[i & 7U]);
#line 403
      bmz_traverse___7(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___7(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___7(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___7(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___7(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___7(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___7(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___7(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___7(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___7(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___7(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___7(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___7(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___7(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___7(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___7(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___7(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___7(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___7(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___7(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___24[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___51[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___7[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___7[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___7(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___7(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___7(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___7(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___7(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___7(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___7(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___7(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___7(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___7(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___7(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___51[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___51[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___7(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___51[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___51[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___51[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___51[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___51[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___51[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___7(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___15(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___7(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___7(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___7(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___7(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___7(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___15(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___51[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___51[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___51[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___51[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___51[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___51[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___51[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___51[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___51[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___51[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___51[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___7(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___7[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___7(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___7(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___7(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___7(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___7(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___7(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___7(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___7(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___7(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___7(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___7(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___7(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___25[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___7(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___7(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___7(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___7(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___7(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___7(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___7(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___7(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___7(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___7(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___7(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___25[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___25[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___25[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___7(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___7(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___7(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___7(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___7(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___7(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___52[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___7[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___7(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___7(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___7(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___7(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___7(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___7(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___7(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___7(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___7(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___7(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___7(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___52[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___52[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___7(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___52[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___52[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___52[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___52[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___52[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___52[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___7(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___16(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___7(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___7(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___7(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___7(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___7(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___16(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___52[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___52[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___7[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___52[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___52[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___7[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___52[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___7[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___52[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___52[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___52[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___7[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___52[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___7[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___52[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___7[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___52[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___7(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___26[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___53[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___8(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___8(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___8(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___53[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___53[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___8(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___8(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___8(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___8(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___8(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___8(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___8(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___8(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___8(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___8(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___8(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___8(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___8(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___8(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___8(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___8(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___8(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___8(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___8(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___8(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___54[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___8  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___8(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___8(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___8(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___8)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___8(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___8(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___8) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___54[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___8) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___54[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___8(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___8(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___54[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___8(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___8(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___8(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___8(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___8(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___8(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___8(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___8(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___8(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___8(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___8(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___8(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___8(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___8(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___8(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___8(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___8(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___8(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___8(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___8(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___55[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___8(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___8(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___8(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___8(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___8(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___55[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___55[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___55[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___55[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___55[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___55[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___55[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___8(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___55[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___55[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___55[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___55[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___55[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___55[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___55[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___17(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___55[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___8(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___55[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___17(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___55[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___8(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___8(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___55[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___55[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___55[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___55[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___55[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___8(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___8(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___55[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___55[i & 7U]);
#line 403
      bmz_traverse___8(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___8(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___8(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___8(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___8(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___8(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___8(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___8(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___8(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___8(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___8(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___8(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___8(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___8(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___8(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___8(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___8(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___8(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___8(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___8(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___8(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___8(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___8(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___8(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___56[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___8(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___8(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___8(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___8(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___8(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___56[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___56[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___56[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___56[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___56[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___56[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___56[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___8(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___56[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___56[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___56[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___56[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___56[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___56[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___56[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___18(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___56[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___8(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___56[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___18(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___56[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___8(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___8(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___56[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___56[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___56[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___56[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___56[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___8(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___8(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___56[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___56[(int )i & 7]);
#line 416
      bmz8_traverse___8(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___8(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___57[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___8[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___8(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___8(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___8(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___8(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___8(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___8(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___8(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___8(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___8(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___8(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___8(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___57[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___57[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___8(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___57[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___57[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___57[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___57[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___57[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___57[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___8(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___17(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___8(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___8(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___8(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___8(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___8(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___17(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___57[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___57[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___8[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___57[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___57[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___8[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___57[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___8[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___57[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___57[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___57[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___8[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___57[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___8[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___57[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___8[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___57[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___8(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___27[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___8(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___8(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___8(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___8(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___8(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___8(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___8(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___8(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___8(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___8(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___8(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___27[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___27[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___27[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___8(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___8(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___8(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___8(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___8(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___8(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___8[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___8[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___8(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___8[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___8[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___8(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___8[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___8[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___8[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___8(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___8[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___8[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___8[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___58[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___8[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___8[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___8(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___8(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___8(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___8(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___8(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___8(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___8(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___8(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___8(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___8(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___8(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___58[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___58[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___8(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___58[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___58[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___58[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___58[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___58[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___58[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___8(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___18(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___8(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___8(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___8(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___8(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___8(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___18(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___58[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___58[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___58[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___58[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___58[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___58[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___58[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___58[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___58[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___58[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___58[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___8(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___8[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___28[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___29[32]  = 
#line 7
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 63 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___9(cmph_uint32 nbuckets ) ;
#line 64
static void chd_ph_bucket_clean___9(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) ;
#line 65
static void chd_ph_bucket_destroy___9(chd_ph_bucket_t *buckets ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_bucket_t *chd_ph_bucket_new___9(cmph_uint32 nbuckets ) 
{ 
  chd_ph_bucket_t *buckets ;
  void *tmp ;

  {
  {
#line 69
  tmp = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 69
  buckets = (chd_ph_bucket_t *)tmp;
  }
#line 70
  return (buckets);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_clean___9(chd_ph_bucket_t *buckets , cmph_uint32 nbuckets ) 
{ 
  register cmph_uint32 i ;

  {
#line 75
  i = (cmph_uint32 )0;
#line 76
  if (! buckets) {
    {
#line 76
    __assert_fail("buckets", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c",
                  76U, "chd_ph_bucket_clean");
    }
  }
#line 77
  i = (cmph_uint32 )0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < nbuckets)) {
#line 77
      goto while_break;
    }
#line 78
    (buckets + i)->__annonCompField15.size = (cmph_uint32 )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static void chd_ph_bucket_destroy___9(chd_ph_bucket_t *buckets ) 
{ 


  {
  {
#line 105
  free((void *)buckets);
  }
#line 106
  return;
}
}
#line 108
static cmph_uint8 chd_ph_mapping___9(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) ;
#line 111
static chd_ph_sorted_list_t *chd_ph_ordering___9(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) ;
#line 114
static cmph_uint8 chd_ph_searching___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_mapping___9(cmph_config_t *mph , chd_ph_bucket_t *buckets ,
                                     chd_ph_item_t *items , cmph_uint32 *max_bucket_size ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 g ;
  cmph_uint32 hl[3] ;
  chd_ph_config_data_t *chd_ph ;
  char *key ;
  cmph_uint32 keylen ;
  chd_ph_map_item_t *map_item ;
  chd_ph_map_item_t *map_items ;
  void *tmp ;
  register cmph_uint32 mapping_iterations ;
  cmph_uint8 tmp___0 ;

  {
  {
#line 218
  i = (cmph_uint32 )0;
#line 218
  g = (cmph_uint32 )0;
#line 220
  chd_ph = (chd_ph_config_data_t *)mph->data;
#line 221
  key = (char *)((void *)0);
#line 222
  keylen = (cmph_uint32 )0;
#line 224
  tmp = malloc((unsigned long )chd_ph->m * sizeof(chd_ph_map_item_t ));
#line 224
  map_items = (chd_ph_map_item_t *)tmp;
#line 225
  mapping_iterations = (cmph_uint32 )1000;
#line 226
  *max_bucket_size = (cmph_uint32 )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    mapping_iterations --;
#line 230
    if (chd_ph->hl) {
      {
#line 230
      hash_state_destroy(chd_ph->hl);
      }
    }
    {
#line 231
    chd_ph->hl = hash_state_new(chd_ph->hashfunc, chd_ph->m);
#line 233
    chd_ph_bucket_clean___9(buckets, chd_ph->nbuckets);
#line 235
    (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 237
    i = (cmph_uint32 )0;
    }
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! (i < chd_ph->m)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 240
      hash_vector(chd_ph->hl, (char const   *)key, keylen, hl);
#line 242
      map_item = map_items + i;
#line 244
      g = hl[0] % chd_ph->nbuckets;
#line 245
      map_item->f = hl[1] % chd_ph->n;
#line 246
      map_item->h = hl[2] % (chd_ph->n - 1U) + 1U;
#line 247
      map_item->bucket_num = g;
#line 248
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 254
      ((buckets + g)->__annonCompField15.size) ++;
      }
#line 255
      if ((buckets + g)->__annonCompField15.size > *max_bucket_size) {
#line 257
        *max_bucket_size = (buckets + g)->__annonCompField15.size;
      }
#line 237
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    (buckets + 0)->items_list = (cmph_uint32 )0;
#line 261
    i = (cmph_uint32 )1;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < chd_ph->nbuckets)) {
#line 261
        goto while_break___1;
      }
#line 263
      (buckets + i)->items_list = (buckets + (i - 1U))->items_list + (buckets + (i - 1U))->__annonCompField15.size;
#line 264
      (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 266
    (buckets + (i - 1U))->__annonCompField15.size = (cmph_uint32 )0;
#line 267
    i = (cmph_uint32 )0;
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < chd_ph->m)) {
#line 267
        goto while_break___2;
      }
      {
#line 269
      map_item = map_items + i;
#line 270
      tmp___0 = chd_ph_bucket_insert(buckets, map_items, items, chd_ph->nbuckets,
                                     i);
      }
#line 270
      if (! tmp___0) {
#line 271
        goto while_break___2;
      }
#line 267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 273
    if (i == chd_ph->m) {
      {
#line 275
      free((void *)map_items);
      }
#line 276
      return ((cmph_uint8 )1);
    }
#line 279
    if (mapping_iterations == 0U) {
#line 281
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  error: 
  {
#line 285
  free((void *)map_items);
#line 286
  hash_state_destroy(chd_ph->hl);
#line 287
  chd_ph->hl = (hash_state_t *)((void *)0);
  }
#line 288
  return ((cmph_uint8 )0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static chd_ph_sorted_list_t *chd_ph_ordering___9(chd_ph_bucket_t **_buckets , chd_ph_item_t **_items ,
                                                 cmph_uint32 nbuckets , cmph_uint32 nitems ,
                                                 cmph_uint32 max_bucket_size ) 
{ 
  chd_ph_sorted_list_t *sorted_lists ;
  void *tmp ;
  chd_ph_bucket_t *input_buckets ;
  chd_ph_bucket_t *output_buckets ;
  chd_ph_item_t *input_items ;
  chd_ph_item_t *output_items ;
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 bucket_size ;
  register cmph_uint32 position ;
  register cmph_uint32 position2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 294
  tmp = calloc((size_t )(max_bucket_size + 1U), sizeof(chd_ph_sorted_list_t ));
#line 294
  sorted_lists = (chd_ph_sorted_list_t *)tmp;
#line 296
  input_buckets = *_buckets;
#line 298
  input_items = *_items;
#line 304
  i = (cmph_uint32 )0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < nbuckets)) {
#line 304
      goto while_break;
    }
#line 306
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 307
    if (bucket_size == 0U) {
#line 308
      goto __Cont;
    }
#line 309
    ((sorted_lists + bucket_size)->size) ++;
    __Cont: /* CIL Label */ 
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  (sorted_lists + 1)->buckets_list = (cmph_uint32 )0;
#line 313
  i = (cmph_uint32 )2;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i <= max_bucket_size)) {
#line 313
      goto while_break___0;
    }
#line 315
    (sorted_lists + i)->buckets_list = (sorted_lists + (i - 1U))->buckets_list + (sorted_lists + (i - 1U))->size;
#line 316
    (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 313
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  (sorted_lists + (i - 1U))->size = (cmph_uint32 )0;
#line 320
  tmp___0 = calloc((size_t )nbuckets, sizeof(chd_ph_bucket_t ));
#line 320
  output_buckets = (chd_ph_bucket_t *)tmp___0;
#line 323
  i = (cmph_uint32 )0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i < nbuckets)) {
#line 323
      goto while_break___1;
    }
#line 325
    bucket_size = (input_buckets + i)->__annonCompField15.size;
#line 326
    if (bucket_size == 0U) {
#line 329
      goto __Cont___0;
    }
#line 331
    position = (sorted_lists + bucket_size)->buckets_list + (sorted_lists + bucket_size)->size;
#line 332
    (output_buckets + position)->__annonCompField15.bucket_id = i;
#line 333
    (output_buckets + position)->items_list = (input_buckets + i)->items_list;
#line 334
    ((sorted_lists + bucket_size)->size) ++;
    __Cont___0: /* CIL Label */ 
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  free((void *)input_buckets);
#line 340
  *_buckets = output_buckets;
#line 344
  tmp___1 = calloc((size_t )nitems, sizeof(chd_ph_item_t ));
#line 344
  output_items = (chd_ph_item_t *)tmp___1;
#line 345
  position = (cmph_uint32 )0;
#line 346
  i = (cmph_uint32 )0;
#line 347
  bucket_size = (cmph_uint32 )1;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (bucket_size <= max_bucket_size)) {
#line 347
      goto while_break___2;
    }
#line 349
    i = (sorted_lists + bucket_size)->buckets_list;
    {
#line 349
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 349
      if (! (i < (sorted_lists + bucket_size)->size + (sorted_lists + bucket_size)->buckets_list)) {
#line 349
        goto while_break___3;
      }
#line 351
      position2 = (output_buckets + i)->items_list;
#line 352
      (output_buckets + i)->items_list = position;
#line 353
      j = (cmph_uint32 )0;
      {
#line 353
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 353
        if (! (j < bucket_size)) {
#line 353
          goto while_break___4;
        }
#line 355
        (output_items + position)->f = (input_items + position2)->f;
#line 356
        (output_items + position)->h = (input_items + position2)->h;
#line 357
        position ++;
#line 358
        position2 ++;
#line 353
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 349
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 347
    bucket_size ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)input_items);
#line 364
  *_items = output_items;
  }
#line 365
  return (sorted_lists);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket_probe___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                                  chd_ph_item_t *items , cmph_uint32 probe0_num ,
                                                  cmph_uint32 probe1_num , cmph_uint32 bucket_num ,
                                                  cmph_uint32 size ) 
{ 
  register cmph_uint32 i ;
  register chd_ph_item_t *item ;
  register cmph_uint32 position ;

  {
#line 376
  item = items + (buckets + bucket_num)->items_list;
#line 378
  if (chd_ph->keys_per_bin > 1U) {
#line 380
    i = (cmph_uint32 )0;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i < size)) {
#line 380
        goto while_break;
      }
#line 382
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 383
      if ((cmph_uint32 )*(chd_ph->occup_table + position) >= chd_ph->keys_per_bin) {
#line 385
        goto while_break;
      }
#line 387
      *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) + 1);
#line 388
      item ++;
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 392
    i = (cmph_uint32 )0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (i < size)) {
#line 392
        goto while_break___0;
      }
#line 394
      position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 395
      if (*((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) & (unsigned int )bitmask32___29[position & 31U]) {
#line 397
        goto while_break___0;
      }
#line 399
      *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) |= (unsigned int )bitmask32___29[position & 31U];
#line 400
      item ++;
#line 392
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 403
  if (i != size) {
#line 405
    item = items + (buckets + bucket_num)->items_list;
#line 406
    if (chd_ph->keys_per_bin > 1U) {
      {
#line 408
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (i == 0U) {
#line 412
          goto while_break___1;
        }
#line 414
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 415
        *(chd_ph->occup_table + position) = (cmph_uint8 )((int )*(chd_ph->occup_table + position) - 1);
#line 416
        item ++;
#line 417
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 421
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 423
        if (i == 0U) {
#line 425
          goto while_break___2;
        }
#line 427
        position = (cmph_uint32 )((((cmph_uint64 )item->f + (cmph_uint64 )item->h * (cmph_uint64 )probe0_num) + (cmph_uint64 )probe1_num) % (unsigned long )chd_ph->n);
#line 428
        *((cmph_uint32 *)chd_ph->occup_table + (position >> 5)) ^= (unsigned int )bitmask32___29[position & 31U];
#line 431
        item ++;
#line 432
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 435
    return ((cmph_uint8 )0);
  }
#line 437
  return ((cmph_uint8 )1);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_bucket___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                            chd_ph_item_t *items , cmph_uint32 max_probes ,
                                            cmph_uint32 *disp_table , cmph_uint32 bucket_num ,
                                            cmph_uint32 size ) 
{ 
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  register cmph_uint32 probe_num ;
  cmph_uint8 tmp ;

  {
#line 445
  probe0_num = (cmph_uint32 )0;
#line 446
  probe1_num = (cmph_uint32 )0;
#line 447
  probe_num = (cmph_uint32 )0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 451
    tmp = place_bucket_probe___9(chd_ph, buckets, items, probe0_num, probe1_num, bucket_num,
                                 size);
    }
#line 451
    if (tmp) {
#line 453
      *(disp_table + (buckets + bucket_num)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
#line 454
      return ((cmph_uint8 )1);
    }
#line 456
    probe0_num ++;
#line 457
    if (probe0_num >= chd_ph->n) {
#line 459
      probe0_num -= chd_ph->n;
#line 460
      probe1_num ++;
    }
#line 462
    probe_num ++;
#line 463
    if (probe_num >= max_probes) {
#line 465
      return ((cmph_uint8 )0);
    } else
#line 463
    if (probe1_num >= chd_ph->n) {
#line 465
      return ((cmph_uint8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((cmph_uint8 )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets1___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 curr_bucket ;
  cmph_uint8 tmp ;

  {
#line 475
  i = (cmph_uint32 )0;
#line 476
  curr_bucket = (cmph_uint32 )0;
#line 478
  i = max_bucket_size;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i > 0U)) {
#line 478
      goto while_break;
    }
#line 480
    curr_bucket = (sorted_lists + i)->buckets_list;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! (curr_bucket < (sorted_lists + i)->size + (sorted_lists + i)->buckets_list)) {
#line 481
        goto while_break___0;
      }
      {
#line 483
      tmp = place_bucket___9(chd_ph, buckets, items, max_probes, disp_table, curr_bucket,
                             i);
      }
#line 483
      if (! tmp) {
#line 485
        return ((cmph_uint8 )0);
      }
#line 487
      curr_bucket ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return ((cmph_uint8 )1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
__inline static cmph_uint8 place_buckets2___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                              chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                              chd_ph_sorted_list_t *sorted_lists ,
                                              cmph_uint32 max_probes , cmph_uint32 *disp_table ) 
{ 
  register cmph_uint32 i ;
  register cmph_uint32 j ;
  register cmph_uint32 non_placed_bucket ;
  register cmph_uint32 curr_bucket ;
  register cmph_uint32 probe_num ;
  register cmph_uint32 probe0_num ;
  register cmph_uint32 probe1_num ;
  cmph_uint32 sorted_list_size ;
  cmph_uint8 tmp ;

  {
#line 506
  i = max_bucket_size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i > 0U)) {
#line 506
      goto while_break;
    }
#line 508
    probe_num = (cmph_uint32 )0;
#line 509
    probe0_num = (cmph_uint32 )0;
#line 510
    probe1_num = (cmph_uint32 )0;
#line 511
    sorted_list_size = (sorted_lists + i)->size;
    {
#line 512
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 512
      if (! ((sorted_lists + i)->size != 0U)) {
#line 512
        goto while_break___0;
      }
#line 514
      curr_bucket = (sorted_lists + i)->buckets_list;
#line 515
      j = (cmph_uint32 )0;
#line 515
      non_placed_bucket = (cmph_uint32 )0;
      {
#line 515
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 515
        if (! (j < (sorted_lists + i)->size)) {
#line 515
          goto while_break___1;
        }
        {
#line 518
        tmp = place_bucket_probe___9(chd_ph, buckets, items, probe0_num, probe1_num,
                                     curr_bucket, i);
        }
#line 518
        if (tmp) {
#line 520
          *(disp_table + (buckets + curr_bucket)->__annonCompField15.bucket_id) = probe0_num + probe1_num * chd_ph->n;
        } else {
#line 530
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->items_list = (buckets + curr_bucket)->items_list;
#line 531
          (buckets + (non_placed_bucket + (sorted_lists + i)->buckets_list))->__annonCompField15.bucket_id = (buckets + curr_bucket)->__annonCompField15.bucket_id;
#line 536
          non_placed_bucket ++;
        }
#line 538
        curr_bucket ++;
#line 515
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      (sorted_lists + i)->size = non_placed_bucket;
#line 541
      probe0_num ++;
#line 542
      if (probe0_num >= chd_ph->n) {
#line 544
        probe0_num -= chd_ph->n;
#line 545
        probe1_num ++;
      }
#line 547
      probe_num ++;
#line 548
      if (probe_num >= max_probes) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      } else
#line 548
      if (probe1_num >= chd_ph->n) {
#line 550
        (sorted_lists + i)->size = sorted_list_size;
#line 551
        return ((cmph_uint8 )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    (sorted_lists + i)->size = sorted_list_size;
#line 506
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return ((cmph_uint8 )1);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chd_ph.c"
static cmph_uint8 chd_ph_searching___9(chd_ph_config_data_t *chd_ph , chd_ph_bucket_t *buckets ,
                                       chd_ph_item_t *items , cmph_uint32 max_bucket_size ,
                                       chd_ph_sorted_list_t *sorted_lists , cmph_uint32 max_probes ,
                                       cmph_uint32 *disp_table ) 
{ 
  cmph_uint8 tmp ;
  cmph_uint8 tmp___0 ;

  {
#line 563
  if (chd_ph->use_h) {
    {
#line 565
    tmp = place_buckets2___9(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                             max_probes, disp_table);
    }
#line 565
    return (tmp);
  } else {
    {
#line 569
    tmp___0 = place_buckets1___9(chd_ph, buckets, items, max_bucket_size, sorted_lists,
                                 max_probes, disp_table);
    }
#line 569
    return (tmp___0);
  }
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_new___9(fch_bucket_t *bucket ) 
{ 


  {
#line 25
  if (! bucket) {
    {
#line 25
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  25U, "fch_bucket_new");
    }
  }
#line 26
  bucket->size = (cmph_uint32 )0;
#line 27
  bucket->entries = (fch_bucket_entry_t *)((void *)0);
#line 28
  bucket->capacity = (cmph_uint32 )0;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_destroy___9(fch_bucket_t *bucket ) 
{ 
  cmph_uint32 i ;

  {
#line 34
  if (! bucket) {
    {
#line 34
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  34U, "fch_bucket_destroy");
    }
  }
#line 35
  i = (cmph_uint32 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < bucket->size)) {
#line 35
      goto while_break;
    }
    {
#line 37
    free((void *)(bucket->entries + i)->value);
#line 35
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  free((void *)bucket->entries);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_reserve___9(fch_bucket_t *bucket , cmph_uint32 size ) 
{ 
  cmph_uint32 new_capacity ;
  void *tmp ;

  {
#line 45
  if (! bucket) {
    {
#line 45
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  45U, "fch_bucket_reserve");
    }
  }
#line 46
  if (bucket->capacity < size) {
#line 48
    new_capacity = bucket->capacity + 1U;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (new_capacity < size)) {
#line 50
        goto while_break;
      }
#line 52
      new_capacity *= 2U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 54
    tmp = realloc((void *)bucket->entries, sizeof(fch_bucket_entry_t ) * (unsigned long )new_capacity);
#line 54
    bucket->entries = (fch_bucket_entry_t *)tmp;
    }
#line 55
    if (! bucket->entries) {
      {
#line 55
      __assert_fail("bucket->entries", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                    55U, "fch_bucket_reserve");
      }
    }
#line 56
    bucket->capacity = new_capacity;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_insert___9(fch_bucket_t *bucket , char *val , cmph_uint32 val_length ) 
{ 


  {
#line 63
  if (! bucket) {
    {
#line 63
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  63U, "fch_bucket_insert");
    }
  }
  {
#line 64
  fch_bucket_reserve___9(bucket, bucket->size + 1U);
#line 65
  (bucket->entries + bucket->size)->value = val;
#line 66
  (bucket->entries + bucket->size)->length = val_length;
#line 67
  (bucket->size) ++;
  }
#line 68
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint8 fch_bucket_is_empty___9(fch_bucket_t *bucket ) 
{ 


  {
#line 73
  if (! bucket) {
    {
#line 73
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  73U, "fch_bucket_is_empty");
    }
  }
#line 74
  return ((cmph_uint8 )(bucket->size == 0U));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_size___9(fch_bucket_t *bucket ) 
{ 


  {
#line 79
  if (! bucket) {
    {
#line 79
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  79U, "fch_bucket_size");
    }
  }
#line 80
  return (bucket->size);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static char *fch_bucket_get_key___9(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 85
  if (! bucket) {
    {
#line 85
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 85
  if (! (index_key < bucket->size)) {
    {
#line 85
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  85U, "fch_bucket_get_key");
    }
  }
#line 86
  return ((bucket->entries + index_key)->value);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static cmph_uint32 fch_bucket_get_length___9(fch_bucket_t *bucket , cmph_uint32 index_key ) 
{ 


  {
#line 91
  if (! bucket) {
    {
#line 91
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 91
  if (! (index_key < bucket->size)) {
    {
#line 91
    __assert_fail("index_key < bucket->size", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  91U, "fch_bucket_get_length");
    }
  }
#line 92
  return ((bucket->entries + index_key)->length);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c"
static void fch_bucket_print___9(fch_bucket_t *bucket , cmph_uint32 index ) 
{ 
  cmph_uint32 i ;

  {
#line 98
  if (! bucket) {
    {
#line 98
    __assert_fail("bucket", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch_buckets.c",
                  98U, "fch_bucket_print");
    }
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Printing bucket %u ...\n",
          index);
#line 100
  i = (cmph_uint32 )0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < bucket->size)) {
#line 100
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  key: %s\n",
            (bucket->entries + i)->value);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___9(void *vector , cmph_uint32 nkeys ) ;
#line 51
static void cmph_io_vector_destroy___9(cmph_io_adapter_t *key_source ) ;
#line 53
static cmph_io_adapter_t *cmph_io_struct_vector_new___9(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) ;
#line 54
static void cmph_io_struct_vector_destroy___9(cmph_io_adapter_t *key_source ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_nlfile_read___9(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  FILE *fd ;
  char buf[8192] ;
  char *c ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 58
  fd = (FILE *)data;
#line 59
  *key = (char *)((void *)0);
#line 60
  *keylen = (cmph_uint32 )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 64
    c = tmp;
    }
#line 65
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 65
      return (-1);
    }
    {
#line 66
    tmp___0 = feof(fd);
    }
#line 66
    if (tmp___0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___1 = strlen((char const   *)(buf));
#line 67
    tmp___2 = realloc((void *)*key, ((size_t )*keylen + tmp___1) + 1UL);
#line 67
    *key = (char *)tmp___2;
#line 68
    tmp___3 = strlen((char const   *)(buf));
#line 68
    memcpy((void */* __restrict  */)(*key + *keylen), (void const   */* __restrict  */)(buf),
           tmp___3);
#line 69
    tmp___4 = strlen((char const   *)(buf));
#line 69
    *keylen += (cmph_uint32 )tmp___4;
#line 70
    tmp___5 = strlen((char const   *)(buf));
    }
#line 70
    if ((int )buf[tmp___5 - 1UL] != 10) {
#line 70
      goto while_continue;
    }
#line 71
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (*keylen) {
#line 73
    if ((int )*(*key + (*keylen - 1U)) == 10) {
#line 75
      *(*key + (*keylen - 1U)) = (char)0;
#line 76
      (*keylen) --;
    }
  }
#line 78
  return ((int )*keylen);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_byte_vector_read___9(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  cmph_uint8 **keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 83
  cmph_vector = (cmph_vector_t *)data;
#line 84
  keys_vd = (cmph_uint8 **)cmph_vector->vector;
#line 86
  memcpy((void */* __restrict  */)keylen, (void const   */* __restrict  */)*(keys_vd + cmph_vector->position),
         sizeof(*keylen));
#line 87
  size = (size_t )*keylen;
#line 88
  tmp = malloc(size);
#line 88
  *key = (char *)tmp;
#line 89
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)(*(keys_vd + cmph_vector->position) + sizeof(*keylen)),
         size);
#line 90
  (cmph_vector->position) ++;
  }
#line 91
  return ((int )*keylen);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_struct_vector_read___9(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;
  char *keys_vd ;
  size_t size ;
  void *tmp ;

  {
  {
#line 97
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 98
  keys_vd = (char *)cmph_struct_vector->vector;
#line 100
  *keylen = cmph_struct_vector->key_len;
#line 101
  size = (size_t )*keylen;
#line 102
  tmp = malloc(size);
#line 102
  *key = (char *)tmp;
#line 103
  memcpy((void */* __restrict  */)*key, (void const   */* __restrict  */)((keys_vd + cmph_struct_vector->position * cmph_struct_vector->struct_size) + cmph_struct_vector->key_offset),
         size);
#line 104
  (cmph_struct_vector->position) ++;
  }
#line 105
  return ((int )*keylen);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static int key_vector_read___9(void *data , char **key , cmph_uint32 *keylen ) 
{ 
  cmph_vector_t *cmph_vector ;
  char **keys_vd ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 110
  cmph_vector = (cmph_vector_t *)data;
#line 111
  keys_vd = (char **)cmph_vector->vector;
#line 113
  tmp = strlen((char const   *)*(keys_vd + cmph_vector->position));
#line 113
  *keylen = (cmph_uint32 )tmp;
#line 114
  size = (size_t )*keylen;
#line 115
  tmp___0 = malloc(size + 1UL);
#line 115
  *key = (char *)tmp___0;
#line 116
  strcpy((char */* __restrict  */)*key, (char const   */* __restrict  */)*(keys_vd + cmph_vector->position));
#line 117
  (cmph_vector->position) ++;
  }
#line 118
  return ((int )*keylen);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_dispose___9(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 125
  free((void *)key);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_dispose___9(void *data , char *key , cmph_uint32 keylen ) 
{ 


  {
  {
#line 130
  free((void *)key);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_nlfile_rewind___9(void *data ) 
{ 
  FILE *fd ;

  {
  {
#line 135
  fd = (FILE *)data;
#line 136
  rewind(fd);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_struct_vector_rewind___9(void *data ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
#line 141
  cmph_struct_vector = (cmph_struct_vector_t *)data;
#line 142
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void key_vector_rewind___9(void *data ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
#line 147
  cmph_vector = (cmph_vector_t *)data;
#line 148
  cmph_vector->position = (cmph_uint32 )0;
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_uint32 count_nlfile_keys___9(FILE *fd ) 
{ 
  cmph_uint32 count ;
  register char *ptr ;
  char buf[8192] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 153
  count = (cmph_uint32 )0;
#line 155
  rewind(fd);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ptr = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)fd);
#line 160
    tmp = feof(fd);
    }
#line 160
    if (tmp) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
    }
#line 161
    if ((int )buf[tmp___0 - 1UL] != 10) {
#line 161
      goto while_continue;
    }
#line 162
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  rewind(fd);
  }
#line 165
  return (count);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_struct_vector_new___9(void *vector , cmph_uint32 struct_size ,
                                                        cmph_uint32 key_offset , cmph_uint32 key_len ,
                                                        cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_struct_vector_t *cmph_struct_vector ;
  void *tmp___0 ;

  {
  {
#line 205
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 205
  key_source = (cmph_io_adapter_t *)tmp;
#line 206
  tmp___0 = malloc(sizeof(cmph_struct_vector_t ));
#line 206
  cmph_struct_vector = (cmph_struct_vector_t *)tmp___0;
  }
#line 207
  if (! key_source) {
    {
#line 207
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  207U, "cmph_io_struct_vector_new");
    }
  }
#line 208
  if (! cmph_struct_vector) {
    {
#line 208
    __assert_fail("cmph_struct_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  208U, "cmph_io_struct_vector_new");
    }
  }
#line 209
  cmph_struct_vector->vector = vector;
#line 210
  cmph_struct_vector->position = (cmph_uint32 )0;
#line 211
  cmph_struct_vector->struct_size = struct_size;
#line 212
  cmph_struct_vector->key_offset = key_offset;
#line 213
  cmph_struct_vector->key_len = key_len;
#line 214
  key_source->data = (void *)cmph_struct_vector;
#line 215
  key_source->nkeys = nkeys;
#line 216
  return (key_source);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_struct_vector_destroy___9(cmph_io_adapter_t *key_source ) 
{ 
  cmph_struct_vector_t *cmph_struct_vector ;

  {
  {
#line 221
  cmph_struct_vector = (cmph_struct_vector_t *)key_source->data;
#line 222
  cmph_struct_vector->vector = (void *)0;
#line 223
  free((void *)cmph_struct_vector);
#line 224
  free((void *)key_source);
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static cmph_io_adapter_t *cmph_io_vector_new___9(void *vector , cmph_uint32 nkeys ) 
{ 
  cmph_io_adapter_t *key_source ;
  void *tmp ;
  cmph_vector_t *cmph_vector ;
  void *tmp___0 ;

  {
  {
#line 229
  tmp = malloc(sizeof(cmph_io_adapter_t ));
#line 229
  key_source = (cmph_io_adapter_t *)tmp;
#line 230
  tmp___0 = malloc(sizeof(cmph_vector_t ));
#line 230
  cmph_vector = (cmph_vector_t *)tmp___0;
  }
#line 231
  if (! key_source) {
    {
#line 231
    __assert_fail("key_source", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  231U, "cmph_io_vector_new");
    }
  }
#line 232
  if (! cmph_vector) {
    {
#line 232
    __assert_fail("cmph_vector", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c",
                  232U, "cmph_io_vector_new");
    }
  }
#line 233
  cmph_vector->vector = vector;
#line 234
  cmph_vector->position = (cmph_uint32 )0;
#line 235
  key_source->data = (void *)cmph_vector;
#line 236
  key_source->nkeys = nkeys;
#line 237
  return (key_source);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/cmph.c"
static void cmph_io_vector_destroy___9(cmph_io_adapter_t *key_source ) 
{ 
  cmph_vector_t *cmph_vector ;

  {
  {
#line 242
  cmph_vector = (cmph_vector_t *)key_source->data;
#line 243
  cmph_vector->vector = (void *)0;
#line 244
  free((void *)cmph_vector);
#line 245
  free((void *)key_source);
  }
#line 246
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___9(cmph_config_t *mph ) ;
#line 23
static cmph_uint32 brz_min_index___9(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 24
static void brz_destroy_keys_vd___9(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) ;
#line 25
static char *brz_copy_partial_fch_mphf___9(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 26
static char *brz_copy_partial_bmz8_mphf___9(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static int brz_gen_mphf___9(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 e ;
  cmph_uint32 error ;
  brz_config_data_t *brz ;
  cmph_uint32 memory_usage ;
  cmph_uint32 nkeys_in_buffer ;
  cmph_uint8 *buffer ;
  void *tmp ;
  cmph_uint32 *buckets_size ;
  void *tmp___0 ;
  cmph_uint32 *keys_index ;
  cmph_uint8 **buffer_merge ;
  cmph_uint32 *buffer_h0 ;
  cmph_uint32 nflushes ;
  cmph_uint32 h0 ;
  register size_t nbytes ;
  FILE *tmp_fd ;
  buffer_manager_t *buff_manager ;
  char *filename ;
  char *key ;
  cmph_uint32 keylen ;
  cmph_uint32 cur_bucket ;
  cmph_uint8 nkeys_vd ;
  cmph_uint8 **keys_vd ;
  cmph_uint32 value ;
  cmph_uint32 sum ;
  cmph_uint32 keylen1 ;
  void *tmp___1 ;
  cmph_uint32 tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 value___0 ;
  cmph_uint32 sum___0 ;
  cmph_uint32 keylen1___0 ;
  void *tmp___6 ;
  cmph_uint32 tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  cmph_uint8 *tmp___15 ;
  cmph_uint32 tmp___16 ;
  void *tmp___17 ;
  cmph_uint8 *tmp___18 ;
  cmph_uint32 tmp___19 ;
  cmph_uint8 tmp___20 ;
  cmph_uint8 *tmp___21 ;
  cmph_uint8 tmp___22 ;
  cmph_uint8 tmp___23 ;
  cmph_io_adapter_t *source ;
  cmph_config_t *config ;
  cmph_t *mphf_tmp ;
  char *bufmphf ;
  cmph_uint32 buflenmphf ;
  fch_data_t *fchf ;
  bmz8_data_t *bmzf ;

  {
  {
#line 224
  brz = (brz_config_data_t *)mph->data;
#line 225
  memory_usage = (cmph_uint32 )0;
#line 226
  nkeys_in_buffer = (cmph_uint32 )0;
#line 227
  tmp = malloc((size_t )brz->memory_availability);
#line 227
  buffer = (cmph_uint8 *)tmp;
#line 228
  tmp___0 = calloc((size_t )brz->k, sizeof(cmph_uint32 ));
#line 228
  buckets_size = (cmph_uint32 *)tmp___0;
#line 229
  keys_index = (cmph_uint32 *)((void *)0);
#line 230
  buffer_merge = (cmph_uint8 **)((void *)0);
#line 231
  buffer_h0 = (cmph_uint32 *)((void *)0);
#line 232
  nflushes = (cmph_uint32 )0;
#line 235
  tmp_fd = (FILE *)((void *)0);
#line 236
  buff_manager = (buffer_manager_t *)((void *)0);
#line 237
  filename = (char *)((void *)0);
#line 238
  key = (char *)((void *)0);
#line 240
  cur_bucket = (cmph_uint32 )0;
#line 241
  nkeys_vd = (cmph_uint8 )0;
#line 242
  keys_vd = (cmph_uint8 **)((void *)0);
#line 244
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 247
  e = (cmph_uint32 )0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (e < brz->m)) {
#line 247
      goto while_break;
    }
    {
#line 249
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
    }
#line 252
    if ((unsigned long )(memory_usage + keylen) + sizeof(keylen) > (unsigned long )brz->memory_availability) {
#line 254
      if (mph->verbosity) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
                nkeys_in_buffer);
        }
      }
#line 258
      value = *(buckets_size + 0);
#line 259
      sum = (cmph_uint32 )0;
#line 260
      keylen1 = (cmph_uint32 )0;
#line 261
      *(buckets_size + 0) = (cmph_uint32 )0;
#line 262
      i = (cmph_uint32 )1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i < brz->k)) {
#line 262
          goto while_break___0;
        }
#line 264
        if (*(buckets_size + i) == 0U) {
#line 264
          goto __Cont;
        }
#line 265
        sum += value;
#line 266
        value = *(buckets_size + i);
#line 267
        *(buckets_size + i) = sum;
        __Cont: /* CIL Label */ 
#line 262
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 270
      memory_usage = (cmph_uint32 )0;
#line 271
      tmp___1 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 271
      keys_index = (cmph_uint32 *)tmp___1;
#line 272
      i = (cmph_uint32 )0;
      }
      {
#line 272
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 272
        if (! (i < nkeys_in_buffer)) {
#line 272
          goto while_break___1;
        }
        {
#line 274
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + memory_usage),
               sizeof(keylen1));
#line 275
        tmp___2 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1))),
                       keylen1);
#line 275
        h0 = tmp___2 % brz->k;
#line 276
        *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 277
        (*(buckets_size + h0)) ++;
#line 278
        memory_usage += keylen1 + (cmph_uint32 )sizeof(keylen1);
#line 272
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 280
      tmp___3 = strlen((char const   *)((char *)brz->tmp_dir));
#line 280
      tmp___4 = calloc(tmp___3 + 11UL, sizeof(char ));
#line 280
      filename = (char *)tmp___4;
#line 281
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
              brz->tmp_dir, nflushes);
#line 282
      tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 283
      free((void *)filename);
#line 284
      filename = (char *)((void *)0);
#line 285
      i = (cmph_uint32 )0;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! (i < nkeys_in_buffer)) {
#line 285
          goto while_break___2;
        }
        {
#line 287
        memcpy((void */* __restrict  */)(& keylen1), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
               sizeof(keylen1));
#line 288
        nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                        (size_t )1, (unsigned long )keylen1 + sizeof(keylen1), (FILE */* __restrict  */)tmp_fd);
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 290
      nkeys_in_buffer = (cmph_uint32 )0;
#line 291
      memory_usage = (cmph_uint32 )0;
#line 292
      memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 293
      nflushes ++;
#line 294
      free((void *)keys_index);
#line 295
      fclose(tmp_fd);
      }
    }
    {
#line 297
    memcpy((void */* __restrict  */)(buffer + memory_usage), (void const   */* __restrict  */)(& keylen),
           sizeof(keylen));
#line 298
    memcpy((void */* __restrict  */)((buffer + memory_usage) + sizeof(keylen)), (void const   */* __restrict  */)key,
           (size_t )keylen);
#line 299
    memory_usage += keylen + (cmph_uint32 )sizeof(keylen);
#line 300
    tmp___5 = hash(brz->h0, (char const   *)key, keylen);
#line 300
    h0 = tmp___5 % brz->k;
    }
#line 302
    if ((int )*(brz->size + h0) == 255) {
      {
#line 304
      free((void *)buffer);
#line 305
      free((void *)buckets_size);
      }
#line 306
      return (0);
    } else
#line 302
    if ((unsigned int )brz->algo == 1U) {
#line 302
      if (brz->c >= 1.0) {
#line 302
        if ((int )((cmph_uint8 )(brz->c * (double )*(brz->size + h0))) < (int )*(brz->size + h0)) {
          {
#line 304
          free((void *)buffer);
#line 305
          free((void *)buckets_size);
          }
#line 306
          return (0);
        }
      }
    }
    {
#line 308
    *(brz->size + h0) = (cmph_uint8 )((unsigned int )*(brz->size + h0) + 1U);
#line 309
    (*(buckets_size + h0)) ++;
#line 310
    nkeys_in_buffer ++;
#line 311
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 247
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  if (memory_usage != 0U) {
#line 315
    if (mph->verbosity) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flushing  %u\n",
              nkeys_in_buffer);
      }
    }
#line 319
    value___0 = *(buckets_size + 0);
#line 320
    sum___0 = (cmph_uint32 )0;
#line 321
    keylen1___0 = (cmph_uint32 )0;
#line 322
    *(buckets_size + 0) = (cmph_uint32 )0;
#line 323
    i = (cmph_uint32 )1;
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      if (! (i < brz->k)) {
#line 323
        goto while_break___3;
      }
#line 325
      if (*(buckets_size + i) == 0U) {
#line 325
        goto __Cont___0;
      }
#line 326
      sum___0 += value___0;
#line 327
      value___0 = *(buckets_size + i);
#line 328
      *(buckets_size + i) = sum___0;
      __Cont___0: /* CIL Label */ 
#line 323
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 330
    memory_usage = (cmph_uint32 )0;
#line 331
    tmp___6 = calloc((size_t )nkeys_in_buffer, sizeof(cmph_uint32 ));
#line 331
    keys_index = (cmph_uint32 *)tmp___6;
#line 332
    i = (cmph_uint32 )0;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < nkeys_in_buffer)) {
#line 332
        goto while_break___4;
      }
      {
#line 334
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + memory_usage),
             sizeof(keylen1___0));
#line 335
      tmp___7 = hash(brz->h0, (char const   *)((char *)((buffer + memory_usage) + sizeof(keylen1___0))),
                     keylen1___0);
#line 335
      h0 = tmp___7 % brz->k;
#line 336
      *(keys_index + *(buckets_size + h0)) = memory_usage;
#line 337
      (*(buckets_size + h0)) ++;
#line 338
      memory_usage += keylen1___0 + (cmph_uint32 )sizeof(keylen1___0);
#line 332
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 340
    tmp___8 = strlen((char const   *)((char *)brz->tmp_dir));
#line 340
    tmp___9 = calloc(tmp___8 + 11UL, sizeof(char ));
#line 340
    filename = (char *)tmp___9;
#line 341
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, nflushes);
#line 342
    tmp_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 343
    free((void *)filename);
#line 344
    filename = (char *)((void *)0);
#line 345
    i = (cmph_uint32 )0;
    }
    {
#line 345
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 345
      if (! (i < nkeys_in_buffer)) {
#line 345
        goto while_break___5;
      }
      {
#line 347
      memcpy((void */* __restrict  */)(& keylen1___0), (void const   */* __restrict  */)(buffer + *(keys_index + i)),
             sizeof(keylen1___0));
#line 348
      nbytes = fwrite((void const   */* __restrict  */)(buffer + *(keys_index + i)),
                      (size_t )1, (unsigned long )keylen1___0 + sizeof(keylen1___0),
                      (FILE */* __restrict  */)tmp_fd);
#line 345
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 350
    nkeys_in_buffer = (cmph_uint32 )0;
#line 351
    memory_usage = (cmph_uint32 )0;
#line 352
    memset((void *)buckets_size, 0, (unsigned long )brz->k * sizeof(cmph_uint32 ));
#line 353
    nflushes ++;
#line 354
    free((void *)keys_index);
#line 355
    fclose(tmp_fd);
    }
  }
  {
#line 358
  free((void *)buffer);
#line 359
  free((void *)buckets_size);
  }
#line 360
  if (nflushes > 1024U) {
#line 360
    return (0);
  }
#line 362
  if (mph->verbosity) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPHF generation \n");
    }
  }
  {
#line 367
  tmp___10 = strlen(cmph_names[3]);
#line 367
  nbytes = fwrite((void const   */* __restrict  */)cmph_names[3], tmp___10 + 1UL,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 368
  nbytes = fwrite((void const   */* __restrict  */)(& brz->m), sizeof(brz->m), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 369
  nbytes = fwrite((void const   */* __restrict  */)(& brz->c), sizeof(double ), (size_t )1,
                  (FILE */* __restrict  */)brz->mphf_fd);
#line 370
  nbytes = fwrite((void const   */* __restrict  */)(& brz->algo), sizeof(brz->algo),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 371
  nbytes = fwrite((void const   */* __restrict  */)(& brz->k), sizeof(cmph_uint32 ),
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 372
  nbytes = fwrite((void const   */* __restrict  */)brz->size, sizeof(cmph_uint8 ) * (unsigned long )brz->k,
                  (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 375
  buff_manager = buffer_manager_new(brz->memory_availability, nflushes);
#line 376
  tmp___11 = calloc((size_t )nflushes, sizeof(cmph_uint8 *));
#line 376
  buffer_merge = (cmph_uint8 **)tmp___11;
#line 377
  tmp___12 = calloc((size_t )nflushes, sizeof(cmph_uint32 ));
#line 377
  buffer_h0 = (cmph_uint32 *)tmp___12;
#line 379
  memory_usage = (cmph_uint32 )0;
#line 380
  i = (cmph_uint32 )0;
  }
  {
#line 380
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 380
    if (! (i < nflushes)) {
#line 380
      goto while_break___6;
    }
    {
#line 382
    tmp___13 = strlen((char const   *)((char *)brz->tmp_dir));
#line 382
    tmp___14 = calloc(tmp___13 + 11UL, sizeof(char ));
#line 382
    filename = (char *)tmp___14;
#line 383
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%u.cmph",
            brz->tmp_dir, i);
#line 384
    buffer_manager_open(buff_manager, i, filename);
#line 385
    free((void *)filename);
#line 386
    filename = (char *)((void *)0);
#line 387
    tmp___15 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 387
    key = (char *)tmp___15;
#line 388
    tmp___16 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 388
    h0 = tmp___16 % brz->k;
#line 389
    *(buffer_h0 + i) = h0;
#line 390
    *(buffer_merge + i) = (cmph_uint8 *)key;
#line 391
    key = (char *)((void *)0);
#line 380
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 393
  e = (cmph_uint32 )0;
#line 394
  tmp___17 = calloc((size_t )255, sizeof(cmph_uint8 *));
#line 394
  keys_vd = (cmph_uint8 **)tmp___17;
#line 395
  nkeys_vd = (cmph_uint8 )0;
#line 396
  error = (cmph_uint32 )0;
  }
  {
#line 397
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 397
    if (! (e < brz->m)) {
#line 397
      goto while_break___7;
    }
    {
#line 399
    i = brz_min_index___9(buffer_h0, nflushes);
#line 400
    cur_bucket = *(buffer_h0 + i);
#line 401
    tmp___18 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 401
    key = (char *)tmp___18;
    }
#line 402
    if (key) {
      {
#line 404
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 404
        if (! key) {
#line 404
          goto while_break___8;
        }
        {
#line 407
        tmp___19 = hash(brz->h0, (char const   *)(key + sizeof(keylen)), keylen);
#line 407
        h0 = tmp___19 % brz->k;
        }
#line 408
        if (h0 != *(buffer_h0 + i)) {
#line 408
          goto while_break___8;
        }
        {
#line 409
        tmp___20 = nkeys_vd;
#line 409
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 409
        *(keys_vd + tmp___20) = (cmph_uint8 *)key;
#line 410
        key = (char *)((void *)0);
#line 411
        e ++;
#line 412
        tmp___21 = buffer_manager_read_key(buff_manager, i, & keylen);
#line 412
        key = (char *)tmp___21;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 414
      if (key) {
#line 416
        if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
          {
#line 416
          __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                        416U, "brz_gen_mphf");
          }
        }
#line 417
        tmp___22 = nkeys_vd;
#line 417
        nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 417
        *(keys_vd + tmp___22) = *(buffer_merge + i);
#line 418
        *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 419
        e ++;
#line 420
        *(buffer_h0 + i) = h0;
#line 421
        *(buffer_merge + i) = (cmph_uint8 *)key;
      }
    }
#line 424
    if (! key) {
#line 426
      if (! ((int )nkeys_vd < (int )*(brz->size + cur_bucket))) {
        {
#line 426
        __assert_fail("nkeys_vd < brz->size[cur_bucket]", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                      426U, "brz_gen_mphf");
        }
      }
#line 427
      tmp___23 = nkeys_vd;
#line 427
      nkeys_vd = (cmph_uint8 )((int )nkeys_vd + 1);
#line 427
      *(keys_vd + tmp___23) = *(buffer_merge + i);
#line 428
      *(buffer_merge + i) = (cmph_uint8 *)((void *)0);
#line 429
      e ++;
#line 430
      *(buffer_h0 + i) = 4294967295U;
    }
#line 433
    if ((int )nkeys_vd == (int )*(brz->size + cur_bucket)) {
      {
#line 435
      source = (cmph_io_adapter_t *)((void *)0);
#line 436
      config = (cmph_config_t *)((void *)0);
#line 437
      mphf_tmp = (cmph_t *)((void *)0);
#line 438
      bufmphf = (char *)((void *)0);
#line 439
      buflenmphf = (cmph_uint32 )0;
#line 441
      source = cmph_io_byte_vector_adapter(keys_vd, (cmph_uint32 )nkeys_vd);
#line 442
      config = cmph_config_new(source);
#line 443
      cmph_config_set_algo(config, brz->algo);
#line 445
      cmph_config_set_graphsize(config, brz->c);
#line 446
      mphf_tmp = cmph_new(config);
      }
#line 447
      if ((unsigned long )mphf_tmp == (unsigned long )((void *)0)) {
#line 449
        if (mph->verbosity) {
          {
#line 449
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Can\'t generate MPHF for bucket %u out of %u\n",
                  cur_bucket + 1U, brz->k);
          }
        }
        {
#line 450
        error = (cmph_uint32 )1;
#line 451
        cmph_config_destroy(config);
#line 452
        brz_destroy_keys_vd___9(keys_vd, (cmph_uint32 )nkeys_vd);
#line 453
        cmph_io_byte_vector_adapter_destroy(source);
        }
#line 454
        goto while_break___7;
      }
#line 456
      if (mph->verbosity) {
#line 458
        if (cur_bucket % 1000U == 0U) {
          {
#line 460
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPHF for bucket %u out of %u was generated.\n",
                  cur_bucket + 1U, brz->k);
          }
        }
      }
      {
#line 465
      if ((unsigned int )brz->algo == 4U) {
#line 465
        goto case_4;
      }
#line 472
      if ((unsigned int )brz->algo == 1U) {
#line 472
        goto case_1;
      }
#line 479
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 467
      fchf = (fch_data_t *)((void *)0);
#line 468
      fchf = (fch_data_t *)mphf_tmp->data;
#line 469
      bufmphf = brz_copy_partial_fch_mphf___9(brz, fchf, cur_bucket, & buflenmphf);
      }
#line 471
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 474
      bmzf = (bmz8_data_t *)((void *)0);
#line 475
      bmzf = (bmz8_data_t *)mphf_tmp->data;
#line 476
      bufmphf = brz_copy_partial_bmz8_mphf___9(brz, bmzf, cur_bucket, & buflenmphf);
      }
#line 478
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c",
                    479U, "brz_gen_mphf");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 481
      nbytes = fwrite((void const   */* __restrict  */)bufmphf, (size_t )buflenmphf,
                      (size_t )1, (FILE */* __restrict  */)brz->mphf_fd);
#line 482
      free((void *)bufmphf);
#line 483
      bufmphf = (char *)((void *)0);
#line 484
      cmph_config_destroy(config);
#line 485
      brz_destroy_keys_vd___9(keys_vd, (cmph_uint32 )nkeys_vd);
#line 486
      cmph_destroy(mphf_tmp);
#line 487
      cmph_io_byte_vector_adapter_destroy(source);
#line 488
      nkeys_vd = (cmph_uint8 )0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 491
  buffer_manager_destroy(buff_manager);
#line 492
  free((void *)keys_vd);
#line 493
  free((void *)buffer_merge);
#line 494
  free((void *)buffer_h0);
  }
#line 495
  if (error) {
#line 495
    return (0);
  }
#line 496
  return (1);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_min_index___9(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 min_index ;

  {
#line 501
  min_index = (cmph_uint32 )0;
#line 502
  i = (cmph_uint32 )1;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < n)) {
#line 502
      goto while_break;
    }
#line 504
    if (*(vector + i) < *(vector + min_index)) {
#line 504
      min_index = i;
    }
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 506
  return (min_index);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static void brz_destroy_keys_vd___9(cmph_uint8 **keys_vd , cmph_uint32 nkeys ) 
{ 
  cmph_uint8 i ;

  {
#line 512
  i = (cmph_uint8 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! ((cmph_uint32 )i < nkeys)) {
#line 512
      goto while_break;
    }
    {
#line 512
    free((void *)*(keys_vd + i));
#line 512
    *(keys_vd + i) = (cmph_uint8 *)((void *)0);
#line 512
    i = (cmph_uint8 )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_fch_mphf___9(brz_config_data_t *brz , fch_data_t *fchf ,
                                           cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  void *tmp ;

  {
  {
#line 517
  i = (cmph_uint32 )0;
#line 518
  buflenh1 = (cmph_uint32 )0;
#line 519
  buflenh2 = (cmph_uint32 )0;
#line 520
  bufh1 = (char *)((void *)0);
#line 521
  bufh2 = (char *)((void *)0);
#line 522
  buf = (char *)((void *)0);
#line 523
  n = fchf->b;
#line 524
  hash_state_dump(fchf->h1, & bufh1, & buflenh1);
#line 525
  hash_state_dump(fchf->h2, & bufh2, & buflenh2);
#line 526
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 527
  tmp = malloc((size_t )*buflen);
#line 527
  buf = (char *)tmp;
#line 528
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 529
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 530
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 531
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 532
  i = (cmph_uint32 )0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < n)) {
#line 532
      goto while_break;
    }
    {
#line 532
    memcpy((void */* __restrict  */)((((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2) + i),
           (void const   */* __restrict  */)(fchf->g + i), (size_t )1);
#line 532
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  free((void *)bufh1);
#line 534
  free((void *)bufh2);
  }
#line 535
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static char *brz_copy_partial_bmz8_mphf___9(brz_config_data_t *brz , bmz8_data_t *bmzf ,
                                            cmph_uint32 index___0 , cmph_uint32 *buflen ) 
{ 
  cmph_uint32 buflenh1 ;
  cmph_uint32 buflenh2 ;
  char *bufh1 ;
  char *bufh2 ;
  char *buf ;
  cmph_uint32 n ;
  double tmp ;
  void *tmp___0 ;

  {
  {
#line 539
  buflenh1 = (cmph_uint32 )0;
#line 540
  buflenh2 = (cmph_uint32 )0;
#line 541
  bufh1 = (char *)((void *)0);
#line 542
  bufh2 = (char *)((void *)0);
#line 543
  buf = (char *)((void *)0);
#line 544
  tmp = ceil(brz->c * (double )*(brz->size + index___0));
#line 544
  n = (cmph_uint32 )tmp;
#line 545
  hash_state_dump(*(bmzf->hashes + 0), & bufh1, & buflenh1);
#line 546
  hash_state_dump(*(bmzf->hashes + 1), & bufh2, & buflenh2);
#line 547
  *buflen = ((buflenh1 + buflenh2) + n) + 2U * (cmph_uint32 )sizeof(cmph_uint32 );
#line 548
  tmp___0 = malloc((size_t )*buflen);
#line 548
  buf = (char *)tmp___0;
#line 549
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(& buflenh1),
         sizeof(cmph_uint32 ));
#line 550
  memcpy((void */* __restrict  */)(buf + sizeof(cmph_uint32 )), (void const   */* __restrict  */)bufh1,
         (size_t )buflenh1);
#line 551
  memcpy((void */* __restrict  */)((buf + sizeof(cmph_uint32 )) + buflenh1), (void const   */* __restrict  */)(& buflenh2),
         sizeof(cmph_uint32 ));
#line 552
  memcpy((void */* __restrict  */)((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1),
         (void const   */* __restrict  */)bufh2, (size_t )buflenh2);
#line 553
  memcpy((void */* __restrict  */)(((buf + 2UL * sizeof(cmph_uint32 )) + buflenh1) + buflenh2),
         (void const   */* __restrict  */)bmzf->g, (size_t )n);
#line 554
  free((void *)bufh1);
#line 555
  free((void *)bufh2);
  }
#line 556
  return (buf);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search___9(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                       cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___1 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 649
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 650
  h0 = *(fingerprint + 2) % brz->k;
#line 652
  m = (cmph_uint32 )*(brz->size + h0);
#line 653
  tmp = ceil(brz->c * (double )m);
#line 653
  n = (cmph_uint32 )tmp;
#line 654
  tmp___0 = hash(*(brz->h1 + h0), key, keylen);
#line 654
  h1 = tmp___0 % n;
#line 655
  tmp___1 = hash(*(brz->h2 + h0), key, keylen);
#line 655
  h2 = tmp___1 % n;
  }
#line 658
  if (h1 == h2) {
#line 658
    h2 ++;
#line 658
    if (h2 >= n) {
#line 658
      h2 = (cmph_uint32 )0;
    }
  }
#line 659
  mphf_bucket = (cmph_uint8 )((int )*(*(brz->g + h0) + h1) + (int )*(*(brz->g + h0) + h2));
#line 663
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search___9(brz_data_t *brz , char const   *key , cmph_uint32 keylen ,
                                      cmph_uint32 *fingerprint ) 
{ 
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp ;
  register double p1 ;
  double tmp___0 ;
  register double p2 ;
  double tmp___1 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___2 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___3 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 670
  hash_vector(brz->h0, key, keylen, fingerprint);
#line 671
  h0 = *(fingerprint + 2) % brz->k;
#line 673
  m = (cmph_uint32 )*(brz->size + h0);
#line 674
  tmp = fch_calc_b(brz->c, m);
#line 674
  b = tmp;
#line 675
  tmp___0 = fch_calc_p1(m);
#line 675
  p1 = tmp___0;
#line 676
  tmp___1 = fch_calc_p2(b);
#line 676
  p2 = tmp___1;
#line 677
  tmp___2 = hash(*(brz->h1 + h0), key, keylen);
#line 677
  h1 = tmp___2 % m;
#line 678
  tmp___3 = hash(*(brz->h2 + h0), key, keylen);
#line 678
  h2 = tmp___3 % m;
#line 679
  mphf_bucket = (cmph_uint8 )0;
#line 680
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 681
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(*(brz->g + h0) + h1)) % m);
  }
#line 682
  return ((cmph_uint32 )mphf_bucket + *(brz->offset + h0));
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_bmz8_search_packed___9(cmph_uint32 *packed_mphf , char const   *key ,
                                              cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 n ;
  double tmp___4 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___5 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___6 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___7 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___8 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 860
  tmp = packed_mphf;
#line 860
  packed_mphf ++;
#line 860
  h0_type = (CMPH_HASH )*tmp;
#line 861
  h0_ptr = packed_mphf;
#line 862
  tmp___0 = hash_state_packed_size(h0_type);
#line 862
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 864
  tmp___1 = packed_mphf;
#line 864
  packed_mphf ++;
#line 864
  k = *tmp___1;
#line 866
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 867
  packed_mphf += 2;
#line 869
  tmp___2 = packed_mphf;
#line 869
  packed_mphf ++;
#line 869
  h1_type = (CMPH_HASH )*tmp___2;
#line 871
  tmp___3 = packed_mphf;
#line 871
  packed_mphf ++;
#line 871
  h2_type = (CMPH_HASH )*tmp___3;
#line 873
  size = (cmph_uint8 *)packed_mphf;
#line 874
  packed_mphf = (cmph_uint32 *)(size + k);
#line 876
  offset = packed_mphf;
#line 877
  packed_mphf += k;
#line 881
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 882
  h0 = *(fingerprint + 2) % k;
#line 884
  m = (cmph_uint32 )*(size + h0);
#line 885
  tmp___4 = ceil(c * (double )m);
#line 885
  n = (cmph_uint32 )tmp___4;
#line 888
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 893
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 895
  tmp___5 = hash_state_packed_size(h1_type);
#line 895
  h2_ptr = h1_ptr + tmp___5;
#line 897
  tmp___6 = hash_state_packed_size(h2_type);
#line 897
  g = h2_ptr + tmp___6;
#line 899
  tmp___7 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 899
  h1 = tmp___7 % n;
#line 900
  tmp___8 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 900
  h2 = tmp___8 % n;
  }
#line 904
  if (h1 == h2) {
#line 904
    h2 ++;
#line 904
    if (h2 >= n) {
#line 904
      h2 = (cmph_uint32 )0;
    }
  }
#line 905
  mphf_bucket = (cmph_uint8 )((int )*(g + h1) + (int )*(g + h2));
#line 908
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/brz.c"
static cmph_uint32 brz_fch_search_packed___9(cmph_uint32 *packed_mphf , char const   *key ,
                                             cmph_uint32 keylen , cmph_uint32 *fingerprint ) 
{ 
  register CMPH_HASH h0_type ;
  cmph_uint32 *tmp ;
  register cmph_uint32 *h0_ptr ;
  cmph_uint32 tmp___0 ;
  register cmph_uint32 k ;
  cmph_uint32 *tmp___1 ;
  register double c ;
  register CMPH_HASH h1_type ;
  cmph_uint32 *tmp___2 ;
  register CMPH_HASH h2_type ;
  cmph_uint32 *tmp___3 ;
  register cmph_uint8 *size ;
  register cmph_uint32 *offset ;
  register cmph_uint32 h0 ;
  register cmph_uint32 m ;
  register cmph_uint32 b ;
  cmph_uint32 tmp___4 ;
  register double p1 ;
  double tmp___5 ;
  register double p2 ;
  double tmp___6 ;
  register cmph_uint64 *g_is_ptr ;
  register cmph_uint8 *h1_ptr ;
  register cmph_uint8 *h2_ptr ;
  cmph_uint32 tmp___7 ;
  register cmph_uint8 *g ;
  cmph_uint32 tmp___8 ;
  register cmph_uint32 h1 ;
  cmph_uint32 tmp___9 ;
  register cmph_uint32 h2 ;
  cmph_uint32 tmp___10 ;
  register cmph_uint8 mphf_bucket ;

  {
  {
#line 913
  tmp = packed_mphf;
#line 913
  packed_mphf ++;
#line 913
  h0_type = (CMPH_HASH )*tmp;
#line 915
  h0_ptr = packed_mphf;
#line 916
  tmp___0 = hash_state_packed_size(h0_type);
#line 916
  packed_mphf = (cmph_uint32 *)((cmph_uint8 *)packed_mphf + tmp___0);
#line 918
  tmp___1 = packed_mphf;
#line 918
  packed_mphf ++;
#line 918
  k = *tmp___1;
#line 920
  c = (double )*((cmph_uint64 *)packed_mphf);
#line 921
  packed_mphf += 2;
#line 923
  tmp___2 = packed_mphf;
#line 923
  packed_mphf ++;
#line 923
  h1_type = (CMPH_HASH )*tmp___2;
#line 925
  tmp___3 = packed_mphf;
#line 925
  packed_mphf ++;
#line 925
  h2_type = (CMPH_HASH )*tmp___3;
#line 927
  size = (cmph_uint8 *)packed_mphf;
#line 928
  packed_mphf = (cmph_uint32 *)(size + k);
#line 930
  offset = packed_mphf;
#line 931
  packed_mphf += k;
#line 935
  hash_vector_packed((void *)h0_ptr, h0_type, key, keylen, fingerprint);
#line 936
  h0 = *(fingerprint + 2) % k;
#line 938
  m = (cmph_uint32 )*(size + h0);
#line 939
  tmp___4 = fch_calc_b(c, m);
#line 939
  b = tmp___4;
#line 940
  tmp___5 = fch_calc_p1(m);
#line 940
  p1 = tmp___5;
#line 941
  tmp___6 = fch_calc_p2(b);
#line 941
  p2 = tmp___6;
#line 944
  g_is_ptr = (cmph_uint64 *)packed_mphf;
#line 949
  h1_ptr = (cmph_uint8 *)*(g_is_ptr + h0);
#line 951
  tmp___7 = hash_state_packed_size(h1_type);
#line 951
  h2_ptr = h1_ptr + tmp___7;
#line 953
  tmp___8 = hash_state_packed_size(h2_type);
#line 953
  g = h2_ptr + tmp___8;
#line 955
  tmp___9 = hash_packed((void *)h1_ptr, h1_type, key, keylen);
#line 955
  h1 = tmp___9 % m;
#line 956
  tmp___10 = hash_packed((void *)h2_ptr, h2_type, key, keylen);
#line 956
  h2 = tmp___10 % m;
#line 958
  mphf_bucket = (cmph_uint8 )0;
#line 959
  h1 = mixh10h11h12(b, p1, p2, h1);
#line 960
  mphf_bucket = (cmph_uint8 )((h2 + (cmph_uint32 )*(g + h1)) % m);
  }
#line 961
  return ((cmph_uint32 )mphf_bucket + *(offset + h0));
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___9(cmph_config_t *mph ) ;
#line 17
static cmph_uint32 *ordering___9(fch_buckets_t *buckets ) ;
#line 18
static cmph_uint8 check_for_collisions_h2___9(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) ;
#line 19
static void permut___9(cmph_uint32 *vector , cmph_uint32 n ) ;
#line 20
static cmph_uint8 searching___9(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static fch_buckets_t *mapping___9(cmph_config_t *mph ) 
{ 
  cmph_uint32 i ;
  fch_buckets_t *buckets ;
  fch_config_data_t *fch ;
  cmph_uint32 h1 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;

  {
#line 87
  i = (cmph_uint32 )0;
#line 88
  buckets = (fch_buckets_t *)((void *)0);
#line 89
  fch = (fch_config_data_t *)mph->data;
#line 90
  if (fch->h1) {
    {
#line 90
    hash_state_destroy(fch->h1);
    }
  }
  {
#line 91
  fch->h1 = hash_state_new(fch->hashfuncs[0], fch->m);
#line 92
  fch->b = fch_calc_b(fch->c, fch->m);
#line 93
  fch->p1 = fch_calc_p1(fch->m);
#line 94
  fch->p2 = fch_calc_p2(fch->b);
#line 96
  buckets = fch_buckets_new(fch->b);
#line 98
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 99
  i = (cmph_uint32 )0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < fch->m)) {
#line 99
      goto while_break;
    }
    {
#line 102
    key = (char *)((void *)0);
#line 103
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 104
    tmp = hash(fch->h1, (char const   *)key, keylen);
#line 104
    h1 = tmp % fch->m;
#line 105
    h1 = mixh10h11h12(fch->b, fch->p1, fch->p2, h1);
#line 106
    fch_buckets_insert(buckets, h1, key, keylen);
#line 107
    key = (char *)((void *)0);
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (buckets);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint32 *ordering___9(fch_buckets_t *buckets ) 
{ 
  cmph_uint32 *tmp ;

  {
  {
#line 117
  tmp = fch_buckets_get_indexes_sorted_by_size(buckets);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 check_for_collisions_h2___9(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                              cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint8 *hashtable ;
  void *tmp ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 i ;
  cmph_uint32 index___0 ;
  cmph_uint32 j ;
  cmph_uint32 nkeys ;
  cmph_uint32 tmp___1 ;
  char *key ;
  char *tmp___2 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 124
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint8 ));
#line 124
  hashtable = (cmph_uint8 *)tmp;
#line 125
  tmp___0 = fch_buckets_get_nbuckets(buckets);
#line 125
  nbuckets = tmp___0;
#line 126
  i = (cmph_uint32 )0;
#line 126
  index___0 = (cmph_uint32 )0;
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < nbuckets)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp___1 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 129
    nkeys = tmp___1;
#line 130
    memset((void *)hashtable, 0, (size_t )fch->m);
#line 132
    j = (cmph_uint32 )0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < nkeys)) {
#line 132
        goto while_break___0;
      }
      {
#line 134
      tmp___2 = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 134
      key = tmp___2;
#line 135
      tmp___3 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 135
      keylen = tmp___3;
#line 136
      tmp___4 = hash(fch->h2, (char const   *)key, keylen);
#line 136
      index___0 = tmp___4 % fch->m;
      }
#line 137
      if (*(hashtable + index___0)) {
        {
#line 138
        free((void *)hashtable);
        }
#line 139
        return ((cmph_uint8 )1);
      }
#line 141
      *(hashtable + index___0) = (cmph_uint8 )1;
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((void *)hashtable);
  }
#line 145
  return ((cmph_uint8 )0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static void permut___9(cmph_uint32 *vector , cmph_uint32 n ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 b ;
  int tmp ;

  {
#line 151
  i = (cmph_uint32 )0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp = rand();
#line 152
    j = (cmph_uint32 )tmp % n;
#line 153
    b = *(vector + i);
#line 154
    *(vector + i) = *(vector + j);
#line 155
    *(vector + j) = b;
#line 151
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/fch.c"
static cmph_uint8 searching___9(fch_config_data_t *fch , fch_buckets_t *buckets ,
                                cmph_uint32 *sorted_indexes ) 
{ 
  cmph_uint32 *random_table ;
  void *tmp ;
  cmph_uint32 *map_table ;
  void *tmp___0 ;
  cmph_uint32 iteration_to_generate_h2 ;
  cmph_uint32 searching_iterations ;
  cmph_uint8 restart ;
  cmph_uint32 nbuckets ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 z ;
  cmph_uint32 counter ;
  cmph_uint32 filled_count ;
  void *tmp___2 ;
  cmph_uint32 bucketsize ;
  cmph_uint32 tmp___3 ;
  char *key ;
  char *tmp___4 ;
  cmph_uint32 keylen ;
  cmph_uint32 tmp___5 ;
  cmph_uint32 h2 ;
  cmph_uint32 tmp___6 ;
  cmph_uint32 index___0 ;
  cmph_uint32 tmp___7 ;
  cmph_uint32 y ;
  cmph_uint32 ry ;

  {
  {
#line 161
  tmp = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 161
  random_table = (cmph_uint32 *)tmp;
#line 162
  tmp___0 = calloc((size_t )fch->m, sizeof(cmph_uint32 ));
#line 162
  map_table = (cmph_uint32 *)tmp___0;
#line 163
  iteration_to_generate_h2 = (cmph_uint32 )0;
#line 164
  searching_iterations = (cmph_uint32 )0;
#line 165
  restart = (cmph_uint8 )0;
#line 166
  tmp___1 = fch_buckets_get_nbuckets(buckets);
#line 166
  nbuckets = tmp___1;
#line 167
  counter = (cmph_uint32 )0;
#line 167
  filled_count = (cmph_uint32 )0;
  }
#line 168
  if (fch->g) {
    {
#line 168
    free((void *)fch->g);
    }
  }
  {
#line 169
  tmp___2 = calloc((size_t )fch->b, sizeof(cmph_uint32 ));
#line 169
  fch->g = (cmph_uint32 *)tmp___2;
#line 173
  i = (cmph_uint32 )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < fch->m)) {
#line 173
      goto while_break;
    }
#line 175
    *(random_table + i) = i;
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  permut___9(random_table, fch->m);
#line 178
  i = (cmph_uint32 )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < fch->m)) {
#line 178
      goto while_break___0;
    }
#line 180
    *(map_table + *(random_table + i)) = i;
#line 178
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (fch->h2) {
      {
#line 183
      hash_state_destroy(fch->h2);
      }
    }
    {
#line 184
    fch->h2 = hash_state_new(fch->hashfuncs[1], fch->m);
#line 185
    restart = check_for_collisions_h2___9(fch, buckets, sorted_indexes);
#line 186
    filled_count = (cmph_uint32 )0;
    }
#line 187
    if (! restart) {
#line 189
      searching_iterations ++;
#line 189
      iteration_to_generate_h2 = (cmph_uint32 )0;
    } else {
#line 193
      iteration_to_generate_h2 ++;
    }
#line 196
    i = (cmph_uint32 )0;
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (i < nbuckets) {
#line 196
        if (! (! restart)) {
#line 196
          goto while_break___2;
        }
      } else {
#line 196
        goto while_break___2;
      }
      {
#line 197
      tmp___3 = fch_buckets_get_size(buckets, *(sorted_indexes + i));
#line 197
      bucketsize = tmp___3;
      }
#line 198
      if (bucketsize == 0U) {
#line 200
        restart = (cmph_uint8 )0;
#line 201
        goto while_break___2;
      } else {
#line 203
        restart = (cmph_uint8 )1;
      }
#line 204
      z = (cmph_uint32 )0;
      {
#line 204
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 204
        if (z < fch->m - filled_count) {
#line 204
          if (! restart) {
#line 204
            goto while_break___3;
          }
        } else {
#line 204
          goto while_break___3;
        }
        {
#line 205
        tmp___4 = fch_buckets_get_key(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 205
        key = tmp___4;
#line 206
        tmp___5 = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), (cmph_uint32 )0);
#line 206
        keylen = tmp___5;
#line 207
        tmp___6 = hash(fch->h2, (char const   *)key, keylen);
#line 207
        h2 = tmp___6 % fch->m;
#line 208
        counter = (cmph_uint32 )0;
#line 209
        restart = (cmph_uint8 )0;
#line 210
        *(fch->g + *(sorted_indexes + i)) = ((fch->m + *(random_table + (filled_count + z))) - h2) % fch->m;
#line 212
        j = (cmph_uint32 )0;
        }
        {
#line 213
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 214
          index___0 = (cmph_uint32 )0;
#line 215
          key = fch_buckets_get_key(buckets, *(sorted_indexes + i), j);
#line 216
          keylen = fch_buckets_get_keylength(buckets, *(sorted_indexes + i), j);
#line 217
          tmp___7 = hash(fch->h2, (char const   *)key, keylen);
#line 217
          h2 = tmp___7 % fch->m;
#line 218
          index___0 = (h2 + *(fch->g + *(sorted_indexes + i))) % fch->m;
          }
#line 220
          if (*(map_table + index___0) >= filled_count) {
#line 221
            y = *(map_table + index___0);
#line 222
            ry = *(random_table + y);
#line 223
            *(random_table + y) = *(random_table + filled_count);
#line 224
            *(random_table + filled_count) = ry;
#line 225
            *(map_table + *(random_table + y)) = y;
#line 226
            *(map_table + *(random_table + filled_count)) = filled_count;
#line 227
            filled_count ++;
#line 228
            counter ++;
          } else {
#line 231
            restart = (cmph_uint8 )1;
#line 232
            filled_count -= counter;
#line 233
            counter = (cmph_uint32 )0;
#line 234
            goto while_break___4;
          }
#line 236
          j = (j + 1U) % bucketsize;
#line 213
          if (! (j % bucketsize != 0U)) {
#line 213
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 204
        z ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    if (restart) {
#line 182
      if (searching_iterations < 10U) {
#line 182
        if (! (iteration_to_generate_h2 < 1000U)) {
#line 182
          goto while_break___1;
        }
      } else {
#line 182
        goto while_break___1;
      }
    } else {
#line 182
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  free((void *)map_table);
#line 243
  free((void *)random_table);
  }
#line 244
  return (restart);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___59[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 34 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint32 EMPTY___9  =    4294967295U;
#line 105 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static int check_edge___9(graph_t *g , cmph_uint32 e , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 


  {
#line 108
  if (*(g->edges + e % g->nedges) == v1) {
#line 108
    if (*(g->edges + (e % g->nedges + g->nedges)) == v2) {
#line 108
      return (1);
    }
  }
#line 109
  if (*(g->edges + e % g->nedges) == v2) {
#line 109
    if (*(g->edges + (e % g->nedges + g->nedges)) == v1) {
#line 109
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void del_edge_point___9(graph_t *g , cmph_uint32 v1 , cmph_uint32 v2 ) 
{ 
  cmph_uint32 e ;
  cmph_uint32 prev ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  e = *(g->first + v1);
#line 133
  tmp = check_edge___9(g, e, v1, v2);
  }
#line 133
  if (tmp) {
#line 135
    *(g->first + v1) = *(g->next + e);
#line 138
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    prev = e;
#line 144
    e = *(g->next + e);
#line 145
    if (! (e != EMPTY___9)) {
      {
#line 145
      __assert_fail("e != EMPTY", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c",
                    145U, "del_edge_point");
      }
    }
    {
#line 141
    tmp___0 = check_edge___9(g, e, v1, v2);
    }
#line 141
    if (tmp___0) {
#line 141
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  *(g->next + prev) = *(g->next + e);
#line 152
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static cmph_uint8 find_degree1_edge___9(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ,
                                        cmph_uint32 *e ) 
{ 
  cmph_uint32 edge ;
  cmph_uint8 found ;

  {
#line 177
  edge = *(g->first + v);
#line 178
  found = (cmph_uint8 )0;
#line 180
  if (edge == EMPTY___9) {
#line 180
    return ((cmph_uint8 )0);
  } else
#line 181
  if (! (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___59[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U))) {
#line 183
    found = (cmph_uint8 )1;
#line 184
    *e = edge;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    edge = *(g->next + edge);
#line 189
    if (edge == EMPTY___9) {
#line 189
      goto while_break;
    }
#line 190
    if (((int )*(deleted + (edge % g->nedges >> 3)) & (int )bitmask___59[edge % g->nedges & 7U]) >> (edge % g->nedges & 7U)) {
#line 190
      goto while_continue;
    }
#line 191
    if (found) {
#line 191
      return ((cmph_uint8 )0);
    }
#line 193
    *e = edge;
#line 194
    found = (cmph_uint8 )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (found);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/graph.c"
static void cyclic_del_edge___9(graph_t *g , cmph_uint32 v , cmph_uint8 *deleted ) 
{ 
  cmph_uint32 e ;
  cmph_uint8 degree1 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;

  {
  {
#line 202
  e = (cmph_uint32 )0;
#line 204
  v1 = v;
#line 205
  v2 = (cmph_uint32 )0;
#line 207
  degree1 = find_degree1_edge___9(g, v1, deleted, & e);
  }
#line 208
  if (! degree1) {
#line 208
    return;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    *(deleted + (e % g->nedges >> 3)) = (cmph_uint8 )((int )*(deleted + (e % g->nedges >> 3)) | (int )bitmask___59[e % g->nedges & 7U]);
#line 214
    v2 = *(g->edges + e % g->nedges);
#line 215
    if (v2 == v1) {
#line 215
      v2 = *(g->edges + (e % g->nedges + g->nedges));
    }
    {
#line 218
    degree1 = find_degree1_edge___9(g, v2, deleted, & e);
    }
#line 219
    if (degree1) {
#line 222
      v1 = v2;
    } else {
#line 224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___60[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___9(cmph_config_t *mph ) ;
#line 18
static void chm_traverse___9(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static void chm_traverse___9(chm_config_data_t *chm , cmph_uint8 *visited , cmph_uint32 v ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 149
  tmp = graph_neighbors_it(chm->graph, v);
#line 149
  it = tmp;
#line 150
  neighbor = (cmph_uint32 )0;
#line 151
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___60[v & 7U]);
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    neighbor = graph_next_neighbor(chm->graph, & it);
    }
#line 154
    if (! (neighbor != 4294967295U)) {
#line 154
      goto while_break;
    }
#line 157
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___60[neighbor & 7U]) >> (neighbor & 7U)) {
#line 157
      goto while_continue;
    }
    {
#line 160
    tmp___0 = graph_edge_id(chm->graph, v, neighbor);
#line 160
    *(chm->g + neighbor) = tmp___0 - *(chm->g + v);
#line 162
    chm_traverse___9(chm, visited, neighbor);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/chm.c"
static int chm_gen_edges___9(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  chm_config_data_t *chm ;
  int cycles ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 169
  chm = (chm_config_data_t *)mph->data;
#line 170
  cycles = 0;
#line 173
  graph_clear_edges(chm->graph);
#line 174
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 175
  e = (cmph_uint32 )0;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (e < (mph->key_source)->nkeys)) {
#line 175
      goto while_break;
    }
    {
#line 180
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 181
    tmp = hash(*(chm->hashes + 0), (char const   *)key, keylen);
#line 181
    h1 = tmp % chm->n;
#line 182
    tmp___0 = hash(*(chm->hashes + 1), (char const   *)key, keylen);
#line 182
    h2 = tmp___0 % chm->n;
    }
#line 183
    if (h1 == h2) {
#line 183
      h2 ++;
#line 183
      if (h2 >= chm->n) {
#line 183
        h2 = (cmph_uint32 )0;
      }
    }
#line 184
    if (h1 == h2) {
#line 186
      if (mph->verbosity) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 187
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 188
      return (0);
    }
    {
#line 191
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 192
    graph_add_edge(chm->graph, h1, h2);
#line 175
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  cycles = graph_is_cyclic(chm->graph);
  }
#line 195
  if (mph->verbosity) {
#line 195
    if (cycles) {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic graph generated\n");
      }
    }
  }
#line 198
  return (! cycles);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___61[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___9(cmph_config_t *mph ) ;
#line 19
static cmph_uint8 bmz_traverse_critical_nodes___9(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 20
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___9(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) ;
#line 21
static void bmz_traverse_non_critical_nodes___9(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes___9(bmz_config_data_t *bmz , cmph_uint32 v ,
                                                  cmph_uint32 *biggest_g_value , cmph_uint32 *biggest_edge_value ,
                                                  cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 198
  tmp = graph_ncritical_nodes(bmz->graph);
#line 198
  tmp___0 = vqueue_new(tmp + 1U);
#line 198
  q = tmp___0;
#line 202
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 202
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 203
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___61[v & 7U]);
#line 204
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 204
  next_g = (cmph_uint32 )tmp___2;
#line 205
  vqueue_insert(q, v);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    tmp___6 = vqueue_is_empty(q);
    }
#line 206
    if (tmp___6) {
#line 206
      goto while_break;
    }
    {
#line 208
    v = vqueue_remove(q);
#line 209
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 210
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 210
      if (! (u != 4294967295U)) {
#line 210
        goto while_break___0;
      }
      {
#line 212
      tmp___5 = graph_node_is_critical(bmz->graph, u);
      }
#line 212
      if (tmp___5) {
#line 212
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___61[u & 7U]) >> (u & 7U))) {
#line 214
          collision = (cmph_uint8 )1;
          {
#line 215
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 215
            if (! collision) {
#line 215
              goto while_break___1;
            }
            {
#line 217
            next_g = *biggest_g_value + 1U;
#line 218
            it1 = graph_neighbors_it(bmz->graph, u);
#line 219
            collision = (cmph_uint8 )0;
            }
            {
#line 220
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 220
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 220
              if (! (lav != 4294967295U)) {
#line 220
                goto while_break___2;
              }
              {
#line 222
              tmp___3 = graph_node_is_critical(bmz->graph, lav);
              }
#line 222
              if (tmp___3) {
#line 222
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___61[lav & 7U]) >> (lav & 7U)) {
#line 224
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 226
                    vqueue_destroy(q);
                    }
#line 227
                    return ((cmph_uint8 )1);
                  }
#line 229
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___61[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 231
                    collision = (cmph_uint8 )1;
#line 232
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 236
            if (next_g > *biggest_g_value) {
#line 236
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 239
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 240
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 240
            if (! (lav != 4294967295U)) {
#line 240
              goto while_break___3;
            }
            {
#line 242
            tmp___4 = graph_node_is_critical(bmz->graph, lav);
            }
#line 242
            if (tmp___4) {
#line 242
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___61[lav & 7U]) >> (lav & 7U)) {
#line 244
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___61[(next_g + *(bmz->g + lav)) & 7U]);
#line 245
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 245
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 248
          *(bmz->g + u) = next_g;
#line 249
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___61[u & 7U]);
#line 250
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  vqueue_destroy(q);
  }
#line 256
  return ((cmph_uint8 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint8 bmz_traverse_critical_nodes_heuristic___9(bmz_config_data_t *bmz ,
                                                            cmph_uint32 v , cmph_uint32 *biggest_g_value ,
                                                            cmph_uint32 *biggest_edge_value ,
                                                            cmph_uint8 *used_edges ,
                                                            cmph_uint8 *visited ) 
{ 
  cmph_uint32 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint32 *unused_g_values ;
  cmph_uint32 unused_g_values_capacity ;
  cmph_uint32 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint32 next_g_index ;
  cmph_uint32 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint32 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 265
  unused_g_values = (cmph_uint32 *)((void *)0);
#line 266
  unused_g_values_capacity = (cmph_uint32 )0;
#line 267
  nunused_g_values = (cmph_uint32 )0;
#line 268
  tmp = graph_ncritical_nodes(bmz->graph);
#line 268
  tmp___0 = vqueue_new((cmph_uint32 )(0.5 * (double )tmp) + 1U);
#line 268
  q = tmp___0;
#line 272
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 272
  *(bmz->g + v) = (cmph_uint32 )tmp___1 - 1U;
#line 273
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___61[v & 7U]);
#line 274
  tmp___2 = floor((double )(*biggest_edge_value / 2U));
#line 274
  next_g = (cmph_uint32 )tmp___2;
#line 275
  vqueue_insert(q, v);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___9 = vqueue_is_empty(q);
    }
#line 276
    if (tmp___9) {
#line 276
      goto while_break;
    }
    {
#line 278
    v = vqueue_remove(q);
#line 279
    it = graph_neighbors_it(bmz->graph, v);
    }
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 280
      u = graph_next_neighbor(bmz->graph, & it);
      }
#line 280
      if (! (u != 4294967295U)) {
#line 280
        goto while_break___0;
      }
      {
#line 282
      tmp___8 = graph_node_is_critical(bmz->graph, u);
      }
#line 282
      if (tmp___8) {
#line 282
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___61[u & 7U]) >> (u & 7U))) {
#line 284
          next_g_index = (cmph_uint32 )0;
#line 285
          collision = (cmph_uint8 )1;
          {
#line 286
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 286
            if (! collision) {
#line 286
              goto while_break___1;
            }
#line 288
            if (next_g_index < nunused_g_values) {
#line 290
              tmp___3 = next_g_index;
#line 290
              next_g_index ++;
#line 290
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 294
              next_g = *biggest_g_value + 1U;
#line 295
              next_g_index = 4294967295U;
            }
            {
#line 297
            it1 = graph_neighbors_it(bmz->graph, u);
#line 298
            collision = (cmph_uint8 )0;
            }
            {
#line 299
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 299
              lav = graph_next_neighbor(bmz->graph, & it1);
              }
#line 299
              if (! (lav != 4294967295U)) {
#line 299
                goto while_break___2;
              }
              {
#line 301
              tmp___4 = graph_node_is_critical(bmz->graph, lav);
              }
#line 301
              if (tmp___4) {
#line 301
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___61[lav & 7U]) >> (lav & 7U)) {
#line 303
                  if (next_g + *(bmz->g + lav) >= bmz->m) {
                    {
#line 305
                    vqueue_destroy(q);
#line 306
                    free((void *)unused_g_values);
                    }
#line 307
                    return ((cmph_uint8 )1);
                  }
#line 309
                  if (((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) & (int )bitmask___61[(next_g + *(bmz->g + lav)) & 7U]) >> ((next_g + *(bmz->g + lav)) & 7U)) {
#line 311
                    collision = (cmph_uint8 )1;
#line 312
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 316
            if (collision) {
#line 316
              if (next_g > *biggest_g_value) {
#line 318
                if (nunused_g_values == unused_g_values_capacity) {
                  {
#line 320
                  tmp___5 = realloc((void *)unused_g_values, (unsigned long )(unused_g_values_capacity + 8192U) * sizeof(cmph_uint32 ));
#line 320
                  unused_g_values = (cmph_uint32 *)tmp___5;
#line 321
                  unused_g_values_capacity += 8192U;
                  }
                }
#line 323
                tmp___6 = nunused_g_values;
#line 323
                nunused_g_values ++;
#line 323
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 326
            if (next_g > *biggest_g_value) {
#line 326
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 328
          next_g_index --;
#line 329
          if (next_g_index < nunused_g_values) {
#line 329
            nunused_g_values --;
#line 329
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 332
          it1 = graph_neighbors_it(bmz->graph, u);
          }
          {
#line 333
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 333
            lav = graph_next_neighbor(bmz->graph, & it1);
            }
#line 333
            if (! (lav != 4294967295U)) {
#line 333
              goto while_break___3;
            }
            {
#line 335
            tmp___7 = graph_node_is_critical(bmz->graph, lav);
            }
#line 335
            if (tmp___7) {
#line 335
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___61[lav & 7U]) >> (lav & 7U)) {
#line 337
                *(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + ((next_g + *(bmz->g + lav)) >> 3)) | (int )bitmask___61[(next_g + *(bmz->g + lav)) & 7U]);
#line 338
                if (next_g + *(bmz->g + lav) > *biggest_edge_value) {
#line 338
                  *biggest_edge_value = next_g + *(bmz->g + lav);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 341
          *(bmz->g + u) = next_g;
#line 342
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___61[u & 7U]);
#line 343
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  vqueue_destroy(q);
#line 349
  free((void *)unused_g_values);
  }
#line 350
  return ((cmph_uint8 )0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static cmph_uint32 next_unused_edge___19(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                         cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (unused_edge_index < bmz->m)) {
      {
#line 357
      __assert_fail("unused_edge_index < bmz->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c",
                    357U, "next_unused_edge");
      }
    }
#line 358
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___61[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 358
      unused_edge_index ++;
    } else {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (unused_edge_index);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse___9(bmz_config_data_t *bmz , cmph_uint8 *used_edges , cmph_uint32 v ,
                             cmph_uint32 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 366
  tmp = graph_neighbors_it(bmz->graph, v);
#line 366
  it = tmp;
#line 367
  neighbor = (cmph_uint32 )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    neighbor = graph_next_neighbor(bmz->graph, & it);
    }
#line 368
    if (! (neighbor != 4294967295U)) {
#line 368
      goto while_break;
    }
#line 370
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___61[neighbor & 7U]) >> (neighbor & 7U)) {
#line 370
      goto while_continue;
    }
    {
#line 372
    *unused_edge_index = next_unused_edge___19(bmz, used_edges, *unused_edge_index);
#line 373
    *(bmz->g + neighbor) = *unused_edge_index - *(bmz->g + v);
#line 375
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___61[neighbor & 7U]);
#line 376
    (*unused_edge_index) ++;
#line 377
    bmz_traverse___9(bmz, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static void bmz_traverse_non_critical_nodes___9(bmz_config_data_t *bmz , cmph_uint8 *used_edges ,
                                                cmph_uint8 *visited ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 unused_edge_index ;

  {
#line 385
  unused_edge_index = (cmph_uint32 )0;
#line 387
  i = (cmph_uint32 )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < bmz->m)) {
#line 387
      goto while_break;
    }
    {
#line 389
    v1 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )0);
#line 390
    v2 = graph_vertex_id(bmz->graph, i, (cmph_uint32 )1);
    }
#line 391
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___61[v1 & 7U]) >> (v1 & 7U)) {
#line 391
      if (((int )*(visited + (v2 >> 3)) & (int )bitmask___61[v2 & 7U]) >> (v2 & 7U)) {
#line 391
        goto __Cont;
      } else {
#line 391
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 391
    if (! (((int )*(visited + (v1 >> 3)) & (int )bitmask___61[v1 & 7U]) >> (v1 & 7U))) {
#line 391
      if (! (((int )*(visited + (v2 >> 3)) & (int )bitmask___61[v2 & 7U]) >> (v2 & 7U))) {
#line 391
        goto __Cont;
      }
    }
#line 392
    if (((int )*(visited + (v1 >> 3)) & (int )bitmask___61[v1 & 7U]) >> (v1 & 7U)) {
      {
#line 392
      bmz_traverse___9(bmz, used_edges, v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 393
      bmz_traverse___9(bmz, used_edges, v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 387
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  i = (cmph_uint32 )0;
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (i < bmz->n)) {
#line 397
      goto while_break___0;
    }
#line 399
    if (! (((int )*(visited + (i >> 3)) & (int )bitmask___61[i & 7U]) >> (i & 7U))) {
      {
#line 401
      *(bmz->g + i) = (cmph_uint32 )0;
#line 402
      *(visited + (i >> 3)) = (cmph_uint8 )((int )*(visited + (i >> 3)) | (int )bitmask___61[i & 7U]);
#line 403
      bmz_traverse___9(bmz, used_edges, i, & unused_edge_index, visited);
      }
    }
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz.c"
static int bmz_gen_edges___9(cmph_config_t *mph ) 
{ 
  cmph_uint32 e ;
  bmz_config_data_t *bmz ;
  cmph_uint8 multiple_edges ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 412
  bmz = (bmz_config_data_t *)mph->data;
#line 413
  multiple_edges = (cmph_uint8 )0;
#line 415
  graph_clear_edges(bmz->graph);
#line 416
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 417
  e = (cmph_uint32 )0;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (e < (mph->key_source)->nkeys)) {
#line 417
      goto while_break;
    }
    {
#line 421
    key = (char *)((void *)0);
#line 422
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 425
    tmp = hash(*(bmz->hashes + 0), (char const   *)key, keylen);
#line 425
    h1 = tmp % bmz->n;
#line 426
    tmp___0 = hash(*(bmz->hashes + 1), (char const   *)key, keylen);
#line 426
    h2 = tmp___0 % bmz->n;
    }
#line 427
    if (h1 == h2) {
#line 427
      h2 ++;
#line 427
      if (h2 >= bmz->n) {
#line 427
        h2 = (cmph_uint32 )0;
      }
    }
#line 428
    if (h1 == h2) {
#line 430
      if (mph->verbosity) {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                e);
        }
      }
      {
#line 431
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 432
      return (0);
    }
    {
#line 435
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 437
    multiple_edges = graph_contains_edge(bmz->graph, h1, h2);
    }
#line 438
    if (mph->verbosity) {
#line 438
      if (multiple_edges) {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 439
    if (multiple_edges) {
#line 439
      return (0);
    }
    {
#line 440
    graph_add_edge(bmz->graph, h1, h2);
#line 417
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (! multiple_edges);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___30[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 rank_lookup_table___9[256]  = 
#line 12 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
  {      (cmph_uint8 )0,      (cmph_uint8 )1,      (cmph_uint8 )1,      (cmph_uint8 )2, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )1,      (cmph_uint8 )2,      (cmph_uint8 )2,      (cmph_uint8 )3, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )2,      (cmph_uint8 )3,      (cmph_uint8 )3,      (cmph_uint8 )4, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )3,      (cmph_uint8 )4,      (cmph_uint8 )4,      (cmph_uint8 )5, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )4,      (cmph_uint8 )5,      (cmph_uint8 )5,      (cmph_uint8 )6, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )5,      (cmph_uint8 )6,      (cmph_uint8 )6,      (cmph_uint8 )7, 
        (cmph_uint8 )6,      (cmph_uint8 )7,      (cmph_uint8 )7,      (cmph_uint8 )8};
#line 40 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select_lookup_tables.h"
static cmph_uint8 select_lookup_table___9[256][8]  = 
#line 40
  { {        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7, 
            (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6, 
            (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4,        (cmph_uint8 )5, 
            (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3,        (cmph_uint8 )4, 
            (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7,        (cmph_uint8 )255}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )3, 
            (cmph_uint8 )4,        (cmph_uint8 )5,        (cmph_uint8 )6,        (cmph_uint8 )7}};
#line 68 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static void select_generate_sel_table___9(select_t *sel ) 
{ 
  register cmph_uint8 *bits_table ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;
  register cmph_uint32 vec_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 sel_table_idx ;

  {
#line 70
  bits_table = (cmph_uint8 *)sel->bits_vec;
#line 74
  sel_table_idx = (cmph_uint32 )0;
#line 74
  one_idx = sel_table_idx;
#line 74
  vec_idx = one_idx;
#line 74
  part_sum = vec_idx;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (one_idx >= sel->n) {
#line 80
      goto while_break;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      old_part_sum = part_sum;
#line 84
      part_sum += (cmph_uint32 )rank_lookup_table___9[*(bits_table + vec_idx)];
#line 85
      vec_idx ++;
#line 81
      if (! (part_sum <= one_idx)) {
#line 81
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    *(sel->select_table + sel_table_idx) = (cmph_uint32 )select_lookup_table___9[*(bits_table + (vec_idx - 1U))][one_idx - old_part_sum] + ((vec_idx - 1U) << 3);
#line 89
    one_idx += 128U;
#line 90
    sel_table_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_query___9(cmph_uint8 *bits_table , cmph_uint32 *select_table ,
                                              cmph_uint32 one_idx ) 
{ 
  register cmph_uint32 vec_bit_idx ;
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 172
  vec_bit_idx = *(select_table + (one_idx >> 7));
#line 173
  vec_byte_idx = vec_bit_idx >> 3;
#line 175
  one_idx &= 127U;
#line 176
  one_idx += (cmph_uint32 )rank_lookup_table___9[(int )*(bits_table + vec_byte_idx) & ((1 << (vec_bit_idx & 7U)) - 1)];
#line 177
  part_sum = (cmph_uint32 )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    old_part_sum = part_sum;
#line 182
    part_sum += (cmph_uint32 )rank_lookup_table___9[*(bits_table + vec_byte_idx)];
#line 183
    vec_byte_idx ++;
#line 179
    if (! (part_sum <= one_idx)) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((cmph_uint32 )select_lookup_table___9[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/select.c"
__inline static cmph_uint32 _select_next_query___9(cmph_uint8 *bits_table , cmph_uint32 vec_bit_idx ) 
{ 
  register cmph_uint32 vec_byte_idx ;
  register cmph_uint32 one_idx ;
  register cmph_uint32 part_sum ;
  register cmph_uint32 old_part_sum ;

  {
#line 201
  vec_byte_idx = vec_bit_idx >> 3;
#line 203
  one_idx = (unsigned int )rank_lookup_table___9[(unsigned int )*(bits_table + vec_byte_idx) & ((1U << (vec_bit_idx & 7U)) - 1U)] + 1U;
#line 204
  part_sum = (cmph_uint32 )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    old_part_sum = part_sum;
#line 209
    part_sum += (cmph_uint32 )rank_lookup_table___9[*(bits_table + vec_byte_idx)];
#line 210
    vec_byte_idx ++;
#line 206
    if (! (part_sum <= one_idx)) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((cmph_uint32 )select_lookup_table___9[*(bits_table + (vec_byte_idx - 1U))][one_idx - old_part_sum] + ((vec_byte_idx - 1U) << 3));
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___62[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 18 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 pow3_table___9[5]  = {      (cmph_uint8 )1,      (cmph_uint8 )3,      (cmph_uint8 )9,      (cmph_uint8 )27, 
        (cmph_uint8 )81};
#line 19 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static cmph_uint8 lookup_table___9[5][256]  = { {        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}, 
   {        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )1, 
            (cmph_uint8 )1,        (cmph_uint8 )1,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2, 
            (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )2,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0, 
            (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0,        (cmph_uint8 )0}};
#line 35 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_queue___9(bdz_ph_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 37
  *queuep = (bdz_ph_queue_t )tmp;
  }
#line 38
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_queue___9(bdz_ph_queue_t *queue ) 
{ 


  {
  {
#line 41
  free((void *)*queue);
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_alloc_graph3___9(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                    cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp = malloc((unsigned long )nedges * sizeof(bdz_ph_edge_t ));
#line 55
  graph3->edges = (bdz_ph_edge_t *)tmp;
#line 56
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 56
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 57
  tmp___1 = malloc((size_t )nvertices);
#line 57
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 58
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_init_graph3___9(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges ,
                                   cmph_uint32 nvertices ) 
{ 


  {
  {
#line 61
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 62
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 63
  graph3->nedges = (cmph_uint32 )0;
  }
#line 64
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_free_graph3___9(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 67
  free((void *)graph3->edges);
#line 68
  free((void *)graph3->first_edge);
#line 69
  free((void *)graph3->vert_degree);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_partial_free_graph3___9(bdz_ph_graph3_t *graph3 ) 
{ 


  {
  {
#line 74
  free((void *)graph3->first_edge);
#line 75
  free((void *)graph3->vert_degree);
#line 76
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 77
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_add_edge___9(bdz_ph_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                                cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 82
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 83
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 84
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 85
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 86
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 87
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 88
  tmp___0 = graph3->nedges;
#line 88
  *(graph3->first_edge + v2) = tmp___0;
#line 88
  tmp = tmp___0;
#line 88
  *(graph3->first_edge + v1) = tmp;
#line 88
  *(graph3->first_edge + v0) = tmp;
#line 89
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 90
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 91
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 92
  (graph3->nedges) ++;
#line 93
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_dump_graph___9(bdz_ph_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((cmph_uint32 )i < nedges)) {
#line 98
      goto while_break;
    }
    {
#line 99
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 101
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((cmph_uint32 )i < nvertices)) {
#line 105
      goto while_break___0;
    }
    {
#line 106
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 105
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_remove_edge___9(bdz_ph_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 113
  j = (cmph_uint32 )0;
#line 114
  i = (cmph_uint32 )0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 3U)) {
#line 114
      goto while_break;
    }
#line 115
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 116
    edge1 = *(graph3->first_edge + vert);
#line 117
    edge2 = 4294967295U;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (edge1 != curr_edge) {
#line 118
        if (! (edge1 != 4294967295U)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      edge2 = edge1;
#line 120
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 121
        j = (cmph_uint32 )0;
      } else
#line 122
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 123
        j = (cmph_uint32 )1;
      } else {
#line 125
        j = (cmph_uint32 )2;
      }
#line 126
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    if (edge1 == 4294967295U) {
      {
#line 129
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 130
      bdz_ph_dump_graph___9(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 131
      exit(-1);
      }
    }
#line 134
    if (edge2 != 4294967295U) {
#line 135
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 138
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 140
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_generate_queue___9(cmph_uint32 nedges , cmph_uint32 nvertices ,
                                     bdz_ph_queue_t queue , bdz_ph_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 148
  queue_head = (cmph_uint32 )0;
#line 148
  queue_tail = (cmph_uint32 )0;
#line 151
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 151
  marked_edge = (cmph_uint8 *)tmp;
#line 152
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 154
  i = (cmph_uint32 )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nedges)) {
#line 154
      goto while_break;
    }
#line 155
    v0 = (graph3->edges + i)->vertices[0];
#line 156
    v1 = (graph3->edges + i)->vertices[1];
#line 157
    v2 = (graph3->edges + i)->vertices[2];
#line 158
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 158
      goto _L;
    } else
#line 158
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 161
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___62[i & 7U]) >> (i & 7U))) {
#line 162
        tmp___0 = queue_head;
#line 162
        queue_head ++;
#line 162
        *(queue + tmp___0) = i;
#line 163
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___62[i & 7U]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (queue_tail != queue_head)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = queue_tail;
#line 168
    queue_tail ++;
#line 168
    curr_edge = *(queue + tmp___1);
#line 169
    bdz_ph_remove_edge___9(graph3, curr_edge);
#line 170
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 171
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 172
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 173
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 174
      tmp_edge = *(graph3->first_edge + v0);
#line 175
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___62[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 176
        tmp___2 = queue_head;
#line 176
        queue_head ++;
#line 176
        *(queue + tmp___2) = tmp_edge;
#line 177
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___62[tmp_edge & 7U]);
      }
    }
#line 181
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 182
      tmp_edge = *(graph3->first_edge + v1);
#line 183
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___62[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 184
        tmp___3 = queue_head;
#line 184
        queue_head ++;
#line 184
        *(queue + tmp___3) = tmp_edge;
#line 185
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___62[tmp_edge & 7U]);
      }
    }
#line 189
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 190
      tmp_edge = *(graph3->first_edge + v2);
#line 191
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___62[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 192
        tmp___4 = queue_head;
#line 192
        queue_head ++;
#line 192
        *(queue + tmp___4) = tmp_edge;
#line 193
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___62[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  free((void *)marked_edge);
  }
#line 198
  return ((int )queue_head - (int )nedges);
}
}
#line 201
static int bdz_ph_mapping___9(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) ;
#line 202
static void assigning___19(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) ;
#line 203
static void bdz_ph_optimization___9(bdz_ph_config_data_t *bdz_ph ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static int bdz_ph_mapping___9(cmph_config_t *mph , bdz_ph_graph3_t *graph3 , bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_ph_config_data_t *bdz_ph ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 355
  cycles = 0;
#line 358
  bdz_ph = (bdz_ph_config_data_t *)mph->data;
#line 359
  bdz_ph_init_graph3___9(graph3, bdz_ph->m, bdz_ph->n);
#line 360
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 361
  e = (cmph_uint32 )0;
  }
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (e < (mph->key_source)->nkeys)) {
#line 361
      goto while_break;
    }
    {
#line 365
    key = (char *)((void *)0);
#line 366
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 367
    hash_vector(bdz_ph->hl, (char const   *)key, keylen, hl);
#line 368
    h0 = hl[0] % bdz_ph->r;
#line 369
    h1 = hl[1] % bdz_ph->r + bdz_ph->r;
#line 370
    h2 = hl[2] % bdz_ph->r + (bdz_ph->r << 1);
#line 371
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 372
    bdz_ph_add_edge___9(graph3, h0, h1, h2);
#line 361
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  cycles = bdz_ph_generate_queue___9(bdz_ph->m, bdz_ph->n, queue, graph3);
  }
#line 375
  return (cycles == 0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void assigning___19(bdz_ph_config_data_t *bdz_ph , bdz_ph_graph3_t *graph3 ,
                           bdz_ph_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 381
  nedges = graph3->nedges;
#line 384
  tmp = malloc((size_t )(bdz_ph->n >> 3) + 1UL);
#line 384
  marked_vertices = (cmph_uint8 *)tmp;
#line 385
  tmp___0 = ceil((double )bdz_ph->n / 4.0);
#line 385
  sizeg = (cmph_uint32 )tmp___0;
#line 386
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 386
  bdz_ph->g = (cmph_uint8 *)tmp___1;
#line 387
  memset((void *)marked_vertices, 0, (size_t )(bdz_ph->n >> 3) + 1UL);
#line 390
  i = nedges - 1U;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i + 1U >= 1U)) {
#line 390
      goto while_break;
    }
#line 391
    curr_edge = *(queue + i);
#line 392
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 393
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 394
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 396
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___62[v0 & 7U]) >> (v0 & 7U))) {
#line 397
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___62[v1 & 7U]) >> (v1 & 7U))) {
#line 400
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___62[v1 & 7U]);
      }
#line 402
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___62[v2 & 7U]) >> (v2 & 7U))) {
#line 405
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___62[v2 & 7U]);
      }
#line 407
      *(bdz_ph->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v0 >> 2)) | (int )((cmph_uint8 )((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1))));
#line 408
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___62[v0 & 7U]);
    } else
#line 409
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___62[v1 & 7U]) >> (v1 & 7U))) {
#line 410
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___62[v2 & 7U]) >> (v2 & 7U))) {
#line 413
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___62[v2 & 7U]);
      }
#line 415
      *(bdz_ph->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v1 >> 2)) | (int )((cmph_uint8 )((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1))));
#line 416
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___62[v1 & 7U]);
    } else {
#line 418
      *(bdz_ph->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz_ph->g + (v2 >> 2)) | (int )((cmph_uint8 )((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1))));
#line 419
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___62[v2 & 7U]);
    }
#line 390
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  free((void *)marked_vertices);
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz_ph.c"
static void bdz_ph_optimization___9(bdz_ph_config_data_t *bdz_ph ) 
{ 
  cmph_uint32 i ;
  cmph_uint8 byte ;
  cmph_uint32 sizeg ;
  double tmp ;
  cmph_uint8 *new_g ;
  void *tmp___0 ;
  cmph_uint8 value ;
  cmph_uint32 idx ;

  {
  {
#line 429
  byte = (cmph_uint8 )0;
#line 430
  tmp = ceil((double )bdz_ph->n / 5.0);
#line 430
  sizeg = (cmph_uint32 )tmp;
#line 431
  tmp___0 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 431
  new_g = (cmph_uint8 *)tmp___0;
#line 434
  i = (cmph_uint32 )0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < bdz_ph->n)) {
#line 434
      goto while_break;
    }
#line 436
    idx = i / 5U;
#line 437
    byte = *(new_g + idx);
#line 438
    value = (cmph_uint8 )((unsigned int )((int )*(bdz_ph->g + (i >> 2)) >> ((i & 3U) << 1U)) & 3U);
#line 439
    byte = (cmph_uint8 )((int )byte + (int )value * (int )pow3_table___9[i % 5U]);
#line 440
    *(new_g + idx) = byte;
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)bdz_ph->g);
#line 443
  bdz_ph->g = new_g;
  }
#line 444
  return;
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___63[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 17 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___9(cmph_config_t *mph ) ;
#line 18
static cmph_uint8 bmz8_traverse_critical_nodes___9(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) ;
#line 19
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___9(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) ;
#line 20
static void bmz8_traverse_non_critical_nodes___9(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes___9(bmz8_config_data_t *bmz8 , cmph_uint32 v ,
                                                   cmph_uint8 *biggest_g_value , cmph_uint8 *biggest_edge_value ,
                                                   cmph_uint8 *used_edges , cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  cmph_uint8 tmp___5 ;
  cmph_uint8 tmp___6 ;

  {
  {
#line 205
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 205
  tmp___0 = vqueue_new(tmp);
#line 205
  q = tmp___0;
#line 209
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 209
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 210
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___63[v & 7U]);
#line 211
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 211
  next_g = (cmph_uint8 )tmp___2;
#line 212
  vqueue_insert(q, v);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___6 = vqueue_is_empty(q);
    }
#line 213
    if (tmp___6) {
#line 213
      goto while_break;
    }
    {
#line 215
    v = vqueue_remove(q);
#line 216
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 217
      if (! (u != 4294967295U)) {
#line 217
        goto while_break___0;
      }
      {
#line 219
      tmp___5 = graph_node_is_critical(bmz8->graph, u);
      }
#line 219
      if (tmp___5) {
#line 219
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___63[u & 7U]) >> (u & 7U))) {
#line 221
          collision = (cmph_uint8 )1;
          {
#line 222
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 222
            if (! collision) {
#line 222
              goto while_break___1;
            }
            {
#line 224
            next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 225
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 226
            collision = (cmph_uint8 )0;
            }
            {
#line 227
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 227
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 227
              if (! (lav != 4294967295U)) {
#line 227
                goto while_break___2;
              }
              {
#line 229
              tmp___3 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 229
              if (tmp___3) {
#line 229
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___63[lav & 7U]) >> (lav & 7U)) {
#line 231
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 233
                    vqueue_destroy(q);
                    }
#line 234
                    return ((cmph_uint8 )1);
                  }
#line 236
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___63[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 238
                    collision = (cmph_uint8 )1;
#line 239
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 243
            if ((int )next_g > (int )*biggest_g_value) {
#line 243
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 246
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 247
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 247
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 247
            if (! (lav != 4294967295U)) {
#line 247
              goto while_break___3;
            }
            {
#line 249
            tmp___4 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 249
            if (tmp___4) {
#line 249
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___63[lav & 7U]) >> (lav & 7U)) {
#line 251
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___63[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 253
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 254
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 257
          *(bmz8->g + u) = next_g;
#line 258
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___63[u & 7U]);
#line 259
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  vqueue_destroy(q);
  }
#line 265
  return ((cmph_uint8 )0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 bmz8_traverse_critical_nodes_heuristic___9(bmz8_config_data_t *bmz8 ,
                                                             cmph_uint32 v , cmph_uint8 *biggest_g_value ,
                                                             cmph_uint8 *biggest_edge_value ,
                                                             cmph_uint8 *used_edges ,
                                                             cmph_uint8 *visited ) 
{ 
  cmph_uint8 next_g ;
  cmph_uint32 u ;
  cmph_uint32 lav ;
  cmph_uint8 collision ;
  cmph_uint8 *unused_g_values ;
  cmph_uint8 unused_g_values_capacity ;
  cmph_uint8 nunused_g_values ;
  vqueue_t *q ;
  cmph_uint32 tmp ;
  vqueue_t *tmp___0 ;
  graph_iterator_t it ;
  graph_iterator_t it1 ;
  double tmp___1 ;
  double tmp___2 ;
  cmph_uint8 next_g_index ;
  cmph_uint8 tmp___3 ;
  cmph_uint8 tmp___4 ;
  void *tmp___5 ;
  cmph_uint8 tmp___6 ;
  cmph_uint8 tmp___7 ;
  cmph_uint8 tmp___8 ;
  cmph_uint8 tmp___9 ;

  {
  {
#line 274
  unused_g_values = (cmph_uint8 *)((void *)0);
#line 275
  unused_g_values_capacity = (cmph_uint8 )0;
#line 276
  nunused_g_values = (cmph_uint8 )0;
#line 277
  tmp = graph_ncritical_nodes(bmz8->graph);
#line 277
  tmp___0 = vqueue_new(tmp);
#line 277
  q = tmp___0;
#line 281
  tmp___1 = ceil((double )*biggest_edge_value / (double )2);
#line 281
  *(bmz8->g + v) = (cmph_uint8 )(tmp___1 - (double )1);
#line 282
  *(visited + (v >> 3)) = (cmph_uint8 )((int )*(visited + (v >> 3)) | (int )bitmask___63[v & 7U]);
#line 283
  tmp___2 = floor((double )((int )*biggest_edge_value / 2));
#line 283
  next_g = (cmph_uint8 )tmp___2;
#line 284
  vqueue_insert(q, v);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___9 = vqueue_is_empty(q);
    }
#line 285
    if (tmp___9) {
#line 285
      goto while_break;
    }
    {
#line 287
    v = vqueue_remove(q);
#line 288
    it = graph_neighbors_it(bmz8->graph, v);
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 289
      u = graph_next_neighbor(bmz8->graph, & it);
      }
#line 289
      if (! (u != 4294967295U)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      tmp___8 = graph_node_is_critical(bmz8->graph, u);
      }
#line 291
      if (tmp___8) {
#line 291
        if (! (((int )*(visited + (u >> 3)) & (int )bitmask___63[u & 7U]) >> (u & 7U))) {
#line 293
          next_g_index = (cmph_uint8 )0;
#line 294
          collision = (cmph_uint8 )1;
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (! collision) {
#line 295
              goto while_break___1;
            }
#line 297
            if ((int )next_g_index < (int )nunused_g_values) {
#line 299
              tmp___3 = next_g_index;
#line 299
              next_g_index = (cmph_uint8 )((int )next_g_index + 1);
#line 299
              next_g = *(unused_g_values + tmp___3);
            } else {
#line 303
              next_g = (cmph_uint8 )((int )*biggest_g_value + 1);
#line 304
              next_g_index = (cmph_uint8 )255;
            }
            {
#line 306
            it1 = graph_neighbors_it(bmz8->graph, u);
#line 307
            collision = (cmph_uint8 )0;
            }
            {
#line 308
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 308
              lav = graph_next_neighbor(bmz8->graph, & it1);
              }
#line 308
              if (! (lav != 4294967295U)) {
#line 308
                goto while_break___2;
              }
              {
#line 310
              tmp___4 = graph_node_is_critical(bmz8->graph, lav);
              }
#line 310
              if (tmp___4) {
#line 310
                if (((int )*(visited + (lav >> 3)) & (int )bitmask___63[lav & 7U]) >> (lav & 7U)) {
#line 312
                  if ((int )next_g + (int )*(bmz8->g + lav) >= (int )bmz8->m) {
                    {
#line 314
                    vqueue_destroy(q);
#line 315
                    free((void *)unused_g_values);
                    }
#line 316
                    return ((cmph_uint8 )1);
                  }
#line 318
                  if (((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) & (int )bitmask___63[((int )next_g + (int )*(bmz8->g + lav)) & 7]) >> (((int )next_g + (int )*(bmz8->g + lav)) & 7)) {
#line 320
                    collision = (cmph_uint8 )1;
#line 321
                    goto while_break___2;
                  }
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 325
            if (collision) {
#line 325
              if ((int )next_g > (int )*biggest_g_value) {
#line 327
                if ((int )nunused_g_values == (int )unused_g_values_capacity) {
                  {
#line 329
                  tmp___5 = realloc((void *)unused_g_values, (size_t )((int )unused_g_values_capacity + 8192) * sizeof(cmph_uint8 ));
#line 329
                  unused_g_values = (cmph_uint8 *)tmp___5;
#line 330
                  unused_g_values_capacity = (cmph_uint8 )((int )unused_g_values_capacity);
                  }
                }
#line 332
                tmp___6 = nunused_g_values;
#line 332
                nunused_g_values = (cmph_uint8 )((int )nunused_g_values + 1);
#line 332
                *(unused_g_values + tmp___6) = next_g;
              }
            }
#line 335
            if ((int )next_g > (int )*biggest_g_value) {
#line 335
              *biggest_g_value = next_g;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 338
          next_g_index = (cmph_uint8 )((int )next_g_index - 1);
#line 339
          if ((int )next_g_index < (int )nunused_g_values) {
#line 339
            nunused_g_values = (cmph_uint8 )((int )nunused_g_values - 1);
#line 339
            *(unused_g_values + next_g_index) = *(unused_g_values + nunused_g_values);
          }
          {
#line 342
          it1 = graph_neighbors_it(bmz8->graph, u);
          }
          {
#line 343
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 343
            lav = graph_next_neighbor(bmz8->graph, & it1);
            }
#line 343
            if (! (lav != 4294967295U)) {
#line 343
              goto while_break___3;
            }
            {
#line 345
            tmp___7 = graph_node_is_critical(bmz8->graph, lav);
            }
#line 345
            if (tmp___7) {
#line 345
              if (((int )*(visited + (lav >> 3)) & (int )bitmask___63[lav & 7U]) >> (lav & 7U)) {
#line 347
                *(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) = (cmph_uint8 )((int )*(used_edges + (((int )next_g + (int )*(bmz8->g + lav)) >> 3)) | (int )bitmask___63[((int )next_g + (int )*(bmz8->g + lav)) & 7]);
#line 348
                if ((int )next_g + (int )*(bmz8->g + lav) > (int )*biggest_edge_value) {
#line 349
                  *biggest_edge_value = (cmph_uint8 )((int )next_g + (int )*(bmz8->g + lav));
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 353
          *(bmz8->g + u) = next_g;
#line 354
          *(visited + (u >> 3)) = (cmph_uint8 )((int )*(visited + (u >> 3)) | (int )bitmask___63[u & 7U]);
#line 355
          vqueue_insert(q, u);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 361
  vqueue_destroy(q);
#line 362
  free((void *)unused_g_values);
  }
#line 363
  return ((cmph_uint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static cmph_uint8 next_unused_edge___20(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                        cmph_uint32 unused_edge_index ) 
{ 


  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (unused_edge_index < (cmph_uint32 )bmz8->m)) {
      {
#line 370
      __assert_fail("unused_edge_index < bmz8->m", "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c",
                    370U, "next_unused_edge");
      }
    }
#line 371
    if (((int )*(used_edges + (unused_edge_index >> 3)) & (int )bitmask___63[unused_edge_index & 7U]) >> (unused_edge_index & 7U)) {
#line 371
      unused_edge_index ++;
    } else {
#line 372
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((cmph_uint8 )unused_edge_index);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse___9(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                              cmph_uint32 v , cmph_uint8 *unused_edge_index , cmph_uint8 *visited ) 
{ 
  graph_iterator_t it ;
  graph_iterator_t tmp ;
  cmph_uint32 neighbor ;

  {
  {
#line 379
  tmp = graph_neighbors_it(bmz8->graph, v);
#line 379
  it = tmp;
#line 380
  neighbor = (cmph_uint32 )0;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    neighbor = graph_next_neighbor(bmz8->graph, & it);
    }
#line 381
    if (! (neighbor != 4294967295U)) {
#line 381
      goto while_break;
    }
#line 383
    if (((int )*(visited + (neighbor >> 3)) & (int )bitmask___63[neighbor & 7U]) >> (neighbor & 7U)) {
#line 383
      goto while_continue;
    }
    {
#line 385
    *unused_edge_index = next_unused_edge___20(bmz8, used_edges, (cmph_uint32 )*unused_edge_index);
#line 386
    *(bmz8->g + neighbor) = (cmph_uint8 )((int )*unused_edge_index - (int )*(bmz8->g + v));
#line 388
    *(visited + (neighbor >> 3)) = (cmph_uint8 )((int )*(visited + (neighbor >> 3)) | (int )bitmask___63[neighbor & 7U]);
#line 389
    *unused_edge_index = (cmph_uint8 )((int )*unused_edge_index + 1);
#line 390
    bmz8_traverse___9(bmz8, used_edges, neighbor, unused_edge_index, visited);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static void bmz8_traverse_non_critical_nodes___9(bmz8_config_data_t *bmz8 , cmph_uint8 *used_edges ,
                                                 cmph_uint8 *visited ) 
{ 
  cmph_uint8 i ;
  cmph_uint8 v1 ;
  cmph_uint8 v2 ;
  cmph_uint8 unused_edge_index ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 398
  unused_edge_index = (cmph_uint8 )0;
#line 400
  i = (cmph_uint8 )0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((int )i < (int )bmz8->m)) {
#line 400
      goto while_break;
    }
    {
#line 402
    tmp = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )0);
#line 402
    v1 = (cmph_uint8 )tmp;
#line 403
    tmp___0 = graph_vertex_id(bmz8->graph, (cmph_uint32 )i, (cmph_uint32 )1);
#line 403
    v2 = (cmph_uint8 )tmp___0;
    }
#line 404
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___63[(int )v1 & 7]) >> ((int )v1 & 7)) {
#line 404
      if (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___63[(int )v2 & 7]) >> ((int )v2 & 7)) {
#line 404
        goto __Cont;
      } else {
#line 404
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 404
    if (! (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___63[(int )v1 & 7]) >> ((int )v1 & 7))) {
#line 404
      if (! (((int )*(visited + ((int )v2 >> 3)) & (int )bitmask___63[(int )v2 & 7]) >> ((int )v2 & 7))) {
#line 404
        goto __Cont;
      }
    }
#line 405
    if (((int )*(visited + ((int )v1 >> 3)) & (int )bitmask___63[(int )v1 & 7]) >> ((int )v1 & 7)) {
      {
#line 405
      bmz8_traverse___9(bmz8, used_edges, (cmph_uint32 )v1, & unused_edge_index, visited);
      }
    } else {
      {
#line 406
      bmz8_traverse___9(bmz8, used_edges, (cmph_uint32 )v2, & unused_edge_index, visited);
      }
    }
    __Cont: /* CIL Label */ 
#line 400
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  i = (cmph_uint8 )0;
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (! ((int )i < (int )bmz8->n)) {
#line 410
      goto while_break___0;
    }
#line 412
    if (! (((int )*(visited + ((int )i >> 3)) & (int )bitmask___63[(int )i & 7]) >> ((int )i & 7))) {
      {
#line 414
      *(bmz8->g + i) = (cmph_uint8 )0;
#line 415
      *(visited + ((int )i >> 3)) = (cmph_uint8 )((int )*(visited + ((int )i >> 3)) | (int )bitmask___63[(int )i & 7]);
#line 416
      bmz8_traverse___9(bmz8, used_edges, (cmph_uint32 )i, & unused_edge_index, visited);
      }
    }
#line 410
    i = (cmph_uint8 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bmz8.c"
static int bmz8_gen_edges___9(cmph_config_t *mph ) 
{ 
  cmph_uint8 e ;
  bmz8_config_data_t *bmz8 ;
  cmph_uint8 multiple_edges ;
  cmph_uint8 h1 ;
  cmph_uint8 h2 ;
  cmph_uint32 keylen ;
  char *key ;
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
  {
#line 425
  bmz8 = (bmz8_config_data_t *)mph->data;
#line 426
  multiple_edges = (cmph_uint8 )0;
#line 428
  graph_clear_edges(bmz8->graph);
#line 429
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 430
  e = (cmph_uint8 )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((cmph_uint32 )e < (mph->key_source)->nkeys)) {
#line 430
      goto while_break;
    }
    {
#line 434
    key = (char *)((void *)0);
#line 435
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 438
    tmp = hash(*(bmz8->hashes + 0), (char const   *)key, keylen);
#line 438
    h1 = (cmph_uint8 )(tmp % (unsigned int )bmz8->n);
#line 439
    tmp___0 = hash(*(bmz8->hashes + 1), (char const   *)key, keylen);
#line 439
    h2 = (cmph_uint8 )(tmp___0 % (unsigned int )bmz8->n);
    }
#line 440
    if ((int )h1 == (int )h2) {
#line 440
      h2 = (cmph_uint8 )((int )h2 + 1);
#line 440
      if ((int )h2 >= (int )bmz8->n) {
#line 440
        h2 = (cmph_uint8 )0;
      }
    }
#line 441
    if ((int )h1 == (int )h2) {
#line 443
      if (mph->verbosity) {
        {
#line 443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Self loop for key %u\n",
                (int )e);
        }
      }
      {
#line 444
      (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
      }
#line 445
      return (0);
    }
    {
#line 448
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 450
    multiple_edges = graph_contains_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
    }
#line 451
    if (mph->verbosity) {
#line 451
      if (multiple_edges) {
        {
#line 451
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A non simple graph was generated\n");
        }
      }
    }
#line 452
    if (multiple_edges) {
#line 452
      return (0);
    }
    {
#line 453
    graph_add_edge(bmz8->graph, (cmph_uint32 )h1, (cmph_uint32 )h2);
#line 430
    e = (cmph_uint8 )((int )e + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (! multiple_edges);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint32 const   bitmask32___31[32]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
  {      (cmph_uint32 const   )1,      (cmph_uint32 const   )(1 << 1),      (cmph_uint32 const   )(1 << 2),      (cmph_uint32 const   )(1 << 3), 
        (cmph_uint32 const   )(1 << 4),      (cmph_uint32 const   )(1 << 5),      (cmph_uint32 const   )(1 << 6),      (cmph_uint32 const   )(1 << 7), 
        (cmph_uint32 const   )(1 << 8),      (cmph_uint32 const   )(1 << 9),      (cmph_uint32 const   )(1 << 10),      (cmph_uint32 const   )(1 << 11), 
        (cmph_uint32 const   )(1 << 12),      (cmph_uint32 const   )(1 << 13),      (cmph_uint32 const   )(1 << 14),      (cmph_uint32 const   )(1 << 15), 
        (cmph_uint32 const   )(1 << 16),      (cmph_uint32 const   )(1 << 17),      (cmph_uint32 const   )(1 << 18),      (cmph_uint32 const   )(1 << 19), 
        (cmph_uint32 const   )(1 << 20),      (cmph_uint32 const   )(1 << 21),      (cmph_uint32 const   )(1 << 22),      (cmph_uint32 const   )(1 << 23), 
        (cmph_uint32 const   )(1 << 24),      (cmph_uint32 const   )(1 << 25),      (cmph_uint32 const   )(1 << 26),      (cmph_uint32 const   )(1 << 27), 
        (cmph_uint32 const   )(1 << 28),      (cmph_uint32 const   )(1 << 29),      (cmph_uint32 const   )(1 << 30),      (cmph_uint32 const   )(1U << 31)};
#line 5 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   bitmask___64[8]  = 
#line 5
  {      (cmph_uint8 const   )1,      (cmph_uint8 const   )(1 << 1),      (cmph_uint8 const   )(1 << 2),      (cmph_uint8 const   )(1 << 3), 
        (cmph_uint8 const   )(1 << 4),      (cmph_uint8 const   )(1 << 5),      (cmph_uint8 const   )(1 << 6),      (cmph_uint8 const   )(1 << 7)};
#line 13 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bitbool.h"
static cmph_uint8 const   valuemask___9[4]  = {      (cmph_uint8 const   )252,      (cmph_uint8 const   )243,      (cmph_uint8 const   )207,      (cmph_uint8 const   )63};
#line 48 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_queue___9(bdz_queue_t *queuep , cmph_uint32 nedges ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = malloc((unsigned long )nedges * sizeof(cmph_uint32 ));
#line 50
  *queuep = (bdz_queue_t )tmp;
  }
#line 51
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_queue___9(bdz_queue_t *queue ) 
{ 


  {
  {
#line 54
  free((void *)*queue);
  }
#line 55
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_alloc_graph3___9(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 68
  tmp = malloc((unsigned long )nedges * sizeof(bdz_edge_t ));
#line 68
  graph3->edges = (bdz_edge_t *)tmp;
#line 69
  tmp___0 = malloc((unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 69
  graph3->first_edge = (cmph_uint32 *)tmp___0;
#line 70
  tmp___1 = malloc((size_t )nvertices);
#line 70
  graph3->vert_degree = (cmph_uint8 *)tmp___1;
  }
#line 71
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_init_graph3___9(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 


  {
  {
#line 74
  memset((void *)graph3->first_edge, 255, (unsigned long )nvertices * sizeof(cmph_uint32 ));
#line 75
  memset((void *)graph3->vert_degree, 0, (size_t )nvertices);
#line 76
  graph3->nedges = (cmph_uint32 )0;
  }
#line 77
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_free_graph3___9(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 80
  free((void *)graph3->edges);
#line 81
  free((void *)graph3->first_edge);
#line 82
  free((void *)graph3->vert_degree);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_partial_free_graph3___9(bdz_graph3_t *graph3 ) 
{ 


  {
  {
#line 87
  free((void *)graph3->first_edge);
#line 88
  free((void *)graph3->vert_degree);
#line 89
  graph3->first_edge = (cmph_uint32 *)((void *)0);
#line 90
  graph3->vert_degree = (cmph_uint8 *)((void *)0);
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_add_edge___9(bdz_graph3_t *graph3 , cmph_uint32 v0 , cmph_uint32 v1 ,
                             cmph_uint32 v2 ) 
{ 
  cmph_uint32 tmp ;
  cmph_uint32 tmp___0 ;

  {
#line 95
  (graph3->edges + graph3->nedges)->vertices[0] = v0;
#line 96
  (graph3->edges + graph3->nedges)->vertices[1] = v1;
#line 97
  (graph3->edges + graph3->nedges)->vertices[2] = v2;
#line 98
  (graph3->edges + graph3->nedges)->next_edges[0] = *(graph3->first_edge + v0);
#line 99
  (graph3->edges + graph3->nedges)->next_edges[1] = *(graph3->first_edge + v1);
#line 100
  (graph3->edges + graph3->nedges)->next_edges[2] = *(graph3->first_edge + v2);
#line 101
  tmp___0 = graph3->nedges;
#line 101
  *(graph3->first_edge + v2) = tmp___0;
#line 101
  tmp = tmp___0;
#line 101
  *(graph3->first_edge + v1) = tmp;
#line 101
  *(graph3->first_edge + v0) = tmp;
#line 102
  *(graph3->vert_degree + v0) = (cmph_uint8 )((int )*(graph3->vert_degree + v0) + 1);
#line 103
  *(graph3->vert_degree + v1) = (cmph_uint8 )((int )*(graph3->vert_degree + v1) + 1);
#line 104
  *(graph3->vert_degree + v2) = (cmph_uint8 )((int )*(graph3->vert_degree + v2) + 1);
#line 105
  (graph3->nedges) ++;
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_dump_graph___9(bdz_graph3_t *graph3 , cmph_uint32 nedges , cmph_uint32 nvertices ) 
{ 
  int i ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((cmph_uint32 )i < nedges)) {
#line 111
      goto while_break;
    }
    {
#line 112
    printf((char const   */* __restrict  */)"\nedge %d %d %d %d ", i, (graph3->edges + i)->vertices[0],
           (graph3->edges + i)->vertices[1], (graph3->edges + i)->vertices[2]);
#line 114
    printf((char const   */* __restrict  */)" nexts %d %d %d", (graph3->edges + i)->next_edges[0],
           (graph3->edges + i)->next_edges[1], (graph3->edges + i)->next_edges[2]);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((cmph_uint32 )i < nvertices)) {
#line 118
      goto while_break___0;
    }
    {
#line 119
    printf((char const   */* __restrict  */)"\nfirst for vertice %d %d ", i, *(graph3->first_edge + i));
#line 118
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void bdz_remove_edge___9(bdz_graph3_t *graph3 , cmph_uint32 curr_edge ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 vert ;
  cmph_uint32 edge1 ;
  cmph_uint32 edge2 ;

  {
#line 126
  j = (cmph_uint32 )0;
#line 127
  i = (cmph_uint32 )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < 3U)) {
#line 127
      goto while_break;
    }
#line 128
    vert = (graph3->edges + curr_edge)->vertices[i];
#line 129
    edge1 = *(graph3->first_edge + vert);
#line 130
    edge2 = 4294967295U;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (edge1 != curr_edge) {
#line 131
        if (! (edge1 != 4294967295U)) {
#line 131
          goto while_break___0;
        }
      } else {
#line 131
        goto while_break___0;
      }
#line 132
      edge2 = edge1;
#line 133
      if ((graph3->edges + edge1)->vertices[0] == vert) {
#line 134
        j = (cmph_uint32 )0;
      } else
#line 135
      if ((graph3->edges + edge1)->vertices[1] == vert) {
#line 136
        j = (cmph_uint32 )1;
      } else {
#line 138
        j = (cmph_uint32 )2;
      }
#line 139
      edge1 = (graph3->edges + edge1)->next_edges[j];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    if (edge1 == 4294967295U) {
      {
#line 142
      printf((char const   */* __restrict  */)"\nerror remove edge %d dump graph",
             curr_edge);
#line 143
      bdz_dump_graph___9(graph3, graph3->nedges, graph3->nedges + graph3->nedges / 4U);
#line 144
      exit(-1);
      }
    }
#line 147
    if (edge2 != 4294967295U) {
#line 148
      (graph3->edges + edge2)->next_edges[j] = (graph3->edges + edge1)->next_edges[i];
    } else {
#line 151
      *(graph3->first_edge + vert) = (graph3->edges + edge1)->next_edges[i];
    }
#line 153
    *(graph3->vert_degree + vert) = (cmph_uint8 )((int )*(graph3->vert_degree + vert) - 1);
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_generate_queue___9(cmph_uint32 nedges , cmph_uint32 nvertices , bdz_queue_t queue ,
                                  bdz_graph3_t *graph3 ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint32 queue_head ;
  cmph_uint32 queue_tail ;
  cmph_uint32 curr_edge ;
  cmph_uint32 tmp_edge ;
  cmph_uint8 *marked_edge ;
  void *tmp ;
  cmph_uint32 tmp___0 ;
  cmph_uint32 tmp___1 ;
  cmph_uint32 tmp___2 ;
  cmph_uint32 tmp___3 ;
  cmph_uint32 tmp___4 ;

  {
  {
#line 161
  queue_head = (cmph_uint32 )0;
#line 161
  queue_tail = (cmph_uint32 )0;
#line 164
  tmp = malloc((size_t )(nedges >> 3) + 1UL);
#line 164
  marked_edge = (cmph_uint8 *)tmp;
#line 165
  memset((void *)marked_edge, 0, (size_t )(nedges >> 3) + 1UL);
#line 167
  i = (cmph_uint32 )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < nedges)) {
#line 167
      goto while_break;
    }
#line 168
    v0 = (graph3->edges + i)->vertices[0];
#line 169
    v1 = (graph3->edges + i)->vertices[1];
#line 170
    v2 = (graph3->edges + i)->vertices[2];
#line 171
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 171
      goto _L;
    } else
#line 171
    if ((int )*(graph3->vert_degree + v2) == 1) {
      _L: /* CIL Label */ 
#line 174
      if (! (((int )*(marked_edge + (i >> 3)) & (int )bitmask___64[i & 7U]) >> (i & 7U))) {
#line 175
        tmp___0 = queue_head;
#line 175
        queue_head ++;
#line 175
        *(queue + tmp___0) = i;
#line 176
        *(marked_edge + (i >> 3)) = (cmph_uint8 )((int )*(marked_edge + (i >> 3)) | (int )bitmask___64[i & 7U]);
      }
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (queue_tail != queue_head)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    tmp___1 = queue_tail;
#line 181
    queue_tail ++;
#line 181
    curr_edge = *(queue + tmp___1);
#line 182
    bdz_remove_edge___9(graph3, curr_edge);
#line 183
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 184
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 185
    v2 = (graph3->edges + curr_edge)->vertices[2];
    }
#line 186
    if ((int )*(graph3->vert_degree + v0) == 1) {
#line 187
      tmp_edge = *(graph3->first_edge + v0);
#line 188
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___64[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 189
        tmp___2 = queue_head;
#line 189
        queue_head ++;
#line 189
        *(queue + tmp___2) = tmp_edge;
#line 190
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___64[tmp_edge & 7U]);
      }
    }
#line 194
    if ((int )*(graph3->vert_degree + v1) == 1) {
#line 195
      tmp_edge = *(graph3->first_edge + v1);
#line 196
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___64[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 197
        tmp___3 = queue_head;
#line 197
        queue_head ++;
#line 197
        *(queue + tmp___3) = tmp_edge;
#line 198
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___64[tmp_edge & 7U]);
      }
    }
#line 202
    if ((int )*(graph3->vert_degree + v2) == 1) {
#line 203
      tmp_edge = *(graph3->first_edge + v2);
#line 204
      if (! (((int )*(marked_edge + (tmp_edge >> 3)) & (int )bitmask___64[tmp_edge & 7U]) >> (tmp_edge & 7U))) {
#line 205
        tmp___4 = queue_head;
#line 205
        queue_head ++;
#line 205
        *(queue + tmp___4) = tmp_edge;
#line 206
        *(marked_edge + (tmp_edge >> 3)) = (cmph_uint8 )((int )*(marked_edge + (tmp_edge >> 3)) | (int )bitmask___64[tmp_edge & 7U]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 210
  free((void *)marked_edge);
  }
#line 211
  return ((int )(queue_head - nedges));
}
}
#line 214
static int bdz_mapping___9(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 215
static void assigning___20(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) ;
#line 216
static void ranking___9(bdz_config_data_t *bdz ) ;
#line 217
__inline static cmph_uint32 rank(cmph_uint32 b , cmph_uint32 *ranktable , cmph_uint8 *g ,
                                 cmph_uint32 vertex ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static int bdz_mapping___9(cmph_config_t *mph , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 e ;
  int cycles ;
  cmph_uint32 hl[3] ;
  bdz_config_data_t *bdz ;
  cmph_uint32 h0 ;
  cmph_uint32 h1 ;
  cmph_uint32 h2 ;
  cmph_uint32 keylen ;
  char *key ;

  {
  {
#line 391
  cycles = 0;
#line 393
  bdz = (bdz_config_data_t *)mph->data;
#line 394
  bdz_init_graph3___9(graph3, bdz->m, bdz->n);
#line 395
  (*((mph->key_source)->rewind))((mph->key_source)->data);
#line 396
  e = (cmph_uint32 )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (e < (mph->key_source)->nkeys)) {
#line 396
      goto while_break;
    }
    {
#line 400
    key = (char *)((void *)0);
#line 401
    (*((mph->key_source)->read))((mph->key_source)->data, & key, & keylen);
#line 402
    hash_vector(bdz->hl, (char const   *)key, keylen, hl);
#line 403
    h0 = hl[0] % bdz->r;
#line 404
    h1 = hl[1] % bdz->r + bdz->r;
#line 405
    h2 = hl[2] % bdz->r + (bdz->r << 1);
#line 406
    (*((mph->key_source)->dispose))((mph->key_source)->data, key, keylen);
#line 407
    bdz_add_edge___9(graph3, h0, h1, h2);
#line 396
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  cycles = bdz_generate_queue___9(bdz->m, bdz->n, queue, graph3);
  }
#line 410
  return (cycles == 0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void assigning___20(bdz_config_data_t *bdz , bdz_graph3_t *graph3 , bdz_queue_t queue ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 nedges ;
  cmph_uint32 curr_edge ;
  cmph_uint32 v0 ;
  cmph_uint32 v1 ;
  cmph_uint32 v2 ;
  cmph_uint8 *marked_vertices ;
  void *tmp ;
  cmph_uint32 sizeg ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 416
  nedges = graph3->nedges;
#line 419
  tmp = malloc((size_t )(bdz->n >> 3) + 1UL);
#line 419
  marked_vertices = (cmph_uint8 *)tmp;
#line 420
  tmp___0 = ceil((double )bdz->n / 4.0);
#line 420
  sizeg = (cmph_uint32 )tmp___0;
#line 421
  tmp___1 = calloc((size_t )sizeg, sizeof(cmph_uint8 ));
#line 421
  bdz->g = (cmph_uint8 *)tmp___1;
#line 422
  memset((void *)marked_vertices, 0, (size_t )(bdz->n >> 3) + 1UL);
#line 423
  memset((void *)bdz->g, 255, (size_t )sizeg);
#line 425
  i = nedges - 1U;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i + 1U >= 1U)) {
#line 425
      goto while_break;
    }
#line 426
    curr_edge = *(queue + i);
#line 427
    v0 = (graph3->edges + curr_edge)->vertices[0];
#line 428
    v1 = (graph3->edges + curr_edge)->vertices[1];
#line 429
    v2 = (graph3->edges + curr_edge)->vertices[2];
#line 431
    if (! (((int )*(marked_vertices + (v0 >> 3)) & (int )bitmask___64[v0 & 7U]) >> (v0 & 7U))) {
#line 432
      if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___64[v1 & 7U]) >> (v1 & 7U))) {
#line 434
        *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )((3U << ((v1 & 3U) << 1)) | (unsigned int )valuemask___9[v1 & 3U])));
#line 435
        *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___64[v1 & 7U]);
      }
#line 437
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___64[v2 & 7U]) >> (v2 & 7U))) {
#line 439
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___9[v2 & 3U])));
#line 440
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___64[v2 & 7U]);
      }
#line 442
      *(bdz->g + (v0 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v0 >> 2)) & (int )((cmph_uint8 )(((6 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v0 & 3U) << 1)) | (int )valuemask___9[v0 & 3U])));
#line 443
      *(marked_vertices + (v0 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v0 >> 3)) | (int )bitmask___64[v0 & 7U]);
    } else
#line 444
    if (! (((int )*(marked_vertices + (v1 >> 3)) & (int )bitmask___64[v1 & 7U]) >> (v1 & 7U))) {
#line 445
      if (! (((int )*(marked_vertices + (v2 >> 3)) & (int )bitmask___64[v2 & 7U]) >> (v2 & 7U))) {
#line 447
        *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )((3U << ((v2 & 3U) << 1)) | (unsigned int )valuemask___9[v2 & 3U])));
#line 448
        *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___64[v2 & 7U]);
      }
#line 450
      *(bdz->g + (v1 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v1 >> 2)) & (int )((cmph_uint8 )(((7 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v2 >> 2)) >> ((v2 & 3U) << 1U)) & 3U)))) % 3 << ((v1 & 3U) << 1)) | (int )valuemask___9[v1 & 3U])));
#line 451
      *(marked_vertices + (v1 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v1 >> 3)) | (int )bitmask___64[v1 & 7U]);
    } else {
#line 453
      *(bdz->g + (v2 >> 2)) = (cmph_uint8 )((int )*(bdz->g + (v2 >> 2)) & (int )((cmph_uint8 )(((8 - ((int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v0 >> 2)) >> ((v0 & 3U) << 1U)) & 3U)) + (int )((cmph_uint8 )((unsigned int )((int )*(bdz->g + (v1 >> 2)) >> ((v1 & 3U) << 1U)) & 3U)))) % 3 << ((v2 & 3U) << 1)) | (int )valuemask___9[v2 & 3U])));
#line 454
      *(marked_vertices + (v2 >> 3)) = (cmph_uint8 )((int )*(marked_vertices + (v2 >> 3)) | (int )bitmask___64[v2 & 7U]);
    }
#line 425
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)marked_vertices);
  }
#line 459
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/cmph-0.9/src/bdz.c"
static void ranking___9(bdz_config_data_t *bdz ) 
{ 
  cmph_uint32 i ;
  cmph_uint32 j ;
  cmph_uint32 offset ;
  cmph_uint32 count ;
  cmph_uint32 size ;
  cmph_uint32 nbytes_total ;
  double tmp ;
  cmph_uint32 nbytes ;
  void *tmp___0 ;

  {
  {
#line 464
  offset = 0U;
#line 464
  count = 0U;
#line 464
  size = bdz->k >> 2U;
#line 464
  tmp = ceil((double )bdz->n / 4.0);
#line 464
  nbytes_total = (cmph_uint32 )tmp;
#line 465
  tmp___0 = calloc((size_t )bdz->ranktablesize, sizeof(cmph_uint32 ));
#line 465
  bdz->ranktable = (cmph_uint32 *)tmp___0;
#line 467
  *(bdz->ranktable + 0) = (cmph_uint32 )0;
#line 468
  i = (cmph_uint32 )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (i == bdz->ranktablesize) {
#line 471
      goto while_break;
    }
#line 472
    if (size < nbytes_total) {
#line 472
      nbytes = size;
    } else {
#line 472
      nbytes = nbytes_total;
    }
#line 473
    j = (cmph_uint32 )0;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 473
      if (! (j < nbytes)) {
#line 473
        goto while_break___0;
      }
#line 475
      count += (cmph_uint32 )bdz_lookup_table[*((bdz->g + offset) + j)];
#line 473
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 477
    *(bdz->ranktable + i) = count;
#line 478
    offset += nbytes;
#line 479
    nbytes_total -= size;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return;
}
}
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
