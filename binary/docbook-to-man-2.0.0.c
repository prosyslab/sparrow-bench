/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 139 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct __anonstruct_Mapping_t_27 {
   char *name ;
   char *sval ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct __anonstruct_Mapping_t_27 Mapping_t;
#line 156 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct _ent {
   char *type ;
   char *ename ;
   char *nname ;
   char *sysid ;
   char *pubid ;
   char *fname ;
   struct _ent *next ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct _ent Entity_t;
#line 168
struct _elem;
#line 168 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
union __anonunion_ch_30 {
   struct _elem *elem ;
   char *data ;
};
#line 168 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct __anonstruct_Content_t_29 {
   char type ;
   union __anonunion_ch_30 ch ;
};
#line 168 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct __anonstruct_Content_t_29 Content_t;
#line 177 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct _elem {
   char *gi ;
   Content_t *cont ;
   int ncont ;
   struct _elem **econt ;
   int necont ;
   char **dcont ;
   int ndcont ;
   Mapping_t *atts ;
   int natts ;
   Entity_t *entity ;
   char *id ;
   int index ;
   int depth ;
   int lineno ;
   char *infile ;
   int my_eorder ;
   struct _elem *parent ;
   struct _elem *next ;
   void *trans ;
   int gen_trans[2] ;
   int processed ;
};
#line 177 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct _elem Element_t;
#line 203 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct id_s {
   char *id ;
   Element_t *elem ;
   struct id_s *next ;
};
#line 203 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct id_s ID_t;
#line 8 "tptregexp/tptregexp.h"
struct regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 8 "tptregexp/tptregexp.h"
typedef struct regexp regexp;
#line 106 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
enum __anonenum_Relation_t_26 {
    REL_None = 0,
    REL_Parent = 1,
    REL_Child = 2,
    REL_Ancestor = 3,
    REL_Descendant = 4,
    REL_Sibling = 5,
    REL_Preceding = 6,
    REL_ImmPreceding = 7,
    REL_Following = 8,
    REL_ImmFollowing = 9,
    REL_Cousin = 10,
    REL_Unknown = 11
} ;
#line 106 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef enum __anonenum_Relation_t_26 Relation_t;
#line 144 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
struct __anonstruct_Map_t_28 {
   int n_alloc ;
   int n_used ;
   int slot_incr ;
   int flags ;
   Mapping_t *maps ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef struct __anonstruct_Map_t_28 Map_t;
#line 73 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
enum __anonenum_RelAction_t_31 {
    RA_Current = 0,
    RA_Related = 1
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
typedef enum __anonenum_RelAction_t_31 RelAction_t;
#line 75 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
struct __anonstruct_AttPair_t_32 {
   char *name ;
   char *val ;
   regexp *rex ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
typedef struct __anonstruct_AttPair_t_32 AttPair_t;
#line 81 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
struct _Trans {
   char *gi ;
   char **gilist ;
   char *context ;
   regexp *context_re ;
   int depth ;
   AttPair_t *attpair ;
   int nattpairs ;
   char *parent ;
   int nth_child ;
   char *content ;
   regexp *content_re ;
   char *pattrset ;
   char *var_name ;
   char *var_value ;
   char *var_RE_name ;
   regexp *var_RE_value ;
   Map_t *relations ;
   char *starttext ;
   char *endtext ;
   char *replace ;
   char *message ;
   int ignore ;
   int verbatim ;
   char *var_reset ;
   char *increment ;
   Map_t *set_var ;
   Map_t *incr_var ;
   char *quit ;
   int my_id ;
   int use_id ;
   struct _Trans *use_trans ;
   struct _Trans *next ;
   int lineno ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
typedef struct _Trans Trans_t;
#line 636 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
struct __anonstruct_Descent_t_33 {
   char *gi ;
   char *gi2 ;
   char action[10] ;
   Element_t *elem ;
   FILE *fp ;
};
#line 636 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
typedef struct __anonstruct_Descent_t_33 Descent_t;
#line 132 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
typedef short bool;
#line 109 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
enum __anonenum_tblalign_33 {
    Left = 0,
    Right = 1,
    Center = 2,
    Justify = 3,
    Char = 4,
    Span = 5
} ;
#line 109 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
typedef enum __anonenum_tblalign_33 tblalign;
#line 111
enum __anonenum_tblsource_34 {
    TGroup = 0,
    THead = 1,
    TFoot = 2,
    TBody = 3
} ;
#line 111 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
typedef enum __anonenum_tblsource_34 tblsource;
#line 116 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblcolspec {
   char name[40] ;
   short num ;
   tblsource source ;
   tblalign align ;
   char alignchar ;
   short aligncharoff ;
   char colwidth[10] ;
   char colpwidth[10] ;
   bool colsep ;
   bool rowsep ;
   short moreRows ;
   struct tblcolspec *next ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblspanspec {
   char name[40] ;
   tblsource source ;
   struct tblcolspec *start ;
   struct tblcolspec *end ;
   tblalign align ;
   char alignchar ;
   short aligncharoff ;
   bool colsep ;
   bool rowsep ;
   struct tblspanspec *next ;
};
#line 150 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblformat {
   short count ;
   short cols ;
   short rowNum ;
   char colformat[30] ;
   char colwidth[30][10] ;
   char colpwidth[30][10] ;
   char font[30][3] ;
   bool colsep[30] ;
   bool rowsep[30] ;
   short moreRows[30] ;
   struct tblformat *next ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct __anonstruct_TableInfo_35 {
   char *cols ;
   char *align ;
   char **align_v ;
   char *colwidth ;
   char **colwidth_v ;
   char *colsep ;
   char **colsep_v ;
   char *rowsep ;
   char **rowsep_v ;
   char *frame ;
   char *orient ;
   int pgwide ;
   int n_align ;
   int n_model ;
   int n_colwidth ;
   int n_colsep ;
   int nc ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
typedef struct __anonstruct_TableInfo_35 TableInfo;
#line 883
struct Element_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 218 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
char **UsedElem ;
#line 219
int nUsedElem ;
#line 222
ID_t *IDList ;
#line 228
FILE *outfp ;
#line 284
char *FindContext(Element_t *e , int levels , char *con ) ;
#line 294
void DescendTree(Element_t *e , void (*enter_f)() , void (*leave_f)() , void (*data_f)() ,
                 void *dp ) ;
#line 315
void PrintContext(Element_t *e ) ;
#line 316
void PrintElemSummary(Element_t *e ) ;
#line 317
void PrintElemTree(Element_t *e ) ;
#line 318
void PrintStats(Element_t *top ) ;
#line 319
void PrintIDList(void) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
static void print_summ(Element_t *e ) 
{ 
  int i ;
  int n ;
  int dsize ;
  char *hfmt ;
  char *fmt ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 90
  hfmt = (char *)"%-18.18s %4s %5s %4s %4s %s\n";
#line 91
  fmt = (char *)"%-18.18s %4d %5d %4d %4d %s\n";
#line 93
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 94
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)hfmt,
            "Element", "Att", "Data", "Chd", "Dep", "Parent");
    }
#line 95
    return;
  }
#line 97
  i = 0;
#line 97
  n = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < e->ncont)) {
#line 97
      goto while_break;
    }
#line 97
    if ((int )(e->cont + i)->type == 40) {
#line 97
      n ++;
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  i = 0;
#line 98
  dsize = 0;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! (i < e->ncont)) {
#line 98
      goto while_break___0;
    }
#line 99
    if ((int )(e->cont + i)->type == 40) {
      {
#line 99
      tmp = strlen((char const   *)(e->cont + i)->ch.data);
#line 99
      dsize = (int )((size_t )dsize + tmp);
      }
    }
#line 98
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  if (e->parent) {
#line 100
    tmp___0 = (char const   *)(e->parent)->gi;
  } else {
#line 100
    tmp___0 = "-";
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)fmt, e->gi,
          e->natts, dsize, n, e->depth, tmp___0);
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 103
    if (! (i < e->natts)) {
#line 103
      goto while_break___1;
    }
#line 104
    if ((e->atts + i)->sval) {
#line 104
      tmp___1 = (char const   *)(e->atts + i)->sval;
    } else {
#line 104
      tmp___1 = "empty";
    }
    {
#line 104
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%45d: %s = %s\n",
            i, (e->atts + i)->name, tmp___1);
#line 103
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
void PrintElemSummary(Element_t *e ) 
{ 


  {
  {
#line 118
  print_summ((Element_t *)0);
#line 119
  DescendTree(e, (void (*)())(& print_summ), (void (*)())0, (void (*)())0, (void *)0);
  }
#line 120
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
static void print_context(Element_t *e ) 
{ 
  char buf___0[60000] ;
  char *tmp ;

  {
  {
#line 138
  tmp = FindContext(e, 10, buf___0);
#line 138
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %s\n",
          e->gi, tmp);
  }
#line 139
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
void PrintContext(Element_t *e ) 
{ 


  {
  {
#line 150
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %s\n",
          "Element", "Context");
#line 151
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %s\n",
          "---------------", "-----------");
#line 152
  DescendTree(e, (void (*)())(& print_context), (void (*)())0, (void (*)())0, (void *)0);
#line 154
  _IO_putc('\n', outfp);
  }
#line 155
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
static void print_indent(Element_t *e ) 
{ 
  int i ;
  int ne ;
  int nd ;

  {
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < e->depth)) {
#line 172
      goto while_break;
    }
    {
#line 172
    fputs((char const   */* __restrict  */)".  ", (FILE */* __restrict  */)outfp);
#line 172
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  i = 0;
#line 173
  ne = 0;
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! (i < e->ncont)) {
#line 173
      goto while_break___0;
    }
#line 173
    if ((int )(e->cont + i)->type == 40) {
#line 173
      ne ++;
    }
#line 173
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  i = 0;
#line 174
  nd = 0;
  {
#line 174
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 174
    if (! (i < e->ncont)) {
#line 174
      goto while_break___1;
    }
#line 174
    if ((int )(e->cont + i)->type == 45) {
#line 174
      nd ++;
    }
#line 174
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 175
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s  (%d,%d)\n",
          e->gi, ne, nd);
  }
#line 176
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
void PrintElemTree(Element_t *e ) 
{ 


  {
  {
#line 187
  DescendTree(e, (void (*)())(& print_indent), (void (*)())0, (void (*)())0, (void *)0);
#line 188
  _IO_putc('\n', outfp);
  }
#line 189
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
static void acc_tots(Element_t *e , int *tot_el , int *tot_data , int *max_depth ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < e->necont)) {
#line 211
      goto while_break;
    }
    {
#line 212
    acc_tots(*(e->econt + i), tot_el, tot_data, max_depth);
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! (i < e->necont)) {
#line 213
      goto while_break___0;
    }
#line 213
    (*tot_el) ++;
#line 213
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 214
    if (! (i < e->ndcont)) {
#line 214
      goto while_break___1;
    }
    {
#line 214
    tmp = strlen((char const   *)*(e->dcont + i));
#line 214
    *tot_data = (int )((size_t )*tot_data + tmp);
#line 214
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 215
  if (e->depth > *max_depth) {
#line 215
    *max_depth = e->depth;
  }
#line 216
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
static void elem_usage(Element_t *e , char *name , int *n_used , int *nchars ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 234
  tmp___0 = strcmp((char const   *)name, (char const   *)e->gi);
  }
#line 234
  if (! tmp___0) {
#line 235
    (*n_used) ++;
#line 236
    i = 0;
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (i < e->ncont)) {
#line 236
        goto while_break;
      }
#line 237
      if ((int )(e->cont + i)->type == 45) {
        {
#line 237
        tmp = strlen((char const   *)(e->cont + i)->ch.data);
#line 237
        *nchars = (int )((size_t )*nchars + tmp);
        }
      }
#line 236
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! (i < e->necont)) {
#line 239
      goto while_break___0;
    }
    {
#line 240
    elem_usage(*(e->econt + i), name, n_used, nchars);
#line 239
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
void PrintStats(Element_t *top ) 
{ 
  int i ;
  int n ;
  int dif_el ;
  int tot_el ;
  int tot_data ;
  int nchars ;
  int max_depth ;
  float pct ;

  {
  {
#line 253
  dif_el = 0;
#line 253
  tot_el = 0;
#line 253
  tot_data = 0;
#line 253
  max_depth = 0;
#line 256
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %s   %s\n",
          "Element name", "Occurrances", "Character Content");
#line 257
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %s   %s\n",
          "---------------", "-----------", "-----------------");
#line 259
  acc_tots(top, & tot_el, & tot_data, & max_depth);
#line 261
  i = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < nUsedElem)) {
#line 261
      goto while_break;
    }
    {
#line 262
    n = 0;
#line 263
    nchars = 0;
#line 264
    elem_usage(top, *(UsedElem + i), & n, & nchars);
    }
#line 265
    if (n > 0) {
      {
#line 266
      pct = (float )((100.0 * (double )((float )n)) / (double )((float )tot_el));
#line 267
      fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%-22s %4d  %4.1f%%   %6d  %4d\n",
              *(UsedElem + i), n, (double )pct, nchars, nchars / n);
#line 269
      dif_el ++;
      }
    }
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\nTotal of %d elements used, %d different ones.\n",
          tot_el, dif_el);
#line 275
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"Total character data: %d.\n",
          tot_data);
#line 276
  fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"Maximum element depth: %d.\n",
          max_depth);
#line 277
  _IO_putc('\n', outfp);
  }
#line 278
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/info.c"
void PrintIDList(void) 
{ 
  ID_t *id ;
  Element_t *ep ;
  char const   *tmp ;

  {
#line 292
  id = IDList;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! id) {
#line 292
      goto while_break;
    }
#line 293
    ep = id->elem;
#line 294
    if (ep->infile) {
#line 294
      tmp = (char const   *)ep->infile;
    } else {
#line 294
      tmp = "-";
    }
    {
#line 294
    fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s:%s:%s:%d\n",
            id->id, ep->gi, tmp, ep->lineno);
#line 292
    id = id->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Element_t *DocTree ;
#line 223
Map_t *Variables ;
#line 234
int fold_case ;
#line 281
Element_t *QRelation(Element_t *e , char *s , Relation_t rel ) ;
#line 283
char *FindAttValByName(Element_t *e , char *name ) ;
#line 288
void OutputString(char *s , FILE *fp , int track_pos ) ;
#line 289
FILE *OpenFile(char *filename ) ;
#line 290
char *FindElementPath(Element_t *e , char *s ) ;
#line 292
void PrintLocation(Element_t *e , FILE *fp ) ;
#line 293
char **Split(char *s , int *ntok , int flag ) ;
#line 297
char *FindMappingVal(Map_t *M , char *name ) ;
#line 299
void SetMappingNV(Map_t *M , char *name , char *value ) ;
#line 301
Element_t *FindElemByID(char *idval ) ;
#line 312
char *Get_A_C_value(char *name ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
int CheckRelation(Element_t *e , char *relname , char *related , char *actname , FILE *fp ,
                  RelAction_t flag ) ;
#line 137
Trans_t *FindTrans(Element_t *e , int specID ) ;
#line 142
void TransElement(Element_t *e , FILE *fp , Trans_t *t ) ;
#line 144
void TranTByAction(Element_t *e , char *strn , FILE *fp ) ;
#line 147
void ExpandSpecialVar(char *name , Element_t *e , FILE *fp , int track_pos ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static char **idrefs  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static char *def_idrefs[4]  = {      (char *)"LINKEND",      (char *)"LINKENDS",      (char *)"IDREF",      (char *)0};
#line 75 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static char *each_A  =    (char *)0;
#line 76 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static char *each_C  =    (char *)0;
#line 79
void ChaseIDRefs(Element_t *e , char *gi , char *action , FILE *fp ) ;
#line 80
void Find(Element_t *e , int ac , char **av , FILE *fp ) ;
#line 81
void GetIDREFnames(void) ;
#line 443
void CALStable(Element_t *e , FILE *fp , char **av , int ac ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
void ExpandSpecialVar(char *name , Element_t *e , FILE *fp , int track_pos ) 
{ 
  FILE *infile ;
  char buf___0[60000] ;
  char *cp ;
  char *atval ;
  char **tok ;
  int ntok ;
  int n ;
  int i ;
  int actioni ;
  char *action ;
  char *action1 ;
  Element_t *ep ;
  Trans_t *t ;
  Trans_t *tt ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  char **s ;
  struct _elem *tmp___8 ;
  int id ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int id___0 ;
  int id___1 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;

  {
#line 111
  if ((int )*name == 33) {
    {
#line 112
    name ++;
#line 113
    infile = popen((char const   *)name, "r");
    }
#line 113
    if (infile) {
      {
#line 114
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 114
        tmp = fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)infile);
        }
#line 114
        if (! tmp) {
#line 114
          goto while_break;
        }
        {
#line 114
        fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)fp);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 115
      pclose(infile);
#line 116
      fflush(fp);
      }
    } else {
      {
#line 119
      tmp___0 = __errno_location();
#line 119
      tmp___1 = strerror(*tmp___0);
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not start program \'%s\': %s",
              name, tmp___1);
      }
    }
#line 122
    return;
  }
#line 128
  if ((int )*name == 65) {
#line 128
    if ((int )*(name + 1) == 0) {
#line 128
      if (each_A) {
        {
#line 129
        OutputString(each_A, fp, track_pos);
        }
#line 130
        return;
      }
    }
  }
#line 132
  if ((int )*name == 67) {
#line 132
    if ((int )*(name + 1) == 0) {
#line 132
      if (each_C) {
        {
#line 133
        OutputString(each_C, fp, track_pos);
        }
#line 134
        return;
      }
    }
  }
  {
#line 137
  ntok = 0;
#line 138
  tok = Split(name, & ntok, 0);
  }
#line 142
  if ((int )*(*(tok + 0) + 0) == (int )*("include" + 0)) {
    {
#line 142
    tmp___44 = strcmp((char const   *)*(tok + 0), "include");
    }
#line 142
    if (tmp___44) {
#line 142
      goto _L___29;
    } else {
#line 143
      name = *(tok + 1);
#line 144
      if (ntok > 1) {
        {
#line 145
        infile = OpenFile(name);
        }
#line 145
        if ((unsigned long )infile == (unsigned long )((void *)0)) {
          {
#line 146
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Can not open included file \'%s\'",
                  name);
#line 147
          perror((char const   *)(buf___0));
          }
#line 148
          return;
        }
        {
#line 150
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 150
          tmp___2 = fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)infile);
          }
#line 150
          if (! tmp___2) {
#line 150
            goto while_break___0;
          }
          {
#line 150
          fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 151
        fclose(infile);
        }
      } else {
        {
#line 153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No file name specified for include\n");
        }
      }
#line 154
      return;
    }
  } else
  _L___29: /* CIL Label */ 
#line 159
  if ((int )*(*(tok + 0) + 0) == (int )*("location" + 0)) {
    {
#line 159
    tmp___43 = strcmp((char const   *)*(tok + 0), "location");
    }
#line 159
    if (tmp___43) {
#line 159
      goto _L___28;
    } else {
      {
#line 160
      PrintLocation(e, fp);
      }
    }
  } else
  _L___28: /* CIL Label */ 
#line 165
  if ((int )*(*(tok + 0) + 0) == (int )*("path" + 0)) {
    {
#line 165
    tmp___42 = strcmp((char const   *)*(tok + 0), "path");
    }
#line 165
    if (tmp___42) {
#line 165
      goto _L___27;
    } else {
      {
#line 166
      FindElementPath(e, buf___0);
#line 167
      OutputString(buf___0, fp, track_pos);
      }
    }
  } else
  _L___27: /* CIL Label */ 
#line 172
  if ((int )*(*(tok + 0) + 0) == (int )*("gi" + 0)) {
    {
#line 172
    tmp___41 = strcmp((char const   *)*(tok + 0), "gi");
    }
#line 172
    if (tmp___41) {
#line 172
      goto _L___26;
    } else {
      {
#line 173
      strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)e->gi);
      }
#line 174
      if (ntok >= 2) {
#line 175
        if ((int )*(*(tok + 1)) == 76) {
#line 175
          goto _L;
        } else
#line 175
        if ((int )*(*(tok + 1)) == 108) {
#line 175
          goto _L;
        } else
#line 175
        if ((int )*(*(tok + 1)) == 77) {
#line 175
          goto _L;
        } else
#line 175
        if ((int )*(*(tok + 1)) == 109) {
          _L: /* CIL Label */ 
#line 177
          cp = buf___0;
          {
#line 177
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 177
            if (! *cp) {
#line 177
              goto while_break___1;
            }
            {
#line 178
            tmp___4 = __ctype_b_loc();
            }
#line 178
            if ((int const   )*(*tmp___4 + (int )*cp) & 256) {
              {
#line 178
              tmp___3 = tolower((int )*cp);
#line 178
              *cp = (char )tmp___3;
              }
            }
#line 177
            cp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 180
        if ((int )*(*(tok + 1)) == 77) {
#line 180
          goto _L___0;
        } else
#line 180
        if ((int )*(*(tok + 1)) == 109) {
          _L___0: /* CIL Label */ 
          {
#line 181
          tmp___6 = __ctype_b_loc();
          }
#line 181
          if ((int const   )*(*tmp___6 + (int )buf___0[0]) & 512) {
            {
#line 181
            tmp___5 = toupper((int )buf___0[0]);
#line 181
            buf___0[0] = (char )tmp___5;
            }
          }
        }
      }
      {
#line 183
      OutputString(buf___0, fp, track_pos);
      }
    }
  } else
  _L___26: /* CIL Label */ 
#line 188
  if ((int )*(*(tok + 0) + 0) == (int )*("filename" + 0)) {
    {
#line 188
    tmp___40 = strcmp((char const   *)*(tok + 0), "filename");
    }
#line 188
    if (tmp___40) {
#line 188
      goto _L___25;
    } else {
#line 189
      if (! e->entity) {
        {
#line 190
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected ext entity (internal error? bug?):\n");
#line 191
        PrintLocation(e, stderr);
        }
#line 192
        return;
      }
#line 194
      if (! (e->entity)->fname) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected filename (internal error? bug?):\n");
#line 196
        PrintLocation(e, stderr);
        }
#line 197
        return;
      }
      {
#line 199
      OutputString((e->entity)->fname, fp, track_pos);
      }
    }
  } else
  _L___25: /* CIL Label */ 
#line 204
  if ((int )*(*(tok + 0) + 0) == (int )*("pattr" + 0)) {
    {
#line 204
    tmp___39 = strcmp((char const   *)*(tok + 0), "pattr");
    }
#line 204
    if (tmp___39) {
#line 204
      goto _L___24;
    } else {
#line 205
      ep = e->parent;
#line 206
      if (! ep) {
        {
#line 207
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Element does not have a parent:\n");
#line 208
        PrintLocation(ep, stderr);
        }
#line 209
        return;
      }
      {
#line 211
      atval = FindAttValByName(ep, *(tok + 1));
      }
#line 211
      if (atval) {
        {
#line 212
        OutputString(atval, fp, track_pos);
        }
      }
    }
  } else
  _L___24: /* CIL Label */ 
#line 218
  if ((int )*(*(tok + 0) + 0) == (int )*("action" + 0)) {
    {
#line 218
    tmp___38 = strcmp((char const   *)*(tok + 0), "action");
    }
#line 218
    if (tmp___38) {
#line 218
      goto _L___23;
    } else {
      {
#line 219
      TranTByAction(e, *(tok + 1), fp);
      }
    }
  } else
  _L___23: /* CIL Label */ 
#line 224
  if ((int )*(*(tok + 0) + 0) == (int )*("nchild" + 0)) {
    {
#line 224
    tmp___37 = strcmp((char const   *)*(tok + 0), "nchild");
    }
#line 224
    if (tmp___37) {
#line 224
      goto _L___22;
    } else {
#line 225
      if (ntok > 1) {
#line 226
        n = 0;
#line 226
        i = 0;
        {
#line 226
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 226
          if (! (i < e->necont)) {
#line 226
            goto while_break___2;
          }
#line 227
          if ((int )*((*(e->econt + i))->gi + 0) == (int )*(*(tok + 1) + 0)) {
            {
#line 227
            tmp___7 = strcmp((char const   *)(*(e->econt + i))->gi, (char const   *)*(tok + 1));
            }
#line 227
            if (! tmp___7) {
#line 227
              n ++;
            }
          }
#line 226
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 229
        n = e->necont;
      }
      {
#line 230
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              n);
#line 231
      OutputString(buf___0, fp, track_pos);
      }
    }
  } else
  _L___22: /* CIL Label */ 
#line 236
  if ((int )*(*(tok + 0) + 0) == (int )*("n1gchild" + 0)) {
    {
#line 236
    tmp___36 = strcmp((char const   *)*(tok + 0), "n1gchild");
    }
#line 236
    if (tmp___36) {
#line 236
      goto _L___21;
    } else
#line 237
    if (e->necont) {
      {
#line 238
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
              (*(e->econt + 0))->necont);
#line 239
      OutputString(buf___0, fp, track_pos);
      }
    }
  } else
  _L___21: /* CIL Label */ 
#line 246
  if ((int )*(*(tok + 0) + 0) == (int )*("chasetogi" + 0)) {
    {
#line 246
    tmp___35 = strcmp((char const   *)*(tok + 0), "chasetogi");
    }
#line 246
    if (tmp___35) {
#line 246
      goto _L___20;
    } else {
#line 247
      if (ntok < 3) {
        {
#line 248
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Not enough args for _chasetogi.\n");
        }
#line 249
        return;
      }
      {
#line 251
      actioni = atoi((char const   *)*(tok + 2));
      }
#line 252
      if (actioni) {
        {
#line 252
        ChaseIDRefs(e, *(tok + 1), *(tok + 2), fp);
        }
      }
    }
  } else
  _L___20: /* CIL Label */ 
#line 257
  if ((int )*(*(tok + 0) + 0) == (int )*("followlink" + 0)) {
    {
#line 257
    tmp___34 = strcmp((char const   *)*(tok + 0), "followlink");
    }
#line 257
    if (tmp___34) {
#line 257
      goto _L___19;
    } else {
#line 259
      if (ntok > 2) {
        {
#line 260
        atval = FindAttValByName(e, *(tok + 1));
        }
#line 260
        if (atval) {
          {
#line 261
          ep = FindElemByID(atval);
          }
#line 261
          if (ep) {
            {
#line 262
            TranTByAction(ep, *(tok + 2), fp);
            }
#line 263
            return;
          }
        } else {
          {
#line 266
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Did not find attr: %s.\n",
                  *(tok + 1));
          }
        }
#line 267
        return;
      }
      {
#line 269
      GetIDREFnames();
#line 270
      s = idrefs;
      }
      {
#line 270
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 270
        if (! *s) {
#line 270
          goto while_break___3;
        }
        {
#line 272
        atval = FindAttValByName(e, *s);
        }
#line 272
        if (atval) {
          {
#line 273
          ntok = 0;
#line 274
          tok = Split(atval, & ntok, 1);
#line 276
          ep = FindElemByID(*(tok + 0));
          }
#line 276
          if (ep) {
            {
#line 277
            TranTByAction(ep, *(tok + 1), fp);
            }
#line 278
            return;
          } else {
            {
#line 280
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can not find elem for ID: %s.\n",
                    *(tok + 0));
            }
          }
        }
#line 270
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 284
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Element does not have IDREF attribute set:\n");
#line 285
      PrintLocation(e, stderr);
      }
#line 286
      return;
    }
  } else
  _L___19: /* CIL Label */ 
#line 292
  if ((int )*(*(tok + 0) + 0) == (int )*("find" + 0)) {
    {
#line 292
    tmp___33 = strcmp((char const   *)*(tok + 0), "find");
    }
#line 292
    if (tmp___33) {
#line 292
      goto _L___18;
    } else {
      {
#line 293
      Find(e, ntok, tok, fp);
      }
    }
  } else
  _L___18: /* CIL Label */ 
#line 299
  if ((int )*(*(tok + 0) + 0) == (int )*("pfind" + 0)) {
    {
#line 299
    tmp___32 = strcmp((char const   *)*(tok + 0), "pfind");
    }
#line 299
    if (tmp___32) {
#line 299
      goto _L___17;
    } else {
#line 300
      if (e->parent) {
#line 300
        tmp___8 = e->parent;
      } else {
#line 300
        tmp___8 = e;
      }
      {
#line 300
      Find(tmp___8, ntok, tok, fp);
      }
    }
  } else
  _L___17: /* CIL Label */ 
#line 306
  if ((int )*(*(tok + 0) + 0) == (int )*("namelist" + 0)) {
    {
#line 306
    tmp___31 = strcmp((char const   *)*(tok + 0), "namelist");
    }
#line 306
    if (tmp___31) {
#line 306
      goto _L___16;
    } else {
#line 308
      action1 = *(tok + 1);
#line 309
      if (ntok > 2) {
#line 309
        action = *(tok + 2);
      } else {
#line 310
        action = action1;
      }
#line 311
      i = 0;
      {
#line 311
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 311
        if (! (i < e->ndcont)) {
#line 311
          goto while_break___4;
        }
        {
#line 312
        n = 0;
#line 313
        tok = Split(*(e->dcont + i), & n, 1);
#line 314
        id = 0;
        }
        {
#line 314
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 314
          if (! (id < n)) {
#line 314
            goto while_break___5;
          }
#line 315
          if (fold_case) {
#line 316
            cp = *(tok + id);
            {
#line 316
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 316
              if (! *cp) {
#line 316
                goto while_break___6;
              }
              {
#line 317
              tmp___10 = __ctype_b_loc();
              }
#line 317
              if ((int const   )*(*tmp___10 + (int )*cp) & 512) {
                {
#line 317
                tmp___9 = toupper((int )*cp);
#line 317
                *cp = (char )tmp___9;
                }
              }
#line 316
              cp ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          {
#line 318
          e = FindElemByID(*(tok + id));
          }
#line 318
          if (e) {
#line 319
            if (id) {
              {
#line 319
              TranTByAction(e, action, fp);
              }
            } else {
              {
#line 320
              TranTByAction(e, action1, fp);
              }
            }
          } else {
            {
#line 322
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can not find ID: %s.\n",
                    *(tok + id));
            }
          }
#line 314
          id ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 311
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  } else
  _L___16: /* CIL Label */ 
#line 329
  if ((int )*(*(tok + 0) + 0) == (int )*("eachcon" + 0)) {
    {
#line 329
    tmp___30 = strcmp((char const   *)*(tok + 0), "eachcon");
    }
#line 329
    if (tmp___30) {
#line 329
      goto _L___15;
    } else {
#line 331
      action1 = *(tok + 1);
#line 332
      if (ntok > 3) {
#line 332
        action = *(tok + 2);
      } else {
#line 333
        action = action1;
      }
#line 334
      i = 0;
      {
#line 334
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 334
        if (! (i < e->ndcont)) {
#line 334
          goto while_break___7;
        }
        {
#line 335
        n = 0;
#line 336
        tok = Split(*(e->dcont + i), & n, 3);
#line 337
        id___0 = 0;
        }
        {
#line 337
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 337
          if (! (id___0 < n)) {
#line 337
            goto while_break___8;
          }
          {
#line 338
          each_C = *(tok + id___0);
#line 339
          TranTByAction(e, action, fp);
#line 337
          id___0 ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 341
        free((void *)*tok);
#line 334
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  } else
  _L___15: /* CIL Label */ 
#line 346
  if ((int )*(*(tok + 0) + 0) == (int )*("eachatt" + 0)) {
    {
#line 346
    tmp___29 = strcmp((char const   *)*(tok + 0), "eachatt");
    }
#line 346
    if (tmp___29) {
#line 346
      goto _L___14;
    } else {
#line 348
      action1 = *(tok + 2);
#line 349
      if (ntok > 3) {
#line 349
        action = *(tok + 3);
      } else {
#line 350
        action = action1;
      }
      {
#line 351
      atval = FindAttValByName(e, *(tok + 1));
      }
#line 351
      if (atval) {
        {
#line 352
        n = 0;
#line 353
        tok = Split(atval, & n, 3);
#line 354
        id___1 = 0;
        }
        {
#line 354
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 354
          if (! (id___1 < n)) {
#line 354
            goto while_break___9;
          }
#line 355
          each_A = *(tok + id___1);
#line 356
          if (id___1) {
            {
#line 356
            TranTByAction(e, action, fp);
            }
          } else {
            {
#line 357
            TranTByAction(e, action1, fp);
            }
          }
#line 354
          id___1 ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 359
        free((void *)*tok);
        }
      }
    }
  } else
  _L___14: /* CIL Label */ 
#line 365
  if ((int )*(*(tok + 0) + 0) == (int )*("relation" + 0)) {
    {
#line 365
    tmp___28 = strcmp((char const   *)*(tok + 0), "relation");
    }
#line 365
    if (tmp___28) {
#line 365
      goto _L___13;
    } else
#line 366
    if (ntok >= 4) {
      {
#line 367
      tmp___11 = CheckRelation(e, *(tok + 1), *(tok + 2), *(tok + 3), fp, (RelAction_t )0);
      }
#line 367
      if (! tmp___11) {
#line 369
        if (ntok >= 5) {
          {
#line 370
          TranTByAction(e, *(tok + 4), fp);
          }
        }
      }
    }
  } else
  _L___13: /* CIL Label */ 
#line 377
  if ((int )*(*(tok + 0) + 0) == (int )*("followrel" + 0)) {
    {
#line 377
    tmp___27 = strcmp((char const   *)*(tok + 0), "followrel");
    }
#line 377
    if (tmp___27) {
#line 377
      goto _L___12;
    } else
#line 378
    if (ntok >= 4) {
      {
#line 379
      CheckRelation(e, *(tok + 1), *(tok + 2), *(tok + 3), fp, (RelAction_t )1);
      }
    }
  } else
  _L___12: /* CIL Label */ 
#line 385
  if ((int )*(*(tok + 0) + 0) == (int )*("id" + 0)) {
    {
#line 385
    tmp___26 = strcmp((char const   *)*(tok + 0), "id");
    }
#line 385
    if (tmp___26) {
#line 385
      goto _L___11;
    } else {
      {
#line 386
      ep = FindElemByID(*(tok + 1));
      }
#line 386
      if (ep) {
#line 387
        if (ntok > 2) {
          {
#line 387
          TranTByAction(ep, *(tok + 2), fp);
          }
        } else {
          {
#line 389
          t = FindTrans(ep, 0);
#line 390
          TransElement(ep, fp, t);
          }
        }
      }
    }
  } else
  _L___11: /* CIL Label */ 
#line 397
  if ((int )*(*(tok + 0) + 0) == (int )*("set" + 0)) {
    {
#line 397
    tmp___25 = strcmp((char const   *)*(tok + 0), "set");
    }
#line 397
    if (tmp___25) {
#line 397
      goto _L___10;
    } else {
      {
#line 398
      SetMappingNV(Variables, *(tok + 1), *(tok + 2));
      }
    }
  } else
  _L___10: /* CIL Label */ 
#line 404
  if ((int )*(*(tok + 0) + 0) == (int )*("isset" + 0)) {
    {
#line 404
    tmp___24 = strcmp((char const   *)*(tok + 0), "isset");
    }
#line 404
    if (tmp___24) {
#line 404
      goto _L___9;
    } else {
      {
#line 405
      cp = FindMappingVal(Variables, *(tok + 1));
      }
#line 405
      if (cp) {
#line 406
        if (ntok == 3) {
          {
#line 406
          TranTByAction(e, *(tok + 2), fp);
          }
        } else
#line 407
        if (ntok > 3) {
          {
#line 407
          tmp___12 = strcmp((char const   *)cp, (char const   *)*(tok + 2));
          }
#line 407
          if (! tmp___12) {
            {
#line 408
            TranTByAction(e, *(tok + 3), fp);
            }
          }
        }
      }
    }
  } else
  _L___9: /* CIL Label */ 
#line 414
  if ((int )*(*(tok + 0) + 0) == (int )*("insertnode" + 0)) {
    {
#line 414
    tmp___23 = strcmp((char const   *)*(tok + 0), "insertnode");
    }
#line 414
    if (tmp___23) {
#line 414
      goto _L___8;
    } else {
      {
#line 415
      actioni = atoi((char const   *)*(tok + 2));
      }
#line 416
      if ((int )*(*(tok + 1)) == 83) {
#line 416
        e->gen_trans[0] = actioni;
      } else
#line 417
      if ((int )*(*(tok + 1)) == 69) {
#line 417
        e->gen_trans[1] = actioni;
      }
    }
  } else
  _L___8: /* CIL Label */ 
#line 442
  if ((int )*(*(tok + 0) + 0) == (int )*("calstable" + 0)) {
    {
#line 442
    tmp___22 = strcmp((char const   *)*(tok + 0), "calstable");
    }
#line 442
    if (tmp___22) {
#line 442
      goto _L___7;
    } else {
      {
#line 443
      CALStable(e, fp, tok, ntok);
      }
    }
  } else
  _L___7: /* CIL Label */ 
#line 449
  if ((int )*(*(tok + 0) + 0) == (int )*("attval" + 0)) {
    {
#line 449
    tmp___21 = strcmp((char const   *)*(tok + 0), "attval");
    }
#line 449
    if (tmp___21) {
#line 449
      goto _L___6;
    } else {
      {
#line 450
      atval = FindAttValByName(e, *(tok + 1));
      }
#line 450
      if (atval) {
#line 451
        if (ntok == 3) {
          {
#line 451
          TranTByAction(e, *(tok + 2), fp);
          }
        } else
#line 452
        if (ntok > 3) {
          {
#line 452
          tmp___13 = strcmp((char const   *)atval, (char const   *)*(tok + 2));
          }
#line 452
          if (! tmp___13) {
            {
#line 453
            TranTByAction(e, *(tok + 3), fp);
            }
          }
        }
      }
    }
  } else
  _L___6: /* CIL Label */ 
#line 457
  if ((int )*(*(tok + 0) + 0) == (int )*("pattval" + 0)) {
    {
#line 457
    tmp___20 = strcmp((char const   *)*(tok + 0), "pattval");
    }
#line 457
    if (tmp___20) {
#line 457
      goto _L___5;
    } else {
      {
#line 458
      atval = FindAttValByName(e->parent, *(tok + 1));
      }
#line 458
      if (atval) {
#line 459
        if (ntok == 3) {
          {
#line 460
          TranTByAction(e, *(tok + 2), fp);
          }
        }
#line 462
        if (ntok > 3) {
          {
#line 462
          tmp___14 = strcmp((char const   *)atval, (char const   *)*(tok + 2));
          }
#line 462
          if (! tmp___14) {
            {
#line 463
            TranTByAction(e, *(tok + 3), fp);
            }
          }
        }
      }
    }
  } else
  _L___5: /* CIL Label */ 
#line 470
  if ((int )*(*(tok + 0) + 0) == (int )*("allatts" + 0)) {
    {
#line 470
    tmp___19 = strcmp((char const   *)*(tok + 0), "allatts");
    }
#line 470
    if (tmp___19) {
#line 470
      goto _L___4;
    } else {
#line 471
      i = 0;
      {
#line 471
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 471
        if (! (i < e->natts)) {
#line 471
          goto while_break___10;
        }
#line 472
        if (i != 0) {
          {
#line 472
          _IO_putc(' ', fp);
          }
        }
        {
#line 473
        fputs((char const   */* __restrict  */)(e->atts + i)->name, (FILE */* __restrict  */)fp);
#line 474
        fputs((char const   */* __restrict  */)"=\"", (FILE */* __restrict  */)fp);
#line 475
        fputs((char const   */* __restrict  */)(e->atts + i)->sval, (FILE */* __restrict  */)fp);
#line 476
        _IO_putc('\"', fp);
#line 471
        i ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  } else
  _L___4: /* CIL Label */ 
#line 482
  if ((int )*(*(tok + 0) + 0) == (int )*("infile" + 0)) {
    {
#line 482
    tmp___18 = strcmp((char const   *)*(tok + 0), "infile");
    }
#line 482
    if (tmp___18) {
#line 482
      goto _L___3;
    } else
#line 483
    if (e->infile) {
#line 484
      if (ntok > 1) {
        {
#line 484
        tmp___16 = strcmp((char const   *)*(tok + 1), "root");
        }
#line 484
        if (tmp___16) {
#line 484
          goto _L___1;
        } else {
          {
#line 485
          strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)e->infile);
#line 486
          cp = strrchr((char const   *)(buf___0), '.');
          }
#line 486
          if (cp) {
#line 486
            *cp = (char )'\000';
          }
          {
#line 487
          fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)fp);
          }
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 490
        fputs((char const   */* __restrict  */)e->infile, (FILE */* __restrict  */)fp);
        }
#line 491
        if (ntok > 1) {
          {
#line 491
          tmp___15 = strcmp((char const   *)*(tok + 1), "line");
          }
#line 491
          if (! tmp___15) {
            {
#line 492
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d",
                    e->lineno);
            }
          }
        }
      }
#line 494
      return;
    } else {
      {
#line 496
      fputs((char const   */* __restrict  */)"input-file??", (FILE */* __restrict  */)fp);
      }
    }
  } else
  _L___3: /* CIL Label */ 
#line 500
  if ((int )*(*(tok + 0) + 0) == (int )*("env" + 0)) {
    {
#line 500
    tmp___17 = strcmp((char const   *)*(tok + 0), "env");
    }
#line 500
    if (tmp___17) {
#line 500
      goto _L___2;
    } else
#line 501
    if (ntok > 1) {
      {
#line 501
      cp = getenv((char const   *)*(tok + 1));
      }
#line 501
      if (cp) {
        {
#line 502
        OutputString(cp, fp, track_pos);
        }
      }
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown special variable: %s\n",
            *(tok + 0));
#line 509
    tt = (Trans_t *)e->trans;
    }
#line 510
    if (tt) {
#line 510
      if (tt->lineno) {
        {
#line 511
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Used in transpec, line %d\n",
                tt->lineno);
        }
      }
    }
  }
#line 513
  return;
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
char *Get_A_C_value(char *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 524
  tmp___0 = strcmp((char const   *)name, "each_A");
  }
#line 524
  if (tmp___0) {
    {
#line 531
    tmp = strcmp((char const   *)name, "each_C");
    }
#line 531
    if (tmp) {
      {
#line 538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Requested value for unknown special variable \'%s\'\n",
              name);
      }
    } else
#line 532
    if (each_C) {
#line 533
      return (each_C);
    } else {
      {
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Requested value for unset _C variable\n");
      }
    }
  } else
#line 525
  if (each_A) {
#line 526
    return (each_A);
  } else {
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Requested value for unset _A variable\n");
    }
  }
#line 541
  return ((char *)"");
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
void GetIDREFnames(void) 
{ 
  char *cp ;

  {
#line 555
  if (! idrefs) {
    {
#line 557
    cp = FindMappingVal(Variables, (char *)"link_atts");
    }
#line 557
    if (cp) {
      {
#line 558
      idrefs = Split(cp, (int *)0, 3);
      }
    } else {
#line 560
      idrefs = def_idrefs;
    }
  }
#line 562
  return;
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
void ChaseIDRefs(Element_t *e , char *gi , char *action , FILE *fp ) 
{ 
  int ntok ;
  int i ;
  int ei ;
  char **tok ;
  char **s ;
  char *atval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 585
  if ((int )*(e->gi + 0) == (int )*(gi + 0)) {
    {
#line 585
    tmp = strcmp((char const   *)e->gi, (char const   *)gi);
    }
#line 585
    if (! tmp) {
      {
#line 586
      TranTByAction(e, action, fp);
      }
#line 587
      return;
    }
  }
  {
#line 589
  GetIDREFnames();
#line 592
  s = idrefs;
  }
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! *s) {
#line 592
      goto while_break;
    }
    {
#line 594
    atval = FindAttValByName(e, *s);
    }
#line 594
    if (atval) {
      {
#line 595
      ntok = 0;
#line 596
      tok = Split(atval, & ntok, 0);
#line 597
      i = 0;
      }
      {
#line 597
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 597
        if (! (i < ntok)) {
#line 597
          goto while_break___0;
        }
        {
#line 599
        e = FindElemByID(*(tok + i));
        }
#line 599
        if (e) {
#line 601
          if ((int )*(e->gi + 0) == (int )*(gi + 0)) {
            {
#line 601
            tmp___1 = strcmp((char const   *)e->gi, (char const   *)gi);
            }
#line 601
            if (tmp___1) {
#line 601
              goto _L;
            } else {
              {
#line 603
              TranTByAction(e, action, fp);
              }
#line 604
              return;
            }
          } else {
            _L: /* CIL Label */ 
#line 608
            ei = 0;
            {
#line 608
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 608
              if (! (ei < e->necont)) {
#line 608
                goto while_break___1;
              }
#line 609
              if ((int )*((*(e->econt + ei))->gi + 0) == (int )*(gi + 0)) {
                {
#line 609
                tmp___0 = strcmp((char const   *)(*(e->econt + ei))->gi, (char const   *)gi);
                }
#line 609
                if (! tmp___0) {
                  {
#line 610
                  TranTByAction(*(e->econt + ei), action, fp);
                  }
#line 611
                  return;
                }
              }
#line 608
              ei ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 615
            ChaseIDRefs(e, gi, action, fp);
            }
#line 616
            return;
          }
        } else {
          {
#line 621
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not find ID %s\n",
                  atval);
          }
#line 622
          return;
        }
#line 597
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 592
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  if (! s) {
    {
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not find \'%s\'\n",
            gi);
    }
  }
#line 630
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static void tr_find_gi(Element_t *e , Descent_t *ds ) 
{ 
  int tmp ;

  {
#line 650
  if ((int )*(ds->gi + 0) == (int )*(e->gi + 0)) {
    {
#line 650
    tmp = strcmp((char const   *)ds->gi, (char const   *)e->gi);
    }
#line 650
    if (! tmp) {
#line 651
      if (ds->action[0]) {
        {
#line 651
        TranTByAction(e, ds->action, ds->fp);
        }
      }
    }
  }
#line 652
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static void tr_find_gipar(Element_t *e , Descent_t *ds ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 660
  if ((int )*(ds->gi + 0) == (int )*(e->gi + 0)) {
    {
#line 660
    tmp = strcmp((char const   *)ds->gi, (char const   *)e->gi);
    }
#line 660
    if (! tmp) {
#line 660
      if (e->parent) {
#line 660
        if ((int )*(ds->gi2 + 0) == (int )*((e->parent)->gi + 0)) {
          {
#line 660
          tmp___0 = strcmp((char const   *)ds->gi2, (char const   *)(e->parent)->gi);
          }
#line 660
          if (! tmp___0) {
#line 662
            if (ds->action[0]) {
              {
#line 662
              TranTByAction(e, ds->action, ds->fp);
              }
            }
          }
        }
      }
    }
  }
#line 663
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static void tr_find_attr(Element_t *e , Descent_t *ds ) 
{ 
  char *atval ;
  int tmp ;

  {
  {
#line 672
  atval = FindAttValByName(e, ds->gi);
  }
#line 672
  if (atval) {
#line 672
    if ((int )*(ds->gi2 + 0) == (int )*(atval + 0)) {
      {
#line 672
      tmp = strcmp((char const   *)ds->gi2, (char const   *)atval);
      }
#line 672
      if (! tmp) {
        {
#line 673
        TranTByAction(e, ds->action, ds->fp);
        }
      }
    }
  }
#line 674
  return;
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
static void tr_find_parent(Element_t *e , Descent_t *ds ) 
{ 
  Element_t *tmp ;

  {
  {
#line 682
  tmp = QRelation(e, ds->gi, (Relation_t )1);
  }
#line 682
  if (tmp) {
#line 683
    if (ds->action[0]) {
      {
#line 683
      TranTByAction(e, ds->action, ds->fp);
      }
    }
  }
#line 685
  return;
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tranvar.c"
void Find(Element_t *e , int ac , char **av , FILE *fp ) 
{ 
  Descent_t DS ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 706
  memset((void *)(& DS), 0, sizeof(Descent_t ));
#line 707
  DS.elem = e;
#line 708
  DS.fp = fp;
  }
#line 711
  if ((int )*(*(av + 1) + 0) == (int )*("top" + 0)) {
    {
#line 711
    tmp = strcmp((char const   *)*(av + 1), "top");
    }
#line 711
    if (! tmp) {
#line 712
      av ++;
#line 713
      ac --;
#line 714
      e = DocTree;
    }
  }
#line 716
  if (ac < 4) {
    {
#line 717
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad \'_find\' specification - missing args.\n");
    }
#line 718
    return;
  }
#line 721
  if ((int )*(*(av + 1) + 0) == (int )*("gi" + 0)) {
    {
#line 721
    tmp___3 = strcmp((char const   *)*(av + 1), "gi");
    }
#line 721
    if (tmp___3) {
#line 721
      goto _L___1;
    } else {
      {
#line 722
      DS.gi = *(av + 2);
#line 723
      strcpy((char */* __restrict  */)(DS.action), (char const   */* __restrict  */)*(av + 3));
#line 724
      DescendTree(e, (void (*)())(& tr_find_gi), (void (*)())0, (void (*)())0, (void *)(& DS));
      }
    }
  } else
  _L___1: /* CIL Label */ 
#line 727
  if ((int )*(*(av + 1) + 0) == (int )*("gi-parent" + 0)) {
    {
#line 727
    tmp___2 = strcmp((char const   *)*(av + 1), "gi-parent");
    }
#line 727
    if (tmp___2) {
#line 727
      goto _L___0;
    } else {
      {
#line 728
      DS.gi = *(av + 2);
#line 729
      DS.gi2 = *(av + 3);
#line 730
      strcpy((char */* __restrict  */)(DS.action), (char const   */* __restrict  */)*(av + 4));
#line 731
      DescendTree(e, (void (*)())(& tr_find_gipar), (void (*)())0, (void (*)())0,
                  (void *)(& DS));
      }
    }
  } else
  _L___0: /* CIL Label */ 
#line 734
  if ((int )*(*(av + 0) + 0) == (int )*("parent" + 0)) {
    {
#line 734
    tmp___1 = strcmp((char const   *)*(av + 0), "parent");
    }
#line 734
    if (tmp___1) {
#line 734
      goto _L;
    } else {
      {
#line 735
      DS.gi = *(av + 2);
#line 736
      strcpy((char */* __restrict  */)(DS.action), (char const   */* __restrict  */)*(av + 3));
#line 737
      DescendTree(e, (void (*)())(& tr_find_parent), (void (*)())0, (void (*)())0,
                  (void *)(& DS));
      }
    }
  } else
  _L: /* CIL Label */ 
#line 740
  if ((int )*(*(av + 0) + 0) == (int )*("attr" + 0)) {
    {
#line 740
    tmp___0 = strcmp((char const   *)*(av + 0), "attr");
    }
#line 740
    if (! tmp___0) {
      {
#line 741
      DS.gi = *(av + 2);
#line 742
      DS.gi2 = *(av + 3);
#line 743
      strcpy((char */* __restrict  */)(DS.action), (char const   */* __restrict  */)*(av + 4));
#line 744
      DescendTree(e, (void (*)())(& tr_find_attr), (void (*)())0, (void (*)())0, (void *)(& DS));
      }
    }
  }
#line 746
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int slave ;
#line 282
Relation_t FindRelByName(char *relname ) ;
#line 304
void DoTranslate(Element_t *e , char *transfile , FILE *fp ) ;
#line 308
void ReadSDATA(char *filename ) ;
#line 309
void ReadCharMap(char *filename ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void PrElemPlusID(Element_t *e ) ;
#line 70
static void ls_node(Element_t *e , int ac , char **av ) ;
#line 71
static void do_query(Element_t *e , char *rel , char *gi ) ;
#line 72
static void do_find(Element_t *e , char **av ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static char *br_help_msg[28]  = 
#line 76
  {      (char *)"  ls            List info about current element in tree",      (char *)"                (context, children, attributes, etc.)",      (char *)"  cd N ...      Change to Nth elememt child, where N is shown by \'ls\'.",      (char *)"                N may also be \'/\' (top) or \'..\' (up).", 
        (char *)"  cd id I       Change to elememt whose ID is I",      (char *)"  data N        Show data of Nth data node",      (char *)"  where         Show current position in the tree",      (char *)"  id I          Show path to element with id I", 
        (char *)"                (using \'?\' for I will lists all IDs and their paths)",      (char *)"  find S        Find elements matching spec S. Recognized syntaxes:",      (char *)"                  find attr <name> <value>",      (char *)"                  find cont <string>", 
        (char *)"                  find parent <gi-name>",      (char *)"                  find child <gi-name>",      (char *)"                  find gi <gi-name>",      (char *)"  q rel gi      Query: report if elem \'gi\' has relation to current elem", 
        (char *)"                (\'rel\' is one of \'child parent ancestor descendant",      (char *)"                  sibling sibling+ sibling+1 sibling- sibling-1 cousin\')",      (char *)"",      (char *)"  tran file [outfile]", 
        (char *)"                With trans spec in \'file\' translate into \'outfile\' (stdout)",      (char *)"  sdata file    Read SDATA map file (for translations).",      (char *)"  cmap file     Read character map file (for translations).",      (char *)"  stat          Print statistics (how often elements occur, etc.)", 
        (char *)"  sum           Print elem usage summary (# of children, depth, etc.)",      (char *)"  tree          Print document hierarchy as a tree",      (char *)"  cont          Print context of each element",      (char *)((void *)0)};
#line 109 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
void Browse(void) 
{ 
  char buf___0[256] ;
  char *cmd ;
  char **av ;
  char **sv ;
  char *cmapfile___0 ;
  char *sdatafile___0 ;
  char *Prompt ;
  Element_t *ce ;
  Element_t *e ;
  int i ;
  int n ;
  int ac ;
  char *tmp ;
  char *_cp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  FILE *fp ;
  char **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 118
  if (slave) {
#line 118
    Prompt = (char *)"=>\n";
  } else {
#line 119
    Prompt = (char *)"=> ";
  }
#line 121
  ce = DocTree;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    tmp___27 = fputs((char const   */* __restrict  */)Prompt, (FILE */* __restrict  */)stdout);
    }
#line 122
    if (! tmp___27) {
#line 122
      goto while_break;
    }
    {
#line 123
    tmp = fgets((char */* __restrict  */)(buf___0), 256, (FILE */* __restrict  */)stdin);
    }
#line 123
    if (! tmp) {
#line 123
      goto while_break;
    }
    {
#line 124
    _cp = strchr((char const   *)(buf___0), '\n');
    }
#line 124
    if (_cp) {
#line 124
      *_cp = (char )'\000';
    }
#line 125
    if ((int )buf___0[0] == 0) {
      {
#line 126
      fputs((char const   */* __restrict  */)Prompt, (FILE */* __restrict  */)stdout);
      }
#line 127
      goto while_continue;
    }
    {
#line 129
    ac = 20;
#line 130
    av = Split(buf___0, & ac, 2);
    }
#line 131
    if (ac > 0) {
#line 131
      cmd = *(av + 0);
    }
#line 132
    if (! cmd) {
#line 132
      goto while_continue;
    } else
#line 132
    if (! *cmd) {
#line 132
      goto while_continue;
    }
    {
#line 134
    tmp___26 = strcmp((char const   *)cmd, "ls");
    }
#line 134
    if (tmp___26) {
      {
#line 136
      tmp___25 = strcmp((char const   *)cmd, "cd");
      }
#line 136
      if (tmp___25) {
        {
#line 167
        tmp___24 = strcmp((char const   *)cmd, "data");
        }
#line 167
        if (tmp___24) {
          {
#line 181
          tmp___23 = strcmp((char const   *)cmd, "where");
          }
#line 181
          if (tmp___23) {
            {
#line 184
            tmp___22 = strcmp((char const   *)cmd, "pwd");
            }
#line 184
            if (tmp___22) {
              {
#line 187
              tmp___21 = strcmp((char const   *)cmd, "q");
              }
#line 187
              if (tmp___21) {
                _L___6: /* CIL Label */ 
                {
#line 191
                tmp___20 = strcmp((char const   *)cmd, "find");
                }
#line 191
                if (tmp___20) {
                  _L___4: /* CIL Label */ 
                  {
#line 195
                  tmp___19 = strcmp((char const   *)cmd, "id");
                  }
#line 195
                  if (tmp___19) {
                    {
#line 216
                    tmp___18 = strcmp((char const   *)cmd, "show");
                    }
#line 216
                    if (tmp___18) {
                      _L___2: /* CIL Label */ 
                      {
#line 219
                      tmp___17 = strcmp((char const   *)cmd, "set");
                      }
#line 219
                      if (tmp___17) {
                        _L___1: /* CIL Label */ 
                        {
#line 224
                        tmp___16 = strcmp((char const   *)cmd, "sum");
                        }
#line 224
                        if (tmp___16) {
                          {
#line 229
                          tmp___15 = strcmp((char const   *)cmd, "tree");
                          }
#line 229
                          if (tmp___15) {
                            {
#line 234
                            tmp___14 = strcmp((char const   *)cmd, "stat");
                            }
#line 234
                            if (tmp___14) {
                              {
#line 239
                              tmp___13 = strcmp((char const   *)cmd, "cont");
                              }
#line 239
                              if (tmp___13) {
                                {
#line 244
                                tmp___12 = strcmp((char const   *)cmd, "tran");
                                }
#line 244
                                if (tmp___12) {
                                  {
#line 256
                                  tmp___11 = strcmp((char const   *)cmd, "sdata");
                                  }
#line 256
                                  if (tmp___11) {
                                    {
#line 260
                                    tmp___10 = strcmp((char const   *)cmd, "cmap");
                                    }
#line 260
                                    if (tmp___10) {
                                      {
#line 265
                                      tmp___9 = strcmp((char const   *)cmd, "help");
                                      }
#line 265
                                      if (tmp___9) {
#line 265
                                        if ((int )*cmd == 63) {
                                          _L: /* CIL Label */ 
#line 266
                                          sv = br_help_msg;
                                          {
#line 267
                                          while (1) {
                                            while_continue___0: /* CIL Label */ ;
#line 267
                                            if (! *sv) {
#line 267
                                              goto while_break___0;
                                            }
                                            {
#line 267
                                            tmp___7 = sv;
#line 267
                                            sv ++;
#line 267
                                            puts((char const   *)*tmp___7);
                                            }
                                          }
                                          while_break___0: /* CIL Label */ ;
                                          }
                                        } else {
                                          {
#line 271
                                          tmp___8 = strcmp((char const   *)cmd, "quit");
                                          }
#line 271
                                          if (tmp___8) {
                                            {
#line 274
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"Unknown command \'%s\' - ingored.\n",
                                                    cmd);
                                            }
                                          } else {
#line 271
                                            goto while_break;
                                          }
                                        }
                                      } else {
#line 265
                                        goto _L;
                                      }
                                    } else {
                                      {
#line 261
                                      cmapfile___0 = strdup((char const   *)*(av + 1));
#line 262
                                      ReadCharMap(cmapfile___0);
                                      }
                                    }
                                  } else {
                                    {
#line 257
                                    sdatafile___0 = strdup((char const   *)*(av + 1));
#line 258
                                    ReadSDATA(sdatafile___0);
                                    }
                                  }
                                } else {
#line 246
                                  if (ac > 2) {
                                    {
#line 247
                                    fp = fopen((char const   */* __restrict  */)*(av + 2),
                                               (char const   */* __restrict  */)"w");
                                    }
#line 247
                                    if (! fp) {
                                      {
#line 248
                                      perror("Can not open output file");
                                      }
#line 249
                                      goto while_continue;
                                    }
                                  } else {
#line 252
                                    fp = stdout;
                                  }
                                  {
#line 253
                                  DoTranslate(ce, *(av + 1), fp);
                                  }
#line 254
                                  if (ac > 2) {
                                    {
#line 254
                                    fclose(fp);
                                    }
                                  }
                                }
                              } else
#line 240
                              if (ac > 1) {
                                {
#line 240
                                PrintContext(ce);
                                }
                              } else {
                                {
#line 241
                                PrintContext(DocTree);
                                }
                              }
                            } else
#line 235
                            if (ac > 1) {
                              {
#line 235
                              PrintStats(ce);
                              }
                            } else {
                              {
#line 236
                              PrintStats(DocTree);
                              }
                            }
                          } else
#line 230
                          if (ac > 1) {
                            {
#line 230
                            PrintElemTree(ce);
                            }
                          } else {
                            {
#line 231
                            PrintElemTree(DocTree);
                            }
                          }
                        } else
#line 225
                        if (ac > 1) {
                          {
#line 225
                          PrintElemSummary(ce);
                          }
                        } else {
                          {
#line 226
                          PrintElemSummary(DocTree);
                          }
                        }
                      } else
#line 219
                      if (*(av + 1)) {
#line 219
                        if (*(av + 2)) {
                          {
#line 220
                          SetMappingNV(Variables, *(av + 1), *(av + 2));
                          }
                        } else {
#line 219
                          goto _L___1;
                        }
                      } else {
#line 219
                        goto _L___1;
                      }
                    } else
#line 216
                    if (*(av + 1)) {
                      {
#line 217
                      tmp___6 = FindMappingVal(Variables, *(av + 1));
#line 217
                      printf((char const   */* __restrict  */)"%s\n", tmp___6);
                      }
                    } else {
#line 216
                      goto _L___2;
                    }
                  } else {
#line 196
                    if (ac <= 1) {
#line 196
                      goto while_continue;
                    }
#line 197
                    if ((int )*(*(av + 1)) == 63) {
                      {
#line 197
                      PrintIDList();
                      }
                    } else {
                      {
#line 200
                      tmp___5 = strcmp((char const   *)*(av + 1), "-l");
                      }
#line 200
                      if (tmp___5) {
#line 201
                        n = 1;
                      } else {
#line 200
                        n = 2;
                      }
#line 202
                      i = n;
                      {
#line 202
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 202
                        if (! (i < ac)) {
#line 202
                          goto while_break___1;
                        }
                        {
#line 203
                        e = FindElemByID(*(av + i));
                        }
#line 203
                        if (e) {
#line 204
                          if (n == 2) {
#line 205
                            if (n != i) {
                              {
#line 205
                              putchar('\n');
                              }
                            }
                            {
#line 206
                            PrintLocation(e, stdout);
                            }
                          } else {
                            {
#line 208
                            PrElemPlusID(e);
                            }
                          }
                        } else {
                          {
#line 210
                          printf((char const   */* __restrict  */)"Element with ID \'%s\' not found.\n",
                                 *(av + i));
                          }
                        }
#line 202
                        i ++;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
                    }
                  }
                } else
#line 191
                if (*(av + 1)) {
#line 191
                  if (*(av + 2)) {
                    {
#line 192
                    do_find(ce, av);
                    }
                  } else {
#line 191
                    goto _L___4;
                  }
                } else {
#line 191
                  goto _L___4;
                }
              } else
#line 187
              if (*(av + 1)) {
#line 187
                if (*(av + 2)) {
                  {
#line 188
                  do_query(ce, *(av + 1), *(av + 2));
                  }
                } else {
#line 187
                  goto _L___6;
                }
              } else {
#line 187
                goto _L___6;
              }
            } else {
              {
#line 184
              PrElemPlusID(ce);
              }
            }
          } else {
            {
#line 181
            PrintLocation(ce, stdout);
            }
          }
        } else
#line 168
        if (*(av + 1)) {
          {
#line 168
          tmp___4 = __ctype_b_loc();
          }
#line 168
          if ((int const   )*(*tmp___4 + (int )*(*(av + 1))) & 2048) {
            {
#line 169
            n = atoi((char const   *)*(av + 1));
            }
#line 170
            if (n < ce->ndcont) {
              {
#line 171
              printf((char const   */* __restrict  */)"%s", *(ce->dcont + n));
#line 172
              fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
              }
            } else
#line 174
            if (ce->ndcont == 0) {
              {
#line 175
              printf((char const   */* __restrict  */)"No data at this node.\n");
              }
            } else {
              {
#line 176
              printf((char const   */* __restrict  */)"Must be in range 0 - %d.\n",
                     ce->ndcont);
              }
            }
          }
        }
      } else
#line 137
      if (*(av + 1)) {
#line 138
        if (ac == 3) {
          {
#line 138
          tmp___0 = strcmp((char const   *)*(av + 1), "id");
          }
#line 138
          if (! tmp___0) {
            {
#line 139
            e = FindElemByID(*(av + 2));
            }
#line 139
            if (e) {
#line 139
              ce = e;
            } else {
              {
#line 140
              printf((char const   */* __restrict  */)"Element with ID \'%s\' not found.\n",
                     *(av + 2));
              }
            }
#line 141
            goto while_continue;
          }
        }
#line 143
        i = 1;
        {
#line 143
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 143
          if (! (i < ac)) {
#line 143
            goto while_break___2;
          }
          {
#line 144
          tmp___1 = strcmp((char const   *)*(av + i), "..");
          }
#line 144
          if (! tmp___1) {
#line 145
            if (ce->parent) {
#line 145
              ce = ce->parent;
            }
#line 146
            goto __Cont;
          }
          {
#line 148
          tmp___2 = strcmp((char const   *)*(av + i), "/");
          }
#line 148
          if (! tmp___2) {
#line 149
            if (ce->parent) {
#line 149
              ce = DocTree;
            }
#line 150
            goto __Cont;
          }
          {
#line 152
          tmp___3 = __ctype_b_loc();
          }
#line 152
          if (! ((int const   )*(*tmp___3 + (int )*(*(av + i))) & 2048)) {
            {
#line 153
            printf((char const   */* __restrict  */)"Expecting digit, \'..\', or \'/\', got \'%s\'.\n",
                   *(av + i));
            }
#line 155
            goto while_break___2;
          }
          {
#line 157
          n = atoi((char const   *)*(av + i));
          }
#line 158
          if (n < ce->necont) {
#line 158
            ce = *(ce->econt + n);
          } else {
            {
#line 160
            printf((char const   */* __restrict  */)"Must be in range 0 - %d.\n",
                   ce->necont);
            }
#line 161
            goto while_break___2;
          }
          __Cont: /* CIL Label */ 
#line 143
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 134
      ls_node(ce, ac, av);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  _IO_putc('\n', stdout);
  }
#line 277
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void ls_node(Element_t *e , int ac , char **av ) 
{ 
  int i ;
  char buf___0[60000] ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 297
  if (ac > 1) {
    {
#line 297
    tmp = strcmp((char const   *)*(av + 1), "-n");
    }
#line 297
    if (! tmp) {
#line 298
      i = 0;
      {
#line 298
      while (1) {
        while_continue: /* CIL Label */ ;
#line 298
        if (! (i < e->ncont)) {
#line 298
          goto while_break;
        }
#line 299
        if ((int )(e->cont + i)->type == 40) {
          {
#line 299
          printf((char const   */* __restrict  */)"%s\n", ((e->cont + i)->ch.elem)->gi);
          }
        } else
#line 300
        if ((int )(e->cont + i)->type == 45) {
          {
#line 300
          printf((char const   */* __restrict  */)"#data %s\n", (e->cont + i)->ch.data);
          }
        } else
#line 301
        if ((int )(e->cont + i)->type == 63) {
          {
#line 301
          printf((char const   */* __restrict  */)"#pi %s\n", (e->cont + i)->ch.data);
          }
        }
#line 298
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 303
      return;
    }
  }
  {
#line 306
  printf((char const   */* __restrict  */)"Element: %s\tLineNumber: %d\n", e->gi,
         e->lineno);
  }
#line 307
  if (e->parent) {
    {
#line 308
    tmp___0 = FindContext(e, 20, buf___0);
#line 308
    printf((char const   */* __restrict  */)"Context: %s\n", tmp___0);
    }
  }
#line 310
  if (e->natts) {
    {
#line 311
    printf((char const   */* __restrict  */)"%d attributes:\n", e->natts);
#line 312
    i = 0;
    }
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 312
      if (! (i < e->natts)) {
#line 312
        goto while_break___0;
      }
      {
#line 313
      printf((char const   */* __restrict  */)"\t%2d: %s = \'%s\'\n", i, (e->atts + i)->name,
             (e->atts + i)->sval);
#line 312
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 315
  if (e->entity) {
    {
#line 316
    printf((char const   */* __restrict  */)"Entity & notation information:\n");
    }
#line 317
    if ((e->entity)->ename) {
      {
#line 318
      printf((char const   */* __restrict  */)"Entity name:   %s\n", (e->entity)->ename);
      }
    }
#line 319
    if ((e->entity)->nname) {
      {
#line 320
      printf((char const   */* __restrict  */)"Notation name: %s\n", (e->entity)->nname);
      }
    }
#line 321
    if ((e->entity)->sysid) {
      {
#line 322
      printf((char const   */* __restrict  */)"Sys id:        %s\n", (e->entity)->sysid);
      }
    }
#line 323
    if ((e->entity)->pubid) {
      {
#line 324
      printf((char const   */* __restrict  */)"Pub id:        %s\n", (e->entity)->pubid);
      }
    }
#line 325
    if ((e->entity)->fname) {
      {
#line 326
      printf((char const   */* __restrict  */)"Filename:      %s\n", (e->entity)->fname);
      }
    }
  }
#line 329
  if (e->my_eorder >= 0) {
    {
#line 330
    printf((char const   */* __restrict  */)"My order among my siblings: %d\n", e->my_eorder);
    }
  }
#line 332
  if (e->necont) {
    {
#line 333
    printf((char const   */* __restrict  */)"%d child element nodes:\n", e->necont);
#line 334
    i = 0;
    }
    {
#line 334
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 334
      if (! (i < e->necont)) {
#line 334
        goto while_break___1;
      }
      {
#line 334
      printf((char const   */* __restrict  */)"\t%2d: %s\n", i, (*(e->econt + i))->gi);
#line 334
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 337
  if (e->ndcont) {
    {
#line 338
    printf((char const   */* __restrict  */)"%d child data nodes:\n", e->ndcont);
#line 339
    i = 0;
    }
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 339
      if (! (i < e->ndcont)) {
#line 339
        goto while_break___2;
      }
      {
#line 340
      tmp___1 = strlen((char const   *)*(e->dcont + i));
      }
#line 340
      if (tmp___1 < 40UL) {
        {
#line 341
        printf((char const   */* __restrict  */)"\t%2d: %s\n", i, *(e->dcont + i));
        }
      } else {
        {
#line 343
        printf((char const   */* __restrict  */)"\t%2d: %-40.40s...\n", i, *(e->dcont + i));
        }
      }
#line 339
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 346
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void do_query(Element_t *e , char *rel , char *gi ) 
{ 
  char *cp ;
  Relation_t r ;
  Element_t *ep ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 368
  cp = gi;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! *cp) {
#line 368
      goto while_break;
    }
    {
#line 368
    tmp___0 = __ctype_b_loc();
    }
#line 368
    if ((int const   )*(*tmp___0 + (int )*cp) & 512) {
      {
#line 368
      tmp = toupper((int )*cp);
#line 368
      *cp = (char )tmp;
      }
    }
#line 368
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  r = FindRelByName(rel);
  }
#line 370
  if ((unsigned int )r == 11U) {
#line 371
    return;
  }
  {
#line 373
  ep = QRelation(e, gi, r);
  }
#line 374
  if (ep) {
#line 374
    tmp___1 = "";
  } else {
#line 374
    tmp___1 = " not";
  }
#line 374
  if (ep) {
#line 374
    tmp___2 = "Yes";
  } else {
#line 374
    tmp___2 = "No";
  }
  {
#line 374
  printf((char const   */* __restrict  */)"%s, \'%s\' is%s %s of \'%s\'.\n", tmp___2,
         gi, tmp___1, rel, e->gi);
  }
#line 376
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void PrElemPlusID(Element_t *e ) 
{ 
  char buf___0[60000] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 390
  if (e->id) {
    {
#line 390
    tmp = FindElementPath(e, buf___0);
#line 390
    printf((char const   */* __restrict  */)"%s -- ID=%s\n", tmp, e->id);
    }
  } else {
    {
#line 391
    tmp___0 = FindElementPath(e, buf___0);
#line 391
    printf((char const   */* __restrict  */)"%s\n", tmp___0);
    }
  }
#line 392
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_gi(Element_t *e , char **av ) 
{ 
  int tmp ;

  {
  {
#line 406
  tmp = strcmp((char const   *)*(av + 1), (char const   *)e->gi);
  }
#line 406
  if (! tmp) {
    {
#line 406
    PrElemPlusID(e);
    }
  }
#line 407
  return;
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_parent(Element_t *e , char **av ) 
{ 
  Element_t *tmp ;

  {
  {
#line 415
  tmp = QRelation(e, *(av + 1), (Relation_t )1);
  }
#line 415
  if (tmp) {
    {
#line 415
    PrElemPlusID(e);
    }
  }
#line 415
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_child(Element_t *e , char **av ) 
{ 
  Element_t *tmp ;

  {
  {
#line 416
  tmp = QRelation(e, *(av + 1), (Relation_t )2);
  }
#line 416
  if (tmp) {
    {
#line 416
    PrElemPlusID(e);
    }
  }
#line 416
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_anc(Element_t *e , char **av ) 
{ 
  Element_t *tmp ;

  {
  {
#line 417
  tmp = QRelation(e, *(av + 1), (Relation_t )3);
  }
#line 417
  if (tmp) {
    {
#line 417
    PrElemPlusID(e);
    }
  }
#line 417
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_desc(Element_t *e , char **av ) 
{ 
  Element_t *tmp ;

  {
  {
#line 418
  tmp = QRelation(e, *(av + 1), (Relation_t )4);
  }
#line 418
  if (tmp) {
    {
#line 418
    PrElemPlusID(e);
    }
  }
#line 418
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_sib(Element_t *e , char **av ) 
{ 
  Element_t *tmp ;

  {
  {
#line 419
  tmp = QRelation(e, *(av + 1), (Relation_t )5);
  }
#line 419
  if (tmp) {
    {
#line 419
    PrElemPlusID(e);
    }
  }
#line 419
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_attr(Element_t *e , char **av ) 
{ 
  char *atval ;
  int tmp ;

  {
  {
#line 429
  atval = FindAttValByName(e, *(av + 1));
  }
#line 429
  if (atval) {
    {
#line 429
    tmp = strcmp((char const   *)*(av + 2), (char const   *)atval);
    }
#line 429
    if (! tmp) {
      {
#line 430
      PrElemPlusID(e);
      }
    }
  }
#line 431
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void match_cont(Element_t *e , char **av ) 
{ 
  int i ;
  char *tmp ;

  {
#line 440
  i = 0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i < e->ncont)) {
#line 440
      goto while_break;
    }
#line 441
    if ((int )(e->cont + i)->type == 45) {
      {
#line 441
      tmp = strstr((char const   *)(e->cont + i)->ch.data, (char const   *)*(av + 1));
      }
#line 441
      if (tmp) {
        {
#line 442
        PrElemPlusID(e);
        }
#line 443
        return;
      }
    }
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/browse.c"
static void do_find(Element_t *e , char **av ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 458
  av ++;
#line 459
  tmp = strcmp((char const   *)*(av + 0), ".");
  }
#line 459
  if (tmp) {
#line 460
    e = DocTree;
  } else {
#line 459
    av ++;
  }
  {
#line 461
  tmp___7 = strcmp((char const   *)*(av + 0), "gi");
  }
#line 461
  if (tmp___7) {
    {
#line 462
    tmp___6 = strcmp((char const   *)*(av + 0), "attr");
    }
#line 462
    if (tmp___6) {
      {
#line 463
      tmp___5 = strcmp((char const   *)*(av + 0), "parent");
      }
#line 463
      if (tmp___5) {
        {
#line 464
        tmp___4 = strcmp((char const   *)*(av + 0), "child");
        }
#line 464
        if (tmp___4) {
          {
#line 465
          tmp___3 = strcmp((char const   *)*(av + 0), "cont");
          }
#line 465
          if (tmp___3) {
            {
#line 466
            tmp___2 = strcmp((char const   *)*(av + 0), "sib");
            }
#line 466
            if (tmp___2) {
              {
#line 467
              tmp___1 = strcmp((char const   *)*(av + 0), "desc");
              }
#line 467
              if (tmp___1) {
                {
#line 468
                tmp___0 = strcmp((char const   *)*(av + 0), "anc");
                }
#line 468
                if (tmp___0) {
                  {
#line 469
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown find command: %s.\n",
                          *(av + 0));
                  }
                } else {
                  {
#line 468
                  DescendTree(e, (void (*)())(& match_anc), (void (*)())0, (void (*)())0,
                              (void *)av);
                  }
                }
              } else {
                {
#line 467
                DescendTree(e, (void (*)())(& match_desc), (void (*)())0, (void (*)())0,
                            (void *)av);
                }
              }
            } else {
              {
#line 466
              DescendTree(e, (void (*)())(& match_sib), (void (*)())0, (void (*)())0,
                          (void *)av);
              }
            }
          } else {
            {
#line 465
            DescendTree(e, (void (*)())(& match_cont), (void (*)())0, (void (*)())0,
                        (void *)av);
            }
          }
        } else {
          {
#line 464
          DescendTree(e, (void (*)())(& match_child), (void (*)())0, (void (*)())0,
                      (void *)av);
          }
        }
      } else {
        {
#line 463
        DescendTree(e, (void (*)())(& match_parent), (void (*)())0, (void (*)())0,
                    (void *)av);
        }
      }
    } else {
      {
#line 462
      DescendTree(e, (void (*)())(& match_attr), (void (*)())0, (void (*)())0, (void *)av);
      }
    }
  } else {
    {
#line 461
    DescendTree(e, (void (*)())(& match_gi), (void (*)())0, (void (*)())0, (void *)av);
    }
  }
#line 470
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
char **UsedAtt ;
#line 221
int nUsedAtt ;
#line 224
Map_t *SDATAmap ;
#line 229
char *tpt_lib ;
#line 230
int verbose ;
#line 231
int warnings ;
#line 285
char *LookupSDATA(char *s ) ;
#line 286
char *AddElemName(char *name ) ;
#line 287
char *AddAttName(char *name ) ;
#line 291
char *NearestOlderElem(Element_t *e , char *name ) ;
#line 295
Map_t *NewMap(int slot_increment ) ;
#line 296
Mapping_t *FindMapping(Map_t *M , char *name ) ;
#line 298
void SetMapping(Map_t *M , char *s ) ;
#line 300
void AddID(Element_t *e , char *idval ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static char *local_tokens[100]  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char **Split(char *s , int *ntok , int flag ) 
{ 
  int maxnt ;
  int i ;
  int n_alloc___1 ;
  char **tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 126
  i = 0;
#line 132
  if ((unsigned long )ntok == (unsigned long )((void *)0)) {
#line 133
    maxnt = 100;
  } else {
#line 135
    if (*ntok <= 0) {
#line 135
      maxnt = 100;
    } else
#line 135
    if (*ntok > 100) {
#line 135
      maxnt = 100;
    } else {
#line 136
      maxnt = *ntok;
    }
#line 137
    *ntok = 0;
  }
#line 140
  if (! s) {
#line 140
    return ((char **)0);
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (*s) {
#line 143
      if (! ((int )*s == 32)) {
#line 143
        if (! ((int )*s == 9)) {
#line 143
          goto while_break;
        }
      }
    } else {
#line 143
      goto while_break;
    }
#line 143
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if ((int )*s == 0) {
#line 144
    return ((char **)0);
  }
#line 147
  if (flag & 1) {
    {
#line 147
    s = strdup((char const   *)s);
    }
  }
#line 150
  if (flag & 2) {
    {
#line 151
    n_alloc___1 = 20;
#line 152
    tmp = malloc((size_t )n_alloc___1 * sizeof(char *));
#line 152
    tokens = (char **)tmp;
    }
#line 152
    if (! tokens) {
      {
#line 152
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 152
      exit(1);
      }
    }
    {
#line 152
    memset((void *)tokens, 0, sizeof(char *));
    }
#line 155
    if (! ntok) {
#line 155
      maxnt = 10000;
    } else
#line 155
    if (! *ntok) {
#line 155
      maxnt = 10000;
    }
  } else {
#line 157
    tokens = local_tokens;
  }
#line 159
  i = 0;
#line 160
  *(tokens + 0) = s;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i < maxnt)) {
#line 161
      goto while_break___0;
    }
#line 162
    *(tokens + i) = s;
#line 163
    i ++;
#line 165
    if (flag & 2) {
#line 165
      if (i >= n_alloc___1) {
        {
#line 166
        n_alloc___1 += 20;
#line 167
        tmp___0 = realloc((void *)tokens, (size_t )n_alloc___1 * sizeof(char *));
#line 167
        tokens = (char **)tmp___0;
        }
#line 167
        if (! tokens) {
          {
#line 167
          perror("Realloc failed -- out of memory.  Bailing out.");
#line 167
          exit(1);
          }
        }
      }
    }
#line 169
    if (i >= maxnt) {
#line 169
      goto while_break___0;
    }
    {
#line 170
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 170
      if (*s) {
#line 170
        if ((int )*s == 32) {
#line 170
          goto while_break___1;
        } else
#line 170
        if ((int )*s == 9) {
#line 170
          goto while_break___1;
        }
      } else {
#line 170
        goto while_break___1;
      }
#line 170
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    if ((int )*s == 0) {
#line 171
      goto while_break___0;
    }
#line 172
    if (*s) {
#line 172
      tmp___1 = s;
#line 172
      s ++;
#line 172
      *tmp___1 = (char )'\000';
    }
    {
#line 173
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 173
      if (*s) {
#line 173
        if (! ((int )*s == 32)) {
#line 173
          if (! ((int )*s == 9)) {
#line 173
            goto while_break___2;
          }
        }
      } else {
#line 173
        goto while_break___2;
      }
#line 173
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  if (ntok) {
#line 175
    *ntok = i;
  }
#line 176
  *(tokens + i) = (char *)0;
#line 177
  return (tokens);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
Map_t *NewMap(int slot_increment ) 
{ 
  Map_t *M ;
  void *tmp ;

  {
  {
#line 208
  tmp = calloc((size_t )1, sizeof(Map_t ));
#line 208
  M = (Map_t *)tmp;
  }
#line 208
  if (! M) {
    {
#line 208
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 208
    exit(1);
    }
  }
  {
#line 208
  memset((void *)M, 0, sizeof(Map_t ));
#line 211
  memset((void *)((char *)M), 0, sizeof(Map_t ));
  }
#line 212
  if (! slot_increment) {
#line 212
    slot_increment = 1;
  }
#line 213
  M->slot_incr = slot_increment;
#line 214
  return (M);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
Mapping_t *FindMapping(Map_t *M , char *name ) 
{ 
  int i ;
  Mapping_t *m ;
  int tmp ;

  {
#line 233
  if (! M) {
#line 233
    return ((Mapping_t *)((void *)0));
  } else
#line 233
  if (M->n_used == 0) {
#line 233
    return ((Mapping_t *)((void *)0));
  }
#line 234
  m = M->maps;
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < M->n_used)) {
#line 234
      goto while_break;
    }
#line 235
    if ((int )*((m + i)->name + 0) == (int )*(name + 0)) {
      {
#line 235
      tmp = strcmp((char const   *)(m + i)->name, (char const   *)name);
      }
#line 235
      if (! tmp) {
#line 235
        return (m + i);
      }
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return ((Mapping_t *)((void *)0));
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *FindMappingVal(Map_t *M , char *name ) 
{ 
  Mapping_t *m ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 255
  tmp___0 = strcmp((char const   *)name, "each_A");
  }
#line 255
  if (tmp___0) {
    {
#line 255
    tmp___1 = strcmp((char const   *)name, "each_C");
    }
#line 255
    if (! tmp___1) {
      {
#line 256
      tmp = Get_A_C_value(name);
      }
#line 256
      return (tmp);
    }
  } else {
    {
#line 256
    tmp = Get_A_C_value(name);
    }
#line 256
    return (tmp);
  }
#line 264
  if (! M) {
#line 265
    return ((char *)((void *)0));
  } else
#line 264
  if (M->n_used == 0) {
#line 265
    return ((char *)((void *)0));
  }
  {
#line 267
  m = FindMapping(M, name);
  }
#line 267
  if (m) {
#line 268
    return (m->sval);
  }
#line 270
  return ((char *)((void *)0));
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void SetMappingNV(Map_t *M , char *name , char *value ) 
{ 
  FILE *pp ;
  char buf___0[60000] ;
  char *cp ;
  char *s ;
  int i ;
  Mapping_t *m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Mapping_t *tmp___2 ;
  void *tmp___3 ;
  Mapping_t *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *_cp ;

  {
  {
#line 295
  tmp = strcmp((char const   *)name, "verbose");
  }
#line 295
  if (! tmp) {
    {
#line 295
    verbose = atoi((char const   *)value);
    }
#line 295
    return;
  }
  {
#line 296
  tmp___0 = strcmp((char const   *)name, "warnings");
  }
#line 296
  if (! tmp___0) {
    {
#line 296
    warnings = atoi((char const   *)value);
    }
#line 296
    return;
  }
  {
#line 297
  tmp___1 = strcmp((char const   *)name, "foldcase");
  }
#line 297
  if (! tmp___1) {
    {
#line 297
    fold_case = atoi((char const   *)value);
    }
#line 297
    return;
  }
  {
#line 299
  m = FindMapping(M, name);
  }
#line 302
  if (m) {
    {
#line 303
    free((void *)m->sval);
    }
#line 304
    if (value) {
      {
#line 304
      m->sval = strdup((char const   *)value);
      }
    } else {
#line 305
      m->sval = (char *)((void *)0);
    }
  } else
#line 308
  if (name) {
#line 310
    if (M->n_used == 0) {
      {
#line 311
      M->n_alloc = M->slot_incr;
#line 312
      tmp___3 = malloc((size_t )M->n_alloc * sizeof(Mapping_t ));
#line 312
      tmp___2 = (Mapping_t *)tmp___3;
#line 312
      M->maps = tmp___2;
      }
#line 312
      if (! tmp___2) {
        {
#line 312
        perror("Malloc failed -- out of memory.  Bailing out.");
#line 312
        exit(1);
        }
      }
      {
#line 312
      memset((void *)M->maps, 0, sizeof(Mapping_t ));
      }
    } else
#line 314
    if (M->n_used >= M->n_alloc) {
      {
#line 315
      M->n_alloc += M->slot_incr;
#line 316
      tmp___5 = realloc((void *)M->maps, (size_t )M->n_alloc * sizeof(Mapping_t ));
#line 316
      tmp___4 = (Mapping_t *)tmp___5;
#line 316
      M->maps = tmp___4;
      }
#line 316
      if (! tmp___4) {
        {
#line 316
        perror("Realloc failed -- out of memory.  Bailing out.");
#line 316
        exit(1);
        }
      }
    }
    {
#line 319
    m = M->maps + M->n_used;
#line 320
    (M->n_used) ++;
#line 321
    m->name = strdup((char const   *)name);
    }
#line 322
    if (value) {
      {
#line 322
      m->sval = strdup((char const   *)value);
      }
    } else {
#line 323
      m->sval = (char *)((void *)0);
    }
  }
#line 327
  if (value) {
#line 332
    s = value;
#line 333
    if ((int )*s == 33) {
      {
#line 334
      s ++;
#line 335
      pp = popen((char const   *)s, "r");
      }
#line 335
      if (pp) {
#line 336
        i = 0;
#line 337
        cp = buf___0;
        {
#line 338
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 338
          tmp___7 = fgets((char */* __restrict  */)cp, 60000 - i, (FILE */* __restrict  */)pp);
          }
#line 338
          if (! tmp___7) {
#line 338
            goto while_break;
          }
          {
#line 339
          tmp___6 = strlen((char const   *)cp);
#line 339
          i = (int )((size_t )i + tmp___6);
#line 340
          cp = & buf___0[i];
          }
#line 341
          if (i >= 60000) {
            {
#line 342
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Prog execution of variable \'%s\' too long.\n",
                    m->name);
            }
#line 345
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 348
        free((void *)m->sval);
#line 349
        _cp = strchr((char const   *)(buf___0), '\n');
        }
#line 349
        if (_cp) {
#line 349
          *_cp = (char )'\000';
        }
        {
#line 350
        m->sval = strdup((char const   *)(buf___0));
#line 351
        pclose(pp);
        }
      } else {
        {
#line 354
        sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Could not start program \'%s\'",
                s);
#line 355
        perror((char const   *)(buf___0));
        }
      }
    }
  }
#line 359
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void SetMapping(Map_t *M , char *s ) 
{ 
  char buf___0[60000] ;
  char *name ;
  char *val ;
  char *tmp ;

  {
#line 375
  if (! M) {
    {
#line 376
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SetMapping: Map not initialized.\n");
    }
#line 377
    return;
  }
  {
#line 379
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)s);
#line 380
  val = buf___0;
#line 380
  name = val;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (*val) {
#line 381
      if ((int )*val == 32) {
#line 381
        goto while_break;
      } else
#line 381
      if ((int )*val == 9) {
#line 381
        goto while_break;
      }
    } else {
#line 381
      goto while_break;
    }
#line 381
    val ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (*val) {
#line 383
    tmp = val;
#line 383
    val ++;
#line 383
    *tmp = (char )'\000';
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 384
      if (*val) {
#line 384
        if (! ((int )*val == 32)) {
#line 384
          if (! ((int )*val == 9)) {
#line 384
            goto while_break___0;
          }
        }
      } else {
#line 384
        goto while_break___0;
      }
#line 384
      val ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 386
  if (name) {
    {
#line 386
    SetMappingNV(M, name, val);
    }
  }
#line 387
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static char **libdirs  ;
#line 407 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static int nlibdirs  =    -1;
#line 398 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
FILE *OpenFile(char *filename ) 
{ 
  FILE *fp ;
  char buf___0[60000] ;
  int i ;
  char *cp ;
  char *s ;

  {
  {
#line 409
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 409
  if (fp) {
#line 409
    return (fp);
  }
#line 411
  if ((int )*filename == 47) {
#line 411
    return ((FILE *)((void *)0));
  }
#line 413
  if (nlibdirs < 0) {
#line 415
    if (tpt_lib) {
      {
#line 416
      s = strdup((char const   *)tpt_lib);
#line 417
      cp = s;
      }
      {
#line 417
      while (1) {
        while_continue: /* CIL Label */ ;
#line 417
        if (! *cp) {
#line 417
          goto while_break;
        }
#line 417
        if ((int )*cp == 58) {
#line 417
          *cp = (char )' ';
        }
#line 417
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 418
      nlibdirs = 0;
#line 419
      libdirs = Split(s, & nlibdirs, 2);
      }
    } else {
#line 421
      nlibdirs = 0;
    }
  }
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 423
    if (! (i < nlibdirs)) {
#line 423
      goto while_break___0;
    }
    {
#line 424
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s/%s",
            *(libdirs + i), filename);
#line 425
    fp = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"r");
    }
#line 425
    if (fp) {
#line 425
      return (fp);
    }
#line 423
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 427
  return ((FILE *)((void *)0));
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *FindElementPath(Element_t *e , char *s ) 
{ 
  Element_t *ep ;
  int i ;
  int e_path[40] ;
  char *cp ;
  size_t tmp ;

  {
#line 454
  ep = e;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! ep) {
#line 454
      goto while_break;
    }
#line 455
    e_path[ep->depth - 1] = ep->my_eorder;
#line 454
    ep = ep->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  cp = s;
#line 457
  i = 0;
#line 457
  ep = DocTree;
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 457
    if (! (i < e->depth)) {
#line 457
      goto while_break___0;
    }
    {
#line 458
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%s(%d) ",
            ep->gi, e_path[i]);
#line 459
    tmp = strlen((char const   *)cp);
#line 459
    cp += tmp;
#line 457
    ep = *(ep->econt + e_path[i]);
#line 457
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 461
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%s", e->gi);
  }
#line 462
  return (s);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void PrintLocation(Element_t *e , FILE *fp ) 
{ 
  char *s ;
  char buf___0[60000] ;
  char *tmp ;

  {
#line 481
  if (! e) {
#line 481
    return;
  } else
#line 481
  if (! fp) {
#line 481
    return;
  }
  {
#line 482
  tmp = FindElementPath(e, buf___0);
#line 482
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  Path: %s\n",
          tmp);
#line 483
  s = NearestOlderElem(e, (char *)"TITLE");
  }
#line 483
  if (s) {
    {
#line 484
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  Position hint: TITLE=\'%s\'\n",
            s);
    }
  }
#line 485
  if (e->lineno) {
#line 486
    if (e->infile) {
      {
#line 487
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  At or near instance file: %s, line: %d\n",
              e->infile, e->lineno);
      }
    } else {
      {
#line 490
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  At or near instance line: %d\n",
              e->lineno);
      }
    }
  }
#line 492
  if (e->id) {
    {
#line 493
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ID: %s\n",
            e->id);
    }
  }
#line 494
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *NearestOlderElem(Element_t *e , char *name ) 
{ 
  int i ;
  Element_t *ep ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 515
  if (! e) {
#line 515
    return ((char *)0);
  }
#line 516
  if (! name) {
#line 516
    name = (char *)"TITLE";
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! e->parent) {
#line 518
      goto while_break;
    }
#line 519
    i = 0;
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      if (! (i <= e->my_eorder)) {
#line 519
        goto while_break___0;
      }
      {
#line 520
      ep = e->parent;
#line 521
      tmp___0 = strcmp((char const   *)name, (char const   *)(*(ep->econt + i))->gi);
      }
#line 521
      if (! tmp___0) {
#line 522
        if ((*(ep->econt + i))->ndcont) {
#line 522
          tmp = (char const   *)*((*(ep->econt + i))->dcont + 0);
        } else {
#line 522
          tmp = "-empty-";
        }
#line 522
        return ((char *)tmp);
      }
#line 519
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 518
    e = e->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return ((char *)((void *)0));
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static int char_pos  ;
#line 543 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void OutputString(char *s , FILE *fp , int track_pos ) 
{ 
  char c ;
  char *sdata ;
  char *cp ;

  {
#line 553
  if (! fp) {
#line 553
    return;
  }
#line 554
  if (! s) {
#line 554
    s = (char *)"^";
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! *s) {
#line 556
      goto while_break;
    }
#line 557
    if ((int )*s == 92) {
#line 558
      s ++;
#line 559
      if (track_pos) {
#line 559
        char_pos ++;
      }
      {
#line 563
      if ((int )*s == 115) {
#line 563
        goto case_115;
      }
#line 565
      if ((int )*s == 116) {
#line 565
        goto case_116;
      }
#line 567
      if ((int )*s == 110) {
#line 567
        goto case_110;
      }
#line 569
      if ((int )*s == 114) {
#line 569
        goto case_114;
      }
#line 572
      if ((int )*s == 55) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 54) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 53) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 52) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 51) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 50) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 49) {
#line 572
        goto case_55;
      }
#line 572
      if ((int )*s == 48) {
#line 572
        goto case_55;
      }
#line 580
      if ((int )*s == 124) {
#line 580
        goto case_124;
      }
#line 561
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 561
      c = *s;
#line 561
      goto switch_break;
      case_115: /* CIL Label */ 
#line 563
      c = (char )' ';
#line 563
      goto switch_break;
      case_116: /* CIL Label */ 
#line 565
      c = (char )'\t';
#line 565
      goto switch_break;
      case_110: /* CIL Label */ 
#line 567
      c = (char )'\n';
#line 567
      char_pos = 0;
#line 567
      goto switch_break;
      case_114: /* CIL Label */ 
#line 569
      c = (char )'\r';
#line 569
      char_pos = 0;
#line 569
      goto switch_break;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 574
      c = (char )((int )*s - 48);
#line 575
      s ++;
      {
#line 575
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 575
        if ((int )*s >= 48) {
#line 575
          if (! ((int )*s <= 55)) {
#line 575
            goto while_break___0;
          }
        } else {
#line 575
          goto while_break___0;
        }
#line 576
        c = (char )(((int )c << 3) + ((int )*s - 48));
#line 575
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 577
      s --;
#line 578
      goto switch_break;
      case_124: /* CIL Label */ 
#line 585
      s ++;
#line 586
      sdata = s;
#line 588
      cp = s;
      {
#line 589
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 589
        if (*cp) {
#line 589
          if ((int )*cp != 92) {
#line 589
            if (! ((int )*(cp + 1) != 124)) {
#line 589
              goto while_break___1;
            }
          } else {
#line 589
            goto while_break___1;
          }
        } else {
#line 589
          goto while_break___1;
        }
#line 589
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 590
      if (! *cp) {
#line 590
        goto switch_break;
      }
      {
#line 592
      *cp = (char )'\000';
#line 593
      cp ++;
#line 594
      s = cp;
#line 596
      cp = LookupSDATA(sdata);
      }
#line 597
      if (cp) {
        {
#line 597
        OutputString(cp, fp, track_pos);
        }
      } else {
        {
#line 600
        _IO_putc('[', fp);
#line 601
        fputs((char const   */* __restrict  */)sdata, (FILE */* __restrict  */)fp);
#line 602
        _IO_putc(']', fp);
        }
      }
#line 604
      c = (char)0;
#line 605
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 609
      c = *s;
#line 612
      if (track_pos) {
#line 613
        if ((int )c == 94) {
#line 616
          if (char_pos != 0) {
#line 616
            c = (char )'\n';
          } else {
#line 617
            c = (char)0;
          }
        } else {
#line 619
          char_pos ++;
        }
#line 620
        if ((int )c == 10) {
#line 620
          char_pos = 0;
        }
      } else
#line 622
      if ((int )c == 94) {
#line 622
        c = (char )'\n';
      }
    }
#line 624
    if (c) {
#line 625
      if (track_pos) {
#line 626
        if ((int )c == 10) {
#line 626
          char_pos = 0;
        } else {
#line 626
          char_pos ++;
        }
      }
      {
#line 628
      _IO_putc((int )c, fp);
      }
    }
#line 556
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return;
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static Map_t *Hits  ;
#line 645 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *LookupSDATA(char *s ) 
{ 
  char *v ;

  {
#line 654
  if (Hits) {
    {
#line 655
    v = FindMappingVal(Hits, s);
    }
#line 655
    if (v) {
#line 655
      return (v);
    }
  }
  {
#line 658
  v = FindMappingVal(SDATAmap, s);
#line 661
  v = FindMappingVal(SDATAmap, s);
  }
#line 661
  if (v) {
#line 662
    if (! Hits) {
      {
#line 662
      Hits = NewMap(30);
      }
    }
    {
#line 663
    SetMappingNV(Hits, s, v);
    }
#line 664
    return (v);
  }
  {
#line 667
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not find SDATA substitution \'%s\'.\n",
          s);
  }
#line 668
  return ((char *)((void *)0));
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static int n_alloc  =    0;
#line 681 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *AddElemName(char *name ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 690
  i = 0;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! (i < nUsedElem)) {
#line 690
      goto while_break;
    }
#line 691
    if ((int )*(*(UsedElem + i) + 0) == (int )*(name + 0)) {
      {
#line 691
      tmp = strcmp((char const   *)*(UsedElem + i), (char const   *)name);
      }
#line 691
      if (! tmp) {
#line 692
        return (*(UsedElem + i));
      }
    }
#line 690
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 696
  if (n_alloc == 0) {
    {
#line 697
    n_alloc = 50;
#line 698
    tmp___0 = calloc((size_t )n_alloc, sizeof(char *));
#line 698
    UsedElem = (char **)tmp___0;
    }
#line 698
    if (! UsedElem) {
      {
#line 698
      perror("Calloc failed -- out of memory.  Bailing out.");
#line 698
      exit(1);
      }
    }
    {
#line 698
    memset((void *)UsedElem, 0, sizeof(char *));
    }
  } else
#line 700
  if (nUsedElem >= n_alloc) {
    {
#line 701
    n_alloc += 50;
#line 702
    tmp___1 = realloc((void *)UsedElem, (size_t )n_alloc * sizeof(char *));
#line 702
    UsedElem = (char **)tmp___1;
    }
#line 702
    if (! UsedElem) {
      {
#line 702
      perror("Realloc failed -- out of memory.  Bailing out.");
#line 702
      exit(1);
      }
    }
  }
  {
#line 704
  *(UsedElem + nUsedElem) = strdup((char const   *)name);
#line 705
  tmp___2 = nUsedElem;
#line 705
  nUsedElem ++;
  }
#line 705
  return (*(UsedElem + tmp___2));
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static int n_alloc___0  =    0;
#line 717 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *AddAttName(char *name ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 726
  i = 0;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! (i < nUsedAtt)) {
#line 726
      goto while_break;
    }
#line 727
    if ((int )*(*(UsedAtt + i) + 0) == (int )*(name + 0)) {
      {
#line 727
      tmp = strcmp((char const   *)*(UsedAtt + i), (char const   *)name);
      }
#line 727
      if (! tmp) {
#line 728
        return (*(UsedAtt + i));
      }
    }
#line 726
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  if (n_alloc___0 == 0) {
    {
#line 733
    n_alloc___0 = 50;
#line 734
    tmp___0 = calloc((size_t )n_alloc___0, sizeof(char *));
#line 734
    UsedAtt = (char **)tmp___0;
    }
#line 734
    if (! UsedAtt) {
      {
#line 734
      perror("Calloc failed -- out of memory.  Bailing out.");
#line 734
      exit(1);
      }
    }
    {
#line 734
    memset((void *)UsedAtt, 0, sizeof(char *));
    }
  } else
#line 736
  if (nUsedAtt >= n_alloc___0) {
    {
#line 737
    n_alloc___0 += 50;
#line 738
    tmp___1 = realloc((void *)UsedAtt, (size_t )n_alloc___0 * sizeof(char *));
#line 738
    UsedAtt = (char **)tmp___1;
    }
#line 738
    if (! UsedAtt) {
      {
#line 738
      perror("Realloc failed -- out of memory.  Bailing out.");
#line 738
      exit(1);
      }
    }
  }
  {
#line 740
  *(UsedAtt + nUsedAtt) = strdup((char const   *)name);
#line 741
  tmp___2 = nUsedAtt;
#line 741
  nUsedAtt ++;
  }
#line 741
  return (*(UsedAtt + tmp___2));
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *FindAttValByName(Element_t *e , char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 779
  if (! e) {
#line 779
    return ((char *)((void *)0));
  }
#line 780
  i = 0;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! (i < e->natts)) {
#line 780
      goto while_break;
    }
#line 781
    if ((int )*((e->atts + i)->name + 0) == (int )*(name + 0)) {
      {
#line 781
      tmp = strcmp((char const   *)(e->atts + i)->name, (char const   *)name);
      }
#line 781
      if (! tmp) {
#line 782
        return ((e->atts + i)->sval);
      }
    }
#line 780
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  return ((char *)((void *)0));
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
char *FindContext(Element_t *e , int levels , char *con ) 
{ 
  char *s ;
  Element_t *ep ;
  int i ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 808
  if (! e) {
#line 808
    return ((char *)((void *)0));
  }
#line 809
  s = con;
#line 810
  *s = (char )'\000';
#line 811
  i = 0;
#line 811
  ep = e->parent;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (ep) {
#line 811
      if (! levels) {
#line 811
        goto while_break;
      }
    } else {
#line 811
      goto while_break;
    }
#line 812
    if (i != 0) {
#line 812
      tmp = s;
#line 812
      s ++;
#line 812
      *tmp = (char )' ';
    }
    {
#line 813
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)ep->gi);
#line 814
    tmp___0 = strlen((char const   *)s);
#line 814
    s += tmp___0;
#line 811
    ep = ep->parent;
#line 811
    i ++;
#line 811
    levels --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 816
  return (con);
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
Element_t *QRelation(Element_t *e , char *s , Relation_t rel ) 
{ 
  int i ;
  Element_t *ep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Element_t *tmp___8 ;

  {
#line 842
  if (! e) {
#line 842
    return ((Element_t *)0);
  }
  {
#line 847
  if ((unsigned int )rel == 1U) {
#line 847
    goto case_1;
  }
#line 851
  if ((unsigned int )rel == 2U) {
#line 851
    goto case_2;
  }
#line 855
  if ((unsigned int )rel == 3U) {
#line 855
    goto case_3;
  }
#line 860
  if ((unsigned int )rel == 4U) {
#line 860
    goto case_4;
  }
#line 870
  if ((unsigned int )rel == 5U) {
#line 870
    goto case_5;
  }
#line 877
  if ((unsigned int )rel == 6U) {
#line 877
    goto case_6;
  }
#line 883
  if ((unsigned int )rel == 7U) {
#line 883
    goto case_7;
  }
#line 888
  if ((unsigned int )rel == 8U) {
#line 888
    goto case_8;
  }
#line 895
  if ((unsigned int )rel == 9U) {
#line 895
    goto case_9;
  }
#line 901
  if ((unsigned int )rel == 10U) {
#line 901
    goto case_10;
  }
#line 907
  if ((unsigned int )rel == 11U) {
#line 907
    goto case_11;
  }
#line 907
  if ((unsigned int )rel == 0U) {
#line 907
    goto case_11;
  }
#line 845
  goto switch_break;
  case_1: /* CIL Label */ 
#line 848
  if (! e->parent) {
#line 848
    return ((Element_t *)0);
  } else
#line 848
  if (! (e->parent)->gi) {
#line 848
    return ((Element_t *)0);
  }
  {
#line 849
  tmp = strcmp((char const   *)(e->parent)->gi, (char const   *)s);
  }
#line 849
  if (! tmp) {
#line 849
    return (e->parent);
  }
#line 850
  goto switch_break;
  case_2: /* CIL Label */ 
#line 852
  i = 0;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < e->necont)) {
#line 852
      goto while_break;
    }
    {
#line 853
    tmp___0 = strcmp((char const   *)s, (char const   *)(*(e->econt + i))->gi);
    }
#line 853
    if (! tmp___0) {
#line 853
      return (*(e->econt + i));
    }
#line 852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  goto switch_break;
  case_3: /* CIL Label */ 
#line 856
  if (! e->parent) {
#line 856
    return ((Element_t *)0);
  } else
#line 856
  if (! (e->parent)->gi) {
#line 856
    return ((Element_t *)0);
  }
#line 857
  ep = e->parent;
  {
#line 857
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 857
    if (! ep) {
#line 857
      goto while_break___0;
    }
    {
#line 858
    tmp___1 = strcmp((char const   *)ep->gi, (char const   *)s);
    }
#line 858
    if (! tmp___1) {
#line 858
      return (ep);
    }
#line 857
    ep = ep->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 859
  goto switch_break;
  case_4: /* CIL Label */ 
#line 861
  if (e->necont == 0) {
#line 861
    return ((Element_t *)0);
  }
#line 863
  i = 0;
  {
#line 863
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 863
    if (! (i < e->necont)) {
#line 863
      goto while_break___1;
    }
    {
#line 864
    tmp___2 = strcmp((char const   *)s, (char const   *)(*(e->econt + i))->gi);
    }
#line 864
    if (! tmp___2) {
#line 864
      return (*(e->econt + i));
    }
#line 863
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 866
  i = 0;
  {
#line 866
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 866
    if (! (i < e->necont)) {
#line 866
      goto while_break___2;
    }
    {
#line 867
    ep = QRelation(*(e->econt + i), s, (Relation_t )4);
    }
#line 867
    if (ep) {
#line 868
      return (ep);
    }
#line 866
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 869
  goto switch_break;
  case_5: /* CIL Label */ 
#line 871
  if (! e->parent) {
#line 871
    return ((Element_t *)0);
  }
#line 872
  ep = e->parent;
#line 873
  i = 0;
  {
#line 873
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 873
    if (! (i < ep->necont)) {
#line 873
      goto while_break___3;
    }
    {
#line 874
    tmp___3 = strcmp((char const   *)s, (char const   *)(*(ep->econt + i))->gi);
    }
#line 874
    if (! tmp___3) {
#line 874
      if (i != e->my_eorder) {
#line 875
        return (*(ep->econt + i));
      }
    }
#line 873
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 876
  goto switch_break;
  case_6: /* CIL Label */ 
#line 878
  if (! e->parent) {
#line 878
    return ((Element_t *)0);
  } else
#line 878
  if (e->my_eorder == 0) {
#line 878
    return ((Element_t *)0);
  }
#line 879
  ep = e->parent;
#line 880
  i = 0;
  {
#line 880
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 880
    if (! (i < e->my_eorder)) {
#line 880
      goto while_break___4;
    }
    {
#line 881
    tmp___4 = strcmp((char const   *)s, (char const   *)(*(ep->econt + i))->gi);
    }
#line 881
    if (! tmp___4) {
#line 881
      return (*(ep->econt + i));
    }
#line 880
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 882
  goto switch_break;
  case_7: /* CIL Label */ 
#line 884
  if (! e->parent) {
#line 884
    return ((Element_t *)0);
  } else
#line 884
  if (e->my_eorder == 0) {
#line 884
    return ((Element_t *)0);
  }
  {
#line 885
  ep = *((e->parent)->econt + (e->my_eorder - 1));
#line 886
  tmp___5 = strcmp((char const   *)s, (char const   *)ep->gi);
  }
#line 886
  if (! tmp___5) {
#line 886
    return (ep);
  }
#line 887
  goto switch_break;
  case_8: /* CIL Label */ 
#line 889
  if (! e->parent) {
#line 890
    return ((Element_t *)0);
  } else
#line 889
  if (e->my_eorder == (e->parent)->necont - 1) {
#line 890
    return ((Element_t *)0);
  }
#line 891
  ep = e->parent;
#line 892
  i = e->my_eorder + 1;
  {
#line 892
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 892
    if (! (i < ep->necont)) {
#line 892
      goto while_break___5;
    }
    {
#line 893
    tmp___6 = strcmp((char const   *)s, (char const   *)(*(ep->econt + i))->gi);
    }
#line 893
    if (! tmp___6) {
#line 893
      return (*(ep->econt + i));
    }
#line 892
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 894
  goto switch_break;
  case_9: /* CIL Label */ 
#line 896
  if (! e->parent) {
#line 897
    return ((Element_t *)0);
  } else
#line 896
  if (e->my_eorder == (e->parent)->necont - 1) {
#line 897
    return ((Element_t *)0);
  }
  {
#line 898
  ep = *((e->parent)->econt + (e->my_eorder + 1));
#line 899
  tmp___7 = strcmp((char const   *)s, (char const   *)ep->gi);
  }
#line 899
  if (! tmp___7) {
#line 899
    return (ep);
  }
#line 900
  goto switch_break;
  case_10: /* CIL Label */ 
#line 902
  if (! e->parent) {
#line 902
    return ((Element_t *)0);
  }
  {
#line 904
  tmp___8 = QRelation(e->parent, s, (Relation_t )2);
  }
#line 904
  return (tmp___8);
#line 905
  goto switch_break;
  case_11: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 908
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You can not query \'REL_None\' or \'REL_Unknown\'.\n");
  }
#line 909
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 911
  return ((Element_t *)((void *)0));
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
Relation_t FindRelByName(char *relname ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 925
  tmp___9 = strcmp((char const   *)relname, "?");
  }
#line 925
  if (tmp___9) {
#line 931
    if ((int )*(relname + 0) == (int )*("child" + 0)) {
      {
#line 931
      tmp___8 = strcmp((char const   *)relname, "child");
      }
#line 931
      if (tmp___8) {
#line 931
        goto _L___7;
      } else {
#line 931
        return ((Relation_t )2);
      }
    } else
    _L___7: /* CIL Label */ 
#line 932
    if ((int )*(relname + 0) == (int )*("parent" + 0)) {
      {
#line 932
      tmp___7 = strcmp((char const   *)relname, "parent");
      }
#line 932
      if (tmp___7) {
#line 932
        goto _L___6;
      } else {
#line 932
        return ((Relation_t )1);
      }
    } else
    _L___6: /* CIL Label */ 
#line 933
    if ((int )*(relname + 0) == (int )*("ancestor" + 0)) {
      {
#line 933
      tmp___6 = strcmp((char const   *)relname, "ancestor");
      }
#line 933
      if (tmp___6) {
#line 933
        goto _L___5;
      } else {
#line 933
        return ((Relation_t )3);
      }
    } else
    _L___5: /* CIL Label */ 
#line 934
    if ((int )*(relname + 0) == (int )*("descendant" + 0)) {
      {
#line 934
      tmp___5 = strcmp((char const   *)relname, "descendant");
      }
#line 934
      if (tmp___5) {
#line 934
        goto _L___4;
      } else {
#line 934
        return ((Relation_t )4);
      }
    } else
    _L___4: /* CIL Label */ 
#line 935
    if ((int )*(relname + 0) == (int )*("sibling" + 0)) {
      {
#line 935
      tmp___4 = strcmp((char const   *)relname, "sibling");
      }
#line 935
      if (tmp___4) {
#line 935
        goto _L___3;
      } else {
#line 935
        return ((Relation_t )5);
      }
    } else
    _L___3: /* CIL Label */ 
#line 936
    if ((int )*(relname + 0) == (int )*("sibling-" + 0)) {
      {
#line 936
      tmp___3 = strcmp((char const   *)relname, "sibling-");
      }
#line 936
      if (tmp___3) {
#line 936
        goto _L___2;
      } else {
#line 936
        return ((Relation_t )6);
      }
    } else
    _L___2: /* CIL Label */ 
#line 937
    if ((int )*(relname + 0) == (int )*("sibling-1" + 0)) {
      {
#line 937
      tmp___2 = strcmp((char const   *)relname, "sibling-1");
      }
#line 937
      if (tmp___2) {
#line 937
        goto _L___1;
      } else {
#line 937
        return ((Relation_t )7);
      }
    } else
    _L___1: /* CIL Label */ 
#line 938
    if ((int )*(relname + 0) == (int )*("sibling+" + 0)) {
      {
#line 938
      tmp___1 = strcmp((char const   *)relname, "sibling+");
      }
#line 938
      if (tmp___1) {
#line 938
        goto _L___0;
      } else {
#line 938
        return ((Relation_t )8);
      }
    } else
    _L___0: /* CIL Label */ 
#line 939
    if ((int )*(relname + 0) == (int )*("sibling+1" + 0)) {
      {
#line 939
      tmp___0 = strcmp((char const   *)relname, "sibling+1");
      }
#line 939
      if (tmp___0) {
#line 939
        goto _L;
      } else {
#line 939
        return ((Relation_t )9);
      }
    } else
    _L: /* CIL Label */ 
#line 940
    if ((int )*(relname + 0) == (int )*("cousin" + 0)) {
      {
#line 940
      tmp = strcmp((char const   *)relname, "cousin");
      }
#line 940
      if (tmp) {
        {
#line 941
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown relationship: %s\n",
                relname);
        }
      } else {
#line 940
        return ((Relation_t )10);
      }
    } else {
      {
#line 941
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown relationship: %s\n",
              relname);
      }
    }
  } else {
    {
#line 926
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Supported query/relationships %s\n%s.\n",
            "child, parent, ancestor, descendant,", "sibling, sibling+, sibling+1, sibling-, sibling-1");
    }
#line 929
    return ((Relation_t )0);
  }
#line 942
  return ((Relation_t )11);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void DescendTree(Element_t *e , void (*enter_f)() , void (*leave_f)() , void (*data_f)() ,
                 void *dp ) 
{ 
  int i ;

  {
#line 973
  if (enter_f) {
    {
#line 973
    (*enter_f)(e, dp);
    }
  }
#line 974
  i = 0;
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (! (i < e->ncont)) {
#line 974
      goto while_break;
    }
#line 975
    if ((int )(e->cont + i)->type == 40) {
      {
#line 976
      DescendTree((e->cont + i)->ch.elem, enter_f, leave_f, data_f, dp);
      }
    } else
#line 978
    if (data_f) {
      {
#line 978
      (*data_f)(e->cont + i, dp);
      }
    }
#line 974
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 980
  if (leave_f) {
    {
#line 980
    (*leave_f)(e, dp);
    }
  }
#line 981
  return;
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
static ID_t *id_last  ;
#line 991 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
void AddID(Element_t *e , char *idval ) 
{ 
  void *tmp ;
  struct id_s *tmp___0 ;
  void *tmp___1 ;

  {
#line 999
  if (! IDList) {
    {
#line 1000
    tmp = malloc(sizeof(ID_t ));
#line 1000
    id_last = (ID_t *)tmp;
    }
#line 1000
    if (! id_last) {
      {
#line 1000
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 1000
      exit(1);
      }
    }
    {
#line 1000
    memset((void *)id_last, 0, sizeof(ID_t ));
#line 1001
    IDList = id_last;
    }
  } else {
    {
#line 1004
    tmp___1 = malloc(sizeof(ID_t ));
#line 1004
    tmp___0 = (ID_t *)tmp___1;
#line 1004
    id_last->next = tmp___0;
    }
#line 1004
    if (! tmp___0) {
      {
#line 1004
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 1004
      exit(1);
      }
    }
    {
#line 1004
    memset((void *)id_last->next, 0, sizeof(ID_t ));
#line 1005
    id_last = id_last->next;
    }
  }
#line 1007
  id_last->elem = e;
#line 1008
  id_last->id = idval;
#line 1009
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/util.c"
Element_t *FindElemByID(char *idval ) 
{ 
  ID_t *id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1025
  id = IDList;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! id) {
#line 1025
      goto while_break;
    }
    {
#line 1026
    tmp = toupper((int )*(id->id + 0));
#line 1026
    tmp___0 = toupper((int )*(idval + 0));
    }
#line 1026
    if (tmp == tmp___0) {
      {
#line 1026
      tmp___1 = strcasecmp((char const   *)id->id, (char const   *)idval);
      }
#line 1026
      if (! tmp___1) {
#line 1026
        return (id->elem);
      }
    }
#line 1025
    id = id->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  return ((Element_t *)0);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 702 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 18 "tptregexp/tptregexp.h"
regexp *tpt_regcomp(char *exp ) ;
#line 307 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
void ReadTransSpec(char *transfile ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
Trans_t *TrSpecs ;
#line 132
Mapping_t *CharMap ;
#line 133
int nCharMap ;
#line 84 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
void RememberTransSpec(Trans_t *t , int lineno ) ;
#line 217
void ExpandVariables(char *in , char *out , Element_t *e ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
void ReadTransSpec(char *transfile ) 
{ 
  FILE *fp ;
  char buf___0[60000] ;
  char *cp ;
  char *fn ;
  char *cp2 ;
  int lineno ;
  int c ;
  int i ;
  Trans_t T ;
  char *_cp ;
  size_t tmp ;
  int tmp___0 ;
  char *_cp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char **tok ;
  char **tok___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 99
  lineno = 0;
#line 102
  fp = OpenFile(transfile);
  }
#line 102
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 103
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Can not open translation spec \'%s\'",
            transfile);
#line 104
    perror((char const   *)(buf___0));
    }
#line 105
    return;
  }
  {
#line 108
  memset((void *)(& T), 0, sizeof(T));
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    tmp___29 = fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)fp);
    }
#line 109
    if (! tmp___29) {
#line 109
      goto while_break;
    }
#line 111
    lineno ++;
#line 113
    if ((int )buf___0[0] == 35) {
#line 113
      goto while_continue;
    } else
#line 113
    if ((int )buf___0[0] == 10) {
#line 113
      goto while_continue;
    }
#line 117
    if ((int )buf___0[0] == 45) {
      {
#line 118
      T.lineno = lineno;
#line 119
      RememberTransSpec(& T, lineno);
#line 120
      memset((void *)(& T), 0, sizeof(T));
      }
#line 121
      goto while_continue;
    }
    {
#line 124
    _cp = strchr((char const   *)(buf___0), '\n');
    }
#line 124
    if (_cp) {
#line 124
      *_cp = (char )'\000';
    }
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 130
      c = _IO_getc(fp);
      }
#line 131
      if (c == 32) {
#line 131
        goto _L;
      } else
#line 131
      if (c == 9) {
        _L: /* CIL Label */ 
        {
#line 133
        c = _IO_getc(fp);
        }
        {
#line 134
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 134
          if (! (c == 32)) {
#line 134
            if (! (c == 9)) {
#line 134
              goto while_break___1;
            }
          }
          {
#line 134
          c = _IO_getc(fp);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 135
        ungetc(c, fp);
#line 136
        tmp = strlen((char const   *)(buf___0));
#line 136
        i = (int )tmp;
#line 137
        tmp___0 = i;
#line 137
        i ++;
#line 137
        buf___0[tmp___0] = (char )' ';
#line 138
        fn = buf___0 + i;
#line 139
        fgets((char */* __restrict  */)fn, 60000 - i, (FILE */* __restrict  */)fp);
#line 140
        lineno ++;
#line 141
        _cp___0 = strchr((char const   *)(buf___0), '\n');
        }
#line 141
        if (_cp___0) {
#line 141
          *_cp___0 = (char )'\000';
        }
      } else {
        {
#line 144
        ungetc(c, fp);
        }
#line 145
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 149
    cp = strchr((char const   *)(buf___0), ':');
    }
#line 149
    if (cp) {
#line 150
      cp ++;
      {
#line 151
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 151
        if (*cp) {
#line 151
          if (! ((int )*cp == 32)) {
#line 151
            if (! ((int )*cp == 9)) {
#line 151
              goto while_break___2;
            }
          }
        } else {
#line 151
          goto while_break___2;
        }
#line 151
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trans spec error, missing colon (skipping line):\n  %s\n",
              fn);
      }
#line 156
      goto while_continue;
    }
    {
#line 158
    fn = buf___0;
#line 161
    tmp___28 = strncmp("GI:", (char const   *)fn, (size_t )3);
    }
#line 161
    if (tmp___28) {
      {
#line 170
      tmp___27 = strncmp("StartText:", (char const   *)fn, (size_t )10);
      }
#line 170
      if (tmp___27) {
        {
#line 171
        tmp___26 = strncmp("EndText:", (char const   *)fn, (size_t )8);
        }
#line 171
        if (tmp___26) {
          {
#line 172
          tmp___25 = strncmp("Relation:", (char const   *)fn, (size_t )9);
          }
#line 172
          if (tmp___25) {
            {
#line 176
            tmp___24 = strncmp("Replace:", (char const   *)fn, (size_t )8);
            }
#line 176
            if (tmp___24) {
              {
#line 177
              tmp___23 = strncmp("AttValue:", (char const   *)fn, (size_t )9);
              }
#line 177
              if (tmp___23) {
                {
#line 190
                tmp___22 = strncmp("Context:", (char const   *)fn, (size_t )8);
                }
#line 190
                if (tmp___22) {
                  {
#line 191
                  tmp___21 = strncmp("Message:", (char const   *)fn, (size_t )8);
                  }
#line 191
                  if (tmp___21) {
                    {
#line 192
                    tmp___20 = strncmp("SpecID:", (char const   *)fn, (size_t )7);
                    }
#line 192
                    if (tmp___20) {
                      {
#line 193
                      tmp___19 = strncmp("Action:", (char const   *)fn, (size_t )7);
                      }
#line 193
                      if (tmp___19) {
                        {
#line 194
                        tmp___18 = strncmp("Content:", (char const   *)fn, (size_t )8);
                        }
#line 194
                        if (tmp___18) {
                          {
#line 195
                          tmp___17 = strncmp("PAttSet:", (char const   *)fn, (size_t )8);
                          }
#line 195
                          if (tmp___17) {
                            {
#line 196
                            tmp___16 = strncmp("Verbatim:", (char const   *)fn, (size_t )9);
                            }
#line 196
                            if (tmp___16) {
                              {
#line 197
                              tmp___15 = strncmp("Ignore:", (char const   *)fn, (size_t )7);
                              }
#line 197
                              if (tmp___15) {
                                {
#line 205
                                tmp___14 = strncmp("VarValue:", (char const   *)fn,
                                                   (size_t )9);
                                }
#line 205
                                if (tmp___14) {
                                  {
#line 212
                                  tmp___13 = strncmp("VarREValue:", (char const   *)fn,
                                                     (size_t )11);
                                  }
#line 212
                                  if (tmp___13) {
                                    {
#line 223
                                    tmp___12 = strncmp("Set:", (char const   *)fn,
                                                       (size_t )4);
                                    }
#line 223
                                    if (tmp___12) {
                                      {
#line 227
                                      tmp___11 = strncmp("Increment:", (char const   *)fn,
                                                         (size_t )10);
                                      }
#line 227
                                      if (tmp___11) {
                                        {
#line 231
                                        tmp___10 = strncmp("NthChild:", (char const   *)fn,
                                                           (size_t )9);
                                        }
#line 231
                                        if (tmp___10) {
                                          {
#line 232
                                          tmp___9 = strncmp("Var:", (char const   *)fn,
                                                            (size_t )4);
                                          }
#line 232
                                          if (tmp___9) {
                                            {
#line 233
                                            tmp___8 = strncmp("Quit:", (char const   *)fn,
                                                              (size_t )5);
                                            }
#line 233
                                            if (tmp___8) {
                                              {
#line 235
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"Unknown translation spec (skipping it): %s\n",
                                                      fn);
                                              }
                                            } else {
                                              {
#line 233
                                              T.quit = strdup((char const   *)cp);
                                              }
                                            }
                                          } else {
                                            {
#line 232
                                            SetMapping(Variables, cp);
                                            }
                                          }
                                        } else {
                                          {
#line 231
                                          T.nth_child = atoi((char const   *)cp);
                                          }
                                        }
                                      } else {
#line 228
                                        if (! T.incr_var) {
                                          {
#line 228
                                          T.incr_var = NewMap(3);
                                          }
                                        }
                                        {
#line 229
                                        SetMapping(T.incr_var, cp);
                                        }
                                      }
                                    } else {
#line 224
                                      if (! T.set_var) {
                                        {
#line 224
                                        T.set_var = NewMap(3);
                                        }
                                      }
                                      {
#line 225
                                      SetMapping(T.set_var, cp);
                                      }
                                    }
                                  } else {
                                    {
#line 214
                                    i = 2;
#line 215
                                    tok___0 = Split(cp, & i, 1);
#line 216
                                    T.var_RE_name = *(tok___0 + 0);
#line 217
                                    ExpandVariables(*(tok___0 + 1), buf___0, 0);
#line 218
                                    T.var_RE_value = tpt_regcomp(buf___0);
                                    }
#line 218
                                    if (! T.var_RE_value) {
                                      {
#line 219
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Regex error in VarREValue Content: %s\n",
                                              *(tok___0 + 1));
                                      }
                                    }
                                  }
                                } else {
                                  {
#line 207
                                  i = 2;
#line 208
                                  tok = Split(cp, & i, 1);
#line 209
                                  T.var_name = *(tok + 0);
#line 210
                                  T.var_value = *(tok + 1);
                                  }
                                }
                              } else {
                                {
#line 198
                                tmp___7 = strcmp((char const   *)cp, "all");
                                }
#line 198
                                if (tmp___7) {
                                  {
#line 199
                                  tmp___6 = strcmp((char const   *)cp, "data");
                                  }
#line 199
                                  if (tmp___6) {
                                    {
#line 200
                                    tmp___5 = strcmp((char const   *)cp, "children");
                                    }
#line 200
                                    if (tmp___5) {
                                      {
#line 202
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad \'Ignore:\' arg in transpec (line %d): %s\n",
                                              lineno, cp);
                                      }
                                    } else {
#line 200
                                      T.ignore = 3;
                                    }
                                  } else {
#line 199
                                    T.ignore = 2;
                                  }
                                } else {
#line 198
                                  T.ignore = 1;
                                }
                              }
                            } else {
#line 196
                              T.verbatim = 1;
                            }
                          } else {
                            {
#line 195
                            T.pattrset = strdup((char const   *)cp);
                            }
                          }
                        } else {
                          {
#line 194
                          T.content = strdup((char const   *)cp);
                          }
                        }
                      } else {
                        {
#line 193
                        T.use_id = atoi((char const   *)cp);
                        }
                      }
                    } else {
                      {
#line 192
                      T.my_id = atoi((char const   *)cp);
                      }
                    }
                  } else {
                    {
#line 191
                    T.message = strdup((char const   *)cp);
                    }
                  }
                } else {
                  {
#line 190
                  T.context = strdup((char const   *)cp);
                  }
                }
              } else {
#line 178
                if (! T.nattpairs) {
                  {
#line 179
                  tmp___3 = malloc(sizeof(AttPair_t ));
#line 179
                  T.attpair = (AttPair_t *)tmp___3;
                  }
#line 179
                  if (! T.attpair) {
                    {
#line 179
                    perror("Malloc failed -- out of memory.  Bailing out.");
#line 179
                    exit(1);
                    }
                  }
                  {
#line 179
                  memset((void *)T.attpair, 0, sizeof(AttPair_t ));
                  }
                } else {
                  {
#line 182
                  tmp___4 = realloc((void *)T.attpair, (size_t )(T.nattpairs + 1) * sizeof(AttPair_t ));
#line 182
                  T.attpair = (AttPair_t *)tmp___4;
                  }
#line 182
                  if (! T.attpair) {
                    {
#line 182
                    perror("Realloc failed -- out of memory.  Bailing out.");
#line 182
                    exit(1);
                    }
                  }
                }
                {
#line 184
                (T.attpair + T.nattpairs)->name = strdup((char const   *)cp);
#line 185
                (T.nattpairs) ++;
                }
              }
            } else {
              {
#line 176
              T.replace = strdup((char const   *)cp);
              }
            }
          } else {
#line 173
            if (! T.relations) {
              {
#line 173
              T.relations = NewMap(3);
              }
            }
            {
#line 174
            SetMapping(T.relations, cp);
            }
          }
        } else {
          {
#line 171
          T.endtext = strdup((char const   *)cp);
          }
        }
      } else {
        {
#line 170
        T.starttext = strdup((char const   *)cp);
        }
      }
    } else {
#line 164
      if (fold_case) {
#line 164
        if ((int )*(cp + 0) != 95) {
#line 164
          if ((int )*(cp + 0) != 35) {
#line 165
            cp2 = cp;
            {
#line 165
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 165
              if (! *cp2) {
#line 165
                goto while_break___3;
              }
              {
#line 166
              tmp___2 = __ctype_b_loc();
              }
#line 166
              if ((int const   )*(*tmp___2 + (int )*cp2) & 512) {
                {
#line 166
                tmp___1 = toupper((int )*cp2);
#line 166
                *cp2 = (char )tmp___1;
                }
              }
#line 165
              cp2 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 168
      T.gi = AddElemName(cp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  fclose(fp);
  }
#line 238
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
static Trans_t *last_t  ;
#line 246 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
void RememberTransSpec(Trans_t *t , int lineno ) 
{ 
  char *cp ;
  int i ;
  int do_regex ;
  char buf___0[1000] ;
  unsigned short const   **tmp ;
  regexp *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  regexp *tmp___3 ;
  regexp *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  struct _Trans *tmp___7 ;
  void *tmp___8 ;

  {
#line 258
  if (t->context) {
#line 264
    do_regex = 0;
#line 264
    cp = t->context;
    {
#line 264
    while (1) {
      while_continue: /* CIL Label */ ;
#line 264
      if (! *cp) {
#line 264
        goto while_break;
      }
      {
#line 265
      tmp = __ctype_b_loc();
      }
#line 265
      if (! ((int const   )*(*tmp + (int )*cp) & 8)) {
#line 265
        if ((int )*cp != 45) {
#line 265
          if ((int )*cp != 46) {
#line 265
            if ((int )*cp != 32) {
#line 266
              do_regex = 1;
#line 267
              goto while_break;
            }
          }
        }
      }
#line 264
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 271
    if (do_regex) {
      {
#line 272
      t->depth = 40;
#line 273
      tmp___0 = tpt_regcomp(t->context);
#line 273
      t->context_re = tmp___0;
      }
#line 273
      if (! tmp___0) {
        {
#line 274
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Regex error in Context: %s\n",
                t->context);
        }
      }
    } else {
      {
#line 281
      cp = t->context;
#line 282
      tmp___1 = strchr((char const   *)cp, ' ');
      }
#line 282
      if (tmp___1) {
#line 288
        t->depth = 0;
        {
#line 289
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 289
          if (! *cp) {
#line 289
            goto while_break___0;
          }
#line 290
          if (*cp) {
#line 290
            (t->depth) ++;
          }
          {
#line 291
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 291
            if (*cp) {
#line 291
              if ((int )*cp == 32) {
#line 291
                goto while_break___1;
              } else
#line 291
              if ((int )*cp == 9) {
#line 291
                goto while_break___1;
              }
            } else {
#line 291
              goto while_break___1;
            }
#line 291
            cp ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 292
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 292
            if (*cp) {
#line 292
              if (! ((int )*cp == 32)) {
#line 292
                if (! ((int )*cp == 9)) {
#line 292
                  goto while_break___2;
                }
              }
            } else {
#line 292
              goto while_break___2;
            }
#line 292
            cp ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 283
        t->parent = t->context;
#line 284
        t->context = (char *)((void *)0);
      }
    }
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 299
    if (! (i < t->nattpairs)) {
#line 299
      goto while_break___3;
    }
#line 301
    cp = (t->attpair + i)->name;
    {
#line 302
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 302
      if (*cp) {
#line 302
        if ((int )*cp == 32) {
#line 302
          goto while_break___4;
        } else
#line 302
        if ((int )*cp == 9) {
#line 302
          goto while_break___4;
        }
      } else {
#line 302
        goto while_break___4;
      }
#line 302
      cp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 303
    if (*cp) {
#line 304
      tmp___2 = cp;
#line 304
      cp ++;
#line 304
      *tmp___2 = (char )'\000';
      {
#line 305
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 305
        if (*cp) {
#line 305
          if (! ((int )*cp == 32)) {
#line 305
            if (! ((int )*cp == 9)) {
#line 305
              goto while_break___5;
            }
          }
        } else {
#line 305
          goto while_break___5;
        }
#line 305
        cp ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 306
      ExpandVariables(cp, buf___0, 0);
#line 307
      (t->attpair + i)->val = strdup((char const   *)(buf___0));
      }
    } else {
#line 310
      (t->attpair + i)->val = (char *)".";
    }
    {
#line 312
    tmp___3 = tpt_regcomp((t->attpair + i)->val);
#line 312
    (t->attpair + i)->rex = tmp___3;
    }
#line 312
    if (! tmp___3) {
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Regex error in AttValue: %s %s\n",
              (t->attpair + i)->name, (t->attpair + i)->val);
      }
    }
#line 299
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 319
  t->content_re = (regexp *)0;
#line 320
  if (t->content) {
    {
#line 321
    ExpandVariables(t->content, buf___0, 0);
#line 322
    tmp___4 = tpt_regcomp(buf___0);
#line 322
    t->content_re = tmp___4;
    }
#line 322
    if (! tmp___4) {
      {
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Regex error in Content: %s\n",
              t->content);
      }
    }
  }
#line 329
  if (t->gi) {
    {
#line 329
    tmp___5 = strchr((char const   *)t->gi, ' ');
    }
#line 329
    if (tmp___5) {
      {
#line 330
      t->gilist = Split(t->gi, (int *)0, 2);
#line 331
      t->gi = (char *)((void *)0);
      }
    }
  }
#line 335
  if (! TrSpecs) {
    {
#line 336
    tmp___6 = malloc(sizeof(Trans_t ));
#line 336
    TrSpecs = (Trans_t *)tmp___6;
    }
#line 336
    if (! TrSpecs) {
      {
#line 336
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 336
      exit(1);
      }
    }
    {
#line 336
    memset((void *)TrSpecs, 0, sizeof(Trans_t ));
#line 337
    last_t = TrSpecs;
    }
  } else {
    {
#line 340
    tmp___8 = malloc(sizeof(Trans_t ));
#line 340
    tmp___7 = (Trans_t *)tmp___8;
#line 340
    last_t->next = tmp___7;
    }
#line 340
    if (! tmp___7) {
      {
#line 340
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 340
      exit(1);
      }
    }
    {
#line 340
    memset((void *)last_t->next, 0, sizeof(Trans_t ));
#line 341
    last_t = last_t->next;
    }
  }
#line 343
  *last_t = *t;
#line 344
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
void ReadCharMap(char *filename ) 
{ 
  FILE *fp ;
  char buf___0[60000] ;
  char *name ;
  char *val ;
  int lineno ;
  int n_alloc___1 ;
  void *tmp ;
  char *_cp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 360
  lineno = 0;
#line 361
  n_alloc___1 = 0;
#line 363
  fp = OpenFile(filename);
  }
#line 363
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 364
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Can not open character mapping file file \'%s\': ",
            filename);
#line 366
    perror((char const   *)(buf___0));
    }
#line 367
    return;
  }
  {
#line 372
  n_alloc___1 = 32;
#line 373
  tmp = calloc((size_t )n_alloc___1, sizeof(Mapping_t ));
#line 373
  CharMap = (Mapping_t *)tmp;
  }
#line 373
  if (! CharMap) {
    {
#line 373
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 373
    exit(1);
    }
  }
  {
#line 373
  memset((void *)CharMap, 0, sizeof(Mapping_t ));
#line 375
  nCharMap = 0;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    tmp___2 = fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)fp);
    }
#line 376
    if (! tmp___2) {
#line 376
      goto while_break;
    }
#line 378
    lineno ++;
#line 380
    if ((int )buf___0[0] == 35) {
#line 380
      goto while_continue;
    } else
#line 380
    if ((int )buf___0[0] == 10) {
#line 380
      goto while_continue;
    }
    {
#line 381
    _cp = strchr((char const   *)(buf___0), '\n');
    }
#line 381
    if (_cp) {
#line 381
      *_cp = (char )'\000';
    }
#line 384
    if (nCharMap >= n_alloc___1) {
      {
#line 385
      n_alloc___1 += 32;
#line 386
      tmp___0 = realloc((void *)CharMap, (size_t )n_alloc___1 * sizeof(Mapping_t ));
#line 386
      CharMap = (Mapping_t *)tmp___0;
      }
#line 386
      if (! CharMap) {
        {
#line 386
        perror("Realloc failed -- out of memory.  Bailing out.");
#line 386
        exit(1);
        }
      }
    }
#line 388
    val = buf___0;
#line 388
    name = val;
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 389
      if (*val) {
#line 389
        if ((int )*val == 32) {
#line 389
          goto while_break___0;
        } else
#line 389
        if ((int )*val == 9) {
#line 389
          goto while_break___0;
        }
      } else {
#line 389
        goto while_break___0;
      }
#line 389
      val ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    if (*val) {
#line 391
      tmp___1 = val;
#line 391
      val ++;
#line 391
      *tmp___1 = (char )'\000';
      {
#line 392
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 392
        if (*val) {
#line 392
          if (! ((int )*val == 32)) {
#line 392
            if (! ((int )*val == 9)) {
#line 392
              goto while_break___1;
            }
          }
        } else {
#line 392
          goto while_break___1;
        }
#line 392
        val ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 394
    if (name) {
      {
#line 395
      (CharMap + nCharMap)->name = strdup((char const   *)name);
      }
#line 396
      if (val) {
        {
#line 396
        (CharMap + nCharMap)->sval = strdup((char const   *)val);
        }
      }
#line 397
      if ((int )*((CharMap + nCharMap)->name + 0) == 92) {
#line 397
        ((CharMap + nCharMap)->name) ++;
      }
#line 398
      nCharMap ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  fclose(fp);
  }
#line 402
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/traninit.c"
void ReadSDATA(char *filename ) 
{ 
  FILE *fp ;
  char buf___0[60000] ;
  char *name ;
  char *val ;
  int lineno ;
  char *_cp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 420
  lineno = 0;
#line 422
  fp = OpenFile(filename);
  }
#line 422
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 423
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Can not open SDATA file \'%s\': ",
            filename);
#line 424
    perror((char const   *)(buf___0));
    }
#line 425
    return;
  }
#line 428
  if (! SDATAmap) {
    {
#line 428
    SDATAmap = NewMap(50);
    }
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp___0 = fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)fp);
    }
#line 430
    if (! tmp___0) {
#line 430
      goto while_break;
    }
#line 432
    lineno ++;
#line 434
    if ((int )buf___0[0] == 35) {
#line 434
      goto while_continue;
    } else
#line 434
    if ((int )buf___0[0] == 10) {
#line 434
      goto while_continue;
    }
    {
#line 435
    _cp = strchr((char const   *)(buf___0), '\n');
    }
#line 435
    if (_cp) {
#line 435
      *_cp = (char )'\000';
    }
#line 437
    val = buf___0;
#line 437
    name = val;
    {
#line 438
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 438
      if (*val) {
#line 438
        if (! ((int )*val != 9)) {
#line 438
          goto while_break___0;
        }
      } else {
#line 438
        goto while_break___0;
      }
#line 438
      val ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    if (*val) {
#line 440
      tmp = val;
#line 440
      val ++;
#line 440
      *tmp = (char )'\000';
      {
#line 441
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 441
        if (*val) {
#line 441
          if (! ((int )*val == 9)) {
#line 441
            goto while_break___1;
          }
        } else {
#line 441
          goto while_break___1;
        }
#line 441
        val ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 444
    SetMappingNV(SDATAmap, name, val);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 446
  fclose(fp);
  }
#line 447
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regerror.c"
void tpt_regerror(char *s ) 
{ 


  {
  {
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tpt_regexp(3): %s",
          s);
#line 11
  exit(1);
  }
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static short tblcols  =    (short)0;
#line 170 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static short tblrow  =    (short)0;
#line 172 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static bool tblTGroupSeen  =    (bool )0;
#line 174 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static char *tblFrame  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static bool tblgcolsep  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static bool tblgrowsep  ;
#line 178 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int tblBOFTCount  =    0;
#line 180 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
int BOFTTextThresh  =    35;
#line 184 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static bool tblinBOFT  =    (bool )0;
#line 186 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *formP  =    (struct tblformat *)0;
#line 188 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblcolspec *tblColSpec  =    (struct tblcolspec *)0;
#line 189 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblspanspec *tblSpanSpec  =    (struct tblspanspec *)0;
#line 209 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int rowsep  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int siderules  ;
#line 210 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int frametop  ;
#line 210 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int framebot  ;
#line 212 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static int spaninfo[100]  ;
#line 213 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static TableInfo TheTab  ;
#line 216
void SetTabAtts(Element_t *e , TableInfo *t , int set_globals ) ;
#line 217
void FreeTabAtts(TableInfo *t ) ;
#line 218
void ClearTable(TableInfo *t ) ;
#line 219
void CheckTable(Element_t *e ) ;
#line 220
void TblTStart(Element_t *ep , FILE *fP ) ;
#line 221
void TblTEnd(Element_t *ep , FILE *fP ) ;
#line 222
void TblTGroup(Element_t *ep , FILE *fP ) ;
#line 223
void TblTGroupEnd(Element_t *ep , FILE *fP ) ;
#line 224
void TblTFoot(Element_t *ep , FILE *fP ) ;
#line 225
void TblBuildFormat(Element_t *ep , struct tblformat **fp , tblsource source ) ;
#line 226
struct tblformat *TblBuild1Format(Element_t *rp , bool addinRowsep , tblsource source ) ;
#line 227
char TblGetAlign(short col , Element_t *entry , tblsource source ) ;
#line 228
char *TblGetWidth(short col , Element_t *entry , bool literal , tblsource source ) ;
#line 229
char *TblGetFont(short col , Element_t *entry , tblsource source ) ;
#line 230
bool TblGetColSep(short col , Element_t *entry , tblsource source ) ;
#line 231
bool TblGetRowSep(short col , Element_t *entry , tblsource source ) ;
#line 232
short TblGetMoreRows(short col , Element_t *entry , tblsource source ) ;
#line 233
bool TblColAdv(short col , Element_t *ep , struct tblformat *tfp___2 , tblsource source ) ;
#line 234
struct tblcolspec *TblEntryColSpec(short num , Element_t *ep , tblsource source ) ;
#line 235
struct tblspanspec *TblEntrySpanSpec(short num , Element_t *ep , tblsource source ) ;
#line 236
bool TblFormatMatch(struct tblformat *tf1 , struct tblformat *tf2 ) ;
#line 237
void TblPrintFormat(FILE *fP , struct tblformat *tfp___2 ) ;
#line 238
void TblTRowStart(Element_t *ep , FILE *fP ) ;
#line 239
void TblTRowEnd(Element_t *ep , FILE *fP ) ;
#line 240
void TblTCellStart(Element_t *ep , FILE *fP ) ;
#line 241
int TblCountContent(Element_t *ep ) ;
#line 242
void TblTCellEnd(Element_t *ep , FILE *fP ) ;
#line 243
struct tblcolspec *TblDoColSpec(short number , Element_t *ep , struct tblcolspec *pcsp ,
                                tblsource source ) ;
#line 244
struct tblspanspec *TblDoSpanSpec(Element_t *ep , struct tblspanspec *pssp , tblsource source ) ;
#line 245
struct tblcolspec *TblFindColSpec(char *name , tblsource source ) ;
#line 246
struct tblcolspec *TblFindColNum(short number , tblsource source ) ;
#line 247
struct tblspanspec *TblFindSpanSpec(char *name , tblsource source ) ;
#line 248
void TexTable(Element_t *e , FILE *fp ) ;
#line 249
void TexTableCellStart(Element_t *e , FILE *fp ) ;
#line 250
void TexTableCellEnd(Element_t *e , FILE *fp ) ;
#line 251
void TexTableRowStart(Element_t *e , FILE *fp ) ;
#line 252
void TexTableRowEnd(Element_t *e , FILE *fp ) ;
#line 253
void TexTableTop(Element_t *e , FILE *fp ) ;
#line 254
void TexTableBottom(Element_t *e , FILE *fp ) ;
#line 357 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void CALStable(Element_t *e , FILE *fp , char **av , int ac ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 367
  tmp___17 = strcmp((char const   *)*(av + 1), "tbl");
  }
#line 367
  if (tmp___17) {
    {
#line 387
    tmp___16 = strcmp((char const   *)*(av + 1), "tex");
    }
#line 387
    if (tmp___16) {
      {
#line 407
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown table type: %s\n",
              *(av + 1));
      }
    } else {
#line 389
      if (ac > 1) {
        {
#line 389
        tmp___9 = strcmp((char const   *)*(av + 1), "check");
        }
#line 389
        if (tmp___9) {
#line 389
          goto _L;
        } else {
          {
#line 389
          CheckTable(e);
          }
        }
      } else
      _L: /* CIL Label */ 
#line 392
      if (ac > 1) {
        {
#line 392
        tmp___8 = strcmp((char const   *)*(av + 1), "clear");
        }
#line 392
        if (! tmp___8) {
          {
#line 392
          ClearTable(& TheTab);
          }
        }
      }
#line 394
      if (ac > 2) {
        {
#line 395
        tmp___15 = strcmp((char const   *)*(av + 2), "cellstart");
        }
#line 395
        if (tmp___15) {
          {
#line 396
          tmp___14 = strcmp((char const   *)*(av + 2), "cellend");
          }
#line 396
          if (tmp___14) {
            {
#line 397
            tmp___13 = strcmp((char const   *)*(av + 2), "rowstart");
            }
#line 397
            if (tmp___13) {
              {
#line 398
              tmp___12 = strcmp((char const   *)*(av + 2), "rowend");
              }
#line 398
              if (tmp___12) {
                {
#line 399
                tmp___11 = strcmp((char const   *)*(av + 2), "top");
                }
#line 399
                if (tmp___11) {
                  {
#line 400
                  tmp___10 = strcmp((char const   *)*(av + 2), "bottom");
                  }
#line 400
                  if (tmp___10) {
                    {
#line 401
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown %s table instruction: %s\n",
                            *(av + 1), *(av + 2));
                    }
                  } else {
                    {
#line 400
                    TexTableBottom(e, fp);
                    }
                  }
                } else {
                  {
#line 399
                  TexTableTop(e, fp);
                  }
                }
              } else {
                {
#line 398
                TexTableRowEnd(e, fp);
                }
              }
            } else {
              {
#line 397
              TexTableRowStart(e, fp);
              }
            }
          } else {
            {
#line 396
            TexTableCellEnd(e, fp);
            }
          }
        } else {
          {
#line 395
          TexTableCellStart(e, fp);
          }
        }
      } else {
        {
#line 404
        TexTable(e, fp);
        }
      }
    }
  } else
#line 369
  if (ac > 2) {
    {
#line 370
    tmp___7 = strcmp((char const   *)*(av + 2), "tablestart");
    }
#line 370
    if (tmp___7) {
      {
#line 371
      tmp___6 = strcmp((char const   *)*(av + 2), "tableend");
      }
#line 371
      if (tmp___6) {
        {
#line 372
        tmp___5 = strcmp((char const   *)*(av + 2), "tablegroup");
        }
#line 372
        if (tmp___5) {
          {
#line 373
          tmp___4 = strcmp((char const   *)*(av + 2), "tablegroupend");
          }
#line 373
          if (tmp___4) {
            {
#line 374
            tmp___3 = strcmp((char const   *)*(av + 2), "tablefoot");
            }
#line 374
            if (tmp___3) {
              {
#line 375
              tmp___2 = strcmp((char const   *)*(av + 2), "rowstart");
              }
#line 375
              if (tmp___2) {
                {
#line 376
                tmp___1 = strcmp((char const   *)*(av + 2), "rowend");
                }
#line 376
                if (tmp___1) {
                  {
#line 377
                  tmp___0 = strcmp((char const   *)*(av + 2), "entrystart");
                  }
#line 377
                  if (tmp___0) {
                    {
#line 378
                    tmp = strcmp((char const   *)*(av + 2), "entryend");
                    }
#line 378
                    if (tmp) {
                      {
#line 379
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown %s table instruction: %s\n",
                              *(av + 1), *(av + 2));
                      }
                    } else {
                      {
#line 378
                      TblTCellEnd(e, fp);
                      }
                    }
                  } else {
                    {
#line 377
                    TblTCellStart(e, fp);
                    }
                  }
                } else {
                  {
#line 376
                  TblTRowEnd(e, fp);
                  }
                }
              } else {
                {
#line 375
                TblTRowStart(e, fp);
                }
              }
            } else {
              {
#line 374
              TblTFoot(e, fp);
              }
            }
          } else {
            {
#line 373
            TblTGroupEnd(e, fp);
            }
          }
        } else {
          {
#line 372
          TblTGroup(e, fp);
          }
        }
      } else {
        {
#line 371
        TblTEnd(e, fp);
        }
      }
    } else {
      {
#line 370
      TblTStart(e, fp);
      }
    }
  } else {
    {
#line 383
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incomplete %s table instruction\n");
    }
  }
#line 409
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void ClearTable(TableInfo *t ) 
{ 


  {
  {
#line 419
  memset((void *)t, 0, sizeof(TableInfo ));
  }
#line 420
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void SetTabAtts(Element_t *e , TableInfo *t , int set_globals ) 
{ 
  char *at ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 443
  at = FindAttValByName(e, (char *)"ALIGN");
  }
#line 443
  if (at) {
#line 443
    t->align = at;
  }
  {
#line 444
  at = FindAttValByName(e, (char *)"COLWIDTH");
  }
#line 444
  if (at) {
#line 444
    t->colwidth = at;
  }
  {
#line 445
  at = FindAttValByName(e, (char *)"COLSEP");
  }
#line 445
  if (at) {
#line 445
    t->colsep = at;
  }
  {
#line 446
  at = FindAttValByName(e, (char *)"FRAME");
  }
#line 446
  if (at) {
#line 446
    t->frame = at;
  }
  {
#line 447
  at = FindAttValByName(e, (char *)"COLS");
  }
#line 447
  if (at) {
#line 447
    t->cols = at;
  }
#line 450
  if (set_globals) {
    {
#line 452
    rowsep = 1;
#line 453
    framebot = 1;
#line 453
    frametop = framebot;
#line 458
    at = FindAttValByName(e, (char *)"ROWSEP");
    }
#line 458
    if (at) {
      {
#line 458
      rowsep = atoi((char const   *)at);
      }
    }
  }
#line 461
  if (t->frame) {
    {
#line 463
    tmp___1 = strcmp((char const   *)t->frame, "NONE");
    }
#line 463
    if (tmp___1) {
      {
#line 463
      tmp___2 = strcmp((char const   *)t->frame, "SIDES");
      }
#line 463
      if (tmp___2) {
        {
#line 465
        tmp___0 = strcmp((char const   *)t->frame, "TOP");
        }
#line 465
        if (tmp___0) {
          {
#line 466
          tmp = strcmp((char const   *)t->frame, "BOTTOM");
          }
#line 466
          if (! tmp) {
#line 466
            frametop = 0;
          }
        } else {
#line 465
          framebot = 0;
        }
      } else {
#line 464
        framebot = 0;
#line 464
        frametop = framebot;
      }
    } else {
#line 464
      framebot = 0;
#line 464
      frametop = framebot;
    }
  }
#line 470
  if (t->colwidth) {
#line 472
    cp = t->colwidth;
    {
#line 472
    while (1) {
      while_continue: /* CIL Label */ ;
#line 472
      if (! *cp) {
#line 472
        goto while_break;
      }
      {
#line 473
      tmp___4 = __ctype_b_loc();
      }
#line 473
      if ((int const   )*(*tmp___4 + (int )*cp) & 256) {
        {
#line 473
        tmp___3 = tolower((int )*cp);
#line 473
        *cp = (char )tmp___3;
        }
      }
#line 472
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 479
  t->align_v = Split(t->align, & t->n_align, 3);
#line 480
  t->colwidth_v = Split(t->colwidth, & t->n_colwidth, 3);
#line 481
  t->colsep_v = Split(t->colsep, & t->n_colsep, 3);
  }
#line 486
  if (t->cols) {
    {
#line 486
    t->nc = atoi((char const   *)t->cols);
    }
  }
#line 487
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void FreeTabAtts(TableInfo *t ) 
{ 


  {
#line 501
  if (! t) {
#line 501
    return;
  }
#line 502
  if (t->align_v) {
    {
#line 502
    free((void *)*(t->align_v));
    }
  }
#line 503
  if (t->colwidth_v) {
    {
#line 503
    free((void *)*(t->colwidth_v));
    }
  }
#line 504
  if (t->colsep_v) {
    {
#line 504
    free((void *)*(t->colsep_v));
    }
  }
#line 505
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void CheckTable(Element_t *e ) 
{ 
  int pr_loc ;
  int i ;
  char *tpref ;
  char *ncolchk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 519
  pr_loc = 0;
#line 523
  tpref = (char *)"Table Check";
#line 524
  ncolchk = (char *)"Table Check: %s (\'%s\') has wrong number of tokens.  Expecting %d.\n";
#line 527
  tmp = strcmp((char const   *)e->gi, "TABLE");
  }
#line 527
  if (tmp) {
    {
#line 527
    tmp___0 = strcmp((char const   *)e->gi, "INFORMALTABLE");
    }
#line 527
    if (tmp___0) {
      {
#line 527
      tmp___1 = strcmp((char const   *)e->gi, "TGROUP");
      }
#line 527
      if (tmp___1) {
        {
#line 527
        tmp___2 = strcmp((char const   *)e->gi, "COLSPEC");
        }
#line 527
        if (tmp___2) {
          {
#line 527
          tmp___3 = strcmp((char const   *)e->gi, "ROW");
          }
#line 527
          if (tmp___3) {
            {
#line 532
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Not pointing to a table element(%s)!\n",
                    tpref, e->gi);
            }
#line 534
            return;
          }
        }
      }
    }
  }
  {
#line 537
  FreeTabAtts(& TheTab);
#line 538
  SetTabAtts(e, & TheTab, 1);
  }
#line 572
  if (TheTab.align) {
#line 573
    if (TheTab.nc != TheTab.n_align) {
      {
#line 574
      pr_loc ++;
#line 575
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)ncolchk,
              "ALIGN", TheTab.align, TheTab.nc);
      }
    } else {
#line 578
      i = 0;
      {
#line 578
      while (1) {
        while_continue: /* CIL Label */ ;
#line 578
        if (! (i < TheTab.nc)) {
#line 578
          goto while_break;
        }
#line 579
        if ((int )*(*(TheTab.align_v + i)) != 67) {
#line 579
          if ((int )*(*(TheTab.align_v + i)) != 76) {
#line 579
            if ((int )*(*(TheTab.align_v + i)) != 82) {
              {
#line 581
              pr_loc ++;
#line 582
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ALIGN (%d) value wrong: %s\n",
                      tpref, i, *(TheTab.align_v + i));
              }
            }
          }
        }
#line 578
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 590
  if (TheTab.colwidth) {
#line 591
    if (TheTab.nc != TheTab.n_colwidth) {
      {
#line 592
      pr_loc ++;
#line 593
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)ncolchk,
              "COLWIDTH", TheTab.colwidth, TheTab.nc);
      }
    } else {
#line 596
      i = 0;
      {
#line 596
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 596
        if (! (i < TheTab.nc)) {
#line 596
          goto while_break___0;
        }
#line 596
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 606
  if (TheTab.colsep) {
#line 607
    if (TheTab.nc != TheTab.n_colsep) {
      {
#line 608
      pr_loc ++;
#line 609
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)ncolchk,
              "COLSEP", TheTab.colsep, TheTab.nc);
      }
    } else {
#line 612
      i = 0;
      {
#line 612
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 612
        if (! (i < TheTab.nc)) {
#line 612
          goto while_break___1;
        }
#line 612
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 617
  if (pr_loc) {
    {
#line 618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Above problem in table located at:\n",
            tpref);
#line 619
    PrintLocation(e, stderr);
    }
  }
#line 621
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
int check_for_spans(Element_t *e ) 
{ 
  int i ;

  {
#line 677
  i = 0;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (i < 100)) {
#line 677
      goto while_break;
    }
#line 677
    spaninfo[i] = 0;
#line 677
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return (0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTable(Element_t *e , FILE *fp ) 
{ 
  int i ;
  char **widths ;
  char **widths_v ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 696
  widths = (char **)0;
#line 696
  widths_v = (char **)0;
#line 698
  FreeTabAtts(& TheTab);
#line 699
  SetTabAtts(e, & TheTab, 1);
#line 700
  SetTabAtts(*(e->econt + 0), & TheTab, 1);
  }
#line 704
  if (TheTab.colwidth) {
#line 704
    if (TheTab.nc == TheTab.n_colwidth) {
#line 705
      widths = TheTab.colwidth_v;
    }
  }
#line 708
  siderules = 1;
#line 709
  if (TheTab.frame) {
    {
#line 710
    tmp = strcmp((char const   *)TheTab.frame, "ALL");
    }
#line 710
    if (tmp) {
      {
#line 710
      tmp___0 = strcmp((char const   *)TheTab.frame, "SIDES");
      }
#line 710
      if (tmp___0) {
#line 711
        siderules = 0;
      }
    }
  }
#line 713
  if (siderules) {
    {
#line 713
    OutputString((char *)"|", fp, 1);
    }
  }
#line 714
  i = 0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i < TheTab.nc)) {
#line 714
      goto while_break;
    }
#line 716
    if (widths) {
#line 716
      if ((int )*(*(widths + i) + 0) != 48) {
#line 716
        if ((int )*(*(widths + i) + 1) != 0) {
#line 717
          if (i) {
#line 717
            tmp___1 = " ";
          } else {
#line 717
            tmp___1 = "";
          }
          {
#line 717
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%sp{%s}",
                  tmp___1, *(widths + i));
          }
        } else {
#line 716
          goto _L___1;
        }
      } else {
#line 716
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 719
    if (TheTab.align) {
#line 719
      if (TheTab.nc == TheTab.n_align) {
#line 720
        if (i) {
#line 720
          tmp___2 = " ";
        } else {
#line 720
          tmp___2 = "";
        }
        {
#line 720
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s",
                tmp___2, *(TheTab.align_v + i));
        }
      } else {
#line 719
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 723
      if (i) {
#line 723
        tmp___3 = " ";
      } else {
#line 723
        tmp___3 = "";
      }
      {
#line 723
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%sl",
              tmp___3);
      }
    }
#line 725
    if (TheTab.colsep) {
#line 727
      if (i + 1 < TheTab.nc) {
#line 728
        if ((int )*(*(TheTab.colsep_v + i)) == 49) {
          {
#line 729
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" |");
          }
        }
#line 731
        if ((int )*(*(TheTab.colsep_v + i)) == 50) {
          {
#line 732
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ||");
          }
        }
      }
    }
#line 714
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  if (siderules) {
    {
#line 738
    OutputString((char *)"|", fp, 1);
    }
  }
#line 740
  if (widths_v) {
    {
#line 740
    free((void *)widths_v);
    }
  }
#line 741
  return;
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableCellStart(Element_t *e , FILE *fp ) 
{ 
  int n ;
  int i ;
  char buf___0[50] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 757
  if (spaninfo[e->my_eorder] == 1) {
#line 758
    i = e->my_eorder + 1;
#line 758
    n = 1;
    {
#line 758
    while (1) {
      while_continue: /* CIL Label */ ;
#line 759
      if (spaninfo[i] == 2) {
#line 759
        n ++;
      } else {
#line 760
        goto while_break;
      }
#line 758
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 762
    if (siderules) {
#line 762
      tmp = "|";
    } else {
#line 762
      tmp = "";
    }
#line 762
    if (siderules) {
#line 762
      tmp___0 = "|";
    } else {
#line 762
      tmp___0 = "";
    }
    {
#line 762
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"\\\\multicolumn{%d}{%sc%s}",
            n, tmp___0, tmp);
#line 764
    OutputString(buf___0, fp, 1);
    }
  }
#line 775
  if (spaninfo[e->my_eorder] != 2) {
    {
#line 775
    OutputString((char *)"{", fp, 1);
    }
  }
#line 776
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableCellEnd(Element_t *e , FILE *fp ) 
{ 


  {
#line 789
  if (spaninfo[e->my_eorder] != 2) {
    {
#line 789
    OutputString((char *)"} ", fp, 1);
    }
  }
#line 792
  if (e->my_eorder < TheTab.nc - 1) {
#line 793
    if (spaninfo[e->my_eorder] == 0) {
      {
#line 795
      OutputString((char *)"& ", fp, 1);
      }
    } else
#line 793
    if (spaninfo[e->my_eorder + 1] != 2) {
      {
#line 795
      OutputString((char *)"& ", fp, 1);
      }
    }
  }
#line 797
  return;
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableRowStart(Element_t *e , FILE *fp ) 
{ 


  {
  {
#line 810
  check_for_spans(e);
  }
#line 811
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableRowEnd(Element_t *e , FILE *fp ) 
{ 
  char *at ;

  {
  {
#line 827
  at = FindAttValByName(e, (char *)"ROWSEP");
  }
#line 827
  if (at) {
#line 828
    if ((int )*(at + 0) == 49) {
      {
#line 828
      OutputString((char *)"\\\\\\\\[2mm] \\\\hline ", fp, 1);
      }
    }
  } else
#line 830
  if (rowsep) {
    {
#line 830
    OutputString((char *)"\\\\\\\\ ", fp, 1);
    }
  } else {
    {
#line 832
    OutputString((char *)"\\\\\\\\ ", fp, 1);
    }
  }
#line 834
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableTop(Element_t *e , FILE *fp ) 
{ 


  {
#line 844
  if (frametop) {
    {
#line 844
    OutputString((char *)"\\\\hline", fp, 1);
    }
  }
#line 845
  return;
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TexTableBottom(Element_t *e , FILE *fp ) 
{ 


  {
#line 850
  if (framebot) {
    {
#line 850
    OutputString((char *)"\\\\hline", fp, 1);
    }
  }
#line 851
  return;
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTStart(Element_t *ep , FILE *fP ) 
{ 
  register char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 887
  OutputString((char *)"^.TS^", fP, 1);
#line 889
  tblTGroupSeen = (bool )0;
#line 890
  tblinBOFT = (bool )0;
#line 891
  tblBOFTCount = 0;
#line 894
  cp = FindAttValByName(ep, (char *)"COLSEP");
  }
#line 894
  if (cp) {
    {
#line 894
    tmp = strcmp((char const   *)cp, "1");
    }
#line 894
    if (tmp) {
#line 894
      tmp___0 = 0;
    } else {
#line 894
      tmp___0 = 1;
    }
  } else {
#line 894
    tmp___0 = 0;
  }
  {
#line 894
  tblgcolsep = (bool )tmp___0;
#line 895
  cp = FindAttValByName(ep, (char *)"ROWSEP");
  }
#line 895
  if (cp) {
    {
#line 895
    tmp___1 = strcmp((char const   *)cp, "1");
    }
#line 895
    if (tmp___1) {
#line 895
      tmp___2 = 0;
    } else {
#line 895
      tmp___2 = 1;
    }
  } else {
#line 895
    tmp___2 = 0;
  }
#line 895
  tblgrowsep = (bool )tmp___2;
#line 896
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTEnd(Element_t *ep , FILE *fP ) 
{ 
  register struct tblformat *ffp ;
  register struct tblformat *ffp2 ;

  {
#line 916
  if (tblBOFTCount > 31) {
    {
#line 917
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# warning, line %d: created %d blocks of filled text in one table\n",
            ep->lineno, tblBOFTCount);
#line 919
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#\t\t(31 is the limit in some systems)\n");
    }
  }
  {
#line 922
  OutputString((char *)"^.TE^", fP, 1);
#line 924
  ffp = formP;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ffp) {
#line 924
      goto while_break;
    }
    {
#line 925
    ffp2 = ffp->next;
#line 926
    free((void *)ffp);
#line 924
    ffp = ffp2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  formP = (struct tblformat *)0;
#line 929
  return;
}
}
#line 952 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTGroup(Element_t *ep , FILE *fP ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register char *cp ;
  register Element_t *ep2 ;
  register struct tblcolspec *tcsp ;
  register struct tblcolspec *tcsp2 ;
  register struct tblspanspec *tssp ;
  register struct tblspanspec *tssp2 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 963
  tblColSpec = (struct tblcolspec *)0;
#line 964
  tblSpanSpec = (struct tblspanspec *)0;
#line 968
  tmp = FindAttValByName(ep, (char *)"COLS");
#line 968
  tmp___0 = atoi((char const   *)tmp);
#line 968
  tblcols = (short )tmp___0;
#line 972
  tcsp = TblDoColSpec((short)0, ep, (struct tblcolspec *)0, (tblsource )0);
#line 972
  tblColSpec = tcsp;
#line 975
  i = 0;
#line 975
  k = 1;
  }
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 975
    if (! (i < ep->necont)) {
#line 975
      goto while_break;
    }
    {
#line 977
    tmp___1 = strcmp((char const   *)(*(ep->econt + i))->gi, "COLSPEC");
    }
#line 977
    if (! tmp___1) {
      {
#line 978
      tcsp2 = TblDoColSpec((short )k, *(ep->econt + i), tblColSpec, (tblsource )0);
#line 979
      tcsp->next = tcsp2;
#line 980
      tcsp = tcsp2;
#line 981
      k = (int )tcsp2->num + 1;
      }
    }
    {
#line 984
    tmp___3 = strcmp((char const   *)(*(ep->econt + i))->gi, "THEAD");
    }
#line 984
    if (! tmp___3) {
#line 985
      ep2 = *(ep->econt + i);
#line 986
      j = 0;
#line 986
      k = 1;
      {
#line 986
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 986
        if (! (j < ep2->necont)) {
#line 986
          goto while_break___0;
        }
        {
#line 987
        tmp___2 = strcmp((char const   *)(*(ep2->econt + j))->gi, "COLSPEC");
        }
#line 987
        if (! tmp___2) {
          {
#line 988
          tcsp2 = TblDoColSpec((short )k, *(ep2->econt + j), tblColSpec, (tblsource )1);
#line 989
          tcsp->next = tcsp2;
#line 990
          tcsp = tcsp2;
#line 991
          k = (int )tcsp2->num + 1;
          }
        }
#line 986
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 996
    tmp___5 = strcmp((char const   *)(*(ep->econt + i))->gi, "TFOOT");
    }
#line 996
    if (! tmp___5) {
#line 997
      ep2 = *(ep->econt + i);
#line 998
      j = 0;
#line 998
      k = 1;
      {
#line 998
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 998
        if (! (j < ep2->necont)) {
#line 998
          goto while_break___1;
        }
        {
#line 999
        tmp___4 = strcmp((char const   *)(*(ep2->econt + j))->gi, "COLSPEC");
        }
#line 999
        if (! tmp___4) {
          {
#line 1000
          tcsp2 = TblDoColSpec((short )k, *(ep2->econt + j), tblColSpec, (tblsource )2);
#line 1001
          tcsp->next = tcsp2;
#line 1002
          tcsp = tcsp2;
#line 1003
          k = (int )tcsp2->num + 1;
          }
        }
#line 998
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1008
    tmp___7 = strcmp((char const   *)(*(ep->econt + i))->gi, "TBODY");
    }
#line 1008
    if (! tmp___7) {
#line 1009
      ep2 = *(ep->econt + i);
#line 1010
      j = 0;
#line 1010
      k = 1;
      {
#line 1010
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1010
        if (! (j < ep2->necont)) {
#line 1010
          goto while_break___2;
        }
        {
#line 1011
        tmp___6 = strcmp((char const   *)(*(ep2->econt + j))->gi, "COLSPEC");
        }
#line 1011
        if (! tmp___6) {
          {
#line 1012
          tcsp2 = TblDoColSpec((short )k, *(ep2->econt + j), tblColSpec, (tblsource )3);
#line 1013
          tcsp->next = tcsp2;
#line 1014
          tcsp = tcsp2;
#line 1015
          k = (int )tcsp2->num + 1;
          }
        }
#line 1010
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 975
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1023
  tssp = TblDoSpanSpec(ep, (struct tblspanspec *)0, (tblsource )0);
#line 1023
  tblSpanSpec = tssp;
#line 1026
  i = 0;
  }
  {
#line 1026
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1026
    if (! (i < ep->necont)) {
#line 1026
      goto while_break___3;
    }
    {
#line 1027
    tmp___8 = strcmp((char const   *)(*(ep->econt + i))->gi, "SPANSPEC");
    }
#line 1027
    if (! tmp___8) {
      {
#line 1028
      tssp2 = TblDoSpanSpec(*(ep->econt + i), tblSpanSpec, (tblsource )0);
#line 1029
      tssp->next = tssp2;
#line 1030
      tssp = tssp2;
      }
    }
#line 1026
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1037
  if (! tblTGroupSeen) {
    {
#line 1039
    OutputString((char *)"tab(\a)", fP, 1);
#line 1041
    ep2 = ep->parent;
#line 1042
    tblFrame = FindAttValByName(ep2, (char *)"FRAME");
    }
#line 1042
    if (! tblFrame) {
#line 1043
      tblFrame = (char *)"";
    }
    {
#line 1045
    tmp___9 = strcmp((char const   *)tblFrame, "ALL");
    }
#line 1045
    if (! tmp___9) {
#line 1046
      if (tcsp->colsep) {
#line 1046
        if (tcsp->rowsep) {
          {
#line 1047
          OutputString((char *)" allbox", fP, 1);
          }
        } else {
          {
#line 1049
          OutputString((char *)" box", fP, 1);
          }
        }
      } else {
        {
#line 1049
        OutputString((char *)" box", fP, 1);
        }
      }
    }
    {
#line 1052
    cp = FindAttValByName(ep, (char *)"ALIGN");
    }
#line 1052
    if (cp) {
      {
#line 1052
      tmp___10 = strcmp((char const   *)cp, "CENTER");
      }
#line 1052
      if (! tmp___10) {
        {
#line 1054
        OutputString((char *)" center", fP, 1);
        }
      }
    }
    {
#line 1057
    OutputString((char *)";\n", fP, 1);
#line 1059
    tblTGroupSeen = (bool )1;
    }
  }
#line 1068
  i = 0;
  {
#line 1068
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1068
    if (! (i < ep->necont)) {
#line 1068
      goto while_break___4;
    }
    {
#line 1069
    tmp___11 = strcmp((char const   *)(*(ep->econt + i))->gi, "THEAD");
    }
#line 1069
    if (! tmp___11) {
      {
#line 1070
      TblBuildFormat(*(ep->econt + i), & formP, (tblsource )1);
      }
#line 1072
      goto while_break___4;
    }
#line 1068
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1076
  i = 0;
  {
#line 1076
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1076
    if (! (i < ep->necont)) {
#line 1076
      goto while_break___5;
    }
    {
#line 1077
    tmp___12 = strcmp((char const   *)(*(ep->econt + i))->gi, "TBODY");
    }
#line 1077
    if (! tmp___12) {
      {
#line 1078
      TblBuildFormat(*(ep->econt + i), & formP, (tblsource )3);
      }
#line 1080
      goto while_break___5;
    }
#line 1076
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1084
  TblPrintFormat(fP, formP);
#line 1086
  tblrow = (short)0;
  }
#line 1087
  return;
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp  ;
#line 1111 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp2  ;
#line 1104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTGroupEnd(Element_t *ep , FILE *fP ) 
{ 
  register struct tblcolspec *tcsp ;
  register struct tblcolspec *tcsp2 ;
  register struct tblspanspec *tssp ;
  register struct tblspanspec *tssp2 ;
  register struct tblformat *ffp ;
  register struct tblformat *ffp2 ;
  bool tmp ;

  {
  {
#line 1113
  tfp = TblBuild1Format(ep, (bool )0, (tblsource )0);
#line 1115
  tfp2 = formP;
  }
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1115
    if (tfp2) {
#line 1115
      if (! tfp2->next) {
#line 1115
        goto while_break;
      }
    } else {
#line 1115
      goto while_break;
    }
#line 1115
    tfp2 = tfp2->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1118
  tmp = TblFormatMatch(tfp, tfp2);
  }
#line 1118
  if (! tmp) {
#line 1120
    ffp = formP;
    {
#line 1120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1120
      if (! ffp) {
#line 1120
        goto while_break___0;
      }
      {
#line 1121
      ffp2 = ffp->next;
#line 1122
      free((void *)ffp);
#line 1120
      ffp = ffp2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1125
    formP = tfp;
#line 1127
    OutputString((char *)"^.T&^", fP, 1);
#line 1128
    TblPrintFormat(fP, formP);
    }
  }
#line 1132
  tcsp = tblColSpec;
  {
#line 1132
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1132
    if (! tcsp) {
#line 1132
      goto while_break___1;
    }
    {
#line 1133
    tcsp2 = tcsp->next;
#line 1134
    free((void *)tcsp);
#line 1132
    tcsp = tcsp2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1136
  tssp = tblSpanSpec;
  {
#line 1136
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1136
    if (! tssp) {
#line 1136
      goto while_break___2;
    }
    {
#line 1137
    tssp2 = tssp->next;
#line 1138
    free((void *)tssp);
#line 1136
    tssp = tssp2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1140
  return;
}
}
#line 1160 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp___0  ;
#line 1160 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp2___0  ;
#line 1155 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTFoot(Element_t *ep , FILE *fP ) 
{ 
  register struct tblformat *ffp ;
  register struct tblformat *ffp2 ;
  bool tmp ;

  {
  {
#line 1163
  TblBuildFormat(ep, & tfp___0, (tblsource )2);
#line 1165
  tfp2___0 = formP;
  }
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (tfp2___0) {
#line 1165
      if (! tfp2___0->next) {
#line 1165
        goto while_break;
      }
    } else {
#line 1165
      goto while_break;
    }
#line 1165
    tfp2___0 = tfp2___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  if (tfp___0->next) {
#line 1168
    goto _L;
  } else {
    {
#line 1168
    tmp = TblFormatMatch(tfp___0, tfp2___0);
    }
#line 1168
    if (! tmp) {
      _L: /* CIL Label */ 
#line 1170
      ffp = formP;
      {
#line 1170
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1170
        if (! ffp) {
#line 1170
          goto while_break___0;
        }
        {
#line 1171
        ffp2 = ffp->next;
#line 1172
        free((void *)ffp);
#line 1170
        ffp = ffp2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1175
      formP = tfp___0;
#line 1177
      OutputString((char *)"^.T&^", fP, 1);
#line 1178
      TblPrintFormat(fP, formP);
      }
    }
  }
#line 1181
  tblrow = (short)0;
#line 1182
  return;
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblBuildFormat(Element_t *ep , struct tblformat **fp , tblsource source ) 
{ 
  register int i ;
  register struct tblformat *lfp ;
  register struct tblformat *nfp ;
  int tmp ;
  struct tblformat *tmp___0 ;
  bool tmp___1 ;

  {
#line 1201
  lfp = *fp;
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1201
    if (lfp) {
#line 1201
      if (! lfp->next) {
#line 1201
        goto while_break;
      }
    } else {
#line 1201
      goto while_break;
    }
#line 1201
    lfp = lfp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  i = 0;
  {
#line 1204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1204
    if (! (i < ep->necont)) {
#line 1204
      goto while_break___0;
    }
    {
#line 1205
    tmp = strcmp((char const   *)(*(ep->econt + i))->gi, "ROW");
    }
#line 1205
    if (! tmp) {
#line 1206
      goto while_break___0;
    }
#line 1204
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1208
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1208
    if (! (i < ep->necont)) {
#line 1208
      goto while_break___1;
    }
    {
#line 1210
    nfp = TblBuild1Format(*(ep->econt + i), (bool )0, source);
    }
#line 1213
    if (! lfp) {
#line 1214
      tmp___0 = nfp;
#line 1214
      *fp = tmp___0;
#line 1214
      lfp = tmp___0;
    } else {
      {
#line 1216
      tmp___1 = TblFormatMatch(lfp, nfp);
      }
#line 1216
      if (tmp___1) {
#line 1217
        lfp->count = (short )((int )lfp->count + 1);
      } else {
#line 1219
        lfp->count = (short)1;
#line 1220
        lfp->next = nfp;
#line 1221
        lfp = nfp;
      }
    }
#line 1208
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1224
  return;
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblformat *TblBuild1Format(Element_t *rp , bool addinRowsep , tblsource source ) 
{ 
  register int i ;
  register int j ;
  register bool allProp ;
  float totalProp ;
  register struct tblformat *tfp___2 ;
  register Element_t *ep ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char *tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  double tmp___13 ;

  {
  {
#line 1251
  tmp = calloc((size_t )1, sizeof(struct tblformat ));
#line 1251
  tfp___2 = (struct tblformat *)tmp;
  }
#line 1251
  if (! tfp___2) {
    {
#line 1251
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 1251
    exit(1);
    }
  }
  {
#line 1251
  memset((void *)tfp___2, 0, sizeof(struct tblformat ));
#line 1252
  tfp___2->cols = tblcols;
  }
#line 1253
  if (rp->necont) {
#line 1253
    ep = *(rp->econt + 0);
  } else {
#line 1253
    ep = (Element_t *)0;
  }
#line 1254
  allProp = (bool )1;
#line 1255
  totalProp = (float )0;
#line 1257
  i = 1;
  {
#line 1257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1257
    if (! (i <= (int )tblcols)) {
#line 1257
      goto while_break;
    }
    {
#line 1258
    tfp___2->colformat[i] = TblGetAlign((short )i, ep, source);
#line 1259
    tmp___0 = TblGetWidth((short )i, ep, (bool )1, source);
#line 1259
    strcpy((char */* __restrict  */)(tfp___2->colwidth[i]), (char const   */* __restrict  */)tmp___0);
#line 1260
    tmp___1 = TblGetWidth((short )i, ep, (bool )0, source);
#line 1260
    strcpy((char */* __restrict  */)(tfp___2->colpwidth[i]), (char const   */* __restrict  */)tmp___1);
    }
#line 1261
    if (allProp) {
      {
#line 1262
      allProp = (bool )tfp___2->colpwidth[i][0];
#line 1263
      tmp___2 = atof((char const   *)(tfp___2->colpwidth[i]));
#line 1263
      totalProp = (float )((double )totalProp + tmp___2);
      }
    }
#line 1265
    if (i > 1) {
#line 1265
      if ((int )tfp___2->colformat[i] == 115) {
#line 1266
        j = i;
        {
#line 1266
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1266
          if (! (j >= 1)) {
#line 1266
            goto while_break___0;
          }
#line 1267
          if ((int )tfp___2->colformat[j] != 115) {
#line 1268
            if (tfp___2->colwidth[i][0]) {
              {
#line 1269
              tmp___3 = atof((char const   *)(tfp___2->colwidth[j]));
#line 1269
              tmp___4 = atof((char const   *)(tfp___2->colwidth[i]));
#line 1269
              sprintf((char */* __restrict  */)(tfp___2->colwidth[j]), (char const   */* __restrict  */)"%fi",
                      tmp___3 + tmp___4);
              }
            }
#line 1273
            if (tfp___2->colpwidth[i][0]) {
              {
#line 1274
              tmp___5 = atof((char const   *)(tfp___2->colpwidth[j]));
#line 1274
              tmp___6 = atof((char const   *)(tfp___2->colpwidth[i]));
#line 1274
              sprintf((char */* __restrict  */)(tfp___2->colpwidth[j]), (char const   */* __restrict  */)"%fi",
                      tmp___5 + tmp___6);
              }
            }
#line 1278
            tfp___2->colwidth[i][0] = (char )'\000';
#line 1279
            tfp___2->colpwidth[i][0] = (char )'\000';
#line 1280
            goto while_break___0;
          }
#line 1266
          j --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1283
        if (j < 1) {
          {
#line 1284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? Warning: missed earlier column to add span width to\n");
          }
        }
      }
    }
    {
#line 1288
    tmp___7 = TblGetFont((short )i, ep, source);
#line 1288
    strcpy((char */* __restrict  */)(tfp___2->font[i]), (char const   */* __restrict  */)tmp___7);
    }
#line 1289
    if (tblgcolsep) {
#line 1289
      tmp___9 = 1;
    } else {
      {
#line 1289
      tmp___8 = TblGetColSep((short )i, ep, source);
      }
#line 1289
      if (tmp___8) {
#line 1289
        tmp___9 = 1;
      } else {
#line 1289
        tmp___9 = 0;
      }
    }
#line 1289
    tfp___2->colsep[i] = (bool )tmp___9;
#line 1290
    if (addinRowsep) {
#line 1291
      if (tblgrowsep) {
#line 1291
        tmp___11 = 1;
      } else {
        {
#line 1291
        tmp___10 = TblGetRowSep((short )i, ep, source);
        }
#line 1291
        if (tmp___10) {
#line 1291
          tmp___11 = 1;
        } else {
#line 1291
          tmp___11 = 0;
        }
      }
#line 1291
      tfp___2->rowsep[i] = (bool )tmp___11;
    }
    {
#line 1292
    tfp___2->moreRows[i] = TblGetMoreRows((short )i, ep, source);
    }
#line 1294
    if (i < rp->necont) {
      {
#line 1294
      tmp___12 = TblColAdv((short )i, ep, tfp___2, source);
      }
#line 1294
      if (tmp___12) {
#line 1295
        ep = *(rp->econt + i);
      }
    }
#line 1257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  if (allProp) {
#line 1302
    i = 1;
    {
#line 1302
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1302
      if (! (i <= (int )tblcols)) {
#line 1302
        goto while_break___1;
      }
#line 1303
      if (tfp___2->colpwidth[i][0]) {
        {
#line 1304
        tmp___13 = atof((char const   *)(tfp___2->colpwidth[i]));
#line 1304
        sprintf((char */* __restrict  */)(tfp___2->colwidth[i]), (char const   */* __restrict  */)"%fi",
                (tmp___13 / (double )totalProp) * 5.5);
        }
      }
#line 1302
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1309
  return (tfp___2);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
char TblGetAlign(short col , Element_t *entry , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;
  register struct tblspanspec *tssp ;
  register tblalign talign ;

  {
#line 1327
  if (entry) {
    {
#line 1327
    tssp = TblEntrySpanSpec(col, entry, source);
    }
#line 1327
    if (tssp) {
      {
#line 1328
      talign = tssp->align;
#line 1329
      free((void *)tssp);
      }
    } else {
#line 1327
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1331
  if (entry) {
    {
#line 1331
    tcsp = TblEntryColSpec(col, entry, source);
    }
#line 1331
    if (tcsp) {
      {
#line 1332
      talign = tcsp->align;
#line 1333
      free((void *)tcsp);
      }
    } else {
#line 1335
      return ((char )'l');
    }
  } else {
#line 1335
    return ((char )'l');
  }
  {
#line 1339
  if ((unsigned int )talign == 0U) {
#line 1339
    goto case_0;
  }
#line 1340
  if ((unsigned int )talign == 1U) {
#line 1340
    goto case_1;
  }
#line 1341
  if ((unsigned int )talign == 2U) {
#line 1341
    goto case_2;
  }
#line 1342
  if ((unsigned int )talign == 3U) {
#line 1342
    goto case_3;
  }
#line 1343
  if ((unsigned int )talign == 4U) {
#line 1343
    goto case_4;
  }
#line 1344
  if ((unsigned int )talign == 5U) {
#line 1344
    goto case_5;
  }
#line 1338
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1339
  return ((char )'l');
  case_1: /* CIL Label */ 
#line 1340
  return ((char )'r');
  case_2: /* CIL Label */ 
#line 1341
  return ((char )'c');
  case_3: /* CIL Label */ 
#line 1342
  return ((char )'l');
  case_4: /* CIL Label */ 
#line 1343
  return ((char )'d');
  case_5: /* CIL Label */ 
#line 1344
  return ((char )'s');
  switch_break: /* CIL Label */ ;
  }
#line 1346
  return ((char)0);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static char colWidth[10]  ;
#line 1353 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
char *TblGetWidth(short col , Element_t *entry , bool literal , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;
  char *tmp ;

  {
#line 1364
  colWidth[0] = (char)0;
#line 1366
  if (entry) {
    {
#line 1366
    tcsp = TblEntryColSpec(col, entry, source);
    }
#line 1366
    if (tcsp) {
#line 1366
      if (tcsp->colwidth[0]) {
        {
#line 1370
        tmp = strstr((char const   *)(tcsp->colwidth), "*");
        }
#line 1370
        if (tmp) {
#line 1374
          if (! literal) {
            {
#line 1375
            strcpy((char */* __restrict  */)(colWidth), (char const   */* __restrict  */)(tcsp->colwidth));
            }
          }
        } else
#line 1371
        if (literal) {
          {
#line 1372
          strcpy((char */* __restrict  */)(colWidth), (char const   */* __restrict  */)(tcsp->colwidth));
          }
        }
        {
#line 1377
        free((void *)tcsp);
        }
      }
    }
  }
#line 1380
  return (colWidth);
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
char *TblGetFont(short col , Element_t *entry , tblsource source ) 
{ 


  {
#line 1397
  return ((char *)"");
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
bool TblGetColSep(short col , Element_t *entry , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;
  register struct tblspanspec *tssp ;
  register bool colsep ;

  {
#line 1415
  if (entry) {
    {
#line 1415
    tssp = TblEntrySpanSpec(col, entry, source);
    }
#line 1415
    if (tssp) {
      {
#line 1416
      colsep = tssp->colsep;
#line 1417
      free((void *)tssp);
      }
    } else {
#line 1415
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1419
  if (entry) {
    {
#line 1419
    tcsp = TblEntryColSpec(col, entry, source);
    }
#line 1419
    if (tcsp) {
      {
#line 1420
      colsep = tcsp->colsep;
#line 1421
      free((void *)tcsp);
      }
    } else {
#line 1423
      colsep = (bool )0;
    }
  } else {
#line 1423
    colsep = (bool )0;
  }
#line 1425
  return (colsep);
}
}
#line 1433 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
bool TblGetRowSep(short col , Element_t *entry , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;
  register struct tblspanspec *tssp ;
  register bool rowsep___0 ;

  {
#line 1442
  if (entry) {
    {
#line 1442
    tssp = TblEntrySpanSpec(col, entry, source);
    }
#line 1442
    if (tssp) {
      {
#line 1443
      rowsep___0 = tssp->rowsep;
#line 1444
      free((void *)tssp);
      }
    } else {
#line 1442
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1446
  if (entry) {
    {
#line 1446
    tcsp = TblEntryColSpec(col, entry, source);
    }
#line 1446
    if (tcsp) {
      {
#line 1447
      rowsep___0 = tcsp->rowsep;
#line 1448
      free((void *)tcsp);
      }
    } else {
#line 1450
      rowsep___0 = (bool )0;
    }
  } else {
#line 1450
    rowsep___0 = (bool )0;
  }
#line 1453
  return (rowsep___0);
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
short TblGetMoreRows(short col , Element_t *entry , tblsource source ) 
{ 
  register char *cp ;
  int tmp ;

  {
  {
#line 1469
  cp = FindAttValByName(entry, (char *)"MOREROWS");
  }
#line 1469
  if (cp) {
    {
#line 1470
    tmp = atoi((char const   *)cp);
    }
#line 1470
    return ((short )tmp);
  } else {
#line 1472
    return ((short)0);
  }
}
}
#line 1480 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
bool TblColAdv(short col , Element_t *ep , struct tblformat *tfp___2 , tblsource source ) 
{ 
  register bool bump ;
  register struct tblspanspec *tssp ;

  {
  {
#line 1490
  bump = (bool )1;
#line 1492
  tssp = TblEntrySpanSpec(col, ep, source);
  }
#line 1492
  if (tssp) {
    {
#line 1493
    bump = (bool )((unsigned int )tssp->align != 5U);
#line 1494
    free((void *)tssp);
    }
  }
#line 1497
  return (bump);
}
}
#line 1505 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblcolspec *TblEntryColSpec(short num , Element_t *ep , tblsource source ) 
{ 
  register bool throwAway ;
  register char *cp ;
  register struct tblcolspec *tcsp ;
  register struct tblcolspec *tcsp2 ;

  {
  {
#line 1516
  tcsp2 = (struct tblcolspec *)0;
#line 1516
  tcsp = tcsp2;
#line 1517
  throwAway = (bool )0;
#line 1519
  cp = FindAttValByName(ep, (char *)"COLNAME");
  }
#line 1519
  if (cp) {
    {
#line 1520
    tcsp = TblFindColSpec(cp, source);
    }
#line 1520
    if (! tcsp) {
      {
#line 1521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? can\'t find column name \'%s\'\n",
              cp);
      }
    }
  }
  {
#line 1525
  tcsp2 = TblFindColNum(num, source);
  }
#line 1525
  if (tcsp2) {
    {
#line 1526
    tcsp = TblDoColSpec(num, ep, tcsp2, source);
#line 1527
    throwAway = (bool )1;
    }
  }
  {
#line 1530
  tcsp2 = TblDoColSpec(num, ep, tcsp, source);
  }
#line 1532
  if (throwAway) {
    {
#line 1533
    free((void *)tcsp);
    }
  }
#line 1535
  return (tcsp2);
}
}
#line 1543 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblspanspec *TblEntrySpanSpec(short num , Element_t *ep , tblsource source ) 
{ 
  register char *cp ;
  register struct tblspanspec *tssp ;
  register struct tblspanspec *tssp2 ;
  char *tmp ;

  {
  {
#line 1552
  tssp2 = (struct tblspanspec *)0;
#line 1554
  cp = FindAttValByName(ep, (char *)"SPANNAME");
  }
#line 1554
  if (cp) {
    {
#line 1554
    tssp2 = TblFindSpanSpec(cp, source);
    }
#line 1554
    if (! tssp2) {
      _L: /* CIL Label */ 
      {
#line 1557
      tmp = FindAttValByName(ep, (char *)"NAMEST");
      }
#line 1557
      if (! tmp) {
#line 1558
        return ((struct tblspanspec *)0);
      }
    }
  } else {
#line 1554
    goto _L;
  }
  {
#line 1561
  tssp = TblDoSpanSpec(ep, tssp2, source);
  }
#line 1563
  if (tssp->start) {
#line 1563
    if (tssp->end) {
#line 1563
      if ((int )(tssp->start)->num < (int )num) {
#line 1563
        if ((int )(tssp->end)->num >= (int )num) {
#line 1565
          tssp->align = (tblalign )5;
        }
      }
    }
  }
#line 1568
  return (tssp);
}
}
#line 1576 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
bool TblFormatMatch(struct tblformat *tf1 , struct tblformat *tf2 ) 
{ 
  register int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 1582
  if ((int )tf1->cols != (int )tf2->cols) {
#line 1583
    return ((bool )0);
  }
#line 1586
  i = 0;
  {
#line 1586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1586
    if (! (i < (int )tf1->cols)) {
#line 1586
      goto while_break;
    }
#line 1588
    if ((int )tf1->colformat[i] != (int )tf2->colformat[i]) {
#line 1589
      return ((bool )0);
    }
    {
#line 1591
    tmp = strcmp((char const   *)(tf1->colwidth[i]), (char const   *)(tf2->colwidth[i]));
    }
#line 1591
    if (tmp) {
#line 1592
      return ((bool )0);
    }
    {
#line 1594
    tmp___0 = strcmp((char const   *)(tf1->font[i]), (char const   *)(tf2->font[i]));
    }
#line 1594
    if (tmp___0) {
#line 1595
      return ((bool )0);
    }
#line 1597
    if ((int )tf1->colsep[i] != (int )tf2->colsep[i]) {
#line 1598
      return ((bool )0);
    }
#line 1600
    if ((int )tf1->rowsep[i] != (int )tf2->rowsep[i]) {
#line 1601
      return ((bool )0);
    }
#line 1603
    if (tf1->moreRows[i]) {
#line 1604
      return ((bool )0);
    } else
#line 1603
    if (tf2->moreRows[i]) {
#line 1604
      return ((bool )0);
    }
#line 1586
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1608
  return ((bool )1);
}
}
#line 1622 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static char buf[3]  = {      (char )'\000',      (char )'\000',      (char )'\000'};
#line 1616 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblPrintFormat(FILE *fP , struct tblformat *tfp___2 ) 
{ 
  register int i ;
  register struct tblformat *tfp2___2 ;
  register struct tblformat *tfp3 ;

  {
#line 1625
  tfp2___2 = tfp___2;
#line 1625
  tfp3 = (struct tblformat *)0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! tfp2___2) {
#line 1625
      goto while_break;
    }
#line 1626
    i = 1;
    {
#line 1626
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1626
      if (! (i <= (int )tfp___2->cols)) {
#line 1626
        goto while_break___0;
      }
#line 1627
      if (i > 1) {
        {
#line 1628
        OutputString((char *)" ", fP, 1);
        }
      }
#line 1629
      if (tfp3) {
#line 1629
        if (tfp3->moreRows[i]) {
          {
#line 1630
          OutputString((char *)"\\^", fP, 1);
          }
        } else {
          {
#line 1632
          buf[0] = tfp2___2->colformat[i];
#line 1633
          OutputString(buf, fP, 1);
          }
        }
      } else {
        {
#line 1632
        buf[0] = tfp2___2->colformat[i];
#line 1633
        OutputString(buf, fP, 1);
        }
      }
#line 1635
      if (tfp2___2->colwidth[i][0]) {
        {
#line 1636
        OutputString((char *)"w(", fP, 1);
#line 1637
        OutputString(tfp2___2->colwidth[i], fP, 1);
#line 1638
        OutputString((char *)")", fP, 1);
        }
      }
#line 1640
      if (tfp2___2->font[i][0]) {
        {
#line 1641
        OutputString(tfp2___2->font[i], fP, 1);
        }
      }
#line 1642
      if (tfp2___2->colsep[i]) {
        {
#line 1643
        OutputString((char *)"|", fP, 1);
        }
      }
#line 1626
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1645
    if (! tfp2___2->next) {
      {
#line 1646
      OutputString((char *)".", fP, 1);
      }
    }
    {
#line 1647
    OutputString((char *)"^", fP, 1);
#line 1648
    tfp3 = tfp2___2;
#line 1625
    tfp2___2 = tfp2___2->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1650
  return;
}
}
#line 1673 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp___1  ;
#line 1673 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
static struct tblformat *tfp2___1  ;
#line 1668 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTRowStart(Element_t *ep , FILE *fP ) 
{ 
  register struct tblformat *ffp ;
  register struct tblformat *ffp2 ;
  bool tmp ;

  {
  {
#line 1675
  tfp___1 = TblBuild1Format(ep, (bool )0, (tblsource )0);
#line 1677
  tfp2___1 = formP;
  }
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    if (tfp2___1) {
#line 1677
      if (! tfp2___1->next) {
#line 1677
        goto while_break;
      }
    } else {
#line 1677
      goto while_break;
    }
#line 1677
    tfp2___1 = tfp2___1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1680
  tmp = TblFormatMatch(tfp___1, tfp2___1);
  }
#line 1680
  if (! tmp) {
#line 1682
    ffp = formP;
    {
#line 1682
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1682
      if (! ffp) {
#line 1682
        goto while_break___0;
      }
      {
#line 1683
      ffp2 = ffp->next;
#line 1684
      free((void *)ffp);
#line 1682
      ffp = ffp2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1687
    formP = tfp___1;
#line 1689
    OutputString((char *)"^.T&^", fP, 1);
#line 1690
    TblPrintFormat(fP, formP);
    }
  }
#line 1693
  tblrow = (short )((int )tblrow + 1);
#line 1695
  return;
}
}
#line 1708 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTRowEnd(Element_t *ep , FILE *fP ) 
{ 
  register int i ;
  register int k ;
  register tblsource source ;
  register bool startedRow ;
  register bool didSep ;
  register struct tblformat *rfp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1718
  OutputString((char *)"^", fP, 1);
#line 1722
  tmp___0 = strcmp((char const   *)(ep->parent)->gi, "TFoot");
  }
#line 1722
  if (tmp___0) {
    {
#line 1725
    tmp = strcmp((char const   *)(ep->parent)->gi, "THead");
    }
#line 1725
    if (tmp) {
#line 1728
      source = (tblsource )3;
    } else {
#line 1726
      source = (tblsource )1;
    }
  } else {
#line 1723
    source = (tblsource )2;
  }
  {
#line 1730
  rfp = TblBuild1Format(ep, (bool )1, source);
#line 1731
  startedRow = (bool )0;
#line 1732
  didSep = (bool )0;
#line 1734
  i = 1;
  }
  {
#line 1734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1734
    if (! (i <= (int )formP->cols)) {
#line 1734
      goto while_break;
    }
#line 1735
    if (rfp->rowsep[i]) {
#line 1735
      goto _L;
    } else
#line 1735
    if (didSep) {
#line 1735
      if ((int )rfp->colformat[i] == 115) {
        _L: /* CIL Label */ 
#line 1737
        if (! startedRow) {
          {
#line 1738
          OutputString((char *)"^", fP, 1);
#line 1739
          k = 1;
          }
          {
#line 1739
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1739
            if (! (k < i)) {
#line 1739
              goto while_break___0;
            }
            {
#line 1740
            OutputString((char *)"\a", fP, 1);
#line 1739
            k ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1741
          startedRow = (bool )1;
        }
        {
#line 1743
        OutputString((char *)"_\a", fP, 1);
#line 1744
        didSep = (bool )1;
        }
      } else {
#line 1735
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1746
    if (startedRow) {
      {
#line 1747
      OutputString((char *)"\a", fP, 1);
      }
    }
#line 1749
    didSep = (bool )0;
#line 1734
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1751
  free((void *)rfp);
  }
#line 1753
  if (startedRow) {
    {
#line 1754
    OutputString((char *)"^", fP, 1);
    }
  }
#line 1755
  return;
}
}
#line 1769 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTCellStart(Element_t *ep , FILE *fP ) 
{ 
  register int i ;
  register bool sawPI ;
  int tmp ;

  {
#line 1778
  i = 0;
#line 1778
  sawPI = (bool )0;
  {
#line 1778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1778
    if (i < ep->ncont) {
#line 1778
      if (! (! sawPI)) {
#line 1778
        goto while_break;
      }
    } else {
#line 1778
      goto while_break;
    }
#line 1779
    if ((int )(ep->cont + i)->type == 63) {
#line 1780
      sawPI = (bool )1;
    }
#line 1778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1782
  if (sawPI) {
    {
#line 1783
    tblBOFTCount ++;
#line 1784
    OutputString((char *)"T{^", fP, 1);
#line 1785
    tblinBOFT = (bool )1;
    }
  } else {
    {
#line 1782
    tmp = TblCountContent(ep);
    }
#line 1782
    if (tmp > BOFTTextThresh) {
      {
#line 1783
      tblBOFTCount ++;
#line 1784
      OutputString((char *)"T{^", fP, 1);
#line 1785
      tblinBOFT = (bool )1;
      }
    }
  }
#line 1787
  return;
}
}
#line 1796 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
int TblCountContent(Element_t *ep ) 
{ 
  register int i ;
  register int count ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1802
  count = 0;
#line 1804
  i = 0;
  {
#line 1804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1804
    if (! (i < ep->ncont)) {
#line 1804
      goto while_break;
    }
#line 1805
    if ((int )(ep->cont + i)->type == 45) {
      {
#line 1806
      tmp = strlen((char const   *)(ep->cont + i)->ch.data);
#line 1806
      count = (int )((size_t )count + tmp);
      }
    } else
#line 1808
    if ((int )(ep->cont + i)->type == 40) {
      {
#line 1809
      tmp___0 = TblCountContent((ep->cont + i)->ch.elem);
#line 1809
      count += tmp___0;
      }
    }
#line 1804
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1813
  return (count);
}
}
#line 1827 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
void TblTCellEnd(Element_t *ep , FILE *fP ) 
{ 
  register Element_t *ep2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1834
  if (tblinBOFT) {
    {
#line 1835
    OutputString((char *)"^T}", fP, 1);
#line 1836
    tblinBOFT = (bool )0;
    }
  }
#line 1839
  ep2 = ep->next;
  {
#line 1839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1839
    if (! ep2) {
#line 1839
      goto while_break;
    }
    {
#line 1840
    tmp = strcmp((char const   *)ep2->gi, "ENTRY");
    }
#line 1840
    if (tmp) {
      {
#line 1840
      tmp___0 = strcmp((char const   *)ep2->gi, "ENTRYTBL");
      }
#line 1840
      if (! tmp___0) {
        {
#line 1841
        OutputString((char *)"\a", fP, 1);
        }
#line 1842
        goto while_break;
      }
    } else {
      {
#line 1841
      OutputString((char *)"\a", fP, 1);
      }
#line 1842
      goto while_break;
    }
    {
#line 1844
    tmp___1 = strcmp((char const   *)ep2->gi, "ROW");
    }
#line 1844
    if (! tmp___1) {
#line 1845
      goto while_break;
    }
#line 1839
    ep2 = ep2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1847
  return;
}
}
#line 1856 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblcolspec *TblDoColSpec(short number , Element_t *ep , struct tblcolspec *pcsp ,
                                tblsource source ) 
{ 
  register char *cp ;
  register struct tblcolspec *tcsp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1866
  tmp = calloc((size_t )1, sizeof(struct tblcolspec ));
#line 1866
  tcsp = (struct tblcolspec *)tmp;
  }
#line 1866
  if (! tcsp) {
    {
#line 1866
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 1866
    exit(1);
    }
  }
  {
#line 1866
  memset((void *)tcsp, 0, sizeof(struct tblcolspec ));
#line 1868
  cp = FindAttValByName(ep, (char *)"COLNAME");
  }
#line 1868
  if (cp) {
    {
#line 1869
    strcpy((char */* __restrict  */)(tcsp->name), (char const   */* __restrict  */)cp);
    }
  }
  {
#line 1871
  tcsp->num = number;
#line 1872
  tcsp->source = source;
#line 1874
  cp = FindAttValByName(ep, (char *)"ALIGN");
  }
#line 1874
  if (cp) {
    {
#line 1875
    tmp___4 = strcmp((char const   *)cp, "LEFT");
    }
#line 1875
    if (tmp___4) {
      {
#line 1876
      tmp___3 = strcmp((char const   *)cp, "RIGHT");
      }
#line 1876
      if (tmp___3) {
        {
#line 1877
        tmp___2 = strcmp((char const   *)cp, "CENTER");
        }
#line 1877
        if (tmp___2) {
          {
#line 1878
          tmp___1 = strcmp((char const   *)cp, "JUSTIFY");
          }
#line 1878
          if (tmp___1) {
            {
#line 1879
            tmp___0 = strcmp((char const   *)cp, "CHAR");
            }
#line 1879
            if (! tmp___0) {
#line 1879
              tcsp->align = (tblalign )4;
            }
          } else {
#line 1878
            tcsp->align = (tblalign )3;
          }
        } else {
#line 1877
          tcsp->align = (tblalign )2;
        }
      } else {
#line 1876
        tcsp->align = (tblalign )1;
      }
    } else {
#line 1875
      tcsp->align = (tblalign )0;
    }
  } else
#line 1881
  if (pcsp) {
#line 1881
    tcsp->align = pcsp->align;
  } else {
#line 1881
    tcsp->align = (tblalign )0;
  }
  {
#line 1883
  cp = FindAttValByName(ep, (char *)"CHAR");
  }
#line 1883
  if (cp) {
#line 1884
    tcsp->alignchar = *(cp + 0);
  } else
#line 1886
  if (pcsp) {
#line 1886
    tcsp->alignchar = pcsp->alignchar;
  } else {
#line 1886
    tcsp->alignchar = (char)0;
  }
  {
#line 1888
  cp = FindAttValByName(ep, (char *)"CHAROFF");
  }
#line 1888
  if (cp) {
    {
#line 1889
    tmp___5 = atoi((char const   *)cp);
#line 1889
    tcsp->aligncharoff = (short )tmp___5;
    }
  } else
#line 1891
  if (pcsp) {
#line 1891
    tcsp->aligncharoff = pcsp->aligncharoff;
  } else {
#line 1891
    tcsp->aligncharoff = (short)0;
  }
  {
#line 1893
  cp = FindAttValByName(ep, (char *)"COLWIDTH");
  }
#line 1893
  if (cp) {
    {
#line 1894
    strcpy((char */* __restrict  */)(tcsp->colwidth), (char const   */* __restrict  */)cp);
    }
  } else {
#line 1896
    if (pcsp) {
#line 1896
      tmp___6 = (char const   *)(pcsp->colwidth);
    } else {
#line 1896
      tmp___6 = "";
    }
    {
#line 1896
    strcpy((char */* __restrict  */)(tcsp->colwidth), (char const   */* __restrict  */)tmp___6);
    }
  }
  {
#line 1898
  cp = FindAttValByName(ep, (char *)"COLSEP");
  }
#line 1898
  if (cp) {
    {
#line 1899
    tmp___7 = strcmp((char const   *)cp, "1");
    }
#line 1899
    if (tmp___7) {
#line 1899
      tmp___8 = 0;
    } else {
#line 1899
      tmp___8 = 1;
    }
#line 1899
    tcsp->colsep = (bool )tmp___8;
  } else
#line 1901
  if (pcsp) {
#line 1901
    tcsp->colsep = pcsp->colsep;
  } else {
#line 1901
    tcsp->colsep = (bool )0;
  }
  {
#line 1903
  cp = FindAttValByName(ep, (char *)"ROWSEP");
  }
#line 1903
  if (cp) {
    {
#line 1904
    tmp___9 = strcmp((char const   *)cp, "1");
    }
#line 1904
    if (tmp___9) {
#line 1904
      tmp___10 = 0;
    } else {
#line 1904
      tmp___10 = 1;
    }
#line 1904
    tcsp->rowsep = (bool )tmp___10;
  } else
#line 1906
  if (pcsp) {
#line 1906
    tcsp->rowsep = pcsp->rowsep;
  } else {
#line 1906
    tcsp->rowsep = (bool )0;
  }
#line 1908
  return (tcsp);
}
}
#line 1920 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblspanspec *TblDoSpanSpec(Element_t *ep , struct tblspanspec *pssp , tblsource source ) 
{ 
  register char *cp ;
  register struct tblspanspec *tssp ;
  register struct tblcolspec *tcsp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 1930
  tmp = calloc((size_t )1, sizeof(struct tblspanspec ));
#line 1930
  tssp = (struct tblspanspec *)tmp;
  }
#line 1930
  if (! tssp) {
    {
#line 1930
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 1930
    exit(1);
    }
  }
  {
#line 1930
  memset((void *)tssp, 0, sizeof(struct tblspanspec ));
#line 1932
  cp = FindAttValByName(ep, (char *)"SPANNAME");
  }
#line 1932
  if (cp) {
    {
#line 1932
    strcpy((char */* __restrict  */)(tssp->name), (char const   */* __restrict  */)cp);
    }
  }
  {
#line 1933
  tssp->source = source;
#line 1935
  cp = FindAttValByName(ep, (char *)"NAMEST");
  }
#line 1935
  if (cp) {
    {
#line 1936
    tcsp = TblFindColSpec(cp, source);
    }
#line 1936
    if (tcsp) {
#line 1938
      tssp->start = tcsp;
    } else {
      {
#line 1936
      tmp___0 = atoi((char const   *)cp);
#line 1936
      tcsp = TblFindColNum((short )tmp___0, source);
      }
#line 1936
      if (tcsp) {
#line 1938
        tssp->start = tcsp;
      } else {
        {
#line 1940
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? spanspec namest points to unknown column \'%s\'\n",
                cp);
#line 1941
        tssp->start = (struct tblcolspec *)0;
        }
      }
    }
  } else
#line 1944
  if (pssp) {
#line 1944
    if (pssp->start) {
#line 1945
      tssp->start = pssp->start;
    }
  }
  {
#line 1949
  cp = FindAttValByName(ep, (char *)"NAMEEND");
  }
#line 1949
  if (cp) {
    {
#line 1950
    tcsp = TblFindColSpec(cp, source);
    }
#line 1950
    if (tcsp) {
#line 1952
      tssp->end = tcsp;
    } else {
      {
#line 1950
      tmp___1 = atoi((char const   *)cp);
#line 1950
      tcsp = TblFindColNum((short )tmp___1, source);
      }
#line 1950
      if (tcsp) {
#line 1952
        tssp->end = tcsp;
      } else {
        {
#line 1954
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? spanspec nameend points to unknown column \'%s\'\n",
                cp);
#line 1955
        tssp->end = (struct tblcolspec *)0;
        }
      }
    }
  } else
#line 1958
  if (pssp) {
#line 1958
    if (pssp->end) {
#line 1959
      tssp->end = pssp->end;
    }
  }
  {
#line 1963
  cp = FindAttValByName(ep, (char *)"ALIGN");
  }
#line 1963
  if (cp) {
    {
#line 1964
    tmp___6 = strcmp((char const   *)cp, "LEFT");
    }
#line 1964
    if (tmp___6) {
      {
#line 1965
      tmp___5 = strcmp((char const   *)cp, "RIGHT");
      }
#line 1965
      if (tmp___5) {
        {
#line 1966
        tmp___4 = strcmp((char const   *)cp, "CENTER");
        }
#line 1966
        if (tmp___4) {
          {
#line 1967
          tmp___3 = strcmp((char const   *)cp, "JUSTIFY");
          }
#line 1967
          if (tmp___3) {
            {
#line 1968
            tmp___2 = strcmp((char const   *)cp, "CHAR");
            }
#line 1968
            if (! tmp___2) {
#line 1968
              tssp->align = (tblalign )4;
            }
          } else {
#line 1967
            tssp->align = (tblalign )3;
          }
        } else {
#line 1966
          tssp->align = (tblalign )2;
        }
      } else {
#line 1965
        tssp->align = (tblalign )1;
      }
    } else {
#line 1964
      tssp->align = (tblalign )0;
    }
  } else
#line 1970
  if (pssp) {
#line 1971
    tssp->align = pssp->align;
  }
  {
#line 1974
  cp = FindAttValByName(ep, (char *)"CHAR");
  }
#line 1974
  if (cp) {
#line 1975
    tssp->alignchar = *(cp + 0);
  } else
#line 1977
  if (pssp) {
#line 1978
    tssp->alignchar = pssp->alignchar;
  }
  {
#line 1980
  cp = FindAttValByName(ep, (char *)"CHAROFF");
  }
#line 1980
  if (cp) {
    {
#line 1981
    tmp___7 = atoi((char const   *)cp);
#line 1981
    tssp->aligncharoff = (short )tmp___7;
    }
  } else
#line 1983
  if (pssp) {
#line 1984
    tssp->alignchar = pssp->alignchar;
  }
  {
#line 1987
  cp = FindAttValByName(ep, (char *)"COLSEP");
  }
#line 1987
  if (cp) {
    {
#line 1988
    tmp___8 = strcmp((char const   *)cp, "1");
    }
#line 1988
    if (tmp___8) {
#line 1988
      tmp___9 = 0;
    } else {
#line 1988
      tmp___9 = 1;
    }
#line 1988
    tssp->colsep = (bool )tmp___9;
  } else
#line 1990
  if (pssp) {
#line 1991
    tssp->colsep = pssp->colsep;
  }
  {
#line 1993
  cp = FindAttValByName(ep, (char *)"ROWSEP");
  }
#line 1993
  if (cp) {
    {
#line 1994
    tmp___10 = strcmp((char const   *)cp, "1");
    }
#line 1994
    if (tmp___10) {
#line 1994
      tmp___11 = 0;
    } else {
#line 1994
      tmp___11 = 1;
    }
#line 1994
    tssp->rowsep = (bool )tmp___11;
  } else
#line 1996
  if (pssp) {
#line 1997
    tssp->rowsep = pssp->rowsep;
  }
#line 2000
  return (tssp);
}
}
#line 2009 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblcolspec *TblFindColSpec(char *name , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;
  int tmp ;
  int tmp___0 ;

  {
#line 2018
  tcsp = tblColSpec;
  {
#line 2018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2018
    if (! tcsp) {
#line 2018
      goto while_break;
    }
#line 2019
    if ((unsigned int )tcsp->source == (unsigned int )source) {
      {
#line 2019
      tmp = strcmp((char const   *)(tcsp->name), (char const   *)name);
      }
#line 2019
      if (! tmp) {
#line 2020
        return (tcsp);
      }
    }
#line 2018
    tcsp = tcsp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2025
  tcsp = tblColSpec;
  {
#line 2025
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2025
    if (! tcsp) {
#line 2025
      goto while_break___0;
    }
#line 2026
    if ((unsigned int )tcsp->source == 0U) {
      {
#line 2026
      tmp___0 = strcmp((char const   *)(tcsp->name), (char const   *)name);
      }
#line 2026
      if (! tmp___0) {
#line 2027
        return (tcsp);
      }
    }
#line 2025
    tcsp = tcsp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2032
  return ((struct tblcolspec *)0);
}
}
#line 2041 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblcolspec *TblFindColNum(short number , tblsource source ) 
{ 
  register struct tblcolspec *tcsp ;

  {
#line 2051
  tcsp = tblColSpec;
  {
#line 2051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2051
    if (! tcsp) {
#line 2051
      goto while_break;
    }
#line 2052
    if ((int )tcsp->num == (int )number) {
#line 2052
      if ((unsigned int )tcsp->source == (unsigned int )source) {
#line 2055
        return (tcsp);
      } else
#line 2052
      if ((unsigned int )source == 1U) {
#line 2052
        if ((unsigned int )tcsp->source == 0U) {
#line 2055
          return (tcsp);
        }
      }
    }
#line 2051
    tcsp = tcsp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2060
  tcsp = tblColSpec;
  {
#line 2060
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2060
    if (! tcsp) {
#line 2060
      goto while_break___0;
    }
#line 2061
    if ((unsigned int )tcsp->source == 0U) {
#line 2061
      if ((int )tcsp->num == (int )number) {
#line 2062
        return (tcsp);
      }
    }
#line 2060
    tcsp = tcsp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2067
  return ((struct tblcolspec *)0);
}
}
#line 2076 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tables.c"
struct tblspanspec *TblFindSpanSpec(char *name , tblsource source ) 
{ 
  register struct tblspanspec *tssp ;
  int tmp ;

  {
#line 2085
  tssp = tblSpanSpec;
  {
#line 2085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2085
    if (! tssp) {
#line 2085
      goto while_break;
    }
    {
#line 2086
    tmp = strcmp((char const   *)(tssp->name), (char const   *)name);
    }
#line 2086
    if (! tmp) {
#line 2086
      if ((unsigned int )tssp->source == (unsigned int )source) {
#line 2089
        return (tssp);
      } else
#line 2086
      if ((unsigned int )source == 1U) {
#line 2086
        if ((unsigned int )tssp->source == 0U) {
#line 2089
          return (tssp);
        }
      }
    }
#line 2085
    tssp = tssp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2094
  return ((struct tblspanspec *)0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 19 "tptregexp/tptregexp.h"
int tpt_regexec(regexp *prog , char *string ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
Trans_t *TrSpecs  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
Mapping_t *CharMap  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.h"
int nCharMap  ;
#line 138
Trans_t *FindTransByName(char *s ) ;
#line 140
void PrepTranspecs(Element_t *e ) ;
#line 143
void TranByAction(Element_t *e , int n , FILE *fp ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
static Trans_t NullTrans  ;
#line 80
void ProcesOutputSpec(char *ib , Element_t *e , FILE *fp , int track_pos ) ;
#line 81
static void WasProcessed(Element_t *e ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void DoTranslate(Element_t *e , char *transfile , FILE *fp ) 
{ 
  Trans_t *t ;
  Trans_t *tn ;

  {
#line 103
  if (! transfile) {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Translation spec file not specified. Skipping translation.\n");
    }
#line 106
    return;
  }
  {
#line 108
  ReadTransSpec(transfile);
#line 111
  DescendTree(e, (void (*)())(& PrepTranspecs), (void (*)())0, (void (*)())0, (void *)0);
#line 114
  t = FindTransByName((char *)"_Start");
  }
#line 114
  if (t) {
#line 115
    if (t->starttext) {
      {
#line 115
      ProcesOutputSpec(t->starttext, (Element_t *)0, fp, 1);
      }
    }
#line 116
    if (t->replace) {
      {
#line 116
      ProcesOutputSpec(t->replace, (Element_t *)0, fp, 1);
      }
    }
#line 117
    if (t->message) {
      {
#line 117
      ProcesOutputSpec(t->message, (Element_t *)0, stderr, 0);
      }
    }
#line 118
    if (t->endtext) {
      {
#line 118
      ProcesOutputSpec(t->endtext, (Element_t *)0, fp, 1);
      }
    }
  }
  {
#line 122
  TransElement(e, fp, (Trans_t *)((void *)0));
#line 125
  t = FindTransByName((char *)"_End");
  }
#line 125
  if (t) {
#line 126
    if (t->starttext) {
      {
#line 126
      ProcesOutputSpec(t->starttext, (Element_t *)0, fp, 1);
      }
    }
#line 127
    if (t->replace) {
      {
#line 127
      ProcesOutputSpec(t->replace, (Element_t *)0, fp, 1);
      }
    }
#line 128
    if (t->message) {
      {
#line 128
      ProcesOutputSpec(t->message, (Element_t *)0, stderr, 0);
      }
    }
#line 129
    if (t->endtext) {
      {
#line 129
      ProcesOutputSpec(t->endtext, (Element_t *)0, fp, 1);
      }
    }
  }
#line 133
  if (verbose) {
    {
#line 134
    DescendTree(e, (void (*)())(& WasProcessed), (void (*)())0, (void (*)())0, (void *)0);
    }
  }
#line 138
  t = TrSpecs;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! t) {
#line 138
      goto while_break;
    }
    {
#line 139
    tn = t->next;
#line 141
    free((void *)t);
#line 142
    t = tn;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  TrSpecs = (Trans_t *)0;
#line 145
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
static void WasProcessed(Element_t *e ) 
{ 
  Trans_t *t ;

  {
#line 159
  t = (Trans_t *)e->trans;
#line 160
  if (! e->processed) {
#line 160
    if (t) {
#line 160
      if (! t->ignore) {
        {
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: element \'%s\' was not processed:\n",
                e->gi);
#line 162
        PrintLocation(e, stderr);
        }
      }
    }
  }
#line 164
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void PrepTranspecs(Element_t *e ) 
{ 
  Trans_t *t ;

  {
  {
#line 177
  t = FindTrans(e, 0);
#line 178
  e->trans = (void *)t;
  }
#line 179
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void ExpandVariables(char *in , char *out , Element_t *e ) 
{ 
  register int i ;
  register int j ;
  char *ip ;
  char *vp ;
  char *op ;
  char *def_val ;
  char *s ;
  char *atval ;
  char *modifier ;
  char vbuf[500] ;
  int lev ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 202
  ip = in;
#line 203
  op = out;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! *ip) {
#line 204
      goto while_break;
    }
#line 206
    if ((int )*ip == 36) {
#line 206
      if ((int )*(ip + 1) == 123) {
#line 206
        if ((int )*(ip + 2) != 95) {
#line 207
          ip ++;
#line 208
          ip ++;
#line 209
          vp = vbuf;
#line 214
          lev = 0;
          {
#line 215
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 215
            if (! *ip) {
#line 215
              goto while_break___0;
            }
#line 216
            if ((int )*ip == 123) {
#line 216
              lev ++;
            }
#line 217
            if ((int )*ip == 125) {
#line 218
              if (lev == 0) {
#line 219
                ip ++;
#line 220
                goto while_break___0;
              } else {
#line 222
                lev --;
              }
            }
#line 224
            tmp = vp;
#line 224
            vp ++;
#line 224
            tmp___0 = ip;
#line 224
            ip ++;
#line 224
            *tmp = *tmp___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 226
          *vp = (char )'\000';
#line 228
          if (lev != 0) {
            {
#line 229
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Botched variable use: %s\n",
                    in);
            }
#line 231
            return;
          }
#line 234
          vp = vbuf;
#line 239
          if ((int )*vp == 43) {
            {
#line 241
            tmp___2 = strcmp((char const   *)vp, "+content");
            }
#line 241
            if (tmp___2) {
              {
#line 253
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown immediate variable: %s\n",
                      vp);
              }
            } else {
#line 242
              i = 0;
              {
#line 242
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 242
                if (! (i < e->ncont)) {
#line 242
                  goto while_break___1;
                }
#line 243
                if ((int )(e->cont + i)->type == 45) {
                  {
#line 244
                  tmp___1 = strlen((char const   *)(e->cont + i)->ch.data);
#line 244
                  j = (int )tmp___1;
#line 245
                  memcpy((void */* __restrict  */)op, (void const   */* __restrict  */)(e->cont + i)->ch.data,
                         (size_t )j);
#line 246
                  op += j;
                  }
                } else {
                  {
#line 248
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: ${+current} skipped element content\n");
                  }
                }
#line 242
                i ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          } else {
#line 260
            def_val = vp;
            {
#line 261
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 261
              if (*def_val) {
#line 261
                if (! ((int )*def_val != 32)) {
#line 261
                  goto while_break___2;
                }
              } else {
#line 261
                goto while_break___2;
              }
#line 261
              def_val ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 262
            if (*def_val) {
#line 262
              tmp___3 = def_val;
#line 262
              def_val ++;
#line 262
              *tmp___3 = (char )'\000';
            } else {
#line 263
              def_val = (char *)0;
            }
#line 266
            modifier = vp;
            {
#line 267
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 267
              if (*modifier) {
#line 267
                if (! ((int )*modifier != 58)) {
#line 267
                  goto while_break___3;
                }
              } else {
#line 267
                goto while_break___3;
              }
#line 267
              modifier ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 268
            if (*modifier) {
#line 268
              tmp___4 = modifier;
#line 268
              modifier ++;
#line 268
              *tmp___4 = (char )'\000';
            } else {
#line 269
              modifier = (char *)0;
            }
#line 272
            s = (char *)0;
#line 274
            if (e) {
              {
#line 274
              atval = FindAttValByName(e, vp);
              }
#line 274
              if (atval) {
#line 275
                s = atval;
              } else {
                {
#line 277
                s = FindMappingVal(Variables, vp);
                }
              }
            } else {
              {
#line 277
              s = FindMappingVal(Variables, vp);
              }
            }
#line 281
            if (s) {
#line 282
              if (modifier) {
#line 282
                if ((int )*modifier == 108) {
                  {
#line 283
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 283
                    if (! *s) {
#line 283
                      goto while_break___4;
                    }
                    {
#line 284
                    tmp___5 = tolower((int )*s);
#line 284
                    *op = (char )tmp___5;
#line 285
                    op ++;
#line 285
                    tmp___6 = s;
#line 285
                    s ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                } else {
#line 282
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 288
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 288
                  if (! *s) {
#line 288
                    goto while_break___5;
                  }
#line 288
                  tmp___7 = op;
#line 288
                  op ++;
#line 288
                  tmp___8 = s;
#line 288
                  s ++;
#line 288
                  *tmp___7 = *tmp___8;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            } else
#line 290
            if (def_val) {
              {
#line 291
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 291
                if (! *def_val) {
#line 291
                  goto while_break___6;
                }
#line 291
                tmp___9 = op;
#line 291
                op ++;
#line 291
                tmp___10 = def_val;
#line 291
                def_val ++;
#line 291
                *tmp___9 = *tmp___10;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
          }
#line 294
          goto while_continue;
        }
      }
    }
#line 296
    tmp___11 = op;
#line 296
    op ++;
#line 296
    tmp___12 = ip;
#line 296
    ip ++;
#line 296
    *tmp___11 = *tmp___12;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  *op = (char )'\000';
#line 299
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void ProcesOutputSpec(char *ib , Element_t *e , FILE *fp , int track_pos ) 
{ 
  char obuf[60000] ;
  char vbuf[60000] ;
  char *dest ;
  char vname[60000] ;
  char *cp ;
  int esc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 331
  obuf[0] = (char )'\000';
#line 333
  ExpandVariables(ib, vbuf, e);
#line 334
  ib = vbuf;
#line 335
  dest = obuf;
#line 337
  esc = 0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! *ib) {
#line 338
      goto while_break;
    }
#line 340
    if ((int )*ib == 92) {
#line 340
      if ((int )*(ib + 1) == 36) {
#line 341
        ib ++;
#line 342
        tmp = dest;
#line 342
        dest ++;
#line 342
        tmp___0 = ib;
#line 342
        ib ++;
#line 342
        *tmp = *tmp___0;
#line 343
        goto while_continue;
      }
    }
#line 347
    if ((int )*ib != 36) {
#line 348
      tmp___1 = dest;
#line 348
      dest ++;
#line 348
      tmp___2 = ib;
#line 348
      ib ++;
#line 348
      *tmp___1 = *tmp___2;
#line 349
      goto while_continue;
    }
#line 355
    if ((int )*(ib + 1) != 123) {
#line 356
      tmp___3 = dest;
#line 356
      dest ++;
#line 356
      tmp___4 = ib;
#line 356
      ib ++;
#line 356
      *tmp___3 = *tmp___4;
#line 357
      goto while_continue;
    }
#line 360
    ib ++;
#line 363
    *dest = (char )'\000';
#line 364
    if (obuf[0]) {
      {
#line 364
      OutputString(obuf, fp, track_pos);
      }
    }
    {
#line 365
    dest = obuf;
#line 367
    tmp___5 = strchr((char const   *)ib, '}');
    }
#line 367
    if (! tmp___5) {
      {
#line 368
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mismatched braces in TranSpec: %s\n",
              ib);
      }
    }
#line 371
    ib ++;
#line 372
    cp = vname;
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 373
      if (*ib) {
#line 373
        if (! ((int )*ib != 125)) {
#line 373
          goto while_break___0;
        }
      } else {
#line 373
        goto while_break___0;
      }
#line 373
      tmp___6 = cp;
#line 373
      cp ++;
#line 373
      tmp___7 = ib;
#line 373
      ib ++;
#line 373
      *tmp___6 = *tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 374
    *cp = (char )'\000';
#line 375
    ib ++;
#line 377
    ExpandSpecialVar(& vname[1], e, fp, track_pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  *dest = (char )'\000';
#line 381
  if (obuf[0]) {
    {
#line 381
    OutputString(obuf, fp, track_pos);
    }
  }
#line 382
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
Trans_t *FindTrans(Element_t *e , int specID ) 
{ 
  char context[60000] ;
  char buf___0[60000] ;
  char *cp ;
  char **vec ;
  char *atval ;
  int i ;
  int a ;
  int match ;
  Trans_t *t ;
  Trans_t *tt ;
  int tmp ;
  int tmp___0 ;
  Element_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  Mapping_t *r ;
  int tmp___6 ;
  char *p ;
  char **tok ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 405
  t = TrSpecs;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! t) {
#line 405
      goto while_break;
    }
#line 409
    if (t->gi) {
#line 409
      if ((int )*(t->gi + 0) == (int )*(e->gi + 0)) {
        {
#line 409
        tmp = strcmp((char const   *)t->gi, (char const   *)e->gi);
        }
#line 409
        if (tmp) {
#line 409
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 409
      if (! specID) {
#line 409
        goto __Cont;
      }
    }
#line 413
    if (specID) {
#line 414
      if (! t->my_id) {
#line 415
        goto __Cont;
      } else
#line 414
      if (specID != t->my_id) {
#line 415
        goto __Cont;
      }
    }
#line 418
    if (t->gilist) {
#line 419
      match = 0;
#line 419
      vec = t->gilist;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if (! *vec) {
#line 419
          goto while_break___0;
        }
#line 420
        if ((int )*(*(vec + 0)) == (int )*(e->gi + 0)) {
          {
#line 420
          tmp___0 = strcmp((char const   *)*vec, (char const   *)e->gi);
          }
#line 420
          if (! tmp___0) {
#line 421
            match = 1;
#line 422
            goto while_break___0;
          }
        }
#line 419
        vec ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 425
      if (! match) {
#line 425
        goto __Cont;
      }
    }
#line 431
    if (t->parent) {
      {
#line 432
      tmp___1 = QRelation(e, t->parent, (Relation_t )1);
      }
#line 432
      if (! tmp___1) {
#line 432
        goto __Cont;
      }
    }
#line 434
    if (t->context) {
      {
#line 435
      FindContext(e, t->depth, context);
      }
#line 438
      if (t->context_re) {
        {
#line 439
        tmp___2 = tpt_regexec(t->context_re, context);
        }
#line 439
        if (! tmp___2) {
#line 439
          goto __Cont;
        }
      } else {
#line 443
        if (t->depth > e->depth) {
#line 443
          goto __Cont;
        }
#line 446
        if ((int )*(t->context + 0) == (int )context[0]) {
          {
#line 446
          tmp___3 = strcmp((char const   *)t->context, (char const   *)(context));
          }
#line 446
          if (tmp___3) {
#line 446
            tmp___4 = 0;
          } else {
#line 446
            tmp___4 = 1;
          }
        } else {
#line 446
          tmp___4 = 0;
        }
#line 446
        match = tmp___4;
#line 448
        if (! match) {
#line 448
          goto __Cont;
        }
      }
    }
#line 453
    if (t->nattpairs) {
#line 454
      match = 1;
#line 454
      a = 0;
      {
#line 454
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 454
        if (! (a < t->nattpairs)) {
#line 454
          goto while_break___1;
        }
        {
#line 455
        atval = FindAttValByName(e, (t->attpair + a)->name);
        }
#line 455
        if (! atval) {
#line 456
          match = 0;
#line 457
          goto while_break___1;
        }
        {
#line 459
        tmp___5 = tpt_regexec((t->attpair + a)->rex, atval);
        }
#line 459
        if (! tmp___5) {
#line 459
          match = 0;
        }
#line 454
        a ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 461
      if (! match) {
#line 461
        goto __Cont;
      }
    }
#line 465
    if (t->relations) {
#line 467
      match = 1;
#line 468
      r = (t->relations)->maps;
#line 468
      i = 0;
      {
#line 468
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 468
        if (! (i < (t->relations)->n_used)) {
#line 468
          goto while_break___2;
        }
        {
#line 469
        tmp___6 = CheckRelation(e, (r + i)->name, (r + i)->sval, (char *)0, (FILE *)0,
                                (RelAction_t )0);
        }
#line 469
        if (! tmp___6) {
#line 470
          match = 0;
#line 471
          goto while_break___2;
        }
#line 468
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 474
      if (! match) {
#line 474
        goto __Cont;
      }
    }
#line 478
    if (t->pattrset) {
#line 478
      if (e->parent) {
        {
#line 481
        i = 2;
#line 482
        match = 1;
#line 483
        tok = Split(t->pattrset, & i, 1);
        }
#line 484
        if (i == 2) {
          {
#line 485
          p = FindAttValByName(e->parent, *(tok + 0));
#line 486
          ExpandVariables(*(tok + 1), buf___0, (Element_t *)0);
          }
#line 487
          if (! p) {
#line 488
            match = 0;
          } else {
            {
#line 487
            tmp___7 = strcmp((char const   *)p, (char const   *)(buf___0));
            }
#line 487
            if (tmp___7) {
#line 488
              match = 0;
            }
          }
        } else {
          {
#line 490
          tmp___8 = FindAttValByName(e->parent, t->pattrset);
          }
#line 490
          if (! tmp___8) {
#line 491
            match = 0;
          }
        }
        {
#line 493
        free((void *)*(tok + 0));
        }
#line 494
        if (! match) {
#line 494
          goto __Cont;
        }
      }
    }
#line 498
    if (t->nth_child) {
#line 500
      i = t->nth_child;
#line 501
      if (i > 0) {
#line 502
        if (e->my_eorder != i - 1) {
#line 502
          goto __Cont;
        }
      } else {
#line 505
        i = (e->parent)->necont - i;
#line 506
        if (e->my_eorder != i) {
#line 506
          goto __Cont;
        }
      }
    }
#line 511
    if (t->var_name) {
      {
#line 512
      cp = FindMappingVal(Variables, t->var_name);
      }
#line 513
      if (! cp) {
#line 513
        goto __Cont;
      } else {
        {
#line 513
        tmp___9 = strcmp((char const   *)cp, (char const   *)t->var_value);
        }
#line 513
        if (tmp___9) {
#line 513
          goto __Cont;
        }
      }
    }
#line 517
    if (t->var_RE_name) {
      {
#line 518
      cp = FindMappingVal(Variables, t->var_RE_name);
      }
#line 519
      if (! cp) {
#line 519
        goto __Cont;
      } else {
        {
#line 519
        tmp___10 = tpt_regexec(t->var_RE_value, cp);
        }
#line 519
        if (! tmp___10) {
#line 519
          goto __Cont;
        }
      }
    }
#line 523
    if (t->content) {
#line 524
      match = 0;
#line 524
      i = 0;
      {
#line 524
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 524
        if (! (i < e->ndcont)) {
#line 524
          goto while_break___3;
        }
        {
#line 525
        tmp___11 = tpt_regexec(t->content_re, *(e->dcont + i));
        }
#line 525
        if (tmp___11) {
#line 526
          match = 1;
#line 527
          goto while_break___3;
        }
#line 524
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 530
      if (! match) {
#line 530
        goto __Cont;
      }
    }
#line 536
    if (t->use_id) {
#line 537
      if (t->use_id < 0) {
#line 537
        return (& NullTrans);
      }
#line 539
      if (t->use_trans) {
#line 539
        return (t->use_trans);
      }
#line 540
      tt = TrSpecs;
      {
#line 540
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 540
        if (! tt) {
#line 540
          goto while_break___4;
        }
#line 541
        if (t->use_id == tt->my_id) {
#line 543
          t->use_trans = tt;
#line 544
          return (t->use_trans);
        }
#line 540
        tt = tt->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 547
      t->use_id = -1;
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: transpec ID (%d) not found for %s.\n",
              t->use_id, e->gi);
      }
#line 550
      return (& NullTrans);
    }
#line 553
    return (t);
    __Cont: /* CIL Label */ 
#line 405
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  t = FindTransByName((char *)"*");
  }
#line 558
  if (t) {
#line 558
    return (t);
  }
#line 560
  if (warnings) {
#line 560
    if (! specID) {
      {
#line 561
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: transpec not found for %s\n",
              e->gi);
      }
    }
  }
#line 564
  return (& NullTrans);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
Trans_t *FindTransByName(char *s ) 
{ 
  Trans_t *t ;
  int tmp ;

  {
#line 582
  t = TrSpecs;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! t) {
#line 582
      goto while_break;
    }
#line 584
    if (t->gi) {
#line 585
      if ((int )*(t->gi) != (int )*s) {
#line 585
        goto __Cont;
      }
      {
#line 586
      tmp = strcmp((char const   *)t->gi, (char const   *)s);
      }
#line 586
      if (! tmp) {
#line 586
        return (t);
      }
    }
    __Cont: /* CIL Label */ 
#line 582
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return ((Trans_t *)((void *)0));
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
Trans_t *FindTranByID(int n ) 
{ 
  Trans_t *t ;

  {
#line 603
  t = TrSpecs;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! t) {
#line 603
      goto while_break;
    }
#line 604
    if (n == t->my_id) {
#line 604
      return (t);
    }
#line 603
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return ((Trans_t *)((void *)0));
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void DoData(char *data , FILE *fp , int verbatim ) 
{ 


  {
#line 632
  if (! fp) {
#line 632
    return;
  }
  {
#line 662
  OutputString(data, fp, 1);
  }
#line 663
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void DoPI(char *pi , FILE *fp ) 
{ 
  char buf___0[250] ;
  char **tok ;
  int n ;
  Trans_t *t ;

  {
  {
#line 687
  buf___0[0] = (char )'_';
#line 688
  strcpy((char */* __restrict  */)(& buf___0[1]), (char const   */* __restrict  */)pi);
#line 689
  n = 2;
#line 690
  tok = Split(buf___0, & n, 0);
#line 691
  t = FindTransByName(*(tok + 0));
  }
#line 691
  if (t) {
#line 691
    goto _L;
  } else {
    {
#line 691
    t = FindTransByName((char *)"_*");
    }
#line 691
    if (t) {
      _L: /* CIL Label */ 
#line 693
      if (t->replace) {
        {
#line 693
        ProcesOutputSpec(t->replace, (Element_t *)0, fp, 1);
        }
      } else {
#line 695
        if (t->starttext) {
          {
#line 695
          ProcesOutputSpec(t->starttext, (Element_t *)0, fp, 1);
          }
        }
#line 696
        if (t->ignore != 2) {
#line 697
          if (n > 1) {
            {
#line 697
            OutputString(*(tok + 1), fp, 1);
            }
          }
        }
#line 698
        if (t->endtext) {
          {
#line 698
          ProcesOutputSpec(t->endtext, (Element_t *)0, fp, 1);
          }
        }
      }
#line 700
      if (t->message) {
        {
#line 700
        ProcesOutputSpec(t->message, (Element_t *)0, stderr, 0);
        }
      }
    } else {
      {
#line 705
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[%s]",
              pi);
      }
#line 706
      if (warnings) {
        {
#line 706
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unrecognized PI: [%s]\n",
                pi);
        }
      }
    }
  }
#line 708
  return;
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
static void set_and_increment(Trans_t *t , Element_t *e ) 
{ 
  Mapping_t *m ;
  int i ;
  int inc ;
  int n ;
  char *cp ;
  char buf___0[50] ;
  char ebuf[500] ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 728
  if (t->set_var) {
#line 729
    m = (t->set_var)->maps;
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
#line 729
      if (! (i < (t->set_var)->n_used)) {
#line 729
        goto while_break;
      }
      {
#line 730
      ExpandVariables((m + i)->sval, ebuf, e);
#line 731
      SetMappingNV(Variables, (m + i)->name, ebuf);
#line 729
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 736
  if (t->incr_var) {
#line 737
    m = (t->incr_var)->maps;
#line 737
    i = 0;
    {
#line 737
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 737
      if (! (i < (t->incr_var)->n_used)) {
#line 737
        goto while_break___0;
      }
      {
#line 738
      cp = FindMappingVal(Variables, (m + i)->name);
      }
#line 740
      if (! cp) {
        {
#line 740
        SetMappingNV(Variables, (m + i)->name, (char *)"1");
        }
      } else {
        {
#line 742
        tmp___1 = __ctype_b_loc();
        }
#line 742
        if ((int const   )*(*tmp___1 + (int )*cp) & 2048) {
#line 742
          goto _L;
        } else
#line 742
        if ((int )*cp == 45) {
          {
#line 742
          tmp___2 = __ctype_b_loc();
          }
#line 742
          if ((int const   )*(*tmp___2 + (int )*(cp + 1)) & 2048) {
            _L: /* CIL Label */ 
            {
#line 743
            n = atoi((char const   *)cp);
            }
#line 744
            if ((m + i)->sval) {
              {
#line 744
              tmp = __ctype_b_loc();
              }
#line 744
              if ((int const   )*(*tmp + (int )*((m + i)->sval)) & 2048) {
                {
#line 744
                inc = atoi((char const   *)(m + i)->sval);
                }
              } else {
#line 745
                inc = 1;
              }
            } else {
#line 745
              inc = 1;
            }
            {
#line 746
            sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
                    n + inc);
#line 747
            SetMappingNV(Variables, (m + i)->name, buf___0);
            }
          } else {
#line 742
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 749
        if (! *(cp + 1)) {
          {
#line 749
          tmp___0 = __ctype_b_loc();
          }
#line 749
          if ((int const   )*(*tmp___0 + (int )*cp) & 1024) {
            {
#line 750
            buf___0[0] = (char )((int )*cp + 1);
#line 751
            buf___0[1] = (char)0;
#line 752
            SetMappingNV(Variables, (m + i)->name, buf___0);
            }
          }
        }
      }
#line 737
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 757
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void TransElement(Element_t *e , FILE *fp , Trans_t *t ) 
{ 
  int i ;
  Trans_t *tp ;
  Trans_t *tp___0 ;

  {
#line 775
  if (! t) {
#line 775
    if (e) {
#line 775
      if (e->trans) {
#line 775
        t = (Trans_t *)e->trans;
      } else {
#line 775
        t = & NullTrans;
      }
    } else {
#line 775
      t = & NullTrans;
    }
  }
#line 778
  if (t->quit) {
    {
#line 779
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Quitting at location:\n");
#line 780
    PrintLocation(e, fp);
#line 781
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            t->quit);
#line 782
    exit(1);
    }
  }
#line 786
  if (t->replace) {
    {
#line 787
    ProcesOutputSpec(t->replace, e, fp, 1);
    }
#line 788
    if (t->message) {
      {
#line 788
      ProcesOutputSpec(t->message, e, stderr, 0);
      }
    }
    {
#line 789
    set_and_increment(t, e);
    }
#line 790
    return;
  }
#line 793
  if (t->starttext) {
    {
#line 793
    ProcesOutputSpec(t->starttext, e, fp, 1);
    }
  }
#line 794
  if (t->message) {
    {
#line 794
    ProcesOutputSpec(t->message, e, stderr, 0);
    }
  }
#line 797
  if (t->ignore != 1) {
#line 799
    if (e->gen_trans[0]) {
      {
#line 801
      tp = FindTranByID(e->gen_trans[0]);
      }
#line 801
      if (tp) {
#line 802
        if (tp->starttext) {
          {
#line 802
          ProcesOutputSpec(tp->starttext, e, fp, 1);
          }
        }
#line 803
        if (tp->message) {
          {
#line 803
          ProcesOutputSpec(tp->message, e, stderr, 0);
          }
        }
#line 804
        if (tp->endtext) {
          {
#line 804
          ProcesOutputSpec(tp->endtext, e, fp, 1);
          }
        }
      }
    }
#line 808
    i = 0;
    {
#line 808
    while (1) {
      while_continue: /* CIL Label */ ;
#line 808
      if (! (i < e->ncont)) {
#line 808
        goto while_break;
      }
#line 809
      if ((int )(e->cont + i)->type == 40) {
#line 810
        if (t->ignore != 3) {
          {
#line 811
          TransElement((e->cont + i)->ch.elem, fp, (Trans_t *)((void *)0));
          }
        }
      } else
#line 813
      if ((int )(e->cont + i)->type == 45) {
#line 814
        if (t->ignore != 2) {
          {
#line 815
          DoData((e->cont + i)->ch.data, fp, t->verbatim);
          }
        }
      } else
#line 817
      if ((int )(e->cont + i)->type == 63) {
        {
#line 818
        DoPI((e->cont + i)->ch.data, fp);
        }
      }
#line 808
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 821
    if (e->gen_trans[1]) {
      {
#line 823
      tp___0 = FindTranByID(e->gen_trans[1]);
      }
#line 823
      if (tp___0) {
#line 824
        if (tp___0->starttext) {
          {
#line 824
          ProcesOutputSpec(tp___0->starttext, e, fp, 1);
          }
        }
#line 825
        if (tp___0->message) {
          {
#line 825
          ProcesOutputSpec(tp___0->message, e, stderr, 0);
          }
        }
#line 826
        if (tp___0->endtext) {
          {
#line 826
          ProcesOutputSpec(tp___0->endtext, e, fp, 1);
          }
        }
      }
    }
  }
  {
#line 831
  set_and_increment(t, e);
  }
#line 833
  if (t->endtext) {
    {
#line 833
    ProcesOutputSpec(t->endtext, e, fp, 1);
    }
  }
#line 835
  e->processed = 1;
#line 836
  return;
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
int CheckRelation(Element_t *e , char *relname , char *related , char *actname , FILE *fp ,
                  RelAction_t flag ) 
{ 
  Element_t *ep ;
  Relation_t r ;

  {
  {
#line 866
  r = FindRelByName(relname);
  }
#line 866
  if ((unsigned int )r == 11U) {
#line 866
    return (0);
  }
  {
#line 867
  ep = QRelation(e, related, r);
  }
#line 867
  if (! ep) {
#line 867
    return (0);
  }
#line 869
  if (! actname) {
#line 869
    return (1);
  }
  {
#line 872
  if ((unsigned int )flag == 1U) {
#line 872
    goto case_1;
  }
#line 873
  if ((unsigned int )flag == 0U) {
#line 873
    goto case_0;
  }
#line 871
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 872
  TranTByAction(ep, actname, fp);
  }
#line 872
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 873
  TranTByAction(e, actname, fp);
  }
#line 873
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 875
  return (1);
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void TranByAction(Element_t *e , int n , FILE *fp ) 
{ 
  Trans_t *t ;

  {
  {
#line 895
  t = FindTranByID(n);
  }
#line 896
  if (! t) {
    {
#line 897
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not find named action for %d.\n",
            n);
    }
#line 898
    return;
  }
  {
#line 900
  TransElement(e, fp, t);
  }
#line 901
  return;
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/translate.c"
void TranTByAction(Element_t *e , char *strn , FILE *fp ) 
{ 
  int n ;
  Trans_t *t ;
  size_t tmp ;

  {
  {
#line 922
  n = atoi((char const   *)strn);
#line 923
  tmp = strlen((char const   *)strn);
  }
#line 923
  if ((int )*(strn + (tmp - 1UL)) != 116) {
    {
#line 924
    t = FindTranByID(n);
    }
#line 925
    if (! t) {
      {
#line 926
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not find named action for %d.\n",
              n);
      }
#line 927
      return;
    }
  } else {
    {
#line 930
    t = FindTrans(e, n);
    }
#line 931
    if (! t) {
#line 932
      return;
    } else
#line 931
    if (! t->my_id) {
#line 932
      return;
    }
  }
  {
#line 934
  TransElement(e, fp, t);
  }
#line 935
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/masterVersion.c"
char _HeadVeRsIoN_[62]  = 
#line 3 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/masterVersion.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'m',      (char )'a',      (char )'s', 
        (char )'t',      (char )'e',      (char )'r',      (char )'V', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )'c', 
        (char )',',      (char )'v',      (char )' ',      (char )'1', 
        (char )'.',      (char )'1',      (char )'.',      (char )'1', 
        (char )'.',      (char )'1',      (char )' ',      (char )'1', 
        (char )'9',      (char )'9',      (char )'8',      (char )'/', 
        (char )'1',      (char )'1',      (char )'/',      (char )'1', 
        (char )'3',      (char )' ',      (char )'2',      (char )'1', 
        (char )':',      (char )'3',      (char )'1',      (char )':', 
        (char )'5',      (char )'9',      (char )' ',      (char )'d', 
        (char )'b',      (char )'3',      (char )'l',      (char )' ', 
        (char )'E',      (char )'x',      (char )'p',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regparse  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static int regnpar  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char regdummy  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regcode  ;
#line 153 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static long regsize  ;
#line 161
static char *reg(int paren , int *flagp ) ;
#line 162
static char *regbranch(int *flagp ) ;
#line 163
static char *regpiece(int *flagp ) ;
#line 164
static char *regatom(int *flagp ) ;
#line 165
static char *regnode(char op ) ;
#line 166
static char *regnext(char *p ) ;
#line 167
static void regc(char b ) ;
#line 168
static void reginsert(char op , char *opnd ) ;
#line 169
static void regtail(char *p , char *val ) ;
#line 170
static void regoptail(char *p , char *val ) ;
#line 190 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
regexp *tpt_regcomp(char *exp ) 
{ 
  register regexp *r ;
  register char *scan ;
  register char *longest ;
  register int len ;
  int flags ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 200
  if ((unsigned long )exp == (unsigned long )((void *)0)) {
    {
#line 201
    tpt_regerror("NULL argument");
    }
#line 201
    return ((regexp *)((void *)0));
  }
  {
#line 204
  regparse = exp;
#line 205
  regnpar = 1;
#line 206
  regsize = 0L;
#line 207
  regcode = & regdummy;
#line 208
  regc(156);
#line 209
  tmp = reg(0, & flags);
  }
#line 209
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 210
    return ((regexp *)((void *)0));
  }
#line 213
  if (regsize >= 32767L) {
    {
#line 214
    tpt_regerror("regexp too big");
    }
#line 214
    return ((regexp *)((void *)0));
  }
  {
#line 217
  tmp___0 = (int )malloc(sizeof(regexp ) + (unsigned long )((unsigned int )regsize));
#line 217
  r = (regexp *)tmp___0;
  }
#line 218
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 219
    tpt_regerror("out of space");
    }
#line 219
    return ((regexp *)((void *)0));
  }
  {
#line 222
  regparse = exp;
#line 223
  regnpar = 1;
#line 224
  regcode = r->program;
#line 225
  regc(156);
#line 226
  tmp___1 = reg(0, & flags);
  }
#line 226
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 227
    return ((regexp *)((void *)0));
  }
  {
#line 230
  r->regstart = (char )'\000';
#line 231
  r->reganch = (char)0;
#line 232
  r->regmust = (char *)((void *)0);
#line 233
  r->regmlen = 0;
#line 234
  scan = r->program + 1;
#line 235
  tmp___4 = regnext(scan);
  }
#line 235
  if ((int )*tmp___4 == 0) {
#line 236
    scan += 3;
#line 239
    if ((int )*scan == 8) {
#line 240
      r->regstart = *(scan + 3);
    } else
#line 241
    if ((int )*scan == 1) {
#line 242
      r->reganch = (char )((int )r->reganch + 1);
    }
#line 252
    if (flags & 4) {
#line 253
      longest = (char *)((void *)0);
#line 254
      len = 0;
      {
#line 255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 255
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 255
          goto while_break;
        }
#line 256
        if ((int )*scan == 8) {
          {
#line 256
          tmp___3 = strlen((char const   *)(scan + 3));
          }
#line 256
          if (tmp___3 >= (size_t )len) {
            {
#line 257
            longest = scan + 3;
#line 258
            tmp___2 = strlen((char const   *)(scan + 3));
#line 258
            len = (int )tmp___2;
            }
          }
        }
        {
#line 255
        scan = regnext(scan);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 260
      r->regmust = longest;
#line 261
      r->regmlen = len;
    }
  }
#line 265
  return (r);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *reg(int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
#line 288
  *flagp = 1;
#line 291
  if (paren) {
#line 292
    if (regnpar >= 10) {
      {
#line 293
      tpt_regerror("too many ()");
      }
#line 293
      return ((char *)((void *)0));
    }
    {
#line 294
    parno = regnpar;
#line 295
    regnpar ++;
#line 296
    ret = regnode(20 + parno);
    }
  } else {
#line 298
    ret = (char *)((void *)0);
  }
  {
#line 301
  br = regbranch(& flags);
  }
#line 302
  if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 303
    return ((char *)((void *)0));
  }
#line 304
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 305
    regtail(ret, br);
    }
  } else {
#line 307
    ret = br;
  }
#line 308
  if (! (flags & 1)) {
#line 309
    *flagp &= -2;
  }
#line 310
  *flagp |= flags & 4;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! ((int )*regparse == 124)) {
#line 311
      goto while_break;
    }
    {
#line 312
    regparse ++;
#line 313
    br = regbranch(& flags);
    }
#line 314
    if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 315
      return ((char *)((void *)0));
    }
    {
#line 316
    regtail(ret, br);
    }
#line 317
    if (! (flags & 1)) {
#line 318
      *flagp &= -2;
    }
#line 319
    *flagp |= flags & 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (paren) {
#line 323
    tmp = 30 + parno;
  } else {
#line 323
    tmp = 0;
  }
  {
#line 323
  ender = regnode(tmp);
#line 324
  regtail(ret, ender);
#line 327
  br = ret;
  }
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
#line 327
      goto while_break___0;
    }
    {
#line 328
    regoptail(br, ender);
#line 327
    br = regnext(br);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 331
  if (paren) {
#line 331
    tmp___0 = regparse;
#line 331
    regparse ++;
#line 331
    if ((int )*tmp___0 != 41) {
      {
#line 332
      tpt_regerror("unmatched ()");
      }
#line 332
      return ((char *)((void *)0));
    } else {
#line 331
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 333
  if (! paren) {
#line 333
    if ((int )*regparse != 0) {
#line 334
      if ((int )*regparse == 41) {
        {
#line 335
        tpt_regerror("unmatched ()");
        }
#line 335
        return ((char *)((void *)0));
      } else {
        {
#line 337
        tpt_regerror("junk on end");
        }
#line 337
        return ((char *)((void *)0));
      }
    }
  }
#line 341
  return (ret);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regbranch(int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;

  {
  {
#line 358
  *flagp = 0;
#line 360
  ret = regnode(6);
#line 361
  chain = (char *)((void *)0);
  }
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if ((int )*regparse != 0) {
#line 362
      if ((int )*regparse != 124) {
#line 362
        if (! ((int )*regparse != 41)) {
#line 362
          goto while_break;
        }
      } else {
#line 362
        goto while_break;
      }
    } else {
#line 362
      goto while_break;
    }
    {
#line 363
    latest = regpiece(& flags);
    }
#line 364
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
#line 365
      return ((char *)((void *)0));
    }
#line 366
    *flagp |= flags & 1;
#line 367
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 368
      *flagp |= flags & 4;
    } else {
      {
#line 370
      regtail(chain, latest);
      }
    }
#line 371
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 374
    regnode(9);
    }
  }
#line 376
  return (ret);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regpiece(int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 397
  ret = regatom(& flags);
  }
#line 398
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 399
    return ((char *)((void *)0));
  }
#line 401
  op = *regparse;
#line 402
  if (! ((int )op == 42)) {
#line 402
    if (! ((int )op == 43)) {
#line 402
      if (! ((int )op == 63)) {
#line 403
        *flagp = flags;
#line 404
        return (ret);
      }
    }
  }
#line 407
  if (! (flags & 1)) {
#line 407
    if ((int )op != 63) {
      {
#line 408
      tpt_regerror("*+ operand could be empty");
      }
#line 408
      return ((char *)((void *)0));
    }
  }
#line 409
  if ((int )op != 43) {
#line 409
    *flagp = 4;
  } else {
#line 409
    *flagp = 1;
  }
#line 411
  if ((int )op == 42) {
#line 411
    if (flags & 2) {
      {
#line 412
      reginsert(10, ret);
      }
    } else {
#line 411
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 413
  if ((int )op == 42) {
    {
#line 415
    reginsert(6, ret);
#line 416
    tmp = regnode(7);
#line 416
    regoptail(ret, tmp);
#line 417
    regoptail(ret, ret);
#line 418
    tmp___0 = regnode(6);
#line 418
    regtail(ret, tmp___0);
#line 419
    tmp___1 = regnode(9);
#line 419
    regtail(ret, tmp___1);
    }
  } else
#line 420
  if ((int )op == 43) {
#line 420
    if (flags & 2) {
      {
#line 421
      reginsert(11, ret);
      }
    } else {
#line 420
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 422
  if ((int )op == 43) {
    {
#line 424
    next = regnode(6);
#line 425
    regtail(ret, next);
#line 426
    tmp___2 = regnode(7);
#line 426
    regtail(tmp___2, ret);
#line 427
    tmp___3 = regnode(6);
#line 427
    regtail(next, tmp___3);
#line 428
    tmp___4 = regnode(9);
#line 428
    regtail(ret, tmp___4);
    }
  } else
#line 429
  if ((int )op == 63) {
    {
#line 431
    reginsert(6, ret);
#line 432
    tmp___5 = regnode(6);
#line 432
    regtail(ret, tmp___5);
#line 433
    next = regnode(9);
#line 434
    regtail(ret, next);
#line 435
    regoptail(ret, next);
    }
  }
#line 437
  regparse ++;
#line 438
  if ((int )*regparse == 42) {
    {
#line 439
    tpt_regerror("nested *?+");
    }
#line 439
    return ((char *)((void *)0));
  } else
#line 438
  if ((int )*regparse == 43) {
    {
#line 439
    tpt_regerror("nested *?+");
    }
#line 439
    return ((char *)((void *)0));
  } else
#line 438
  if ((int )*regparse == 63) {
    {
#line 439
    tpt_regerror("nested *?+");
    }
#line 439
    return ((char *)((void *)0));
  }
#line 441
  return (ret);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regatom(int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int class ;
  register int classend ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register int len ;
  register char ender ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 459
  *flagp = 0;
#line 461
  tmp = regparse;
#line 461
  regparse ++;
  {
#line 462
  if ((int )*tmp == 94) {
#line 462
    goto case_94;
  }
#line 465
  if ((int )*tmp == 36) {
#line 465
    goto case_36;
  }
#line 468
  if ((int )*tmp == 46) {
#line 468
    goto case_46;
  }
#line 472
  if ((int )*tmp == 91) {
#line 472
    goto case_91;
  }
#line 507
  if ((int )*tmp == 40) {
#line 507
    goto case_40;
  }
#line 515
  if ((int )*tmp == 41) {
#line 515
    goto case_41;
  }
#line 515
  if ((int )*tmp == 124) {
#line 515
    goto case_41;
  }
#line 515
  if ((int )*tmp == 0) {
#line 515
    goto case_41;
  }
#line 520
  if ((int )*tmp == 42) {
#line 520
    goto case_42;
  }
#line 520
  if ((int )*tmp == 43) {
#line 520
    goto case_42;
  }
#line 520
  if ((int )*tmp == 63) {
#line 520
    goto case_42;
  }
#line 523
  if ((int )*tmp == 92) {
#line 523
    goto case_92;
  }
#line 531
  goto switch_default;
  case_94: /* CIL Label */ 
  {
#line 463
  ret = regnode(1);
  }
#line 464
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 466
  ret = regnode(2);
  }
#line 467
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 469
  ret = regnode(3);
#line 470
  *flagp |= 3;
  }
#line 471
  goto switch_break;
  case_91: /* CIL Label */ 
#line 476
  if ((int )*regparse == 94) {
    {
#line 477
    ret = regnode(5);
#line 478
    regparse ++;
    }
  } else {
    {
#line 480
    ret = regnode(4);
    }
  }
#line 481
  if ((int )*regparse == 93) {
    {
#line 482
    tmp___0 = regparse;
#line 482
    regparse ++;
#line 482
    regc((int )*tmp___0);
    }
  } else
#line 481
  if ((int )*regparse == 45) {
    {
#line 482
    tmp___0 = regparse;
#line 482
    regparse ++;
#line 482
    regc((int )*tmp___0);
    }
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if ((int )*regparse != 0) {
#line 483
      if (! ((int )*regparse != 93)) {
#line 483
        goto while_break;
      }
    } else {
#line 483
      goto while_break;
    }
#line 484
    if ((int )*regparse == 45) {
#line 485
      regparse ++;
#line 486
      if ((int )*regparse == 93) {
        {
#line 487
        regc('-');
        }
      } else
#line 486
      if ((int )*regparse == 0) {
        {
#line 487
        regc('-');
        }
      } else {
#line 489
        class = (int )*((unsigned char *)(regparse - 2)) + 1;
#line 490
        classend = (int )*((unsigned char *)regparse);
#line 491
        if (class > classend + 1) {
          {
#line 492
          tpt_regerror("invalid [] range");
          }
#line 492
          return ((char *)((void *)0));
        }
        {
#line 493
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 493
          if (! (class <= classend)) {
#line 493
            goto while_break___0;
          }
          {
#line 494
          regc(class);
#line 493
          class ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 495
        regparse ++;
      }
    } else {
      {
#line 498
      tmp___1 = regparse;
#line 498
      regparse ++;
#line 498
      regc((int )*tmp___1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  regc('\000');
  }
#line 501
  if ((int )*regparse != 93) {
    {
#line 502
    tpt_regerror("unmatched []");
    }
#line 502
    return ((char *)((void *)0));
  }
#line 503
  regparse ++;
#line 504
  *flagp |= 3;
#line 506
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 508
  ret = reg(1, & flags);
  }
#line 509
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 510
    return ((char *)((void *)0));
  }
#line 511
  *flagp |= flags & 5;
#line 512
  goto switch_break;
  case_41: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 516
  tpt_regerror("internal urp");
  }
#line 516
  return ((char *)((void *)0));
#line 517
  goto switch_break;
  case_42: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_63: /* CIL Label */ 
  {
#line 521
  tpt_regerror("?+* follows nothing");
  }
#line 521
  return ((char *)((void *)0));
#line 522
  goto switch_break;
  case_92: /* CIL Label */ 
#line 524
  if ((int )*regparse == 0) {
    {
#line 525
    tpt_regerror("trailing \\");
    }
#line 525
    return ((char *)((void *)0));
  }
  {
#line 526
  ret = regnode(8);
#line 527
  tmp___2 = regparse;
#line 527
  regparse ++;
#line 527
  regc((int )*tmp___2);
#line 528
  regc('\000');
#line 529
  *flagp |= 3;
  }
#line 530
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 535
  regparse --;
#line 536
  tmp___3 = strcspn((char const   *)regparse, "^$.[()|?+*\\");
#line 536
  len = (int )tmp___3;
  }
#line 537
  if (len <= 0) {
    {
#line 538
    tpt_regerror("internal disaster");
    }
#line 538
    return ((char *)((void *)0));
  }
#line 539
  ender = *(regparse + len);
#line 540
  if (len > 1) {
#line 540
    if ((int )ender == 42) {
#line 541
      len --;
    } else
#line 540
    if ((int )ender == 43) {
#line 541
      len --;
    } else
#line 540
    if ((int )ender == 63) {
#line 541
      len --;
    }
  }
#line 542
  *flagp |= 1;
#line 543
  if (len == 1) {
#line 544
    *flagp |= 2;
  }
  {
#line 545
  ret = regnode(8);
  }
  {
#line 546
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 546
    if (! (len > 0)) {
#line 546
      goto while_break___1;
    }
    {
#line 547
    tmp___4 = regparse;
#line 547
    regparse ++;
#line 547
    regc((int )*tmp___4);
#line 548
    len --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 550
  regc('\000');
  }
#line 552
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 555
  return (ret);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regnode(char op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 568
  ret = regcode;
#line 569
  if ((unsigned long )ret == (unsigned long )(& regdummy)) {
#line 570
    regsize += 3L;
#line 571
    return (ret);
  }
#line 574
  ptr = ret;
#line 575
  tmp = ptr;
#line 575
  ptr ++;
#line 575
  *tmp = op;
#line 576
  tmp___0 = ptr;
#line 576
  ptr ++;
#line 576
  *tmp___0 = (char )'\000';
#line 577
  tmp___1 = ptr;
#line 577
  ptr ++;
#line 577
  *tmp___1 = (char )'\000';
#line 578
  regcode = ptr;
#line 580
  return (ret);
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static void regc(char b ) 
{ 
  char *tmp ;

  {
#line 590
  if ((unsigned long )regcode != (unsigned long )(& regdummy)) {
#line 591
    tmp = regcode;
#line 591
    regcode ++;
#line 591
    *tmp = b;
  } else {
#line 593
    regsize ++;
  }
#line 594
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static void reginsert(char op , char *opnd ) 
{ 
  register char *src ;
  register char *dst ;
  register char *place ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 610
  if ((unsigned long )regcode == (unsigned long )(& regdummy)) {
#line 611
    regsize += 3L;
#line 612
    return;
  }
#line 615
  src = regcode;
#line 616
  regcode += 3;
#line 617
  dst = regcode;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! ((unsigned long )src > (unsigned long )opnd)) {
#line 618
      goto while_break;
    }
#line 619
    dst --;
#line 619
    src --;
#line 619
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  place = opnd;
#line 622
  tmp = place;
#line 622
  place ++;
#line 622
  *tmp = op;
#line 623
  tmp___0 = place;
#line 623
  place ++;
#line 623
  *tmp___0 = (char )'\000';
#line 624
  tmp___1 = place;
#line 624
  place ++;
#line 624
  *tmp___1 = (char )'\000';
#line 625
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static void regtail(char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
#line 639
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 640
    return;
  }
#line 643
  scan = p;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 645
    temp = regnext(scan);
    }
#line 646
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 647
      goto while_break;
    }
#line 648
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if ((int )*scan == 7) {
#line 652
    offset = (int )(scan - val);
  } else {
#line 654
    offset = (int )(val - scan);
  }
#line 655
  *(scan + 1) = (char )((offset >> 8) & 255);
#line 656
  *(scan + 2) = (char )(offset & 255);
#line 657
  return;
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static void regoptail(char *p , char *val ) 
{ 


  {
#line 668
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 669
    return;
  } else
#line 668
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 669
    return;
  } else
#line 668
  if ((int )*p != 6) {
#line 669
    return;
  }
  {
#line 670
  regtail(p + 3, val);
  }
#line 671
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *reginput  ;
#line 681 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regbol  ;
#line 682 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char **regstartp  ;
#line 683 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char **regendp  ;
#line 688
static int regtry(regexp *prog , char *string ) ;
#line 689
static int regmatch(char *prog ) ;
#line 690
static int regrepeat(char *p ) ;
#line 701 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
int tpt_regexec(regexp *prog , char *string ) 
{ 
  register char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 709
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
#line 710
    tpt_regerror("NULL parameter");
    }
#line 711
    return (0);
  } else
#line 709
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 710
    tpt_regerror("NULL parameter");
    }
#line 711
    return (0);
  }
#line 715
  if ((int )*((unsigned char *)(prog->program)) != 156) {
    {
#line 716
    tpt_regerror("corrupted program");
    }
#line 717
    return (0);
  }
#line 721
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
#line 722
    s = string;
    {
#line 723
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 723
      s = strchr((char const   *)s, (int )*(prog->regmust + 0));
      }
#line 723
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 723
        goto while_break;
      }
      {
#line 724
      tmp = strncmp((char const   *)s, (char const   *)prog->regmust, (size_t )prog->regmlen);
      }
#line 724
      if (tmp == 0) {
#line 725
        goto while_break;
      }
#line 726
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 728
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 729
      return (0);
    }
  }
#line 733
  regbol = string;
#line 736
  if (prog->reganch) {
    {
#line 737
    tmp___0 = regtry(prog, string);
    }
#line 737
    return (tmp___0);
  }
#line 740
  s = string;
#line 741
  if ((int )prog->regstart != 0) {
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 743
      s = strchr((char const   *)s, (int )prog->regstart);
      }
#line 743
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 743
        goto while_break___0;
      }
      {
#line 744
      tmp___1 = regtry(prog, s);
      }
#line 744
      if (tmp___1) {
#line 745
        return (1);
      }
#line 746
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 750
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 751
      tmp___2 = regtry(prog, s);
      }
#line 751
      if (tmp___2) {
#line 752
        return (1);
      }
#line 750
      tmp___3 = s;
#line 750
      s ++;
#line 750
      if (! ((int )*tmp___3 != 0)) {
#line 750
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 756
  return (0);
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static int regtry(regexp *prog , char *string ) 
{ 
  register int i ;
  register char **sp ;
  register char **ep ;
  char **tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
#line 771
  reginput = string;
#line 772
  regstartp = prog->startp;
#line 773
  regendp = prog->endp;
#line 775
  sp = prog->startp;
#line 776
  ep = prog->endp;
#line 777
  i = 10;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! (i > 0)) {
#line 777
      goto while_break;
    }
#line 778
    tmp = sp;
#line 778
    sp ++;
#line 778
    *tmp = (char *)((void *)0);
#line 779
    tmp___0 = ep;
#line 779
    ep ++;
#line 779
    *tmp___0 = (char *)((void *)0);
#line 777
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 781
  tmp___1 = regmatch(prog->program + 1);
  }
#line 781
  if (tmp___1) {
#line 782
    prog->startp[0] = string;
#line 783
    prog->endp[0] = reginput;
#line 784
    return (1);
  } else {
#line 786
    return (0);
  }
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static int regmatch(char *prog ) 
{ 
  register char *scan ;
  char *next ;
  register int len ;
  register char *opnd ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register int no ;
  register char *save ;
  int tmp___3 ;
  register int no___0 ;
  register char *save___0 ;
  int tmp___4 ;
  register char *save___1 ;
  int tmp___5 ;
  register char nextch ;
  register int no___1 ;
  register char *save___2 ;
  register int min ;
  int tmp___6 ;

  {
#line 806
  scan = prog;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 811
      goto while_break;
    }
    {
#line 816
    next = regnext(scan);
    }
    {
#line 819
    if ((int )*scan == 1) {
#line 819
      goto case_1;
    }
#line 823
    if ((int )*scan == 2) {
#line 823
      goto case_2;
    }
#line 827
    if ((int )*scan == 3) {
#line 827
      goto case_3;
    }
#line 832
    if ((int )*scan == 8) {
#line 832
      goto case_8;
    }
#line 846
    if ((int )*scan == 4) {
#line 846
      goto case_4;
    }
#line 851
    if ((int )*scan == 5) {
#line 851
      goto case_5;
    }
#line 856
    if ((int )*scan == 9) {
#line 856
      goto case_9;
    }
#line 858
    if ((int )*scan == 7) {
#line 858
      goto case_7;
    }
#line 868
    if ((int )*scan == 29) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 28) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 27) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 26) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 25) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 24) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 23) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 22) {
#line 868
      goto case_29;
    }
#line 868
    if ((int )*scan == 21) {
#line 868
      goto case_29;
    }
#line 896
    if ((int )*scan == 39) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 38) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 37) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 36) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 35) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 34) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 33) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 32) {
#line 896
      goto case_39;
    }
#line 896
    if ((int )*scan == 31) {
#line 896
      goto case_39;
    }
#line 916
    if ((int )*scan == 6) {
#line 916
      goto case_6;
    }
#line 935
    if ((int )*scan == 11) {
#line 935
      goto case_11;
    }
#line 935
    if ((int )*scan == 10) {
#line 935
      goto case_11;
    }
#line 963
    if ((int )*scan == 0) {
#line 963
      goto case_0;
    }
#line 966
    goto switch_default;
    case_1: /* CIL Label */ 
#line 820
    if ((unsigned long )reginput != (unsigned long )regbol) {
#line 821
      return (0);
    }
#line 822
    goto switch_break;
    case_2: /* CIL Label */ 
#line 824
    if ((int )*reginput != 0) {
#line 825
      return (0);
    }
#line 826
    goto switch_break;
    case_3: /* CIL Label */ 
#line 828
    if ((int )*reginput == 0) {
#line 829
      return (0);
    }
#line 830
    reginput ++;
#line 831
    goto switch_break;
    case_8: /* CIL Label */ 
#line 836
    opnd = scan + 3;
#line 838
    if ((int )*opnd != (int )*reginput) {
#line 839
      return (0);
    }
    {
#line 840
    tmp = strlen((char const   *)opnd);
#line 840
    len = (int )tmp;
    }
#line 841
    if (len > 1) {
      {
#line 841
      tmp___0 = strncmp((char const   *)opnd, (char const   *)reginput, (size_t )len);
      }
#line 841
      if (tmp___0 != 0) {
#line 842
        return (0);
      }
    }
#line 843
    reginput += len;
#line 845
    goto switch_break;
    case_4: /* CIL Label */ 
#line 847
    if ((int )*reginput == 0) {
#line 848
      return (0);
    } else {
      {
#line 847
      tmp___1 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 847
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 848
        return (0);
      }
    }
#line 849
    reginput ++;
#line 850
    goto switch_break;
    case_5: /* CIL Label */ 
#line 852
    if ((int )*reginput == 0) {
#line 853
      return (0);
    } else {
      {
#line 852
      tmp___2 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 852
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 853
        return (0);
      }
    }
#line 854
    reginput ++;
#line 855
    goto switch_break;
    case_9: /* CIL Label */ 
#line 857
    goto switch_break;
    case_7: /* CIL Label */ 
#line 859
    goto switch_break;
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 872
    no = (int )*scan - 20;
#line 873
    save = reginput;
#line 875
    tmp___3 = regmatch(next);
    }
#line 875
    if (tmp___3) {
#line 881
      if ((unsigned long )*(regstartp + no) == (unsigned long )((void *)0)) {
#line 882
        *(regstartp + no) = save;
      }
#line 883
      return (1);
    } else {
#line 885
      return (0);
    }
#line 887
    goto switch_break;
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 900
    no___0 = (int )*scan - 30;
#line 901
    save___0 = reginput;
#line 903
    tmp___4 = regmatch(next);
    }
#line 903
    if (tmp___4) {
#line 909
      if ((unsigned long )*(regendp + no___0) == (unsigned long )((void *)0)) {
#line 910
        *(regendp + no___0) = save___0;
      }
#line 911
      return (1);
    } else {
#line 913
      return (0);
    }
#line 915
    goto switch_break;
    case_6: /* CIL Label */ 
#line 919
    if ((int )*next != 6) {
#line 920
      next = scan + 3;
    } else {
      {
#line 922
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 923
        save___1 = reginput;
#line 924
        tmp___5 = regmatch(scan + 3);
        }
#line 924
        if (tmp___5) {
#line 925
          return (1);
        }
        {
#line 926
        reginput = save___1;
#line 927
        scan = regnext(scan);
        }
#line 922
        if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 922
          if (! ((int )*scan == 6)) {
#line 922
            goto while_break___0;
          }
        } else {
#line 922
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 929
      return (0);
    }
#line 933
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 945
    nextch = (char )'\000';
#line 946
    if ((int )*next == 8) {
#line 947
      nextch = *(next + 3);
    }
#line 948
    if ((int )*scan == 10) {
#line 948
      min = 0;
    } else {
#line 948
      min = 1;
    }
    {
#line 949
    save___2 = reginput;
#line 950
    no___1 = regrepeat(scan + 3);
    }
    {
#line 951
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 951
      if (! (no___1 >= min)) {
#line 951
        goto while_break___1;
      }
#line 953
      if ((int )nextch == 0) {
#line 953
        goto _L;
      } else
#line 953
      if ((int )*reginput == (int )nextch) {
        _L: /* CIL Label */ 
        {
#line 954
        tmp___6 = regmatch(next);
        }
#line 954
        if (tmp___6) {
#line 955
          return (1);
        }
      }
#line 957
      no___1 --;
#line 958
      reginput = save___2 + no___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 960
    return (0);
#line 962
    goto switch_break;
    case_0: /* CIL Label */ 
#line 964
    return (1);
#line 965
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 967
    tpt_regerror("memory corruption");
    }
#line 968
    return (0);
#line 969
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 972
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 979
  tpt_regerror("corrupted pointers");
  }
#line 980
  return (0);
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static int regrepeat(char *p ) 
{ 
  register int count ;
  register char *scan ;
  register char *opnd ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 990
  count = 0;
#line 994
  scan = reginput;
#line 995
  opnd = p + 3;
  {
#line 997
  if ((int )*p == 3) {
#line 997
    goto case_3;
  }
#line 1001
  if ((int )*p == 8) {
#line 1001
    goto case_8;
  }
#line 1007
  if ((int )*p == 4) {
#line 1007
    goto case_4;
  }
#line 1013
  if ((int )*p == 5) {
#line 1013
    goto case_5;
  }
#line 1019
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 998
  tmp = strlen((char const   *)scan);
#line 998
  count = (int )tmp;
#line 999
  scan += count;
  }
#line 1000
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! ((int )*opnd == (int )*scan)) {
#line 1002
      goto while_break;
    }
#line 1003
    count ++;
#line 1004
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1006
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1008
    if ((int )*scan != 0) {
      {
#line 1008
      tmp___0 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1008
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1008
        goto while_break___0;
      }
    } else {
#line 1008
      goto while_break___0;
    }
#line 1009
    count ++;
#line 1010
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1012
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1014
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1014
    if ((int )*scan != 0) {
      {
#line 1014
      tmp___1 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1014
      if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 1014
        goto while_break___1;
      }
    } else {
#line 1014
      goto while_break___1;
    }
#line 1015
    count ++;
#line 1016
    scan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1018
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1020
  tpt_regerror("internal foulup");
#line 1021
  count = 0;
  }
#line 1022
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1024
  reginput = scan;
#line 1026
  return (count);
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regexp.c"
static char *regnext(char *p ) 
{ 
  register int offset ;

  {
#line 1038
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 1039
    return ((char *)((void *)0));
  }
#line 1041
  offset = (((int )*(p + 1) & 255) << 8) + ((int )*(p + 2) & 255);
#line 1042
  if (offset == 0) {
#line 1043
    return ((char *)((void *)0));
  }
#line 1045
  if ((int )*p == 7) {
#line 1046
    return (p - offset);
  } else {
#line 1048
    return (p + offset);
  }
}
}
#line 20 "./tptregexp.h"
void tpt_regsub(regexp *prog , char *source , char *dest ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regsub.c"
extern char *strncpy() ;
#line 34 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/tptregexp/regsub.c"
void tpt_regsub(regexp *prog , char *source , char *dest ) 
{ 
  register char *src ;
  register char *dst ;
  register char c ;
  register int no ;
  register int len ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 47
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
#line 48
    tpt_regerror("NULL parm to regsub");
    }
#line 49
    return;
  } else
#line 47
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 48
    tpt_regerror("NULL parm to regsub");
    }
#line 49
    return;
  } else
#line 47
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    {
#line 48
    tpt_regerror("NULL parm to regsub");
    }
#line 49
    return;
  }
#line 51
  if ((int )*((unsigned char *)(prog->program)) != 156) {
    {
#line 52
    tpt_regerror("damaged regexp fed to regsub");
    }
#line 53
    return;
  }
#line 56
  src = source;
#line 57
  dst = dest;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    tmp___2 = src;
#line 58
    src ++;
#line 58
    c = *tmp___2;
#line 58
    if (! ((int )c != 0)) {
#line 58
      goto while_break;
    }
#line 59
    if ((int )c == 38) {
#line 60
      no = 0;
    } else
#line 61
    if ((int )c == 92) {
#line 61
      if (48 <= (int )*src) {
#line 61
        if ((int )*src <= 57) {
#line 62
          tmp = src;
#line 62
          src ++;
#line 62
          no = (int )*tmp - 48;
        } else {
#line 64
          no = -1;
        }
      } else {
#line 64
        no = -1;
      }
    } else {
#line 64
      no = -1;
    }
#line 66
    if (no < 0) {
#line 67
      if ((int )c == 92) {
#line 67
        if ((int )*src == 92) {
#line 68
          tmp___0 = src;
#line 68
          src ++;
#line 68
          c = *tmp___0;
        } else
#line 67
        if ((int )*src == 38) {
#line 68
          tmp___0 = src;
#line 68
          src ++;
#line 68
          c = *tmp___0;
        }
      }
#line 69
      tmp___1 = dst;
#line 69
      dst ++;
#line 69
      *tmp___1 = c;
    } else
#line 70
    if ((unsigned long )prog->startp[no] != (unsigned long )((void *)0)) {
#line 70
      if ((unsigned long )prog->endp[no] != (unsigned long )((void *)0)) {
        {
#line 71
        len = (int )(prog->endp[no] - prog->startp[no]);
#line 72
        strncpy(dst, prog->startp[no], len);
#line 73
        dst += len;
        }
#line 74
        if (len != 0) {
#line 74
          if ((int )*(dst - 1) == 0) {
            {
#line 75
            tpt_regerror("damaged match string");
            }
#line 76
            return;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  tmp___3 = dst;
#line 80
  dst ++;
#line 80
  *tmp___3 = (char )'\000';
#line 81
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 217 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Element_t *DocTree  ;
#line 218 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
char **UsedElem  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int nUsedElem  ;
#line 220 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
char **UsedAtt  ;
#line 221 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int nUsedAtt  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
ID_t *IDList  ;
#line 223 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Map_t *Variables  ;
#line 224 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Map_t *SDATAmap  ;
#line 225 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Map_t *PImap  ;
#line 226 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
Entity_t *Entities  ;
#line 228 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
FILE *outfp  ;
#line 229 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
char *tpt_lib  ;
#line 230 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int verbose  ;
#line 231 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int warnings  ;
#line 232 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int interactive  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int slave  ;
#line 234 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int fold_case  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/general.h"
int xml_mode  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_context  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_tree  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_summ  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_stats  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_validate  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_idlist  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int do_DATAhack  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *this_prog  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *in_file  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *out_file  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *tranfile  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *cmapfile  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *sdatafile  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *start_id  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *last_file  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int last_lineno  ;
#line 116
static void HandleArgs(int ac , char **av ) ;
#line 117
static void Initialize1(char *myname ) ;
#line 118
static void Initialize2(void) ;
#line 119
static void ReadInstance(char *filename ) ;
#line 120
static void DoHelpMessage(void) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
int main(int ac , char **av ) 
{ 
  Element_t *e ;

  {
  {
#line 137
  Initialize1(*(av + 0));
#line 138
  HandleArgs(ac, av);
#line 139
  Initialize2();
  }
#line 141
  if (sdatafile) {
    {
#line 141
    ReadSDATA(sdatafile);
    }
  }
#line 142
  if (cmapfile) {
    {
#line 142
    ReadCharMap(cmapfile);
    }
  }
  {
#line 144
  ReadInstance(in_file);
  }
#line 146
  if (interactive) {
    {
#line 147
    Browse();
    }
  } else {
#line 151
    if (tranfile) {
#line 155
      if (start_id) {
        {
#line 156
        e = FindElemByID(start_id);
        }
#line 156
        if (! e) {
          {
#line 157
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can not find element with ID %s\n",
                  start_id);
#line 159
          exit(1);
          }
        }
      } else {
#line 162
        e = DocTree;
      }
#line 165
      if (do_validate) {
#line 165
        outfp = (FILE *)((void *)0);
      }
      {
#line 166
      DoTranslate(e, tranfile, outfp);
      }
    }
#line 168
    if (do_summ) {
      {
#line 168
      PrintElemSummary(DocTree);
      }
    }
#line 169
    if (do_tree) {
      {
#line 169
      PrintElemTree(DocTree);
      }
    }
#line 170
    if (do_stats) {
      {
#line 170
      PrintStats(DocTree);
      }
    }
#line 171
    if (do_context) {
      {
#line 171
      PrintContext(DocTree);
      }
    }
#line 172
    if (do_idlist) {
      {
#line 172
      PrintIDList();
      }
    }
  }
#line 174
  if (out_file) {
#line 174
    if (outfp) {
      {
#line 174
      fclose(outfp);
      }
    }
  }
#line 176
  return (0);
}
}
#line 193
extern int gethostname(char * , int  ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void Initialize1(char *myname ) 
{ 
  time_t tnow ;
  struct tm *nowtm ;
  char *cp ;
  char buf___0[100] ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 196
  tpt_lib = getenv("TPT_LIB");
  }
#line 196
  if (! tpt_lib) {
#line 196
    tpt_lib = (char *)"/usr/local/share/sgml/transpec";
  }
  {
#line 199
  warnings = 1;
#line 200
  fold_case = 1;
#line 201
  this_prog = myname;
#line 202
  xml_mode = 0;
#line 205
  Variables = NewMap(20);
#line 208
  cp = getenv("USER");
  }
#line 208
  if (cp) {
#line 208
    tmp = (char const   *)cp;
  } else {
#line 208
    tmp = "UnknownUser";
  }
  {
#line 208
  SetMappingNV(Variables, (char *)"user", (char *)tmp);
#line 209
  time(& tnow);
#line 210
  nowtm = localtime((time_t const   *)(& tnow));
#line 211
  strftime((char */* __restrict  */)(buf___0), (size_t )100, (char const   */* __restrict  */)"%a %d %b %Y, %R",
           (struct tm  const  */* __restrict  */)nowtm);
#line 212
  SetMappingNV(Variables, (char *)"date", buf___0);
#line 213
  tmp___0 = gethostname(buf___0, 100);
  }
#line 213
  if (tmp___0 < 0) {
    {
#line 213
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"unknown-host");
    }
  }
  {
#line 214
  SetMappingNV(Variables, (char *)"host", buf___0);
  }
#line 215
  if (tranfile) {
#line 215
    tmp___1 = (char const   *)tranfile;
  } else {
#line 215
    tmp___1 = "??";
  }
  {
#line 215
  SetMappingNV(Variables, (char *)"transpec", (char *)tmp___1);
  }
#line 216
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void Initialize2(void) 
{ 
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 223
  if (tranfile) {
#line 223
    tmp = (char const   *)tranfile;
  } else {
#line 223
    tmp = "??";
  }
  {
#line 223
  SetMappingNV(Variables, (char *)"transpec", (char *)tmp);
  }
#line 227
  if (out_file) {
    {
#line 228
    outfp = fopen((char const   */* __restrict  */)out_file, (char const   */* __restrict  */)"w");
    }
#line 228
    if (! outfp) {
      {
#line 229
      tmp___0 = __errno_location();
#line 229
      tmp___1 = strerror(*tmp___0);
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open output \'%s\' file for writing.\n%s",
              out_file, tmp___1);
#line 231
      exit(1);
      }
    }
  } else {
#line 234
    outfp = stdout;
  }
#line 235
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void CmdLineSetVariable(char *var ) 
{ 
  char *cp ;
  char buf___0[100] ;
  char **tok ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 252
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)var);
#line 253
  cp = strchr((char const   *)(buf___0), '=');
  }
#line 253
  if (cp) {
    {
#line 255
    *cp = (char )' ';
#line 256
    n = 2;
#line 257
    tok = Split(buf___0, & n, 0);
#line 259
    tmp___2 = strcmp((char const   *)*(tok + 0), "verbose");
    }
#line 259
    if (tmp___2) {
      {
#line 260
      tmp___1 = strcmp((char const   *)*(tok + 0), "warnings");
      }
#line 260
      if (tmp___1) {
        {
#line 261
        tmp___0 = strcmp((char const   *)*(tok + 0), "foldcase");
        }
#line 261
        if (tmp___0) {
          {
#line 262
          tmp = strcmp((char const   *)*(tok + 0), "xmlmode");
          }
#line 262
          if (tmp) {
            {
#line 263
            SetMappingNV(Variables, *(tok + 0), *(tok + 1));
            }
          } else {
            {
#line 262
            xml_mode = atoi((char const   *)*(tok + 1));
            }
          }
        } else {
          {
#line 261
          fold_case = atoi((char const   *)*(tok + 1));
          }
        }
      } else {
        {
#line 260
        warnings = atoi((char const   *)*(tok + 1));
        }
      }
    } else {
      {
#line 259
      verbose = atoi((char const   *)*(tok + 1));
      }
    }
#line 265
    if (xml_mode) {
#line 265
      fold_case = 0;
    }
  } else {
    {
#line 268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected an \'=\' in variable assignment: %s. Ignored\n",
            var);
    }
  }
#line 271
  return;
}
}
#line 285
extern char *optarg ;
#line 286
extern int optind ;
#line 288
extern int ( /* missing proto */  getopt)() ;
#line 278 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void HandleArgs(int ac , char **av ) 
{ 
  int c ;
  int errflag ;

  {
#line 284
  errflag = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    c = getopt(ac, av, "df:t:vc:s:o:huSxIl:bHVWi:D:Z");
    }
#line 288
    if (! (c != -1)) {
#line 288
      goto while_break;
    }
    {
#line 290
    if (c == 116) {
#line 290
      goto case_116;
    }
#line 291
    if (c == 118) {
#line 291
      goto case_118;
    }
#line 292
    if (c == 115) {
#line 292
      goto case_115;
    }
#line 293
    if (c == 99) {
#line 293
      goto case_99;
    }
#line 294
    if (c == 104) {
#line 294
      goto case_104;
    }
#line 295
    if (c == 117) {
#line 295
      goto case_117;
    }
#line 296
    if (c == 83) {
#line 296
      goto case_83;
    }
#line 297
    if (c == 120) {
#line 297
      goto case_120;
    }
#line 298
    if (c == 73) {
#line 298
      goto case_73;
    }
#line 299
    if (c == 108) {
#line 299
      goto case_108;
    }
#line 300
    if (c == 105) {
#line 300
      goto case_105;
    }
#line 301
    if (c == 111) {
#line 301
      goto case_111;
    }
#line 302
    if (c == 100) {
#line 302
      goto case_100;
    }
#line 303
    if (c == 102) {
#line 303
      goto case_102;
    }
#line 304
    if (c == 98) {
#line 304
      goto case_98;
    }
#line 305
    if (c == 87) {
#line 305
      goto case_87;
    }
#line 306
    if (c == 86) {
#line 306
      goto case_86;
    }
#line 307
    if (c == 90) {
#line 307
      goto case_90;
    }
#line 308
    if (c == 72) {
#line 308
      goto case_72;
    }
#line 309
    if (c == 68) {
#line 309
      goto case_68;
    }
#line 310
    if (c == 63) {
#line 310
      goto case_63;
    }
#line 289
    goto switch_break;
    case_116: /* CIL Label */ 
#line 290
    tranfile = optarg;
#line 290
    goto switch_break;
    case_118: /* CIL Label */ 
#line 291
    do_validate = 1;
#line 291
    goto switch_break;
    case_115: /* CIL Label */ 
#line 292
    sdatafile = optarg;
#line 292
    goto switch_break;
    case_99: /* CIL Label */ 
#line 293
    cmapfile = optarg;
#line 293
    goto switch_break;
    case_104: /* CIL Label */ 
#line 294
    do_tree = 1;
#line 294
    goto switch_break;
    case_117: /* CIL Label */ 
#line 295
    do_summ = 1;
#line 295
    goto switch_break;
    case_83: /* CIL Label */ 
#line 296
    do_stats = 1;
#line 296
    goto switch_break;
    case_120: /* CIL Label */ 
#line 297
    do_context = 1;
#line 297
    goto switch_break;
    case_73: /* CIL Label */ 
#line 298
    do_idlist = 1;
#line 298
    goto switch_break;
    case_108: /* CIL Label */ 
#line 299
    tpt_lib = optarg;
#line 299
    goto switch_break;
    case_105: /* CIL Label */ 
#line 300
    start_id = optarg;
#line 300
    goto switch_break;
    case_111: /* CIL Label */ 
#line 301
    out_file = optarg;
#line 301
    goto switch_break;
    case_100: /* CIL Label */ 
#line 302
    do_DATAhack ++;
#line 302
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 303
    BOFTTextThresh = atoi((char const   *)optarg);
    }
#line 303
    goto switch_break;
    case_98: /* CIL Label */ 
#line 304
    interactive = 1;
#line 304
    goto switch_break;
    case_87: /* CIL Label */ 
#line 305
    warnings = 0;
#line 305
    goto switch_break;
    case_86: /* CIL Label */ 
#line 306
    verbose = 1;
#line 306
    goto switch_break;
    case_90: /* CIL Label */ 
#line 307
    slave = 1;
#line 307
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 308
    DoHelpMessage();
#line 308
    exit(0);
    }
#line 308
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 309
    CmdLineSetVariable(optarg);
    }
#line 309
    goto switch_break;
    case_63: /* CIL Label */ 
#line 310
    errflag = 1;
#line 310
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 312
    if (errflag) {
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \'%s -H\' for help.\n",
              this_prog);
#line 314
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  if (optind < ac) {
#line 319
    in_file = *(av + optind);
  }
#line 322
  if (interactive) {
#line 322
    if (! in_file) {
      {
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must specify ESIS file on cmd line for browser mode.\n");
#line 325
      exit(1);
      }
    }
  }
#line 327
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static char *help_msg[20]  = 
#line 333
  {      (char *)"",      (char *)"  -t file   Print translated output using translation spec in <file>",      (char *)"  -s file   <file> contains a list of SDATA entity mappings",      (char *)"  -c file   <file> contains a list of character mappings", 
        (char *)"  -v        Validate using translation spec specified with -t",      (char *)"  -i id     Consider only subtree starting at element with ID <id>",      (char *)"  -b        Interactive browser",      (char *)"  -S        Print statistics (how often elements occur, etc.)", 
        (char *)"  -u        Print element usage summary (# of children, depth, etc.)",      (char *)"  -x        Print context of each element",      (char *)"  -h        Print document hierarchy as a tree",      (char *)"  -o file   Write output to <file>.  Default is standard output.", 
        (char *)"  -l dir    Set library directory to <dir>. (or env. variable TPT_LIB)",      (char *)"  -I        List all IDs used in the instance",      (char *)"  -W        Do not print warning messages",      (char *)"  -H        Print this help message", 
        (char *)"  -Dvar=val Set variable \'var\' to value \'val\'",      (char *)"  file      Take input from named file.  If not specified, assume stdin.",      (char *)"            File should be output from the \'sgmls\' program (ESIS).",      (char *)((void *)0)};
#line 356 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void DoHelpMessage(void) 
{ 
  char **s ;
  char **tmp ;

  {
  {
#line 359
  s = help_msg;
#line 360
  printf((char const   */* __restrict  */)"Instant: SGML document processor/translator, Version %s\n",
         "2.0(0)-ANS");
#line 362
  printf((char const   */* __restrict  */)"usage: %s [option ...] [file]", this_prog);
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! *s) {
#line 363
      goto while_break;
    }
    {
#line 363
    tmp = s;
#line 363
    s ++;
#line 363
    puts((char const   *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static Entity_t *last_ent  ;
#line 374 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void AddEntity(Entity_t *ent ) 
{ 
  void *tmp ;
  struct _ent *tmp___0 ;
  void *tmp___1 ;

  {
#line 381
  if (! Entities) {
    {
#line 382
    tmp = malloc(sizeof(Entity_t ));
#line 382
    Entities = (Entity_t *)tmp;
    }
#line 382
    if (! Entities) {
      {
#line 382
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 382
      exit(1);
      }
    }
    {
#line 382
    memset((void *)Entities, 0, sizeof(Entity_t ));
#line 383
    last_ent = Entities;
    }
  } else {
    {
#line 386
    tmp___1 = malloc(sizeof(Entity_t ));
#line 386
    tmp___0 = (Entity_t *)tmp___1;
#line 386
    last_ent->next = tmp___0;
    }
#line 386
    if (! tmp___0) {
      {
#line 386
      perror("Malloc failed -- out of memory.  Bailing out.");
#line 386
      exit(1);
      }
    }
    {
#line 386
    memset((void *)last_ent->next, 0, sizeof(Entity_t ));
#line 387
    last_ent = last_ent->next;
    }
  }
#line 389
  *last_ent = *ent;
#line 391
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static Entity_t *FindEntity(char *ename ) 
{ 
  Entity_t *n ;
  int tmp ;

  {
#line 403
  n = Entities;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! n) {
#line 403
      goto while_break;
    }
#line 404
    if ((int )*(ename + 0) == (int )*(n->ename + 0)) {
      {
#line 404
      tmp = strcmp((char const   *)ename, (char const   *)n->ename);
      }
#line 404
      if (! tmp) {
#line 404
        return (n);
      }
    }
#line 403
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return ((Entity_t *)0);
}
}
#line 424
static Element_t *AccumElemInfo(FILE *fp ) ;
#line 424 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static int Index  =    0;
#line 425 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static Element_t *last_e  ;
#line 411 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static Element_t *AccumElemInfo(FILE *fp ) 
{ 
  char buf___0[60001] ;
  int c ;
  int i ;
  int na ;
  char *cp ;
  char *atval ;
  Mapping_t a[100] ;
  Element_t *e ;
  Entity_t ent ;
  Entity_t *ent2 ;
  char **tok ;
  void *tmp ;
  int tmp___0 ;
  char *_cp ;
  Mapping_t *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 428
  tmp = calloc((size_t )1, sizeof(Element_t ));
#line 428
  e = (Element_t *)tmp;
  }
#line 428
  if (! e) {
    {
#line 428
    perror("Calloc failed -- out of memory.  Bailing out.");
#line 428
    exit(1);
    }
  }
  {
#line 428
  memset((void *)e, 0, sizeof(Element_t ));
#line 429
  memset((void *)(& ent), 0, sizeof(ent));
  }
#line 432
  if (last_e) {
#line 432
    last_e->next = e;
  }
#line 433
  last_e = e;
#line 435
  tmp___0 = Index;
#line 435
  Index ++;
#line 435
  e->index = tmp___0;
#line 438
  e->lineno = last_lineno;
#line 439
  e->infile = last_file;
#line 441
  na = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 443
    c = _IO_getc(fp);
    }
#line 443
    if (c == -1) {
#line 443
      goto while_break;
    }
    {
#line 444
    fgets((char */* __restrict  */)(buf___0), 60000, (FILE */* __restrict  */)fp);
#line 445
    _cp = strchr((char const   *)(buf___0), '\n');
    }
#line 445
    if (_cp) {
#line 445
      *_cp = (char )'\000';
    }
    {
#line 447
    if (c == -1) {
#line 447
      goto case_neg_1;
    }
#line 452
    if (c == 40) {
#line 452
      goto case_40;
    }
#line 474
    if (c == 65) {
#line 474
      goto case_65;
    }
#line 491
    if (c == 76) {
#line 491
      goto case_76;
    }
#line 503
    if (c == 45) {
#line 503
      goto case_45;
    }
#line 513
    if (c == 63) {
#line 513
      goto case_63;
    }
#line 513
    if (c == 78) {
#line 513
      goto case_63;
    }
#line 513
    if (c == 68) {
#line 513
      goto case_63;
    }
#line 519
    if (c == 69) {
#line 519
      goto case_69;
    }
#line 527
    if (c == 73) {
#line 527
      goto case_73;
    }
#line 530
    if (c == 115) {
#line 530
      goto case_115;
    }
#line 533
    if (c == 112) {
#line 533
      goto case_112;
    }
#line 536
    if (c == 102) {
#line 536
      goto case_102;
    }
#line 547
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unexpectedly reached end of ESIS.\n");
#line 449
    exit(1);
    }
#line 450
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 453
    e->gi = AddElemName(buf___0);
    }
#line 454
    if (na > 0) {
      {
#line 455
      tmp___2 = malloc((size_t )na * sizeof(Mapping_t ));
#line 455
      tmp___1 = (Mapping_t *)tmp___2;
#line 455
      e->atts = tmp___1;
      }
#line 455
      if (! tmp___1) {
        {
#line 455
        perror("Malloc failed -- out of memory.  Bailing out.");
#line 455
        exit(1);
        }
      }
      {
#line 455
      memset((void *)e->atts, 0, sizeof(Mapping_t ));
#line 456
      memcpy((void */* __restrict  */)e->atts, (void const   */* __restrict  */)(a),
             (unsigned long )na * sizeof(Mapping_t ));
#line 457
      e->natts = na;
#line 458
      na = 0;
      }
    }
    {
#line 464
    atval = FindAttValByName(e, (char *)"NAME");
    }
#line 464
    if (atval) {
#line 464
      goto _L;
    } else {
      {
#line 464
      atval = FindAttValByName(e, (char *)"ENTITYREF");
      }
#line 464
      if (atval) {
#line 464
        goto _L;
      } else {
        {
#line 464
        atval = FindAttValByName(e, (char *)"EXTERNAL");
        }
#line 464
        if (atval) {
          _L: /* CIL Label */ 
          {
#line 464
          ent2 = FindEntity(atval);
          }
#line 464
          if (ent2) {
#line 468
            e->entity = ent2;
          }
        }
      }
    }
#line 471
    return (e);
#line 472
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 475
    i = 3;
#line 476
    tok = Split(buf___0, & i, 0);
#line 477
    tmp___3 = strcmp((char const   *)*(tok + 1), "IMPLIED");
    }
#line 477
    if (! tmp___3) {
#line 477
      goto switch_break;
    }
    {
#line 478
    tmp___4 = strcmp((char const   *)*(tok + 1), "CDATA");
    }
#line 478
    if (tmp___4) {
      {
#line 478
      tmp___5 = strcmp((char const   *)*(tok + 1), "TOKEN");
      }
#line 478
      if (tmp___5) {
        {
#line 478
        tmp___6 = strcmp((char const   *)*(tok + 1), "ENTITY");
        }
#line 478
        if (tmp___6) {
          {
#line 478
          tmp___7 = strcmp((char const   *)*(tok + 1), "NOTATION");
          }
#line 478
          if (tmp___7) {
            {
#line 486
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Bad attr line (%d): A%s %s...\n",
                    e->lineno, *(tok + 0), *(tok + 1));
            }
          } else {
            {
#line 481
            a[na].name = AddAttName(*(tok + 0));
#line 482
            a[na].sval = AddAttName(*(tok + 2));
#line 483
            na ++;
            }
          }
        } else {
          {
#line 481
          a[na].name = AddAttName(*(tok + 0));
#line 482
          a[na].sval = AddAttName(*(tok + 2));
#line 483
          na ++;
          }
        }
      } else {
        {
#line 481
        a[na].name = AddAttName(*(tok + 0));
#line 482
        a[na].sval = AddAttName(*(tok + 2));
#line 483
        na ++;
        }
      }
    } else {
      {
#line 481
      a[na].name = AddAttName(*(tok + 0));
#line 482
      a[na].sval = AddAttName(*(tok + 2));
#line 483
      na ++;
      }
    }
#line 489
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 495
    cp = strchr((char const   *)(buf___0), ' ');
    }
#line 495
    if (cp) {
      {
#line 496
      cp ++;
#line 497
      last_file = strdup((char const   *)cp);
      }
    }
    {
#line 499
    tmp___8 = atoi((char const   *)(buf___0));
#line 499
    e->lineno = tmp___8;
#line 499
    last_lineno = tmp___8;
#line 500
    e->infile = last_file;
    }
#line 501
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data in AccumElemInfo, line %d:\n%c%s\n",
            e->lineno, c, buf___0);
#line 507
    exit(1);
    }
#line 508
    goto switch_break;
    case_63: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 517
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 520
    i = 3;
#line 521
    tok = Split(buf___0, & i, 0);
#line 522
    ent.ename = strdup((char const   *)*(tok + 0));
#line 523
    ent.type = strdup((char const   *)*(tok + 1));
#line 524
    ent.nname = strdup((char const   *)*(tok + 2));
#line 525
    AddEntity(& ent);
    }
#line 526
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Got CMD_INT_ENT in AccumElemInfo: %s\n",
            buf___0);
    }
#line 529
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 531
    ent.sysid = strdup((char const   *)(buf___0));
    }
#line 532
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 534
    ent.pubid = strdup((char const   *)(buf___0));
    }
#line 535
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 537
    ent.fname = strdup((char const   *)(buf___0));
    }
#line 538
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 548
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unexpected input in AccumElemInfo, %d:\n%c%s\n",
            e->lineno, c, buf___0);
#line 550
    exit(1);
    }
#line 551
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  if (e) {
#line 554
    if (e->gi) {
#line 554
      tmp___9 = (char const   *)e->gi;
    } else {
#line 554
      tmp___9 = "(No element)";
    }
  } else {
#line 554
    tmp___9 = "(No element)";
  }
  {
#line 554
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: End of AccumElemInfo - should not be here: %s\n",
          tmp___9);
#line 557
  exit(1);
  }
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static Element_t *ReadESIS(FILE *fp , int depth , Element_t *parent ) 
{ 
  char *buf___0 ;
  char *xlatebuf ;
  char *dst ;
  char *src ;
  char *pch ;
  char *sdata ;
  int i ;
  int c ;
  int ncont ;
  int inspace ;
  int nomap ;
  Element_t *e ;
  Element_t *cur_e ;
  Content_t cont[5000] ;
  void *tmp ;
  void *tmp___0 ;
  char *_cp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *_cp___0 ;
  char *_cp___1 ;
  Content_t *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 582
  tmp = malloc(60000UL + sizeof(char ));
#line 582
  buf___0 = (char *)tmp;
  }
#line 582
  if (! buf___0) {
    {
#line 582
    perror("Malloc failed -- out of memory.  Bailing out.");
#line 582
    exit(1);
    }
  }
  {
#line 582
  memset((void *)buf___0, 0, sizeof(char ));
#line 583
  tmp___0 = malloc(60000UL + sizeof(char ));
#line 583
  xlatebuf = (char *)tmp___0;
  }
#line 583
  if (! xlatebuf) {
    {
#line 583
    perror("Malloc failed -- out of memory.  Bailing out.");
#line 583
    exit(1);
    }
  }
  {
#line 583
  memset((void *)xlatebuf, 0, sizeof(char ));
#line 586
  e = AccumElemInfo(fp);
#line 587
  e->depth = depth;
#line 588
  e->parent = parent;
#line 590
  ncont = 0;
  }
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 592
    c = _IO_getc(fp);
    }
#line 592
    if (c == -1) {
#line 592
      goto while_break;
    }
    {
#line 594
    if (c == -1) {
#line 594
      goto case_neg_1;
    }
#line 597
    if (c == 45) {
#line 597
      goto case_45;
    }
#line 792
    if (c == 63) {
#line 792
      goto case_63;
    }
#line 800
    if (c == 41) {
#line 800
      goto case_41;
    }
#line 824
    if (c == 102) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 112) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 115) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 73) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 69) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 78) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 68) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 65) {
#line 824
      goto case_102;
    }
#line 824
    if (c == 40) {
#line 824
      goto case_102;
    }
#line 832
    if (c == 76) {
#line 832
      goto case_76;
    }
#line 842
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
#line 595
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 598
    fgets((char */* __restrict  */)buf___0, 60000, (FILE */* __restrict  */)fp);
#line 599
    _cp = strchr((char const   *)buf___0, '\n');
    }
#line 599
    if (_cp) {
#line 599
      *_cp = (char )'\000';
    }
#line 621
    if (! do_DATAhack) {
#line 631
      src = buf___0;
#line 632
      dst = xlatebuf;
      {
#line 633
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 633
        if (! *src) {
#line 633
          goto while_break___0;
        }
#line 634
        nomap = 0;
#line 635
        if ((int )*src == 92) {
#line 636
          src ++;
          {
#line 638
          if ((int )*src == 92) {
#line 638
            goto case_92;
          }
#line 642
          if ((int )*src == 110) {
#line 642
            goto case_110;
          }
#line 647
          if ((int )*src == 55) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 54) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 53) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 52) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 51) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 50) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 49) {
#line 647
            goto case_55;
          }
#line 647
          if ((int )*src == 48) {
#line 647
            goto case_55;
          }
#line 660
          if ((int )*src == 37) {
#line 660
            goto case_37;
          }
#line 660
          if ((int )*src == 35) {
#line 660
            goto case_37;
          }
#line 672
          if ((int )*src == 124) {
#line 672
            goto case_124;
          }
#line 695
          goto switch_default;
          case_92: /* CIL Label */ 
#line 640
          tmp___1 = src;
#line 640
          src ++;
#line 640
          *dst = *tmp___1;
#line 641
          goto switch_break___0;
          case_110: /* CIL Label */ 
#line 644
          *dst = (char )'\n';
#line 644
          src ++;
#line 645
          goto switch_break___0;
          case_55: /* CIL Label */ 
          case_54: /* CIL Label */ 
          case_53: /* CIL Label */ 
          case_52: /* CIL Label */ 
          case_51: /* CIL Label */ 
          case_50: /* CIL Label */ 
          case_49: /* CIL Label */ 
          case_48: /* CIL Label */ 
#line 649
          *dst = (char )(((((int )*src - 48) << 6) + (((int )*(src + 1) - 48) << 3)) + ((int )*(src + 2) - 48));
#line 652
          if (xml_mode) {
#line 652
            if ((int )*dst == 10) {
#line 652
              if ((int )*(dst - 1) == 10) {
#line 656
                tmp___2 = dst;
#line 656
                dst --;
              }
            }
          }
#line 658
          src += 3;
#line 659
          goto switch_break___0;
          case_37: /* CIL Label */ 
          case_35: /* CIL Label */ 
#line 663
          tmp___3 = dst;
#line 663
          dst ++;
#line 663
          *tmp___3 = (char )'[';
          {
#line 664
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 664
            if (! ((int )*src != 59)) {
#line 664
              goto while_break___1;
            }
#line 665
            tmp___4 = dst;
#line 665
            dst ++;
#line 665
            tmp___5 = src;
#line 665
            src ++;
#line 665
            *tmp___4 = *tmp___5;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 667
          tmp___6 = dst;
#line 667
          dst ++;
#line 667
          *tmp___6 = (char )']';
#line 668
          src ++;
#line 670
          nomap = 1;
#line 671
          goto switch_break___0;
          case_124: /* CIL Label */ 
#line 674
          src ++;
#line 674
          sdata = src;
          {
#line 675
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 675
            if (*src) {
#line 675
              if ((int )*src != 92) {
#line 675
                if (! ((int )*(src + 1) != 124)) {
#line 675
                  goto while_break___2;
                }
              } else {
#line 675
                goto while_break___2;
              }
            } else {
#line 675
              goto while_break___2;
            }
#line 677
            src ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 679
          if (! *src) {
#line 679
            goto switch_break___0;
          }
          {
#line 680
          *src = (char )'\000';
#line 681
          src += 2;
#line 682
          pch = LookupSDATA(sdata);
          }
#line 682
          if (pch) {
            {
#line 683
            strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)pch);
#line 684
            tmp___7 = strlen((char const   *)pch);
#line 684
            dst += tmp___7;
            }
          } else {
            {
#line 687
            tmp___8 = dst;
#line 687
            dst ++;
#line 687
            *tmp___8 = (char )'[';
#line 688
            strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)sdata);
#line 689
            tmp___9 = strlen((char const   *)sdata);
#line 689
            dst += tmp___9;
#line 690
            tmp___10 = dst;
#line 690
            dst ++;
#line 690
            *tmp___10 = (char )']';
            }
          }
#line 693
          nomap = 1;
#line 694
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 696
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"? Warning: Unknown ESIS escape sequence in stream: (\'%c\')\n",
                  (int )*src);
#line 700
          tmp___11 = dst;
#line 700
          dst ++;
#line 700
          tmp___12 = src;
#line 700
          src ++;
#line 700
          *tmp___11 = *tmp___12;
#line 701
          nomap = 1;
          }
          switch_break___0: /* CIL Label */ ;
          }
        } else {
#line 704
          tmp___13 = src;
#line 704
          src ++;
#line 704
          *dst = *tmp___13;
        }
#line 708
        if (! nomap) {
#line 709
          if (nCharMap) {
#line 710
            i = 0;
            {
#line 710
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 710
              if (! (i < nCharMap)) {
#line 710
                goto while_break___3;
              }
#line 711
              if ((int )*dst != (int )*((CharMap + i)->name + 0)) {
#line 711
                goto __Cont;
              }
              {
#line 712
              strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)(CharMap + i)->sval);
#line 713
              tmp___14 = strlen((char const   *)(CharMap + i)->sval);
#line 713
              dst += tmp___14 - 1UL;
              }
              __Cont: /* CIL Label */ 
#line 710
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          } else
#line 715
          if ((int )*dst == 92) {
#line 718
            dst ++;
#line 718
            *dst = (char )'\\';
          }
#line 720
          dst ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 723
      *dst = (char )'\000';
#line 727
      pch = xlatebuf;
#line 728
      xlatebuf = buf___0;
#line 729
      buf___0 = pch;
#line 736
      cur_e = e;
      {
#line 737
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 737
        if (! cur_e) {
#line 737
          goto while_break___4;
        }
#line 738
        if (xml_mode) {
#line 738
          tmp___15 = "format";
        } else {
#line 738
          tmp___15 = "FORMAT";
        }
        {
#line 738
        pch = FindAttValByName(cur_e, (char *)tmp___15);
        }
#line 738
        if (pch) {
#line 743
          goto while_break___4;
        }
#line 745
        cur_e = cur_e->parent;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 747
      if (pch) {
#line 747
        if (xml_mode) {
#line 747
          tmp___18 = "linespecific";
        } else {
#line 747
          tmp___18 = "LINESPECIFIC";
        }
        {
#line 747
        tmp___19 = strcmp((char const   *)pch, tmp___18);
        }
#line 747
        if (tmp___19) {
#line 747
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 752
        src = buf___0;
#line 752
        dst = src;
#line 753
        inspace = 0;
        {
#line 754
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 754
          if (! *src) {
#line 754
            goto while_break___5;
          }
          {
#line 755
          tmp___16 = __ctype_b_loc();
#line 755
          i = (int )((int const   )*(*tmp___16 + (int )*src) & 8192);
          }
#line 756
          if (inspace) {
#line 756
            if (! i) {
#line 756
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 757
            tmp___17 = dst;
#line 757
            dst ++;
#line 757
            if (i) {
#line 757
              *tmp___17 = (char )' ';
            } else {
#line 757
              *tmp___17 = *src;
            }
          }
#line 759
          inspace = i;
#line 760
          src ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 762
        *dst = (char )'\000';
      }
    }
#line 771
    if ((int )*buf___0 == 0) {
#line 773
      goto switch_break;
    }
#line 780
    if (do_DATAhack == 1) {
#line 780
      if ((int )*(buf___0 + 0) == 92) {
#line 780
        if ((int )*(buf___0 + 1) == 110) {
#line 781
          if (! *(buf___0 + 2)) {
#line 782
            goto switch_break;
          }
          {
#line 783
          *(buf___0 + 0) = (char )' ';
#line 784
          tmp___20 = strlen((char const   *)buf___0);
#line 784
          memcpy((void */* __restrict  */)(buf___0 + 1), (void const   */* __restrict  */)(buf___0 + 2),
                 tmp___20 - 1UL);
          }
        }
      }
    }
    {
#line 787
    cont[ncont].ch.data = strdup((char const   *)buf___0);
#line 788
    cont[ncont].type = (char )'-';
#line 789
    ncont ++;
    }
#line 790
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 793
    fgets((char */* __restrict  */)buf___0, 60000, (FILE */* __restrict  */)fp);
#line 794
    _cp___0 = strchr((char const   *)buf___0, '\n');
    }
#line 794
    if (_cp___0) {
#line 794
      *_cp___0 = (char )'\000';
    }
    {
#line 795
    cont[ncont].type = (char )'?';
#line 796
    cont[ncont].ch.data = strdup((char const   *)buf___0);
#line 797
    ncont ++;
    }
#line 798
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 801
    fgets((char */* __restrict  */)buf___0, 60000, (FILE */* __restrict  */)fp);
#line 802
    _cp___1 = strchr((char const   *)buf___0, '\n');
    }
#line 802
    if (_cp___1) {
#line 802
      *_cp___1 = (char )'\000';
    }
#line 803
    if (ncont) {
      {
#line 804
      e->ncont = ncont;
#line 805
      tmp___22 = malloc((size_t )ncont * sizeof(Content_t ));
#line 805
      tmp___21 = (Content_t *)tmp___22;
#line 805
      e->cont = tmp___21;
      }
#line 805
      if (! tmp___21) {
        {
#line 805
        perror("Malloc failed -- out of memory.  Bailing out.");
#line 805
        exit(1);
        }
      }
      {
#line 805
      memset((void *)e->cont, 0, sizeof(Content_t ));
#line 806
      i = 0;
      }
      {
#line 806
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 806
        if (! (i < ncont)) {
#line 806
          goto while_break___6;
        }
#line 806
        *(e->cont + i) = cont[i];
#line 806
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 808
    free((void *)buf___0);
#line 809
    free((void *)xlatebuf);
    }
#line 810
    return (e);
#line 811
    goto switch_break;
    case_102: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 825
    ungetc(c, fp);
#line 826
    cont[ncont].ch.elem = ReadESIS(fp, depth + 1, e);
#line 827
    cont[ncont].type = (char )'(';
#line 828
    (cont[ncont].ch.elem)->parent = e;
#line 829
    ncont ++;
    }
#line 830
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 833
    fgets((char */* __restrict  */)buf___0, 60000, (FILE */* __restrict  */)fp);
    }
#line 834
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 843
    fgets((char */* __restrict  */)buf___0, 60000, (FILE */* __restrict  */)fp);
#line 844
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unexpected input at %d: \'%c%s\'\n",
            e->lineno, c, buf___0);
#line 846
    exit(1);
    }
#line 847
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 850
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: End of ReadESIS - should not be here: %s\n",
          e->gi);
#line 851
  free((void *)buf___0);
#line 852
  free((void *)xlatebuf);
  }
#line 853
  return ((Element_t *)((void *)0));
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/docbook-to-man-2.0.0/Instant/main.c"
static void ReadInstance(char *filename ) 
{ 
  int i ;
  int n ;
  FILE *fp ;
  Element_t *e ;
  char *idatt ;
  struct _elem **tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 871
  if (filename) {
    {
#line 872
    fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 872
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 873
      perror((char const   *)filename);
#line 874
      exit(1);
      }
    }
  } else {
#line 877
    fp = stdin;
  }
  {
#line 878
  last_file = filename;
#line 879
  DocTree = ReadESIS(fp, 0, (Element_t *)((void *)0));
  }
#line 880
  if (filename) {
    {
#line 880
    fclose(fp);
    }
  }
#line 884
  DocTree->my_eorder = -1;
#line 885
  e = DocTree;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! e) {
#line 885
      goto while_break;
    }
#line 888
    i = 0;
#line 888
    n = 0;
    {
#line 888
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 888
      if (! (i < e->ncont)) {
#line 888
        goto while_break___0;
      }
#line 888
      if ((int )(e->cont + i)->type == 40) {
#line 888
        n ++;
      }
#line 888
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 889
    if (n > 0) {
      {
#line 889
      tmp___0 = calloc((size_t )n, sizeof(Element_t *));
#line 889
      tmp = (Element_t **)tmp___0;
#line 889
      e->econt = tmp;
      }
#line 889
      if (! tmp) {
        {
#line 889
        perror("Calloc failed -- out of memory.  Bailing out.");
#line 889
        exit(1);
        }
      }
      {
#line 889
      memset((void *)e->econt, 0, sizeof(Element_t *));
      }
    }
#line 890
    i = 0;
    {
#line 890
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 890
      if (! (i < e->ncont)) {
#line 890
        goto while_break___1;
      }
#line 891
      if ((int )(e->cont + i)->type == 40) {
#line 891
        tmp___1 = e->necont;
#line 891
        (e->necont) ++;
#line 891
        *(e->econt + tmp___1) = (e->cont + i)->ch.elem;
      }
#line 890
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 894
    i = 0;
#line 894
    n = 0;
    {
#line 894
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 894
      if (! (i < e->ncont)) {
#line 894
        goto while_break___2;
      }
#line 894
      if ((int )(e->cont + i)->type == 45) {
#line 894
        n ++;
      }
#line 894
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 895
    if (n > 0) {
      {
#line 895
      tmp___3 = calloc((size_t )n, sizeof(char *));
#line 895
      tmp___2 = (char **)tmp___3;
#line 895
      e->dcont = tmp___2;
      }
#line 895
      if (! tmp___2) {
        {
#line 895
        perror("Calloc failed -- out of memory.  Bailing out.");
#line 895
        exit(1);
        }
      }
      {
#line 895
      memset((void *)e->dcont, 0, sizeof(char *));
      }
    }
#line 896
    i = 0;
    {
#line 896
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 896
      if (! (i < e->ncont)) {
#line 896
        goto while_break___3;
      }
#line 897
      if ((int )(e->cont + i)->type == 45) {
#line 897
        tmp___4 = e->ndcont;
#line 897
        (e->ndcont) ++;
#line 897
        *(e->dcont + tmp___4) = (e->cont + i)->ch.data;
      }
#line 896
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 900
    i = 0;
    {
#line 900
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 900
      if (! (i < e->necont)) {
#line 900
        goto while_break___4;
      }
#line 901
      (*(e->econt + i))->my_eorder = i;
#line 900
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 904
    i = 0;
    {
#line 904
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 904
      if (! (i < e->natts)) {
#line 904
        goto while_break___5;
      }
      {
#line 905
      idatt = FindAttValByName(e, (char *)"ID");
      }
#line 905
      if (idatt) {
        {
#line 906
        AddID(e, idatt);
#line 908
        e->id = idatt;
        }
#line 909
        goto while_break___5;
      }
#line 904
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 885
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  return;
}
}
