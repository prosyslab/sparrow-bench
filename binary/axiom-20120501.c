/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/errors.h"
enum errorlevel {
    Normal = 0,
    Warning = 1,
    Error = 2,
    Fatal = 3,
    Impossible = 4
} ;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "markmain.nw"
enum state {
    Code = 1,
    Docs = 2,
    CodeIndex = 3
} ;
#line 35 "markmain.nw"
typedef enum state State;
#line 36
enum mark {
    Begin = 1,
    End = 2
} ;
#line 36 "markmain.nw"
typedef enum mark Mark;
#line 37
enum index {
    Defn = 1,
    Use = 2,
    Newline = 3
} ;
#line 37 "markmain.nw"
typedef enum index Index;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
struct location {
   char *filename ;
   int lineno ;
};
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
typedef struct location Location;
#line 6
enum parttype {
    STRING = 1,
    MODULE = 2,
    NEWLINE = 3
} ;
#line 6 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
typedef enum parttype Parttype;
#line 8 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
struct modpart {
   Parttype ptype ;
   char *contents ;
   Location loc ;
   struct modpart *next ;
};
#line 14 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
struct module {
   char *name ;
   int usecount ;
   struct modpart *head ;
   struct modpart *tail ;
};
#line 14 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
typedef struct module *Module;
#line 26 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
struct parent {
   Module this ;
   struct parent *parent ;
};
#line 26 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
typedef struct parent *Parent;
#line 24 "modtrees.nw"
struct tnode {
   struct tnode *left ;
   struct tnode *right ;
   Module data ;
};
#line 24 "modtrees.nw"
typedef struct tnode TNODE;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/recognize.h"
struct recognizer;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/recognize.h"
typedef struct recognizer *Recognizer;
#line 95 "finduses.nw"
struct line_and_outfile {
   char *line ;
   FILE *out ;
};
#line 95 "finduses.nw"
typedef struct line_and_outfile LineOut;
#line 74 "recognize.nw"
struct goto_node;
#line 74 "recognize.nw"
typedef struct goto_node Goto_Node;
#line 75
struct move_node;
#line 75 "recognize.nw"
typedef struct move_node Move_Node;
#line 77 "recognize.nw"
struct name_node {
   struct name_node *next ;
   char *name ;
};
#line 77 "recognize.nw"
typedef struct name_node Name_Node;
#line 82 "recognize.nw"
struct move_node {
   Move_Node *next ;
   Goto_Node *state ;
   unsigned char c ;
};
#line 88 "recognize.nw"
struct goto_node {
   Name_Node *output ;
   Move_Node *moves ;
   Goto_Node *fail ;
   Goto_Node *next ;
};
#line 95 "recognize.nw"
struct recognizer {
   Goto_Node *root[256] ;
   char *alphas ;
   char *syms ;
   int max_depth ;
   Goto_Node **depths ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 2 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/errors.h"
enum errorlevel errorlevel ;
#line 3
int finalstage ;
#line 4
char *progname ;
#line 5
void nowebexit(char *msg ) ;
#line 6
void errormsg(enum errorlevel level , char *s  , ...) ;
#line 10
void errorat(char *filename , int lineno , enum errorlevel level , char *s  , ...) ;
#line 34 "errors.nw"
enum errorlevel errorlevel  =    (enum errorlevel )0;
#line 35 "errors.nw"
int finalstage  =    0;
#line 36 "errors.nw"
char *progname  =    (char *)((void *)0);
#line 44 "errors.nw"
void nowebexit(char *msg ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 45
  if (! finalstage) {
#line 45
    if ((unsigned int )errorlevel > 0U) {
#line 46
      if ((unsigned long )msg != (unsigned long )((void *)0)) {
#line 46
        tmp = (char const   *)msg;
      } else {
#line 46
        tmp = "an unspecified error occurred";
      }
#line 46
      if ((unsigned long )progname != (unsigned long )((void *)0)) {
#line 46
        tmp___0 = (char const   *)progname;
      } else {
#line 46
        tmp___0 = "a-noweb-filter";
      }
      {
#line 46
      printf((char const   */* __restrict  */)"@fatal %s %s\n", tmp___0, tmp);
      }
    }
  }
  {
#line 48
  exit((int )errorlevel);
  }
}
}
#line 58 "errors.nw"
void errormsg(enum errorlevel level , char *s  , ...) 
{ 
  va_list args ;

  {
  {
#line 60
  __builtin_va_start(args, s);
  }
#line 79
  if ((unsigned int )level > (unsigned int )errorlevel) {
#line 80
    errorlevel = level;
  }
  {
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, args);
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 62
  __builtin_va_end(args);
  }
#line 63
  if ((unsigned int )level >= 3U) {
    {
#line 64
    nowebexit(s);
    }
  }
#line 65
  return;
}
}
#line 69 "errors.nw"
void errorat(char *filename , int lineno , enum errorlevel level , char *s  , ...) 
{ 
  va_list args ;

  {
  {
#line 71
  __builtin_va_start(args, s);
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          filename, lineno);
  }
#line 79
  if ((unsigned int )level > (unsigned int )errorlevel) {
#line 80
    errorlevel = level;
  }
  {
#line 81
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, args);
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 74
  __builtin_va_end(args);
  }
#line 75
  if ((unsigned int )level >= 3U) {
    {
#line 76
    nowebexit(s);
    }
  }
#line 77
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/columns.h"
int tabsize ;
#line 2
int columnwidth(char *s ) ;
#line 3
int limitcolumn(char *s , int col ) ;
#line 5
void indent_for(int width , FILE *fp ) ;
#line 23 "columns.nw"
int tabsize  =    8;
#line 25 "columns.nw"
int columnwidth(char *s ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = limitcolumn(s, 0);
  }
#line 26
  return (tmp);
}
}
#line 29 "columns.nw"
int limitcolumn(char *s , int col ) 
{ 


  {
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! *s) {
#line 30
      goto while_break;
    }
#line 31
    col ++;
#line 32
    if ((int )*s == 9) {
#line 32
      if (tabsize > 0) {
        {
#line 32
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 32
          if (! (col % tabsize != 0)) {
#line 32
            goto while_break___0;
          }
#line 32
          col ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 33
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return (col);
}
}
#line 38 "columns.nw"
void indent_for(int width , FILE *fp ) 
{ 


  {
#line 41
  if (tabsize > 1) {
    {
#line 42
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      if (! (width >= tabsize)) {
#line 42
        goto while_break;
      }
      {
#line 43
      _IO_putc('\t', fp);
#line 44
      width -= tabsize;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (width > 0)) {
#line 46
      goto while_break___0;
    }
    {
#line 47
    _IO_putc(' ', fp);
#line 48
    width --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/getline.h"
char *getline_expand(FILE *fp ) ;
#line 4
char *getline(FILE *fp ) ;
#line 28 "getline.nw"
static char *buf1  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size  =    128;
#line 42 "getline.nw"
void new_buffers(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    tmp = realloc((void *)buf1, (size_t )buf_size);
#line 43
    buf1 = (char *)tmp;
    }
#line 43
    if (! buf1) {
      {
#line 43
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 43
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 44
    tmp___0 = realloc((void *)buf2, (size_t )buf_size);
#line 44
    buf2 = (char *)tmp___0;
    }
#line 44
    if (! buf2) {
      {
#line 44
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 44
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 47 "getline.nw"
char *getline(FILE *fp ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 82
  if ((unsigned long )buf1 == (unsigned long )((void *)0)) {
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 83
      tmp = malloc((size_t )buf_size);
#line 83
      buf1 = (char *)tmp;
      }
#line 83
      if (! buf1) {
        {
#line 83
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 83
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 84
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 84
      tmp___0 = malloc((size_t )buf_size);
#line 84
      buf2 = (char *)tmp___0;
      }
#line 84
      if (! buf2) {
        {
#line 84
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 84
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 51
  buf1 = fgets((char */* __restrict  */)buf1, buf_size, (FILE */* __restrict  */)fp);
  }
#line 52
  if ((unsigned long )buf1 == (unsigned long )((void *)0)) {
#line 52
    return (buf1);
  }
  {
#line 53
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 53
    tmp___4 = strlen((char const   *)buf1);
    }
#line 53
    if (! ((int )*(buf1 + (tmp___4 - 1UL)) != 10)) {
#line 53
      goto while_break___1;
    }
    {
#line 54
    buf_size *= 2;
#line 55
    new_buffers();
#line 56
    tmp___1 = strlen((char const   *)buf1);
#line 56
    tmp___2 = strlen((char const   *)buf1);
#line 56
    tmp___3 = fgets((char */* __restrict  */)(buf1 + tmp___2), (int )((size_t )buf_size - tmp___1),
                    (FILE */* __restrict  */)fp);
    }
#line 56
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 57
      return (buf1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  return (buf1);
}
}
#line 62 "getline.nw"
char *getline_expand(FILE *fp ) 
{ 
  char *s ;
  char *t ;
  int width ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 66
  tmp = getline(fp);
  }
#line 66
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 66
    return ((char *)((void *)0));
  }
  {
#line 87
  tmp___1 = columnwidth(buf1);
  }
#line 87
  if (tmp___1 > buf_size - 1) {
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 88
      tmp___0 = columnwidth(buf1);
      }
#line 88
      if (! (tmp___0 > buf_size - 1)) {
#line 88
        goto while_break;
      }
#line 88
      buf_size *= 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 89
    new_buffers();
    }
  }
#line 68
  s = buf1;
#line 68
  t = buf2;
#line 68
  width = 0;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! *s) {
#line 69
      goto while_break___0;
    }
#line 70
    if ((int )*s == 9) {
#line 70
      if (tabsize > 0) {
        {
#line 71
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 72
          tmp___2 = t;
#line 72
          t ++;
#line 72
          *tmp___2 = (char )' ';
#line 72
          width ++;
#line 71
          if (! (width % tabsize != 0)) {
#line 71
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 74
        s ++;
      } else {
#line 70
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 76
      tmp___3 = t;
#line 76
      t ++;
#line 76
      tmp___4 = s;
#line 76
      s ++;
#line 76
      *tmp___3 = *tmp___4;
#line 76
      width ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 78
  *t = (char )'\000';
#line 79
  return (buf2);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 2 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/markup.h"
int starts_doc(char *line ) ;
#line 3
char *first_doc_line(char *line ) ;
#line 4
int is_def(char *line ) ;
#line 5
char *remove_def_marker(char *line ) ;
#line 8
int starts_code(char *line , char *filename , int lineno ) ;
#line 10
void getmodname(char *dest , int size , char *source ) ;
#line 39 "markmain.nw"
static char *states[4]  = {      (char *)"bad state",      (char *)"code",      (char *)"docs",      (char *)"code"};
#line 40 "markmain.nw"
static char *marks[3]  = {      (char *)"bad mark",      (char *)"begin",      (char *)"end"};
#line 41 "markmain.nw"
static char *indices[4]  = {      (char *)"bad index",      (char *)"defn",      (char *)"use",      (char *)"nl"};
#line 42 "markmain.nw"
static char low_at_sign  =    (char )'@';
#line 44 "markmain.nw"
static void print_state(FILE *out , Mark be , State state , int count ) 
{ 


  {
  {
#line 45
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s %d\n",
          (int )low_at_sign, marks[be], states[state], count);
  }
#line 46
  return;
}
}
#line 48 "markmain.nw"
static void print_index(FILE *out , Index idx , char *arg ) 
{ 


  {
#line 49
  if (arg) {
    {
#line 50
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%cindex %s %s\n",
            (int )low_at_sign, indices[idx], arg);
    }
  } else {
    {
#line 52
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%cindex %s\n",
            (int )low_at_sign, indices[idx]);
    }
  }
#line 53
  return;
}
}
#line 55 "markmain.nw"
static void print_pair(FILE *out , char *name , char *value ) 
{ 
  int last ;
  size_t tmp ;

  {
#line 56
  if (value) {
    {
#line 57
    tmp = strlen((char const   *)value);
#line 57
    last = (int )(tmp - 1UL);
    }
#line 58
    if (last >= 0) {
#line 58
      if ((int )*(value + last) == 10) {
        {
#line 59
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s%cnl\n",
                (int )low_at_sign, name, value, (int )low_at_sign);
        }
      } else {
        {
#line 61
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s\n",
                (int )low_at_sign, name, value);
        }
      }
    } else {
      {
#line 61
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s\n",
              (int )low_at_sign, name, value);
      }
    }
  } else {
    {
#line 63
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s\n",
            (int )low_at_sign, name);
    }
  }
#line 64
  return;
}
}
#line 182 "markmain.nw"
static char *buf  ;
#line 183
void markup(FILE *in , FILE *out , char *filename ) ;
#line 183 "markmain.nw"
static int buflen  =    0;
#line 80 "markmain.nw"
void markup(FILE *in , FILE *out , char *filename ) 
{ 
  State state ;
  int quoting ;
  int count ;
  int missing_newline ;
  int lineno ;
  int last_open_quote ;
  char *line ;
  char modname[256] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char tmp___2 ;
  char *s ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *p ;
  char *s___0 ;
  char *t ;
  char c ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;

  {
#line 81
  state = (State )2;
#line 82
  quoting = 0;
#line 83
  count = 0;
#line 85
  lineno = 0;
#line 91
  modname[0] = (char )'\000';
#line 91
  tmp = 1U;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (tmp >= 256U) {
#line 91
      goto while_break;
    }
#line 91
    modname[tmp] = (char)0;
#line 91
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  print_pair(out, (char *)"file", filename);
#line 122
  print_state(out, (Mark )1, state, count);
  }
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 123
    line = getline_expand(in);
    }
#line 123
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 123
      goto while_break___0;
    }
    {
#line 124
    lineno ++;
#line 172
    tmp___0 = strlen((char const   *)line);
#line 172
    missing_newline = (int )*(line + (tmp___0 - 1UL)) != 10;
#line 126
    tmp___94 = starts_code(line, filename, lineno);
    }
#line 126
    if (tmp___94) {
#line 542
      if (quoting) {
        {
#line 543
        errorat(filename, last_open_quote, (enum errorlevel )1, (char *)"open quote `[[\' never closed");
#line 544
        quoting = 0;
        }
      }
      {
#line 128
      print_state(out, (Mark )2, state, count);
#line 129
      count ++;
#line 130
      state = (State )1;
#line 131
      print_state(out, (Mark )1, state, count);
#line 132
      getmodname(modname, 255, line);
#line 133
      print_pair(out, (char *)"defn", modname);
#line 134
      print_pair(out, (char *)"nl", (char *)0);
      }
    } else {
      {
#line 135
      tmp___93 = is_def(line);
      }
#line 135
      if (tmp___93) {
        {
#line 528
        line = remove_def_marker(line);
        }
        {
#line 529
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 529
          if (*line) {
            {
#line 529
            tmp___1 = __ctype_b_loc();
            }
#line 529
            if (! ((int const   )*(*tmp___1 + (int )*line) & 8192)) {
#line 529
              goto while_break___1;
            }
          } else {
#line 529
            goto while_break___1;
          }
#line 529
          line ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 530
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 530
          if (! *line) {
#line 530
            goto while_break___2;
          }
#line 532
          s = line + 1;
          {
#line 533
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 533
            if (*s) {
              {
#line 533
              tmp___3 = __ctype_b_loc();
              }
#line 533
              if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 533
                goto while_break___3;
              }
            } else {
#line 533
              goto while_break___3;
            }
#line 533
            s ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 534
          tmp___2 = *s;
#line 534
          *s = (char)0;
#line 535
          print_index(out, (Index )1, line);
#line 536
          *s = tmp___2;
          }
          {
#line 537
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 537
            tmp___4 = __ctype_b_loc();
            }
#line 537
            if (! ((int const   )*(*tmp___4 + (int )*s) & 8192)) {
#line 537
              goto while_break___4;
            }
#line 537
            s ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 538
          line = s;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 540
        print_index(out, (Index )3, (char *)0);
        }
#line 137
        if ((unsigned int )state == 1U) {
#line 138
          state = (State )3;
        }
      } else {
        {
#line 140
        tmp___6 = starts_doc(line);
        }
#line 140
        if (tmp___6) {
#line 140
          goto _L;
        } else
#line 140
        if ((unsigned int )state == 3U) {
          _L: /* CIL Label */ 
#line 542
          if (quoting) {
            {
#line 543
            errorat(filename, last_open_quote, (enum errorlevel )1, (char *)"open quote `[[\' never closed");
#line 544
            quoting = 0;
            }
          }
          {
#line 142
          print_state(out, (Mark )2, state, count);
#line 143
          count ++;
#line 144
          state = (State )2;
#line 145
          print_state(out, (Mark )1, state, count);
#line 146
          tmp___5 = starts_doc(line);
          }
#line 146
          if (tmp___5) {
            {
#line 147
            line = first_doc_line(line);
            }
          }
        }
#line 505
        if ((unsigned long )buf == (unsigned long )((void *)0)) {
          {
#line 506
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 506
            buflen = 128;
#line 506
            tmp___7 = malloc((size_t )buflen);
#line 506
            buf = (char *)tmp___7;
            }
#line 506
            if (! buf) {
              {
#line 506
              errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
              }
            }
#line 506
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
#line 507
        tmp___10 = strlen((char const   *)line);
        }
#line 507
        if ((size_t )buflen < (tmp___10 + 1UL) + 2UL) {
          {
#line 508
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 508
            tmp___8 = strlen((char const   *)line);
            }
#line 508
            if (! ((size_t )buflen < (tmp___8 + 1UL) + 2UL)) {
#line 508
              goto while_break___6;
            }
#line 509
            buflen *= 2;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 510
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 510
            tmp___9 = realloc((void *)buf, (size_t )buflen);
#line 510
            buf = (char *)tmp___9;
            }
#line 510
            if (! buf) {
              {
#line 510
              errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
              }
            }
#line 510
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 186
        s___0 = buf + 2;
#line 186
        p = s___0;
#line 187
        t = line;
#line 188
        tmp___11 = t;
#line 188
        t ++;
#line 188
        c = *tmp___11;
#line 206
        if ((int )c == 64) {
#line 206
          if ((int )*t == 64) {
#line 206
            tmp___12 = s___0;
#line 206
            s___0 ++;
#line 206
            *tmp___12 = (char )'@';
#line 206
            t ++;
#line 206
            c = *t;
#line 206
            t ++;
          }
        }
#line 153
        if ((unsigned int )state == 1U) {
#line 154
          goto convert_code;
        } else
#line 153
        if (quoting) {
#line 154
          goto convert_code;
        }
        convert_docs: ;
#line 298
        if ((int )c == 64) {
          {
#line 298
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 298
            tmp___13 = t;
#line 298
            t ++;
#line 298
            c = *tmp___13;
#line 298
            goto at;
#line 298
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 299
        if ((int )c == 60) {
          {
#line 299
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 299
            tmp___14 = t;
#line 299
            t ++;
#line 299
            c = *tmp___14;
#line 299
            goto la;
#line 299
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 300
        if ((int )c == 91) {
          {
#line 300
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 300
            tmp___15 = t;
#line 300
            t ++;
#line 300
            c = *tmp___15;
#line 300
            goto ls;
#line 300
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 242
        if ((int )c == 0) {
#line 513
          if ((unsigned long )s___0 > (unsigned long )p) {
            {
#line 514
            *s___0 = (char)0;
#line 515
            print_pair(out, (char *)"text", p);
            }
          }
#line 517
          p = buf + 2;
#line 517
          s___0 = p;
#line 244
          goto done_converting;
        }
        {
#line 302
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 302
          tmp___16 = s___0;
#line 302
          s___0 ++;
#line 302
          *tmp___16 = c;
#line 302
          tmp___17 = t;
#line 302
          t ++;
#line 302
          c = *tmp___17;
#line 302
          goto convert_docs;
#line 302
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        at: 
#line 310
        if ((int )c == 60) {
          {
#line 310
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 310
            tmp___18 = t;
#line 310
            t ++;
#line 310
            c = *tmp___18;
#line 310
            goto atla;
#line 310
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
#line 311
        if ((int )c == 91) {
          {
#line 311
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 311
            tmp___19 = t;
#line 311
            t ++;
#line 311
            c = *tmp___19;
#line 311
            goto atls;
#line 311
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 312
        if ((int )c == 62) {
          {
#line 312
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 312
            tmp___20 = t;
#line 312
            t ++;
#line 312
            c = *tmp___20;
#line 312
            goto atra;
#line 312
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 313
        if ((int )c == 93) {
          {
#line 313
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 313
            tmp___21 = t;
#line 313
            t ++;
#line 313
            c = *tmp___21;
#line 313
            goto atrs;
#line 313
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
#line 314
        tmp___22 = s___0;
#line 314
        s___0 ++;
#line 314
        *tmp___22 = (char )'@';
#line 314
        goto convert_docs;
        atls: 
#line 319
        if ((int )c == 91) {
#line 319
          tmp___23 = s___0;
#line 319
          s___0 ++;
#line 319
          *tmp___23 = (char )'[';
#line 319
          tmp___24 = s___0;
#line 319
          s___0 ++;
#line 319
          *tmp___24 = (char )'[';
          {
#line 319
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 319
            tmp___25 = t;
#line 319
            t ++;
#line 319
            c = *tmp___25;
#line 319
            goto convert_docs;
#line 319
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 320
        tmp___26 = s___0;
#line 320
        s___0 ++;
#line 320
        *tmp___26 = (char )'@';
#line 320
        tmp___27 = s___0;
#line 320
        s___0 ++;
#line 320
        *tmp___27 = (char )'[';
#line 320
        goto convert_docs;
        atla: 
#line 325
        if ((int )c == 60) {
#line 325
          tmp___28 = s___0;
#line 325
          s___0 ++;
#line 325
          *tmp___28 = (char )'<';
#line 325
          tmp___29 = s___0;
#line 325
          s___0 ++;
#line 325
          *tmp___29 = (char )'<';
          {
#line 325
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 325
            tmp___30 = t;
#line 325
            t ++;
#line 325
            c = *tmp___30;
#line 325
            goto convert_docs;
#line 325
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
#line 326
        tmp___31 = s___0;
#line 326
        s___0 ++;
#line 326
        *tmp___31 = (char )'@';
#line 326
        tmp___32 = s___0;
#line 326
        s___0 ++;
#line 326
        *tmp___32 = (char )'<';
#line 326
        goto convert_docs;
        atrs: 
#line 331
        if ((int )c == 93) {
#line 331
          tmp___33 = s___0;
#line 331
          s___0 ++;
#line 331
          *tmp___33 = (char )']';
#line 331
          tmp___34 = s___0;
#line 331
          s___0 ++;
#line 331
          *tmp___34 = (char )']';
          {
#line 331
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 331
            tmp___35 = t;
#line 331
            t ++;
#line 331
            c = *tmp___35;
#line 331
            goto convert_docs;
#line 331
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
#line 332
        tmp___36 = s___0;
#line 332
        s___0 ++;
#line 332
        *tmp___36 = (char )'@';
#line 332
        tmp___37 = s___0;
#line 332
        s___0 ++;
#line 332
        *tmp___37 = (char )']';
#line 332
        goto convert_docs;
        atra: 
#line 337
        if ((int )c == 62) {
#line 337
          tmp___38 = s___0;
#line 337
          s___0 ++;
#line 337
          *tmp___38 = (char )'>';
#line 337
          tmp___39 = s___0;
#line 337
          s___0 ++;
#line 337
          *tmp___39 = (char )'>';
          {
#line 337
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 337
            tmp___40 = t;
#line 337
            t ++;
#line 337
            c = *tmp___40;
#line 337
            goto convert_docs;
#line 337
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
#line 338
        tmp___41 = s___0;
#line 338
        s___0 ++;
#line 338
        *tmp___41 = (char )'@';
#line 338
        tmp___42 = s___0;
#line 338
        s___0 ++;
#line 338
        *tmp___42 = (char )'>';
#line 338
        goto convert_docs;
        la: 
#line 343
        if ((int )c == 60) {
          {
#line 525
          errorat(filename, lineno, (enum errorlevel )2, (char *)"unescaped << in documentation chunk");
#line 345
          tmp___43 = s___0;
#line 345
          s___0 ++;
#line 345
          *tmp___43 = (char )'<';
#line 345
          tmp___44 = s___0;
#line 345
          s___0 ++;
#line 345
          *tmp___44 = (char )'<';
          }
          {
#line 345
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 345
            tmp___45 = t;
#line 345
            t ++;
#line 345
            c = *tmp___45;
#line 345
            goto convert_docs;
#line 345
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 347
        tmp___46 = s___0;
#line 347
        s___0 ++;
#line 347
        *tmp___46 = (char )'<';
#line 347
        goto convert_docs;
        ls: ;
#line 356
        if ((int )c == 91) {
#line 513
          if ((unsigned long )s___0 > (unsigned long )p) {
            {
#line 514
            *s___0 = (char)0;
#line 515
            print_pair(out, (char *)"text", p);
            }
          }
          {
#line 517
          p = buf + 2;
#line 517
          s___0 = p;
#line 358
          quoting = 1;
#line 358
          last_open_quote = lineno;
#line 358
          print_pair(out, (char *)"quote", (char *)0);
          }
          {
#line 359
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 359
            tmp___47 = t;
#line 359
            t ++;
#line 359
            c = *tmp___47;
#line 359
            goto convert_code;
#line 359
            goto while_break___21;
          }
          while_break___21: /* CIL Label */ ;
          }
        }
#line 361
        tmp___48 = s___0;
#line 361
        s___0 ++;
#line 361
        *tmp___48 = (char )'[';
#line 362
        goto convert_docs;
        convert_code: ;
#line 374
        if ((int )c == 93) {
#line 374
          if (quoting) {
            {
#line 374
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 374
              tmp___49 = t;
#line 374
              t ++;
#line 374
              c = *tmp___49;
#line 374
              goto crs;
#line 374
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        }
#line 375
        if ((int )c == 60) {
          {
#line 375
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 375
            tmp___50 = t;
#line 375
            t ++;
#line 375
            c = *tmp___50;
#line 375
            goto cla;
#line 375
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
#line 376
        if ((int )c == 64) {
          {
#line 376
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 376
            tmp___51 = t;
#line 376
            t ++;
#line 376
            c = *tmp___51;
#line 376
            goto cat;
#line 376
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
        }
#line 242
        if ((int )c == 0) {
#line 513
          if ((unsigned long )s___0 > (unsigned long )p) {
            {
#line 514
            *s___0 = (char)0;
#line 515
            print_pair(out, (char *)"text", p);
            }
          }
#line 517
          p = buf + 2;
#line 517
          s___0 = p;
#line 244
          goto done_converting;
        }
        {
#line 378
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 378
          tmp___52 = s___0;
#line 378
          s___0 ++;
#line 378
          *tmp___52 = c;
#line 378
          tmp___53 = t;
#line 378
          t ++;
#line 378
          c = *tmp___53;
#line 378
          goto convert_code;
#line 378
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
        cat: 
#line 386
        if ((int )c == 60) {
          {
#line 386
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 386
            tmp___54 = t;
#line 386
            t ++;
#line 386
            c = *tmp___54;
#line 386
            goto catla;
#line 386
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
#line 387
        if ((int )c == 62) {
          {
#line 387
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 387
            tmp___55 = t;
#line 387
            t ++;
#line 387
            c = *tmp___55;
#line 387
            goto catra;
#line 387
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
        }
#line 388
        tmp___56 = s___0;
#line 388
        s___0 ++;
#line 388
        *tmp___56 = (char )'@';
#line 388
        goto convert_code;
        catla: 
#line 393
        if ((int )c == 60) {
#line 393
          tmp___57 = s___0;
#line 393
          s___0 ++;
#line 393
          *tmp___57 = (char )'<';
#line 393
          tmp___58 = s___0;
#line 393
          s___0 ++;
#line 393
          *tmp___58 = (char )'<';
          {
#line 393
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 393
            tmp___59 = t;
#line 393
            t ++;
#line 393
            c = *tmp___59;
#line 393
            goto convert_code;
#line 393
            goto while_break___28;
          }
          while_break___28: /* CIL Label */ ;
          }
        }
#line 394
        tmp___60 = s___0;
#line 394
        s___0 ++;
#line 394
        *tmp___60 = (char )'@';
#line 394
        tmp___61 = s___0;
#line 394
        s___0 ++;
#line 394
        *tmp___61 = (char )'<';
#line 394
        goto convert_code;
        catra: 
#line 399
        if ((int )c == 62) {
#line 399
          tmp___62 = s___0;
#line 399
          s___0 ++;
#line 399
          *tmp___62 = (char )'>';
#line 399
          tmp___63 = s___0;
#line 399
          s___0 ++;
#line 399
          *tmp___63 = (char )'>';
          {
#line 399
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 399
            tmp___64 = t;
#line 399
            t ++;
#line 399
            c = *tmp___64;
#line 399
            goto convert_code;
#line 399
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
        }
#line 400
        tmp___65 = s___0;
#line 400
        s___0 ++;
#line 400
        *tmp___65 = (char )'@';
#line 400
        tmp___66 = s___0;
#line 400
        s___0 ++;
#line 400
        *tmp___66 = (char )'>';
#line 400
        goto convert_code;
        crs: 
#line 407
        if ((int )c == 93) {
          {
#line 407
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 407
            tmp___67 = t;
#line 407
            t ++;
#line 407
            c = *tmp___67;
#line 407
            goto ce;
#line 407
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
        }
#line 408
        tmp___68 = s___0;
#line 408
        s___0 ++;
#line 408
        *tmp___68 = (char )']';
#line 408
        goto convert_code;
        ce: ;
#line 414
        if ((int )c == 93) {
          {
#line 414
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 414
            tmp___69 = s___0;
#line 414
            s___0 ++;
#line 414
            *tmp___69 = c;
#line 414
            tmp___70 = t;
#line 414
            t ++;
#line 414
            c = *tmp___70;
#line 414
            goto ce;
#line 414
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
        }
#line 415
        quoting = 0;
#line 513
        if ((unsigned long )s___0 > (unsigned long )p) {
          {
#line 514
          *s___0 = (char)0;
#line 515
          print_pair(out, (char *)"text", p);
          }
        }
        {
#line 517
        p = buf + 2;
#line 517
        s___0 = p;
#line 415
        print_pair(out, (char *)"endquote", (char *)0);
        }
#line 416
        goto convert_docs;
        cla: 
#line 423
        if ((int )c == 60) {
#line 513
          if ((unsigned long )s___0 > (unsigned long )p) {
            {
#line 514
            *s___0 = (char)0;
#line 515
            print_pair(out, (char *)"text", p);
            }
          }
#line 517
          p = buf + 2;
#line 517
          s___0 = p;
          {
#line 423
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 423
            tmp___71 = t;
#line 423
            t ++;
#line 423
            c = *tmp___71;
#line 423
            goto u;
#line 423
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
#line 424
        tmp___72 = s___0;
#line 424
        s___0 ++;
#line 424
        *tmp___72 = (char )'<';
#line 424
        goto convert_code;
        u: ;
#line 435
        if ((int )c == 91) {
          {
#line 435
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 435
            tmp___73 = s___0;
#line 435
            s___0 ++;
#line 435
            *tmp___73 = c;
#line 435
            tmp___74 = t;
#line 435
            t ++;
#line 435
            c = *tmp___74;
#line 435
            goto uls;
#line 435
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
        }
#line 436
        if ((int )c == 93) {
#line 436
          if (quoting) {
            {
#line 436
            while (1) {
              while_continue___34: /* CIL Label */ ;
#line 436
              tmp___75 = t;
#line 436
              t ++;
#line 436
              c = *tmp___75;
#line 436
              goto urs;
#line 436
              goto while_break___34;
            }
            while_break___34: /* CIL Label */ ;
            }
          }
        }
#line 437
        if ((int )c == 62) {
          {
#line 437
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 437
            tmp___76 = t;
#line 437
            t ++;
#line 437
            c = *tmp___76;
#line 437
            goto ura;
#line 437
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
        }
#line 438
        if ((int )c == 0) {
#line 501
          p -= 2;
#line 502
          *(p + 0) = (char )'<';
#line 503
          *(p + 1) = (char )'<';
#line 440
          goto convert_code;
        }
        {
#line 442
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 442
          tmp___77 = s___0;
#line 442
          s___0 ++;
#line 442
          *tmp___77 = c;
#line 442
          tmp___78 = t;
#line 442
          t ++;
#line 442
          c = *tmp___78;
#line 442
          goto u;
#line 442
          goto while_break___36;
        }
        while_break___36: /* CIL Label */ ;
        }
        urs: ;
#line 448
        if ((int )c == 93) {
#line 501
          p -= 2;
#line 502
          *(p + 0) = (char )'<';
#line 503
          *(p + 1) = (char )'<';
          {
#line 450
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 450
            tmp___79 = t;
#line 450
            t ++;
#line 450
            c = *tmp___79;
#line 450
            goto ce;
#line 450
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
        }
#line 452
        tmp___80 = s___0;
#line 452
        s___0 ++;
#line 452
        *tmp___80 = (char )']';
#line 452
        goto u;
        uls: 
#line 457
        if ((int )c == 91) {
          {
#line 457
          while (1) {
            while_continue___38: /* CIL Label */ ;
#line 457
            tmp___81 = s___0;
#line 457
            s___0 ++;
#line 457
            *tmp___81 = c;
#line 457
            tmp___82 = t;
#line 457
            t ++;
#line 457
            c = *tmp___82;
#line 457
            goto uc;
#line 457
            goto while_break___38;
          }
          while_break___38: /* CIL Label */ ;
          }
        }
#line 458
        goto u;
        uc: ;
#line 465
        if ((int )c == 93) {
          {
#line 465
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 465
            tmp___83 = s___0;
#line 465
            s___0 ++;
#line 465
            *tmp___83 = c;
#line 465
            tmp___84 = t;
#line 465
            t ++;
#line 465
            c = *tmp___84;
#line 465
            goto ucrs;
#line 465
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
        }
#line 466
        if ((int )c == 0) {
#line 501
          p -= 2;
#line 502
          *(p + 0) = (char )'<';
#line 503
          *(p + 1) = (char )'<';
#line 468
          goto convert_code;
        }
        {
#line 470
        while (1) {
          while_continue___40: /* CIL Label */ ;
#line 470
          tmp___85 = s___0;
#line 470
          s___0 ++;
#line 470
          *tmp___85 = c;
#line 470
          tmp___86 = t;
#line 470
          t ++;
#line 470
          c = *tmp___86;
#line 470
          goto uc;
#line 470
          goto while_break___40;
        }
        while_break___40: /* CIL Label */ ;
        }
        ucrs: 
#line 475
        if ((int )c == 93) {
          {
#line 475
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 475
            tmp___87 = s___0;
#line 475
            s___0 ++;
#line 475
            *tmp___87 = c;
#line 475
            tmp___88 = t;
#line 475
            t ++;
#line 475
            c = *tmp___88;
#line 475
            goto uce;
#line 475
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
        }
#line 476
        goto uc;
        uce: 
#line 481
        if ((int )c == 93) {
          {
#line 481
          while (1) {
            while_continue___42: /* CIL Label */ ;
#line 481
            tmp___89 = s___0;
#line 481
            s___0 ++;
#line 481
            *tmp___89 = c;
#line 481
            tmp___90 = t;
#line 481
            t ++;
#line 481
            c = *tmp___90;
#line 481
            goto uce;
#line 481
            goto while_break___42;
          }
          while_break___42: /* CIL Label */ ;
          }
        }
#line 482
        goto u;
        ura: 
#line 487
        if ((int )c == 62) {
          {
#line 520
          *s___0 = (char)0;
#line 521
          print_pair(out, (char *)"use", p);
#line 522
          p = buf + 2;
#line 522
          s___0 = p;
          }
          {
#line 487
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 487
            tmp___91 = t;
#line 487
            t ++;
#line 487
            c = *tmp___91;
#line 487
            goto convert_code;
#line 487
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
        }
#line 488
        tmp___92 = s___0;
#line 488
        s___0 ++;
#line 488
        *tmp___92 = (char )'>';
#line 488
        goto u;
        done_converting: ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 542
  if (quoting) {
    {
#line 543
    errorat(filename, last_open_quote, (enum errorlevel )1, (char *)"open quote `[[\' never closed");
#line 544
    quoting = 0;
    }
  }
#line 174
  if (missing_newline) {
    {
#line 174
    print_pair(out, (char *)"nl", (char *)0);
    }
  }
  {
#line 165
  print_state(out, (Mark )2, state, count);
  }
#line 95
  return;
}
}
#line 551 "markmain.nw"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 555
  progname = *(argv + 0);
#line 556
  i = 1;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (i < argc) {
#line 556
      if ((int )*(*(argv + i) + 0) == 45) {
#line 556
        if (! ((int )*(*(argv + i) + 1) != 0)) {
#line 556
          goto while_break;
        }
      } else {
#line 556
        goto while_break;
      }
    } else {
#line 556
      goto while_break;
    }
    {
#line 558
    if ((int )*(*(argv + i) + 1) == 116) {
#line 558
      goto case_116;
    }
#line 559
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 582
    tmp = __ctype_b_loc();
    }
#line 582
    if ((int const   )*(*tmp + (int )*(*(argv + i) + 2)) & 2048) {
      {
#line 583
      tabsize = atoi((char const   *)(*(argv + i) + 2));
      }
    } else
#line 584
    if ((int )*(*(argv + i) + 2) == 0) {
#line 585
      tabsize = 0;
    } else {
      {
#line 587
      errormsg((enum errorlevel )2, (char *)"%s: ill-formed option %s", progname,
               *(argv + i));
      }
    }
#line 558
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 559
    errormsg((enum errorlevel )2, (char *)"%s: unknown option -%c", progname, (int )*(*(argv + i) + 1));
    }
#line 560
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 556
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  if (i < argc) {
    {
#line 563
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (i < argc)) {
#line 563
        goto while_break___0;
      }
      {
#line 564
      tmp___0 = strcmp((char const   *)*(argv + i), "-");
      }
#line 564
      if (tmp___0) {
        {
#line 567
        fp = fopen((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"r");
        }
#line 567
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 568
          errormsg((enum errorlevel )2, (char *)"%s: couldn\'t open file %s", progname,
                   *(argv + i));
#line 569
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"@fatal couldn\'t open file %s\n",
                  *(argv + i));
          }
        } else {
          {
#line 571
          markup(fp, stdout, *(argv + i));
#line 572
          fclose(fp);
          }
        }
      } else {
        {
#line 565
        markup(stdin, stdout, (char *)"");
        }
      }
#line 563
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 576
    markup(stdin, stdout, (char *)"");
    }
  }
  {
#line 577
  nowebexit((char *)((void *)0));
  }
#line 578
  return ((int )errorlevel);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/markup.h"
char at_sign ;
#line 6
char *mod_start(char *s , int mark ) ;
#line 7
char *mod_end(char *s , int mark ) ;
#line 12
char *find_escaped(char *s , char *search , char *escape , int mark ) ;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/strsave.h"
char *strsave(char *s ) ;
#line 62 "markup.nw"
char at_sign  =    (char )'@';
#line 86 "markup.nw"
static char def_marker[7]  = {      (char )' ',      (char )'%',      (char )'d',      (char )'e', 
        (char )'f',      (char )' ',      (char )'\000'};
#line 72 "markup.nw"
int starts_doc(char *line ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 73
  if ((int )*line == (int )at_sign) {
#line 73
    if ((int )*(line + 1) == 0) {
#line 73
      tmp___0 = 1;
    } else {
      {
#line 73
      tmp = __ctype_b_loc();
      }
#line 73
      if ((int const   )*(*tmp + (int )*(line + 1)) & 8192) {
#line 73
        tmp___0 = 1;
      } else {
#line 73
        tmp___0 = 0;
      }
    }
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  return (tmp___0);
}
}
#line 76 "markup.nw"
char *first_doc_line(char *line ) 
{ 


  {
#line 77
  if ((int )*(line + 1) != 0) {
#line 77
    if ((int )*(line + 1) != 10) {
#line 77
      return (line + 2);
    } else {
#line 78
      return (line + 1);
    }
  } else {
#line 78
    return (line + 1);
  }
}
}
#line 91 "markup.nw"
static int complained  ;
#line 102 "markup.nw"
static int checked  =    0;
#line 89 "markup.nw"
int is_def(char *line ) 
{ 
  int answer ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  if (! checked) {
    {
#line 104
    tmp = strlen((char const   *)(def_marker));
    }
#line 104
    if (! (tmp == 6UL)) {
      {
#line 104
      __assert_fail("strlen(def_marker) == (6)", "markup.nw", 104U, "is_def");
      }
    }
#line 105
    checked = 1;
  }
#line 93
  if ((int )*line == (int )at_sign) {
    {
#line 93
    tmp___0 = strncmp((char const   *)(line + 1), (char const   *)(def_marker), (size_t )6);
    }
#line 93
    if (tmp___0) {
#line 93
      tmp___1 = 0;
    } else {
#line 93
      tmp___1 = 1;
    }
  } else {
#line 93
    tmp___1 = 0;
  }
#line 93
  answer = tmp___1;
#line 112
  if (answer) {
#line 112
    if (! complained) {
#line 113
      complained = 1;
    }
  }
#line 95
  return (answer);
}
}
#line 98 "markup.nw"
char *remove_def_marker(char *line ) 
{ 


  {
#line 99
  return ((line + 1) + 6);
}
}
#line 142 "markup.nw"
char *mod_start(char *s , int mark ) 
{ 
  char *tmp ;

  {
  {
#line 143
  tmp = find_escaped(s, (char *)"<<", (char *)"@<<", mark);
  }
#line 143
  return (tmp);
}
}
#line 145 "markup.nw"
char *mod_end(char *s , int mark ) 
{ 
  char *tmp ;

  {
  {
#line 146
  tmp = find_escaped(s, (char *)">>", (char *)"@>>", mark);
  }
#line 146
  return (tmp);
}
}
#line 157 "markup.nw"
int starts_code(char *line , char *filename , int lineno ) 
{ 
  char *tail ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 159
  tmp = mod_start(line, 0);
  }
#line 159
  if ((unsigned long )tmp != (unsigned long )(line + 2)) {
#line 159
    return (0);
  }
  {
#line 160
  tail = mod_end(line + 2, 0);
  }
#line 161
  if ((unsigned long )tail == (unsigned long )((void *)0)) {
    {
#line 180
    errorat(filename, lineno, (enum errorlevel )2, (char *)"Module name doesn\'t end",
            line);
    }
#line 181
    return (0);
  }
#line 162
  tmp___0 = tail;
#line 162
  tail ++;
#line 162
  if ((int )*tmp___0 != 61) {
#line 162
    return (0);
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    tmp___1 = __ctype_b_loc();
    }
#line 163
    if (! ((int const   )*(*tmp___1 + (int )*tail) & 8192)) {
#line 163
      goto while_break;
    }
#line 163
    tail ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return ((int )*tail == 0);
}
}
#line 167 "markup.nw"
void getmodname(char *dest , int size , char *source ) 
{ 
  char *p ;
  char *tmp ;
  char *q ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 169
  tmp = strsave(source);
#line 169
  p = tmp;
#line 170
  tmp___0 = mod_start(p, 1);
#line 170
  q = tmp___0;
  }
#line 172
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)p);
#line 186
    errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "I couldn\'t manage to extract a module name, but I\'m sure I saw one");
    }
  }
  {
#line 173
  tmp___1 = mod_end(q, 1);
  }
#line 173
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 185
    free((void *)p);
#line 186
    errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "I couldn\'t manage to extract a module name, but I\'m sure I saw one");
    }
  }
  {
#line 174
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)q, (size_t )(size - 1));
#line 175
  *(dest + (size - 1)) = (char )'\000';
#line 176
  free((void *)p);
  }
#line 177
  return;
}
}
#line 207 "markup.nw"
char *find_escaped(char *s , char *search , char *escape , int mark ) 
{ 
  register char first ;
  register char first_escape ;
  int tmp ;
  int searchlen ;
  size_t tmp___0 ;
  int escapelen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 208
  first = *search;
#line 209
  if ((unsigned long )escape != (unsigned long )((void *)0)) {
#line 209
    tmp = (int )*escape;
  } else {
#line 209
    tmp = '\000';
  }
  {
#line 209
  first_escape = (char )tmp;
#line 210
  tmp___0 = strlen((char const   *)search);
#line 210
  searchlen = (int )tmp___0;
  }
#line 211
  if ((unsigned long )escape != (unsigned long )((void *)0)) {
    {
#line 211
    tmp___1 = strlen((char const   *)escape);
#line 211
    tmp___2 = tmp___1;
    }
  } else {
#line 211
    tmp___2 = (size_t )0;
  }
#line 211
  escapelen = (int )tmp___2;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (*s) {
#line 214
        if ((int )*s != (int )first) {
#line 214
          if (! ((int )*s != (int )first_escape)) {
#line 214
            goto while_break___0;
          }
        } else {
#line 214
          goto while_break___0;
        }
      } else {
#line 214
        goto while_break___0;
      }
#line 214
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 215
    if (! *s) {
#line 215
      goto while_break;
    }
#line 216
    if (first_escape) {
      {
#line 216
      tmp___3 = strncmp((char const   *)s, (char const   *)escape, (size_t )escapelen);
      }
#line 216
      if (! tmp___3) {
#line 217
        s += escapelen;
#line 218
        goto __Cont;
      }
    }
    {
#line 220
    tmp___4 = strncmp((char const   *)s, (char const   *)search, (size_t )searchlen);
    }
#line 220
    if (! tmp___4) {
#line 220
      goto while_break;
    }
#line 221
    s ++;
    __Cont: /* CIL Label */ 
#line 213
    if (! ((int )*s != 0)) {
#line 213
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if ((int )*s == 0) {
#line 224
    return ((char *)((void *)0));
  }
#line 225
  if (mark) {
#line 225
    *s = (char )'\000';
  }
#line 226
  return (s + searchlen);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 14 "strsave.nw"
char *strsave(char *s ) 
{ 
  char *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 15
  tmp = strlen((char const   *)s);
#line 15
  tmp___0 = malloc(tmp + 1UL);
#line 15
  t = (char *)tmp___0;
  }
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! t) {
      {
#line 16
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 16
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
#line 18
  return (t);
}
}
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/match.h"
int is_keyword(char *line , char *keyword ) ;
#line 2
int is_begin(char *line , char *type ) ;
#line 3
int is_end(char *line , char *type ) ;
#line 4
int is_index(char *line , char *type ) ;
#line 14 "match.nw"
static int matches(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 22 "match.nw"
int is_keyword(char *line , char *keyword ) 
{ 
  char low_at_sign___1 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 23
  low_at_sign___1 = (char )'@';
#line 24
  if ((int )*line == (int )low_at_sign___1) {
    {
#line 24
    tmp = matches(line + 1, keyword);
    }
#line 24
    if (tmp) {
      {
#line 24
      tmp___0 = strlen((char const   *)keyword);
      }
#line 24
      if ((int )*(line + (tmp___0 + 1UL)) == 32) {
#line 24
        tmp___3 = 1;
      } else {
        {
#line 24
        tmp___1 = strlen((char const   *)keyword);
        }
#line 24
        if ((int )*(line + (tmp___1 + 1UL)) == 10) {
#line 24
          tmp___3 = 1;
        } else {
          {
#line 24
          tmp___2 = strlen((char const   *)keyword);
          }
#line 24
          if ((int )*(line + (tmp___2 + 1UL)) == 0) {
#line 24
            tmp___3 = 1;
          } else {
#line 24
            tmp___3 = 0;
          }
        }
      }
    } else {
#line 24
      tmp___3 = 0;
    }
  } else {
#line 24
    tmp___3 = 0;
  }
#line 24
  return (tmp___3);
}
}
#line 28 "match.nw"
int is_begin(char *line , char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 29
  tmp = is_keyword(line, (char *)"begin");
  }
#line 29
  if (tmp) {
    {
#line 29
    tmp___0 = matches((line + 1) + 6, type);
    }
#line 29
    if (tmp___0) {
#line 29
      tmp___1 = 1;
    } else {
#line 29
      tmp___1 = 0;
    }
  } else {
#line 29
    tmp___1 = 0;
  }
#line 29
  return (tmp___1);
}
}
#line 31 "match.nw"
int is_end(char *line , char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp = is_keyword(line, (char *)"end");
  }
#line 32
  if (tmp) {
    {
#line 32
    tmp___0 = matches((line + 1) + 4, type);
    }
#line 32
    if (tmp___0) {
#line 32
      tmp___1 = 1;
    } else {
#line 32
      tmp___1 = 0;
    }
  } else {
#line 32
    tmp___1 = 0;
  }
#line 32
  return (tmp___1);
}
}
#line 34 "match.nw"
int is_index(char *line , char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 35
  tmp = is_keyword(line, (char *)"index");
  }
#line 35
  if (tmp) {
    {
#line 35
    tmp___0 = matches((line + 1) + 6, type);
    }
#line 35
    if (tmp___0) {
#line 35
      tmp___1 = 1;
    } else {
#line 35
      tmp___1 = 0;
    }
  } else {
#line 35
    tmp___1 = 0;
  }
#line 35
  return (tmp___1);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 209
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 31 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
int expand(Module mp , int indent , int partial_distance , Parent parent , char *locformat___1 ,
           FILE *out ) ;
#line 34
void resetloc(void) ;
#line 36
void remove_final_newline(Module mp ) ;
#line 2 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modtrees.h"
Module lookup(char *modname ) ;
#line 3
void apply_each_module(void (*fun)(Module  ) ) ;
#line 2 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/notangle.h"
void read_defs(FILE *in ) ;
#line 52 "mnt.nw"
void add_uses_to_usecounts(Module mp ) ;
#line 53
void emit_if_unused_and_conforming(Module mp ) ;
#line 86
static void emitfile(char *modname ) ;
#line 26 "mnt.nw"
static char *locformat  =    (char *)"#line %L \"%F\"%N";
#line 55 "mnt.nw"
void add_uses_to_usecounts(Module mp ) 
{ 
  Module used ;
  struct modpart *p ;

  {
#line 58
  p = mp->head;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 58
      goto while_break;
    }
#line 59
    if ((unsigned int )p->ptype == 2U) {
      {
#line 60
      used = lookup(p->contents);
      }
#line 61
      if ((unsigned long )used != (unsigned long )((void *)0)) {
#line 62
        (used->usecount) ++;
      }
    }
#line 58
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 71 "mnt.nw"
void emit_if_unused_and_conforming(Module mp ) 
{ 
  char *index ;
  int tmp ;
  char *tmp___0 ;

  {
#line 73
  if (mp->usecount == 0) {
    {
#line 73
    tmp___0 = strpbrk((char const   *)mp->name, " \n\t\v\r\f");
    }
#line 73
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 74
      index = strpbrk((char const   *)mp->name, "[](){}!$&<>*?;|^`\'\\\"");
      }
#line 74
      if ((unsigned long )index == (unsigned long )((void *)0)) {
#line 74
        tmp = 1;
      } else
#line 74
      if ((int )*(index + 0) == 42) {
#line 74
        if ((int )*(index + 1) == 0) {
#line 74
          tmp = 1;
        } else {
#line 74
          tmp = 0;
        }
      } else {
#line 74
        tmp = 0;
      }
#line 74
      if (tmp) {
#line 76
        if ((unsigned long )index == (unsigned long )mp->name) {
          {
#line 77
          errormsg((enum errorlevel )2, (char *)"<<*>> is not a good chunk name for noweb; use notangle instead");
          }
        } else {
          {
#line 80
          emitfile(mp->name);
          }
        }
      } else {
        {
#line 82
        errormsg((enum errorlevel )2, (char *)"<<%s>> cannot be an output chunk; it contains a metacharacter",
                 mp->name);
        }
      }
    }
  }
#line 84
  return;
}
}
#line 88 "mnt.nw"
static void emitfile(char *modname ) 
{ 
  Module root___3 ;
  Module tmp ;
  char *tempname ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *fp ;
  char *lfmt ;
  char *filename ;
  int n ;
  size_t tmp___2 ;
  FILE *dest ;
  FILE *tmp___3 ;
  int x ;
  int y ;
  FILE *fp___0 ;
  FILE *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 89
  tmp = lookup(modname);
#line 89
  root___3 = tmp;
#line 90
  tmp___0 = tmpnam((char *)((void *)0));
#line 90
  tmp___1 = strsave(tmp___0);
#line 90
  tempname = tmp___1;
#line 108
  tmp___2 = strlen((char const   *)modname);
#line 108
  n = (int )(tmp___2 - 1UL);
  }
#line 109
  if (n >= 0) {
#line 109
    if ((int )*(modname + n) == 42) {
      {
#line 110
      lfmt = locformat;
#line 111
      filename = strsave(modname);
#line 112
      *(filename + n) = (char)0;
      }
    } else {
#line 114
      lfmt = (char *)"";
#line 115
      filename = modname;
    }
  } else {
#line 114
    lfmt = (char *)"";
#line 115
    filename = modname;
  }
#line 147
  if ((unsigned long )root___3 == (unsigned long )((void *)0)) {
    {
#line 148
    errormsg((enum errorlevel )2, (char *)"Chunk <<%s>> is undefined", filename);
    }
#line 149
    return;
  }
  {
#line 95
  fp = fopen((char const   */* __restrict  */)tempname, (char const   */* __restrict  */)"w");
  }
#line 96
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 96
    errormsg((enum errorlevel )3, (char *)"Can\'t open temporary file %s", tempname);
    }
  }
  {
#line 119
  resetloc();
#line 120
  expand(root___3, 0, 0, (Parent )0, lfmt, fp);
#line 121
  _IO_putc('\n', fp);
#line 122
  fclose(fp);
#line 126
  dest = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 127
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
    {
#line 129
    tmp___3 = fopen((char const   */* __restrict  */)tempname, (char const   */* __restrict  */)"r");
    }
#line 130
    if (! tmp___3) {
      {
#line 130
      __assert_fail("tmp", "mnt.nw", 130U, "emitfile");
      }
    }
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 132
      x = _IO_getc(tmp___3);
#line 133
      y = _IO_getc(dest);
      }
#line 131
      if (x == y) {
#line 131
        if (! (x != -1)) {
#line 131
          goto while_break;
        }
      } else {
#line 131
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 135
    fclose(tmp___3);
#line 136
    fclose(dest);
    }
#line 137
    if (x == y) {
      {
#line 138
      remove((char const   *)tempname);
      }
#line 139
      return;
    }
  }
  {
#line 99
  remove((char const   *)filename);
#line 100
  tmp___5 = rename((char const   *)tempname, (char const   *)filename);
  }
#line 100
  if (tmp___5 != 0) {
    {
#line 101
    tmp___4 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
#line 101
    fp___0 = tmp___4;
    }
#line 102
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 102
      remove((char const   *)tempname);
#line 144
      errormsg((enum errorlevel )2, (char *)"Can\'t open output file %s", filename);
      }
#line 145
      return;
    }
    {
#line 119
    resetloc();
#line 120
    expand(root___3, 0, 0, (Parent )0, lfmt, fp___0);
#line 121
    _IO_putc('\n', fp___0);
#line 122
    fclose(fp___0);
#line 104
    remove((char const   *)tempname);
    }
  }
#line 106
  return;
}
}
#line 28 "getline.nw"
static char *buf1___0  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___0  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___0  =    128;
#line 19 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
Module newmodule(char *modname ) ;
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modtrees.h"
Module insert(char *modname ) ;
#line 29 "modtrees.nw"
static struct tnode *root  =    (struct tnode *)((void *)0);
#line 60
static Module insert_tree(TNODE **rootptr , char *modname ) ;
#line 61
static Module lookup_tree(TNODE **rootptr , char *modname ) ;
#line 33 "modtrees.nw"
Module insert(char *modname ) 
{ 
  Module tmp ;

  {
  {
#line 34
  tmp = insert_tree(& root, modname);
  }
#line 34
  return (tmp);
}
}
#line 37 "modtrees.nw"
static Module insert_tree(TNODE **rootptr , char *modname ) 
{ 
  TNODE *tmp ;
  void *tmp___0 ;
  struct tnode *tmp___1 ;
  Module tmp___2 ;
  Module tmp___3 ;
  Module tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 39
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      tmp___0 = malloc(sizeof(struct tnode ));
#line 56
      tmp = (struct tnode *)tmp___0;
#line 56
      *rootptr = tmp;
      }
#line 56
      if (! tmp) {
        {
#line 56
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    tmp___1 = (struct tnode *)((void *)0);
#line 57
    (*rootptr)->right = tmp___1;
#line 57
    (*rootptr)->left = tmp___1;
#line 41
    tmp___2 = newmodule(modname);
#line 41
    (*rootptr)->data = tmp___2;
    }
#line 41
    return (tmp___2);
  }
  {
#line 43
  tmp___6 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 43
  if (tmp___6 == 0) {
#line 44
    return ((*rootptr)->data);
  } else {
    {
#line 45
    tmp___5 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 45
    if (tmp___5 < 0) {
      {
#line 46
      tmp___3 = insert_tree(& (*rootptr)->left, modname);
      }
#line 46
      return (tmp___3);
    } else {
      {
#line 48
      tmp___4 = insert_tree(& (*rootptr)->right, modname);
      }
#line 48
      return (tmp___4);
    }
  }
}
}
#line 64 "modtrees.nw"
Module lookup(char *modname ) 
{ 
  Module tmp ;

  {
  {
#line 65
  tmp = lookup_tree(& root, modname);
  }
#line 65
  return (tmp);
}
}
#line 68 "modtrees.nw"
static Module lookup_tree(TNODE **rootptr , char *modname ) 
{ 
  Module tmp ;
  Module tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 70
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
#line 71
    return ((Module )((void *)0));
  }
  {
#line 73
  tmp___2 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 73
  if (tmp___2 == 0) {
#line 74
    return ((*rootptr)->data);
  } else {
    {
#line 75
    tmp___1 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 75
    if (tmp___1 < 0) {
      {
#line 76
      tmp = lookup_tree(& (*rootptr)->left, modname);
      }
#line 76
      return (tmp);
    } else {
      {
#line 78
      tmp___0 = lookup_tree(& (*rootptr)->right, modname);
      }
#line 78
      return (tmp___0);
    }
  }
}
}
#line 88 "modtrees.nw"
static void apply_to_tree(TNODE *p , void (*fun)(Module  ) ) 
{ 


  {
#line 90
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 91
    apply_to_tree(p->left, fun);
#line 92
    (*fun)(p->data);
#line 93
    apply_to_tree(p->right, fun);
    }
  }
#line 95
  return;
}
}
#line 96 "modtrees.nw"
void apply_each_module(void (*fun)(Module  ) ) 
{ 


  {
  {
#line 97
  apply_to_tree(root, fun);
  }
#line 98
  return;
}
}
#line 25 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/modules.h"
void add_part(Module mp , char *s , Parttype type , Location *loc ) ;
#line 35
int printloc(FILE *fp , char *fmt , Location loc , int partial ) ;
#line 62 "modules.nw"
static struct modpart *newmodpart(int type , char *s , Location *loc ) ;
#line 65
static void append(Module mp , struct modpart *p ) ;
#line 67
static int seekcycle(Module mp , Parent parent ) ;
#line 68 "modules.nw"
static char *lastfilename  =    (char *)0;
#line 69 "modules.nw"
static int lastlineno  =    -1;
#line 70 "modules.nw"
Module newmodule(char *modname ) 
{ 
  Module p ;
  void *tmp ;
  struct modpart *tmp___0 ;

  {
  {
#line 71
  tmp = malloc(sizeof(struct module ));
#line 71
  p = (Module )tmp;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! p) {
      {
#line 72
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  p->name = strsave(modname);
#line 74
  p->usecount = 0;
#line 75
  tmp___0 = (struct modpart *)((void *)0);
#line 75
  p->tail = tmp___0;
#line 75
  p->head = tmp___0;
  }
#line 76
  return (p);
}
}
#line 78 "modules.nw"
void add_part(Module mp , char *s , Parttype type , Location *loc ) 
{ 
  struct modpart *p ;
  struct modpart *tmp ;

  {
  {
#line 79
  tmp = newmodpart((int )type, s, loc);
#line 79
  p = tmp;
#line 80
  append(mp, p);
  }
#line 81
  return;
}
}
#line 82 "modules.nw"
static struct modpart *newmodpart(int type , char *s , Location *loc ) 
{ 
  struct modpart *p ;
  void *tmp ;
  int k ;
  size_t tmp___0 ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct modpart ));
#line 84
  p = (struct modpart *)tmp;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! p) {
      {
#line 85
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  p->ptype = (Parttype )type;
#line 87
  if (s) {
    {
#line 88
    p->contents = strsave(s);
#line 89
    tmp___0 = strlen((char const   *)p->contents);
#line 89
    k = (int )(tmp___0 - 1UL);
    }
#line 90
    if ((int )*(p->contents + k) == 10) {
#line 90
      *(p->contents + k) = (char )'\000';
    } else {
      {
#line 91
      errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "input line doesn\'t end with newline");
      }
    }
  }
#line 94
  if (loc) {
#line 94
    p->loc = *loc;
  }
#line 95
  p->next = (struct modpart *)((void *)0);
#line 96
  return (p);
}
}
#line 98 "modules.nw"
static void append(Module mp , struct modpart *p ) 
{ 
  struct modpart *tmp ;

  {
#line 101
  if ((unsigned long )mp->head == (unsigned long )((void *)0)) {
#line 102
    tmp = p;
#line 102
    mp->tail = tmp;
#line 102
    mp->head = tmp;
  } else {
#line 104
    (mp->tail)->next = p;
#line 105
    mp->tail = p;
  }
#line 107
  return;
}
}
#line 108 "modules.nw"
void resetloc(void) 
{ 


  {
#line 109
  lastfilename = (char *)0;
#line 110
  lastlineno = -1;
#line 111
  return;
}
}
#line 112 "modules.nw"
int expand(Module mp , int indent , int partial_distance , Parent parent , char *locformat___1 ,
           FILE *out ) 
{ 
  struct modpart *p ;
  Module newmod ;
  int error ;
  struct parent thismodule ;
  int tmp ;
  int tmp___0 ;
  int retcode ;
  int tmp___1 ;

  {
  {
#line 116
  error = 0;
#line 119
  thismodule.this = mp;
#line 120
  thismodule.parent = parent;
#line 121
  tmp = seekcycle(mp, parent);
  }
#line 121
  if (tmp) {
    {
#line 122
    errormsg((enum errorlevel )2, (char *)"<<%s>>", mp->name);
    }
#line 123
    return (2);
  }
#line 126
  p = mp->head;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 126
      goto while_break;
    }
    {
#line 128
    if ((unsigned int )p->ptype == 1U) {
#line 128
      goto case_1;
    }
#line 139
    if ((unsigned int )p->ptype == 2U) {
#line 139
      goto case_2;
    }
#line 156
    if ((unsigned int )p->ptype == 3U) {
#line 156
      goto case_3;
    }
#line 159
    goto switch_default;
    case_1: /* CIL Label */ 
#line 128
    if ((int )*(p->contents) != 0) {
#line 129
      if (*locformat___1) {
        {
#line 130
        tmp___0 = printloc(out, locformat___1, p->loc, partial_distance);
        }
#line 130
        if (tmp___0) {
#line 130
          if ((unsigned long )p != (unsigned long )mp->head) {
            {
#line 131
            indent_for(partial_distance, out);
            }
          }
        }
      } else
#line 132
      if (partial_distance == 0) {
        {
#line 133
        indent_for(indent, out);
#line 134
        partial_distance = indent;
        }
      }
      {
#line 136
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
              p->contents);
#line 137
      partial_distance = limitcolumn(p->contents, partial_distance);
      }
    }
#line 138
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 139
    newmod = lookup(p->contents);
    }
#line 140
    if ((unsigned long )newmod == (unsigned long )((void *)0)) {
      {
#line 141
      errormsg((enum errorlevel )2, (char *)"ignoring undefined chunk name: <<%s>>",
               p->contents);
#line 142
      error = 2;
#line 143
      printf((char const   */* __restrict  */)"<<%s>>", p->contents);
      }
    } else {
#line 146
      if ((int )*locformat___1 == 0) {
#line 146
        if (partial_distance == 0) {
          {
#line 147
          indent_for(indent, out);
#line 148
          partial_distance = indent;
          }
        }
      }
      {
#line 150
      retcode = expand(newmod, partial_distance, partial_distance, & thismodule, locformat___1,
                       out);
      }
#line 152
      if (retcode > error) {
#line 152
        error = retcode;
      }
    }
    {
#line 154
    tmp___1 = limitcolumn(p->contents, partial_distance + 2);
#line 154
    partial_distance = tmp___1 + 2;
    }
#line 155
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 156
    partial_distance = 0;
#line 157
    _IO_putc('\n', out);
#line 158
    lastlineno ++;
    }
#line 158
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 159
    errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "bad part type");
    }
    switch_break: /* CIL Label */ ;
    }
#line 126
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (error);
}
}
#line 164 "modules.nw"
static int seekcycle(Module mp , Parent parent ) 
{ 
  int tmp ;

  {
#line 165
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 166
    return (0);
  } else
#line 167
  if ((unsigned long )parent->this == (unsigned long )mp) {
#line 167
    goto _L;
  } else {
    {
#line 167
    tmp = seekcycle(mp, parent->parent);
    }
#line 167
    if (tmp) {
      _L: /* CIL Label */ 
#line 168
      if ((unsigned long )parent->this == (unsigned long )mp) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic code chunks: ");
        }
      }
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<%s>> -> ",
              (parent->this)->name);
      }
#line 171
      return (1);
    } else {
#line 173
      return (0);
    }
  }
}
}
#line 194 "modules.nw"
static int complained___0  =    0;
#line 201 "modules.nw"
static int complained___1  =    0;
#line 176 "modules.nw"
int printloc(FILE *fp , char *fmt , Location loc , int partial ) 
{ 
  char *p ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 178
  if (*fmt) {
#line 178
    if ((unsigned long )loc.filename != (unsigned long )lastfilename) {
#line 178
      goto _L___0;
    } else
#line 178
    if (lastlineno != loc.lineno) {
      _L___0: /* CIL Label */ 
#line 180
      if (partial) {
        {
#line 180
        _IO_putc('\n', fp);
        }
      }
#line 181
      p = fmt;
      {
#line 181
      while (1) {
        while_continue: /* CIL Label */ ;
#line 181
        if (! *p) {
#line 181
          goto while_break;
        }
#line 182
        if ((int )*p == 37) {
#line 183
          p ++;
          {
#line 184
          if ((int )*p == 37) {
#line 184
            goto case_37;
          }
#line 185
          if ((int )*p == 78) {
#line 185
            goto case_78;
          }
#line 186
          if ((int )*p == 70) {
#line 186
            goto case_70;
          }
#line 187
          if ((int )*p == 76) {
#line 187
            goto case_76;
          }
#line 188
          if ((int )*p == 43) {
#line 188
            goto case_43;
          }
#line 188
          if ((int )*p == 45) {
#line 188
            goto case_43;
          }
#line 201
          goto switch_default;
          case_37: /* CIL Label */ 
          {
#line 184
          _IO_putc('%', fp);
          }
#line 184
          goto switch_break;
          case_78: /* CIL Label */ 
          {
#line 185
          _IO_putc('\n', fp);
          }
#line 185
          goto switch_break;
          case_70: /* CIL Label */ 
          {
#line 186
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
                  loc.filename);
          }
#line 186
          goto switch_break;
          case_76: /* CIL Label */ 
          {
#line 187
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d",
                  loc.lineno);
          }
#line 187
          goto switch_break;
          case_43: /* CIL Label */ 
          case_45: /* CIL Label */ 
          {
#line 189
          tmp___0 = __ctype_b_loc();
          }
#line 189
          if ((int const   )*(*tmp___0 + (int )*(p + 1)) & 2048) {
#line 189
            if ((int )*(p + 2) == 76) {
#line 190
              if ((int )*p == 43) {
#line 190
                tmp = loc.lineno + ((int )*(p + 1) - 48);
              } else {
#line 190
                tmp = loc.lineno - ((int )*(p + 1) - 48);
              }
              {
#line 190
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d",
                      tmp);
#line 192
              p += 2;
              }
            } else {
#line 189
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 195
          if (! complained___0) {
            {
#line 196
            errormsg((enum errorlevel )2, (char *)"Bad format sequence ``%%%c\'\' in -L%s",
                     (int )*p, fmt);
#line 197
            complained___0 = 1;
            }
          }
#line 200
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 202
          if (! complained___1) {
            {
#line 203
            errormsg((enum errorlevel )2, (char *)"Bad format sequence ``%%%c\'\' in -L%s",
                     (int )*p, fmt);
#line 204
            complained___1 = 1;
            }
          }
#line 206
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 208
          _IO_putc((int )*p, fp);
          }
        }
#line 181
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 210
      lastfilename = loc.filename;
#line 211
      lastlineno = loc.lineno;
#line 212
      return (1);
    } else {
#line 213
      return (0);
    }
  } else {
#line 213
    return (0);
  }
}
}
#line 215 "modules.nw"
void remove_final_newline(Module mp ) 
{ 
  struct modpart *tmp ;
  struct modpart *p ;

  {
#line 217
  if ((unsigned long )mp->tail == (unsigned long )((void *)0)) {
#line 218
    return;
  }
#line 219
  if (! ((unsigned int )(mp->tail)->ptype != 3U)) {
#line 223
    if ((unsigned long )mp->tail == (unsigned long )mp->head) {
#line 224
      tmp = (struct modpart *)((void *)0);
#line 224
      mp->tail = tmp;
#line 224
      mp->head = tmp;
    } else {
#line 226
      p = mp->head;
      {
#line 227
      while (1) {
        while_continue: /* CIL Label */ ;
#line 227
        if (! ((unsigned long )p->next != (unsigned long )mp->tail)) {
#line 227
          goto while_break;
        }
#line 227
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 228
      p->next = (struct modpart *)((void *)0);
    }
  }
#line 230
  return;
}
}
#line 1 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/notangle.h"
void emit_module_named(FILE *out , char *rootname , char *locformat___1 ) ;
#line 161 "notangle.nw"
static void warn_dots(char *modname ) ;
#line 180
void insist(char *line , char *keyword , char *msg ) ;
#line 37 "notangle.nw"
void emit_module_named(FILE *out , char *rootname , char *locformat___1 ) 
{ 
  Module root___3 ;

  {
  {
#line 38
  root___3 = (Module )((void *)0);
#line 40
  root___3 = lookup(rootname);
  }
#line 165
  if ((unsigned long )root___3 == (unsigned long )((void *)0)) {
    {
#line 166
    errormsg((enum errorlevel )3, (char *)"The root module <<%s>> was not defined.",
             rootname);
    }
#line 167
    return;
  }
  {
#line 42
  expand(root___3, 0, 0, (Parent )0, locformat___1, out);
#line 43
  _IO_putc('\n', out);
  }
#line 44
  return;
}
}
#line 56 "notangle.nw"
void read_defs(FILE *in ) 
{ 
  char modname[256] ;
  unsigned int tmp ;
  Module modptr ;
  char *line ;
  Location loc ;
  int tmp___0 ;
  char temp[256] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char temp___0[256] ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *p ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char temp___1[256] ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  char temp___2[256] ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  char *p___0 ;
  unsigned short const   **tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 57
  modname[0] = (char )'\000';
#line 57
  tmp = 1U;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (tmp >= 256U) {
#line 57
      goto while_break;
    }
#line 57
    modname[tmp] = (char)0;
#line 57
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  modptr = (Module )((void *)0);
#line 60
  line = (char *)((void *)0);
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 63
    line = getline(in);
    }
#line 63
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 63
      goto while_break___0;
    }
    {
#line 64
    tmp___0 = is_keyword(line, (char *)"fatal");
    }
#line 64
    if (tmp___0) {
      {
#line 64
      exit(1);
      }
    }
    {
#line 101
    tmp___12 = is_keyword(line, (char *)"nl");
    }
#line 101
    if (tmp___12) {
#line 102
      (loc.lineno) ++;
    } else {
      {
#line 101
      tmp___13 = is_index(line, (char *)"nl");
      }
#line 101
      if (tmp___13) {
#line 102
        (loc.lineno) ++;
      } else {
        {
#line 113
        tmp___11 = is_keyword(line, (char *)"file");
        }
#line 113
        if (tmp___11) {
          {
#line 127
          tmp___1 = strlen((char const   *)line);
#line 127
          tmp___2 = strlen("@file ");
          }
#line 127
          if (tmp___1 >= 255UL + tmp___2) {
            {
#line 128
            errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "file name size");
            }
          }
          {
#line 129
          tmp___3 = strlen("@file ");
#line 129
          strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)(line + tmp___3));
#line 130
          tmp___4 = strlen((char const   *)(temp));
#line 130
          temp[tmp___4 - 1UL] = (char )'\000';
#line 131
          loc.filename = strsave(temp);
#line 115
          loc.lineno = 1;
          }
        } else {
          {
#line 116
          tmp___10 = is_keyword(line, (char *)"line");
          }
#line 116
          if (tmp___10) {
            {
#line 135
            tmp___5 = strlen((char const   *)line);
#line 135
            tmp___6 = strlen("@line ");
            }
#line 135
            if (tmp___5 >= 255UL + tmp___6) {
              {
#line 136
              errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "file name size");
              }
            }
            {
#line 137
            tmp___7 = strlen("@line ");
#line 137
            strcpy((char */* __restrict  */)(temp___0), (char const   */* __restrict  */)(line + tmp___7));
#line 138
            tmp___8 = strlen((char const   *)(temp___0));
#line 138
            temp___0[tmp___8 - 1UL] = (char )'\000';
#line 144
            p = temp___0;
            }
            {
#line 144
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 144
              if (! *p) {
#line 144
                goto while_break___1;
              }
              {
#line 145
              tmp___9 = __ctype_b_loc();
              }
#line 145
              if (! ((int const   )*(*tmp___9 + (int )*p) & 2048)) {
                {
#line 146
                errormsg((enum errorlevel )2, (char *)"non-numeric line number in `@line %s\'",
                         temp___0);
                }
              }
#line 144
              p ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 140
            loc.lineno = atoi((char const   *)(temp___0));
#line 118
            (loc.lineno) --;
            }
          }
        }
      }
    }
    {
#line 105
    tmp___14 = is_begin(line, (char *)"code");
    }
#line 105
    if (! tmp___14) {
#line 106
      goto while_continue___0;
    }
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 97
      line = getline(in);
      }
#line 97
      if ((unsigned long )line != (unsigned long )((void *)0)) {
        {
#line 97
        tmp___15 = is_keyword(line, (char *)"defn");
        }
#line 97
        if (tmp___15) {
#line 97
          goto while_break___2;
        } else {
          {
#line 97
          tmp___16 = is_keyword(line, (char *)"text");
          }
#line 97
          if (tmp___16) {
#line 97
            goto while_break___2;
          }
        }
      } else {
#line 97
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 67
    insist(line, (char *)"defn", (char *)"code chunk had no definition line");
#line 123
    tmp___17 = strlen("@defn ");
#line 123
    strcpy((char */* __restrict  */)(modname), (char const   */* __restrict  */)(line + tmp___17));
#line 124
    tmp___18 = strlen((char const   *)(modname));
#line 124
    modname[tmp___18 - 1UL] = (char )'\000';
#line 69
    warn_dots(modname);
#line 70
    modptr = insert(modname);
#line 72
    line = getline(in);
#line 73
    insist(line, (char *)"nl", (char *)"definition line not followed by newline");
#line 74
    (loc.lineno) ++;
#line 75
    line = getline(in);
    }
    {
#line 76
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 76
      if ((unsigned long )line != (unsigned long )((void *)0)) {
        {
#line 76
        tmp___35 = is_end(line, (char *)"code");
        }
#line 76
        if (tmp___35) {
#line 76
          goto while_break___3;
        }
      } else {
#line 76
        goto while_break___3;
      }
      {
#line 77
      tmp___34 = is_keyword(line, (char *)"nl");
      }
#line 77
      if (tmp___34) {
        {
#line 78
        add_part(modptr, (char *)0, (Parttype )3, (Location *)0);
#line 79
        (loc.lineno) ++;
        }
      } else {
        {
#line 80
        tmp___33 = is_keyword(line, (char *)"text");
        }
#line 80
        if (tmp___33) {
          {
#line 81
          add_part(modptr, ((line + 1) + 4) + 1, (Parttype )1, & loc);
          }
        } else {
          {
#line 82
          tmp___32 = is_keyword(line, (char *)"use");
          }
#line 82
          if (tmp___32) {
            {
#line 83
            warn_dots(((line + 1) + 3) + 5);
#line 84
            add_part(modptr, ((line + 1) + 3) + 1, (Parttype )2, (Location *)0);
            }
          } else {
            {
#line 85
            tmp___31 = is_index(line, (char *)"nl");
            }
#line 85
            if (tmp___31) {
#line 86
              (loc.lineno) ++;
            } else {
              {
#line 113
              tmp___30 = is_keyword(line, (char *)"file");
              }
#line 113
              if (tmp___30) {
                {
#line 127
                tmp___19 = strlen((char const   *)line);
#line 127
                tmp___20 = strlen("@file ");
                }
#line 127
                if (tmp___19 >= 255UL + tmp___20) {
                  {
#line 128
                  errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "file name size");
                  }
                }
                {
#line 129
                tmp___21 = strlen("@file ");
#line 129
                strcpy((char */* __restrict  */)(temp___1), (char const   */* __restrict  */)(line + tmp___21));
#line 130
                tmp___22 = strlen((char const   *)(temp___1));
#line 130
                temp___1[tmp___22 - 1UL] = (char )'\000';
#line 131
                loc.filename = strsave(temp___1);
#line 115
                loc.lineno = 1;
                }
              } else {
                {
#line 116
                tmp___29 = is_keyword(line, (char *)"line");
                }
#line 116
                if (tmp___29) {
                  {
#line 135
                  tmp___23 = strlen((char const   *)line);
#line 135
                  tmp___24 = strlen("@line ");
                  }
#line 135
                  if (tmp___23 >= 255UL + tmp___24) {
                    {
#line 136
                    errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s",
                             "file name size");
                    }
                  }
                  {
#line 137
                  tmp___25 = strlen("@line ");
#line 137
                  strcpy((char */* __restrict  */)(temp___2), (char const   */* __restrict  */)(line + tmp___25));
#line 138
                  tmp___26 = strlen((char const   *)(temp___2));
#line 138
                  temp___2[tmp___26 - 1UL] = (char )'\000';
#line 144
                  p___0 = temp___2;
                  }
                  {
#line 144
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 144
                    if (! *p___0) {
#line 144
                      goto while_break___4;
                    }
                    {
#line 145
                    tmp___27 = __ctype_b_loc();
                    }
#line 145
                    if (! ((int const   )*(*tmp___27 + (int )*p___0) & 2048)) {
                      {
#line 146
                      errormsg((enum errorlevel )2, (char *)"non-numeric line number in `@line %s\'",
                               temp___2);
                      }
                    }
#line 144
                    p___0 ++;
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                  {
#line 140
                  loc.lineno = atoi((char const   *)(temp___2));
#line 118
                  (loc.lineno) --;
                  }
                } else {
                  {
#line 88
                  tmp___28 = is_keyword(line, (char *)"index");
                  }
#line 88
                  if (! tmp___28) {
                    {
#line 182
                    errorat(loc.filename, loc.lineno, (enum errorlevel )2, (char *)"botched code chunk `%s\'",
                            line);
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 90
      line = getline(in);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 176
    if ((unsigned long )line == (unsigned long )((void *)0)) {
      {
#line 177
      errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "End of file occurred in mid-module");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 154 "notangle.nw"
static void warn_dots(char *modname ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = strlen((char const   *)modname);
#line 156
  tmp___0 = strcmp((char const   *)((modname + tmp) - 3), "...");
  }
#line 156
  if (! tmp___0) {
    {
#line 157
    errormsg((enum errorlevel )1, (char *)"Module name <<%s>> isn\'t completed as in web",
             modname);
    }
  }
#line 159
  return;
}
}
#line 170 "notangle.nw"
void insist(char *line , char *keyword , char *msg ) 
{ 
  int tmp ;

  {
#line 176
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 177
    errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "End of file occurred in mid-module");
    }
  }
  {
#line 172
  tmp = is_keyword(line, keyword);
  }
#line 172
  if (! tmp) {
    {
#line 173
    errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", msg);
    }
  }
#line 174
  return;
}
}
#line 195 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 3 "/home/june/collector/temp/axiom-20120501/obj/noweb/src/c/recognize.h"
Recognizer new_recognizer(char *alphanum , char *symbols ) ;
#line 4
void add_ident(Recognizer r , char *id ) ;
#line 5
void stop_adding(Recognizer r ) ;
#line 6
void search_for_ident(Recognizer r , char *input , void (*f)(void *closure , char *id ,
                                                             char *instance ) , void *closure ) ;
#line 21 "finduses.nw"
static Recognizer nwindex  ;
#line 29 "finduses.nw"
static int showquotes  =    1;
#line 64
static void read_ids(FILE *in ) ;
#line 100
static void add_use_markers(FILE *in , FILE *out ) ;
#line 152
static void write_index_use(void *closure , char *id , char *instance ) ;
#line 153
static char *emit_up_to(FILE *f , char *s , char *limit ) ;
#line 66 "finduses.nw"
static void read_ids(FILE *in ) 
{ 
  char *line ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    line = getline(in);
    }
#line 68
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp___0 = strlen((char const   *)line);
    }
#line 69
    if ((int )*(line + (tmp___0 - 1UL)) == 10) {
      {
#line 69
      tmp = strlen((char const   *)line);
#line 69
      *(line + (tmp - 1UL)) = (char)0;
      }
    }
    {
#line 70
    add_ident(nwindex, line);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 102 "finduses.nw"
static void add_use_markers(FILE *in , FILE *out ) 
{ 
  char *line ;
  int incode ;
  LineOut info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 104
  incode = 0;
#line 105
  info.line = (char *)0;
#line 105
  info.out = out;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    line = getline(in);
    }
#line 107
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___1 = is_begin(line, (char *)"code");
    }
#line 108
    if (tmp___1) {
#line 109
      incode = 1;
    } else
#line 108
    if (showquotes) {
      {
#line 108
      tmp___2 = is_keyword(line, (char *)"quote");
      }
#line 108
      if (tmp___2) {
#line 109
        incode = 1;
      } else {
#line 108
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 110
      tmp = is_end(line, (char *)"code");
      }
#line 110
      if (tmp) {
#line 111
        incode = 0;
      } else {
        {
#line 110
        tmp___0 = is_keyword(line, (char *)"endquote");
        }
#line 110
        if (tmp___0) {
#line 111
          incode = 0;
        }
      }
    }
    {
#line 112
    tmp___3 = is_keyword(line, (char *)"text");
    }
#line 112
    if (tmp___3) {
#line 112
      if (incode) {
        {
#line 113
        info.line = line + 6;
#line 114
        search_for_ident(nwindex, line, & write_index_use, (void *)(& info));
        }
#line 115
        if (*(info.line)) {
#line 115
          if ((int )*(info.line) != 10) {
            {
#line 116
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"@text %s",
                    info.line);
            }
          }
        }
      } else {
        {
#line 118
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
                line);
        }
      }
    } else {
      {
#line 118
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
              line);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 133 "finduses.nw"
static void write_index_use(void *closure , char *id , char *instance ) 
{ 
  LineOut *info ;
  size_t tmp ;

  {
  {
#line 134
  info = (LineOut *)closure;
#line 135
  info->line = emit_up_to(info->out, info->line, instance);
#line 136
  fprintf((FILE */* __restrict  */)info->out, (char const   */* __restrict  */)"@index use %s\n",
          id);
#line 137
  tmp = strlen((char const   *)id);
#line 137
  info->line = emit_up_to(info->out, info->line, instance + tmp);
  }
#line 138
  return;
}
}
#line 140 "finduses.nw"
static char *emit_up_to(FILE *f , char *s , char *limit ) 
{ 
  char saved ;

  {
#line 141
  if ((unsigned long )s < (unsigned long )limit) {
    {
#line 142
    saved = *limit;
#line 143
    *limit = (char)0;
#line 144
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"@text %s\n",
            s);
#line 145
    *limit = saved;
    }
#line 146
    return (limit);
  } else {
#line 148
    return (s);
  }
}
}
#line 14 "match.nw"
static int matches___0(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 28 "getline.nw"
static char *buf1___1  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___1  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___1  =    128;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 320 "recognize.nw"
int reject_match(Recognizer r , char *id , char *input , char *current ) ;
#line 112 "recognize.nw"
static Goto_Node *goto_lookup(unsigned char c , Goto_Node *g ) 
{ 
  Move_Node *m ;
  Goto_Node *tmp ;

  {
#line 114
  m = g->moves;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (m) {
#line 115
      if (! ((int )m->c != (int )c)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (m) {
#line 117
    tmp = m->state;
  } else {
#line 117
    tmp = (Goto_Node *)((void *)0);
  }
#line 117
  return (tmp);
}
}
#line 125 "recognize.nw"
Recognizer new_recognizer(char *alphanum , char *symbols ) 
{ 
  Recognizer r ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 127
  tmp = calloc((size_t )1, sizeof(struct recognizer ));
#line 127
  r = (Recognizer )tmp;
#line 128
  r->alphas = alphanum;
#line 129
  r->syms = symbols;
#line 130
  r->max_depth = 10;
#line 131
  tmp___0 = calloc((size_t )r->max_depth, sizeof(Goto_Node *));
#line 131
  r->depths = (Goto_Node **)tmp___0;
  }
#line 132
  return (r);
}
}
#line 140 "recognize.nw"
void add_ident(Recognizer r , char *id ) 
{ 
  int depth ;
  char *p ;
  unsigned char c ;
  char *tmp ;
  Goto_Node *q ;
  void *tmp___0 ;
  char *tmp___1 ;
  Goto_Node *new ;
  Goto_Node *tmp___2 ;
  Move_Node *new_move ;
  void *tmp___3 ;
  void *tmp___4 ;
  int i ;
  Goto_Node **new_depths ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *copy ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 142
  depth = 2;
#line 143
  p = id;
#line 144
  tmp = p;
#line 144
  p ++;
#line 144
  c = (unsigned char )*tmp;
#line 145
  q = r->root[c];
#line 146
  if (! q) {
    {
#line 161
    tmp___0 = calloc((size_t )1, sizeof(Goto_Node ));
#line 161
    q = (Goto_Node *)tmp___0;
#line 162
    r->root[c] = q;
#line 163
    q->next = *(r->depths + 1);
#line 164
    *(r->depths + 1) = q;
    }
  }
#line 148
  tmp___1 = p;
#line 148
  p ++;
#line 148
  c = (unsigned char )*tmp___1;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! c) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp___2 = goto_lookup(c, q);
#line 150
    new = tmp___2;
    }
#line 151
    if (! new) {
      {
#line 168
      tmp___3 = malloc(sizeof(Move_Node ));
#line 168
      new_move = (Move_Node *)tmp___3;
#line 169
      tmp___4 = calloc((size_t )1, sizeof(Goto_Node ));
#line 169
      new = (Goto_Node *)tmp___4;
#line 170
      new_move->state = new;
#line 171
      new_move->c = c;
#line 172
      new_move->next = q->moves;
#line 173
      q->moves = new_move;
      }
#line 174
      if (depth == r->max_depth) {
        {
#line 182
        tmp___5 = calloc((size_t )(2 * depth), sizeof(Goto_Node *));
#line 182
        new_depths = (Goto_Node **)tmp___5;
#line 183
        r->max_depth = 2 * depth;
#line 184
        i = 0;
        }
        {
#line 184
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 184
          if (! (i < depth)) {
#line 184
            goto while_break___0;
          }
#line 185
          *(new_depths + i) = *(r->depths + i);
#line 184
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 186
        free((void *)r->depths);
#line 187
        r->depths = new_depths;
        }
      }
#line 176
      new->next = *(r->depths + depth);
#line 177
      *(r->depths + depth) = new;
    }
#line 153
    q = new;
#line 154
    depth ++;
#line 155
    tmp___6 = p;
#line 155
    p ++;
#line 155
    c = (unsigned char )*tmp___6;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if (! q->output) {
    {
#line 191
    tmp___7 = strlen((char const   *)id);
#line 191
    tmp___8 = malloc(tmp___7 + 1UL);
#line 191
    copy = (char *)tmp___8;
#line 192
    strcpy((char */* __restrict  */)copy, (char const   */* __restrict  */)id);
#line 193
    tmp___9 = malloc(sizeof(Name_Node ));
#line 193
    q->output = (Name_Node *)tmp___9;
#line 194
    (q->output)->next = (struct name_node *)((void *)0);
#line 195
    (q->output)->name = copy;
    }
  }
#line 158
  return;
}
}
#line 206 "recognize.nw"
void stop_adding(Recognizer r ) 
{ 
  int depth ;
  Goto_Node *g ;
  Move_Node *m ;
  unsigned char a ;
  Goto_Node *s ;
  Goto_Node *state ;
  Goto_Node *tmp ;
  Name_Node *p ;
  Name_Node *q ;
  void *tmp___0 ;

  {
#line 209
  depth = 1;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (depth < r->max_depth)) {
#line 209
      goto while_break;
    }
#line 210
    g = *(r->depths + depth);
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! g) {
#line 211
        goto while_break___0;
      }
#line 212
      m = g->moves;
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 213
        if (! m) {
#line 213
          goto while_break___1;
        }
#line 214
        a = m->c;
#line 215
        s = m->state;
#line 216
        state = g->fail;
        {
#line 217
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 217
          if (state) {
            {
#line 217
            tmp = goto_lookup(a, state);
            }
#line 217
            if (tmp) {
#line 217
              goto while_break___2;
            }
          } else {
#line 217
            goto while_break___2;
          }
#line 218
          state = state->fail;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 219
        if (state) {
          {
#line 220
          s->fail = goto_lookup(a, state);
          }
        } else {
#line 222
          s->fail = r->root[a];
        }
#line 223
        if (s->fail) {
#line 224
          p = (s->fail)->output;
          {
#line 225
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 225
            if (! p) {
#line 225
              goto while_break___3;
            }
            {
#line 226
            tmp___0 = malloc(sizeof(Name_Node ));
#line 226
            q = (Name_Node *)tmp___0;
#line 227
            q->name = p->name;
#line 229
            q->next = s->output;
#line 230
            s->output = q;
#line 231
            p = p->next;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 234
        m = m->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 236
      g = g->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 209
    depth ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 245 "recognize.nw"
void search_for_ident(Recognizer r , char *input , void (*f)(void *closure , char *id ,
                                                             char *instance ) , void *closure ) 
{ 
  Goto_Node *state ;
  char *current ;
  unsigned char c ;
  char *tmp ;
  Goto_Node *tmp___0 ;
  Goto_Node *tmp___1 ;
  Name_Node *p ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 247
  state = (Goto_Node *)((void *)0);
#line 248
  current = input;
#line 249
  tmp = current;
#line 249
  current ++;
#line 249
  c = (unsigned char )*tmp;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! c) {
#line 250
      goto while_break;
    }
    {
#line 262
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 262
      if (state) {
        {
#line 262
        tmp___0 = goto_lookup(c, state);
        }
#line 262
        if (tmp___0) {
#line 262
          goto while_break___0;
        }
      } else {
#line 262
        goto while_break___0;
      }
#line 263
      state = state->fail;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    if (state) {
      {
#line 264
      tmp___1 = goto_lookup(c, state);
#line 264
      state = tmp___1;
      }
    } else {
#line 264
      state = r->root[c];
    }
#line 272
    if (state) {
#line 273
      p = state->output;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 274
        if (! p) {
#line 274
          goto while_break___1;
        }
        {
#line 275
        tmp___3 = reject_match(r, p->name, input, current);
        }
#line 275
        if (! tmp___3) {
          {
#line 276
          tmp___2 = strlen((char const   *)p->name);
#line 276
          (*f)(closure, p->name, current - tmp___2);
          }
        }
#line 277
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 253
    tmp___4 = current;
#line 253
    current ++;
#line 253
    c = (unsigned char )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 295 "recognize.nw"
int reject_match(Recognizer r , char *id , char *input , char *current ) 
{ 
  int len ;
  size_t tmp ;
  char first ;
  char last ;
  char next ;
  char prev ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 297
  tmp = strlen((char const   *)id);
#line 297
  len = (int )tmp;
#line 298
  first = *(id + 0);
#line 299
  last = *(id + (len - 1));
#line 300
  next = *current;
#line 301
  prev = (char )'\000';
#line 302
  current = (current - len) - 1;
  }
#line 303
  if ((unsigned long )input <= (unsigned long )current) {
#line 304
    prev = *current;
  }
#line 305
  if (prev) {
    {
#line 305
    tmp___0 = strchr((char const   *)r->alphas, (int )first);
    }
#line 305
    if (tmp___0) {
      {
#line 305
      tmp___1 = strchr((char const   *)r->alphas, (int )prev);
      }
#line 305
      if (tmp___1) {
#line 305
        return (1);
      }
    }
  }
#line 306
  if (next) {
    {
#line 306
    tmp___2 = strchr((char const   *)r->alphas, (int )last);
    }
#line 306
    if (tmp___2) {
      {
#line 306
      tmp___3 = strchr((char const   *)r->alphas, (int )next);
      }
#line 306
      if (tmp___3) {
#line 306
        return (1);
      }
    }
  }
#line 307
  if (prev) {
    {
#line 307
    tmp___4 = strchr((char const   *)r->syms, (int )first);
    }
#line 307
    if (tmp___4) {
      {
#line 307
      tmp___5 = strchr((char const   *)r->syms, (int )prev);
      }
#line 307
      if (tmp___5) {
#line 307
        return (1);
      }
    }
  }
#line 308
  if (next) {
    {
#line 308
    tmp___6 = strchr((char const   *)r->syms, (int )last);
    }
#line 308
    if (tmp___6) {
      {
#line 308
      tmp___7 = strchr((char const   *)r->syms, (int )next);
      }
#line 308
      if (tmp___7) {
#line 308
        return (1);
      }
    }
  }
#line 309
  return (0);
}
}
#line 14 "match.nw"
static int matches___1(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 161 "notangle.nw"
static void warn_dots___0(char *modname ) ;
#line 154 "notangle.nw"
static void warn_dots___0(char *modname ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = strlen((char const   *)modname);
#line 156
  tmp___0 = strcmp((char const   *)((modname + tmp) - 3), "...");
  }
#line 156
  if (! tmp___0) {
    {
#line 157
    errormsg((enum errorlevel )1, (char *)"Module name <<%s>> isn\'t completed as in web",
             modname);
    }
  }
#line 159
  return;
}
}
#line 28 "getline.nw"
static char *buf1___2  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___2  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___2  =    128;
#line 29 "modtrees.nw"
static struct tnode *root___0  =    (struct tnode *)((void *)0);
#line 60
static Module insert_tree___0(TNODE **rootptr , char *modname ) ;
#line 61
static Module lookup_tree___0(TNODE **rootptr , char *modname ) ;
#line 37 "modtrees.nw"
static Module insert_tree___0(TNODE **rootptr , char *modname ) 
{ 
  TNODE *tmp ;
  void *tmp___0 ;
  struct tnode *tmp___1 ;
  Module tmp___2 ;
  Module tmp___3 ;
  Module tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 39
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      tmp___0 = malloc(sizeof(struct tnode ));
#line 56
      tmp = (struct tnode *)tmp___0;
#line 56
      *rootptr = tmp;
      }
#line 56
      if (! tmp) {
        {
#line 56
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    tmp___1 = (struct tnode *)((void *)0);
#line 57
    (*rootptr)->right = tmp___1;
#line 57
    (*rootptr)->left = tmp___1;
#line 41
    tmp___2 = newmodule(modname);
#line 41
    (*rootptr)->data = tmp___2;
    }
#line 41
    return (tmp___2);
  }
  {
#line 43
  tmp___6 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 43
  if (tmp___6 == 0) {
#line 44
    return ((*rootptr)->data);
  } else {
    {
#line 45
    tmp___5 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 45
    if (tmp___5 < 0) {
      {
#line 46
      tmp___3 = insert_tree___0(& (*rootptr)->left, modname);
      }
#line 46
      return (tmp___3);
    } else {
      {
#line 48
      tmp___4 = insert_tree___0(& (*rootptr)->right, modname);
      }
#line 48
      return (tmp___4);
    }
  }
}
}
#line 68 "modtrees.nw"
static Module lookup_tree___0(TNODE **rootptr , char *modname ) 
{ 
  Module tmp ;
  Module tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 70
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
#line 71
    return ((Module )((void *)0));
  }
  {
#line 73
  tmp___2 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 73
  if (tmp___2 == 0) {
#line 74
    return ((*rootptr)->data);
  } else {
    {
#line 75
    tmp___1 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 75
    if (tmp___1 < 0) {
      {
#line 76
      tmp = lookup_tree___0(& (*rootptr)->left, modname);
      }
#line 76
      return (tmp);
    } else {
      {
#line 78
      tmp___0 = lookup_tree___0(& (*rootptr)->right, modname);
      }
#line 78
      return (tmp___0);
    }
  }
}
}
#line 88 "modtrees.nw"
static void apply_to_tree___0(TNODE *p , void (*fun)(Module  ) ) 
{ 


  {
#line 90
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 91
    apply_to_tree___0(p->left, fun);
#line 92
    (*fun)(p->data);
#line 93
    apply_to_tree___0(p->right, fun);
    }
  }
#line 95
  return;
}
}
#line 62 "modules.nw"
static struct modpart *newmodpart___0(int type , char *s , Location *loc ) ;
#line 65
static void append___0(Module mp , struct modpart *p ) ;
#line 67
static int seekcycle___0(Module mp , Parent parent ) ;
#line 68 "modules.nw"
static char *lastfilename___0  =    (char *)0;
#line 69 "modules.nw"
static int lastlineno___0  =    -1;
#line 82 "modules.nw"
static struct modpart *newmodpart___0(int type , char *s , Location *loc ) 
{ 
  struct modpart *p ;
  void *tmp ;
  int k ;
  size_t tmp___0 ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct modpart ));
#line 84
  p = (struct modpart *)tmp;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! p) {
      {
#line 85
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  p->ptype = (Parttype )type;
#line 87
  if (s) {
    {
#line 88
    p->contents = strsave(s);
#line 89
    tmp___0 = strlen((char const   *)p->contents);
#line 89
    k = (int )(tmp___0 - 1UL);
    }
#line 90
    if ((int )*(p->contents + k) == 10) {
#line 90
      *(p->contents + k) = (char )'\000';
    } else {
      {
#line 91
      errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "input line doesn\'t end with newline");
      }
    }
  }
#line 94
  if (loc) {
#line 94
    p->loc = *loc;
  }
#line 95
  p->next = (struct modpart *)((void *)0);
#line 96
  return (p);
}
}
#line 98 "modules.nw"
static void append___0(Module mp , struct modpart *p ) 
{ 
  struct modpart *tmp ;

  {
#line 101
  if ((unsigned long )mp->head == (unsigned long )((void *)0)) {
#line 102
    tmp = p;
#line 102
    mp->tail = tmp;
#line 102
    mp->head = tmp;
  } else {
#line 104
    (mp->tail)->next = p;
#line 105
    mp->tail = p;
  }
#line 107
  return;
}
}
#line 164 "modules.nw"
static int seekcycle___0(Module mp , Parent parent ) 
{ 
  int tmp ;

  {
#line 165
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 166
    return (0);
  } else
#line 167
  if ((unsigned long )parent->this == (unsigned long )mp) {
#line 167
    goto _L;
  } else {
    {
#line 167
    tmp = seekcycle___0(mp, parent->parent);
    }
#line 167
    if (tmp) {
      _L: /* CIL Label */ 
#line 168
      if ((unsigned long )parent->this == (unsigned long )mp) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic code chunks: ");
        }
      }
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<%s>> -> ",
              (parent->this)->name);
      }
#line 171
      return (1);
    } else {
#line 173
      return (0);
    }
  }
}
}
#line 194 "modules.nw"
static int complained___2  =    0;
#line 201 "modules.nw"
static int complained___3  =    0;
#line 28 "getline.nw"
static char *buf1___3  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___3  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___3  =    128;
#line 39 "markmain.nw"
static char *states___0[4]  = {      (char *)"bad state",      (char *)"code",      (char *)"docs",      (char *)"code"};
#line 40 "markmain.nw"
static char *marks___0[3]  = {      (char *)"bad mark",      (char *)"begin",      (char *)"end"};
#line 41 "markmain.nw"
static char *indices___0[4]  = {      (char *)"bad index",      (char *)"defn",      (char *)"use",      (char *)"nl"};
#line 42 "markmain.nw"
static char low_at_sign___0  =    (char )'@';
#line 44 "markmain.nw"
static void print_state___0(FILE *out , Mark be , State state , int count ) 
{ 


  {
  {
#line 45
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s %d\n",
          (int )low_at_sign___0, marks___0[be], states___0[state], count);
  }
#line 46
  return;
}
}
#line 48 "markmain.nw"
static void print_index___0(FILE *out , Index idx , char *arg ) 
{ 


  {
#line 49
  if (arg) {
    {
#line 50
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%cindex %s %s\n",
            (int )low_at_sign___0, indices___0[idx], arg);
    }
  } else {
    {
#line 52
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%cindex %s\n",
            (int )low_at_sign___0, indices___0[idx]);
    }
  }
#line 53
  return;
}
}
#line 55 "markmain.nw"
static void print_pair___0(FILE *out , char *name , char *value ) 
{ 
  int last ;
  size_t tmp ;

  {
#line 56
  if (value) {
    {
#line 57
    tmp = strlen((char const   *)value);
#line 57
    last = (int )(tmp - 1UL);
    }
#line 58
    if (last >= 0) {
#line 58
      if ((int )*(value + last) == 10) {
        {
#line 59
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s%cnl\n",
                (int )low_at_sign___0, name, value, (int )low_at_sign___0);
        }
      } else {
        {
#line 61
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s\n",
                (int )low_at_sign___0, name, value);
        }
      }
    } else {
      {
#line 61
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s %s\n",
              (int )low_at_sign___0, name, value);
      }
    }
  } else {
    {
#line 63
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c%s\n",
            (int )low_at_sign___0, name);
    }
  }
#line 64
  return;
}
}
#line 182 "markmain.nw"
static char *buf___0  ;
#line 183 "markmain.nw"
static int buflen___0  =    0;
#line 86 "markup.nw"
static char def_marker___0[7]  = {      (char )' ',      (char )'%',      (char )'d',      (char )'e', 
        (char )'f',      (char )' ',      (char )'\000'};
#line 91 "markup.nw"
static int complained___4  ;
#line 102 "markup.nw"
static int checked___0  =    0;
#line 14 "match.nw"
static int matches___2(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 86 "mnt.nw"
static void emitfile___0(char *modname ) ;
#line 26 "mnt.nw"
static char *locformat___0  =    (char *)"#line %L \"%F\"%N";
#line 88 "mnt.nw"
static void emitfile___0(char *modname ) 
{ 
  Module root___3 ;
  Module tmp ;
  char *tempname ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *fp ;
  char *lfmt ;
  char *filename ;
  int n ;
  size_t tmp___2 ;
  FILE *dest ;
  FILE *tmp___3 ;
  int x ;
  int y ;
  FILE *fp___0 ;
  FILE *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 89
  tmp = lookup(modname);
#line 89
  root___3 = tmp;
#line 90
  tmp___0 = tmpnam((char *)((void *)0));
#line 90
  tmp___1 = strsave(tmp___0);
#line 90
  tempname = tmp___1;
#line 108
  tmp___2 = strlen((char const   *)modname);
#line 108
  n = (int )(tmp___2 - 1UL);
  }
#line 109
  if (n >= 0) {
#line 109
    if ((int )*(modname + n) == 42) {
      {
#line 110
      lfmt = locformat___0;
#line 111
      filename = strsave(modname);
#line 112
      *(filename + n) = (char)0;
      }
    } else {
#line 114
      lfmt = (char *)"";
#line 115
      filename = modname;
    }
  } else {
#line 114
    lfmt = (char *)"";
#line 115
    filename = modname;
  }
#line 147
  if ((unsigned long )root___3 == (unsigned long )((void *)0)) {
    {
#line 148
    errormsg((enum errorlevel )2, (char *)"Chunk <<%s>> is undefined", filename);
    }
#line 149
    return;
  }
  {
#line 95
  fp = fopen((char const   */* __restrict  */)tempname, (char const   */* __restrict  */)"w");
  }
#line 96
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 96
    errormsg((enum errorlevel )3, (char *)"Can\'t open temporary file %s", tempname);
    }
  }
  {
#line 119
  resetloc();
#line 120
  expand(root___3, 0, 0, (Parent )0, lfmt, fp);
#line 121
  _IO_putc('\n', fp);
#line 122
  fclose(fp);
#line 126
  dest = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 127
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
    {
#line 129
    tmp___3 = fopen((char const   */* __restrict  */)tempname, (char const   */* __restrict  */)"r");
    }
#line 130
    if (! tmp___3) {
      {
#line 130
      __assert_fail("tmp", "mnt.nw", 130U, "emitfile");
      }
    }
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 132
      x = _IO_getc(tmp___3);
#line 133
      y = _IO_getc(dest);
      }
#line 131
      if (x == y) {
#line 131
        if (! (x != -1)) {
#line 131
          goto while_break;
        }
      } else {
#line 131
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 135
    fclose(tmp___3);
#line 136
    fclose(dest);
    }
#line 137
    if (x == y) {
      {
#line 138
      remove((char const   *)tempname);
      }
#line 139
      return;
    }
  }
  {
#line 99
  remove((char const   *)filename);
#line 100
  tmp___5 = rename((char const   *)tempname, (char const   *)filename);
  }
#line 100
  if (tmp___5 != 0) {
    {
#line 101
    tmp___4 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
#line 101
    fp___0 = tmp___4;
    }
#line 102
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 102
      remove((char const   *)tempname);
#line 144
      errormsg((enum errorlevel )2, (char *)"Can\'t open output file %s", filename);
      }
#line 145
      return;
    }
    {
#line 119
    resetloc();
#line 120
    expand(root___3, 0, 0, (Parent )0, lfmt, fp___0);
#line 121
    _IO_putc('\n', fp___0);
#line 122
    fclose(fp___0);
#line 104
    remove((char const   *)tempname);
    }
  }
#line 106
  return;
}
}
#line 28 "getline.nw"
static char *buf1___4  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___4  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___4  =    128;
#line 29 "modtrees.nw"
static struct tnode *root___1  =    (struct tnode *)((void *)0);
#line 60
static Module insert_tree___1(TNODE **rootptr , char *modname ) ;
#line 61
static Module lookup_tree___1(TNODE **rootptr , char *modname ) ;
#line 37 "modtrees.nw"
static Module insert_tree___1(TNODE **rootptr , char *modname ) 
{ 
  TNODE *tmp ;
  void *tmp___0 ;
  struct tnode *tmp___1 ;
  Module tmp___2 ;
  Module tmp___3 ;
  Module tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 39
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      tmp___0 = malloc(sizeof(struct tnode ));
#line 56
      tmp = (struct tnode *)tmp___0;
#line 56
      *rootptr = tmp;
      }
#line 56
      if (! tmp) {
        {
#line 56
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    tmp___1 = (struct tnode *)((void *)0);
#line 57
    (*rootptr)->right = tmp___1;
#line 57
    (*rootptr)->left = tmp___1;
#line 41
    tmp___2 = newmodule(modname);
#line 41
    (*rootptr)->data = tmp___2;
    }
#line 41
    return (tmp___2);
  }
  {
#line 43
  tmp___6 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 43
  if (tmp___6 == 0) {
#line 44
    return ((*rootptr)->data);
  } else {
    {
#line 45
    tmp___5 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 45
    if (tmp___5 < 0) {
      {
#line 46
      tmp___3 = insert_tree___1(& (*rootptr)->left, modname);
      }
#line 46
      return (tmp___3);
    } else {
      {
#line 48
      tmp___4 = insert_tree___1(& (*rootptr)->right, modname);
      }
#line 48
      return (tmp___4);
    }
  }
}
}
#line 68 "modtrees.nw"
static Module lookup_tree___1(TNODE **rootptr , char *modname ) 
{ 
  Module tmp ;
  Module tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 70
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
#line 71
    return ((Module )((void *)0));
  }
  {
#line 73
  tmp___2 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 73
  if (tmp___2 == 0) {
#line 74
    return ((*rootptr)->data);
  } else {
    {
#line 75
    tmp___1 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 75
    if (tmp___1 < 0) {
      {
#line 76
      tmp = lookup_tree___1(& (*rootptr)->left, modname);
      }
#line 76
      return (tmp);
    } else {
      {
#line 78
      tmp___0 = lookup_tree___1(& (*rootptr)->right, modname);
      }
#line 78
      return (tmp___0);
    }
  }
}
}
#line 88 "modtrees.nw"
static void apply_to_tree___1(TNODE *p , void (*fun)(Module  ) ) 
{ 


  {
#line 90
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 91
    apply_to_tree___1(p->left, fun);
#line 92
    (*fun)(p->data);
#line 93
    apply_to_tree___1(p->right, fun);
    }
  }
#line 95
  return;
}
}
#line 62 "modules.nw"
static struct modpart *newmodpart___1(int type , char *s , Location *loc ) ;
#line 65
static void append___1(Module mp , struct modpart *p ) ;
#line 67
static int seekcycle___1(Module mp , Parent parent ) ;
#line 68 "modules.nw"
static char *lastfilename___1  =    (char *)0;
#line 69 "modules.nw"
static int lastlineno___1  =    -1;
#line 82 "modules.nw"
static struct modpart *newmodpart___1(int type , char *s , Location *loc ) 
{ 
  struct modpart *p ;
  void *tmp ;
  int k ;
  size_t tmp___0 ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct modpart ));
#line 84
  p = (struct modpart *)tmp;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! p) {
      {
#line 85
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  p->ptype = (Parttype )type;
#line 87
  if (s) {
    {
#line 88
    p->contents = strsave(s);
#line 89
    tmp___0 = strlen((char const   *)p->contents);
#line 89
    k = (int )(tmp___0 - 1UL);
    }
#line 90
    if ((int )*(p->contents + k) == 10) {
#line 90
      *(p->contents + k) = (char )'\000';
    } else {
      {
#line 91
      errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "input line doesn\'t end with newline");
      }
    }
  }
#line 94
  if (loc) {
#line 94
    p->loc = *loc;
  }
#line 95
  p->next = (struct modpart *)((void *)0);
#line 96
  return (p);
}
}
#line 98 "modules.nw"
static void append___1(Module mp , struct modpart *p ) 
{ 
  struct modpart *tmp ;

  {
#line 101
  if ((unsigned long )mp->head == (unsigned long )((void *)0)) {
#line 102
    tmp = p;
#line 102
    mp->tail = tmp;
#line 102
    mp->head = tmp;
  } else {
#line 104
    (mp->tail)->next = p;
#line 105
    mp->tail = p;
  }
#line 107
  return;
}
}
#line 164 "modules.nw"
static int seekcycle___1(Module mp , Parent parent ) 
{ 
  int tmp ;

  {
#line 165
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 166
    return (0);
  } else
#line 167
  if ((unsigned long )parent->this == (unsigned long )mp) {
#line 167
    goto _L;
  } else {
    {
#line 167
    tmp = seekcycle___1(mp, parent->parent);
    }
#line 167
    if (tmp) {
      _L: /* CIL Label */ 
#line 168
      if ((unsigned long )parent->this == (unsigned long )mp) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic code chunks: ");
        }
      }
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<%s>> -> ",
              (parent->this)->name);
      }
#line 171
      return (1);
    } else {
#line 173
      return (0);
    }
  }
}
}
#line 194 "modules.nw"
static int complained___5  =    0;
#line 201 "modules.nw"
static int complained___6  =    0;
#line 161 "notangle.nw"
static void warn_dots___1(char *modname ) ;
#line 154 "notangle.nw"
static void warn_dots___1(char *modname ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = strlen((char const   *)modname);
#line 156
  tmp___0 = strcmp((char const   *)((modname + tmp) - 3), "...");
  }
#line 156
  if (! tmp___0) {
    {
#line 157
    errormsg((enum errorlevel )1, (char *)"Module name <<%s>> isn\'t completed as in web",
             modname);
    }
  }
#line 159
  return;
}
}
#line 21 "finduses.nw"
static Recognizer nwindex___0  ;
#line 29 "finduses.nw"
static int showquotes___0  =    1;
#line 64
static void read_ids___0(FILE *in ) ;
#line 100
static void add_use_markers___0(FILE *in , FILE *out ) ;
#line 152
static void write_index_use___0(void *closure , char *id , char *instance ) ;
#line 153
static char *emit_up_to___0(FILE *f , char *s , char *limit ) ;
#line 66 "finduses.nw"
static void read_ids___0(FILE *in ) 
{ 
  char *line ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    line = getline(in);
    }
#line 68
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp___0 = strlen((char const   *)line);
    }
#line 69
    if ((int )*(line + (tmp___0 - 1UL)) == 10) {
      {
#line 69
      tmp = strlen((char const   *)line);
#line 69
      *(line + (tmp - 1UL)) = (char)0;
      }
    }
    {
#line 70
    add_ident(nwindex___0, line);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 102 "finduses.nw"
static void add_use_markers___0(FILE *in , FILE *out ) 
{ 
  char *line ;
  int incode ;
  LineOut info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 104
  incode = 0;
#line 105
  info.line = (char *)0;
#line 105
  info.out = out;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    line = getline(in);
    }
#line 107
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___1 = is_begin(line, (char *)"code");
    }
#line 108
    if (tmp___1) {
#line 109
      incode = 1;
    } else
#line 108
    if (showquotes___0) {
      {
#line 108
      tmp___2 = is_keyword(line, (char *)"quote");
      }
#line 108
      if (tmp___2) {
#line 109
        incode = 1;
      } else {
#line 108
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 110
      tmp = is_end(line, (char *)"code");
      }
#line 110
      if (tmp) {
#line 111
        incode = 0;
      } else {
        {
#line 110
        tmp___0 = is_keyword(line, (char *)"endquote");
        }
#line 110
        if (tmp___0) {
#line 111
          incode = 0;
        }
      }
    }
    {
#line 112
    tmp___3 = is_keyword(line, (char *)"text");
    }
#line 112
    if (tmp___3) {
#line 112
      if (incode) {
        {
#line 113
        info.line = line + 6;
#line 114
        search_for_ident(nwindex___0, line, & write_index_use___0, (void *)(& info));
        }
#line 115
        if (*(info.line)) {
#line 115
          if ((int )*(info.line) != 10) {
            {
#line 116
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"@text %s",
                    info.line);
            }
          }
        }
      } else {
        {
#line 118
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
                line);
        }
      }
    } else {
      {
#line 118
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s",
              line);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 133 "finduses.nw"
static void write_index_use___0(void *closure , char *id , char *instance ) 
{ 
  LineOut *info ;
  size_t tmp ;

  {
  {
#line 134
  info = (LineOut *)closure;
#line 135
  info->line = emit_up_to___0(info->out, info->line, instance);
#line 136
  fprintf((FILE */* __restrict  */)info->out, (char const   */* __restrict  */)"@index use %s\n",
          id);
#line 137
  tmp = strlen((char const   *)id);
#line 137
  info->line = emit_up_to___0(info->out, info->line, instance + tmp);
  }
#line 138
  return;
}
}
#line 140 "finduses.nw"
static char *emit_up_to___0(FILE *f , char *s , char *limit ) 
{ 
  char saved ;

  {
#line 141
  if ((unsigned long )s < (unsigned long )limit) {
    {
#line 142
    saved = *limit;
#line 143
    *limit = (char)0;
#line 144
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"@text %s\n",
            s);
#line 145
    *limit = saved;
    }
#line 146
    return (limit);
  } else {
#line 148
    return (s);
  }
}
}
#line 14 "match.nw"
static int matches___3(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 28 "getline.nw"
static char *buf1___5  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___5  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___5  =    128;
#line 112 "recognize.nw"
static Goto_Node *goto_lookup___0(unsigned char c , Goto_Node *g ) 
{ 
  Move_Node *m ;
  Goto_Node *tmp ;

  {
#line 114
  m = g->moves;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (m) {
#line 115
      if (! ((int )m->c != (int )c)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (m) {
#line 117
    tmp = m->state;
  } else {
#line 117
    tmp = (Goto_Node *)((void *)0);
  }
#line 117
  return (tmp);
}
}
#line 14 "match.nw"
static int matches___4(char *line , char *search ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 15
  tmp = strlen((char const   *)search);
#line 15
  tmp___0 = strncmp((char const   *)line, (char const   *)search, tmp);
  }
#line 15
  if (tmp___0) {
#line 15
    tmp___1 = 0;
  } else {
#line 15
    tmp___1 = 1;
  }
#line 15
  return (tmp___1);
}
}
#line 161 "notangle.nw"
static void warn_dots___2(char *modname ) ;
#line 154 "notangle.nw"
static void warn_dots___2(char *modname ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = strlen((char const   *)modname);
#line 156
  tmp___0 = strcmp((char const   *)((modname + tmp) - 3), "...");
  }
#line 156
  if (! tmp___0) {
    {
#line 157
    errormsg((enum errorlevel )1, (char *)"Module name <<%s>> isn\'t completed as in web",
             modname);
    }
  }
#line 159
  return;
}
}
#line 28 "getline.nw"
static char *buf1___6  =    (char *)((void *)0);
#line 28 "getline.nw"
static char *buf2___6  =    (char *)((void *)0);
#line 29 "getline.nw"
static int buf_size___6  =    128;
#line 29 "modtrees.nw"
static struct tnode *root___2  =    (struct tnode *)((void *)0);
#line 60
static Module insert_tree___2(TNODE **rootptr , char *modname ) ;
#line 61
static Module lookup_tree___2(TNODE **rootptr , char *modname ) ;
#line 37 "modtrees.nw"
static Module insert_tree___2(TNODE **rootptr , char *modname ) 
{ 
  TNODE *tmp ;
  void *tmp___0 ;
  struct tnode *tmp___1 ;
  Module tmp___2 ;
  Module tmp___3 ;
  Module tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 39
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 56
      tmp___0 = malloc(sizeof(struct tnode ));
#line 56
      tmp = (struct tnode *)tmp___0;
#line 56
      *rootptr = tmp;
      }
#line 56
      if (! tmp) {
        {
#line 56
        errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    tmp___1 = (struct tnode *)((void *)0);
#line 57
    (*rootptr)->right = tmp___1;
#line 57
    (*rootptr)->left = tmp___1;
#line 41
    tmp___2 = newmodule(modname);
#line 41
    (*rootptr)->data = tmp___2;
    }
#line 41
    return (tmp___2);
  }
  {
#line 43
  tmp___6 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 43
  if (tmp___6 == 0) {
#line 44
    return ((*rootptr)->data);
  } else {
    {
#line 45
    tmp___5 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 45
    if (tmp___5 < 0) {
      {
#line 46
      tmp___3 = insert_tree___2(& (*rootptr)->left, modname);
      }
#line 46
      return (tmp___3);
    } else {
      {
#line 48
      tmp___4 = insert_tree___2(& (*rootptr)->right, modname);
      }
#line 48
      return (tmp___4);
    }
  }
}
}
#line 68 "modtrees.nw"
static Module lookup_tree___2(TNODE **rootptr , char *modname ) 
{ 
  Module tmp ;
  Module tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 70
  if ((unsigned long )*rootptr == (unsigned long )((void *)0)) {
#line 71
    return ((Module )((void *)0));
  }
  {
#line 73
  tmp___2 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
  }
#line 73
  if (tmp___2 == 0) {
#line 74
    return ((*rootptr)->data);
  } else {
    {
#line 75
    tmp___1 = strcmp((char const   *)((*rootptr)->data)->name, (char const   *)modname);
    }
#line 75
    if (tmp___1 < 0) {
      {
#line 76
      tmp = lookup_tree___2(& (*rootptr)->left, modname);
      }
#line 76
      return (tmp);
    } else {
      {
#line 78
      tmp___0 = lookup_tree___2(& (*rootptr)->right, modname);
      }
#line 78
      return (tmp___0);
    }
  }
}
}
#line 88 "modtrees.nw"
static void apply_to_tree___2(TNODE *p , void (*fun)(Module  ) ) 
{ 


  {
#line 90
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 91
    apply_to_tree___2(p->left, fun);
#line 92
    (*fun)(p->data);
#line 93
    apply_to_tree___2(p->right, fun);
    }
  }
#line 95
  return;
}
}
#line 62 "modules.nw"
static struct modpart *newmodpart___2(int type , char *s , Location *loc ) ;
#line 65
static void append___2(Module mp , struct modpart *p ) ;
#line 67
static int seekcycle___2(Module mp , Parent parent ) ;
#line 68 "modules.nw"
static char *lastfilename___2  =    (char *)0;
#line 69 "modules.nw"
static int lastlineno___2  =    -1;
#line 82 "modules.nw"
static struct modpart *newmodpart___2(int type , char *s , Location *loc ) 
{ 
  struct modpart *p ;
  void *tmp ;
  int k ;
  size_t tmp___0 ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct modpart ));
#line 84
  p = (struct modpart *)tmp;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! p) {
      {
#line 85
      errormsg((enum errorlevel )3, (char *)"Capacity exceeded: %s", "memory");
      }
    }
#line 85
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  p->ptype = (Parttype )type;
#line 87
  if (s) {
    {
#line 88
    p->contents = strsave(s);
#line 89
    tmp___0 = strlen((char const   *)p->contents);
#line 89
    k = (int )(tmp___0 - 1UL);
    }
#line 90
    if ((int )*(p->contents + k) == 10) {
#line 90
      *(p->contents + k) = (char )'\000';
    } else {
      {
#line 91
      errormsg((enum errorlevel )4, (char *)"This can\'t happen: %s", "input line doesn\'t end with newline");
      }
    }
  }
#line 94
  if (loc) {
#line 94
    p->loc = *loc;
  }
#line 95
  p->next = (struct modpart *)((void *)0);
#line 96
  return (p);
}
}
#line 98 "modules.nw"
static void append___2(Module mp , struct modpart *p ) 
{ 
  struct modpart *tmp ;

  {
#line 101
  if ((unsigned long )mp->head == (unsigned long )((void *)0)) {
#line 102
    tmp = p;
#line 102
    mp->tail = tmp;
#line 102
    mp->head = tmp;
  } else {
#line 104
    (mp->tail)->next = p;
#line 105
    mp->tail = p;
  }
#line 107
  return;
}
}
#line 164 "modules.nw"
static int seekcycle___2(Module mp , Parent parent ) 
{ 
  int tmp ;

  {
#line 165
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 166
    return (0);
  } else
#line 167
  if ((unsigned long )parent->this == (unsigned long )mp) {
#line 167
    goto _L;
  } else {
    {
#line 167
    tmp = seekcycle___2(mp, parent->parent);
    }
#line 167
    if (tmp) {
      _L: /* CIL Label */ 
#line 168
      if ((unsigned long )parent->this == (unsigned long )mp) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cyclic code chunks: ");
        }
      }
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<%s>> -> ",
              (parent->this)->name);
      }
#line 171
      return (1);
    } else {
#line 173
      return (0);
    }
  }
}
}
#line 194 "modules.nw"
static int complained___7  =    0;
#line 201 "modules.nw"
static int complained___8  =    0;
