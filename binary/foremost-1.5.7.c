/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 296 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
struct f_state {
   off_t mode ;
   char *config_file ;
   char *input_file ;
   char *output_directory ;
   char *start_time ;
   char *invocation ;
   char *audit_file_name ;
   FILE *audit_file ;
   int audit_file_open ;
   int num_builtin ;
   int chunk_size ;
   int fileswritten ;
   int block_size ;
   int skip ;
   int time_stamp ;
};
#line 296 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
typedef struct f_state f_state;
#line 316 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
struct marker {
   unsigned char *value ;
   int len ;
   size_t marker_bm_table[256] ;
};
#line 316 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
typedef struct marker marker;
#line 323 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
struct s_spec {
   char *suffix ;
   int type ;
   unsigned long long max_len ;
   unsigned char *header ;
   unsigned int header_len ;
   size_t header_bm_table[256] ;
   unsigned char *footer ;
   unsigned int footer_len ;
   size_t footer_bm_table[256] ;
   marker markerlist[5] ;
   int num_markers ;
   int searchtype ;
   int case_sen ;
   int found ;
   char comment[1024] ;
   int written ;
};
#line 323 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
typedef struct s_spec s_spec;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 349 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
struct f_info {
   char *file_name ;
   off_t total_bytes ;
   off_t total_megs ;
   off_t bytes_read ;
   FILE *handle ;
   int is_stdin ;
};
#line 349 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
typedef struct f_info f_info;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.h"
struct zipLocalFileHeader {
   unsigned int signature ;
   unsigned short version ;
   unsigned short genFlag ;
   short compression ;
   unsigned short last_mod_time ;
   unsigned short last_mod_date ;
   unsigned int crc ;
   unsigned int compressed ;
   unsigned int uncompressed ;
   unsigned short filename_length ;
   unsigned short extra_length ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.h"
struct zipCentralFileHeader {
   unsigned int signature ;
   unsigned char version_extract[2] ;
   unsigned char version_madeby[2] ;
   unsigned short genFlag ;
   unsigned short compression ;
   unsigned short last_mod_time ;
   unsigned short last_mod_date ;
   unsigned int crc ;
   unsigned int compressed ;
   unsigned int uncompressed ;
   unsigned short filename_length ;
   unsigned short extra_length ;
   unsigned short filecomment_length ;
   unsigned short disk_number_start ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
struct OLE_HDR {
   char magic[8] ;
   char clsid[16] ;
   unsigned short uMinorVersion ;
   unsigned short uDllVersion ;
   unsigned short uByteOrder ;
   unsigned short uSectorShift ;
   unsigned short uMiniSectorShift ;
   unsigned short reserved ;
   u_int32_t reserved1 ;
   u_int32_t reserved2 ;
   u_int32_t num_FAT_blocks ;
   u_int32_t root_start_block ;
   u_int32_t dfsignature ;
   u_int32_t miniSectorCutoff ;
   u_int32_t dir_flag ;
   u_int32_t csectMiniFat ;
   u_int32_t FAT_next_block ;
   u_int32_t num_extra_FAT_blocks ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
struct DIRECTORY {
   char name[64] ;
   int type ;
   int level ;
   int start_block ;
   int size ;
   int next ;
   int prev ;
   int dir ;
   int s1 ;
   int s2 ;
   int d1 ;
   int d2 ;
};
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 53 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
struct OLE_DIR {
   char name[64] ;
   unsigned short namsiz ;
   char type ;
   char bflags ;
   unsigned long prev_dirent ;
   unsigned long next_dirent ;
   unsigned long dir_dirent ;
   char clsid[16] ;
   unsigned long userFlags ;
   int secs1 ;
   int days1 ;
   int secs2 ;
   int days2 ;
   unsigned long start_block ;
   unsigned long size ;
   short reserved ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
extern char *__progname ;
#line 295 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
char wildcard  ;
#line 347 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
s_spec search_spec[50]  ;
#line 370 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
int signal_caught  ;
#line 391
int get_audit_file_open(f_state *s ) ;
#line 394
int get_mode(f_state *s , off_t check_mode ) ;
#line 416
void audit_msg(f_state *s , char *format  , ...) ;
#line 417
int close_audit_file(f_state *s ) ;
#line 449
void fatal_error(f_state *s , char *msg ) ;
#line 450
void print_error(f_state *s , char *fn , char *msg ) ;
#line 451
void print_message(f_state *s , char *format , va_list argp ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/cli.c"
void fatal_error(f_state *s , char *msg ) 
{ 
  int tmp ;

  {
  {
#line 7
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s%s",
          __progname, msg, "\n");
#line 8
  tmp = get_audit_file_open(s);
  }
#line 8
  if (tmp) {
    {
#line 10
    audit_msg(s, msg);
#line 11
    close_audit_file(s);
    }
  }
  {
#line 13
  exit(1);
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/cli.c"
void print_error(f_state *s , char *fn , char *msg ) 
{ 
  int tmp ;

  {
  {
#line 18
  tmp = get_mode(s, (off_t )(1 << 2));
  }
#line 18
  if (! tmp) {
    {
#line 19
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s%s",
            __progname, fn, msg, "\n");
    }
  }
#line 20
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/cli.c"
void print_message(f_state *s , char *format , va_list argp ) 
{ 


  {
  {
#line 24
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
           argp);
#line 25
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          "\n");
  }
#line 26
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 378 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
int initialize_state(f_state *s , int argc , char **argv ) ;
#line 379
void free_state(f_state *s ) ;
#line 381
char *get_invocation(f_state *s ) ;
#line 382
char *get_start_time(f_state *s ) ;
#line 384
int set_config_file(f_state *s , char *fn ) ;
#line 385
char *get_config_file(f_state *s ) ;
#line 387
int set_output_directory(f_state *s , char *fn ) ;
#line 388
char *get_output_directory(f_state *s ) ;
#line 393
void set_mode(f_state *s , off_t new_mode ) ;
#line 396
int set_search_def(f_state *s , char *ft , unsigned long long max_file_size ) ;
#line 399
void set_input_file(f_state *s , char *filename ) ;
#line 402
void set_chunk(f_state *s , int size ) ;
#line 404
void init_bm_table(unsigned char *needle , size_t *table , size_t len , int casesensitive ,
                   int searchtype ) ;
#line 406
void set_skip(f_state *s , int size ) ;
#line 407
void set_block(f_state *s , int size ) ;
#line 415
int open_audit_file(f_state *s ) ;
#line 431
char *current_time(void) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int initialize_state(f_state *s , int argc , char **argv ) 
{ 
  char **argv_copy ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 7
  argv_copy = argv;
#line 12
  tmp = current_time();
#line 12
  s->start_time = strdup((char const   *)tmp);
#line 13
  wildcard = (char )'?';
#line 14
  s->audit_file_open = 0;
#line 15
  s->mode = (off_t )0;
#line 16
  s->input_file = (char *)((void *)0);
#line 17
  s->fileswritten = 0;
#line 18
  s->block_size = 512;
#line 21
  set_config_file(s, (char *)"foremost.conf");
#line 22
  set_output_directory(s, (char *)"output");
#line 24
  tmp___0 = malloc(sizeof(char ) * 1024UL);
#line 24
  s->invocation = (char *)tmp___0;
#line 25
  *(s->invocation + 0) = (char)0;
#line 26
  s->chunk_size = 100;
#line 27
  s->num_builtin = 0;
#line 28
  s->skip = 0;
#line 29
  s->time_stamp = 0;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    tmp___1 = strlen((char const   *)s->invocation);
#line 32
    strncat((char */* __restrict  */)s->invocation, (char const   */* __restrict  */)*argv_copy,
            1024UL - tmp___1);
#line 33
    tmp___2 = strlen((char const   *)s->invocation);
#line 33
    strncat((char */* __restrict  */)s->invocation, (char const   */* __restrict  */)" ",
            1024UL - tmp___2);
#line 34
    argv_copy ++;
    }
#line 30
    if (! *argv_copy) {
#line 30
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void free_state(f_state *s ) 
{ 


  {
  {
#line 43
  free((void *)s->start_time);
#line 44
  free((void *)s->output_directory);
#line 45
  free((void *)s->config_file);
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int get_audit_file_open(f_state *s ) 
{ 


  {
#line 50
  return (s->audit_file_open);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
char *get_invocation(f_state *s ) 
{ 


  {
#line 55
  return (s->invocation);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
char *get_start_time(f_state *s ) 
{ 


  {
#line 60
  return (s->start_time);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
char *get_config_file(f_state *s ) 
{ 


  {
#line 65
  return (s->config_file);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int set_config_file(f_state *s , char *fn ) 
{ 
  char temp[4096] ;

  {
  {
#line 75
  realpath((char const   */* __restrict  */)fn, (char */* __restrict  */)(temp));
#line 78
  s->config_file = strdup((char const   *)(temp));
  }
#line 79
  return (0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
char *get_output_directory(f_state *s ) 
{ 


  {
#line 84
  return (s->output_directory);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int set_output_directory(f_state *s , char *fn ) 
{ 
  char temp[4096] ;
  int fullpathlen ;
  size_t tmp ;

  {
  {
#line 90
  fullpathlen = 0;
#line 96
  realpath((char const   */* __restrict  */)fn, (char */* __restrict  */)(temp));
#line 97
  tmp = strlen((char const   *)(temp));
#line 97
  fullpathlen = (int )tmp;
  }
#line 99
  if (fullpathlen != 0) {
    {
#line 101
    s->output_directory = strdup((char const   *)(temp));
    }
  } else {
    {
#line 106
    s->output_directory = strdup((char const   *)fn);
    }
  }
#line 108
  return (0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int get_mode(f_state *s , off_t check_mode ) 
{ 


  {
#line 113
  return ((int )(s->mode & check_mode));
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void set_mode(f_state *s , off_t new_mode ) 
{ 


  {
#line 118
  s->mode |= new_mode;
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void set_chunk(f_state *s , int size ) 
{ 


  {
#line 123
  s->chunk_size = size;
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void set_skip(f_state *s , int size ) 
{ 


  {
#line 128
  s->skip = size;
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void set_block(f_state *s , int size ) 
{ 


  {
#line 133
  s->block_size = size;
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void write_audit_header(f_state *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 138
  audit_msg(s, (char *)"Foremost version %s by %s", "1.5.7", "Jesse Kornblum, Kris Kendall, and Nick Mikus");
#line 139
  audit_msg(s, (char *)"Audit File");
#line 140
  audit_msg(s, (char *)"");
#line 141
  tmp = get_start_time(s);
#line 141
  audit_msg(s, (char *)"Foremost started at %s", tmp);
#line 142
  tmp___0 = get_invocation(s);
#line 142
  audit_msg(s, (char *)"Invocation: %s", tmp___0);
#line 143
  tmp___1 = get_output_directory(s);
#line 143
  audit_msg(s, (char *)"Output directory: %s", tmp___1);
#line 144
  tmp___2 = get_config_file(s);
#line 144
  audit_msg(s, (char *)"Configuration file: %s", tmp___2);
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int open_audit_file(f_state *s ) 
{ 
  char fn[1024] ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;

  {
  {
#line 151
  tmp = get_output_directory(s);
#line 151
  snprintf((char */* __restrict  */)(fn), (size_t )1024, (char const   */* __restrict  */)"%s%c%s",
           tmp, '/', "audit.txt");
#line 158
  tmp___2 = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"w");
#line 158
  s->audit_file = tmp___2;
  }
#line 158
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 160
    tmp___0 = __errno_location();
#line 160
    tmp___1 = strerror(*tmp___0);
#line 160
    print_error(s, fn, tmp___1);
#line 161
    fatal_error(s, (char *)"Can\'t open audit file");
    }
  }
  {
#line 164
  s->audit_file_open = 1;
#line 165
  write_audit_header(s);
  }
#line 167
  return (0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int close_audit_file(f_state *s ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 172
  audit_msg(s, (char *)"------------------------------------------------------------------");
#line 173
  audit_msg(s, (char *)"");
#line 174
  tmp = current_time();
#line 174
  audit_msg(s, (char *)"Foremost finished at %s", tmp);
#line 176
  tmp___2 = fclose(s->audit_file);
  }
#line 176
  if (tmp___2) {
    {
#line 178
    tmp___0 = __errno_location();
#line 178
    tmp___1 = strerror(*tmp___0);
#line 178
    print_error(s, (char *)"audit.txt", tmp___1);
    }
#line 179
    return (1);
  }
#line 182
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void audit_msg(f_state *s , char *format  , ...) 
{ 
  va_list argp ;
  int tmp ;

  {
  {
#line 188
  __builtin_va_start(argp, format);
#line 190
  tmp = get_mode(s, (off_t )(1 << 1));
  }
#line 190
  if (tmp) {
    {
#line 191
    print_message(s, format, argp);
#line 192
    __builtin_va_end(argp);
#line 193
    __builtin_va_start(argp, format);
    }
  }
  {
#line 196
  vfprintf((FILE */* __restrict  */)s->audit_file, (char const   */* __restrict  */)format,
           argp);
#line 197
  __builtin_va_end(argp);
#line 199
  fprintf((FILE */* __restrict  */)s->audit_file, (char const   */* __restrict  */)"%s",
          "\n");
#line 200
  fflush(stdout);
  }
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void set_input_file(f_state *s , char *filename ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 205
  tmp = strlen((char const   *)filename);
#line 205
  tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 205
  s->input_file = (char *)tmp___0;
#line 206
  tmp___1 = strlen((char const   *)filename);
#line 206
  strncpy((char */* __restrict  */)s->input_file, (char const   */* __restrict  */)filename,
          tmp___1 + 1UL);
  }
#line 207
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int init_builtin(f_state *s , int type , char *suffix , char *header , char *footer ,
                 int header_len , int footer_len , unsigned long long max_len , int case_sen ) 
{ 
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 214
  i = s->num_builtin;
#line 216
  search_spec[i].type = type;
#line 217
  tmp = strlen((char const   *)suffix);
#line 217
  tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 217
  search_spec[i].suffix = (char *)tmp___0;
#line 218
  search_spec[i].num_markers = 0;
#line 219
  strcpy((char */* __restrict  */)search_spec[i].suffix, (char const   */* __restrict  */)suffix);
#line 221
  search_spec[i].header_len = (unsigned int )header_len;
#line 222
  search_spec[i].footer_len = (unsigned int )footer_len;
#line 224
  search_spec[i].max_len = max_len;
#line 225
  search_spec[i].found = 0;
#line 226
  tmp___1 = malloc((unsigned long )search_spec[i].header_len * sizeof(unsigned char ));
#line 226
  search_spec[i].header = (unsigned char *)tmp___1;
#line 227
  tmp___2 = malloc((unsigned long )search_spec[i].footer_len * sizeof(unsigned char ));
#line 227
  search_spec[i].footer = (unsigned char *)tmp___2;
#line 228
  search_spec[i].case_sen = case_sen;
#line 229
  memset((void *)(search_spec[i].comment), 0, (size_t )63);
#line 231
  memcpy((void */* __restrict  */)search_spec[i].header, (void const   */* __restrict  */)header,
         (size_t )search_spec[i].header_len);
#line 232
  memcpy((void */* __restrict  */)search_spec[i].footer, (void const   */* __restrict  */)footer,
         (size_t )search_spec[i].footer_len);
#line 234
  init_bm_table(search_spec[i].header, (size_t *)(search_spec[i].header_bm_table),
                (size_t )search_spec[i].header_len, search_spec[i].case_sen, 0);
#line 239
  init_bm_table(search_spec[i].footer, (size_t *)(search_spec[i].footer_bm_table),
                (size_t )search_spec[i].footer_len, search_spec[i].case_sen, 0);
#line 244
  (s->num_builtin) ++;
  }
#line 246
  return (i);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void add_marker(f_state *s , int index___0 , char *marker___0 , int markerlength ) 
{ 
  int i ;
  void *tmp ;

  {
#line 252
  i = search_spec[index___0].num_markers;
#line 253
  if ((unsigned long )marker___0 == (unsigned long )((void *)0)) {
#line 255
    search_spec[index___0].num_markers = 0;
#line 256
    return;
  }
  {
#line 259
  search_spec[index___0].markerlist[i].len = markerlength;
#line 260
  tmp = malloc((unsigned long )search_spec[index___0].markerlist[i].len * sizeof(unsigned char ));
#line 260
  search_spec[index___0].markerlist[i].value = (unsigned char *)tmp;
#line 262
  memcpy((void */* __restrict  */)search_spec[index___0].markerlist[i].value, (void const   */* __restrict  */)marker___0,
         (size_t )search_spec[index___0].markerlist[i].len);
#line 263
  init_bm_table(search_spec[index___0].markerlist[i].value, (size_t *)(search_spec[index___0].markerlist[i].marker_bm_table),
                (size_t )search_spec[index___0].markerlist[i].len, 1, 0);
#line 268
  (search_spec[index___0].num_markers) ++;
  }
#line 269
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void init_all(f_state *state ) 
{ 
  int index___0 ;

  {
  {
#line 274
  index___0 = 0;
#line 275
  init_builtin(state, 0, (char *)"jpg", (char *)"\377\330\377", (char *)"\377\331",
               3, 2, 20971520ULL, 1);
#line 276
  index___0 = init_builtin(state, 1, (char *)"gif", (char *)"GIF8", (char *)"\000;",
                           4, 2, 1048576ULL, 1);
#line 277
  add_marker(state, index___0, (char *)"\000\000;", 3);
#line 278
  init_builtin(state, 2, (char *)"bmp", (char *)"BM", (char *)((void *)0), 2, 0, 2097152ULL,
               1);
#line 279
  init_builtin(state, 7, (char *)"wmv", (char *)"0&\262u\216f\317\021", (char *)"\241\334\253\214G\251",
               8, 6, 41943040ULL, 1);
#line 288
  init_builtin(state, 10, (char *)"mov", (char *)"moov", (char *)((void *)0), 4, 0,
               41943040ULL, 1);
#line 289
  init_builtin(state, 32, (char *)"mp4", (char *)"\000\000\000\034ftyp", (char *)((void *)0),
               8, 0, 629145600ULL, 1);
#line 290
  init_builtin(state, 17, (char *)"rif", (char *)"RIFF", (char *)"INFO", 4, 4, 20971520ULL,
               1);
#line 291
  init_builtin(state, 8, (char *)"htm", (char *)"<html", (char *)"</html>", 5, 7,
               1048576ULL, 0);
#line 292
  init_builtin(state, 15, (char *)"ole", (char *)"\320\317\021\340\241\261\032\341\000\000\000\000\000\000\000\000",
               (char *)((void *)0), 16, 0, 5242880ULL, 1);
#line 301
  init_builtin(state, 9, (char *)"zip", (char *)"PK\003\004", (char *)"K\005\006\000",
               4, 4, 104857600ULL, 1);
#line 310
  init_builtin(state, 25, (char *)"rar", (char *)"Rar!\032\a\000", (char *)"\000\000\000\000\000\000\000\000",
               7, 8, 104857600ULL, 1);
#line 319
  init_builtin(state, 26, (char *)"exe", (char *)"MZ", (char *)((void *)0), 2, 0,
               1048576ULL, 1);
#line 321
  index___0 = init_builtin(state, 24, (char *)"png", (char *)"\211PNG\r\n\032\n",
                           (char *)"IEND", 8, 4, 1048576ULL, 1);
#line 330
  index___0 = init_builtin(state, 3, (char *)"mpg", (char *)"\000\000\001\272", (char *)"\000\000\001\271",
                           4, 4, 52428800ULL, 1);
#line 339
  add_marker(state, index___0, (char *)"\000\000\001", 3);
#line 341
  index___0 = init_builtin(state, 4, (char *)"pdf", (char *)"%PDF-1.", (char *)"%%EOF",
                           7, 5, 41943040ULL, 1);
#line 342
  add_marker(state, index___0, (char *)"/L ", 3);
#line 343
  add_marker(state, index___0, (char *)"obj", 3);
#line 344
  add_marker(state, index___0, (char *)"/Linearized", 11);
#line 345
  add_marker(state, index___0, (char *)"/Length", 7);
  }
#line 346
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
int set_search_def(f_state *s , char *ft , unsigned long long max_file_size ) 
{ 
  int index___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
  {
#line 351
  index___0 = 0;
#line 353
  tmp___35 = strcmp((char const   *)ft, "jpg");
  }
#line 353
  if (tmp___35 == 0) {
#line 353
    goto _L___3;
  } else {
    {
#line 353
    tmp___36 = strcmp((char const   *)ft, "jpeg");
    }
#line 353
    if (tmp___36 == 0) {
      _L___3: /* CIL Label */ 
#line 355
      if (max_file_size == 0ULL) {
#line 356
        max_file_size = 20971520ULL;
      }
      {
#line 357
      init_builtin(s, 0, (char *)"jpg", (char *)"\377\330\377", (char *)"\377\331",
                   3, 2, max_file_size, 1);
      }
    } else {
      {
#line 359
      tmp___34 = strcmp((char const   *)ft, "gif");
      }
#line 359
      if (tmp___34 == 0) {
#line 361
        if (max_file_size == 0ULL) {
#line 362
          max_file_size = 1048576ULL;
        }
        {
#line 363
        index___0 = init_builtin(s, 1, (char *)"gif", (char *)"GIF8", (char *)"\000;",
                                 4, 2, max_file_size, 1);
#line 373
        add_marker(s, index___0, (char *)"\000\000;", 3);
        }
      } else {
        {
#line 375
        tmp___33 = strcmp((char const   *)ft, "bmp");
        }
#line 375
        if (tmp___33 == 0) {
#line 378
          if (max_file_size == 0ULL) {
#line 379
            max_file_size = 2097152ULL;
          }
          {
#line 381
          init_builtin(s, 2, (char *)"bmp", (char *)"BM", (char *)((void *)0), 2,
                       0, max_file_size, 1);
          }
        } else {
          {
#line 383
          tmp___32 = strcmp((char const   *)ft, "mp4");
          }
#line 383
          if (tmp___32 == 0) {
            {
#line 385
            init_builtin(s, 32, (char *)"mp4", (char *)"\000\000\000\034ftyp", (char *)((void *)0),
                         8, 0, 629145600ULL, 1);
            }
          } else {
            {
#line 387
            tmp___31 = strcmp((char const   *)ft, "exe");
            }
#line 387
            if (tmp___31 == 0) {
#line 390
              if (max_file_size == 0ULL) {
#line 391
                max_file_size = 1048576ULL;
              }
              {
#line 393
              init_builtin(s, 26, (char *)"exe", (char *)"MZ", (char *)((void *)0),
                           2, 0, max_file_size, 1);
              }
            } else {
              {
#line 395
              tmp___30 = strcmp((char const   *)ft, "elf");
              }
#line 395
              if (tmp___30 == 0) {
#line 398
                if (max_file_size == 0ULL) {
#line 399
                  max_file_size = 1048576ULL;
                }
                {
#line 401
                init_builtin(s, 27, (char *)"elf", (char *)"0x7fELF", (char *)((void *)0),
                             4, 0, max_file_size, 1);
                }
              } else {
                {
#line 403
                tmp___29 = strcmp((char const   *)ft, "reg");
                }
#line 403
                if (tmp___29 == 0) {
#line 406
                  if (max_file_size == 0ULL) {
#line 407
                    max_file_size = 2097152ULL;
                  }
                  {
#line 409
                  init_builtin(s, 28, (char *)"reg", (char *)"regf", (char *)((void *)0),
                               4, 0, max_file_size, 1);
                  }
                } else {
                  {
#line 412
                  tmp___27 = strcmp((char const   *)ft, "mpg");
                  }
#line 412
                  if (tmp___27 == 0) {
#line 412
                    goto _L___2;
                  } else {
                    {
#line 412
                    tmp___28 = strcmp((char const   *)ft, "mpeg");
                    }
#line 412
                    if (tmp___28 == 0) {
                      _L___2: /* CIL Label */ 
#line 414
                      if (max_file_size == 0ULL) {
#line 415
                        max_file_size = 52428800ULL;
                      }
                      {
#line 418
                      index___0 = init_builtin(s, 3, (char *)"mpg", (char *)"\000\000\001\272",
                                               (char *)"\000\000\001\271", 4, 4, max_file_size,
                                               1);
#line 427
                      add_marker(s, index___0, (char *)"\000\000\001", 3);
                      }
                    } else {
                      {
#line 435
                      tmp___26 = strcmp((char const   *)ft, "wmv");
                      }
#line 435
                      if (tmp___26 == 0) {
#line 438
                        if (max_file_size == 0ULL) {
#line 439
                          max_file_size = 20971520ULL;
                        }
                        {
#line 441
                        init_builtin(s, 7, (char *)"wmv", (char *)"0&\262u\216f\317\021",
                                     (char *)"\241\334\253\214G\251", 8, 6, max_file_size,
                                     1);
                        }
                      } else {
                        {
#line 451
                        tmp___25 = strcmp((char const   *)ft, "avi");
                        }
#line 451
                        if (tmp___25 == 0) {
#line 454
                          if (max_file_size == 0ULL) {
#line 455
                            max_file_size = 20971520ULL;
                          }
                          {
#line 457
                          init_builtin(s, 6, (char *)"avi", (char *)"RIFF", (char *)"INFO",
                                       4, 4, max_file_size, 1);
                          }
                        } else {
                          {
#line 460
                          tmp___24 = strcmp((char const   *)ft, "rif");
                          }
#line 460
                          if (tmp___24 == 0) {
#line 463
                            if (max_file_size == 0ULL) {
#line 464
                              max_file_size = 20971520ULL;
                            }
                            {
#line 465
                            init_builtin(s, 17, (char *)"rif", (char *)"RIFF", (char *)"INFO",
                                         4, 4, max_file_size, 1);
                            }
                          } else {
                            {
#line 467
                            tmp___23 = strcmp((char const   *)ft, "wav");
                            }
#line 467
                            if (tmp___23 == 0) {
#line 470
                              if (max_file_size == 0ULL) {
#line 471
                                max_file_size = 20971520ULL;
                              }
                              {
#line 472
                              init_builtin(s, 18, (char *)"wav", (char *)"RIFF", (char *)"INFO",
                                           4, 4, max_file_size, 1);
                              }
                            } else {
                              {
#line 475
                              tmp___21 = strcmp((char const   *)ft, "html");
                              }
#line 475
                              if (tmp___21 == 0) {
#line 475
                                goto _L___1;
                              } else {
                                {
#line 475
                                tmp___22 = strcmp((char const   *)ft, "htm");
                                }
#line 475
                                if (tmp___22 == 0) {
                                  _L___1: /* CIL Label */ 
#line 478
                                  if (max_file_size == 0ULL) {
#line 479
                                    max_file_size = 1048576ULL;
                                  }
                                  {
#line 480
                                  init_builtin(s, 8, (char *)"htm", (char *)"<html",
                                               (char *)"</html>", 5, 7, max_file_size,
                                               0);
                                  }
                                } else {
                                  {
#line 483
                                  tmp___19 = strcmp((char const   *)ft, "ole");
                                  }
#line 483
                                  if (tmp___19 == 0) {
#line 483
                                    goto _L___0;
                                  } else {
                                    {
#line 483
                                    tmp___20 = strcmp((char const   *)ft, "office");
                                    }
#line 483
                                    if (tmp___20 == 0) {
                                      _L___0: /* CIL Label */ 
#line 486
                                      if (max_file_size == 0ULL) {
#line 487
                                        max_file_size = 10485760ULL;
                                      }
                                      {
#line 488
                                      init_builtin(s, 15, (char *)"ole", (char *)"\320\317\021\340\241\261\032\341\000\000\000\000\000\000\000\000",
                                                   (char *)((void *)0), 16, 0, max_file_size,
                                                   1);
                                      }
                                    } else {
                                      {
#line 498
                                      tmp___18 = strcmp((char const   *)ft, "doc");
                                      }
#line 498
                                      if (tmp___18 == 0) {
#line 500
                                        if (max_file_size == 0ULL) {
#line 501
                                          max_file_size = 20971520ULL;
                                        }
                                        {
#line 502
                                        init_builtin(s, 5, (char *)"doc", (char *)"\320\317\021\340\241\261\032\341\000\000\000\000\000\000\000\000",
                                                     (char *)((void *)0), 16, 0, max_file_size,
                                                     1);
                                        }
                                      } else {
                                        {
#line 512
                                        tmp___17 = strcmp((char const   *)ft, "xls");
                                        }
#line 512
                                        if (tmp___17 == 0) {
#line 514
                                          if (max_file_size == 0ULL) {
#line 515
                                            max_file_size = 10485760ULL;
                                          }
                                          {
#line 517
                                          init_builtin(s, 11, (char *)"xls", (char *)"\320\317\021\340\241\261\032\341\000\000\000\000\000\000\000\000",
                                                       (char *)((void *)0), 16, 0,
                                                       max_file_size, 1);
                                          }
                                        } else {
                                          {
#line 528
                                          tmp___16 = strcmp((char const   *)ft, "ppt");
                                          }
#line 528
                                          if (tmp___16 == 0) {
#line 531
                                            if (max_file_size == 0ULL) {
#line 532
                                              max_file_size = 10485760ULL;
                                            }
                                            {
#line 533
                                            init_builtin(s, 12, (char *)"ppt", (char *)"\320\317\021\340\241\261\032\341\000\000\000\000\000\000\000\000",
                                                         (char *)((void *)0), 16,
                                                         0, max_file_size, 1);
                                            }
                                          } else {
                                            {
#line 543
                                            tmp___15 = strcmp((char const   *)ft,
                                                              "zip");
                                            }
#line 543
                                            if (tmp___15 == 0) {
#line 545
                                              if (max_file_size == 0ULL) {
#line 546
                                                max_file_size = 104857600ULL;
                                              }
                                              {
#line 548
                                              init_builtin(s, 9, (char *)"zip", (char *)"PK\003\004",
                                                           (char *)"PK\005\006", 4,
                                                           4, max_file_size, 1);
                                              }
                                            } else {
                                              {
#line 559
                                              tmp___14 = strcmp((char const   *)ft,
                                                                "rar");
                                              }
#line 559
                                              if (tmp___14 == 0) {
#line 561
                                                if (max_file_size == 0ULL) {
#line 562
                                                  max_file_size = 104857600ULL;
                                                }
                                                {
#line 564
                                                init_builtin(s, 25, (char *)"rar",
                                                             (char *)"Rar!\032\a\000",
                                                             (char *)"\000\000\000\000\000\000\000\000",
                                                             7, 8, max_file_size,
                                                             1);
                                                }
                                              } else {
                                                {
#line 575
                                                tmp___13 = strcmp((char const   *)ft,
                                                                  "sxw");
                                                }
#line 575
                                                if (tmp___13 == 0) {
#line 577
                                                  if (max_file_size == 0ULL) {
#line 578
                                                    max_file_size = 10485760ULL;
                                                  }
                                                  {
#line 580
                                                  init_builtin(s, 20, (char *)"sxw",
                                                               (char *)"PK\003\004",
                                                               (char *)"K\005\006\000",
                                                               4, 4, max_file_size,
                                                               1);
                                                  }
                                                } else {
                                                  {
#line 591
                                                  tmp___12 = strcmp((char const   *)ft,
                                                                    "sxc");
                                                  }
#line 591
                                                  if (tmp___12 == 0) {
#line 593
                                                    if (max_file_size == 0ULL) {
#line 594
                                                      max_file_size = 10485760ULL;
                                                    }
                                                    {
#line 596
                                                    init_builtin(s, 21, (char *)"sxc",
                                                                 (char *)"PK\003\004",
                                                                 (char *)"K\005\006\000",
                                                                 4, 4, max_file_size,
                                                                 1);
                                                    }
                                                  } else {
                                                    {
#line 607
                                                    tmp___11 = strcmp((char const   *)ft,
                                                                      "sxi");
                                                    }
#line 607
                                                    if (tmp___11 == 0) {
#line 609
                                                      if (max_file_size == 0ULL) {
#line 610
                                                        max_file_size = 10485760ULL;
                                                      }
                                                      {
#line 612
                                                      init_builtin(s, 22, (char *)"sxi",
                                                                   (char *)"PK\003\004",
                                                                   (char *)"K\005\006\000",
                                                                   4, 4, max_file_size,
                                                                   1);
                                                      }
                                                    } else {
                                                      {
#line 623
                                                      tmp___10 = strcmp((char const   *)ft,
                                                                        "docx");
                                                      }
#line 623
                                                      if (tmp___10 == 0) {
#line 625
                                                        if (max_file_size == 0ULL) {
#line 626
                                                          max_file_size = 10485760ULL;
                                                        }
                                                        {
#line 628
                                                        init_builtin(s, 29, (char *)"docx",
                                                                     (char *)"PK\003\004",
                                                                     (char *)"K\005\006\000",
                                                                     4, 4, max_file_size,
                                                                     1);
                                                        }
                                                      } else {
                                                        {
#line 639
                                                        tmp___9 = strcmp((char const   *)ft,
                                                                         "pptx");
                                                        }
#line 639
                                                        if (tmp___9 == 0) {
#line 641
                                                          if (max_file_size == 0ULL) {
#line 642
                                                            max_file_size = 10485760ULL;
                                                          }
                                                          {
#line 644
                                                          init_builtin(s, 31, (char *)"pptx",
                                                                       (char *)"PK\003\004",
                                                                       (char *)"K\005\006\000",
                                                                       4, 4, max_file_size,
                                                                       1);
                                                          }
                                                        } else {
                                                          {
#line 655
                                                          tmp___8 = strcmp((char const   *)ft,
                                                                           "xlsx");
                                                          }
#line 655
                                                          if (tmp___8 == 0) {
#line 657
                                                            if (max_file_size == 0ULL) {
#line 658
                                                              max_file_size = 10485760ULL;
                                                            }
                                                            {
#line 660
                                                            init_builtin(s, 30, (char *)"xlsx",
                                                                         (char *)"PK\003\004",
                                                                         (char *)"K\005\006\000",
                                                                         4, 4, max_file_size,
                                                                         1);
                                                            }
                                                          } else {
                                                            {
#line 671
                                                            tmp___6 = strcmp((char const   *)ft,
                                                                             "gzip");
                                                            }
#line 671
                                                            if (tmp___6 == 0) {
#line 671
                                                              goto _L;
                                                            } else {
                                                              {
#line 671
                                                              tmp___7 = strcmp((char const   *)ft,
                                                                               "gz");
                                                              }
#line 671
                                                              if (tmp___7 == 0) {
                                                                _L: /* CIL Label */ 
#line 673
                                                                if (max_file_size == 0ULL) {
#line 674
                                                                  max_file_size = 104857600ULL;
                                                                }
                                                                {
#line 676
                                                                init_builtin(s, 16,
                                                                             (char *)"gz",
                                                                             (char *)"\037\213",
                                                                             (char *)"\000\000\000\000",
                                                                             2, 4,
                                                                             max_file_size,
                                                                             1);
                                                                }
                                                              } else {
                                                                {
#line 678
                                                                tmp___5 = strcmp((char const   *)ft,
                                                                                 "pdf");
                                                                }
#line 678
                                                                if (tmp___5 == 0) {
#line 680
                                                                  if (max_file_size == 0ULL) {
#line 681
                                                                    max_file_size = 20971520ULL;
                                                                  }
                                                                  {
#line 683
                                                                  index___0 = init_builtin(s,
                                                                                           4,
                                                                                           (char *)"pdf",
                                                                                           (char *)"%PDF-1.",
                                                                                           (char *)"%%EOF",
                                                                                           7,
                                                                                           5,
                                                                                           max_file_size,
                                                                                           1);
#line 684
                                                                  add_marker(s, index___0,
                                                                             (char *)"/L ",
                                                                             3);
#line 685
                                                                  add_marker(s, index___0,
                                                                             (char *)"obj",
                                                                             3);
#line 686
                                                                  add_marker(s, index___0,
                                                                             (char *)"/Linearized",
                                                                             11);
#line 687
                                                                  add_marker(s, index___0,
                                                                             (char *)"/Length",
                                                                             7);
                                                                  }
                                                                } else {
                                                                  {
#line 689
                                                                  tmp___4 = strcmp((char const   *)ft,
                                                                                   "vjpeg");
                                                                  }
#line 689
                                                                  if (tmp___4 == 0) {
#line 691
                                                                    if (max_file_size == 0ULL) {
#line 692
                                                                      max_file_size = 41943040ULL;
                                                                    }
                                                                    {
#line 693
                                                                    init_builtin(s,
                                                                                 19,
                                                                                 (char *)"mov",
                                                                                 (char *)"pnot",
                                                                                 (char *)((void *)0),
                                                                                 4,
                                                                                 0,
                                                                                 max_file_size,
                                                                                 1);
                                                                    }
                                                                  } else {
                                                                    {
#line 695
                                                                    tmp___3 = strcmp((char const   *)ft,
                                                                                     "mov");
                                                                    }
#line 695
                                                                    if (tmp___3 == 0) {
#line 697
                                                                      if (max_file_size == 0ULL) {
#line 698
                                                                        max_file_size = 41943040ULL;
                                                                      }
                                                                      {
#line 700
                                                                      init_builtin(s,
                                                                                   10,
                                                                                   (char *)"mov",
                                                                                   (char *)"moov",
                                                                                   (char *)((void *)0),
                                                                                   4,
                                                                                   0,
                                                                                   max_file_size,
                                                                                   1);
                                                                      }
                                                                    } else {
                                                                      {
#line 702
                                                                      tmp___2 = strcmp((char const   *)ft,
                                                                                       "wpd");
                                                                      }
#line 702
                                                                      if (tmp___2 == 0) {
#line 704
                                                                        if (max_file_size == 0ULL) {
#line 705
                                                                          max_file_size = 1048576ULL;
                                                                        }
                                                                        {
#line 707
                                                                        init_builtin(s,
                                                                                     13,
                                                                                     (char *)"wpd",
                                                                                     (char *)"\377WPC",
                                                                                     (char *)((void *)0),
                                                                                     4,
                                                                                     0,
                                                                                     max_file_size,
                                                                                     1);
                                                                        }
                                                                      } else {
                                                                        {
#line 709
                                                                        tmp___1 = strcmp((char const   *)ft,
                                                                                         "cpp");
                                                                        }
#line 709
                                                                        if (tmp___1 == 0) {
#line 711
                                                                          if (max_file_size == 0ULL) {
#line 712
                                                                            max_file_size = 1048576ULL;
                                                                          }
                                                                          {
#line 714
                                                                          index___0 = init_builtin(s,
                                                                                                   14,
                                                                                                   (char *)"cpp",
                                                                                                   (char *)"#include",
                                                                                                   (char *)"char",
                                                                                                   8,
                                                                                                   4,
                                                                                                   max_file_size,
                                                                                                   1);
#line 715
                                                                          add_marker(s,
                                                                                     index___0,
                                                                                     (char *)"int",
                                                                                     3);
                                                                          }
                                                                        } else {
                                                                          {
#line 717
                                                                          tmp___0 = strcmp((char const   *)ft,
                                                                                           "png");
                                                                          }
#line 717
                                                                          if (tmp___0 == 0) {
#line 719
                                                                            if (max_file_size == 0ULL) {
#line 720
                                                                              max_file_size = 1048576ULL;
                                                                            }
                                                                            {
#line 721
                                                                            index___0 = init_builtin(s,
                                                                                                     24,
                                                                                                     (char *)"png",
                                                                                                     (char *)"\211PNG\r\n\032\n",
                                                                                                     (char *)"IEND",
                                                                                                     8,
                                                                                                     4,
                                                                                                     max_file_size,
                                                                                                     1);
                                                                            }
                                                                          } else {
                                                                            {
#line 731
                                                                            tmp = strcmp((char const   *)ft,
                                                                                         "all");
                                                                            }
#line 731
                                                                            if (tmp == 0) {
                                                                              {
#line 733
                                                                              init_all(s);
                                                                              }
                                                                            } else {
#line 737
                                                                              return (0);
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 740
  return (1);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/state.c"
void init_bm_table(unsigned char *needle , size_t *table , size_t len , int casesensitive ,
                   int searchtype ) 
{ 
  size_t i ;
  size_t j ;
  size_t currentindex ;
  int tmp ;
  int tmp___0 ;

  {
#line 747
  i = (size_t )0;
#line 747
  j = (size_t )0;
#line 747
  currentindex = (size_t )0;
#line 749
  i = (size_t )0;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (i <= 255UL)) {
#line 749
      goto while_break;
    }
#line 750
    *(table + i) = len;
#line 749
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  i = (size_t )0;
  {
#line 751
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 751
    if (! (i < len)) {
#line 751
      goto while_break___0;
    }
#line 753
    if (searchtype == 1) {
#line 756
      currentindex = i;
    } else {
#line 761
      currentindex = (len - i) - 1UL;
    }
#line 764
    if ((int )*(needle + i) == (int )wildcard) {
#line 766
      j = (size_t )0;
      {
#line 766
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 766
        if (! (j <= 255UL)) {
#line 766
          goto while_break___1;
        }
#line 767
        *(table + j) = currentindex;
#line 766
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 770
    *(table + *(needle + i)) = currentindex;
#line 771
    if (! casesensitive) {
      {
#line 778
      tmp = tolower((int )*(needle + i));
#line 778
      *(table + tmp) = currentindex;
#line 779
      tmp___0 = toupper((int )*(needle + i));
#line 779
      *(table + tmp___0) = currentindex;
      }
    }
#line 751
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 782
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 432 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
off_t find_file_size(FILE *f ) ;
#line 433
char *human_readable(off_t size , char *buffer___0 ) ;
#line 434
char *units(unsigned int c ) ;
#line 435
unsigned int chop(char *buf ) ;
#line 436
void print_search_specs(f_state *s ) ;
#line 437
int memwildcardcmp(void const   *s1 , void const   *s2 , size_t n , int caseSensitive ) ;
#line 438
int charactersMatch(char a , char b , int caseSensitive ) ;
#line 439
void printx(unsigned char *buf , int start , int end ) ;
#line 440
unsigned short htos(unsigned char *s , int endian ) ;
#line 441
unsigned int htoi(unsigned char *s , int endian ) ;
#line 442
unsigned long long htoll(unsigned char *s , int endian ) ;
#line 443
int displayPosition(f_state *s , f_info *i , unsigned long long pos ) ;
#line 452
void print_stats(f_state *s ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
unsigned int chop(char *buf ) 
{ 
  unsigned int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 24
  tmp = strlen((char const   *)buf);
#line 24
  len = (unsigned int )tmp;
  }
#line 25
  if ((int )*(buf + (len - 1U)) == 10) {
#line 27
    if ((int )*(buf + (len - 2U)) == 13) {
#line 29
      *(buf + (len - 2U)) = *(buf + (len - 1U));
    }
#line 31
    *(buf + (len - 1U)) = *(buf + len);
  }
  {
#line 33
  tmp___0 = strlen((char const   *)buf);
  }
#line 33
  return ((unsigned int )tmp___0);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
char *units(unsigned int c ) 
{ 


  {
  {
#line 40
  if (c == 0U) {
#line 40
    goto case_0;
  }
#line 41
  if (c == 1U) {
#line 41
    goto case_1;
  }
#line 42
  if (c == 2U) {
#line 42
    goto case_2;
  }
#line 43
  if (c == 3U) {
#line 43
    goto case_3;
  }
#line 44
  if (c == 4U) {
#line 44
    goto case_4;
  }
#line 45
  if (c == 5U) {
#line 45
    goto case_5;
  }
#line 46
  if (c == 6U) {
#line 46
    goto case_6;
  }
#line 53
  goto switch_default;
  case_0: /* CIL Label */ 
#line 40
  return ((char *)"B");
  case_1: /* CIL Label */ 
#line 41
  return ((char *)"KB");
  case_2: /* CIL Label */ 
#line 42
  return ((char *)"MB");
  case_3: /* CIL Label */ 
#line 43
  return ((char *)"GB");
  case_4: /* CIL Label */ 
#line 44
  return ((char *)"TB");
  case_5: /* CIL Label */ 
#line 45
  return ((char *)"PB");
  case_6: /* CIL Label */ 
#line 46
  return ((char *)"EB");
  switch_default: /* CIL Label */ 
#line 53
  return ((char *)"??");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
char *human_readable(off_t size , char *buffer___0 ) 
{ 
  unsigned int count ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 59
  count = 0U;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (size > 1024L)) {
#line 60
      goto while_break;
    }
#line 62
    size /= 1024L;
#line 63
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (sizeof(off_t ) == 4UL) {
    {
#line 71
    tmp = units(count);
#line 71
    snprintf((char */* __restrict  */)buffer___0, (size_t )8, (char const   */* __restrict  */)"%u %s",
             (unsigned int )size, tmp);
    }
  } else
#line 73
  if (sizeof(off_t ) == 8UL) {
    {
#line 75
    tmp___0 = units(count);
#line 75
    snprintf((char */* __restrict  */)buffer___0, (size_t )8, (char const   */* __restrict  */)"%llu %s",
             (unsigned long long )size, tmp___0);
    }
  }
#line 78
  return (buffer___0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
char *current_time(void) 
{ 
  time_t now ;
  time_t tmp ;
  char *ascii_time ;
  char *tmp___0 ;

  {
  {
#line 83
  tmp = time((time_t *)((void *)0));
#line 83
  now = tmp;
#line 84
  tmp___0 = ctime((time_t const   *)(& now));
#line 84
  ascii_time = tmp___0;
#line 85
  chop(ascii_time);
  }
#line 86
  return (ascii_time);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
void shift_string(char *fn , int start , int new_start ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 93
  if (start < 0) {
#line 94
    return;
  } else {
    {
#line 93
    tmp = strlen((char const   *)fn);
    }
#line 93
    if ((size_t )start > tmp) {
#line 94
      return;
    } else
#line 93
    if (new_start < 0) {
#line 94
      return;
    } else
#line 93
    if (new_start < start) {
#line 94
      return;
    }
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    tmp___0 = strlen((char const   *)fn);
    }
#line 96
    if (! ((size_t )new_start < tmp___0)) {
#line 96
      goto while_break;
    }
#line 98
    *(fn + start) = *(fn + new_start);
#line 99
    new_start ++;
#line 100
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  *(fn + start) = (char)0;
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
void make_magic(void) 
{ 


  {
  {
#line 108
  printf((char const   */* __restrict  */)"%s%s", "SAN DIMAS HIGH SCHOOL FOOTBALL RULES!",
         "\n");
  }
#line 111
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
off_t find_file_size(FILE *f ) 
{ 
  off_t num_sectors ;
  int fd ;
  int tmp ;
  struct stat sb ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 120
  num_sectors = (off_t )0;
#line 121
  tmp = fileno(f);
#line 121
  fd = tmp;
#line 124
  tmp___0 = fstat(fd, & sb);
  }
#line 124
  if (tmp___0) {
#line 126
    return ((off_t )0);
  }
#line 129
  if ((sb.st_mode & 61440U) == 32768U) {
#line 130
    return (sb.st_size);
  } else
#line 129
  if ((sb.st_mode & 61440U) == 16384U) {
#line 130
    return (sb.st_size);
  } else
#line 131
  if ((sb.st_mode & 61440U) == 8192U) {
#line 131
    goto _L;
  } else
#line 131
  if ((sb.st_mode & 61440U) == 24576U) {
    _L: /* CIL Label */ 
    {
#line 133
    tmp___1 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 96U), & num_sectors);
    }
#line 133
    if (! tmp___1) {
#line 140
      return (num_sectors * 512L);
    }
  }
#line 143
  return ((off_t )0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
void print_search_specs(f_state *s ) 
{ 
  int i ;
  int j ;

  {
  {
#line 323
  i = 0;
#line 324
  j = 0;
#line 325
  printf((char const   */* __restrict  */)"\nDUMPING BUILTIN SEARCH INFO\n\t");
#line 326
  i = 0;
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < s->num_builtin)) {
#line 326
      goto while_break;
    }
    {
#line 329
    printf((char const   */* __restrict  */)"%s:\n\t footer_len:=%d, header_len:=%d, max_len:=%llu ",
           search_spec[i].suffix, search_spec[i].footer_len, search_spec[i].header_len,
           search_spec[i].max_len);
#line 334
    printf((char const   */* __restrict  */)"\n\t header:\t");
#line 335
    printx(search_spec[i].header, 0, (int )search_spec[i].header_len);
#line 336
    printf((char const   */* __restrict  */)"\t footer:\t");
#line 337
    printx(search_spec[i].footer, 0, (int )search_spec[i].footer_len);
#line 338
    j = 0;
    }
    {
#line 338
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 338
      if (! (j < search_spec[i].num_markers)) {
#line 338
        goto while_break___0;
      }
      {
#line 340
      printf((char const   */* __restrict  */)"\tmarker: \t");
#line 341
      printx(search_spec[i].markerlist[j].value, 0, search_spec[i].markerlist[j].len);
#line 338
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
void print_stats(f_state *s ) 
{ 
  int i ;

  {
  {
#line 350
  i = 0;
#line 351
  audit_msg(s, (char *)"\n%d FILES EXTRACTED\n\t", s->fileswritten);
#line 352
  i = 0;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < s->num_builtin)) {
#line 352
      goto while_break;
    }
#line 355
    if (search_spec[i].found != 0) {
#line 357
      if (search_spec[i].type == 15) {
#line 358
        search_spec[i].suffix = (char *)"ole";
      } else
#line 359
      if (search_spec[i].type == 17) {
#line 360
        search_spec[i].suffix = (char *)"rif";
      } else
#line 361
      if (search_spec[i].type == 9) {
#line 362
        search_spec[i].suffix = (char *)"zip";
      }
      {
#line 363
      audit_msg(s, (char *)"%s:= %d", search_spec[i].suffix, search_spec[i].found);
      }
    }
#line 352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
int charactersMatch(char a , char b , int caseSensitive ) 
{ 
  int tmp ;

  {
#line 372
  if ((int )a == (int )wildcard) {
#line 373
    return (1);
  } else
#line 372
  if ((int )a == (int )b) {
#line 373
    return (1);
  }
#line 374
  if (caseSensitive) {
#line 375
    return (0);
  } else
#line 374
  if ((int )a < 65) {
#line 375
    return (0);
  } else
#line 374
  if ((int )a > 122) {
#line 375
    return (0);
  } else
#line 374
  if ((int )b < 65) {
#line 375
    return (0);
  } else
#line 374
  if ((int )b > 122) {
#line 375
    return (0);
  }
  {
#line 378
  tmp = abs((int )a - (int )b);
  }
#line 378
  return (tmp == 32);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
int memwildcardcmp(void const   *s1 , void const   *s2 , size_t n , int caseSensitive ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 383
  if (n != 0UL) {
#line 385
    p1 = (unsigned char const   *)s1;
#line 385
    p2 = (unsigned char const   *)s2;
    {
#line 386
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 388
      tmp = p2;
#line 388
      p2 ++;
#line 388
      tmp___0 = p1;
#line 388
      p1 ++;
#line 388
      tmp___1 = charactersMatch((char )*tmp___0, (char )*tmp, caseSensitive);
      }
#line 388
      if (! tmp___1) {
#line 389
        p1 --;
#line 389
        p2 --;
#line 389
        return ((int )((int const   )*p1 - (int const   )*p2));
      }
#line 386
      n --;
#line 386
      if (! (n != 0UL)) {
#line 386
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 394
  return (0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
void printx(unsigned char *buf , int start , int end ) 
{ 
  int i ;

  {
#line 399
  i = 0;
#line 400
  i = start;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < end)) {
#line 400
      goto while_break;
    }
    {
#line 402
    printf((char const   */* __restrict  */)"%x ", (int )*(buf + i));
#line 400
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 405
  printf((char const   */* __restrict  */)"\n");
  }
#line 406
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
char *reverse_string(char *to , char *from , int startLocation , int endLocation ) 
{ 
  int i ;
  int j ;

  {
#line 410
  i = endLocation;
#line 411
  j = 0;
#line 412
  j = startLocation;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (j < endLocation)) {
#line 412
      goto while_break;
    }
#line 414
    i --;
#line 415
    *(to + j) = *(from + i);
#line 412
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return (to);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
unsigned short htos(unsigned char *s , int endian ) 
{ 
  unsigned char *bytes ;
  void *tmp ;
  unsigned short size ;
  char temp ;
  void *tmp___0 ;

  {
  {
#line 424
  tmp = malloc(sizeof(unsigned short ) * sizeof(char ));
#line 424
  bytes = (unsigned char *)tmp;
#line 425
  size = (unsigned short)0;
#line 426
  temp = (char )'x';
#line 427
  tmp___0 = memcpy((void */* __restrict  */)bytes, (void const   */* __restrict  */)s,
                   sizeof(short ));
#line 427
  bytes = (unsigned char *)tmp___0;
  }
#line 429
  if (endian == 0) {
#line 433
    temp = (char )*(bytes + 0);
#line 434
    *(bytes + 0) = *(bytes + 1);
#line 435
    *(bytes + 1) = (unsigned char )temp;
  } else
#line 438
  if (endian == 1) {

  }
  {
#line 445
  size = *((unsigned short *)bytes);
#line 446
  free((void *)bytes);
  }
#line 447
  return (size);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
unsigned int htoi(unsigned char *s , int endian ) 
{ 
  int length ;
  unsigned char *bytes ;
  void *tmp ;
  unsigned int size ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 453
  length = (int )sizeof(int );
#line 454
  tmp = malloc((unsigned long )length * sizeof(char ));
#line 454
  bytes = (unsigned char *)tmp;
#line 455
  size = 0U;
#line 457
  tmp___0 = memcpy((void */* __restrict  */)bytes, (void const   */* __restrict  */)s,
                   (size_t )length);
#line 457
  bytes = (unsigned char *)tmp___0;
  }
#line 459
  if (endian == 0) {
    {
#line 462
    tmp___1 = reverse_string((char *)bytes, (char *)s, 0, length);
#line 462
    bytes = (unsigned char *)tmp___1;
    }
  } else
#line 464
  if (endian == 1) {

  }
  {
#line 470
  size = *((unsigned int *)bytes);
#line 472
  free((void *)bytes);
  }
#line 473
  return (size);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
unsigned long long htoll(unsigned char *s , int endian ) 
{ 
  int length ;
  unsigned char *bytes ;
  void *tmp ;
  unsigned long long size ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 478
  length = (int )sizeof(unsigned long long );
#line 479
  tmp = malloc((unsigned long )length * sizeof(char ));
#line 479
  bytes = (unsigned char *)tmp;
#line 480
  size = 0ULL;
#line 481
  tmp___0 = memcpy((void */* __restrict  */)bytes, (void const   */* __restrict  */)s,
                   (size_t )length);
#line 481
  bytes = (unsigned char *)tmp___0;
  }
#line 485
  if (endian == 0) {
    {
#line 490
    tmp___1 = reverse_string((char *)bytes, (char *)s, 0, length);
#line 490
    bytes = (unsigned char *)tmp___1;
    }
  } else
#line 492
  if (endian == 1) {

  }
  {
#line 500
  size = *((unsigned long long *)bytes);
#line 507
  free((void *)bytes);
  }
#line 508
  return (size);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
static int last_val  =    0;
#line 512 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/helpers.c"
int displayPosition(f_state *s , f_info *i , unsigned long long pos ) 
{ 
  int percentDone ;
  int count ;
  int flag ;
  int factor ;
  int multiplier ;
  int number_of_stars ;
  char buffer___0[256] ;
  long double skip ;
  long double tot_bytes ;
  char *tmp ;

  {
#line 515
  percentDone = 0;
#line 518
  flag = 0;
#line 519
  factor = 4;
#line 520
  multiplier = 25;
#line 521
  number_of_stars = 0;
#line 523
  skip = (long double )(s->skip * s->block_size);
#line 525
  tot_bytes = (long double )i->total_bytes;
#line 526
  tot_bytes -= skip;
#line 527
  if (i->total_bytes > 0L) {
#line 529
    percentDone = (int )(((long double )pos / tot_bytes) * (long double )100);
#line 530
    if (percentDone != last_val) {
#line 531
      flag = 1;
    }
#line 532
    last_val = percentDone;
  } else {
#line 536
    flag = 1;
#line 537
    factor = 4;
#line 538
    multiplier = 25;
  }
#line 541
  if (flag) {
    {
#line 543
    number_of_stars = percentDone / factor;
#line 545
    printf((char const   */* __restrict  */)"%s: |", s->input_file);
#line 546
    count = 0;
    }
    {
#line 546
    while (1) {
      while_continue: /* CIL Label */ ;
#line 546
      if (! (count < number_of_stars)) {
#line 546
        goto while_break;
      }
      {
#line 548
      printf((char const   */* __restrict  */)"*");
#line 546
      count ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 551
    count = 0;
    {
#line 551
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 551
      if (! (count < multiplier - number_of_stars)) {
#line 551
        goto while_break___0;
      }
      {
#line 553
      printf((char const   */* __restrict  */)" ");
#line 551
      count ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 556
    if (i->total_bytes > 0L) {
      {
#line 558
      printf((char const   */* __restrict  */)"|\t %d%% done\n", percentDone);
      }
    } else {
      {
#line 562
      tmp = human_readable((off_t )pos, buffer___0);
#line 562
      printf((char const   */* __restrict  */)"|\t %s done\n", tmp);
      }
    }
  }
#line 567
  if (percentDone == 100) {
#line 569
    last_val = 0;
  }
#line 572
  return (1);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 427 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
int load_config_file(f_state *s ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/config.c"
int translate(char *str ) 
{ 
  char next ;
  char *rd ;
  char *wr ;
  char *bad ;
  char temp[5] ;
  char ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 8
  rd = str;
#line 8
  wr = str;
#line 12
  if (! *rd) {
#line 14
    return (0);
  }
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if (! *rd) {
#line 17
      goto while_break;
    }
#line 21
    if ((int )*rd == 92) {
#line 23
      rd ++;
      {
#line 26
      if ((int )*rd == 92) {
#line 26
        goto case_92;
      }
#line 31
      if ((int )*rd == 97) {
#line 31
        goto case_97;
      }
#line 36
      if ((int )*rd == 115) {
#line 36
        goto case_115;
      }
#line 41
      if ((int )*rd == 110) {
#line 41
        goto case_110;
      }
#line 46
      if ((int )*rd == 114) {
#line 46
        goto case_114;
      }
#line 51
      if ((int )*rd == 116) {
#line 51
        goto case_116;
      }
#line 56
      if ((int )*rd == 118) {
#line 56
        goto case_118;
      }
#line 66
      if ((int )*rd == 51) {
#line 66
        goto case_51;
      }
#line 66
      if ((int )*rd == 50) {
#line 66
        goto case_51;
      }
#line 66
      if ((int )*rd == 49) {
#line 66
        goto case_51;
      }
#line 66
      if ((int )*rd == 48) {
#line 66
        goto case_51;
      }
#line 66
      if ((int )*rd == 120) {
#line 66
        goto case_51;
      }
#line 85
      goto switch_default;
      case_92: /* CIL Label */ 
#line 27
      tmp = rd;
#line 27
      rd ++;
#line 28
      tmp___0 = wr;
#line 28
      wr ++;
#line 28
      *tmp___0 = (char )'\\';
#line 29
      goto switch_break;
      case_97: /* CIL Label */ 
#line 32
      tmp___1 = rd;
#line 32
      rd ++;
#line 33
      tmp___2 = wr;
#line 33
      wr ++;
#line 33
      *tmp___2 = (char )'\a';
#line 34
      goto switch_break;
      case_115: /* CIL Label */ 
#line 37
      tmp___3 = rd;
#line 37
      rd ++;
#line 38
      tmp___4 = wr;
#line 38
      wr ++;
#line 38
      *tmp___4 = (char )' ';
#line 39
      goto switch_break;
      case_110: /* CIL Label */ 
#line 42
      tmp___5 = rd;
#line 42
      rd ++;
#line 43
      tmp___6 = wr;
#line 43
      wr ++;
#line 43
      *tmp___6 = (char )'\n';
#line 44
      goto switch_break;
      case_114: /* CIL Label */ 
#line 47
      tmp___7 = rd;
#line 47
      rd ++;
#line 48
      tmp___8 = wr;
#line 48
      wr ++;
#line 48
      *tmp___8 = (char )'\r';
#line 49
      goto switch_break;
      case_116: /* CIL Label */ 
#line 52
      tmp___9 = rd;
#line 52
      rd ++;
#line 53
      tmp___10 = wr;
#line 53
      wr ++;
#line 53
      *tmp___10 = (char )'\t';
#line 54
      goto switch_break;
      case_118: /* CIL Label */ 
#line 57
      tmp___11 = rd;
#line 57
      rd ++;
#line 58
      tmp___12 = wr;
#line 58
      wr ++;
#line 58
      *tmp___12 = (char )'\v';
#line 59
      goto switch_break;
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 67
      next = *(rd + 1);
#line 68
      if ((int )next < 48) {
#line 69
        goto switch_break;
      } else
#line 68
      if (57 < (int )next) {
#line 68
        if ((int )next < 65) {
#line 69
          goto switch_break;
        } else {
#line 68
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 68
      if (70 < (int )next) {
#line 68
        if ((int )next < 97) {
#line 69
          goto switch_break;
        } else {
#line 68
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 68
      if ((int )next > 102) {
#line 69
        goto switch_break;
      }
#line 70
      next = *(rd + 2);
#line 71
      if ((int )next < 48) {
#line 72
        goto switch_break;
      } else
#line 71
      if (57 < (int )next) {
#line 71
        if ((int )next < 65) {
#line 72
          goto switch_break;
        } else {
#line 71
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 71
      if (70 < (int )next) {
#line 71
        if ((int )next < 97) {
#line 72
          goto switch_break;
        } else {
#line 71
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 71
      if ((int )next > 102) {
#line 72
        goto switch_break;
      }
      {
#line 73
      temp[0] = (char )'0';
#line 74
      bad = temp;
#line 75
      strncpy((char */* __restrict  */)(temp + 1), (char const   */* __restrict  */)rd,
              (size_t )3);
#line 76
      temp[4] = (char )'\000';
#line 77
      tmp___13 = strtoul((char const   */* __restrict  */)(temp), (char **/* __restrict  */)(& bad),
                         0);
#line 77
      ch = (char )tmp___13;
      }
#line 78
      if ((int )*bad == 0) {
#line 80
        tmp___14 = wr;
#line 80
        wr ++;
#line 80
        *tmp___14 = ch;
#line 81
        rd += 3;
      }
#line 83
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 86
      tmp___15 = wr;
#line 86
      wr ++;
#line 86
      *tmp___15 = (char )'\\';
#line 87
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 93
      tmp___16 = wr;
#line 93
      wr ++;
#line 93
      tmp___17 = rd;
#line 93
      rd ++;
#line 93
      *tmp___16 = *tmp___17;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  *wr = (char )'\000';
#line 96
  return ((int )(wr - str));
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/config.c"
char *skipWhiteSpace(char *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = __ctype_b_loc();
    }
#line 101
    if (! ((int const   )*(*tmp + (int )*(str + 0)) & 8192)) {
#line 101
      goto while_break;
    }
#line 102
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (str);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/config.c"
int extractSearchSpecData(f_state *state , char **tokenarray ) 
{ 
  s_spec *s ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 119
  s = & search_spec[state->num_builtin];
#line 121
  tmp = malloc(8UL * sizeof(char ));
#line 121
  s->suffix = (char *)tmp;
#line 122
  tmp___0 = malloc(1024UL * sizeof(char ));
#line 122
  s->header = (unsigned char *)tmp___0;
#line 123
  tmp___1 = malloc(1024UL * sizeof(char ));
#line 123
  s->footer = (unsigned char *)tmp___1;
#line 124
  s->type = 23;
#line 125
  tmp___2 = strlen("NONE");
#line 125
  tmp___3 = strncasecmp((char const   *)*(tokenarray + 0), "NONE", tmp___2);
  }
#line 125
  if (tmp___3) {
    {
#line 135
    memcpy((void */* __restrict  */)s->suffix, (void const   */* __restrict  */)*(tokenarray + 0),
           (size_t )8);
    }
  } else {
#line 128
    *(s->suffix + 0) = (char )' ';
#line 129
    *(s->suffix + 1) = (char)0;
  }
  {
#line 139
  tmp___4 = strncasecmp((char const   *)*(tokenarray + 1), "y", (size_t )1);
  }
#line 139
  if (tmp___4) {
    {
#line 139
    tmp___5 = strncasecmp((char const   *)*(tokenarray + 1), "yes", (size_t )3);
    }
#line 139
    if (tmp___5) {
#line 139
      tmp___6 = 0;
    } else {
#line 139
      tmp___6 = 1;
    }
  } else {
#line 139
    tmp___6 = 1;
  }
  {
#line 139
  s->case_sen = tmp___6;
#line 141
  tmp___7 = atoi((char const   *)*(tokenarray + 2));
#line 141
  s->max_len = (unsigned long long )tmp___7;
#line 144
  s->searchtype = 0;
#line 145
  tmp___14 = strlen("REVERSE");
#line 145
  tmp___15 = strncasecmp((char const   *)*(tokenarray + 5), "REVERSE", tmp___14);
  }
#line 145
  if (tmp___15) {
    {
#line 150
    tmp___12 = strlen("NEXT");
#line 150
    tmp___13 = strncasecmp((char const   *)*(tokenarray + 5), "NEXT", tmp___12);
    }
#line 150
    if (tmp___13) {
      {
#line 156
      tmp___10 = strlen("FORWARD");
#line 156
      tmp___11 = strncasecmp((char const   *)*(tokenarray + 5), "FORWARD", tmp___10);
      }
#line 156
      if (tmp___11) {
        {
#line 160
        tmp___8 = strlen("ASCII");
#line 160
        tmp___9 = strncasecmp((char const   *)*(tokenarray + 5), "ASCII", tmp___8);
        }
#line 160
        if (! tmp___9) {
#line 163
          s->searchtype = 3;
        }
      } else {
#line 158
        s->searchtype = 0;
      }
    } else {
#line 152
      s->searchtype = 2;
    }
  } else {
#line 148
    s->searchtype = 1;
  }
  {
#line 171
  tmp___16 = translate(*(tokenarray + 3));
#line 171
  s->header_len = (unsigned int )tmp___16;
#line 172
  memcpy((void */* __restrict  */)s->header, (void const   */* __restrict  */)*(tokenarray + 3),
         (size_t )s->header_len);
#line 173
  tmp___17 = translate(*(tokenarray + 4));
#line 173
  s->footer_len = (unsigned int )tmp___17;
#line 174
  memcpy((void */* __restrict  */)s->footer, (void const   */* __restrict  */)*(tokenarray + 4),
         (size_t )s->footer_len);
#line 176
  init_bm_table(s->header, (size_t *)(s->header_bm_table), (size_t )s->header_len,
                s->case_sen, s->searchtype);
#line 177
  init_bm_table(s->footer, (size_t *)(s->footer_bm_table), (size_t )s->footer_len,
                s->case_sen, s->searchtype);
  }
#line 179
  return (1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/config.c"
int process_line(f_state *s , char *buffer___0 , int line_number ) 
{ 
  char *buf ;
  char *token ;
  char **tokenarray ;
  void *tmp ;
  int i ;
  int len ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 185
  buf = buffer___0;
#line 187
  tmp = malloc(6UL * sizeof(char [1024]));
#line 187
  tokenarray = (char **)tmp;
#line 188
  i = 0;
#line 188
  tmp___0 = strlen((char const   *)buffer___0);
#line 188
  len = (int )tmp___0;
  }
#line 192
  if ((int )*(buffer___0 + (len - 2)) == 13) {
#line 192
    if ((int )*(buffer___0 + (len - 1)) == 10) {
#line 194
      *(buffer___0 + (len - 2)) = *(buffer___0 + (len - 1));
#line 195
      *(buffer___0 + (len - 1)) = *(buffer___0 + len);
    }
  }
  {
#line 198
  tmp___1 = skipWhiteSpace(buf);
#line 198
  buf = tmp___1;
#line 199
  token = strtok((char */* __restrict  */)buf, (char const   */* __restrict  */)" \t\n");
  }
#line 202
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 204
    return (1);
  } else
#line 202
  if ((int )*(token + 0) == 35) {
#line 204
    return (1);
  }
  {
#line 208
  tmp___4 = strncasecmp((char const   *)token, "wildcard", (size_t )9);
  }
#line 208
  if (! tmp___4) {
    {
#line 210
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
#line 210
    if ((unsigned long )token != (unsigned long )((void *)0)) {
      {
#line 212
      translate(token);
      }
    } else {
#line 216
      return (1);
    }
    {
#line 219
    tmp___3 = strlen((char const   *)token);
    }
#line 219
    if (tmp___3 > 1UL) {
      {
#line 221
      tmp___2 = strlen((char const   *)token);
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Wildcard can only be one character, but you specified %zu characters.\n         Using the first character, \"%c\", as the wildcard.\n",
              tmp___2, (int )*(token + 0));
      }
    }
#line 229
    wildcard = *(token + 0);
#line 230
    return (1);
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (token) {
#line 233
      if (! (i < 6)) {
#line 233
        goto while_break;
      }
    } else {
#line 233
      goto while_break;
    }
    {
#line 235
    *(tokenarray + i) = token;
#line 236
    i ++;
#line 237
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  if (6 - i == 2) {
#line 242
    goto case_2;
  }
#line 247
  if (6 - i == 1) {
#line 247
    goto case_1;
  }
#line 251
  if (6 - i == 0) {
#line 251
    goto case_0;
  }
#line 254
  goto switch_default;
  case_2: /* CIL Label */ 
#line 243
  *(tokenarray + 5) = (char *)"";
#line 244
  *(tokenarray + 4) = (char *)"";
#line 245
  goto switch_break;
  case_1: /* CIL Label */ 
#line 248
  *(tokenarray + 5) = (char *)"";
#line 249
  goto switch_break;
  case_0: /* CIL Label */ 
#line 252
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 255
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: In line %d of the configuration file.\n",
          line_number);
  }
#line 256
  return (0);
#line 257
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 261
  tmp___5 = extractSearchSpecData(s, tokenarray);
  }
#line 261
  if (! tmp___5) {
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: Unknown error on line %d of the configuration file.\n",
            line_number);
    }
  }
#line 268
  (s->num_builtin) ++;
#line 270
  return (1);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/config.c"
int load_config_file(f_state *s ) 
{ 
  FILE *f ;
  char *buffer___0 ;
  void *tmp ;
  off_t line_number ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 276
  tmp = malloc(1024UL * sizeof(char ));
#line 276
  buffer___0 = (char *)tmp;
#line 277
  line_number = (off_t )0;
#line 283
  tmp___4 = get_config_file(s);
#line 283
  f = fopen((char const   */* __restrict  */)tmp___4, (char const   */* __restrict  */)"r");
  }
#line 283
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 291
    set_config_file(s, (char *)"/etc/foremost.conf");
#line 293
    tmp___3 = get_config_file(s);
#line 293
    f = fopen((char const   */* __restrict  */)tmp___3, (char const   */* __restrict  */)"r");
    }
#line 293
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 295
      tmp___0 = __errno_location();
#line 295
      tmp___1 = strerror(*tmp___0);
#line 295
      tmp___2 = get_config_file(s);
#line 295
      print_error(s, tmp___2, tmp___1);
#line 296
      free((void *)buffer___0);
      }
#line 297
      return (1);
    }
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    tmp___6 = fgets((char */* __restrict  */)buffer___0, 1024, (FILE */* __restrict  */)f);
    }
#line 302
    if (! tmp___6) {
#line 302
      goto while_break;
    }
    {
#line 304
    line_number ++;
#line 305
    tmp___5 = process_line(s, buffer___0, (int )line_number);
    }
#line 305
    if (! tmp___5) {
      {
#line 307
      free((void *)buffer___0);
#line 308
      fclose(f);
      }
#line 309
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  fclose(f);
#line 315
  free((void *)buffer___0);
  }
#line 316
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 297
extern FILE *fopen64(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 781
extern int fseeko(FILE *stream , __off64_t offset , int whence )  __asm__("fseeko64")  ;
#line 784
extern __off64_t ftello(FILE *stream )  __asm__("ftello64")  ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 422 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
int write_to_disk(f_state *s , s_spec *needle , unsigned long long len , unsigned char *buf ,
                  unsigned long long t_offset ) ;
#line 424
void cleanup_output(f_state *s ) ;
#line 455
int process_file(f_state *s ) ;
#line 456
int process_stdin(f_state *s ) ;
#line 457
unsigned char *bm_search(unsigned char *needle , size_t needle_len , unsigned char *haystack ,
                         size_t haystack_len , size_t *table , int case_sen , int searchtype ) ;
#line 459
unsigned char *bm_search_skipn(unsigned char *needle , size_t needle_len , unsigned char *haystack ,
                               size_t haystack_len , size_t *table , int casesensitive ,
                               int searchtype , int start_pos ) ;
#line 464
unsigned char *extract_file(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                            unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int user_interrupt(f_state *s , f_info *i ) 
{ 
  char *tmp ;

  {
  {
#line 19
  tmp = current_time();
#line 19
  audit_msg(s, (char *)"Interrupt received at %s", tmp);
#line 22
  fclose(i->handle);
#line 23
  free((void *)s);
#line 24
  free((void *)i);
#line 25
  cleanup_output(s);
#line 26
  exit(-1);
  }
#line 27
  return (0);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
unsigned char *read_from_disk(unsigned long long offset , f_info *i , unsigned long long length ) 
{ 
  unsigned long long bytesread ;
  unsigned char *newbuf ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 33
  bytesread = 0ULL;
#line 34
  tmp = malloc((size_t )(length * (unsigned long long )sizeof(char )));
#line 34
  newbuf = (unsigned char *)tmp;
  }
#line 35
  if (! newbuf) {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of memory in read_from_disk()\n");
#line 37
    exit(1);
    }
  }
  {
#line 40
  fseeko(i->handle, (__off64_t )offset, 0);
#line 41
  tmp___0 = fread((void */* __restrict  */)newbuf, (size_t )1, (size_t )length, (FILE */* __restrict  */)i->handle);
#line 41
  bytesread = (unsigned long long )tmp___0;
  }
#line 42
  if (bytesread != length) {
    {
#line 44
    free((void *)newbuf);
    }
#line 45
    return ((unsigned char *)((void *)0));
  } else {
#line 49
    return (newbuf);
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
unsigned char *bm_search_skipn(unsigned char *needle , size_t needle_len , unsigned char *haystack ,
                               size_t haystack_len , size_t *table , int casesensitive ,
                               int searchtype , int start_pos ) 
{ 
  register size_t shift ;
  register size_t pos ;
  unsigned char *here ;
  int tmp ;
  int tmp___0 ;

  {
#line 61
  shift = (size_t )0;
#line 62
  pos = (size_t )start_pos;
#line 65
  if (needle_len == 0UL) {
#line 66
    return (haystack);
  }
#line 68
  if (searchtype == 0) {
#line 68
    goto _L;
  } else
#line 68
  if (searchtype == 2) {
    _L: /* CIL Label */ 
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (pos < haystack_len)) {
#line 70
        goto while_break;
      }
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 72
        if (pos < haystack_len) {
#line 72
          shift = *(table + *(haystack + pos));
#line 72
          if (! (shift > 0UL)) {
#line 72
            goto while_break___0;
          }
        } else {
#line 72
          goto while_break___0;
        }
#line 74
        pos += shift;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 77
      if (0UL == shift) {
        {
#line 79
        here = haystack + ((pos - needle_len) + 1UL);
#line 80
        tmp = memwildcardcmp((void const   *)needle, (void const   *)here, needle_len,
                             casesensitive);
        }
#line 80
        if (0 == tmp) {
#line 82
          return (here);
        } else {
#line 85
          pos ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    return ((unsigned char *)((void *)0));
  } else
#line 91
  if (searchtype == 1) {
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if (! (pos < haystack_len)) {
#line 93
        goto while_break___1;
      }
      {
#line 95
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 95
        if (pos < haystack_len) {
#line 95
          shift = *(table + *(haystack + ((haystack_len - pos) - 1UL)));
#line 95
          if (! (shift > 0UL)) {
#line 95
            goto while_break___2;
          }
        } else {
#line 95
          goto while_break___2;
        }
#line 101
        pos += shift;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 104
      if (0UL == shift) {
        {
#line 106
        here = haystack + ((haystack_len - pos) - 1UL);
#line 106
        tmp___0 = memwildcardcmp((void const   *)needle, (void const   *)here, needle_len,
                                 casesensitive);
        }
#line 106
        if (0 == tmp___0) {
#line 109
          return (here);
        } else {
#line 112
          pos ++;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    return ((unsigned char *)((void *)0));
  }
#line 119
  return ((unsigned char *)((void *)0));
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
unsigned char *bm_search(unsigned char *needle , size_t needle_len , unsigned char *haystack ,
                         size_t haystack_len , size_t *table , int case_sen , int searchtype ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 133
  tmp = bm_search_skipn(needle, needle_len, haystack, haystack_len, table, case_sen,
                        searchtype, (int )(needle_len - 1UL));
  }
#line 133
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
void setup_stream(f_state *s , f_info *i ) 
{ 
  char buffer___0[1024] ;
  unsigned long long skip ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 147
  skip = (unsigned long long )s->skip * (unsigned long long )s->block_size;
#line 154
  i->bytes_read = (off_t )0;
#line 155
  i->total_megs = i->total_bytes / 1048576L;
#line 157
  if (i->total_bytes != 0L) {
    {
#line 159
    tmp = human_readable(i->total_bytes, buffer___0);
#line 159
    audit_msg(s, (char *)"Length: %s (%llu bytes)", tmp, i->total_bytes);
    }
  } else {
    {
#line 165
    audit_msg(s, (char *)"Length: Unknown");
    }
  }
#line 167
  if (s->skip != 0) {
    {
#line 169
    tmp___0 = human_readable((off_t )skip, buffer___0);
#line 169
    audit_msg(s, (char *)"Skipping: %s (%llu bytes)", tmp___0, skip);
#line 170
    fseeko(i->handle, (__off64_t )skip, 0);
    }
#line 171
    if (i->total_bytes != 0L) {
#line 172
      i->total_bytes = (off_t )((unsigned long long )i->total_bytes - skip);
    }
  }
  {
#line 175
  audit_msg(s, (char *)" ");
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
void audit_layout(f_state *s ) 
{ 


  {
  {
#line 186
  audit_msg(s, (char *)"Num\t %s (bs=%d)\t %10s\t %s\t %s \n", "Name", s->block_size,
            "Size", "File Offset", "Comment");
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
void dumpInd(unsigned char *ind , int bs ) 
{ 
  int i ;
  unsigned int tmp ;

  {
  {
#line 198
  i = 0;
#line 199
  printf((char const   */* __restrict  */)"\n/*******************************/\n");
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (bs > 0)) {
#line 201
      goto while_break;
    }
#line 203
    if (i % 10 == 0) {
      {
#line 204
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 207
    tmp = htoi(ind, 1);
#line 207
    printf((char const   */* __restrict  */)"%4u ", tmp);
#line 209
    bs -= 4;
#line 210
    ind += 4;
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  printf((char const   */* __restrict  */)"\n/*******************************/\n");
  }
#line 215
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int ind_block(unsigned char *foundat , unsigned long long buflen , int bs ) 
{ 
  unsigned char *temp ;
  int jump ;
  unsigned int block ;
  unsigned int block2 ;
  unsigned int dif ;
  int i ;
  unsigned int one ;
  unsigned int numbers ;

  {
#line 226
  temp = foundat;
#line 227
  jump = 12 * bs;
#line 228
  block = 0U;
#line 229
  block2 = 0U;
#line 230
  dif = 0U;
#line 231
  i = 0;
#line 232
  one = 1U;
#line 233
  numbers = (unsigned int )(bs / 4 - 1);
#line 238
  if (buflen < (unsigned long long )(jump + 16)) {
#line 239
    return (0);
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((unsigned int )i < numbers)) {
#line 241
      goto while_break;
    }
    {
#line 243
    block = htoi(temp + (jump + i * 4), 1);
    }
#line 245
    if (block < 0U) {
#line 246
      return (0);
    }
#line 248
    if (block == 0U) {
#line 250
      goto while_break;
    }
    {
#line 253
    i ++;
#line 254
    block2 = htoi(temp + (jump + i * 4), 1);
    }
#line 255
    if (block2 < 0U) {
#line 256
      return (0);
    }
#line 258
    if (block2 == 0U) {
#line 260
      goto while_break;
    }
#line 263
    dif = block2 - block;
#line 265
    if (! (dif == one)) {
#line 280
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (i == 0) {
#line 289
    return (0);
  }
#line 292
  i ++;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! ((unsigned int )i < numbers)) {
#line 292
      goto while_break___0;
    }
    {
#line 294
    block = htoi(temp + (jump + i * 4), 1);
    }
#line 295
    if (block != 0U) {
#line 299
      return (0);
    }
#line 292
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  return (1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int search_chunk(f_state *s , unsigned char *buf , f_info *i , unsigned long long chunk_size ,
                 unsigned long long f_offset ) 
{ 
  unsigned long long c_offset ;
  unsigned char *foundat ;
  unsigned char *current_pos ;
  unsigned char *header_pos ;
  unsigned char *newbuf ;
  unsigned char *ind_ptr ;
  unsigned long long current_buflen ;
  int tryBS[3] ;
  unsigned char *extractbuf ;
  unsigned long long file_size ;
  s_spec *needle ;
  int j ;
  int bs ;
  int rem ;
  int x ;
  int found_ind ;
  off_t saveme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 314
  c_offset = 0ULL;
#line 318
  foundat = buf;
#line 319
  current_pos = (unsigned char *)((void *)0);
#line 320
  header_pos = (unsigned char *)((void *)0);
#line 321
  newbuf = (unsigned char *)((void *)0);
#line 322
  ind_ptr = (unsigned char *)((void *)0);
#line 323
  current_buflen = chunk_size;
#line 324
  tryBS[0] = 4096;
#line 324
  tryBS[1] = 1024;
#line 324
  tryBS[2] = 512;
#line 325
  extractbuf = (unsigned char *)((void *)0);
#line 326
  file_size = 0ULL;
#line 327
  needle = (s_spec *)((void *)0);
#line 328
  j = 0;
#line 329
  bs = 0;
#line 330
  rem = 0;
#line 331
  x = 0;
#line 332
  found_ind = 0;
#line 335
  j = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (j < s->num_builtin)) {
#line 335
      goto while_break;
    }
#line 337
    needle = & search_spec[j];
#line 338
    foundat = buf;
#line 342
    bs = 0;
#line 343
    current_buflen = chunk_size;
    {
#line 344
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 344
      if (! foundat) {
#line 344
        goto while_break___0;
      }
      {
#line 346
      needle->written = 0;
#line 347
      found_ind = 0;
#line 348
      memset((void *)(needle->comment), 0, (size_t )63);
      }
#line 349
      if (chunk_size <= (unsigned long long )(foundat - buf)) {
#line 353
        foundat = (unsigned char *)((void *)0);
#line 354
        goto while_break___0;
      }
#line 356
      current_buflen = chunk_size - (unsigned long long )(foundat - buf);
#line 364
      if (signal_caught == 15) {
        {
#line 366
        user_interrupt(s, i);
#line 367
        printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 368
        signal_caught = 0;
        }
      } else
#line 364
      if (signal_caught == 2) {
        {
#line 366
        user_interrupt(s, i);
#line 367
        printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 368
        signal_caught = 0;
        }
      }
      {
#line 371
      tmp___0 = get_mode(s, (off_t )(1 << 4));
      }
#line 371
      if (tmp___0) {
#line 379
        rem = (int )((foundat - buf) % (long )s->block_size);
#line 380
        if (rem != 0) {
#line 382
          foundat += s->block_size - rem;
        }
        {
#line 385
        tmp = memwildcardcmp((void const   *)needle->header, (void const   *)foundat,
                             (size_t )needle->header_len, needle->case_sen);
        }
#line 385
        if (tmp != 0) {
#line 390
          if (current_buflen > (unsigned long long )s->block_size) {
#line 392
            foundat += s->block_size;
#line 393
            goto while_continue___0;
          } else {
#line 397
            foundat = (unsigned char *)((void *)0);
#line 398
            goto while_break___0;
          }
        }
#line 402
        header_pos = foundat;
      } else {
        {
#line 406
        foundat = bm_search(needle->header, (size_t )needle->header_len, foundat,
                            (size_t )current_buflen, (size_t *)(needle->header_bm_table),
                            needle->case_sen, 0);
#line 414
        header_pos = foundat;
        }
      }
#line 417
      if ((unsigned long )foundat != (unsigned long )((void *)0)) {
#line 417
        if ((unsigned long )foundat >= 0UL) {
          {
#line 419
          current_buflen = chunk_size - (unsigned long long )(foundat - buf);
#line 421
          tmp___4 = get_mode(s, (off_t )(1 << 3));
          }
#line 421
          if (tmp___4) {
#line 428
            x = 0;
            {
#line 428
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 428
              if (! (x < 3)) {
#line 428
                goto while_break___1;
              }
              {
#line 430
              bs = tryBS[x];
#line 432
              tmp___3 = ind_block(foundat, current_buflen, bs);
              }
#line 432
              if (tmp___3) {
                {
#line 434
                tmp___1 = get_mode(s, (off_t )(1 << 1));
                }
#line 434
                if (tmp___1) {
                  {
#line 436
                  sprintf((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)" (IND BLK bs:=%d)",
                          bs);
                  }
                }
#line 443
                if (current_buflen > (unsigned long long )(13 * bs)) {
                  {
#line 445
                  tmp___2 = memmove((void *)(foundat + 12 * bs), (void const   *)(foundat + 13 * bs),
                                    (size_t )(current_buflen - (unsigned long long )(13 * bs)));
                  }
#line 445
                  if (! tmp___2) {
#line 446
                    goto while_break___1;
                  }
#line 448
                  found_ind = 1;
#line 452
                  ind_ptr = foundat + 12 * bs;
#line 453
                  current_buflen -= (unsigned long long )bs;
#line 454
                  chunk_size -= (unsigned long long )bs;
#line 455
                  goto while_break___1;
                }
              }
#line 428
              x ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          {
#line 463
          c_offset = (unsigned long long )(foundat - buf);
#line 464
          current_pos = foundat;
#line 469
          foundat = extract_file(s, c_offset, foundat, current_buflen, needle, f_offset);
#line 476
          tmp___6 = get_mode(s, (off_t )(1 << 5));
          }
#line 476
          if (tmp___6) {
#line 478
            if (needle->written == 0) {
#line 482
              if (current_buflen >= needle->max_len) {
#line 484
                file_size = needle->max_len;
              } else {
#line 488
                file_size = current_buflen;
              }
              {
#line 491
              sprintf((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)" (Header dump)");
#line 492
              tmp___5 = malloc((size_t )(file_size * (unsigned long long )sizeof(char )));
#line 492
              extractbuf = (unsigned char *)tmp___5;
#line 493
              memcpy((void */* __restrict  */)extractbuf, (void const   */* __restrict  */)header_pos,
                     (size_t )file_size);
#line 494
              write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 495
              free((void *)extractbuf);
              }
            }
          } else
#line 498
          if (! foundat) {
#line 504
            if (current_buflen < needle->max_len) {
              {
#line 509
              saveme = ftello(i->handle);
#line 511
              newbuf = read_from_disk(c_offset + f_offset, i, needle->max_len);
              }
#line 512
              if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 513
                goto while_break___0;
              }
              {
#line 514
              current_pos = extract_file(s, c_offset, newbuf, needle->max_len, needle,
                                         f_offset);
#line 522
              fseeko(i->handle, saveme, 0);
#line 525
              free((void *)newbuf);
              }
            } else {
#line 529
              foundat = header_pos;
#line 530
              foundat += needle->header_len + 1U;
            }
          }
        }
      }
#line 537
      if (found_ind) {
        {
#line 545
        tmp___7 = memmove((void *)(ind_ptr + bs), (void const   *)ind_ptr, (size_t )(current_buflen - (unsigned long long )(13 * bs)));
        }
#line 545
        if (! tmp___7) {
#line 546
          goto while_break___0;
        }
        {
#line 547
        memset((void *)ind_ptr, 0, (size_t )(bs - 1));
#line 548
        chunk_size += (unsigned long long )bs;
#line 549
        memset((void *)(needle->comment), 0, (size_t )63);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 335
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (1);
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int search_stream(f_state *s , f_info *i ) 
{ 
  unsigned long long bytesread ;
  unsigned long long f_offset ;
  unsigned long long chunk_size ;
  unsigned char *buf ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 565
  bytesread = 0ULL;
#line 566
  f_offset = 0ULL;
#line 567
  chunk_size = ((unsigned long long )s->chunk_size * 1024ULL) * 1024ULL;
#line 568
  tmp = malloc((size_t )((unsigned long long )sizeof(char ) * chunk_size));
#line 568
  buf = (unsigned char *)tmp;
#line 570
  setup_stream(s, i);
#line 572
  audit_layout(s);
  }
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 577
    tmp___1 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )chunk_size,
                    (FILE */* __restrict  */)i->handle);
#line 577
    bytesread = (unsigned long long )tmp___1;
    }
#line 577
    if (! (bytesread > 0ULL)) {
#line 577
      goto while_break;
    }
#line 579
    if (signal_caught == 15) {
      {
#line 581
      user_interrupt(s, i);
#line 582
      printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 583
      signal_caught = 0;
      }
    } else
#line 579
    if (signal_caught == 2) {
      {
#line 581
      user_interrupt(s, i);
#line 582
      printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 583
      signal_caught = 0;
      }
    }
    {
#line 589
    search_chunk(s, buf, i, bytesread, f_offset);
#line 590
    f_offset += bytesread;
#line 591
    tmp___0 = get_mode(s, (off_t )(1 << 2));
    }
#line 591
    if (! tmp___0) {
      {
#line 593
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 604
  tmp___2 = get_mode(s, (off_t )(1 << 2));
  }
#line 604
  if (! tmp___2) {
    {
#line 606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|\n");
    }
  }
#line 612
  if (signal_caught == 15) {
    {
#line 614
    user_interrupt(s, i);
#line 615
    printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 616
    signal_caught = 0;
    }
  } else
#line 612
  if (signal_caught == 2) {
    {
#line 614
    user_interrupt(s, i);
#line 615
    printf((char const   */* __restrict  */)"Cleaning up.\n");
#line 616
    signal_caught = 0;
    }
  }
  {
#line 619
  free((void *)buf);
  }
#line 620
  return (0);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
void audit_start(f_state *s , f_info *i ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 625
  tmp = get_mode(s, (off_t )(1 << 2));
  }
#line 625
  if (! tmp) {
    {
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Processing: %s\n|",
            i->file_name);
    }
  }
  {
#line 630
  audit_msg(s, (char *)"------------------------------------------------------------------");
#line 631
  audit_msg(s, (char *)"File: %s", i->file_name);
#line 632
  tmp___0 = current_time();
#line 632
  audit_msg(s, (char *)"Start: %s", tmp___0);
  }
#line 633
  return;
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
void audit_finish(f_state *s , f_info *i ) 
{ 
  char *tmp ;

  {
  {
#line 637
  tmp = current_time();
#line 637
  audit_msg(s, (char *)"Finish: %s", tmp);
  }
#line 638
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int process_file(f_state *s ) 
{ 
  f_info *i ;
  void *tmp ;
  char temp[4096] ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 644
  tmp = malloc(sizeof(f_info ));
#line 644
  i = (f_info *)tmp;
#line 647
  tmp___2 = realpath((char const   */* __restrict  */)s->input_file, (char */* __restrict  */)(temp));
  }
#line 647
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 649
    tmp___0 = __errno_location();
#line 649
    tmp___1 = strerror(*tmp___0);
#line 649
    print_error(s, s->input_file, tmp___1);
    }
#line 650
    return (1);
  }
  {
#line 653
  i->file_name = strdup((char const   *)s->input_file);
#line 654
  i->is_stdin = 0;
#line 655
  audit_start(s, i);
#line 662
  i->handle = fopen64((char const   */* __restrict  */)i->file_name, (char const   */* __restrict  */)"rb");
  }
#line 674
  if ((unsigned long )i->handle == (unsigned long )((void *)0)) {
    {
#line 676
    tmp___3 = __errno_location();
#line 676
    tmp___4 = strerror(*tmp___3);
#line 676
    print_error(s, s->input_file, tmp___4);
#line 677
    tmp___5 = __errno_location();
#line 677
    tmp___6 = strerror(*tmp___5);
#line 677
    audit_msg(s, (char *)"Error: %s", tmp___6);
    }
#line 678
    return (1);
  }
  {
#line 681
  i->total_bytes = find_file_size(i->handle);
#line 682
  search_stream(s, i);
#line 683
  audit_finish(s, i);
#line 685
  fclose(i->handle);
#line 686
  free((void *)i);
  }
#line 687
  return (0);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/engine.c"
int process_stdin(f_state *s ) 
{ 
  f_info *i ;
  void *tmp ;

  {
  {
#line 692
  tmp = malloc(sizeof(f_info ));
#line 692
  i = (f_info *)tmp;
#line 694
  i->file_name = strdup("stdin");
#line 695
  s->input_file = (char *)"stdin";
#line 696
  i->handle = stdin;
#line 697
  i->is_stdin = 1;
#line 700
  i->total_bytes = (off_t )0;
#line 701
  audit_start(s, i);
#line 703
  search_stream(s, i);
#line 705
  free((void *)i->file_name);
#line 706
  free((void *)i);
  }
#line 707
  return (0);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.h"
void print_zip(struct zipLocalFileHeader *fileHeader , struct zipCentralFileHeader *centralHeader ) 
{ 


  {
  {
#line 95
  printf((char const   */* __restrict  */)"\n\tLocal Header Data\n");
#line 96
  printf((char const   */* __restrict  */)"GenFlag:=%d,compressed:=%d,uncompressed:=%d\n",
         (int )fileHeader->genFlag, fileHeader->compressed, fileHeader->uncompressed);
#line 100
  printf((char const   */* __restrict  */)"Compression:=%d, filename_len:=%d,extralen:=%d\n",
         (int )fileHeader->compression, (int )fileHeader->filename_length, (int )fileHeader->extra_length);
#line 105
  printf((char const   */* __restrict  */)"\tCentral Header Data\n");
#line 106
  printf((char const   */* __restrict  */)"GenFlag:=%d,compressed:=%d,uncompressed:=%d\n",
         (int )centralHeader->genFlag, centralHeader->compressed, centralHeader->uncompressed);
#line 110
  printf((char const   */* __restrict  */)"Compression:=%d, Version Madeby:=%x%x\n",
         (int )centralHeader->compression, (int )centralHeader->version_madeby[0],
         (int )centralHeader->version_madeby[1]);
  }
#line 114
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
struct DIRECTORY *dirlist  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
struct DIRECTORY *dl  ;
#line 90
int get_dir_block(unsigned char *fd , int blknum , int buffersize ) ;
#line 91
int get_dir_info(unsigned char *src ) ;
#line 95
int get_block(unsigned char *fd , int blknum , unsigned char *dest , long long buffersize ) ;
#line 96
int get_FAT_block(unsigned char *fd , int blknum , int *dest , int buffersize ) ;
#line 103
void *Malloc(size_t bytes ) ;
#line 105
void init_ole(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char buffer[512] ;
#line 21
int dir_count ;
#line 22
int block_list[512UL / sizeof(int )] ;
#line 23
int *FAT ;
#line 26
int FATblk ;
#line 27
int highblk ;
#line 35 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_zip(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ,
                           char *type ) 
{ 
  unsigned char *currentpos ;
  unsigned char *buf ;
  unsigned short comment_length ;
  unsigned char *extractbuf ;
  struct zipLocalFileHeader localFH ;
  unsigned long long bytes_to_search ;
  unsigned long long file_size ;
  int oOffice ;
  int office2007 ;
  char comment[32] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 38
  currentpos = (unsigned char *)((void *)0);
#line 39
  buf = foundat;
#line 40
  comment_length = (unsigned short)0;
#line 41
  extractbuf = (unsigned char *)((void *)0);
#line 43
  bytes_to_search = 51200ULL;
#line 44
  file_size = 0ULL;
#line 45
  oOffice = 0;
#line 46
  office2007 = 0;
#line 49
  localFH.genFlag = (unsigned short)0;
#line 50
  localFH.compressed = 0U;
#line 51
  localFH.uncompressed = 0U;
#line 52
  if (buflen < 100ULL) {
#line 53
    return ((unsigned char *)((void *)0));
  }
  {
#line 55
  tmp___2 = strncmp((char const   *)((char *)(foundat + 30)), "mimetypeapplication/vnd.sun.xml.",
                    (size_t )32);
  }
#line 55
  if (tmp___2 == 0) {
    {
#line 57
    oOffice = 1;
#line 58
    tmp___1 = strncmp((char const   *)((char *)(foundat + 62)), "calc", (size_t )4);
    }
#line 58
    if (tmp___1 == 0) {
#line 60
      needle->suffix = (char *)"sxc";
    } else {
      {
#line 62
      tmp___0 = strncmp((char const   *)((char *)(foundat + 62)), "impress", (size_t )7);
      }
#line 62
      if (tmp___0 == 0) {
#line 64
        needle->suffix = (char *)"sxi";
      } else {
        {
#line 66
        tmp = strncmp((char const   *)((char *)(foundat + 62)), "writer", (size_t )6);
        }
#line 66
        if (tmp == 0) {
#line 68
          needle->suffix = (char *)"sxw";
        } else {
          {
#line 72
          sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (OpenOffice Doc?)");
#line 73
          strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 74
          needle->suffix = (char *)"sx";
          }
        }
      }
    }
  } else {
#line 79
    needle->suffix = (char *)"zip";
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if ((int )*(foundat + 2) == 3) {
#line 86
      if ((int )*(foundat + 3) == 4) {
        {
#line 89
        tmp___3 = htos(foundat + 8, 1);
#line 89
        localFH.compression = (short )tmp___3;
#line 90
        localFH.compressed = htoi(foundat + 18, 1);
#line 91
        localFH.uncompressed = htoi(foundat + 22, 1);
#line 92
        localFH.filename_length = htos(foundat + 26, 1);
#line 93
        localFH.extra_length = htos(foundat + 28, 1);
#line 94
        localFH.genFlag = htos(foundat + 6, 1);
        }
#line 97
        if ((unsigned long long )localFH.compressed > needle->max_len) {
#line 98
          return (foundat + needle->header_len);
        }
#line 100
        if ((int )localFH.filename_length > 100) {
#line 101
          return (foundat + needle->header_len);
        }
#line 104
        if ((unsigned long long )(localFH.compressed + 30U) > buflen - (unsigned long long )(foundat - buf)) {
#line 106
          return ((unsigned char *)((void *)0));
        }
        {
#line 110
        foundat += 30;
#line 112
        tmp___13 = strcmp((char const   *)needle->suffix, "zip");
        }
#line 112
        if (tmp___13 == 0) {
          {
#line 114
          tmp___11 = strncmp((char const   *)((char *)foundat), "content.xml", (size_t )11);
          }
#line 114
          if (tmp___11 == 0) {
            {
#line 114
            tmp___12 = strcmp((char const   *)needle->suffix, "zip");
            }
#line 114
            if (tmp___12 == 0) {
              {
#line 116
              oOffice = 1;
#line 117
              sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (OpenOffice Doc?)");
#line 118
              strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 119
              needle->suffix = (char *)"sx";
              }
            } else {
#line 114
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            {
#line 121
            tmp___8 = strstr((char const   *)((char *)foundat), ".class");
            }
#line 121
            if (tmp___8) {
#line 124
              needle->suffix = (char *)"jar";
            } else {
              {
#line 121
              tmp___9 = strstr((char const   *)((char *)foundat), ".jar");
              }
#line 121
              if (tmp___9) {
#line 124
                needle->suffix = (char *)"jar";
              } else {
                {
#line 121
                tmp___10 = strstr((char const   *)((char *)foundat), ".java");
                }
#line 121
                if (tmp___10) {
#line 124
                  needle->suffix = (char *)"jar";
                } else {
                  {
#line 126
                  tmp___7 = strncmp((char const   *)((char *)foundat), "[Content_Types].xml",
                                    (size_t )19);
                  }
#line 126
                  if (tmp___7 == 0) {
#line 128
                    office2007 = 1;
                  } else {
                    {
#line 130
                    tmp___6 = strncmp((char const   *)((char *)foundat), "ppt/slides",
                                      (size_t )10);
                    }
#line 130
                    if (tmp___6 == 0) {
#line 130
                      if (office2007 == 1) {
#line 132
                        needle->suffix = (char *)"pptx";
                      } else {
#line 130
                        goto _L___0;
                      }
                    } else {
                      _L___0: /* CIL Label */ 
                      {
#line 134
                      tmp___5 = strncmp((char const   *)((char *)foundat), "word/document.xml",
                                        (size_t )17);
                      }
#line 134
                      if (tmp___5 == 0) {
#line 134
                        if (office2007 == 1) {
#line 136
                          needle->suffix = (char *)"docx";
                        } else {
#line 134
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
                        {
#line 138
                        tmp___4 = strncmp((char const   *)((char *)foundat), "xl/workbook.xml",
                                          (size_t )15);
                        }
#line 138
                        if (tmp___4 == 0) {
#line 138
                          if (office2007 == 1) {
#line 140
                            needle->suffix = (char *)"xlsx";
                          } else {
                            {
#line 146
                            printf((char const   */* __restrict  */)"foundat=%s\n",
                                   foundat);
                            }
                          }
                        } else {
                          {
#line 146
                          printf((char const   */* __restrict  */)"foundat=%s\n",
                                 foundat);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 150
        foundat += localFH.compressed;
#line 151
        foundat += (int )localFH.filename_length;
#line 152
        foundat += (int )localFH.extra_length;
#line 162
        if ((int )localFH.genFlag & (1 << 3)) {
#line 162
          if (localFH.uncompressed == 0U) {
#line 162
            if (localFH.compressed == 0U) {
#line 167
              goto while_break;
            }
          }
        }
      } else {
#line 86
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 178
    if (oOffice) {
#line 178
      if ((int )localFH.genFlag == 8) {
#line 180
        goto while_break;
      } else {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if (oOffice) {
#line 194
    bytes_to_search = 1048576ULL;
  } else
#line 196
  if ((int )localFH.genFlag & (1 << 3)) {
#line 196
    if (localFH.uncompressed == 0U) {
#line 196
      if (localFH.compressed == 0U) {
#line 198
        bytes_to_search = needle->max_len;
      } else {
#line 196
        goto _L___4;
      }
    } else {
#line 196
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 202
  if (buflen < (unsigned long long )(foundat - buf)) {
#line 202
    bytes_to_search = buflen;
  } else {
#line 202
    bytes_to_search = buflen - (unsigned long long )(foundat - buf);
  }
#line 206
  if (buflen <= (unsigned long long )(foundat - buf)) {
#line 210
    bytes_to_search = 0ULL;
  } else
#line 212
  if (buflen - (unsigned long long )(foundat - buf) < bytes_to_search) {
#line 214
    bytes_to_search = buflen - (unsigned long long )(foundat - buf);
  }
  {
#line 219
  currentpos = foundat;
#line 224
  foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                      (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
  }
#line 235
  if (foundat) {
#line 242
    if (buflen - (unsigned long long )(foundat - buf) > 20ULL) {
#line 244
      foundat += 20;
    } else {
#line 248
      return ((unsigned char *)((void *)0));
    }
    {
#line 251
    comment_length = htos(foundat, 1);
#line 252
    foundat += (int )comment_length + 2;
#line 253
    file_size = (unsigned long long )(foundat - buf);
#line 258
    extractbuf = buf;
#line 259
    tmp___14 = strcmp((char const   *)type, "all");
    }
#line 259
    if (tmp___14 == 0) {
      {
#line 264
      write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
      }
    } else {
      {
#line 259
      tmp___15 = strcmp((char const   *)type, (char const   *)needle->suffix);
      }
#line 259
      if (tmp___15 == 0) {
        {
#line 264
        write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
        }
      }
    }
#line 270
    return (foundat - 2);
  }
#line 273
  if (bytes_to_search > buflen - (unsigned long long )(currentpos - buf)) {
#line 274
    return ((unsigned char *)((void *)0));
  }
#line 279
  return (currentpos);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_pdf(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *currentpos ;
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned char *tempsize ;
  unsigned long size ;
  int file_size ;
  unsigned char *header ;
  int bytes_to_search ;
  char comment[32] ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 291
  currentpos = (unsigned char *)((void *)0);
#line 292
  buf = foundat;
#line 293
  extractbuf = (unsigned char *)((void *)0);
#line 295
  size = 0UL;
#line 296
  file_size = 0;
#line 297
  header = foundat;
#line 298
  bytes_to_search = 0;
#line 301
  foundat += needle->header_len;
#line 302
  currentpos = foundat;
#line 309
  if (buflen >= needle->max_len) {
#line 311
    bytes_to_search = (int )needle->max_len;
  } else {
#line 315
    bytes_to_search = (int )buflen;
  }
#line 319
  if (buflen < 512ULL) {
#line 320
    return ((unsigned char *)((void *)0));
  } else {
    {
#line 323
    currentpos = foundat;
#line 326
    foundat = bm_search(needle->markerlist[1].value, (size_t )needle->markerlist[1].len,
                        foundat, (size_t )100, (size_t *)(needle->markerlist[1].marker_bm_table),
                        needle->case_sen, 0);
    }
#line 334
    if (! foundat) {
#line 339
      return (currentpos + 100);
    }
    {
#line 342
    foundat = currentpos;
#line 345
    foundat = bm_search(needle->markerlist[2].value, (size_t )needle->markerlist[2].len,
                        foundat, (size_t )512, (size_t *)(needle->markerlist[2].marker_bm_table),
                        needle->case_sen, 0);
    }
#line 353
    if (foundat) {
      {
#line 355
      foundat = bm_search(needle->markerlist[0].value, (size_t )needle->markerlist[0].len,
                          foundat, (size_t )512, (size_t *)(needle->markerlist[0].marker_bm_table),
                          needle->case_sen, 0);
      }
    }
  }
#line 371
  if (foundat) {
    {
#line 373
    sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (PDF is Linearized)");
#line 374
    strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 376
    foundat += needle->markerlist[0].len;
#line 377
    tmp = malloc(8UL * sizeof(char ));
#line 377
    tempsize = (unsigned char *)tmp;
#line 378
    tmp___0 = memcpy((void */* __restrict  */)tempsize, (void const   */* __restrict  */)foundat,
                     (size_t )8);
#line 378
    tempsize = (unsigned char *)tmp___0;
#line 379
    tmp___1 = atoi((char const   *)((char *)tempsize));
#line 379
    size = (unsigned long )tmp___1;
#line 381
    free((void *)tempsize);
    }
#line 382
    if (size <= 0UL) {
#line 383
      return (foundat);
    }
#line 384
    if ((unsigned long long )size > buflen) {
#line 386
      if ((unsigned long long )size > needle->max_len) {
#line 387
        return (foundat);
      } else {
#line 389
        return ((unsigned char *)((void *)0));
      }
    }
    {
#line 392
    header += size;
#line 393
    foundat = header;
#line 394
    foundat -= needle->footer_len;
#line 397
    foundat -= 10;
#line 398
    currentpos = foundat;
#line 399
    foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )(needle->footer_len + 9U),
                        (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
    }
#line 406
    if (foundat) {
      {
#line 408
      foundat += needle->footer_len + 1U;
#line 409
      file_size = (int )(foundat - buf);
#line 411
      extractbuf = buf;
#line 412
      write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, c_offset + f_offset);
      }
#line 414
      return (foundat);
    }
#line 417
    return ((unsigned char *)((void *)0));
  } else {
    {
#line 427
    foundat = currentpos;
#line 428
    foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                        (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
    }
#line 436
    if (foundat) {
      {
#line 438
      foundat += needle->footer_len + 1U;
#line 439
      file_size = (int )(foundat - buf);
#line 440
      extractbuf = buf;
#line 442
      write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, c_offset + f_offset);
      }
#line 444
      return (foundat);
    }
#line 448
    return ((unsigned char *)((void *)0));
  }
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_cpp(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *header ;
  unsigned char *buf ;
  unsigned char *extractbuf ;
  int end ;
  int start ;
  int i ;
  int marker_score ;
  int ok ;
  int file_size ;
  unsigned char *footer ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 462
  header = foundat;
#line 463
  buf = foundat;
#line 464
  extractbuf = (unsigned char *)((void *)0);
#line 465
  end = 0;
#line 466
  start = 0;
#line 467
  i = 0;
#line 468
  marker_score = 0;
#line 469
  ok = 0;
#line 470
  file_size = 0;
#line 471
  footer = (unsigned char *)((void *)0);
#line 474
  i = 0;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (i < 20)) {
#line 474
      goto while_break;
    }
#line 476
    if ((int )*(foundat + i) == 34) {
#line 478
      ok = 1;
    } else
#line 476
    if ((int )*(foundat + i) == 60) {
#line 478
      ok = 1;
    }
#line 474
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  if (! ok) {
#line 483
    return (foundat + needle->header_len);
  }
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 486
    tmp = __ctype_b_loc();
    }
#line 486
    if (! ((int const   )*(*tmp + (int )*(foundat + end)) & 16384)) {
#line 486
      if (! ((int )*(foundat + end) == 10)) {
#line 486
        if (! ((int )*(foundat + end) == 9)) {
#line 486
          goto while_break___0;
        }
      }
    }
#line 488
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 491
  foundat += end - 1;
#line 492
  footer = foundat;
#line 494
  if (end < 50) {
#line 495
    return (foundat);
  }
  {
#line 498
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 498
    tmp___0 = __ctype_b_loc();
    }
#line 498
    if (! ((int const   )*(*tmp___0 + (int )*(buf + start)) & 16384)) {
#line 498
      if (! ((int )*(buf + start) == 10)) {
#line 498
        if (! ((int )*(buf + start) == 9)) {
#line 498
          goto while_break___1;
        }
      }
    }
#line 500
    start --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 503
  header = buf + (start + 1);
#line 504
  file_size = (int )(footer - header);
#line 506
  foundat = header;
#line 509
  foundat = bm_search(needle->footer, (size_t )needle->footer_len, header, (size_t )file_size,
                      (size_t *)(needle->footer_bm_table), 0, 0);
  }
#line 516
  if (foundat) {
#line 517
    marker_score ++;
  }
  {
#line 519
  foundat = header;
#line 520
  foundat = bm_search(needle->markerlist[0].value, (size_t )needle->markerlist[0].len,
                      header, (size_t )file_size, (size_t *)(needle->markerlist[0].marker_bm_table),
                      1, 0);
  }
#line 527
  if (foundat) {
#line 528
    marker_score ++;
  }
#line 530
  if (marker_score == 0) {
#line 531
    return (foundat);
  }
#line 533
  if (foundat) {
    {
#line 535
    extractbuf = buf;
#line 536
    write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, ((c_offset + f_offset) + (unsigned long long )start) + 1ULL);
    }
#line 538
    return (footer);
  }
#line 542
  return ((unsigned char *)((void *)0));
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_htm(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned char *currentpos ;
  int bytes_to_search ;
  int i ;
  int file_size ;
  unsigned short const   **tmp ;

  {
#line 554
  buf = foundat;
#line 555
  extractbuf = (unsigned char *)((void *)0);
#line 556
  currentpos = (unsigned char *)((void *)0);
#line 558
  bytes_to_search = 0;
#line 559
  i = 0;
#line 560
  file_size = 0;
#line 563
  foundat += needle->header_len;
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < 16)) {
#line 566
      goto while_break;
    }
    {
#line 568
    tmp = __ctype_b_loc();
    }
#line 568
    if (! ((int const   )*(*tmp + (int )*(foundat + i)) & 16384)) {
#line 568
      if ((int )*(foundat + i) != 10) {
#line 568
        if ((int )*(foundat + i) != 9) {
#line 570
          return (foundat + 16);
        }
      }
    }
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  if (buflen < needle->max_len) {
#line 577
    bytes_to_search = (int )(buflen - (unsigned long long )(foundat - buf));
  } else {
#line 581
    bytes_to_search = (int )needle->max_len;
  }
  {
#line 585
  currentpos = foundat;
#line 586
  foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                      (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
  }
#line 593
  if (foundat) {
    {
#line 595
    file_size = (int )((foundat - buf) + (long )needle->footer_len);
#line 596
    extractbuf = buf;
#line 597
    write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, c_offset + f_offset);
#line 598
    foundat += needle->footer_len;
    }
#line 599
    return (foundat);
  } else {
#line 604
    return ((unsigned char *)((void *)0));
  }
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
int valid_ole_header(struct OLE_HDR *h ) 
{ 
  unsigned short tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
  {
#line 618
  tmp = htos((unsigned char *)(& h->reserved), 1);
  }
#line 618
  if ((int )tmp != 0) {
#line 622
    return (0);
  } else {
    {
#line 618
    tmp___0 = htoi((unsigned char *)(& h->reserved1), 1);
    }
#line 618
    if (tmp___0 != 0U) {
#line 622
      return (0);
    } else {
      {
#line 618
      tmp___1 = htoi((unsigned char *)(& h->reserved2), 1);
      }
#line 618
      if (tmp___1 != 0U) {
#line 622
        return (0);
      }
    }
  }
  {
#line 626
  tmp___2 = htos((unsigned char *)(& h->uMiniSectorShift), 1);
  }
#line 626
  if ((int )tmp___2 != 6) {
#line 630
    return (0);
  } else {
    {
#line 626
    tmp___3 = htos((unsigned char *)(& h->uSectorShift), 1);
    }
#line 626
    if ((int )tmp___3 != 9) {
#line 630
      return (0);
    } else {
      {
#line 626
      tmp___4 = htoi((unsigned char *)(& h->dir_flag), 1);
      }
#line 626
      if (tmp___4 < 0U) {
#line 630
        return (0);
      }
    }
  }
  {
#line 634
  tmp___5 = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
  }
#line 634
  if (tmp___5 <= 0U) {
#line 637
    return (0);
  } else {
    {
#line 634
    tmp___6 = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
    }
#line 634
    if (tmp___6 > 100U) {
#line 637
      return (0);
    }
  }
  {
#line 640
  tmp___7 = htoi((unsigned char *)(& h->num_extra_FAT_blocks), 1);
  }
#line 640
  if (tmp___7 < 0U) {
#line 643
    return (0);
  } else {
    {
#line 640
    tmp___8 = htoi((unsigned char *)(& h->num_extra_FAT_blocks), 1);
    }
#line 640
    if (tmp___8 > 100U) {
#line 643
      return (0);
    }
  }
#line 646
  return (1);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
char *check_ole_name(char *name ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 658
  tmp___7 = strstr((char const   *)name, "WordDocument");
  }
#line 658
  if (tmp___7) {
#line 660
    return ((char *)"doc");
  } else {
    {
#line 662
    tmp___4 = strstr((char const   *)name, "Worksheet");
    }
#line 662
    if (tmp___4) {
#line 664
      return ((char *)"xls");
    } else {
      {
#line 662
      tmp___5 = strstr((char const   *)name, "Book");
      }
#line 662
      if (tmp___5) {
#line 664
        return ((char *)"xls");
      } else {
        {
#line 662
        tmp___6 = strstr((char const   *)name, "Workbook");
        }
#line 662
        if (tmp___6) {
#line 664
          return ((char *)"xls");
        } else {
          {
#line 666
          tmp___3 = strstr((char const   *)name, "Power");
          }
#line 666
          if (tmp___3) {
#line 668
            return ((char *)"ppt");
          } else {
            {
#line 670
            tmp___1 = strstr((char const   *)name, "Access");
            }
#line 670
            if (tmp___1) {
#line 672
              return ((char *)"mbd");
            } else {
              {
#line 670
              tmp___2 = strstr((char const   *)name, "AccessObjSiteData");
              }
#line 670
              if (tmp___2) {
#line 672
                return ((char *)"mbd");
              } else {
                {
#line 674
                tmp___0 = strstr((char const   *)name, "Visio");
                }
#line 674
                if (tmp___0) {
#line 676
                  return ((char *)"vis");
                } else {
                  {
#line 678
                  tmp = strstr((char const   *)name, "Sfx");
                  }
#line 678
                  if (tmp) {
#line 680
                    return ((char *)"sdw");
                  } else {
#line 684
                    return ((char *)((void *)0));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 687
  return ((char *)((void *)0));
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
int adjust_bs(int size , int bs ) 
{ 
  int rem ;

  {
#line 693
  rem = size % bs;
#line 695
  if (rem == 0) {
#line 698
    return (size);
  }
#line 704
  return (size + (bs - rem));
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_ole(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ,
                           char *type ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  char *temp ;
  char *suffix ;
  int totalsize ;
  int extrasize ;
  int oldblk ;
  int i ;
  int j ;
  int size ;
  int blknum ;
  int validblk ;
  int file_size ;
  int num_extra_FAT_blocks ;
  unsigned char *htoi_c ;
  int extra_dir_blocks ;
  int num_FAT_blocks ;
  int next_FAT_block ;
  unsigned char *p ;
  int fib ;
  struct OLE_HDR *h ;
  int result ;
  int highblock ;
  unsigned long miniSectorCutoff ;
  unsigned long csectMiniFat ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;

  {
#line 717
  buf = foundat;
#line 718
  extractbuf = (unsigned char *)((void *)0);
#line 719
  temp = (char *)((void *)0);
#line 720
  suffix = (char *)"ole";
#line 721
  totalsize = 0;
#line 722
  extrasize = 0;
#line 723
  oldblk = 0;
#line 725
  size = 0;
#line 726
  blknum = 0;
#line 727
  validblk = 512;
#line 728
  file_size = 0;
#line 729
  num_extra_FAT_blocks = 0;
#line 730
  htoi_c = (unsigned char *)((void *)0);
#line 731
  extra_dir_blocks = 0;
#line 732
  num_FAT_blocks = 0;
#line 733
  next_FAT_block = 0;
#line 735
  fib = 1024;
#line 736
  h = (struct OLE_HDR *)((void *)0);
#line 738
  result = 0;
#line 739
  highblock = 0;
#line 740
  miniSectorCutoff = 0UL;
#line 741
  csectMiniFat = 0UL;
#line 744
  if ((unsigned long )dirlist != (unsigned long )((void *)0)) {
    {
#line 745
    free((void *)dirlist);
    }
  }
#line 746
  if ((unsigned long )FAT != (unsigned long )((void *)0)) {
    {
#line 747
    free((void *)FAT);
    }
  }
  {
#line 748
  init_ole();
  }
#line 750
  if (buflen < (unsigned long long )validblk) {
#line 751
    validblk = (int )buflen;
  }
  {
#line 752
  h = (struct OLE_HDR *)foundat;
#line 756
  tmp = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
#line 756
  num_FAT_blocks = (int )tmp;
#line 758
  tmp___0 = valid_ole_header(h);
  }
#line 758
  if (! tmp___0) {
#line 759
    return (buf + validblk);
  }
  {
#line 761
  tmp___1 = htoi((unsigned char *)(& h->miniSectorCutoff), 1);
#line 761
  miniSectorCutoff = (unsigned long )tmp___1;
#line 762
  tmp___2 = htoi((unsigned char *)(& h->csectMiniFat), 1);
#line 762
  csectMiniFat = (unsigned long )tmp___2;
#line 763
  tmp___3 = htoi((unsigned char *)(& h->FAT_next_block), 1);
#line 763
  next_FAT_block = (int )tmp___3;
#line 764
  tmp___4 = htoi((unsigned char *)(& h->num_extra_FAT_blocks), 1);
#line 764
  num_extra_FAT_blocks = (int )tmp___4;
#line 766
  tmp___5 = Malloc((size_t )(512 * (num_FAT_blocks + 1)));
#line 766
  FAT = (int *)tmp___5;
#line 767
  p = (unsigned char *)FAT;
#line 768
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(h + 1), (size_t )436);
  }
#line 769
  if (next_FAT_block > 0) {
#line 771
    p += 436;
#line 772
    blknum = next_FAT_block;
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue: /* CIL Label */ ;
#line 773
      if (! (i < num_extra_FAT_blocks)) {
#line 773
        goto while_break;
      }
      {
#line 775
      tmp___6 = get_block(buf, blknum, p, (long long )buflen);
      }
#line 775
      if (! tmp___6) {
#line 776
        return (buf + validblk);
      }
      {
#line 777
      validblk = (blknum + 1) * 512;
#line 778
      p += 512UL - sizeof(int );
#line 779
      tmp___7 = htoi(p, 1);
#line 779
      blknum = (int )tmp___7;
#line 773
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 783
  tmp___8 = htoi((unsigned char *)(& h->root_start_block), 1);
#line 783
  blknum = (int )tmp___8;
  }
#line 785
  if (blknum < 0) {
#line 787
    return (buf + 10);
  }
  {
#line 790
  tmp___9 = htoi((unsigned char *)(& h->dir_flag), 1);
#line 790
  highblock = (int )tmp___9;
#line 796
  tmp___10 = get_block(buf, blknum, buffer, (long long )buflen);
  }
#line 796
  if (! tmp___10) {
#line 797
    return (buf + validblk);
  }
#line 801
  validblk = (blknum + 1) * 512;
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 802
    if (! (blknum != -2)) {
#line 802
      goto while_break___0;
    }
#line 807
    if (extra_dir_blocks > 300) {
#line 808
      return (buf + validblk);
    }
    {
#line 814
    oldblk = blknum;
#line 815
    htoi_c = (unsigned char *)(FAT + (unsigned long )blknum / (512UL / sizeof(int )));
#line 817
    tmp___11 = htoi(htoi_c, 1);
#line 817
    FATblk = (int )tmp___11;
#line 822
    tmp___12 = get_FAT_block(buf, blknum, block_list, (int )buflen);
    }
#line 822
    if (! tmp___12) {
#line 823
      return (buf + validblk);
    }
    {
#line 824
    tmp___13 = htoi((unsigned char *)(& block_list[blknum % 128]), 1);
#line 824
    blknum = (int )tmp___13;
    }
#line 828
    if (blknum == -2) {
#line 833
      goto while_break___0;
    } else
#line 828
    if (oldblk == blknum) {
#line 833
      goto while_break___0;
    }
    {
#line 836
    extra_dir_blocks ++;
#line 837
    result = get_dir_block(buf, blknum, (int )buflen);
    }
#line 838
    if (result == 3) {
#line 843
      goto while_break___0;
    } else
#line 845
    if (! result) {
#line 846
      return (buf + validblk);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 853
  tmp___14 = htoi((unsigned char *)(& h->root_start_block), 1);
#line 853
  blknum = (int )tmp___14;
#line 854
  size = 512 * (extra_dir_blocks + 1);
#line 855
  tmp___15 = Malloc((size_t )size);
#line 855
  dirlist = (struct DIRECTORY *)tmp___15;
#line 856
  memset((void *)dirlist, 0, (size_t )size);
#line 858
  tmp___16 = get_block(buf, blknum, buffer, (long long )buflen);
  }
#line 858
  if (! tmp___16) {
#line 859
    return (buf + validblk);
  }
  {
#line 861
  tmp___17 = get_dir_info(buffer);
  }
#line 861
  if (! tmp___17) {
#line 863
    return (foundat + validblk);
  }
#line 866
  i = 0;
  {
#line 866
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 866
    if (! (i < extra_dir_blocks)) {
#line 866
      goto while_break___1;
    }
    {
#line 868
    tmp___18 = get_FAT_block(buf, blknum, block_list, (int )buflen);
    }
#line 868
    if (! tmp___18) {
#line 869
      return (buf + validblk);
    }
    {
#line 870
    tmp___19 = htoi((unsigned char *)(& block_list[blknum % 128]), 1);
#line 870
    blknum = (int )tmp___19;
    }
#line 871
    if (blknum == -2) {
#line 872
      goto while_break___1;
    }
    {
#line 876
    tmp___20 = get_block(buf, blknum, buffer, (long long )buflen);
    }
#line 876
    if (! tmp___20) {
#line 877
      return (buf + validblk);
    }
    {
#line 878
    tmp___21 = get_dir_info(buffer);
    }
#line 878
    if (! tmp___21) {
#line 880
      return (buf + validblk);
    }
#line 866
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 887
  dl = dirlist;
#line 887
  i = 0;
  {
#line 887
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 887
    if (! (i < dir_count)) {
#line 887
      goto while_break___2;
    }
    {
#line 889
    memset((void *)(buffer), ' ', (size_t )75);
#line 890
    tmp___22 = htoi((unsigned char *)(& dl->level), 1);
#line 890
    j = (int )(tmp___22 * 4U);
#line 891
    sprintf((char */* __restrict  */)((char *)(& buffer[j])), (char const   */* __restrict  */)"%-s",
            dl->name);
#line 892
    tmp___23 = strlen((char const   *)((char *)(buffer)));
#line 892
    j = (int )tmp___23;
    }
#line 894
    if ((int )dl->name[0] == 64) {
#line 895
      return (foundat + validblk);
    }
#line 896
    if (dl->type == 2) {
      {
#line 898
      buffer[j] = (unsigned char )' ';
#line 899
      sprintf((char */* __restrict  */)((char *)(& buffer[60])), (char const   */* __restrict  */)"%8d\n",
              dl->size);
      }
#line 901
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 903
        temp = check_ole_name(dl->name);
        }
#line 904
        if (temp) {
#line 905
          suffix = temp;
        }
      }
#line 908
      if ((unsigned long )dl->size > miniSectorCutoff) {
        {
#line 910
        tmp___24 = adjust_bs(dl->size, 512);
#line 910
        totalsize += tmp___24;
        }
      } else {
        {
#line 914
        tmp___25 = adjust_bs(dl->size, 64);
#line 914
        totalsize += tmp___25;
        }
      }
    } else {
      {
#line 923
      sprintf((char */* __restrict  */)((char *)(& buffer[j])), (char const   */* __restrict  */)"\n");
#line 929
      tmp___26 = adjust_bs(dl->size, 512);
#line 929
      extrasize += tmp___26;
      }
    }
#line 887
    i ++;
#line 887
    dl ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 934
  totalsize += fib;
#line 941
  tmp___27 = adjust_bs(dir_count * 128, 512);
#line 941
  totalsize += tmp___27;
#line 942
  totalsize += num_FAT_blocks * 512;
#line 943
  tmp___28 = adjust_bs((int )(64UL * csectMiniFat), 512);
#line 943
  totalsize += tmp___28;
  }
#line 944
  if (highblk + 5 > highblock) {
#line 944
    if (highblk > 0) {
#line 946
      highblock = highblk + 5;
    }
  }
#line 949
  highblock *= 512;
#line 954
  if (highblock > totalsize) {
#line 961
    totalsize = highblock;
  }
  {
#line 964
  totalsize = adjust_bs(totalsize, 512);
  }
#line 970
  if (buflen < (unsigned long long )totalsize) {
#line 977
    totalsize = (int )buflen;
  }
#line 980
  foundat = buf;
#line 981
  highblock -= 2560;
#line 982
  if (highblock > 0) {
#line 982
    if ((unsigned long long )highblock < buflen) {
#line 984
      foundat += highblock;
    } else {
#line 988
      foundat += totalsize;
    }
  } else {
#line 988
    foundat += totalsize;
  }
#line 992
  file_size = totalsize;
#line 993
  extractbuf = buf;
#line 995
  if (suffix) {
#line 996
    needle->suffix = suffix;
  }
  {
#line 998
  tmp___29 = strstr((char const   *)needle->suffix, (char const   *)type);
  }
#line 998
  if (! tmp___29) {
    {
#line 998
    tmp___30 = strcmp((char const   *)type, "all");
    }
#line 998
    if (tmp___30 != 0) {
#line 1000
      return (foundat);
    }
  }
  {
#line 1003
  write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, c_offset + f_offset);
  }
#line 1004
  return (foundat);
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
int check_mov(unsigned char *atom ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1014
  tmp = strncmp((char const   *)((char *)atom), "free", (size_t )4);
  }
#line 1014
  if (tmp == 0) {
#line 1018
    return (1);
  } else {
    {
#line 1014
    tmp___0 = strncmp((char const   *)((char *)atom), "mdat", (size_t )4);
    }
#line 1014
    if (tmp___0 == 0) {
#line 1018
      return (1);
    } else {
      {
#line 1014
      tmp___1 = strncmp((char const   *)((char *)atom), "free", (size_t )4);
      }
#line 1014
      if (tmp___1 == 0) {
#line 1018
        return (1);
      } else {
        {
#line 1014
        tmp___2 = strncmp((char const   *)((char *)atom), "wide", (size_t )4);
        }
#line 1014
        if (tmp___2 == 0) {
#line 1018
          return (1);
        } else {
          {
#line 1014
          tmp___3 = strncmp((char const   *)((char *)atom), "PICT", (size_t )4);
          }
#line 1014
          if (tmp___3 == 0) {
#line 1018
            return (1);
          }
        }
      }
    }
  }
  {
#line 1021
  tmp___4 = strncmp((char const   *)((char *)atom), "trak", (size_t )4);
  }
#line 1021
  if (tmp___4 == 0) {
#line 1025
    return (1);
  } else {
    {
#line 1021
    tmp___5 = strncmp((char const   *)((char *)atom), "mdat", (size_t )4);
    }
#line 1021
    if (tmp___5 == 0) {
#line 1025
      return (1);
    } else {
      {
#line 1021
      tmp___6 = strncmp((char const   *)((char *)atom), "mp3", (size_t )3);
      }
#line 1021
      if (tmp___6 == 0) {
#line 1025
        return (1);
      } else {
        {
#line 1021
        tmp___7 = strncmp((char const   *)((char *)atom), "wide", (size_t )4);
        }
#line 1021
        if (tmp___7 == 0) {
#line 1025
          return (1);
        } else {
          {
#line 1021
          tmp___8 = strncmp((char const   *)((char *)atom), "moov", (size_t )4);
          }
#line 1021
          if (tmp___8 == 0) {
#line 1025
            return (1);
          }
        }
      }
    }
  }
#line 1028
  return (0);
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_mov(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned int atomsize ;
  unsigned int filesize ;
  int mdat ;
  int tmp ;
  int tmp___0 ;

  {
#line 1040
  buf = foundat - 4;
#line 1041
  extractbuf = (unsigned char *)((void *)0);
#line 1042
  atomsize = 0U;
#line 1043
  filesize = 0U;
#line 1044
  mdat = 0;
#line 1045
  foundat -= 4;
#line 1046
  buflen += 4ULL;
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1049
    atomsize = htoi(foundat, 0);
    }
#line 1053
    if (atomsize <= 0U) {
#line 1055
      return ((foundat + needle->header_len) + 4);
    } else
#line 1053
    if ((unsigned long long )atomsize > needle->max_len) {
#line 1055
      return ((foundat + needle->header_len) + 4);
    }
#line 1058
    filesize += atomsize;
#line 1059
    if ((unsigned long long )filesize > buflen) {
#line 1064
      if (buflen >= needle->max_len) {
#line 1065
        return ((foundat + needle->header_len) + 4);
      } else {
#line 1068
        return ((unsigned char *)((void *)0));
      }
    }
#line 1072
    foundat += atomsize;
#line 1073
    if (buflen - (unsigned long long )(foundat - buf) < 5ULL) {
#line 1075
      if (mdat) {
#line 1077
        goto while_break;
      } else {
#line 1084
        return (foundat);
      }
    }
    {
#line 1090
    tmp = strncmp((char const   *)((char *)foundat + 4), "mdat", (size_t )4);
    }
#line 1090
    if (tmp == 0) {
#line 1092
      mdat = 1;
    }
    {
#line 1095
    tmp___0 = check_mov(foundat + 4);
    }
#line 1095
    if (! tmp___0) {
#line 1106
      if (mdat) {
#line 1108
        goto while_break;
      } else {
#line 1115
        return (foundat);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1121
  if (foundat) {
    {
#line 1124
    filesize = (unsigned int )(foundat - buf);
#line 1128
    extractbuf = buf;
#line 1129
    write_to_disk(s, needle, (unsigned long long )filesize, extractbuf, (c_offset + f_offset) - 4ULL);
    }
#line 1130
    return (foundat);
  }
#line 1136
  return ((unsigned char *)((void *)0));
}
}
#line 1146 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_wmv(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *currentpos ;
  unsigned char *header ;
  unsigned char *extractbuf ;
  unsigned char *buf ;
  unsigned int size ;
  unsigned long long file_size ;
  unsigned long long headerSize ;
  unsigned long long fileObjHeaderSize ;
  int numberofHeaderObjects ;
  int reserved[2] ;
  int bytes_to_search ;
  unsigned int tmp ;

  {
#line 1150
  currentpos = (unsigned char *)((void *)0);
#line 1151
  header = foundat;
#line 1152
  extractbuf = (unsigned char *)((void *)0);
#line 1153
  buf = foundat;
#line 1154
  size = 0U;
#line 1155
  file_size = 0ULL;
#line 1156
  headerSize = 0ULL;
#line 1157
  fileObjHeaderSize = 0ULL;
#line 1158
  numberofHeaderObjects = 0;
#line 1160
  bytes_to_search = 0;
#line 1163
  if (buflen < 70ULL) {
#line 1164
    return ((unsigned char *)((void *)0));
  }
  {
#line 1166
  foundat += 16;
#line 1167
  headerSize = htoll(foundat, 1);
#line 1169
  foundat += 8;
#line 1170
  tmp = htoi(foundat, 1);
#line 1170
  numberofHeaderObjects = (int )tmp;
#line 1171
  foundat += 4;
#line 1172
  reserved[0] = (int )*(foundat + 0);
#line 1173
  reserved[1] = (int )*(foundat + 1);
#line 1174
  foundat += 2;
  }
#line 1181
  if (headerSize <= 0ULL) {
    {
#line 1183
    printf((char const   */* __restrict  */)"WMV err num_header_objs=%d headerSize=%llu\n",
           numberofHeaderObjects, headerSize);
    }
#line 1184
    return (foundat);
  } else
#line 1181
  if (numberofHeaderObjects <= 0) {
    {
#line 1183
    printf((char const   */* __restrict  */)"WMV err num_header_objs=%d headerSize=%llu\n",
           numberofHeaderObjects, headerSize);
    }
#line 1184
    return (foundat);
  } else
#line 1181
  if (reserved[0] != 1) {
    {
#line 1183
    printf((char const   */* __restrict  */)"WMV err num_header_objs=%d headerSize=%llu\n",
           numberofHeaderObjects, headerSize);
    }
#line 1184
    return (foundat);
  }
#line 1187
  currentpos = foundat;
#line 1188
  if (buflen - (unsigned long long )(foundat - buf) >= needle->max_len) {
#line 1189
    bytes_to_search = (int )needle->max_len;
  } else {
#line 1191
    bytes_to_search = (int )(buflen - (unsigned long long )(foundat - buf));
  }
  {
#line 1194
  foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                      (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
  }
#line 1201
  if (foundat) {
    {
#line 1203
    foundat += 16;
#line 1204
    fileObjHeaderSize = htoll(foundat, 1);
#line 1206
    foundat += 24;
#line 1207
    size = htoi(foundat, 1);
    }
  } else {
#line 1216
    return ((unsigned char *)((void *)0));
  }
#line 1220
  if (size > 0U) {
#line 1220
    if ((unsigned long long )size <= needle->max_len) {
#line 1220
      if ((unsigned long long )size <= buflen) {
        {
#line 1222
        header += size;
#line 1233
        file_size = (unsigned long long )(header - buf);
#line 1234
        extractbuf = buf;
#line 1235
        write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1236
        foundat += file_size;
        }
#line 1237
        return (header);
      }
    }
  }
#line 1240
  return ((unsigned char *)((void *)0));
}
}
#line 1249 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_riff(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                            unsigned long long buflen , s_spec *needle , unsigned long long f_offset ,
                            char *type ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  int size ;
  unsigned long long file_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1252
  buf = foundat;
#line 1253
  extractbuf = (unsigned char *)((void *)0);
#line 1254
  size = 0;
#line 1255
  file_size = 0ULL;
#line 1257
  tmp = htoi(foundat + 4, 1);
#line 1257
  size = (int )tmp;
#line 1258
  tmp___6 = strncmp((char const   *)((char *)(foundat + 8)), "AVI", (size_t )3);
  }
#line 1258
  if (tmp___6 == 0) {
    {
#line 1260
    tmp___2 = strncmp((char const   *)((char *)(foundat + 12)), "LIST", (size_t )4);
    }
#line 1260
    if (tmp___2 == 0) {
#line 1262
      if (size > 0) {
#line 1262
        if ((unsigned long long )size <= needle->max_len) {
#line 1262
          if ((unsigned long long )size <= buflen) {
            {
#line 1267
            file_size = (unsigned long long )size;
#line 1268
            extractbuf = buf;
#line 1269
            needle->suffix = (char *)"avi";
#line 1270
            tmp___0 = strstr((char const   *)needle->suffix, (char const   *)type);
            }
#line 1270
            if (! tmp___0) {
              {
#line 1270
              tmp___1 = strcmp((char const   *)type, "all");
              }
#line 1270
              if (tmp___1 != 0) {
#line 1271
                return (foundat + size);
              }
            }
            {
#line 1272
            write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1273
            foundat += size;
            }
#line 1274
            return (foundat);
          }
        }
      }
#line 1277
      return (buf + needle->header_len);
    } else {
#line 1282
      return (buf + needle->header_len);
    }
  } else {
    {
#line 1285
    tmp___5 = strncmp((char const   *)((char *)(foundat + 8)), "WAVE", (size_t )4);
    }
#line 1285
    if (tmp___5 == 0) {
#line 1287
      if (size > 0) {
#line 1287
        if ((unsigned long long )size <= needle->max_len) {
#line 1287
          if ((unsigned long long )size <= buflen) {
            {
#line 1293
            file_size = (unsigned long long )size;
#line 1294
            extractbuf = buf;
#line 1295
            needle->suffix = (char *)"wav";
#line 1296
            tmp___3 = strstr((char const   *)needle->suffix, (char const   *)type);
            }
#line 1296
            if (! tmp___3) {
              {
#line 1296
              tmp___4 = strcmp((char const   *)type, "all");
              }
#line 1296
              if (tmp___4 != 0) {
#line 1297
                return (foundat + size);
              }
            }
            {
#line 1299
            write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1300
            foundat += file_size;
            }
#line 1301
            return (foundat);
          }
        }
      }
#line 1304
      return (buf + needle->header_len);
    } else {
#line 1309
      return (buf + needle->header_len);
    }
  }
#line 1312
  return ((unsigned char *)((void *)0));
}
}
#line 1321 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_bmp(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  int size ;
  int headerlength ;
  int v_size ;
  int h_size ;
  unsigned char *extractbuf ;
  unsigned long long file_size ;
  char comment[32] ;
  int dataOffset ;
  int dataSize ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1324
  buf = foundat;
#line 1325
  size = 0;
#line 1326
  headerlength = 0;
#line 1327
  v_size = 0;
#line 1328
  h_size = 0;
#line 1329
  extractbuf = (unsigned char *)((void *)0);
#line 1330
  file_size = 0ULL;
#line 1332
  dataOffset = 0;
#line 1333
  dataSize = 0;
#line 1335
  if (buflen < 100ULL) {
#line 1336
    return (buf + needle->header_len);
  }
  {
#line 1339
  tmp = htoi(foundat + 2, 1);
#line 1339
  size = (int )tmp;
  }
#line 1342
  if (size <= 100) {
#line 1343
    return (buf + needle->header_len);
  } else
#line 1342
  if ((unsigned long long )size > needle->max_len) {
#line 1343
    return (buf + needle->header_len);
  }
  {
#line 1345
  tmp___0 = htoi(foundat + 10, 1);
#line 1345
  dataOffset = (int )tmp___0;
#line 1346
  tmp___1 = htoi(foundat + 34, 1);
#line 1346
  dataSize = (int )tmp___1;
#line 1348
  tmp___2 = htoi(foundat + 14, 1);
#line 1348
  headerlength = (int )tmp___2;
  }
#line 1357
  if (headerlength > 1000) {
#line 1358
    return (buf + needle->header_len);
  } else
#line 1357
  if (headerlength <= 0) {
#line 1358
    return (buf + needle->header_len);
  }
  {
#line 1361
  tmp___3 = htoi(foundat + 22, 1);
#line 1361
  v_size = (int )tmp___3;
#line 1362
  tmp___4 = htoi(foundat + 18, 1);
#line 1362
  h_size = (int )tmp___4;
  }
#line 1365
  if (v_size <= 0) {
#line 1366
    return (buf + needle->header_len);
  } else
#line 1365
  if (v_size > 2000) {
#line 1366
    return (buf + needle->header_len);
  } else
#line 1365
  if (h_size <= 0) {
#line 1366
    return (buf + needle->header_len);
  }
#line 1376
  if ((unsigned long long )size <= buflen) {
    {
#line 1379
    sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (%d x %d)",
            h_size, v_size);
#line 1380
    strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 1382
    file_size = (unsigned long long )size;
#line 1383
    extractbuf = buf;
#line 1385
    write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1386
    foundat += file_size;
    }
#line 1387
    return (foundat);
  }
#line 1391
  return ((unsigned char *)((void *)0));
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_gif(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *currentpos ;
  unsigned char *extractbuf ;
  int bytes_to_search ;
  unsigned short width ;
  unsigned short height ;
  unsigned long long file_size ;
  char comment[32] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1403
  buf = foundat;
#line 1404
  currentpos = foundat;
#line 1405
  extractbuf = (unsigned char *)((void *)0);
#line 1406
  bytes_to_search = 0;
#line 1407
  width = (unsigned short)0;
#line 1408
  height = (unsigned short)0;
#line 1409
  file_size = 0ULL;
#line 1411
  foundat += 4;
#line 1414
  tmp = strncmp((char const   *)((char *)foundat), "9a", (size_t )2);
  }
#line 1414
  if (tmp == 0) {
#line 1414
    goto _L;
  } else {
    {
#line 1414
    tmp___0 = strncmp((char const   *)((char *)foundat), "7a", (size_t )2);
    }
#line 1414
    if (tmp___0 == 0) {
      _L: /* CIL Label */ 
      {
#line 1416
      foundat += 2;
#line 1417
      width = htos(foundat, 1);
#line 1418
      height = htos(foundat + 2, 1);
#line 1420
      sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (%d x %d)",
              (int )width, (int )height);
#line 1421
      strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 1423
      currentpos = foundat;
      }
#line 1424
      if (buflen - (unsigned long long )(foundat - buf) >= needle->max_len) {
#line 1425
        bytes_to_search = (int )needle->max_len;
      } else {
#line 1427
        bytes_to_search = (int )(buflen - (unsigned long long )(foundat - buf));
      }
      {
#line 1428
      foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                          (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
      }
#line 1435
      if (foundat) {
        {
#line 1442
        file_size = (unsigned long long )((foundat - buf) + (long )needle->footer_len);
#line 1446
        extractbuf = buf;
#line 1447
        write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1448
        foundat += needle->footer_len;
        }
#line 1449
        return (foundat);
      }
#line 1452
      return ((unsigned char *)((void *)0));
    } else {
#line 1457
      return (foundat);
    }
  }
}
}
#line 1466 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_mpg(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *currentpos ;
  unsigned char *extractbuf ;
  int bytes_to_search ;
  unsigned short size ;
  unsigned long long file_size ;
  int j ;

  {
#line 1469
  buf = foundat;
#line 1470
  currentpos = (unsigned char *)((void *)0);
#line 1472
  extractbuf = (unsigned char *)((void *)0);
#line 1473
  bytes_to_search = 0;
#line 1474
  size = (unsigned short)0;
#line 1475
  file_size = 0ULL;
#line 1484
  j = 0;
#line 1485
  if (! ((int )*(foundat + 15) == 187)) {
#line 1491
    return (buf + needle->header_len);
  }
#line 1494
  if (buflen <= 2048ULL) {
#line 1496
    bytes_to_search = (int )buflen;
  } else {
#line 1500
    bytes_to_search = 2048;
  }
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1505
    j = 0;
#line 1506
    currentpos = foundat;
#line 1510
    foundat = bm_search(needle->markerlist[0].value, (size_t )needle->markerlist[0].len,
                        foundat, (size_t )bytes_to_search, (size_t *)(needle->markerlist[0].marker_bm_table),
                        needle->case_sen, 0);
    }
#line 1518
    if (foundat) {
      {
#line 1523
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1526
        if ((int )*(foundat + 3) >= 187) {
#line 1526
          if ((int )*(foundat + 3) <= 239) {
            {
#line 1531
            size = htos(foundat + 4, 0);
#line 1537
            file_size += (unsigned long long )((foundat - buf) + (long )size);
            }
#line 1538
            if ((int )size <= 0) {
#line 1538
              goto _L;
            } else
#line 1538
            if ((unsigned long long )size > buflen - (unsigned long long )(foundat - buf)) {
              _L: /* CIL Label */ 
#line 1543
              if ((int )size <= 51200) {
#line 1543
                if ((int )size > 0) {
#line 1547
                  if (file_size < needle->max_len) {
#line 1549
                    return ((unsigned char *)((void *)0));
                  } else {
#line 1553
                    goto while_break___0;
                  }
                } else {
#line 1558
                  return (currentpos + needle->header_len);
                }
              } else {
#line 1558
                return (currentpos + needle->header_len);
              }
            }
#line 1562
            foundat += (int )size + 6;
#line 1566
            j ++;
          } else {
#line 1571
            goto while_break___0;
          }
        } else {
#line 1571
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1575
      if ((int )*(foundat + 3) == 185) {
#line 1577
        goto while_break;
      } else
#line 1579
      if ((int )*(foundat + 3) != 186) {
#line 1579
        if ((int )*(foundat + 3) != 0) {
          {
#line 1583
          size = htos(foundat + 4, 0);
          }
#line 1590
          if (currentpos - buf >= 1048576L) {
#line 1592
            foundat = currentpos;
#line 1593
            goto while_break;
          }
#line 1596
          return (currentpos + needle->header_len);
        } else {
#line 1579
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1599
      if ((int )*(foundat + 3) == 179) {
#line 1601
        foundat += 3;
      } else {
#line 1605
        foundat += 3;
      }
    } else
#line 1610
    if (currentpos - buf >= 1048576L) {
#line 1612
      foundat = currentpos;
#line 1613
      goto while_break;
    } else {
#line 1620
      return (buf + needle->header_len);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1625
  if (foundat) {
#line 1627
    file_size = (unsigned long long )((foundat - buf) + (long )needle->footer_len);
#line 1628
    if (file_size < 1024ULL) {
#line 1629
      return (buf + needle->header_len);
    }
  } else {
#line 1633
    return (buf + needle->header_len);
  }
#line 1636
  if (file_size > buflen) {
#line 1637
    file_size = buflen;
  }
  {
#line 1638
  foundat = buf;
#line 1643
  extractbuf = buf;
#line 1644
  write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1645
  foundat += file_size;
  }
#line 1646
  return (foundat);
}
}
#line 1654 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_mp4(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned int size ;
  unsigned long long file_size ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1657
  buf = foundat;
#line 1659
  extractbuf = (unsigned char *)((void *)0);
#line 1660
  size = 0U;
#line 1661
  file_size = 0ULL;
  {
#line 1664
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1666
    size = htoi(foundat + 28, 0);
    }
#line 1667
    if (size == 0U) {
#line 1670
      foundat += 28;
#line 1671
      goto while_break;
    }
#line 1674
    if (size > 0U) {
#line 1674
      if ((unsigned long long )size < buflen) {
        {
#line 1676
        tmp = __ctype_b_loc();
        }
#line 1676
        if ((int const   )*(*tmp + (int )*(foundat + 32)) & 16384) {
          {
#line 1676
          tmp___0 = __ctype_b_loc();
          }
#line 1676
          if (! ((int const   )*(*tmp___0 + (int )*(foundat + 33)) & 16384)) {
#line 1679
            goto while_break;
          }
        } else {
#line 1679
          goto while_break;
        }
#line 1682
        foundat += size;
      } else {
#line 1674
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1687
    if ((unsigned long long )size < needle->max_len) {
#line 1690
      return ((unsigned char *)((void *)0));
    } else {
#line 1696
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1703
  if (foundat) {
#line 1705
    file_size = (unsigned long long )((foundat - buf) + (long )needle->footer_len);
#line 1706
    if (file_size < 1024ULL) {
#line 1707
      return (buf + needle->header_len);
    }
  }
#line 1711
  if (file_size > buflen) {
#line 1712
    file_size = buflen;
  }
  {
#line 1713
  foundat = buf;
#line 1716
  extractbuf = buf;
#line 1717
  write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1718
  foundat += file_size;
  }
#line 1719
  return (foundat);
}
}
#line 1729 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_png(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *currentpos ;
  unsigned char *extractbuf ;
  int size ;
  int height ;
  int width ;
  unsigned long long file_size ;
  char comment[32] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1732
  buf = foundat;
#line 1733
  currentpos = (unsigned char *)((void *)0);
#line 1735
  extractbuf = (unsigned char *)((void *)0);
#line 1736
  size = 0;
#line 1737
  height = 0;
#line 1738
  width = 0;
#line 1739
  file_size = 0ULL;
#line 1742
  if (buflen < 100ULL) {
#line 1743
    return ((unsigned char *)((void *)0));
  }
  {
#line 1744
  foundat += 8;
#line 1745
  tmp = htoi(foundat + 8, 0);
#line 1745
  width = (int )tmp;
#line 1746
  tmp___0 = htoi(foundat + 12, 0);
#line 1746
  height = (int )tmp___0;
  }
#line 1748
  if (width < 1) {
#line 1749
    return (foundat);
  } else
#line 1748
  if (height < 1) {
#line 1749
    return (foundat);
  }
#line 1751
  if (width > 3000) {
#line 1752
    return (foundat);
  } else
#line 1751
  if (height > 3000) {
#line 1752
    return (foundat);
  }
  {
#line 1754
  sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" (%d x %d)",
          width, height);
#line 1755
  strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
  }
  {
#line 1757
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1759
    tmp___1 = htoi(foundat, 0);
#line 1759
    size = (int )tmp___1;
#line 1765
    currentpos = foundat;
    }
#line 1766
    if (size <= 0) {
#line 1771
      return (currentpos);
    } else
#line 1766
    if ((unsigned long long )size > buflen - (unsigned long long )(foundat - buf)) {
#line 1771
      return (currentpos);
    }
    {
#line 1775
    foundat += size + 12;
#line 1777
    tmp___3 = __ctype_b_loc();
    }
#line 1777
    if ((int const   )*(*tmp___3 + (int )*(foundat + 4)) & 16384) {
      {
#line 1779
      tmp___2 = strncmp((char const   *)((char *)(foundat + 4)), "IEND", (size_t )4);
      }
#line 1779
      if (tmp___2 == 0) {
#line 1781
        goto while_break;
      }
    } else {
#line 1790
      return (currentpos);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1795
  if (foundat) {
    {
#line 1797
    tmp___4 = htoi(foundat, 0);
#line 1797
    file_size = (unsigned long long )(((foundat - buf) + (long )tmp___4) + 12L);
    }
#line 1799
    if (file_size > buflen) {
#line 1800
      file_size = buflen;
    }
    {
#line 1801
    foundat = buf;
#line 1805
    extractbuf = buf;
#line 1806
    write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1807
    foundat += file_size;
    }
#line 1808
    return (foundat);
  }
#line 1811
  return ((unsigned char *)((void *)0));
}
}
#line 1820 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_jpeg(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                            unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *currentpos ;
  unsigned char *extractbuf ;
  unsigned short headersize ;
  int bytes_to_search ;
  int hasTable ;
  int hasHuffman ;
  unsigned long long file_size ;

  {
#line 1823
  buf = foundat;
#line 1824
  currentpos = (unsigned char *)((void *)0);
#line 1826
  extractbuf = (unsigned char *)((void *)0);
#line 1828
  bytes_to_search = 0;
#line 1829
  hasTable = 0;
#line 1830
  hasHuffman = 0;
#line 1831
  file_size = 0ULL;
#line 1836
  if (buflen < 128ULL) {
#line 1838
    return ((unsigned char *)((void *)0));
  }
#line 1841
  if (! ((int )*(foundat + 3) == 224)) {
#line 1848
    if (! ((int )*(foundat + 3) == 225)) {
#line 1855
      return (foundat + needle->header_len);
    }
  }
  {
#line 1856
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1861
    foundat += 2;
#line 1862
    headersize = htos(foundat + 2, 0);
    }
#line 1868
    if ((unsigned long long )((foundat + (int )headersize) - buf) > buflen) {
#line 1868
      return ((unsigned char *)((void *)0));
    }
#line 1870
    foundat += (int )headersize;
#line 1872
    if ((int )*(foundat + 2) != 255) {
#line 1874
      goto while_break;
    }
#line 1878
    if ((int )*(foundat + 2) == 255) {
#line 1878
      if ((int )*(foundat + 3) == 255) {
#line 1880
        foundat ++;
      }
    }
#line 1883
    if ((int )*(foundat + 3) == 219) {
#line 1885
      hasTable = 1;
    } else
#line 1883
    if ((int )*(foundat + 4) == 219) {
#line 1885
      hasTable = 1;
    } else
#line 1887
    if ((int )*(foundat + 3) == 196) {
#line 1889
      hasHuffman = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1894
  if (! hasTable) {
#line 1899
    return (buf + needle->header_len);
  } else
#line 1894
  if (! hasHuffman) {
#line 1899
    return (buf + needle->header_len);
  }
#line 1902
  currentpos = foundat;
#line 1905
  if (buflen < (unsigned long long )(foundat - buf)) {
#line 1909
    bytes_to_search = 0;
  } else
#line 1911
  if (buflen - (unsigned long long )(foundat - buf) >= needle->max_len) {
#line 1912
    bytes_to_search = (int )needle->max_len;
  } else {
#line 1914
    bytes_to_search = (int )(buflen - (unsigned long long )(foundat - buf));
  }
  {
#line 1917
  foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                      (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
  }
#line 1925
  if (foundat) {
    {
#line 1929
    file_size = (unsigned long long )((foundat - buf) + (long )needle->footer_len);
#line 1936
    extractbuf = buf;
#line 1937
    write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 1938
    foundat += needle->footer_len;
    }
#line 1941
    return (foundat);
  } else {
#line 1945
    return ((unsigned char *)((void *)0));
  }
}
}
#line 1955 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_generic(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                               unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *endptr ;
  unsigned char *beginptr ;
  unsigned char *extractbuf ;
  int bytes_to_search ;
  unsigned long long file_size ;
  int begin ;
  int end ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
#line 1958
  buf = foundat;
#line 1959
  endptr = foundat;
#line 1960
  beginptr = foundat;
#line 1961
  extractbuf = (unsigned char *)((void *)0);
#line 1962
  bytes_to_search = 0;
#line 1963
  file_size = 0ULL;
#line 1964
  begin = 0;
#line 1965
  end = 0;
#line 1968
  if (buflen - (unsigned long long )(foundat - buf) >= needle->max_len) {
#line 1969
    bytes_to_search = (int )needle->max_len;
  } else {
#line 1971
    bytes_to_search = (int )(buflen - (unsigned long long )(foundat - buf));
  }
#line 1973
  if (needle->searchtype == 2) {
    {
#line 1975
    foundat += needle->header_len;
#line 1976
    foundat = bm_search(needle->header, (size_t )needle->header_len, foundat, (size_t )bytes_to_search,
                        (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
    }
  } else
#line 1984
  if (needle->searchtype == 3) {
    {
#line 1988
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1988
      tmp = __ctype_b_loc();
      }
#line 1988
      if (! ((int const   )*(*tmp + (int )*(foundat + end)) & 16384)) {
#line 1988
        if (! ((int )*(foundat + end) == 10)) {
#line 1988
          if (! ((int )*(foundat + end) == 13)) {
#line 1988
            if (! ((int )*(foundat + end) == 9)) {
#line 1988
              goto while_break;
            }
          }
        }
      }
#line 1990
      end ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1993
    foundat += end;
#line 1994
    endptr = foundat;
#line 1995
    foundat = buf;
    {
#line 1997
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1997
      tmp___0 = __ctype_b_loc();
      }
#line 1997
      if (! ((int const   )*(*tmp___0 + (int )*(foundat + (begin - 1))) & 16384)) {
#line 1997
        if (! ((int )*(foundat + (begin - 1)) == 10)) {
#line 1997
          if (! ((int )*(foundat + (begin - 1)) == 13)) {
#line 1997
            if (! ((int )*(foundat + (begin - 1)) == 9)) {
#line 1997
              goto while_break___0;
            }
          }
        }
      }
#line 1999
      begin --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2002
    foundat += begin;
#line 2003
    beginptr = foundat;
#line 2005
    buf = beginptr;
#line 2006
    foundat = endptr;
#line 2009
    file_size = (unsigned long long )(end - begin);
#line 2011
    if ((unsigned long )buf == (unsigned long )foundat) {
      {
#line 2013
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Returning Foundat\n");
      }
#line 2014
      return (foundat + needle->header_len);
    }
  } else
#line 2017
  if ((unsigned long )needle->footer == (unsigned long )((void *)0)) {
#line 2022
    foundat = (unsigned char *)((void *)0);
  } else {
    {
#line 2017
    tmp___1 = strlen((char const   *)((char *)needle->footer));
    }
#line 2017
    if (tmp___1 < 1UL) {
#line 2022
      foundat = (unsigned char *)((void *)0);
    } else {
      {
#line 2029
      foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                          (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
      }
    }
  }
#line 2038
  if (foundat) {
#line 2043
    if (needle->searchtype == 2) {
#line 2045
      file_size = (unsigned long long )(foundat - buf);
    } else
#line 2043
    if (needle->searchtype == 3) {
#line 2045
      file_size = (unsigned long long )(foundat - buf);
    } else {
#line 2049
      file_size = (unsigned long long )((foundat - buf) + (long )needle->footer_len);
    }
  } else {
#line 2054
    file_size = needle->max_len;
  }
#line 2057
  if (file_size == 0ULL) {
#line 2059
    file_size = needle->max_len;
  }
#line 2062
  if (file_size > buflen - (unsigned long long )begin) {
#line 2064
    file_size = buflen;
  }
  {
#line 2071
  extractbuf = buf;
#line 2072
  write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
  }
#line 2074
  if (needle->searchtype != 3) {
#line 2076
    foundat = buf;
#line 2077
    foundat += needle->header_len;
  }
#line 2079
  return (foundat);
}
}
#line 2090 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_exe(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned long long file_size ;
  unsigned short pe_offset ;
  unsigned int SizeOfCode ;
  unsigned int SizeOfInitializedData ;
  unsigned int SizeOfUninitializedData ;
  unsigned int rva ;
  unsigned int offset ;
  unsigned short sections ;
  unsigned int sizeofimage ;
  unsigned int raw_section_size ;
  unsigned int size_of_headers ;
  unsigned short dll ;
  unsigned int sum ;
  unsigned short exe_char ;
  unsigned int align ;
  int i ;
  time_t compile_time ;
  struct tm *ret_time ;
  char comment[32] ;
  char ascii_time[32] ;
  unsigned int tmp ;

  {
#line 2093
  buf = foundat;
#line 2094
  extractbuf = (unsigned char *)((void *)0);
#line 2095
  file_size = 0ULL;
#line 2096
  pe_offset = (unsigned short)0;
#line 2097
  SizeOfCode = 0U;
#line 2098
  SizeOfInitializedData = 0U;
#line 2099
  SizeOfUninitializedData = 0U;
#line 2100
  rva = 0U;
#line 2101
  offset = 0U;
#line 2102
  sections = (unsigned short)0;
#line 2103
  sizeofimage = 0U;
#line 2104
  raw_section_size = 0U;
#line 2105
  size_of_headers = 0U;
#line 2106
  dll = (unsigned short)0;
#line 2107
  sum = 0U;
#line 2108
  exe_char = (unsigned short)0;
#line 2109
  align = 0U;
#line 2110
  i = 0;
#line 2111
  compile_time = (time_t )0;
#line 2116
  if (buflen < 100ULL) {
#line 2117
    return (foundat + 2);
  }
  {
#line 2118
  pe_offset = htos(foundat + 60, 1);
  }
#line 2119
  if ((int )pe_offset < 1) {
#line 2121
    return (foundat + 60);
  } else
#line 2119
  if ((int )pe_offset > 1000) {
#line 2121
    return (foundat + 60);
  } else
#line 2119
  if ((unsigned long long )pe_offset > buflen) {
#line 2121
    return (foundat + 60);
  }
#line 2124
  foundat += (int )pe_offset;
#line 2125
  if ((int )*(foundat + 0) != 80) {
#line 2127
    return (foundat);
  } else
#line 2125
  if ((int )*(foundat + 1) != 69) {
#line 2127
    return (foundat);
  }
  {
#line 2130
  sections = htos(foundat + 6, 1);
  }
#line 2131
  if (buflen < (unsigned long long )(40 * (int )sections + 224)) {
#line 2133
    return (foundat);
  }
  {
#line 2136
  tmp = htoi(foundat + 8, 1);
#line 2136
  compile_time = (time_t )tmp;
#line 2137
  ret_time = gmtime((time_t const   *)(& compile_time));
#line 2138
  sprintf((char */* __restrict  */)(ascii_time), (char const   */* __restrict  */)"%02d/%02d/%04d %02d:%02d:%02d",
          ret_time->tm_mon + 1, ret_time->tm_mday, ret_time->tm_year + 1900, ret_time->tm_hour,
          ret_time->tm_min, ret_time->tm_sec);
#line 2146
  chop(ascii_time);
#line 2148
  sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)(ascii_time));
#line 2149
  strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 2150
  exe_char = htos(foundat + 22, 1);
  }
#line 2151
  if ((int )exe_char & 8192) {
#line 2153
    dll = (unsigned short)1;
  } else
#line 2155
  if (! ((int )exe_char & 4096)) {
#line 2160
    if (! ((int )exe_char & 2)) {
#line 2167
      return (foundat);
    }
  }
  {
#line 2170
  foundat += 24;
#line 2172
  SizeOfCode = htoi(foundat + 4, 1);
#line 2173
  SizeOfInitializedData = htoi(foundat + 8, 1);
#line 2174
  SizeOfUninitializedData = htoi(foundat + 12, 1);
#line 2175
  rva = htoi(foundat + 16, 1);
#line 2176
  align = htoi(foundat + 36, 1);
#line 2178
  sizeofimage = htoi(foundat + 56, 1);
#line 2179
  size_of_headers = htoi(foundat + 60, 1);
#line 2180
  foundat += 224;
#line 2183
  i = 0;
  }
  {
#line 2183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2183
    if (! (i < (int )sections)) {
#line 2183
      goto while_break;
    }
    {
#line 2187
    offset = htoi(foundat + 20, 1);
#line 2188
    raw_section_size = htoi(foundat + 16, 1);
#line 2191
    foundat += 40;
#line 2195
    sum = offset + raw_section_size;
#line 2183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2205
  file_size = (unsigned long long )sum;
#line 2206
  if (file_size < 512ULL) {
#line 2208
    return (foundat + 60);
  } else
#line 2206
  if (file_size > 4194304ULL) {
#line 2208
    return (foundat + 60);
  }
#line 2211
  if (file_size > buflen) {
#line 2212
    file_size = buflen;
  }
#line 2213
  foundat = buf;
#line 2218
  extractbuf = buf;
#line 2219
  if ((int )dll == 1) {
    {
#line 2221
    strcpy((char */* __restrict  */)needle->suffix, (char const   */* __restrict  */)"dll");
#line 2222
    write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
#line 2223
    strcpy((char */* __restrict  */)needle->suffix, (char const   */* __restrict  */)"exe");
    }
  } else {
    {
#line 2227
    write_to_disk(s, needle, file_size, extractbuf, c_offset + f_offset);
    }
  }
#line 2230
  foundat += needle->header_len;
#line 2231
  return (buf + file_size);
}
}
#line 2240 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_reg(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  int sizeofreg ;
  unsigned int tmp ;
  int file_size ;

  {
  {
#line 2243
  buf = foundat;
#line 2244
  extractbuf = (unsigned char *)((void *)0);
#line 2245
  tmp = htoi(foundat + 40, 1);
#line 2245
  sizeofreg = (int )tmp;
#line 2246
  file_size = 0;
  }
#line 2247
  if (sizeofreg < 0) {
#line 2249
    return (foundat + 4);
  } else
#line 2247
  if ((unsigned long long )sizeofreg > needle->max_len) {
#line 2249
    return (foundat + 4);
  }
  {
#line 2251
  foundat += sizeofreg;
#line 2252
  file_size = (int )(foundat - buf);
#line 2254
  extractbuf = buf;
#line 2257
  write_to_disk(s, needle, (unsigned long long )file_size, extractbuf, c_offset + f_offset);
  }
#line 2260
  return ((unsigned char *)((void *)0));
}
}
#line 2267 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_rar(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                           unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *buf ;
  unsigned char *extractbuf ;
  unsigned long long file_size ;
  unsigned short headersize ;
  unsigned short flags ;
  unsigned int filesize ;
  unsigned int tot_file_size ;
  unsigned int ufilesize ;
  int i ;
  int scan ;
  int flag ;
  int passwd ;
  unsigned long long bytes_to_search ;
  char comment[32] ;

  {
  {
#line 2270
  buf = foundat;
#line 2271
  extractbuf = (unsigned char *)((void *)0);
#line 2272
  file_size = 0ULL;
#line 2273
  headersize = (unsigned short)0;
#line 2274
  flags = (unsigned short)0;
#line 2275
  filesize = 0U;
#line 2276
  tot_file_size = 0U;
#line 2277
  ufilesize = 0U;
#line 2278
  i = 0;
#line 2279
  scan = 0;
#line 2280
  flag = 0;
#line 2281
  passwd = 0;
#line 2282
  bytes_to_search = 51200ULL;
#line 2286
  headersize = htos(foundat + 5, 1);
#line 2287
  foundat += (int )headersize;
#line 2290
  headersize = htos(foundat + 5, 1);
#line 2291
  filesize = htoi(foundat + 7, 1);
  }
#line 2293
  if ((int )*(foundat + 2) != 115) {
#line 2295
    return (foundat);
  }
  {
#line 2298
  flags = htos(foundat + 3, 1);
  }
#line 2299
  if (((int )flags & 1) != 0) {
    {
#line 2301
    sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" Multi-volume:");
#line 2302
    strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
    }
  }
#line 2305
  if ((int )flags & 2) {
    {
#line 2307
    sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)" an archive comment is present:");
#line 2308
    strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
    }
  }
#line 2311
  foundat += (int )headersize;
#line 2313
  if ((int )*(foundat + 2) != 116) {
#line 2315
    i = 0;
    {
#line 2315
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2315
      if (! (i < 500)) {
#line 2315
        goto while_break;
      }
#line 2317
      if ((int )*(foundat + i) == 116) {
#line 2319
        foundat += i - 2;
#line 2320
        scan = 1;
#line 2321
        goto while_break;
      }
#line 2315
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2326
  if ((int )headersize == 13) {
#line 2326
    if ((int )*(foundat + 2) != 116) {
#line 2329
      if (scan == 0) {
        {
#line 2331
        sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)"Encrypted Headers!");
#line 2332
        strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
        }
      }
#line 2335
      if (buflen - (unsigned long long )(foundat - buf) >= needle->max_len) {
#line 2336
        bytes_to_search = needle->max_len;
      } else {
#line 2338
        bytes_to_search = buflen - (unsigned long long )(foundat - buf);
      }
      {
#line 2341
      foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                          (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
      }
#line 2348
      if ((unsigned long )foundat == (unsigned long )((void *)0)) {
#line 2350
        tot_file_size = (unsigned int )bytes_to_search;
#line 2351
        foundat = buf + tot_file_size;
      }
    } else {
#line 2326
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2358
      if (! ((int )*(foundat + 2) == 116)) {
#line 2358
        goto while_break___0;
      }
      {
#line 2361
      headersize = htos(foundat + 5, 1);
#line 2362
      filesize = htoi(foundat + 7, 1);
#line 2363
      ufilesize = htoi(foundat + 11, 1);
      }
#line 2365
      if ((int )headersize < 1) {
#line 2366
        flag = 1;
      } else
#line 2365
      if ((unsigned long long )headersize > buflen) {
#line 2366
        flag = 1;
      }
#line 2367
      if (filesize < 0U) {
#line 2368
        flag = 1;
      } else
#line 2367
      if ((unsigned long long )filesize > buflen) {
#line 2368
        flag = 1;
      }
#line 2369
      if ((unsigned long long )((unsigned int )headersize + filesize) > buflen) {
#line 2370
        flag = 1;
      }
#line 2371
      if (ufilesize < 0U) {
#line 2372
        flag = 1;
      }
      {
#line 2374
      flags = htos(foundat + 3, 1);
      }
#line 2375
      if (((int )flags & 4) != 0) {
#line 2377
        passwd = 1;
      }
#line 2380
      tot_file_size = (unsigned int )(foundat - buf);
#line 2381
      if ((unsigned long long )((tot_file_size + (unsigned int )headersize) + filesize) > buflen) {
#line 2383
        goto while_break___0;
      }
#line 2386
      foundat += (unsigned int )headersize + filesize;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2389
    if (passwd == 1) {
      {
#line 2391
      sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)"Password Protected:");
#line 2392
      strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
      }
    }
#line 2395
    if (flag == 1) {
      {
#line 2397
      sprintf((char */* __restrict  */)(comment), (char const   */* __restrict  */)"Encrypted Headers!");
#line 2398
      strcat((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)(comment));
#line 2399
      foundat = bm_search(needle->footer, (size_t )needle->footer_len, foundat, (size_t )bytes_to_search,
                          (size_t *)(needle->footer_bm_table), needle->case_sen, 0);
      }
#line 2406
      if ((unsigned long )foundat == (unsigned long )((void *)0)) {
#line 2408
        tot_file_size = (unsigned int )bytes_to_search;
#line 2409
        foundat = buf + tot_file_size;
      }
    }
#line 2413
    if ((int )*(foundat + 2) != 123) {
#line 2413
      if (tot_file_size == 0U) {
#line 2417
        return (foundat);
      }
    }
#line 2420
    foundat += 7;
  }
#line 2424
  if (foundat) {
#line 2428
    tot_file_size = (unsigned int )(foundat - buf);
#line 2429
    if ((unsigned long long )tot_file_size > buflen) {
#line 2430
      file_size = buflen;
    }
    {
#line 2432
    extractbuf = buf;
#line 2433
    write_to_disk(s, needle, (unsigned long long )tot_file_size, extractbuf, c_offset + f_offset);
    }
#line 2434
    return (foundat);
  } else {
#line 2438
    return ((unsigned char *)((void *)0));
  }
#line 2441
  return ((unsigned char *)((void *)0));
}
}
#line 2444 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/extract.c"
unsigned char *extract_file(f_state *s , unsigned long long c_offset , unsigned char *foundat ,
                            unsigned long long buflen , s_spec *needle , unsigned long long f_offset ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;

  {
#line 2447
  if (needle->type == 0) {
    {
#line 2449
    tmp = extract_jpeg(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2449
    return (tmp);
  } else
#line 2451
  if (needle->type == 1) {
    {
#line 2453
    tmp___0 = extract_gif(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2453
    return (tmp___0);
  } else
#line 2455
  if (needle->type == 24) {
    {
#line 2457
    tmp___1 = extract_png(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2457
    return (tmp___1);
  } else
#line 2459
  if (needle->type == 2) {
    {
#line 2461
    tmp___2 = extract_bmp(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2461
    return (tmp___2);
  } else
#line 2463
  if (needle->type == 17) {
    {
#line 2465
    needle->suffix = (char *)"rif";
#line 2466
    tmp___3 = extract_riff(s, c_offset, foundat, buflen, needle, f_offset, (char *)"all");
    }
#line 2466
    return (tmp___3);
  } else
#line 2468
  if (needle->type == 6) {
    {
#line 2470
    tmp___4 = extract_riff(s, c_offset, foundat, buflen, needle, f_offset, (char *)"avi");
    }
#line 2470
    return (tmp___4);
  } else
#line 2472
  if (needle->type == 18) {
    {
#line 2474
    needle->suffix = (char *)"rif";
#line 2475
    tmp___5 = extract_riff(s, c_offset, foundat, buflen, needle, f_offset, (char *)"wav");
    }
#line 2475
    return (tmp___5);
  } else
#line 2477
  if (needle->type == 7) {
    {
#line 2479
    tmp___6 = extract_wmv(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2479
    return (tmp___6);
  } else
#line 2481
  if (needle->type == 15) {
    {
#line 2483
    needle->suffix = (char *)"ole";
#line 2484
    tmp___7 = extract_ole(s, c_offset, foundat, buflen, needle, f_offset, (char *)"all");
    }
#line 2484
    return (tmp___7);
  } else
#line 2486
  if (needle->type == 5) {
    {
#line 2488
    tmp___8 = extract_ole(s, c_offset, foundat, buflen, needle, f_offset, (char *)"doc");
    }
#line 2488
    return (tmp___8);
  } else
#line 2490
  if (needle->type == 12) {
    {
#line 2492
    tmp___9 = extract_ole(s, c_offset, foundat, buflen, needle, f_offset, (char *)"ppt");
    }
#line 2492
    return (tmp___9);
  } else
#line 2494
  if (needle->type == 11) {
    {
#line 2496
    needle->suffix = (char *)"ole";
#line 2497
    tmp___10 = extract_ole(s, c_offset, foundat, buflen, needle, f_offset, (char *)"xls");
    }
#line 2497
    return (tmp___10);
  } else
#line 2499
  if (needle->type == 4) {
    {
#line 2501
    tmp___11 = extract_pdf(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2501
    return (tmp___11);
  } else
#line 2503
  if (needle->type == 14) {
    {
#line 2505
    tmp___12 = extract_cpp(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2505
    return (tmp___12);
  } else
#line 2507
  if (needle->type == 8) {
    {
#line 2509
    tmp___13 = extract_htm(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2509
    return (tmp___13);
  } else
#line 2511
  if (needle->type == 3) {
    {
#line 2513
    tmp___14 = extract_mpg(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2513
    return (tmp___14);
  } else
#line 2515
  if (needle->type == 32) {
    {
#line 2517
    tmp___15 = extract_mp4(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2517
    return (tmp___15);
  } else
#line 2519
  if (needle->type == 9) {
    {
#line 2521
    tmp___16 = extract_zip(s, c_offset, foundat, buflen, needle, f_offset, (char *)"all");
    }
#line 2521
    return (tmp___16);
  } else
#line 2523
  if (needle->type == 25) {
    {
#line 2525
    tmp___17 = extract_rar(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2525
    return (tmp___17);
  } else
#line 2527
  if (needle->type == 20) {
    {
#line 2529
    tmp___18 = extract_zip(s, c_offset, foundat, buflen, needle, f_offset, (char *)"sxw");
    }
#line 2529
    return (tmp___18);
  } else
#line 2531
  if (needle->type == 21) {
    {
#line 2533
    tmp___19 = extract_zip(s, c_offset, foundat, buflen, needle, f_offset, (char *)"sxc");
    }
#line 2533
    return (tmp___19);
  } else
#line 2535
  if (needle->type == 22) {
    {
#line 2537
    tmp___20 = extract_zip(s, c_offset, foundat, buflen, needle, f_offset, (char *)"sxi");
    }
#line 2537
    return (tmp___20);
  } else
#line 2539
  if (needle->type == 26) {
    {
#line 2541
    tmp___21 = extract_exe(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2541
    return (tmp___21);
  } else
#line 2543
  if (needle->type == 10) {
    {
#line 2545
    tmp___22 = extract_mov(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2545
    return (tmp___22);
  } else
#line 2543
  if (needle->type == 19) {
    {
#line 2545
    tmp___22 = extract_mov(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2545
    return (tmp___22);
  } else
#line 2547
  if (needle->type == 23) {
    {
#line 2549
    tmp___23 = extract_generic(s, c_offset, foundat, buflen, needle, f_offset);
    }
#line 2549
    return (tmp___23);
  } else {
#line 2553
    return ((unsigned char *)((void *)0));
  }
#line 2555
  return ((unsigned char *)((void *)0));
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 835 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 421 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.h"
int create_output_directory(f_state *s ) ;
#line 423
int create_sub_dirs(f_state *s ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
int is_empty_directory(DIR *temp ) 
{ 
  struct dirent *tmp ;
  struct dirent *tmp___0 ;
  struct dirent *tmp___1 ;

  {
  {
#line 10
  tmp = readdir(temp);
  }
#line 10
  if (tmp) {
    {
#line 10
    tmp___0 = readdir(temp);
    }
#line 10
    if (tmp___0) {
      {
#line 10
      tmp___1 = readdir(temp);
      }
#line 10
      if (tmp___1) {
#line 11
        return (0);
      }
    }
  }
#line 13
  return (1);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
void cleanup_output(f_state *s ) 
{ 
  char dir_name[1024] ;
  DIR *temp ;
  DIR *outputDir ;
  struct dirent *entry ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 25
  tmp = get_output_directory(s);
#line 25
  outputDir = opendir((char const   *)tmp);
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 31
    entry = readdir(outputDir);
    }
#line 31
    if (! entry) {
#line 31
      goto while_break;
    }
    {
#line 33
    memset((void *)(dir_name), 0, (size_t )1023);
#line 34
    tmp___0 = get_output_directory(s);
#line 34
    strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___0);
#line 35
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 36
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(entry->d_name));
#line 37
    temp = opendir((char const   *)(dir_name));
    }
#line 38
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
      {
#line 40
      tmp___1 = is_empty_directory(temp);
      }
#line 40
      if (tmp___1) {
        {
#line 42
        rmdir((char const   *)(dir_name));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
int make_new_directory(f_state *s , char *fn ) 
{ 
  mode_t new_mode ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 61
  new_mode = (mode_t )(((((448 | (256 >> 3)) | (128 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 72
  tmp___2 = mkdir((char const   *)fn, new_mode);
  }
#line 72
  if (tmp___2) {
    {
#line 75
    tmp___1 = __errno_location();
    }
#line 75
    if (*tmp___1 != 17) {
      {
#line 77
      tmp = __errno_location();
#line 77
      tmp___0 = strerror(*tmp);
#line 77
      print_error(s, fn, tmp___0);
      }
#line 78
      return (1);
    }
  }
#line 82
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
char *clean_time_string(char *time___0 ) 
{ 
  int len ;
  size_t tmp ;
  int i ;

  {
  {
#line 88
  tmp = strlen((char const   *)time___0);
#line 88
  len = (int )tmp;
#line 89
  i = 0;
#line 91
  i = 0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < len)) {
#line 91
      goto while_break;
    }
#line 100
    if ((int )*(time___0 + i) == 32) {
#line 102
      *(time___0 + i) = (char )'_';
    } else
#line 100
    if ((int )*(time___0 + i) == 58) {
#line 102
      *(time___0 + i) = (char )'_';
    }
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (time___0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
int create_output_directory(f_state *s ) 
{ 
  DIR *d ;
  char dir_name[1024] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 115
  memset((void *)(dir_name), 0, (size_t )1023);
  }
#line 116
  if (s->time_stamp) {
    {
#line 118
    tmp = get_output_directory(s);
#line 118
    strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp);
#line 119
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"_");
#line 120
    tmp___0 = get_start_time(s);
#line 120
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___0);
#line 121
    clean_time_string(dir_name);
#line 122
    set_output_directory(s, dir_name);
    }
  }
  {
#line 128
  tmp___3 = get_output_directory(s);
#line 128
  d = opendir((char const   *)tmp___3);
  }
#line 128
  if ((unsigned long )d != (unsigned long )((void *)0)) {
    {
#line 132
    tmp___2 = is_empty_directory(d);
    }
#line 132
    if (! tmp___2) {
      {
#line 134
      tmp___1 = get_output_directory(s);
#line 134
      printf((char const   */* __restrict  */)"ERROR: %s is not empty\n \tPlease specify another directory or run with -T.\n",
             tmp___1);
#line 137
      exit(1);
      }
    }
    {
#line 141
    closedir(d);
    }
#line 142
    return (0);
  }
  {
#line 149
  tmp___7 = __errno_location();
  }
#line 149
  if (*tmp___7 != 2) {
    {
#line 151
    tmp___4 = __errno_location();
#line 151
    tmp___5 = strerror(*tmp___4);
#line 151
    tmp___6 = get_output_directory(s);
#line 151
    print_error(s, tmp___6, tmp___5);
    }
#line 152
    return (1);
  }
  {
#line 155
  tmp___8 = get_output_directory(s);
#line 155
  tmp___9 = strlen((char const   *)tmp___8);
  }
#line 155
  if (tmp___9 == 0UL) {
    {
#line 161
    print_error(s, (char *)"(output_directory)", (char *)"Output directory name unknown");
    }
#line 162
    return (1);
  }
  {
#line 165
  tmp___10 = get_output_directory(s);
#line 165
  tmp___11 = make_new_directory(s, tmp___10);
  }
#line 165
  return (tmp___11);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
int create_sub_dirs(f_state *s ) 
{ 
  int i ;
  int j ;
  char dir_name[1024] ;
  char ole_types[7][4] ;
  char riff_types[2][4] ;
  char zip_types[8][5] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
#line 172
  i = 0;
#line 173
  j = 0;
#line 175
  ole_types[0][0] = (char )'p';
#line 175
  ole_types[0][1] = (char )'p';
#line 175
  ole_types[0][2] = (char )'t';
#line 175
  ole_types[0][3] = (char )'\000';
#line 175
  ole_types[1][0] = (char )'d';
#line 175
  ole_types[1][1] = (char )'o';
#line 175
  ole_types[1][2] = (char )'c';
#line 175
  ole_types[1][3] = (char )'\000';
#line 175
  ole_types[2][0] = (char )'x';
#line 175
  ole_types[2][1] = (char )'l';
#line 175
  ole_types[2][2] = (char )'s';
#line 175
  ole_types[2][3] = (char )'\000';
#line 175
  ole_types[3][0] = (char )'s';
#line 175
  ole_types[3][1] = (char )'d';
#line 175
  ole_types[3][2] = (char )'w';
#line 175
  ole_types[3][3] = (char )'\000';
#line 175
  ole_types[4][0] = (char )'m';
#line 175
  ole_types[4][1] = (char )'b';
#line 175
  ole_types[4][2] = (char )'d';
#line 175
  ole_types[4][3] = (char )'\000';
#line 175
  ole_types[5][0] = (char )'v';
#line 175
  ole_types[5][1] = (char )'i';
#line 175
  ole_types[5][2] = (char )'s';
#line 175
  ole_types[5][3] = (char )'\000';
#line 175
  ole_types[6][0] = (char )'o';
#line 175
  ole_types[6][1] = (char )'l';
#line 175
  ole_types[6][2] = (char )'e';
#line 175
  ole_types[6][3] = (char )'\000';
#line 176
  riff_types[0][0] = (char )'a';
#line 176
  riff_types[0][1] = (char )'v';
#line 176
  riff_types[0][2] = (char )'i';
#line 176
  riff_types[0][3] = (char )'\000';
#line 176
  riff_types[1][0] = (char )'w';
#line 176
  riff_types[1][1] = (char )'a';
#line 176
  riff_types[1][2] = (char )'v';
#line 176
  riff_types[1][3] = (char )'\000';
#line 177
  zip_types[0][0] = (char )'s';
#line 177
  zip_types[0][1] = (char )'x';
#line 177
  zip_types[0][2] = (char )'c';
#line 177
  zip_types[0][3] = (char )'\000';
#line 177
  tmp = 4U;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (tmp >= 5U) {
#line 177
      goto while_break;
    }
#line 177
    zip_types[0][tmp] = (char)0;
#line 177
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  zip_types[1][0] = (char )'s';
#line 177
  zip_types[1][1] = (char )'x';
#line 177
  zip_types[1][2] = (char )'w';
#line 177
  zip_types[1][3] = (char )'\000';
#line 177
  tmp___0 = 4U;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (tmp___0 >= 5U) {
#line 177
      goto while_break___0;
    }
#line 177
    zip_types[1][tmp___0] = (char)0;
#line 177
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  zip_types[2][0] = (char )'s';
#line 177
  zip_types[2][1] = (char )'x';
#line 177
  zip_types[2][2] = (char )'i';
#line 177
  zip_types[2][3] = (char )'\000';
#line 177
  tmp___1 = 4U;
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (tmp___1 >= 5U) {
#line 177
      goto while_break___1;
    }
#line 177
    zip_types[2][tmp___1] = (char)0;
#line 177
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 177
  zip_types[3][0] = (char )'s';
#line 177
  zip_types[3][1] = (char )'x';
#line 177
  zip_types[3][2] = (char )'\000';
#line 177
  tmp___2 = 3U;
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (tmp___2 >= 5U) {
#line 177
      goto while_break___2;
    }
#line 177
    zip_types[3][tmp___2] = (char)0;
#line 177
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 177
  zip_types[4][0] = (char )'j';
#line 177
  zip_types[4][1] = (char )'a';
#line 177
  zip_types[4][2] = (char )'r';
#line 177
  zip_types[4][3] = (char )'\000';
#line 177
  tmp___3 = 4U;
  {
#line 177
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 177
    if (tmp___3 >= 5U) {
#line 177
      goto while_break___3;
    }
#line 177
    zip_types[4][tmp___3] = (char)0;
#line 177
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 177
  zip_types[5][0] = (char )'d';
#line 177
  zip_types[5][1] = (char )'o';
#line 177
  zip_types[5][2] = (char )'c';
#line 177
  zip_types[5][3] = (char )'x';
#line 177
  zip_types[5][4] = (char )'\000';
#line 177
  zip_types[6][0] = (char )'p';
#line 177
  zip_types[6][1] = (char )'p';
#line 177
  zip_types[6][2] = (char )'t';
#line 177
  zip_types[6][3] = (char )'x';
#line 177
  zip_types[6][4] = (char )'\000';
#line 177
  zip_types[7][0] = (char )'x';
#line 177
  zip_types[7][1] = (char )'l';
#line 177
  zip_types[7][2] = (char )'s';
#line 177
  zip_types[7][3] = (char )'x';
#line 177
  zip_types[7][4] = (char )'\000';
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 179
    if (! (i < s->num_builtin)) {
#line 179
      goto while_break___4;
    }
    {
#line 181
    memset((void *)(dir_name), 0, (size_t )1023);
#line 182
    tmp___4 = get_output_directory(s);
#line 182
    strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___4);
#line 183
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 184
    strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)search_spec[i].suffix);
#line 185
    make_new_directory(s, dir_name);
    }
#line 187
    if (search_spec[i].type == 15) {
#line 189
      j = 0;
      {
#line 189
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 189
        if (! (j < 7)) {
#line 189
          goto while_break___5;
        }
        {
#line 191
        tmp___5 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
        }
#line 191
        if (tmp___5) {
#line 192
          goto __Cont;
        }
        {
#line 194
        memset((void *)(dir_name), 0, (size_t )1023);
#line 195
        tmp___6 = get_output_directory(s);
#line 195
        strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___6);
#line 196
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 197
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(ole_types[j]));
#line 198
        make_new_directory(s, dir_name);
        }
        __Cont: /* CIL Label */ 
#line 189
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
      {
#line 201
      tmp___10 = get_mode(s, (off_t )(1 << 5));
      }
#line 201
      if (tmp___10) {
#line 203
        j = 0;
        {
#line 203
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 203
          if (! (j < 7)) {
#line 203
            goto while_break___6;
          }
          {
#line 205
          tmp___9 = strstr((char const   *)search_spec[i].suffix, (char const   *)(ole_types[j]));
          }
#line 205
          if (tmp___9) {
#line 207
            j = 0;
            {
#line 207
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 207
              if (! (j < 7)) {
#line 207
                goto while_break___7;
              }
              {
#line 209
              tmp___7 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
              }
#line 209
              if (tmp___7) {
#line 210
                goto __Cont___0;
              }
              {
#line 212
              memset((void *)(dir_name), 0, (size_t )1023);
#line 213
              tmp___8 = get_output_directory(s);
#line 213
              strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___8);
#line 214
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 215
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(ole_types[j]));
#line 216
              make_new_directory(s, dir_name);
              }
              __Cont___0: /* CIL Label */ 
#line 207
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 218
            goto while_break___6;
          }
#line 203
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
#line 224
    if (search_spec[i].type == 26) {
      {
#line 226
      memset((void *)(dir_name), 0, (size_t )1023);
#line 227
      tmp___11 = get_output_directory(s);
#line 227
      strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___11);
#line 228
      strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 229
      strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"dll");
#line 230
      make_new_directory(s, dir_name);
      }
    }
#line 233
    if (search_spec[i].type == 17) {
#line 235
      j = 0;
      {
#line 235
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 235
        if (! (j < 2)) {
#line 235
          goto while_break___8;
        }
        {
#line 237
        tmp___12 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
        }
#line 237
        if (tmp___12) {
#line 238
          goto __Cont___1;
        }
        {
#line 239
        memset((void *)(dir_name), 0, (size_t )1023);
#line 240
        tmp___13 = get_output_directory(s);
#line 240
        strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___13);
#line 241
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 242
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(riff_types[j]));
#line 243
        make_new_directory(s, dir_name);
        }
        __Cont___1: /* CIL Label */ 
#line 235
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
      {
#line 246
      tmp___17 = get_mode(s, (off_t )(1 << 5));
      }
#line 246
      if (tmp___17) {
#line 248
        j = 0;
        {
#line 248
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 248
          if (! (j < 2)) {
#line 248
            goto while_break___9;
          }
          {
#line 250
          tmp___16 = strstr((char const   *)search_spec[i].suffix, (char const   *)(riff_types[j]));
          }
#line 250
          if (tmp___16) {
#line 252
            j = 0;
            {
#line 252
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 252
              if (! (j < 2)) {
#line 252
                goto while_break___10;
              }
              {
#line 254
              tmp___14 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
              }
#line 254
              if (tmp___14) {
#line 255
                goto __Cont___2;
              }
              {
#line 257
              memset((void *)(dir_name), 0, (size_t )1023);
#line 258
              tmp___15 = get_output_directory(s);
#line 258
              strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___15);
#line 259
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 260
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(riff_types[j]));
#line 261
              make_new_directory(s, dir_name);
              }
              __Cont___2: /* CIL Label */ 
#line 252
              j ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 263
            goto while_break___9;
          }
#line 248
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
#line 269
    if (search_spec[i].type == 9) {
#line 271
      j = 0;
      {
#line 271
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 271
        if (! (j < 8)) {
#line 271
          goto while_break___11;
        }
        {
#line 273
        tmp___18 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
        }
#line 273
        if (tmp___18) {
#line 274
          goto __Cont___3;
        }
        {
#line 276
        memset((void *)(dir_name), 0, (size_t )1023);
#line 277
        tmp___19 = get_output_directory(s);
#line 277
        strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___19);
#line 278
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 279
        strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(zip_types[j]));
#line 280
        make_new_directory(s, dir_name);
        }
        __Cont___3: /* CIL Label */ 
#line 271
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 283
      tmp___23 = get_mode(s, (off_t )(1 << 5));
      }
#line 283
      if (tmp___23) {
#line 285
        j = 0;
        {
#line 285
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 285
          if (! (j < 8)) {
#line 285
            goto while_break___12;
          }
          {
#line 287
          tmp___22 = strstr((char const   *)search_spec[i].suffix, (char const   *)(zip_types[j]));
          }
#line 287
          if (tmp___22) {
#line 289
            j = 0;
            {
#line 289
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 289
              if (! (j < 5)) {
#line 289
                goto while_break___13;
              }
              {
#line 291
              tmp___20 = strstr((char const   *)(ole_types[j]), (char const   *)search_spec[i].suffix);
              }
#line 291
              if (tmp___20) {
#line 292
                goto __Cont___4;
              }
              {
#line 294
              memset((void *)(dir_name), 0, (size_t )1023);
#line 295
              tmp___21 = get_output_directory(s);
#line 295
              strcpy((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)tmp___21);
#line 296
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)"/");
#line 297
              strcat((char */* __restrict  */)(dir_name), (char const   */* __restrict  */)(zip_types[j]));
#line 298
              make_new_directory(s, dir_name);
              }
              __Cont___4: /* CIL Label */ 
#line 289
              j ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 300
            goto while_break___12;
          }
#line 285
          j ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 179
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 307
  return (1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/dir.c"
int write_to_disk(f_state *s , s_spec *needle , unsigned long long len , unsigned char *buf ,
                  unsigned long long t_offset ) 
{ 
  char fn[1024] ;
  FILE *f ;
  FILE *test ;
  long byteswritten ;
  char temp[32] ;
  unsigned long long block ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 317
  byteswritten = 0L;
#line 319
  block = t_offset / (unsigned long long )s->block_size;
#line 320
  i = 1;
#line 323
  needle->written = 1;
#line 325
  tmp___0 = get_mode(s, (off_t )(1 << 6));
  }
#line 325
  if (tmp___0) {
#line 327
    if ((unsigned long )(needle->comment) == (unsigned long )((void *)0)) {
      {
#line 328
      strcpy((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)" ");
      }
    }
    {
#line 330
    tmp = human_readable((off_t )len, temp);
#line 330
    audit_msg(s, (char *)"%d:\t%10ld.%s \t %10s \t %10llu \t %s", s->fileswritten,
              block, needle->suffix, tmp, t_offset, needle->comment);
#line 338
    (s->fileswritten) ++;
#line 339
    (needle->found) ++;
    }
#line 340
    return (1);
  }
  {
#line 343
  snprintf((char */* __restrict  */)(fn), (size_t )1024, (char const   */* __restrict  */)"%s/%s/%0*llu.%s",
           s->output_directory, needle->suffix, 8, block, needle->suffix);
#line 352
  test = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! test) {
#line 353
      goto while_break;
    }
    {
#line 355
    memset((void *)(fn), 0, (size_t )1023);
#line 356
    snprintf((char */* __restrict  */)(fn), (size_t )1023, (char const   */* __restrict  */)"%s/%s/%0*llu_%d.%s",
             s->output_directory, needle->suffix, 8, block, i, needle->suffix);
#line 365
    i ++;
#line 366
    fclose(test);
#line 367
    test = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  f = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"w");
  }
#line 370
  if (! f) {
    {
#line 372
    printf((char const   */* __restrict  */)"fn = %s  failed\n", fn);
#line 373
    fatal_error(s, (char *)"Can\'t open file for writing \n");
    }
  }
  {
#line 376
  tmp___1 = fwrite((void const   */* __restrict  */)buf, sizeof(char ), (size_t )len,
                   (FILE */* __restrict  */)f);
#line 376
  byteswritten = (long )tmp___1;
  }
#line 376
  if ((unsigned long long )byteswritten != len) {
    {
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fn=%s bytes=%lu\n",
            fn, byteswritten);
#line 379
    fatal_error(s, (char *)"Error writing file\n");
    }
  }
  {
#line 382
  tmp___2 = fclose(f);
  }
#line 382
  if (tmp___2) {
    {
#line 384
    fatal_error(s, (char *)"Error closing file\n");
    }
  }
#line 387
  if ((unsigned long )(needle->comment) == (unsigned long )((void *)0)) {
    {
#line 388
    strcpy((char */* __restrict  */)(needle->comment), (char const   */* __restrict  */)" ");
    }
  }
#line 390
  if (i == 1) {
    {
#line 391
    tmp___3 = human_readable((off_t )len, temp);
#line 391
    audit_msg(s, (char *)"%d:\t%08llu.%s \t %10s \t %10llu \t %s", s->fileswritten,
              block, needle->suffix, tmp___3, t_offset, needle->comment);
    }
  } else {
    {
#line 399
    tmp___4 = human_readable((off_t )len, temp);
#line 399
    audit_msg(s, (char *)"%d:\t%08llu_%d.%s \t %10s \t %10llu \t %s", s->fileswritten,
              block, i - 1, needle->suffix, tmp___4, t_offset, needle->comment);
    }
  }
#line 419
  (s->fileswritten) ++;
#line 420
  (needle->found) ++;
#line 421
  return (1);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/ole.h"
void dump_header(struct OLE_HDR *h ) ;
#line 94
int dump_dirent(int which_one ) ;
#line 97
int reorder_dirlist(struct DIRECTORY *dir , int level ) ;
#line 99
unsigned char *get_ole_block(unsigned char *fd , int blknum , unsigned long long buffersize ) ;
#line 100
struct OLE_HDR *reverseBlock(struct OLE_HDR *dest , struct OLE_HDR *h ) ;
#line 102
void dump_ole_header(struct OLE_HDR *h ) ;
#line 104
void die(char *fmt , void *arg ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
unsigned char buffer[512]  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
char *extract_name  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int extract  =    0;
#line 15 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int dir_count  =    0;
#line 16 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int *FAT  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int verbose  =    1;
#line 18 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int FATblk  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int currFATblk  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int highblk  =    0;
#line 21 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int block_list[512UL / sizeof(int )]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
void init_ole(void) 
{ 
  int i ;

  {
#line 27
  i = 0;
#line 28
  extract = 0;
#line 29
  dir_count = 0;
#line 30
  FAT = (int *)((void *)0);
#line 31
  highblk = 0;
#line 32
  FATblk = 0;
#line 33
  currFATblk = -1;
#line 34
  dirlist = (struct DIRECTORY *)((void *)0);
#line 35
  dl = (struct DIRECTORY *)((void *)0);
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )i < 512UL / sizeof(int ))) {
#line 36
      goto while_break;
    }
#line 38
    block_list[i] = 0;
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! (i < 512)) {
#line 41
      goto while_break___0;
    }
#line 43
    buffer[i] = (unsigned char)0;
#line 41
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
void *Malloc(size_t bytes ) 
{ 
  void *x ;

  {
  {
#line 51
  x = malloc(bytes);
  }
#line 52
  if (x) {
#line 53
    return (x);
  }
  {
#line 54
  die((char *)"Can\'t malloc %d bytes.\n", (void *)((char *)bytes));
  }
#line 55
  return ((void *)0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
void die(char *fmt , void *arg ) 
{ 


  {
  {
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt, arg);
#line 61
  exit(1);
  }
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int get_dir_block(unsigned char *fd , int blknum , int buffersize ) 
{ 
  int i ;
  struct OLE_DIR *dir ;
  unsigned char *dest ;

  {
  {
#line 68
  dest = (unsigned char *)((void *)0);
#line 70
  dest = get_ole_block(fd, blknum, (unsigned long long )buffersize);
  }
#line 71
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 73
    return (0);
  }
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 4)) {
#line 76
      goto while_break;
    }
#line 78
    dir = (struct OLE_DIR *)(dest + sizeof(struct OLE_DIR ) * (unsigned long )i);
#line 79
    if ((int )dir->type == 0) {
#line 80
      goto while_break;
    }
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  if (i == 4) {
#line 85
    return (1);
  } else {
#line 89
    return (3);
  }
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int get_dir_info(unsigned char *src ) 
{ 
  int i ;
  int j ;
  char *p ;
  char *q ;
  struct OLE_DIR *dir ;
  int punctCount ;
  short name_size ;
  int tmp ;
  unsigned short tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 98
  punctCount = 0;
#line 99
  name_size = (short)0;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < 4)) {
#line 101
      goto while_break;
    }
#line 103
    dir = (struct OLE_DIR *)(src + sizeof(struct OLE_DIR ) * (unsigned long )i);
#line 104
    punctCount = 0;
#line 107
    if ((int )dir->type < 0) {
#line 113
      return (0);
    }
#line 116
    if ((int )dir->type == 0) {
#line 117
      goto while_break;
    }
#line 123
    tmp = dir_count;
#line 123
    dir_count ++;
#line 123
    dl = dirlist + tmp;
#line 124
    if ((unsigned long )dl == (unsigned long )((void *)0)) {
#line 129
      return (0);
    }
#line 132
    if (dir_count > 500) {
#line 133
      return (0);
    }
    {
#line 134
    q = dl->name;
#line 135
    p = dir->name;
#line 137
    tmp___0 = htos((unsigned char *)(& dir->namsiz), 1);
#line 137
    name_size = (short )tmp___0;
    }
#line 142
    if ((int )name_size > 64) {
#line 143
      return (0);
    } else
#line 142
    if ((int )name_size <= 0) {
#line 143
      return (0);
    }
#line 145
    if ((int )*p < 32) {
#line 146
      p += 2;
    }
#line 147
    j = 0;
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (! (j < (int )name_size)) {
#line 147
        goto while_break___0;
      }
#line 150
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 151
        return (0);
      } else
#line 150
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 151
        return (0);
      }
#line 152
      if (*p) {
        {
#line 152
        tmp___3 = __ctype_b_loc();
        }
#line 152
        if ((int const   )*(*tmp___3 + (int )*p) & 16384) {
          {
#line 155
          tmp___1 = __ctype_b_loc();
          }
#line 155
          if ((int const   )*(*tmp___1 + (int )*p) & 4) {
#line 156
            punctCount ++;
          }
#line 157
          tmp___2 = q;
#line 157
          q ++;
#line 157
          *tmp___2 = *p;
        }
      }
#line 147
      j ++;
#line 147
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 162
    if (punctCount > 3) {
#line 168
      return (0);
    }
#line 171
    if ((unsigned long )(dl->name) == (unsigned long )((void *)0)) {
#line 176
      return (0);
    }
    {
#line 180
    tmp___4 = strstr((char const   *)(dl->name), "Catalog");
    }
#line 180
    if (tmp___4) {
#line 181
      return (0);
    }
    {
#line 182
    *q = (char)0;
#line 183
    dl->type = (int )dir->type;
#line 184
    tmp___5 = htoi((unsigned char *)(& dir->size), 1);
#line 184
    dl->size = (int )tmp___5;
#line 186
    tmp___6 = htoi((unsigned char *)(& dir->start_block), 1);
#line 186
    dl->start_block = (int )tmp___6;
#line 187
    tmp___7 = htoi((unsigned char *)(& dir->next_dirent), 1);
#line 187
    dl->next = (int )tmp___7;
#line 188
    tmp___8 = htoi((unsigned char *)(& dir->prev_dirent), 1);
#line 188
    dl->prev = (int )tmp___8;
#line 189
    tmp___9 = htoi((unsigned char *)(& dir->dir_dirent), 1);
#line 189
    dl->dir = (int )tmp___9;
    }
#line 190
    if ((int )dir->type != 2) {
#line 192
      dl->s1 = dir->secs1;
#line 193
      dl->s2 = dir->secs2;
#line 194
      dl->d1 = dir->days1;
#line 195
      dl->d2 = dir->days2;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (1);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
static int *lnlv  ;
#line 203 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int reorder_dirlist(struct DIRECTORY *dir , int level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 207
  dir->level = level;
#line 208
  if (dir->dir != -1) {
#line 210
    return (0);
  } else
#line 208
  if (dir->dir > dir_count) {
#line 210
    return (0);
  } else {
    {
#line 212
    tmp = reorder_dirlist(dirlist + dir->dir, level + 1);
    }
#line 212
    if (! tmp) {
#line 213
      return (0);
    }
  }
#line 216
  if (dir->next != -1) {
#line 218
    if (dir->next > dir_count) {
#line 219
      return (0);
    } else {
      {
#line 220
      tmp___0 = reorder_dirlist(dirlist + dir->next, level);
      }
#line 220
      if (! tmp___0) {
#line 221
        return (0);
      }
    }
  } else {
#line 224
    lnlv = & dir->next;
  }
#line 228
  if (dir->prev != -1) {
#line 230
    if (dir->prev > dir_count) {
#line 231
      return (0);
    } else {
      {
#line 234
      *lnlv = dir->prev;
#line 235
      dir->prev = -1;
#line 236
      tmp___1 = reorder_dirlist(dirlist + *lnlv, level);
      }
#line 236
      if (! tmp___1) {
#line 237
        return (0);
      }
    }
  }
#line 241
  return (1);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int get_block(unsigned char *fd , int blknum , unsigned char *dest , long long buffersize ) 
{ 
  unsigned char *temp ;
  int i ;
  unsigned long long jump ;

  {
#line 246
  temp = fd;
#line 247
  i = 0;
#line 248
  jump = 512ULL * (unsigned long long )(blknum + 1);
#line 249
  if (blknum < -1) {
#line 254
    return (0);
  } else
#line 249
  if (jump < 0ULL) {
#line 254
    return (0);
  } else
#line 249
  if ((long long )blknum > buffersize) {
#line 254
    return (0);
  } else
#line 249
  if ((unsigned long long )buffersize < jump) {
#line 254
    return (0);
  }
#line 257
  temp = fd + jump;
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 512)) {
#line 261
      goto while_break;
    }
#line 263
    *(dest + i) = *(temp + i);
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if (blknum + 1 > highblk) {
#line 267
    highblk = blknum + 1;
  }
#line 268
  return (1);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
unsigned char *get_ole_block(unsigned char *fd , int blknum , unsigned long long buffersize ) 
{ 
  unsigned long long jump ;

  {
#line 273
  jump = 512ULL * (unsigned long long )(blknum + 1);
#line 274
  if (blknum < -1) {
#line 279
    return ((unsigned char *)0);
  } else
#line 274
  if (jump < 0ULL) {
#line 279
    return ((unsigned char *)0);
  } else
#line 274
  if ((unsigned long long )blknum > buffersize) {
#line 279
    return ((unsigned char *)0);
  } else
#line 274
  if (buffersize < jump) {
#line 279
    return ((unsigned char *)0);
  }
#line 285
  return (fd + jump);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
static int FATblk___0  ;
#line 288 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int get_FAT_block(unsigned char *fd , int blknum , int *dest , int buffersize ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = htoi((unsigned char *)(FAT + (unsigned long )blknum / (512UL / sizeof(int ))),
             1);
#line 293
  FATblk___0 = (int )tmp;
  }
#line 298
  if (currFATblk != FATblk___0) {
    {
#line 303
    tmp___0 = get_block(fd, FATblk___0, (unsigned char *)dest, (long long )buffersize);
    }
#line 303
    if (! tmp___0) {
#line 305
      return (0);
    }
#line 308
    currFATblk = FATblk___0;
  }
#line 311
  return (1);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
void dump_header(struct OLE_HDR *h ) 
{ 
  int i ;
  int *x ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;

  {
  {
#line 321
  tmp = htos((unsigned char *)(& h->uMinorVersion), 1);
#line 321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nuMinorVersion  = %u\t",
          (int )tmp);
#line 324
  tmp___0 = htos((unsigned char *)(& h->uDllVersion), 1);
#line 324
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uDllVersion  = %u\t",
          (int )tmp___0);
#line 327
  tmp___1 = htos((unsigned char *)(& h->uByteOrder), 1);
#line 327
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uByteOrder  = %u\n",
          (int )tmp___1);
#line 330
  tmp___2 = htos((unsigned char *)(& h->uSectorShift), 1);
#line 330
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uSectorShift  = %u\t",
          (int )tmp___2);
#line 333
  tmp___3 = htos((unsigned char *)(& h->uMiniSectorShift), 1);
#line 333
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uMiniSectorShift  = %u\t",
          (int )tmp___3);
#line 336
  tmp___4 = htos((unsigned char *)(& h->reserved), 1);
#line 336
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved  = %u\n",
          (int )tmp___4);
#line 339
  tmp___5 = htoi((unsigned char *)(& h->reserved1), 1);
#line 339
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved1  = %u\t",
          tmp___5);
#line 342
  tmp___6 = htoi((unsigned char *)(& h->reserved2), 1);
#line 342
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved2  = %u\t",
          tmp___6);
#line 345
  tmp___7 = htoi((unsigned char *)(& h->csectMiniFat), 1);
#line 345
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"csectMiniFat = %u\t",
          tmp___7);
#line 348
  tmp___8 = htoi((unsigned char *)(& h->miniSectorCutoff), 1);
#line 348
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"miniSectorCutoff = %u\n",
          tmp___8);
#line 351
  tmp___9 = htoi((unsigned char *)(& h->root_start_block), 1);
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"root_start_block  = %u\n",
          tmp___9);
#line 354
  tmp___10 = htoi((unsigned char *)(& h->dir_flag), 1);
#line 354
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dir flag = %u\n",
          tmp___10);
#line 357
  tmp___11 = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
#line 357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# FAT blocks = %u\n",
          tmp___11);
#line 360
  tmp___12 = htoi((unsigned char *)(& h->FAT_next_block), 1);
#line 360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FAT_next_block = %u\n",
          tmp___12);
#line 363
  tmp___13 = htoi((unsigned char *)(& h->num_extra_FAT_blocks), 1);
#line 363
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# extra FAT blocks = %u\n",
          tmp___13);
#line 366
  x = (int *)(h + 1);
#line 367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bbd list:");
#line 368
  i = 0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 109)) {
#line 368
      goto while_break;
    }
#line 370
    if (i % 10 == 0) {
      {
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 372
    if (*x == -1) {
#line 373
      goto while_break;
    }
    {
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%x ",
            *x);
#line 368
    i ++;
#line 368
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\t**************End of header***********\n");
  }
#line 378
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
struct OLE_HDR *reverseBlock(struct OLE_HDR *dest , struct OLE_HDR *h ) 
{ 
  int i ;
  int *x ;
  int *y ;
  unsigned int tmp ;

  {
  {
#line 383
  dest->uMinorVersion = htos((unsigned char *)(& h->uMinorVersion), 1);
#line 384
  dest->uDllVersion = htos((unsigned char *)(& h->uDllVersion), 1);
#line 385
  dest->uByteOrder = htos((unsigned char *)(& h->uByteOrder), 1);
#line 386
  dest->uSectorShift = htos((unsigned char *)(& h->uSectorShift), 1);
#line 387
  dest->uMiniSectorShift = htos((unsigned char *)(& h->uMiniSectorShift), 1);
#line 388
  dest->reserved = htos((unsigned char *)(& h->reserved), 1);
#line 389
  dest->reserved1 = htoi((unsigned char *)(& h->reserved1), 1);
#line 390
  dest->reserved2 = htoi((unsigned char *)(& h->reserved2), 1);
#line 391
  dest->num_FAT_blocks = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
#line 392
  dest->root_start_block = htoi((unsigned char *)(& h->root_start_block), 1);
#line 393
  dest->dfsignature = htoi((unsigned char *)(& h->dfsignature), 1);
#line 394
  dest->miniSectorCutoff = htoi((unsigned char *)(& h->miniSectorCutoff), 1);
#line 395
  dest->dir_flag = htoi((unsigned char *)(& h->dir_flag), 1);
#line 396
  dest->csectMiniFat = htoi((unsigned char *)(& h->csectMiniFat), 1);
#line 397
  dest->FAT_next_block = htoi((unsigned char *)(& h->FAT_next_block), 1);
#line 398
  dest->num_extra_FAT_blocks = htoi((unsigned char *)(& h->num_extra_FAT_blocks),
                                    1);
#line 401
  x = (int *)(h + 1);
#line 402
  y = (int *)(dest + 1);
#line 403
  i = 0;
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < 109)) {
#line 403
      goto while_break;
    }
    {
#line 405
    tmp = htoi((unsigned char *)x, 1);
#line 405
    *y = (int )tmp;
#line 406
    y ++;
#line 403
    i ++;
#line 403
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return (dest);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
void dump_ole_header(struct OLE_HDR *h ) 
{ 
  int i ;
  int *x ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;

  {
  {
#line 418
  tmp = htos((unsigned char *)(& h->uMinorVersion), 1);
#line 418
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nuMinorVersion  = %u\t",
          (int )tmp);
#line 421
  tmp___0 = htos((unsigned char *)(& h->uDllVersion), 1);
#line 421
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uDllVersion  = %u\t",
          (int )tmp___0);
#line 424
  tmp___1 = htos((unsigned char *)(& h->uByteOrder), 1);
#line 424
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uByteOrder  = %u\n",
          (int )tmp___1);
#line 427
  tmp___2 = htos((unsigned char *)(& h->uSectorShift), 1);
#line 427
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uSectorShift  = %u\t",
          (int )tmp___2);
#line 430
  tmp___3 = htos((unsigned char *)(& h->uMiniSectorShift), 1);
#line 430
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uMiniSectorShift  = %u\t",
          (int )tmp___3);
#line 433
  tmp___4 = htos((unsigned char *)(& h->reserved), 1);
#line 433
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved  = %u\n",
          (int )tmp___4);
#line 436
  tmp___5 = htoi((unsigned char *)(& h->reserved1), 1);
#line 436
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved1  = %u\t",
          tmp___5);
#line 439
  tmp___6 = htoi((unsigned char *)(& h->reserved2), 1);
#line 439
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved2  = %u\t",
          tmp___6);
#line 442
  tmp___7 = htoi((unsigned char *)(& h->csectMiniFat), 1);
#line 442
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"csectMiniFat = %u\t",
          tmp___7);
#line 445
  tmp___8 = htoi((unsigned char *)(& h->miniSectorCutoff), 1);
#line 445
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"miniSectorCutoff = %u\n",
          tmp___8);
#line 448
  tmp___9 = htoi((unsigned char *)(& h->root_start_block), 1);
#line 448
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"root_start_block  = %u\n",
          tmp___9);
#line 451
  tmp___10 = htoi((unsigned char *)(& h->dir_flag), 1);
#line 451
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dir flag = %u\n",
          tmp___10);
#line 454
  tmp___11 = htoi((unsigned char *)(& h->num_FAT_blocks), 1);
#line 454
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# FAT blocks = %u\n",
          tmp___11);
#line 457
  tmp___12 = htoi((unsigned char *)(& h->FAT_next_block), 1);
#line 457
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FAT_next_block = %u\n",
          tmp___12);
#line 460
  tmp___13 = htoi((unsigned char *)(& h->num_extra_FAT_blocks), 1);
#line 460
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# extra FAT blocks = %u\n",
          tmp___13);
#line 463
  x = (int *)(h + 1);
#line 464
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bbd list:");
#line 465
  i = 0;
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < 109)) {
#line 465
      goto while_break;
    }
#line 467
    if (i % 10 == 0) {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 469
    if (*x == -1) {
#line 470
      goto while_break;
    }
    {
#line 471
    tmp___14 = htoi((unsigned char *)x, 1);
#line 471
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%x ",
            tmp___14);
#line 465
    i ++;
#line 465
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\t**************End of header***********\n");
  }
#line 475
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/api.c"
int dump_dirent(int which_one ) 
{ 
  int i ;
  char *p ;
  short unknown ;
  struct OLE_DIR *dir ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 484
  dir = (struct OLE_DIR *)(& buffer[(unsigned long )which_one * sizeof(struct OLE_DIR )]);
#line 485
  if ((int )dir->type == 0) {
#line 486
    return (1);
  }
  {
#line 487
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DIRENT_%d :\t",
          dir_count);
  }
#line 488
  if ((int )dir->type == 5) {
#line 488
    tmp___0 = "root directory";
  } else {
#line 488
    if ((int )dir->type == 1) {
#line 488
      tmp = "directory";
    } else {
#line 488
      tmp = "file";
    }
#line 488
    tmp___0 = tmp;
  }
  {
#line 488
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\t",
          tmp___0);
#line 493
  p = dir->name;
  }
#line 494
  if ((int )*p < 32) {
#line 496
    unknown = *((short *)p);
#line 499
    p += 2;
  }
#line 502
  i = 0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < (int )dir->namsiz)) {
#line 502
      goto while_break;
    }
#line 504
    if (*p) {
#line 504
      if ((int )*p > 31) {
        {
#line 506
        tmp___1 = __ctype_b_loc();
        }
#line 506
        if ((int const   )*(*tmp___1 + (int )*p) & 16384) {
          {
#line 508
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                  (int )*p);
          }
        } else {
          {
#line 512
          printf((char const   */* __restrict  */)"***\tInvalid char %x ***\n", (int )*p);
          }
#line 513
          return (0);
        }
      }
    }
#line 502
    i ++;
#line 502
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 524
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"namsiz  = %u\t",
          (int )dir->namsiz);
#line 525
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"type  = %d\t",
          (int )dir->type);
#line 526
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reserved  = %u\n",
          (int )dir->reserved);
#line 528
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"start block  = %lu\n",
          dir->start_block);
#line 529
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"size  = %lu\n",
          dir->size);
#line 530
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\t**************End of dirent***********\n");
  }
#line 531
  return (1);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
void catch_alarm(int signum ) 
{ 


  {
  {
#line 28
  signal_caught = signum;
#line 29
  signal(signum, & catch_alarm);
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
void register_signal_handler(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;

  {
  {
#line 34
  signal_caught = 0;
#line 36
  tmp = signal(2, & catch_alarm);
  }
#line 36
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))1)) {
    {
#line 37
    signal(2, (void (*)(int  ))1);
    }
  }
  {
#line 38
  tmp___0 = signal(15, & catch_alarm);
  }
#line 38
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
    {
#line 39
    signal(15, (void (*)(int  ))1);
    }
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
void try_msg(void) 
{ 


  {
  {
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s -h` for more information.%s",
          __progname, "\n");
  }
#line 58
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
void usage(void) 
{ 


  {
  {
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s by %s.%s",
          __progname, "1.5.7", "Jesse Kornblum, Kris Kendall, and Nick Mikus", "\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t <type>] [-s <blocks>] [-k <size>] \n\t[-b <size>] [-c <file>] [-o <dir>] [-i <file] %s%s",
          "$", __progname, "\n", "\n");
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-V  - display copyright information and exit%s",
          "\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-t  - specify file type.  (-t jpeg,pdf ...) %s",
          "\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-d  - turn on indirect block detection (for UNIX file-systems) %s",
          "\n");
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-i  - specify input file (default is stdin) %s",
          "\n");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-a  - Write all headers, perform no error detection (corrupted files) %s",
          "\n");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-w  - Only write the audit file, do not write any detected files to the disk %s",
          "\n");
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-o  - set output directory (defaults to %s)%s",
          "output", "\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c  - set configuration file to use (defaults to %s)%s",
          "foremost.conf", "\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-q  - enables quick mode. Search are performed on 512 byte boundaries.%s",
          "\n");
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-Q  - enables quiet mode. Suppress output messages. %s",
          "\n");
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-v  - verbose mode. Logs all messages to screen%s",
          "\n");
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
void process_command_line(int argc , char **argv , f_state *s ) 
{ 
  int i ;
  char *ptr1 ;
  char *ptr2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    i = getopt(argc, (char * const  *)argv, "o:b:c:t:s:i:k:hqmQTadvVw");
    }
#line 104
    if (! (i != -1)) {
#line 104
      goto while_break;
    }
    {
#line 109
    if (i == 118) {
#line 109
      goto case_118;
    }
#line 113
    if (i == 100) {
#line 113
      goto case_100;
    }
#line 117
    if (i == 119) {
#line 117
      goto case_119;
    }
#line 121
    if (i == 97) {
#line 121
      goto case_97;
    }
#line 125
    if (i == 98) {
#line 125
      goto case_98;
    }
#line 129
    if (i == 111) {
#line 129
      goto case_111;
    }
#line 133
    if (i == 113) {
#line 133
      goto case_113;
    }
#line 137
    if (i == 81) {
#line 137
      goto case_81;
    }
#line 141
    if (i == 99) {
#line 141
      goto case_99;
    }
#line 145
    if (i == 109) {
#line 145
      goto case_109;
    }
#line 148
    if (i == 107) {
#line 148
      goto case_107;
    }
#line 152
    if (i == 115) {
#line 152
      goto case_115;
    }
#line 156
    if (i == 105) {
#line 156
      goto case_105;
    }
#line 160
    if (i == 84) {
#line 160
      goto case_84;
    }
#line 164
    if (i == 116) {
#line 164
      goto case_116;
    }
#line 199
    if (i == 104) {
#line 199
      goto case_104;
    }
#line 203
    if (i == 86) {
#line 203
      goto case_86;
    }
#line 212
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 110
    set_mode(s, (off_t )(1 << 1));
    }
#line 111
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 114
    set_mode(s, (off_t )(1 << 3));
    }
#line 115
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 118
    set_mode(s, (off_t )(1 << 6));
    }
#line 119
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 122
    set_mode(s, (off_t )(1 << 5));
    }
#line 123
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 126
    tmp = atoi((char const   *)optarg);
#line 126
    set_block(s, tmp);
    }
#line 127
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 130
    set_output_directory(s, optarg);
    }
#line 131
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 134
    set_mode(s, (off_t )(1 << 4));
    }
#line 135
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 138
    set_mode(s, (off_t )(1 << 2));
    }
#line 139
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 142
    set_config_file(s, optarg);
    }
#line 143
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 146
    set_mode(s, (off_t )(1 << 7));
    }
    case_107: /* CIL Label */ 
    {
#line 149
    tmp___0 = atoi((char const   *)optarg);
#line 149
    set_chunk(s, tmp___0);
    }
#line 150
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 153
    tmp___1 = atoi((char const   *)optarg);
#line 153
    set_skip(s, tmp___1);
    }
#line 154
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 157
    set_input_file(s, optarg);
    }
#line 158
    goto switch_break;
    case_84: /* CIL Label */ 
#line 161
    s->time_stamp = 1;
#line 162
    goto switch_break;
    case_116: /* CIL Label */ 
#line 167
    ptr2 = optarg;
#line 167
    ptr1 = ptr2;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 170
      if (! *ptr2) {
        {
#line 172
        tmp___2 = set_search_def(s, ptr1, 0ULL);
        }
#line 172
        if (! tmp___2) {
          {
#line 174
          usage();
#line 175
          exit(0);
          }
        }
#line 177
        goto while_break___0;
      }
#line 180
      if ((int )*ptr2 == 44) {
        {
#line 182
        *ptr2 = (char )'\000';
#line 183
        tmp___3 = set_search_def(s, ptr1, 0ULL);
        }
#line 183
        if (! tmp___3) {
          {
#line 185
          usage();
#line 186
          exit(0);
          }
        }
#line 189
        tmp___4 = ptr2;
#line 189
        ptr2 ++;
#line 189
        *tmp___4 = (char )',';
#line 190
        ptr1 = ptr2;
      } else {
#line 194
        ptr2 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 197
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 200
    usage();
#line 201
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 204
    printf((char const   */* __restrict  */)"%s%s", "1.5.7", "\n");
#line 209
    printf((char const   */* __restrict  */)"%s", "This program is a work of the US Government. In accordance with 17 USC 105,\r\ncopyright protection is not available for any work of the US Government.\r\nThis is free software; see the source for copying conditions. There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n");
#line 210
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 213
    try_msg();
#line 214
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/foremost-1.5.7/main.c"
int main(int argc , char **argv ) 
{ 
  FILE *testFile ;
  f_state *s ;
  void *tmp ;
  int input_files ;
  char **temp ;
  DIR *dir ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 229
  testFile = (FILE *)((void *)0);
#line 230
  tmp = malloc(sizeof(f_state ));
#line 230
  s = (f_state *)tmp;
#line 231
  input_files = 0;
#line 232
  temp = argv;
#line 240
  tmp___0 = initialize_state(s, argc, argv);
  }
#line 240
  if (tmp___0) {
    {
#line 241
    fatal_error(s, (char *)"Unable to initialize state");
    }
  }
  {
#line 243
  register_signal_handler();
#line 244
  process_command_line(argc, argv, s);
#line 246
  load_config_file(s);
  }
#line 248
  if (s->num_builtin == 0) {
    {
#line 253
    set_search_def(s, (char *)"all", 0ULL);
    }
  }
  {
#line 256
  tmp___1 = create_output_directory(s);
  }
#line 256
  if (tmp___1) {
    {
#line 257
    fatal_error(s, (char *)"Unable to open output directory");
    }
  }
  {
#line 259
  tmp___2 = get_mode(s, (off_t )(1 << 6));
  }
#line 259
  if (! tmp___2) {
    {
#line 261
    create_sub_dirs(s);
    }
  }
  {
#line 264
  tmp___3 = open_audit_file(s);
  }
#line 264
  if (tmp___3) {
    {
#line 265
    fatal_error(s, (char *)"Can\'t open audit file");
    }
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 268
      goto while_break;
    }
    {
#line 270
    tmp___4 = strcmp((char const   *)*argv, "-c");
    }
#line 270
    if (tmp___4 == 0) {
#line 273
      argv += 2;
    }
    {
#line 275
    testFile = fopen((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"rb");
    }
#line 276
    if (testFile) {
      {
#line 278
      fclose(testFile);
#line 279
      dir = opendir((char const   *)*argv);
#line 281
      tmp___5 = strstr((char const   *)s->config_file, (char const   *)*argv);
      }
#line 281
      if (tmp___5) {
#line 281
        tmp___6 = 0;
      } else {
#line 281
        tmp___6 = 1;
      }
#line 281
      if (tmp___6 != 0) {
#line 281
        if (! dir) {
#line 283
          input_files ++;
        }
      }
#line 286
      if (dir) {
        {
#line 286
        closedir(dir);
        }
      }
    }
#line 289
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  argv = temp;
#line 293
  if (input_files > 1) {
    {
#line 295
    set_mode(s, (off_t )(1 << 7));
    }
  }
#line 298
  argv ++;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 299
      goto while_break___0;
    }
    {
#line 301
    testFile = fopen((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"rb");
    }
#line 303
    if (testFile) {
      {
#line 305
      fclose(testFile);
#line 306
      dir = opendir((char const   *)*argv);
#line 307
      tmp___7 = strstr((char const   *)s->config_file, (char const   *)*argv);
      }
#line 307
      if (tmp___7) {
#line 307
        tmp___8 = 0;
      } else {
#line 307
        tmp___8 = 1;
      }
#line 307
      if (tmp___8 != 0) {
#line 307
        if (! dir) {
          {
#line 309
          set_input_file(s, *argv);
#line 310
          process_file(s);
          }
        }
      }
#line 312
      if (dir) {
        {
#line 312
        closedir(dir);
        }
      }
    }
#line 315
    argv ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 318
  if (input_files == 0) {
    {
#line 322
    process_stdin(s);
    }
  }
  {
#line 325
  print_stats(s);
#line 328
  cleanup_output(s);
#line 330
  tmp___9 = close_audit_file(s);
  }
#line 330
  if (tmp___9) {
    {
#line 335
    print_error(s, (char *)"audit.txt", (char *)"Error closing audit file");
    }
  }
  {
#line 338
  free_state(s);
#line 339
  free((void *)s);
  }
#line 340
  return (0);
}
}
