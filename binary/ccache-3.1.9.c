/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.h"
struct mdfour {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   size_t totalN ;
   unsigned char tail[64] ;
   size_t tail_len ;
   int finalized ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 208 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 208 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 218 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
struct exit_function {
   void (*function)(void * ) ;
   void *context ;
   struct exit_function *next ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
struct nullary_exit_function {
   void (*function)(void) ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
struct __anonstruct_extensions_57 {
   char const   *extension ;
   char const   *language ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
struct __anonstruct_languages_58 {
   char const   *language ;
   char const   *p_language ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 93 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 385 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void const   *voidpc;
#line 387 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidp;
#line 1224 "/usr/include/zlib.h"
struct gzFile_s;
#line 1224 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1670 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 29 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
struct compopt {
   char const   *name ;
   int type ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
struct files {
   char *fname ;
   time_t mtime ;
   size_t size ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/counters.h"
struct counters {
   unsigned int *data ;
   size_t size ;
   size_t allocated ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
enum stats {
    STATS_NONE = 0,
    STATS_STDOUT = 1,
    STATS_STATUS = 2,
    STATS_ERROR = 3,
    STATS_TOCACHE = 4,
    STATS_PREPROCESSOR = 5,
    STATS_COMPILER = 6,
    STATS_MISSING = 7,
    STATS_CACHEHIT_CPP = 8,
    STATS_ARGS = 9,
    STATS_LINK = 10,
    STATS_NUMFILES = 11,
    STATS_TOTALSIZE = 12,
    STATS_MAXFILES = 13,
    STATS_MAXSIZE = 14,
    STATS_SOURCELANG = 15,
    STATS_DEVICE = 16,
    STATS_NOINPUT = 17,
    STATS_MULTIPLE = 18,
    STATS_CONFTEST = 19,
    STATS_UNSUPPORTED = 20,
    STATS_OUTSTDOUT = 21,
    STATS_CACHEHIT_DIR = 22,
    STATS_NOOUTPUT = 23,
    STATS_EMPTYOUTPUT = 24,
    STATS_BADEXTRAFILE = 25,
    STATS_COMPCHECK = 26,
    STATS_CANTUSEPCH = 27,
    STATS_PREPROCESSING = 28,
    STATS_END = 29
} ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
struct __anonstruct_stats_info_57 {
   enum stats stat ;
   char *message ;
   void (*fn)(size_t  ) ;
   unsigned int flags ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
struct args {
   char **argv ;
   int argc ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.h"
struct hashtable;
#line 9 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_private.h"
struct entry {
   void *k ;
   void *v ;
   unsigned int h ;
   struct entry *next ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_private.h"
struct hashtable {
   unsigned int tablelength ;
   struct entry **table ;
   unsigned int entrycount ;
   unsigned int loadlimit ;
   unsigned int primeindex ;
   unsigned int (*hashfn)(void *k ) ;
   int (*eqfn)(void *k1 , void *k2 ) ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.h"
struct hashtable_itr {
   struct hashtable *h ;
   struct entry *e ;
   struct entry *parent ;
   unsigned int index ;
};
#line 7 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.h"
struct file_hash {
   uint8_t hash[16] ;
   uint32_t size ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
enum fromcache_call_mode {
    FROMCACHE_DIRECT_MODE = 0,
    FROMCACHE_CPP_MODE = 1,
    FROMCACHE_COMPILED_MODE = 2
} ;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 72 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
struct file_info {
   uint32_t index ;
   uint8_t hash[16] ;
   uint32_t size ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
struct object {
   uint32_t n_file_info_indexes ;
   uint32_t *file_info_indexes ;
   struct file_hash hash ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
struct manifest {
   uint8_t hash_size ;
   uint32_t n_files ;
   char **files ;
   uint32_t n_file_infos ;
   struct file_info *file_infos ;
   uint32_t n_objects ;
   struct object *objects ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
struct __anonstruct_tokens_57 {
   unsigned char type ;
   unsigned char num_toks ;
   char const   *toks[7] ;
};
#line 281 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
union __anonunion_57___0 {
   int __in ;
   int __i ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
union __anonunion_58___0 {
   int __in ;
   int __i ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
union __anonunion_59___0 {
   int __in ;
   int __i ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.h"
void mdfour_begin(struct mdfour *md ) ;
#line 16
void mdfour_update(struct mdfour *md , unsigned char const   *in , size_t n ) ;
#line 17
void mdfour_result(struct mdfour *md , unsigned char *out ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
static struct mdfour *m  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
static void mdfour64(uint32_t *M ) 
{ 
  uint32_t AA ;
  uint32_t BB ;
  uint32_t CC ;
  uint32_t DD ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;

  {
#line 43
  A = m->A;
#line 43
  B = m->B;
#line 43
  C = m->C;
#line 43
  D = m->D;
#line 44
  AA = A;
#line 44
  BB = B;
#line 44
  CC = C;
#line 44
  DD = D;
#line 46
  A = (((((A + ((B & C) | (~ B & D))) + *(M + 0)) & 4294967295U) << 3) & 4294967295U) | (((((A + ((B & C) | (~ B & D))) + *(M + 0)) & 4294967295U) >> 29) & 4294967295U);
#line 46
  D = (((((D + ((A & B) | (~ A & C))) + *(M + 1)) & 4294967295U) << 7) & 4294967295U) | (((((D + ((A & B) | (~ A & C))) + *(M + 1)) & 4294967295U) >> 25) & 4294967295U);
#line 47
  C = (((((C + ((D & A) | (~ D & B))) + *(M + 2)) & 4294967295U) << 11) & 4294967295U) | (((((C + ((D & A) | (~ D & B))) + *(M + 2)) & 4294967295U) >> 21) & 4294967295U);
#line 47
  B = (((((B + ((C & D) | (~ C & A))) + *(M + 3)) & 4294967295U) << 19) & 4294967295U) | (((((B + ((C & D) | (~ C & A))) + *(M + 3)) & 4294967295U) >> 13) & 4294967295U);
#line 48
  A = (((((A + ((B & C) | (~ B & D))) + *(M + 4)) & 4294967295U) << 3) & 4294967295U) | (((((A + ((B & C) | (~ B & D))) + *(M + 4)) & 4294967295U) >> 29) & 4294967295U);
#line 48
  D = (((((D + ((A & B) | (~ A & C))) + *(M + 5)) & 4294967295U) << 7) & 4294967295U) | (((((D + ((A & B) | (~ A & C))) + *(M + 5)) & 4294967295U) >> 25) & 4294967295U);
#line 49
  C = (((((C + ((D & A) | (~ D & B))) + *(M + 6)) & 4294967295U) << 11) & 4294967295U) | (((((C + ((D & A) | (~ D & B))) + *(M + 6)) & 4294967295U) >> 21) & 4294967295U);
#line 49
  B = (((((B + ((C & D) | (~ C & A))) + *(M + 7)) & 4294967295U) << 19) & 4294967295U) | (((((B + ((C & D) | (~ C & A))) + *(M + 7)) & 4294967295U) >> 13) & 4294967295U);
#line 50
  A = (((((A + ((B & C) | (~ B & D))) + *(M + 8)) & 4294967295U) << 3) & 4294967295U) | (((((A + ((B & C) | (~ B & D))) + *(M + 8)) & 4294967295U) >> 29) & 4294967295U);
#line 50
  D = (((((D + ((A & B) | (~ A & C))) + *(M + 9)) & 4294967295U) << 7) & 4294967295U) | (((((D + ((A & B) | (~ A & C))) + *(M + 9)) & 4294967295U) >> 25) & 4294967295U);
#line 51
  C = (((((C + ((D & A) | (~ D & B))) + *(M + 10)) & 4294967295U) << 11) & 4294967295U) | (((((C + ((D & A) | (~ D & B))) + *(M + 10)) & 4294967295U) >> 21) & 4294967295U);
#line 51
  B = (((((B + ((C & D) | (~ C & A))) + *(M + 11)) & 4294967295U) << 19) & 4294967295U) | (((((B + ((C & D) | (~ C & A))) + *(M + 11)) & 4294967295U) >> 13) & 4294967295U);
#line 52
  A = (((((A + ((B & C) | (~ B & D))) + *(M + 12)) & 4294967295U) << 3) & 4294967295U) | (((((A + ((B & C) | (~ B & D))) + *(M + 12)) & 4294967295U) >> 29) & 4294967295U);
#line 52
  D = (((((D + ((A & B) | (~ A & C))) + *(M + 13)) & 4294967295U) << 7) & 4294967295U) | (((((D + ((A & B) | (~ A & C))) + *(M + 13)) & 4294967295U) >> 25) & 4294967295U);
#line 53
  C = (((((C + ((D & A) | (~ D & B))) + *(M + 14)) & 4294967295U) << 11) & 4294967295U) | (((((C + ((D & A) | (~ D & B))) + *(M + 14)) & 4294967295U) >> 21) & 4294967295U);
#line 53
  B = (((((B + ((C & D) | (~ C & A))) + *(M + 15)) & 4294967295U) << 19) & 4294967295U) | (((((B + ((C & D) | (~ C & A))) + *(M + 15)) & 4294967295U) >> 13) & 4294967295U);
#line 56
  A = ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 0)) + 1518500249U) & 4294967295U) << 3) & 4294967295U) | ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 0)) + 1518500249U) & 4294967295U) >> 29) & 4294967295U);
#line 56
  D = ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 4)) + 1518500249U) & 4294967295U) << 5) & 4294967295U) | ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 4)) + 1518500249U) & 4294967295U) >> 27) & 4294967295U);
#line 57
  C = ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 8)) + 1518500249U) & 4294967295U) << 9) & 4294967295U) | ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 8)) + 1518500249U) & 4294967295U) >> 23) & 4294967295U);
#line 57
  B = ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 12)) + 1518500249U) & 4294967295U) << 13) & 4294967295U) | ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 12)) + 1518500249U) & 4294967295U) >> 19) & 4294967295U);
#line 58
  A = ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 1)) + 1518500249U) & 4294967295U) << 3) & 4294967295U) | ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 1)) + 1518500249U) & 4294967295U) >> 29) & 4294967295U);
#line 58
  D = ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 5)) + 1518500249U) & 4294967295U) << 5) & 4294967295U) | ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 5)) + 1518500249U) & 4294967295U) >> 27) & 4294967295U);
#line 59
  C = ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 9)) + 1518500249U) & 4294967295U) << 9) & 4294967295U) | ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 9)) + 1518500249U) & 4294967295U) >> 23) & 4294967295U);
#line 59
  B = ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 13)) + 1518500249U) & 4294967295U) << 13) & 4294967295U) | ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 13)) + 1518500249U) & 4294967295U) >> 19) & 4294967295U);
#line 60
  A = ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 2)) + 1518500249U) & 4294967295U) << 3) & 4294967295U) | ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 2)) + 1518500249U) & 4294967295U) >> 29) & 4294967295U);
#line 60
  D = ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 6)) + 1518500249U) & 4294967295U) << 5) & 4294967295U) | ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 6)) + 1518500249U) & 4294967295U) >> 27) & 4294967295U);
#line 61
  C = ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 10)) + 1518500249U) & 4294967295U) << 9) & 4294967295U) | ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 10)) + 1518500249U) & 4294967295U) >> 23) & 4294967295U);
#line 61
  B = ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 14)) + 1518500249U) & 4294967295U) << 13) & 4294967295U) | ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 14)) + 1518500249U) & 4294967295U) >> 19) & 4294967295U);
#line 62
  A = ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 3)) + 1518500249U) & 4294967295U) << 3) & 4294967295U) | ((((((A + (((B & C) | (B & D)) | (C & D))) + *(M + 3)) + 1518500249U) & 4294967295U) >> 29) & 4294967295U);
#line 62
  D = ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 7)) + 1518500249U) & 4294967295U) << 5) & 4294967295U) | ((((((D + (((A & B) | (A & C)) | (B & C))) + *(M + 7)) + 1518500249U) & 4294967295U) >> 27) & 4294967295U);
#line 63
  C = ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 11)) + 1518500249U) & 4294967295U) << 9) & 4294967295U) | ((((((C + (((D & A) | (D & B)) | (A & B))) + *(M + 11)) + 1518500249U) & 4294967295U) >> 23) & 4294967295U);
#line 63
  B = ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 15)) + 1518500249U) & 4294967295U) << 13) & 4294967295U) | ((((((B + (((C & D) | (C & A)) | (D & A))) + *(M + 15)) + 1518500249U) & 4294967295U) >> 19) & 4294967295U);
#line 65
  A = ((((((A + ((B ^ C) ^ D)) + *(M + 0)) + 1859775393U) & 4294967295U) << 3) & 4294967295U) | ((((((A + ((B ^ C) ^ D)) + *(M + 0)) + 1859775393U) & 4294967295U) >> 29) & 4294967295U);
#line 65
  D = ((((((D + ((A ^ B) ^ C)) + *(M + 8)) + 1859775393U) & 4294967295U) << 9) & 4294967295U) | ((((((D + ((A ^ B) ^ C)) + *(M + 8)) + 1859775393U) & 4294967295U) >> 23) & 4294967295U);
#line 66
  C = ((((((C + ((D ^ A) ^ B)) + *(M + 4)) + 1859775393U) & 4294967295U) << 11) & 4294967295U) | ((((((C + ((D ^ A) ^ B)) + *(M + 4)) + 1859775393U) & 4294967295U) >> 21) & 4294967295U);
#line 66
  B = ((((((B + ((C ^ D) ^ A)) + *(M + 12)) + 1859775393U) & 4294967295U) << 15) & 4294967295U) | ((((((B + ((C ^ D) ^ A)) + *(M + 12)) + 1859775393U) & 4294967295U) >> 17) & 4294967295U);
#line 67
  A = ((((((A + ((B ^ C) ^ D)) + *(M + 2)) + 1859775393U) & 4294967295U) << 3) & 4294967295U) | ((((((A + ((B ^ C) ^ D)) + *(M + 2)) + 1859775393U) & 4294967295U) >> 29) & 4294967295U);
#line 67
  D = ((((((D + ((A ^ B) ^ C)) + *(M + 10)) + 1859775393U) & 4294967295U) << 9) & 4294967295U) | ((((((D + ((A ^ B) ^ C)) + *(M + 10)) + 1859775393U) & 4294967295U) >> 23) & 4294967295U);
#line 68
  C = ((((((C + ((D ^ A) ^ B)) + *(M + 6)) + 1859775393U) & 4294967295U) << 11) & 4294967295U) | ((((((C + ((D ^ A) ^ B)) + *(M + 6)) + 1859775393U) & 4294967295U) >> 21) & 4294967295U);
#line 68
  B = ((((((B + ((C ^ D) ^ A)) + *(M + 14)) + 1859775393U) & 4294967295U) << 15) & 4294967295U) | ((((((B + ((C ^ D) ^ A)) + *(M + 14)) + 1859775393U) & 4294967295U) >> 17) & 4294967295U);
#line 69
  A = ((((((A + ((B ^ C) ^ D)) + *(M + 1)) + 1859775393U) & 4294967295U) << 3) & 4294967295U) | ((((((A + ((B ^ C) ^ D)) + *(M + 1)) + 1859775393U) & 4294967295U) >> 29) & 4294967295U);
#line 69
  D = ((((((D + ((A ^ B) ^ C)) + *(M + 9)) + 1859775393U) & 4294967295U) << 9) & 4294967295U) | ((((((D + ((A ^ B) ^ C)) + *(M + 9)) + 1859775393U) & 4294967295U) >> 23) & 4294967295U);
#line 70
  C = ((((((C + ((D ^ A) ^ B)) + *(M + 5)) + 1859775393U) & 4294967295U) << 11) & 4294967295U) | ((((((C + ((D ^ A) ^ B)) + *(M + 5)) + 1859775393U) & 4294967295U) >> 21) & 4294967295U);
#line 70
  B = ((((((B + ((C ^ D) ^ A)) + *(M + 13)) + 1859775393U) & 4294967295U) << 15) & 4294967295U) | ((((((B + ((C ^ D) ^ A)) + *(M + 13)) + 1859775393U) & 4294967295U) >> 17) & 4294967295U);
#line 71
  A = ((((((A + ((B ^ C) ^ D)) + *(M + 3)) + 1859775393U) & 4294967295U) << 3) & 4294967295U) | ((((((A + ((B ^ C) ^ D)) + *(M + 3)) + 1859775393U) & 4294967295U) >> 29) & 4294967295U);
#line 71
  D = ((((((D + ((A ^ B) ^ C)) + *(M + 11)) + 1859775393U) & 4294967295U) << 9) & 4294967295U) | ((((((D + ((A ^ B) ^ C)) + *(M + 11)) + 1859775393U) & 4294967295U) >> 23) & 4294967295U);
#line 72
  C = ((((((C + ((D ^ A) ^ B)) + *(M + 7)) + 1859775393U) & 4294967295U) << 11) & 4294967295U) | ((((((C + ((D ^ A) ^ B)) + *(M + 7)) + 1859775393U) & 4294967295U) >> 21) & 4294967295U);
#line 72
  B = ((((((B + ((C ^ D) ^ A)) + *(M + 15)) + 1859775393U) & 4294967295U) << 15) & 4294967295U) | ((((((B + ((C ^ D) ^ A)) + *(M + 15)) + 1859775393U) & 4294967295U) >> 17) & 4294967295U);
#line 74
  A += AA;
#line 74
  B += BB;
#line 75
  C += CC;
#line 75
  D += DD;
#line 77
  A &= 4294967295U;
#line 77
  B &= 4294967295U;
#line 78
  C &= 4294967295U;
#line 78
  D &= 4294967295U;
#line 80
  m->A = A;
#line 80
  m->B = B;
#line 80
  m->C = C;
#line 80
  m->D = D;
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
static void copy64(uint32_t *M , unsigned char const   *in ) 
{ 
  int i ;

  {
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < 16)) {
#line 88
      goto while_break;
    }
#line 89
    *(M + i) = (uint32_t )(((((int const   )*(in + (i * 4 + 3)) << 24) | ((int const   )*(in + (i * 4 + 2)) << 16)) | ((int const   )*(in + (i * 4 + 1)) << 8)) | (int const   )*(in + i * 4));
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
static void copy4(unsigned char *out , uint32_t x ) 
{ 


  {
#line 96
  *(out + 0) = (unsigned char )(x & 255U);
#line 97
  *(out + 1) = (unsigned char )((x >> 8) & 255U);
#line 98
  *(out + 2) = (unsigned char )((x >> 16) & 255U);
#line 99
  *(out + 3) = (unsigned char )((x >> 24) & 255U);
#line 100
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
void mdfour_begin(struct mdfour *md ) 
{ 


  {
#line 105
  md->A = (uint32_t )1732584193;
#line 106
  md->B = 4023233417U;
#line 107
  md->C = 2562383102U;
#line 108
  md->D = (uint32_t )271733878;
#line 109
  md->totalN = (size_t )0;
#line 110
  md->tail_len = (size_t )0;
#line 111
  md->finalized = 0;
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
static void mdfour_tail(unsigned char const   *in , size_t n ) 
{ 
  unsigned char buf___0[128] ;
  unsigned int tmp ;
  uint32_t M[16] ;
  uint32_t b ;

  {
#line 117
  buf___0[0] = (unsigned char)0;
#line 117
  tmp = 1U;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (tmp >= 128U) {
#line 117
      goto while_break;
    }
#line 117
    buf___0[tmp] = (unsigned char)0;
#line 117
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  m->totalN += n;
#line 123
  b = (uint32_t )(m->totalN * 8UL);
#line 125
  if (n) {
    {
#line 125
    memcpy((void */* __restrict  */)(buf___0), (void const   */* __restrict  */)in,
           n);
    }
  }
#line 126
  buf___0[n] = (unsigned char)128;
#line 128
  if (n <= 55UL) {
    {
#line 129
    copy4(buf___0 + 56, b);
#line 130
    copy64(M, (unsigned char const   *)(buf___0));
#line 131
    mdfour64(M);
    }
  } else {
    {
#line 133
    copy4(buf___0 + 120, b);
#line 134
    copy64(M, (unsigned char const   *)(buf___0));
#line 135
    mdfour64(M);
#line 136
    copy64(M, (unsigned char const   *)(buf___0 + 64));
#line 137
    mdfour64(M);
    }
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
void mdfour_update(struct mdfour *md , unsigned char const   *in , size_t n ) 
{ 
  uint32_t M[16] ;
  size_t len___0 ;

  {
#line 154
  m = md;
#line 156
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 157
    if (! md->finalized) {
      {
#line 158
      mdfour_tail((unsigned char const   *)(md->tail), md->tail_len);
#line 159
      md->finalized = 1;
      }
    }
#line 161
    return;
  }
#line 164
  if (md->tail_len) {
#line 165
    len___0 = 64UL - md->tail_len;
#line 166
    if (len___0 > n) {
#line 166
      len___0 = n;
    }
    {
#line 167
    memcpy((void */* __restrict  */)(md->tail + md->tail_len), (void const   */* __restrict  */)in,
           len___0);
#line 168
    md->tail_len += len___0;
#line 169
    n -= len___0;
#line 170
    in += len___0;
    }
#line 171
    if (md->tail_len == 64UL) {
      {
#line 172
      copy64(M, (unsigned char const   *)(md->tail));
#line 173
      mdfour64(M);
#line 174
      m->totalN += 64UL;
#line 175
      md->tail_len = (size_t )0;
      }
    }
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (n >= 64UL)) {
#line 179
      goto while_break;
    }
    {
#line 180
    copy64(M, in);
#line 181
    mdfour64(M);
#line 182
    in += 64;
#line 183
    n -= 64UL;
#line 184
    m->totalN += 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if (n) {
    {
#line 188
    memcpy((void */* __restrict  */)(md->tail), (void const   */* __restrict  */)in,
           n);
#line 189
    md->tail_len = n;
    }
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/mdfour.c"
void mdfour_result(struct mdfour *md , unsigned char *out ) 
{ 


  {
  {
#line 196
  copy4(out, md->A);
#line 197
  copy4(out + 4, md->B);
#line 198
  copy4(out + 8, md->C);
#line 199
  copy4(out + 12, md->D);
  }
#line 200
  return;
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/murmurhashneutral2.h"
unsigned int murmurhashneutral2(void const   *key , int len___0 , unsigned int seed ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/murmurhashneutral2.c"
unsigned int murmurhashneutral2(void const   *key , int len___0 , unsigned int seed ) 
{ 
  unsigned int m___0 ;
  int r ;
  unsigned int h ;
  unsigned char const   *data ;
  unsigned int k ;

  {
#line 11
  m___0 = 1540483477U;
#line 12
  r = 24;
#line 14
  h = seed ^ (unsigned int )len___0;
#line 16
  data = (unsigned char const   *)key;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (len___0 >= 4)) {
#line 18
      goto while_break;
    }
#line 21
    k = (unsigned int )*(data + 0);
#line 22
    k |= (unsigned int )((int const   )*(data + 1) << 8);
#line 23
    k |= (unsigned int )((int const   )*(data + 2) << 16);
#line 24
    k |= (unsigned int )((int const   )*(data + 3) << 24);
#line 26
    k *= m___0;
#line 27
    k ^= k >> r;
#line 28
    k *= m___0;
#line 30
    h *= m___0;
#line 31
    h ^= k;
#line 33
    data += 4;
#line 34
    len___0 -= 4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  if (len___0 == 3) {
#line 39
    goto case_3;
  }
#line 40
  if (len___0 == 2) {
#line 40
    goto case_2;
  }
#line 41
  if (len___0 == 1) {
#line 41
    goto case_1;
  }
#line 37
  goto switch_break;
  case_3: /* CIL Label */ 
#line 39
  h ^= (unsigned int )((int const   )*(data + 2) << 16);
  case_2: /* CIL Label */ 
#line 40
  h ^= (unsigned int )((int const   )*(data + 1) << 8);
  case_1: /* CIL Label */ 
#line 41
  h ^= (unsigned int )*(data + 0);
#line 42
  h *= m___0;
  switch_break: /* CIL Label */ ;
  }
#line 45
  h ^= h >> 13;
#line 46
  h *= m___0;
#line 47
  h ^= h >> 15;
#line 49
  return (h);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 604
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *s ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void ( /* format attribute */  cc_log)(char const   *format___0  , ...) ;
#line 102
void cc_log_argv(char const   *prefix , char **argv ) ;
#line 103
void ( /* format attribute */  fatal)(char const   *format___0  , ...) ;
#line 118
char *( /* format attribute */  format)(char const   *format___0  , ...) ;
#line 119
char *x_strdup(char const   *s ) ;
#line 131
char *x_realpath(char const   *path ) ;
#line 139
_Bool is_absolute_path(char const   *path ) ;
#line 144
int tmp_unlink(char const   *path ) ;
#line 189
int execute(char **argv , char const   *path_stdout , char const   *path_stderr ) ;
#line 192
char *find_executable(char const   *name , char const   *exclude_name ) ;
#line 193
void print_command(FILE *fp , char **argv ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
static char *find_executable_in_path(char const   *name , char const   *exclude_name ,
                                     char *path ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
int execute(char **argv , char const   *path_stdout , char const   *path_stderr ) 
{ 
  pid_t pid ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  int fd ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  __pid_t tmp___8 ;
  union __anonunion_57 __constr_expr_0 ;
  union __anonunion_58 __constr_expr_1 ;
  union __anonunion_59 __constr_expr_2 ;

  {
  {
#line 175
  cc_log_argv("Executing ", argv);
#line 177
  pid = fork();
  }
#line 178
  if (pid == -1) {
    {
#line 178
    tmp = __errno_location();
#line 178
    tmp___0 = strerror(*tmp);
#line 178
    fatal("Failed to fork: %s", tmp___0);
    }
  }
#line 180
  if (pid == 0) {
    {
#line 183
    tmp_unlink(path_stdout);
#line 184
    fd = open(path_stdout, 705, 438);
    }
#line 185
    if (fd == -1) {
      {
#line 186
      tmp___1 = __errno_location();
#line 186
      tmp___2 = strerror(*tmp___1);
#line 186
      cc_log("Error creating %s: %s", path_stdout, tmp___2);
#line 187
      exit(212);
      }
    }
    {
#line 189
    dup2(fd, 1);
#line 190
    close(fd);
#line 192
    tmp_unlink(path_stderr);
#line 193
    fd = open(path_stderr, 705, 438);
    }
#line 194
    if (fd == -1) {
      {
#line 195
      tmp___3 = __errno_location();
#line 195
      tmp___4 = strerror(*tmp___3);
#line 195
      cc_log("Error creating %s: %s", path_stderr, tmp___4);
#line 196
      exit(213);
      }
    }
    {
#line 198
    dup2(fd, 2);
#line 199
    close(fd);
#line 201
    tmp___5 = execv((char const   *)*(argv + 0), (char * const  *)argv);
#line 201
    exit(tmp___5);
    }
  }
  {
#line 204
  tmp___8 = waitpid(pid, & status, 0);
  }
#line 204
  if (tmp___8 != pid) {
    {
#line 205
    tmp___6 = __errno_location();
#line 205
    tmp___7 = strerror(*tmp___6);
#line 205
    fatal("waitpid failed: %s", tmp___7);
    }
  }
#line 208
  __constr_expr_0.__in = status;
#line 208
  if ((__constr_expr_0.__i & 65280) >> 8 == 0) {
#line 208
    __constr_expr_1.__in = status;
#line 208
    if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 209
      return (-1);
    }
  }
#line 212
  if (status == 212) {
    {
#line 213
    fatal("Could not create %s (permission denied?)", path_stdout);
    }
  } else
#line 214
  if (status == 213) {
    {
#line 215
    fatal("Could not create %s (permission denied?)", path_stderr);
    }
  }
#line 218
  __constr_expr_2.__in = status;
#line 218
  return ((__constr_expr_2.__i & 65280) >> 8);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
char *find_executable(char const   *name , char const   *exclude_name ) 
{ 
  char *path ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 232
  tmp___0 = is_absolute_path(name);
  }
#line 232
  if (tmp___0) {
    {
#line 233
    tmp = x_strdup(name);
    }
#line 233
    return (tmp);
  }
  {
#line 236
  path = getenv("CCACHE_PATH");
  }
#line 237
  if (! path) {
    {
#line 238
    path = getenv("PATH");
    }
  }
#line 240
  if (! path) {
    {
#line 241
    cc_log("No PATH variable");
    }
#line 242
    return ((char *)((void *)0));
  }
  {
#line 245
  tmp___1 = find_executable_in_path(name, exclude_name, path);
  }
#line 245
  return (tmp___1);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
static char *find_executable_in_path(char const   *name , char const   *exclude_name ,
                                     char *path ) 
{ 
  char *tok ;
  char *saveptr ;
  struct stat st1 ;
  struct stat st2 ;
  char *fname ;
  char *tmp ;
  char *buf___0 ;
  char *tmp___0 ;
  char *p ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 251
  saveptr = (char *)((void *)0);
#line 253
  path = x_strdup((char const   *)path);
#line 257
  tok = strtok_r((char */* __restrict  */)path, (char const   */* __restrict  */)":",
                 (char **/* __restrict  */)(& saveptr));
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! tok) {
#line 257
      goto while_break;
    }
    {
#line 274
    tmp = format("%s/%s", tok, name);
#line 274
    fname = tmp;
#line 276
    tmp___3 = access((char const   *)fname, 1);
    }
#line 276
    if (tmp___3 == 0) {
      {
#line 276
      tmp___4 = lstat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& st1));
      }
#line 276
      if (tmp___4 == 0) {
        {
#line 276
        tmp___5 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& st2));
        }
#line 276
        if (tmp___5 == 0) {
#line 276
          if ((st2.st_mode & 61440U) == 32768U) {
#line 280
            if ((st1.st_mode & 61440U) == 40960U) {
              {
#line 281
              tmp___0 = x_realpath((char const   *)fname);
#line 281
              buf___0 = tmp___0;
              }
#line 282
              if (buf___0) {
                {
#line 283
                tmp___1 = basename((char const   *)buf___0);
#line 283
                p = tmp___1;
#line 284
                tmp___2 = strcmp((char const   *)p, exclude_name);
                }
#line 284
                if (tmp___2 == 0) {
                  {
#line 286
                  free((void *)p);
#line 287
                  free((void *)buf___0);
                  }
#line 288
                  goto __Cont;
                }
                {
#line 290
                free((void *)buf___0);
#line 291
                free((void *)p);
                }
              }
            }
            {
#line 296
            free((void *)path);
            }
#line 297
            return (fname);
          }
        }
      }
    }
    {
#line 299
    free((void *)fname);
    }
    __Cont: /* CIL Label */ 
    {
#line 257
    tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                   (char **/* __restrict  */)(& saveptr));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  free((void *)path);
  }
#line 304
  return ((char *)((void *)0));
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/execute.c"
void print_command(FILE *fp , char **argv ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! *(argv + i)) {
#line 311
      goto while_break;
    }
#line 312
    if (i == 0) {
#line 312
      tmp = "";
    } else {
#line 312
      tmp = " ";
    }
    {
#line 312
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s",
            tmp, *(argv + i));
#line 311
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 315
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/main.c"
int ccache_main(int argc , char **argv ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 27
  tmp = ccache_main(argc, argv);
  }
#line 27
  return (tmp);
}
}
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 122 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void *x_malloc(size_t size ) ;
#line 174
void exitfn_init(void) ;
#line 175
void exitfn_add_nullary(void (*function)(void) ) ;
#line 176
void exitfn_add(void (*function)(void * ) , void *context ) ;
#line 177
void exitfn_call(void) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
static struct exit_function *exit_functions  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
static void call_nullary_exit_function(void *context ) 
{ 
  struct nullary_exit_function *p ;

  {
  {
#line 36
  p = (struct nullary_exit_function *)context;
#line 37
  (*(p->function))();
#line 38
  free((void *)p);
  }
#line 39
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
void exitfn_init(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 47
  tmp___1 = atexit(& exitfn_call);
  }
#line 47
  if (tmp___1 != 0) {
    {
#line 48
    tmp = __errno_location();
#line 48
    tmp___0 = strerror(*tmp);
#line 48
    fatal("atexit failed: %s", tmp___0);
    }
  }
#line 50
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
void exitfn_add_nullary(void (*function)(void) ) 
{ 
  struct nullary_exit_function *p ;
  void *tmp ;

  {
  {
#line 59
  tmp = x_malloc(sizeof(*p));
#line 59
  p = (struct nullary_exit_function *)tmp;
#line 60
  p->function = function;
#line 61
  exitfn_add(& call_nullary_exit_function, (void *)p);
  }
#line 62
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
void exitfn_add(void (*function)(void * ) , void *context ) 
{ 
  struct exit_function *p ;
  void *tmp ;

  {
  {
#line 73
  tmp = x_malloc(sizeof(*p));
#line 73
  p = (struct exit_function *)tmp;
#line 74
  p->function = function;
#line 75
  p->context = context;
#line 76
  p->next = exit_functions;
#line 77
  exit_functions = p;
  }
#line 78
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/exitfn.c"
void exitfn_call(void) 
{ 
  struct exit_function *p ;
  struct exit_function *q ;

  {
#line 86
  p = exit_functions;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! p) {
#line 87
      goto while_break;
    }
    {
#line 88
    (*(p->function))(p->context);
#line 89
    q = p;
#line 90
    p = p->next;
#line 91
    free((void *)q);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  exit_functions = (struct exit_function *)((void *)0);
#line 94
  return;
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/version.c"
char const   CCACHE_VERSION[6]  = {      (char const   )'3',      (char const   )'.',      (char const   )'1',      (char const   )'.', 
        (char const   )'9',      (char const   )'\000'};
#line 127 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
char const   *get_extension(char const   *path ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
static struct __anonstruct_extensions_57  const  extensions[34]  = 
#line 25 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
  {      {".c", "c"}, 
        {".C", "c++"}, 
        {".cc", "c++"}, 
        {".CC", "c++"}, 
        {".cp", "c++"}, 
        {".CP", "c++"}, 
        {".cpp", "c++"}, 
        {".CPP", "c++"}, 
        {".cxx", "c++"}, 
        {".CXX", "c++"}, 
        {".c++", "c++"}, 
        {".C++", "c++"}, 
        {".m", "objective-c"}, 
        {".M", "objective-c++"}, 
        {".mm", "objective-c++"}, 
        {".i", "cpp-output"}, 
        {".ii", "c++-cpp-output"}, 
        {".mi", "objc-cpp-output"}, 
        {".mii", "objc++-cpp-output"}, 
        {".h", "c-header"}, 
        {".H", "c++-header"}, 
        {".h++", "c++-header"}, 
        {".H++", "c++-header"}, 
        {".hh", "c++-header"}, 
        {".HH", "c++-header"}, 
        {".hp", "c++-header"}, 
        {".HP", "c++-header"}, 
        {".hpp", "c++-header"}, 
        {".HPP", "c++-header"}, 
        {".hxx", "c++-header"}, 
        {".HXX", "c++-header"}, 
        {".tcc", "c++-header"}, 
        {".TCC", "c++-header"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 69 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
static struct __anonstruct_languages_58  const  languages[13]  = 
#line 69
  {      {"c", "cpp-output"}, 
        {"cpp-output", "cpp-output"}, 
        {"c-header", "cpp-output"}, 
        {"c++", "c++-cpp-output"}, 
        {"c++-cpp-output", "c++-cpp-output"}, 
        {"c++-header", "c++-cpp-output"}, 
        {"objective-c", "objc-cpp-output"}, 
        {"objective-c-header", "objc-cpp-output"}, 
        {"objc-cpp-output", "objc-cpp-output"}, 
        {"objective-c++", "objc++-cpp-output"}, 
        {"objc++-cpp-output", "objc++-cpp-output"}, 
        {"objective-c++-header", "objc++-cpp-output"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 91 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
char const   *language_for_file(char const   *fname ) 
{ 
  int i ;
  char const   *p ;
  int tmp ;

  {
  {
#line 97
  p = get_extension(fname);
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! extensions[i].extension) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = strcmp(p, (char const   *)extensions[i].extension);
    }
#line 99
    if (tmp == 0) {
#line 100
      return ((char const   *)extensions[i].language);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((char const   *)((void *)0));
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
char const   *p_language_for_language(char const   *language ) 
{ 
  int i ;
  int tmp ;

  {
#line 114
  if (! language) {
#line 115
    return ((char const   *)((void *)0));
  }
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! languages[i].language) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp = strcmp(language, (char const   *)languages[i].language);
    }
#line 118
    if (tmp == 0) {
#line 119
      return ((char const   *)languages[i].p_language);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((char const   *)((void *)0));
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
char const   *extension_for_language(char const   *language ) 
{ 
  int i ;
  int tmp ;

  {
#line 134
  if (! language) {
#line 135
    return ((char const   *)((void *)0));
  }
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! extensions[i].extension) {
#line 137
      goto while_break;
    }
    {
#line 138
    tmp = strcmp(language, (char const   *)extensions[i].language);
    }
#line 138
    if (tmp == 0) {
#line 139
      return ((char const   *)extensions[i].extension);
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return ((char const   *)((void *)0));
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
_Bool language_is_supported(char const   *language ) 
{ 
  char const   *tmp ;

  {
  {
#line 148
  tmp = p_language_for_language(language);
  }
#line 148
  return ((_Bool )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/language.c"
_Bool language_is_preprocessed(char const   *language ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 154
  tmp = p_language_for_language(language);
#line 154
  tmp___0 = strcmp(language, tmp);
  }
#line 154
  return ((_Bool )(tmp___0 == 0));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void copy_fd(int fd_in , int fd_out ) ;
#line 106
int copy_file(char const   *src , char const   *dest , int compress_dest ) ;
#line 107
int move_file(char const   *src , char const   *dest , int compress_dest ) ;
#line 108
int move_uncompressed_file(char const   *src , char const   *dest , int compress_dest ) ;
#line 110
_Bool file_is_compressed(char const   *filename ) ;
#line 112
int create_dir(char const   *dir ) ;
#line 113
char const   *get_hostname(void) ;
#line 114
char const   *tmp_string(void) ;
#line 115
char *format_hash_as_string(unsigned char const   *hash___0 , unsigned int size ) ;
#line 117
int create_cachedirtag(char const   *dir ) ;
#line 120
char *x_strndup(char const   *s , size_t n ) ;
#line 121
void *x_realloc(void *ptr , size_t size ) ;
#line 123
void *x_calloc(size_t nmemb , size_t size ) ;
#line 124
void traverse(char const   *dir , void (*fn)(char const   * , struct stat * ) ) ;
#line 126
char *dirname(char *s ) ;
#line 128
char *remove_extension(char const   *path ) ;
#line 129
size_t file_size(struct stat *st ) ;
#line 130
int safe_open(char const   *fname ) ;
#line 132
char *gnu_getcwd(void) ;
#line 133
int create_empty_file(char const   *fname ) ;
#line 134
char const   *get_home_directory(void) ;
#line 135
char *get_cwd(void) ;
#line 136
_Bool same_executable_name(char const   *s1 , char const   *s2 ) ;
#line 137
size_t common_dir_prefix_length(char const   *s1 , char const   *s2 ) ;
#line 138
char *get_relative_path(char const   *from , char const   *to ) ;
#line 140
_Bool is_full_path(char const   *path ) ;
#line 141
void update_mtime(char const   *path ) ;
#line 142
int x_rename(char const   *oldpath , char const   *newpath ) ;
#line 143
int x_unlink(char const   *path ) ;
#line 145
char *x_readlink(char const   *path ) ;
#line 146
char *read_text_file(char const   *path ) ;
#line 147
_Bool read_file(char const   *path , size_t size_hint , char **data , size_t *size ) ;
#line 160
size_t value_units(char const   *s ) ;
#line 161
char *format_size(size_t v ) ;
#line 1264 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1313
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1341
extern int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1475
extern int gzeof(gzFile file ) ;
#line 1511
extern int gzclose(gzFile file ) ;
#line 1536
extern char const   *gzerror(gzFile file , int *errnum ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 138
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static FILE *logfile  ;
#line 41
char *cache_logfile ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static _Bool init_log(void) 
{ 
  int fd ;
  int tmp ;
  int flags ;
  int tmp___0 ;

  {
#line 43
  if (logfile) {
#line 44
    return ((_Bool)1);
  }
#line 46
  if (! cache_logfile) {
#line 47
    return ((_Bool)0);
  }
  {
#line 49
  logfile = fopen((char const   */* __restrict  */)cache_logfile, (char const   */* __restrict  */)"a");
  }
#line 50
  if (logfile) {
    {
#line 51
    tmp = fileno(logfile);
#line 51
    fd = tmp;
#line 52
    tmp___0 = fcntl(fd, 1, 0);
#line 52
    flags = tmp___0;
    }
#line 53
    if (flags >= 0) {
      {
#line 54
      fcntl(fd, 2, flags | 1);
      }
    }
#line 56
    return ((_Bool)1);
  } else {
#line 58
    return ((_Bool)0);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static void log_prefix(void) 
{ 
  char timestamp[100] ;
  struct timeval tv ;
  struct tm *tm ;
  __pid_t tmp ;

  {
  {
#line 70
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 74
  tm = localtime((time_t const   *)(& tv.tv_sec));
#line 76
  strftime((char */* __restrict  */)(timestamp), sizeof(timestamp), (char const   */* __restrict  */)"%Y-%m-%dT%H:%M:%S",
           (struct tm  const  */* __restrict  */)tm);
#line 77
  tmp = getpid();
#line 77
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"[%s.%06d %-5d] ",
          timestamp, (int )tv.tv_usec, tmp);
  }
#line 82
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void ( /* format attribute */  cc_log)(char const   *format___0  , ...) 
{ 
  va_list ap ;
  _Bool tmp ;

  {
  {
#line 92
  tmp = init_log();
  }
#line 92
  if (! tmp) {
#line 93
    return;
  }
  {
#line 96
  log_prefix();
#line 97
  __builtin_va_start(ap, format___0);
#line 98
  vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)format___0,
           ap);
#line 99
  __builtin_va_end(ap);
#line 100
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 101
  fflush(logfile);
  }
#line 102
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void cc_log_argv(char const   *prefix , char **argv ) 
{ 
  _Bool tmp ;

  {
  {
#line 110
  tmp = init_log();
  }
#line 110
  if (! tmp) {
#line 111
    return;
  }
  {
#line 114
  log_prefix();
#line 115
  fputs((char const   */* __restrict  */)prefix, (FILE */* __restrict  */)logfile);
#line 116
  print_command(logfile, argv);
#line 117
  fflush(logfile);
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void ( /* format attribute */  fatal)(char const   *format___0  , ...) 
{ 
  va_list ap ;
  char msg[1000] ;

  {
  {
#line 127
  __builtin_va_start(ap, format___0);
#line 128
  vsnprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)format___0,
            ap);
#line 129
  __builtin_va_end(ap);
#line 131
  cc_log("FATAL: %s", msg);
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ccache: FATAL: %s\n",
          msg);
#line 134
  exit(1);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void copy_fd(int fd_in , int fd_out ) 
{ 
  char buf___0[10240] ;
  int n ;
  gzFile gz_in ;
  int tmp ;
  ssize_t count ;
  ssize_t written ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 147
  tmp = dup(fd_in);
#line 147
  gz_in = gzdopen(tmp, "rb");
  }
#line 149
  if (! gz_in) {
    {
#line 150
    fatal("Failed to copy fd");
    }
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    n = gzread(gz_in, (voidp )(buf___0), (unsigned int )sizeof(buf___0));
    }
#line 153
    if (! (n > 0)) {
#line 153
      goto while_break;
    }
#line 154
    written = (ssize_t )0;
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 156
      count = write(fd_out, (void const   *)(buf___0 + written), (size_t )((ssize_t )n - written));
      }
#line 157
      if (count == -1L) {
        {
#line 158
        tmp___0 = __errno_location();
        }
#line 158
        if (*tmp___0 != 11) {
          {
#line 158
          tmp___1 = __errno_location();
          }
#line 158
          if (*tmp___1 != 4) {
            {
#line 159
            fatal("Failed to copy fd");
            }
          }
        }
      } else {
#line 162
        written += count;
      }
#line 155
      if (! (written < (ssize_t )n)) {
#line 155
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  gzclose(gz_in);
  }
#line 168
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int copy_file(char const   *src , char const   *dest , int compress_dest ) 
{ 
  int fd_in ;
  int fd_out ;
  gzFile gz_in ;
  gzFile gz_out ;
  char buf___0[10240] ;
  int n ;
  int written ;
  char *tmp_name ;
  mode_t mask ;
  struct stat st ;
  int errnum ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  ssize_t count ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;

  {
  {
#line 187
  fd_in = -1;
#line 187
  fd_out = -1;
#line 188
  gz_in = (gzFile )((void *)0);
#line 188
  gz_out = (gzFile )((void *)0);
#line 198
  tmp = tmp_string();
#line 198
  tmp_name = format("%s.%s.XXXXXX", dest, tmp);
  }
#line 199
  if (compress_dest) {
#line 199
    tmp___0 = "compressed";
  } else {
#line 199
    tmp___0 = "uncompressed";
  }
  {
#line 199
  cc_log("Copying %s to %s via %s (%s)", src, dest, tmp_name, tmp___0);
#line 203
  fd_in = open(src, 0);
  }
#line 204
  if (fd_in == -1) {
    {
#line 205
    tmp___1 = __errno_location();
#line 205
    tmp___2 = strerror(*tmp___1);
#line 205
    cc_log("open error: %s", tmp___2);
    }
#line 206
    return (-1);
  }
  {
#line 209
  gz_in = gzdopen(fd_in, "rb");
  }
#line 210
  if (! gz_in) {
    {
#line 211
    tmp___3 = __errno_location();
#line 211
    tmp___4 = strerror(*tmp___3);
#line 211
    cc_log("gzdopen(src) error: %s", tmp___4);
#line 212
    close(fd_in);
    }
#line 213
    return (-1);
  }
  {
#line 217
  fd_out = mkstemp(tmp_name);
  }
#line 218
  if (fd_out == -1) {
    {
#line 219
    tmp___5 = __errno_location();
#line 219
    tmp___6 = strerror(*tmp___5);
#line 219
    cc_log("mkstemp error: %s", tmp___6);
    }
#line 220
    goto error;
  }
#line 223
  if (compress_dest) {
    {
#line 229
    tmp___9 = fstat(fd_in, & st);
    }
#line 229
    if (tmp___9 != 0) {
      {
#line 230
      tmp___7 = __errno_location();
#line 230
      tmp___8 = strerror(*tmp___7);
#line 230
      cc_log("fstat error: %s", tmp___8);
      }
#line 231
      goto error;
    }
    {
#line 233
    tmp___10 = file_size(& st);
    }
#line 233
    if (tmp___10 == 0UL) {
#line 234
      compress_dest = 0;
    }
  }
#line 238
  if (compress_dest) {
    {
#line 239
    tmp___11 = dup(fd_out);
#line 239
    gz_out = gzdopen(tmp___11, "wb");
    }
#line 240
    if (! gz_out) {
      {
#line 241
      tmp___12 = __errno_location();
#line 241
      tmp___13 = strerror(*tmp___12);
#line 241
      cc_log("gzdopen(dest) error: %s", tmp___13);
      }
#line 242
      goto error;
    }
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 246
    n = gzread(gz_in, (voidp )(buf___0), (unsigned int )sizeof(buf___0));
    }
#line 246
    if (! (n > 0)) {
#line 246
      goto while_break;
    }
#line 247
    if (compress_dest) {
      {
#line 248
      written = gzwrite(gz_out, (voidpc )(buf___0), (unsigned int )n);
      }
    } else {
#line 251
      written = 0;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 253
        count = write(fd_out, (void const   *)(buf___0 + written), (size_t )(n - written));
        }
#line 254
        if (count == -1L) {
          {
#line 254
          tmp___14 = __errno_location();
          }
#line 254
          if (*tmp___14 != 4) {
#line 255
            goto while_break___0;
          }
        }
#line 257
        written = (int )((ssize_t )written + count);
#line 252
        if (! (written < n)) {
#line 252
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 260
    if (written != n) {
#line 261
      if (compress_dest) {
        {
#line 262
        tmp___15 = __errno_location();
#line 262
        tmp___16 = strerror(*tmp___15);
#line 262
        tmp___17 = gzerror(gz_in, & errnum);
#line 262
        cc_log("gzwrite error: %s (errno: %s)", tmp___17, tmp___16);
        }
      } else {
        {
#line 266
        tmp___18 = __errno_location();
#line 266
        tmp___19 = strerror(*tmp___18);
#line 266
        cc_log("write error: %s", tmp___19);
        }
      }
#line 268
      goto error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  gzerror(gz_in, & errnum);
#line 277
  tmp___23 = gzeof(gz_in);
  }
#line 277
  if (tmp___23) {
#line 277
    if (errnum != 0) {
#line 277
      if (errnum != 1) {
        _L: /* CIL Label */ 
        {
#line 278
        tmp___20 = __errno_location();
#line 278
        tmp___21 = strerror(*tmp___20);
#line 278
        tmp___22 = gzerror(gz_in, & errnum);
#line 278
        cc_log("gzread error: %s (errno: %s)", tmp___22, tmp___21);
#line 280
        gzclose(gz_in);
        }
#line 281
        if (gz_out) {
          {
#line 282
          gzclose(gz_out);
          }
        }
        {
#line 284
        close(fd_out);
#line 285
        tmp_unlink((char const   *)tmp_name);
#line 286
        free((void *)tmp_name);
        }
#line 287
        return (-1);
      }
    }
  } else {
#line 277
    goto _L;
  }
  {
#line 290
  gzclose(gz_in);
#line 291
  gz_in = (gzFile )((void *)0);
  }
#line 292
  if (gz_out) {
    {
#line 293
    gzclose(gz_out);
#line 294
    gz_out = (gzFile )((void *)0);
    }
  }
  {
#line 299
  mask = umask((__mode_t )0);
#line 300
  fchmod(fd_out, 438U & ~ mask);
#line 301
  umask(mask);
#line 305
  tmp___26 = close(fd_out);
  }
#line 305
  if (tmp___26 == -1) {
    {
#line 306
    tmp___24 = __errno_location();
#line 306
    tmp___25 = strerror(*tmp___24);
#line 306
    cc_log("close error: %s", tmp___25);
    }
#line 307
    goto error;
  }
  {
#line 310
  tmp___29 = x_rename((char const   *)tmp_name, dest);
  }
#line 310
  if (tmp___29 == -1) {
    {
#line 311
    tmp___27 = __errno_location();
#line 311
    tmp___28 = strerror(*tmp___27);
#line 311
    cc_log("rename error: %s", tmp___28);
    }
#line 312
    goto error;
  }
  {
#line 315
  free((void *)tmp_name);
  }
#line 317
  return (0);
  error: 
#line 320
  if (gz_in) {
    {
#line 321
    gzclose(gz_in);
    }
  }
#line 323
  if (gz_out) {
    {
#line 324
    gzclose(gz_out);
    }
  }
#line 326
  if (fd_out != -1) {
    {
#line 327
    close(fd_out);
    }
  }
  {
#line 329
  tmp_unlink((char const   *)tmp_name);
#line 330
  free((void *)tmp_name);
  }
#line 331
  return (-1);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int move_file(char const   *src , char const   *dest , int compress_dest ) 
{ 
  int ret___0 ;

  {
  {
#line 340
  ret___0 = copy_file(src, dest, compress_dest);
  }
#line 341
  if (ret___0 != -1) {
    {
#line 342
    x_unlink(src);
    }
  }
#line 344
  return (ret___0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int move_uncompressed_file(char const   *src , char const   *dest , int compress_dest ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 354
  if (compress_dest) {
    {
#line 355
    tmp = move_file(src, dest, compress_dest);
    }
#line 355
    return (tmp);
  } else {
    {
#line 357
    tmp___0 = x_rename(src, dest);
    }
#line 357
    return (tmp___0);
  }
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
_Bool file_is_compressed(char const   *filename ) 
{ 
  FILE *f ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 367
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 368
  if (! f) {
#line 369
    return ((_Bool)0);
  }
  {
#line 374
  tmp = fgetc(f);
  }
#line 374
  if (tmp != 31) {
    {
#line 375
    fclose(f);
    }
#line 376
    return ((_Bool)0);
  } else {
    {
#line 374
    tmp___0 = fgetc(f);
    }
#line 374
    if (tmp___0 != 139) {
      {
#line 375
      fclose(f);
      }
#line 376
      return ((_Bool)0);
    }
  }
  {
#line 379
  fclose(f);
  }
#line 380
  return ((_Bool)1);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int create_dir(char const   *dir ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 388
  tmp___0 = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& st));
  }
#line 388
  if (tmp___0 == 0) {
#line 389
    if ((st.st_mode & 61440U) == 16384U) {
#line 390
      return (0);
    }
    {
#line 392
    tmp = __errno_location();
#line 392
    *tmp = 20;
    }
#line 393
    return (1);
  }
  {
#line 395
  tmp___1 = mkdir(dir, (__mode_t )511);
  }
#line 395
  if (tmp___1 != 0) {
    {
#line 395
    tmp___2 = __errno_location();
    }
#line 395
    if (*tmp___2 != 17) {
#line 396
      return (1);
    }
  }
#line 398
  return (0);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static char hostname[200]  = {      (char )'\000'};
#line 404 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char const   *get_hostname(void) 
{ 


  {
#line 409
  if (! hostname[0]) {
    {
#line 410
    strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)"unknown");
#line 412
    gethostname(hostname, sizeof(hostname) - 1UL);
#line 414
    hostname[sizeof(hostname) - 1UL] = (char)0;
    }
  }
#line 417
  return ((char const   *)(hostname));
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static char *ret  ;
#line 424 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char const   *tmp_string(void) 
{ 
  __pid_t tmp ;
  char const   *tmp___0 ;

  {
#line 429
  if (! ret) {
    {
#line 430
    tmp = getpid();
#line 430
    tmp___0 = get_hostname();
#line 430
    ret = format("%s.%u", tmp___0, (unsigned int )tmp);
    }
  }
#line 433
  return ((char const   *)ret);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *format_hash_as_string(unsigned char const   *hash___0 , unsigned int size ) 
{ 
  char *ret___0 ;
  int i ;
  void *tmp ;

  {
  {
#line 443
  tmp = x_malloc((size_t )53);
#line 443
  ret___0 = (char *)tmp;
#line 444
  i = 0;
  }
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! (i < 16)) {
#line 444
      goto while_break;
    }
    {
#line 445
    sprintf((char */* __restrict  */)(ret___0 + i * 2), (char const   */* __restrict  */)"%02x",
            (unsigned int )*(hash___0 + i));
#line 444
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  sprintf((char */* __restrict  */)(ret___0 + i * 2), (char const   */* __restrict  */)"-%u",
          size);
  }
#line 449
  return (ret___0);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char const   CACHEDIR_TAG[191]  = 
#line 452
  {      (char const   )'S',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'8', 
        (char const   )'a',      (char const   )'4',      (char const   )'7',      (char const   )'7', 
        (char const   )'f',      (char const   )'5',      (char const   )'9',      (char const   )'7', 
        (char const   )'d',      (char const   )'2',      (char const   )'8',      (char const   )'d', 
        (char const   )'1',      (char const   )'7',      (char const   )'2',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'f',      (char const   )'0', 
        (char const   )'6',      (char const   )'8',      (char const   )'8',      (char const   )'6', 
        (char const   )'8',      (char const   )'0',      (char const   )'6',      (char const   )'b', 
        (char const   )'c',      (char const   )'5',      (char const   )'5',      (char const   )'\n', 
        (char const   )'#',      (char const   )' ',      (char const   )'T',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'t',      (char const   )'a',      (char const   )'g', 
        (char const   )' ',      (char const   )'c',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )' ', 
        (char const   )'c',      (char const   )'c',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )'.',      (char const   )'\n', 
        (char const   )'#',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'b', 
        (char const   )'o',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'g',      (char const   )'s', 
        (char const   )',',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'e',      (char const   )':',      (char const   )'\n',      (char const   )'#', 
        (char const   )'\t',      (char const   )'h',      (char const   )'t',      (char const   )'t', 
        (char const   )'p',      (char const   )':',      (char const   )'/',      (char const   )'/', 
        (char const   )'w',      (char const   )'w',      (char const   )'w',      (char const   )'.', 
        (char const   )'b',      (char const   )'r',      (char const   )'y',      (char const   )'n', 
        (char const   )'o',      (char const   )'s',      (char const   )'a',      (char const   )'u', 
        (char const   )'r',      (char const   )'u',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'/', 
        (char const   )'c',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'/',      (char const   )'\n',      (char const   )'\000'};
#line 458 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int create_cachedirtag(char const   *dir ) 
{ 
  struct stat st ;
  FILE *f ;
  char *filename ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 463
  tmp = format("%s/CACHEDIR.TAG", dir);
#line 463
  filename = tmp;
#line 464
  tmp___1 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 464
  if (tmp___1 == 0) {
#line 465
    if ((st.st_mode & 61440U) == 32768U) {
#line 466
      goto success;
    }
    {
#line 468
    tmp___0 = __errno_location();
#line 468
    *tmp___0 = 17;
    }
#line 469
    goto error;
  }
  {
#line 471
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 472
  if (! f) {
#line 472
    goto error;
  }
  {
#line 473
  tmp___2 = fwrite((void const   */* __restrict  */)(CACHEDIR_TAG), sizeof(CACHEDIR_TAG) - 1UL,
                   (size_t )1, (FILE */* __restrict  */)f);
  }
#line 473
  if (tmp___2 != 1UL) {
    {
#line 474
    fclose(f);
    }
#line 475
    goto error;
  }
  {
#line 477
  tmp___3 = fclose(f);
  }
#line 477
  if (tmp___3) {
#line 477
    goto error;
  }
  success: 
  {
#line 479
  free((void *)filename);
  }
#line 480
  return (0);
  error: 
  {
#line 482
  free((void *)filename);
  }
#line 483
  return (1);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *( /* format attribute */  format)(char const   *format___0  , ...) 
{ 
  va_list ap ;
  char *ptr ;
  int tmp ;

  {
  {
#line 491
  ptr = (char *)((void *)0);
#line 493
  __builtin_va_start(ap, format___0);
#line 494
  tmp = vasprintf((char **/* __restrict  */)(& ptr), (char const   */* __restrict  */)format___0,
                  ap);
  }
#line 494
  if (tmp == -1) {
    {
#line 495
    fatal("Out of memory in format");
    }
  }
  {
#line 497
  __builtin_va_end(ap);
  }
#line 499
  if (! *ptr) {
    {
#line 499
    fatal("Internal error in format");
    }
  }
#line 500
  return (ptr);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *x_strdup(char const   *s ) 
{ 
  char *ret___0 ;

  {
  {
#line 510
  ret___0 = strdup(s);
  }
#line 511
  if (! ret___0) {
    {
#line 512
    fatal("Out of memory in x_strdup");
    }
  }
#line 514
  return (ret___0);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *x_strndup(char const   *s , size_t n ) 
{ 
  char *ret___0 ;

  {
  {
#line 539
  ret___0 = strndup(s, n);
  }
#line 541
  if (! ret___0) {
    {
#line 542
    fatal("x_strndup: Could not allocate %lu bytes", n);
    }
  }
#line 544
  return (ret___0);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void *x_malloc(size_t size ) 
{ 
  void *ret___0 ;

  {
#line 554
  if (size == 0UL) {
#line 559
    return ((void *)0);
  }
  {
#line 561
  ret___0 = malloc(size);
  }
#line 562
  if (! ret___0) {
    {
#line 563
    fatal("x_malloc: Could not allocate %lu bytes", size);
    }
  }
#line 565
  return (ret___0);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void *x_calloc(size_t nmemb , size_t size ) 
{ 
  void *ret___0 ;

  {
#line 573
  if (nmemb * size == 0UL) {
#line 578
    return ((void *)0);
  }
  {
#line 580
  ret___0 = calloc(nmemb, size);
  }
#line 581
  if (! ret___0) {
    {
#line 582
    fatal("x_calloc: Could not allocate %lu bytes", size);
    }
  }
#line 584
  return (ret___0);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void *x_realloc(void *ptr , size_t size ) 
{ 
  void *p2 ;
  void *tmp ;

  {
#line 594
  if (! ptr) {
    {
#line 594
    tmp = x_malloc(size);
    }
#line 594
    return (tmp);
  }
  {
#line 595
  p2 = realloc(ptr, size);
  }
#line 596
  if (! p2) {
    {
#line 597
    fatal("x_realloc: Could not allocate %lu bytes", size);
    }
  }
#line 599
  return (p2);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void x_asprintf2(char **ptr , char const   *format___0  , ...) 
{ 
  char *saved ;
  va_list ap ;
  int tmp ;

  {
  {
#line 609
  saved = *ptr;
#line 612
  *ptr = (char *)((void *)0);
#line 613
  __builtin_va_start(ap, format___0);
#line 614
  tmp = vasprintf((char **/* __restrict  */)ptr, (char const   */* __restrict  */)format___0,
                  ap);
  }
#line 614
  if (tmp == -1) {
    {
#line 615
    fatal("Out of memory in x_asprintf2");
    }
  }
  {
#line 617
  __builtin_va_end(ap);
  }
#line 619
  if (! ptr) {
    {
#line 619
    fatal("Out of memory in x_asprintf2");
    }
  }
#line 620
  if (saved) {
    {
#line 621
    free((void *)saved);
    }
  }
#line 623
  return;
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void traverse(char const   *dir , void (*fn)(char const   * , struct stat * ) ) 
{ 
  DIR *d ;
  struct dirent *de ;
  char *fname ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 634
  d = opendir(dir);
  }
#line 635
  if (! d) {
#line 635
    return;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 637
    de = readdir(d);
    }
#line 637
    if (! de) {
#line 637
      goto while_break;
    }
    {
#line 641
    tmp = strcmp((char const   *)(de->d_name), ".");
    }
#line 641
    if (tmp == 0) {
#line 641
      goto while_continue;
    }
    {
#line 642
    tmp___0 = strcmp((char const   *)(de->d_name), "..");
    }
#line 642
    if (tmp___0 == 0) {
#line 642
      goto while_continue;
    }
    {
#line 644
    tmp___1 = strlen((char const   *)(de->d_name));
    }
#line 644
    if (tmp___1 == 0UL) {
#line 644
      goto while_continue;
    }
    {
#line 646
    fname = format("%s/%s", dir, de->d_name);
#line 647
    tmp___3 = lstat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& st));
    }
#line 647
    if (tmp___3) {
      {
#line 648
      tmp___2 = __errno_location();
      }
#line 648
      if (*tmp___2 != 2) {
        {
#line 649
        perror((char const   *)fname);
        }
      }
      {
#line 651
      free((void *)fname);
      }
#line 652
      goto while_continue;
    }
#line 655
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 656
      traverse((char const   *)fname, fn);
      }
    }
    {
#line 659
    (*fn)((char const   *)fname, & st);
#line 660
    free((void *)fname);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  closedir(d);
  }
#line 664
  return;
}
}
#line 668
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *s ) ;
#line 668 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *s ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 672
  p = strrchr(s, '/');
  }
#line 673
  if (p) {
#line 673
    s = (char const   *)(p + 1);
  }
  {
#line 679
  tmp = x_strdup(s);
  }
#line 679
  return (tmp);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *dirname(char *s ) 
{ 
  char *p ;
  char *p2 ;
  char *tmp ;

  {
  {
#line 687
  p2 = (char *)((void *)0);
#line 688
  s = x_strdup((char const   *)s);
#line 689
  p = strrchr((char const   *)s, '/');
  }
#line 693
  if ((unsigned long )p < (unsigned long )p2) {
#line 694
    p = p2;
  }
#line 695
  if (p) {
#line 696
    *p = (char)0;
#line 697
    return (s);
  } else {
    {
#line 699
    free((void *)s);
#line 700
    tmp = x_strdup(".");
    }
#line 700
    return (tmp);
  }
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char const   *get_extension(char const   *path ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  char const   *p ;

  {
  {
#line 712
  tmp = strlen(path);
#line 712
  len___0 = tmp;
#line 715
  p = path + (len___0 - 1UL);
  }
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 715
    if (! ((unsigned long )p >= (unsigned long )path)) {
#line 715
      goto while_break;
    }
#line 716
    if ((int const   )*p == 46) {
#line 717
      return (p);
    }
#line 719
    if ((int const   )*p == 47) {
#line 720
      goto while_break;
    }
#line 715
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  return (path + len___0);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *remove_extension(char const   *path ) 
{ 
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 733
  tmp = strlen(path);
#line 733
  tmp___0 = get_extension(path);
#line 733
  tmp___1 = strlen(tmp___0);
#line 733
  tmp___2 = x_strndup(path, tmp - tmp___1);
  }
#line 733
  return (tmp___2);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
size_t file_size(struct stat *st ) 
{ 
  size_t size ;

  {
#line 743
  size = (size_t )(st->st_blocks * 512L);
#line 744
  if ((size_t )st->st_size > size) {
#line 746
    size = (size_t )((st->st_size + 1023L) & -1024L);
  }
#line 748
  return (size);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int safe_open(char const   *fname ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 756
  tmp = open(fname, 2);
#line 756
  fd = tmp;
  }
#line 757
  if (fd == -1) {
    {
#line 757
    tmp___1 = __errno_location();
    }
#line 757
    if (*tmp___1 == 2) {
      {
#line 758
      fd = open(fname, 194, 438);
      }
#line 759
      if (fd == -1) {
        {
#line 759
        tmp___0 = __errno_location();
        }
#line 759
        if (*tmp___0 == 17) {
          {
#line 760
          fd = open(fname, 2);
          }
        }
      }
    }
  }
#line 763
  return (fd);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *format_size(size_t v ) 
{ 
  char *s ;

  {
#line 771
  if (v >= 1048576UL) {
    {
#line 772
    s = format("%.1f Gbytes", (double )v / (double )1048576);
    }
  } else
#line 773
  if (v >= 1024UL) {
    {
#line 774
    s = format("%.1f Mbytes", (double )v / (double )1024);
    }
  } else {
    {
#line 776
    s = format("%.0f Kbytes", (double )v);
    }
  }
#line 778
  return (s);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
size_t value_units(char const   *s ) 
{ 
  char m___0 ;
  double v ;
  double tmp ;
  size_t tmp___0 ;

  {
  {
#line 788
  tmp = atof(s);
#line 788
  v = tmp;
#line 789
  tmp___0 = strlen(s);
#line 789
  m___0 = (char )*(s + (tmp___0 - 1UL));
  }
  {
#line 797
  if ((int )m___0 == 109) {
#line 797
    goto case_109;
  }
#line 797
  if ((int )m___0 == 77) {
#line 797
    goto case_109;
  }
#line 801
  if ((int )m___0 == 107) {
#line 801
    goto case_107;
  }
#line 801
  if ((int )m___0 == 75) {
#line 801
    goto case_107;
  }
#line 793
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 794
  v *= (double )1048576;
#line 795
  goto switch_break;
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 798
  v *= (double )1024;
#line 799
  goto switch_break;
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 802
  v *= (double )1;
#line 803
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return ((size_t )v);
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
static long path_max(char const   *path ) 
{ 


  {
#line 814
  return (4096L);
}
}
#line 832 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *x_realpath(char const   *path ) 
{ 
  long maxlen ;
  long tmp ;
  char *ret___0 ;
  char *p ;
  void *tmp___0 ;

  {
  {
#line 835
  tmp = path_max(path);
#line 835
  maxlen = tmp;
#line 838
  tmp___0 = x_malloc((size_t )maxlen);
#line 838
  ret___0 = (char *)tmp___0;
#line 841
  p = realpath((char const   */* __restrict  */)path, (char */* __restrict  */)ret___0);
  }
#line 855
  if (p) {
    {
#line 856
    p = x_strdup((char const   *)p);
#line 857
    free((void *)ret___0);
    }
#line 858
    return (p);
  }
  {
#line 860
  free((void *)ret___0);
  }
#line 861
  return ((char *)((void *)0));
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *gnu_getcwd(void) 
{ 
  unsigned int size ;
  char *buffer ;
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 869
  size = 128U;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 872
    tmp = x_malloc((size_t )size);
#line 872
    buffer = (char *)tmp;
#line 873
    tmp___0 = getcwd(buffer, (size_t )size);
    }
#line 873
    if ((unsigned long )tmp___0 == (unsigned long )buffer) {
#line 874
      return (buffer);
    }
    {
#line 876
    free((void *)buffer);
#line 877
    tmp___4 = __errno_location();
    }
#line 877
    if (*tmp___4 != 34) {
      {
#line 878
      tmp___1 = __errno_location();
#line 878
      tmp___2 = strerror(*tmp___1);
#line 878
      tmp___3 = __errno_location();
#line 878
      cc_log("getcwd error: %d (%s)", *tmp___3, tmp___2);
      }
#line 879
      return ((char *)((void *)0));
    }
#line 881
    size *= 2U;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int create_empty_file(char const   *fname ) 
{ 
  int fd ;

  {
  {
#line 891
  fd = open(fname, 705, 438);
  }
#line 892
  if (fd == -1) {
#line 893
    return (-1);
  }
  {
#line 895
  close(fd);
  }
#line 896
  return (0);
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char const   *get_home_directory(void) 
{ 
  char const   *p ;
  char *tmp ;
  struct passwd *pwd ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;

  {
  {
#line 905
  tmp = getenv("HOME");
#line 905
  p = (char const   *)tmp;
  }
#line 906
  if (p) {
#line 907
    return (p);
  }
  {
#line 911
  tmp___0 = getuid();
#line 911
  tmp___1 = getpwuid(tmp___0);
#line 911
  pwd = tmp___1;
  }
#line 912
  if (pwd) {
#line 913
    return ((char const   *)pwd->pw_dir);
  }
#line 917
  return ((char const   *)((void *)0));
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *get_cwd(void) 
{ 
  char *pwd ;
  char *cwd ;
  struct stat st_pwd ;
  struct stat st_cwd ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 932
  cwd = gnu_getcwd();
  }
#line 933
  if (! cwd) {
#line 934
    return ((char *)((void *)0));
  }
  {
#line 936
  pwd = getenv("PWD");
  }
#line 937
  if (! pwd) {
#line 938
    return (cwd);
  }
  {
#line 940
  tmp = stat((char const   */* __restrict  */)pwd, (struct stat */* __restrict  */)(& st_pwd));
  }
#line 940
  if (tmp != 0) {
#line 941
    return (cwd);
  }
  {
#line 943
  tmp___0 = stat((char const   */* __restrict  */)cwd, (struct stat */* __restrict  */)(& st_cwd));
  }
#line 943
  if (tmp___0 != 0) {
#line 944
    return (cwd);
  }
#line 946
  if (st_pwd.st_dev == st_cwd.st_dev) {
#line 946
    if (st_pwd.st_ino == st_cwd.st_ino) {
      {
#line 947
      free((void *)cwd);
#line 948
      tmp___1 = x_strdup((char const   *)pwd);
      }
#line 948
      return (tmp___1);
    } else {
#line 950
      return (cwd);
    }
  } else {
#line 950
    return (cwd);
  }
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
_Bool same_executable_name(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 969
  tmp = strcmp(s1, s2);
  }
#line 969
  return ((_Bool )(tmp == 0));
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
size_t common_dir_prefix_length(char const   *s1 , char const   *s2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;

  {
#line 980
  p1 = s1;
#line 981
  p2 = s2;
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    if (*p1) {
#line 983
      if (*p2) {
#line 983
        if (! ((int const   )*p1 == (int const   )*p2)) {
#line 983
          goto while_break;
        }
      } else {
#line 983
        goto while_break;
      }
    } else {
#line 983
      goto while_break;
    }
#line 984
    p1 ++;
#line 985
    p2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  if ((int const   )*p2 == 47) {
#line 989
    return ((size_t )(p1 - s1));
  }
#line 991
  if (! *p2) {
#line 993
    if ((unsigned long )p2 == (unsigned long )(s2 + 1)) {
#line 995
      return ((size_t )0);
    } else {
#line 997
      return ((size_t )(p1 - s1));
    }
  }
  {
#line 1001
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1001
    if ((unsigned long )p1 > (unsigned long )s1) {
#line 1001
      if (! ((int const   )*p1 != 47)) {
#line 1001
        goto while_break___0;
      }
    } else {
#line 1001
      goto while_break___0;
    }
#line 1002
    p1 --;
#line 1003
    p2 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1005
  return ((size_t )(p1 - s1));
}
}
#line 1013 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *get_relative_path(char const   *from , char const   *to ) 
{ 
  size_t common_prefix_len ;
  int i ;
  char const   *p ;
  char *result ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1021
  if (from) {
#line 1021
    if (! ((int const   )*(from + 0) == 47)) {
      {
#line 1021
      __assert_fail("from && from[0] == \'/\'", "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c",
                    1021U, "get_relative_path");
      }
    }
  } else {
    {
#line 1021
    __assert_fail("from && from[0] == \'/\'", "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c",
                  1021U, "get_relative_path");
    }
  }
#line 1022
  if (! to) {
    {
#line 1022
    __assert_fail("to", "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c",
                  1022U, "get_relative_path");
    }
  }
#line 1024
  if (! *to) {
    {
#line 1025
    tmp = x_strdup(to);
    }
#line 1025
    return (tmp);
  } else
#line 1024
  if ((int const   )*to != 47) {
    {
#line 1025
    tmp = x_strdup(to);
    }
#line 1025
    return (tmp);
  }
  {
#line 1028
  result = x_strdup("");
#line 1029
  common_prefix_len = common_dir_prefix_length(from, to);
  }
#line 1030
  if (common_prefix_len > 0UL) {
#line 1030
    goto _L;
  } else {
    {
#line 1030
    tmp___0 = strcmp(from, "/");
    }
#line 1030
    if (! (tmp___0 == 0)) {
      _L: /* CIL Label */ 
#line 1031
      p = from + common_prefix_len;
      {
#line 1031
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1031
        if (! *p) {
#line 1031
          goto while_break;
        }
#line 1032
        if ((int const   )*p == 47) {
          {
#line 1033
          x_asprintf2(& result, "../%s", result);
          }
        }
#line 1031
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1037
  tmp___1 = strlen(to);
  }
#line 1037
  if (tmp___1 > common_prefix_len) {
    {
#line 1038
    x_asprintf2(& result, "%s%s", result, (to + common_prefix_len) + 1);
    }
  }
  {
#line 1040
  tmp___2 = strlen((char const   *)result);
#line 1040
  i = (int )(tmp___2 - 1UL);
  }
  {
#line 1041
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1041
    if (i >= 0) {
#line 1041
      if (! ((int )*(result + i) == 47)) {
#line 1041
        goto while_break___0;
      }
    } else {
#line 1041
      goto while_break___0;
    }
#line 1042
    *(result + i) = (char )'\000';
#line 1043
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1045
  tmp___3 = strcmp((char const   *)result, "");
  }
#line 1045
  if (tmp___3 == 0) {
    {
#line 1046
    free((void *)result);
#line 1047
    result = x_strdup(".");
    }
  }
#line 1049
  return (result);
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
_Bool is_absolute_path(char const   *path ) 
{ 


  {
#line 1061
  return ((_Bool )((int const   )*(path + 0) == 47));
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
_Bool is_full_path(char const   *path ) 
{ 
  char *tmp ;

  {
  {
#line 1071
  tmp = strchr(path, '/');
  }
#line 1071
  if (tmp) {
#line 1072
    return ((_Bool)1);
  }
#line 1077
  return ((_Bool)0);
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
void update_mtime(char const   *path ) 
{ 


  {
  {
#line 1088
  utimes(path, (struct timeval  const  *)((void *)0));
  }
#line 1092
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int x_rename(char const   *oldpath , char const   *newpath ) 
{ 
  int tmp ;

  {
  {
#line 1104
  tmp = rename(oldpath, newpath);
  }
#line 1104
  return (tmp);
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int tmp_unlink(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 1114
  cc_log("Unlink %s (as-tmp)", path);
#line 1115
  tmp = unlink(path);
  }
#line 1115
  return (tmp);
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
int x_unlink(char const   *path ) 
{ 
  char *tmp_name ;
  char const   *tmp ;
  char *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1129
  tmp = tmp_string();
#line 1129
  tmp___0 = format("%s.tmp.rm.%s", path, tmp);
#line 1129
  tmp_name = tmp___0;
#line 1130
  result = 0;
#line 1131
  cc_log("Unlink %s via %s", path, tmp_name);
#line 1132
  tmp___1 = x_rename(path, (char const   *)tmp_name);
  }
#line 1132
  if (tmp___1 == -1) {
#line 1133
    result = -1;
#line 1134
    goto out;
  }
  {
#line 1136
  tmp___2 = unlink((char const   *)tmp_name);
  }
#line 1136
  if (tmp___2 == -1) {
#line 1137
    result = -1;
  }
  out: 
  {
#line 1140
  free((void *)tmp_name);
  }
#line 1141
  return (result);
}
}
#line 1146 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *x_readlink(char const   *path ) 
{ 
  long maxlen ;
  long tmp ;
  ssize_t len___0 ;
  char *buf___0 ;
  void *tmp___0 ;

  {
  {
#line 1149
  tmp = path_max(path);
#line 1149
  maxlen = tmp;
#line 1153
  maxlen = 4096L;
  }
#line 1159
  if (maxlen < 4096L) {
#line 1159
    maxlen = 4096L;
  }
  {
#line 1161
  tmp___0 = x_malloc((size_t )maxlen);
#line 1161
  buf___0 = (char *)tmp___0;
#line 1162
  len___0 = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)buf___0,
                     (size_t )(maxlen - 1L));
  }
#line 1163
  if (len___0 == -1L) {
    {
#line 1164
    free((void *)buf___0);
    }
#line 1165
    return ((char *)((void *)0));
  }
#line 1167
  *(buf___0 + len___0) = (char)0;
#line 1168
  return (buf___0);
}
}
#line 1176 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
_Bool read_file(char const   *path , size_t size_hint , char **data , size_t *size ) 
{ 
  int fd ;
  int ret___0 ;
  size_t pos ;
  size_t allocated___0 ;
  struct stat st ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
#line 1180
  pos = (size_t )0;
#line 1182
  if (size_hint == 0UL) {
    {
#line 1184
    tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
    }
#line 1184
    if (tmp == 0) {
#line 1185
      size_hint = (size_t )st.st_size;
    }
  }
#line 1188
  if (size_hint < 1024UL) {
#line 1188
    size_hint = (size_t )1024;
  } else {
#line 1188
    size_hint = size_hint;
  }
  {
#line 1190
  fd = open(path, 0);
  }
#line 1191
  if (fd == -1) {
#line 1192
    return ((_Bool)0);
  }
  {
#line 1194
  allocated___0 = size_hint;
#line 1195
  tmp___0 = x_malloc(allocated___0);
#line 1195
  *data = (char *)tmp___0;
#line 1196
  ret___0 = 0;
  }
  {
#line 1197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1198
    if (pos > allocated___0 / 2UL) {
      {
#line 1199
      allocated___0 *= 2UL;
#line 1200
      tmp___1 = x_realloc((void *)*data, allocated___0);
#line 1200
      *data = (char *)tmp___1;
      }
    }
    {
#line 1202
    tmp___2 = read(fd, (void *)(*data + pos), allocated___0 - pos);
#line 1202
    ret___0 = (int )tmp___2;
    }
#line 1203
    if (ret___0 == 0) {
#line 1204
      goto while_break;
    } else
#line 1203
    if (ret___0 == -1) {
      {
#line 1203
      tmp___3 = __errno_location();
      }
#line 1203
      if (*tmp___3 != 4) {
#line 1204
        goto while_break;
      }
    }
#line 1206
    if (ret___0 > 0) {
#line 1207
      pos += (size_t )ret___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1210
  close(fd);
  }
#line 1211
  if (ret___0 == -1) {
    {
#line 1212
    cc_log("Failed reading %s", path);
#line 1213
    free((void *)*data);
#line 1214
    *data = (char *)((void *)0);
    }
#line 1215
    return ((_Bool)0);
  }
#line 1218
  *size = pos;
#line 1219
  return ((_Bool)1);
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/util.c"
char *read_text_file(char const   *path ) 
{ 
  size_t size ;
  char *data ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1232
  tmp___0 = read_file(path, (size_t )0, & data, & size);
  }
#line 1232
  if (tmp___0) {
    {
#line 1233
    tmp = x_realloc((void *)data, size + 1UL);
#line 1233
    data = (char *)tmp;
#line 1234
    *(data + size) = (char )'\000';
    }
#line 1235
    return (data);
  } else {
#line 1237
    return ((char *)((void *)0));
  }
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void hash_start(struct mdfour *md ) ;
#line 88
void hash_buffer(struct mdfour *md , void const   *s , size_t len___0 ) ;
#line 89
char *hash_result(struct mdfour *md ) ;
#line 90
void hash_result_as_bytes(struct mdfour *md , unsigned char *out ) ;
#line 91
_Bool hash_equal(struct mdfour *md1 , struct mdfour *md2 ) ;
#line 92
void hash_delimiter(struct mdfour *md , char const   *type ) ;
#line 93
void hash_string(struct mdfour *md , char const   *s ) ;
#line 94
void hash_int(struct mdfour *md , int x ) ;
#line 95
_Bool hash_fd(struct mdfour *md , int fd ) ;
#line 96
_Bool hash_file(struct mdfour *md , char const   *fname ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_start(struct mdfour *md ) 
{ 


  {
  {
#line 27
  mdfour_begin(md);
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_buffer(struct mdfour *md , void const   *s , size_t len___0 ) 
{ 


  {
  {
#line 33
  mdfour_update(md, (unsigned char const   *)((unsigned char *)s), len___0);
  }
#line 34
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
char *hash_result(struct mdfour *md ) 
{ 
  unsigned char sum[16] ;
  char *tmp ;

  {
  {
#line 42
  hash_result_as_bytes(md, sum);
#line 43
  tmp = format_hash_as_string((unsigned char const   *)(sum), (unsigned int )md->totalN);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_result_as_bytes(struct mdfour *md , unsigned char *out ) 
{ 


  {
  {
#line 50
  hash_buffer(md, (void const   *)((void *)0), (size_t )0);
#line 51
  mdfour_result(md, out);
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
_Bool hash_equal(struct mdfour *md1 , struct mdfour *md2 ) 
{ 
  unsigned char sum1[16] ;
  unsigned char sum2[16] ;
  int tmp ;

  {
  {
#line 58
  hash_result_as_bytes(md1, sum1);
#line 59
  hash_result_as_bytes(md2, sum2);
#line 60
  tmp = memcmp((void const   *)(sum1), (void const   *)(sum2), sizeof(sum1));
  }
#line 60
  return ((_Bool )(tmp == 0));
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_delimiter(struct mdfour *md , char const   *type ) 
{ 
  size_t tmp ;

  {
  {
#line 76
  hash_buffer(md, (void const   *)"\000cCaChE", sizeof("\000cCaChE"));
#line 77
  tmp = strlen(type);
#line 77
  hash_buffer(md, (void const   *)type, tmp + 1UL);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_string(struct mdfour *md , char const   *s ) 
{ 
  size_t tmp ;

  {
  {
#line 83
  tmp = strlen(s);
#line 83
  hash_buffer(md, (void const   *)s, tmp);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
void hash_int(struct mdfour *md , int x ) 
{ 


  {
  {
#line 89
  hash_buffer(md, (void const   *)((char *)(& x)), sizeof(x));
  }
#line 90
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
_Bool hash_fd(struct mdfour *md , int fd ) 
{ 
  char buf___0[16384] ;
  ssize_t n ;
  int *tmp ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    n = read(fd, (void *)(buf___0), sizeof(buf___0));
    }
#line 102
    if (! (n != 0L)) {
#line 102
      goto while_break;
    }
#line 103
    if (n == -1L) {
      {
#line 103
      tmp = __errno_location();
      }
#line 103
      if (*tmp != 4) {
#line 104
        goto while_break;
      }
    }
#line 106
    if (n > 0L) {
      {
#line 107
      hash_buffer(md, (void const   *)(buf___0), (size_t )n);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return ((_Bool )(n == 0L));
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hash.c"
_Bool hash_file(struct mdfour *md , char const   *fname ) 
{ 
  int fd ;
  _Bool ret___0 ;

  {
  {
#line 123
  fd = open(fname, 0);
  }
#line 124
  if (fd == -1) {
#line 125
    return ((_Bool)0);
  }
  {
#line 128
  ret___0 = hash_fd(md, fd);
#line 129
  close(fd);
  }
#line 130
  return (ret___0);
}
}
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 198 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
_Bool lockfile_acquire(char const   *path , unsigned int staleness_limit ) ;
#line 199
void lockfile_release(char const   *path ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/lockfile.c"
_Bool lockfile_acquire(char const   *path , unsigned int staleness_limit ) 
{ 
  char *lockfile ;
  char *tmp ;
  char *my_content ;
  char *content ;
  char *initial_content ;
  char const   *hostname___0 ;
  char const   *tmp___0 ;
  _Bool acquired ;
  int ret___0 ;
  unsigned int to_sleep ;
  unsigned int slept ;
  time_t tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;

  {
  {
#line 34
  tmp = format("%s.lock", path);
#line 34
  lockfile = tmp;
#line 35
  my_content = (char *)((void *)0);
#line 35
  content = (char *)((void *)0);
#line 35
  initial_content = (char *)((void *)0);
#line 36
  tmp___0 = get_hostname();
#line 36
  hostname___0 = tmp___0;
#line 37
  acquired = (_Bool)0;
#line 44
  to_sleep = 1000U;
#line 44
  slept = 0U;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    free((void *)my_content);
#line 48
    tmp___1 = time((time_t *)((void *)0));
#line 48
    tmp___2 = getpid();
#line 48
    my_content = format("%s:%d:%d", hostname___0, tmp___2, (int )tmp___1);
#line 95
    ret___0 = symlink((char const   *)my_content, (char const   *)lockfile);
    }
#line 96
    if (ret___0 == 0) {
#line 98
      acquired = (_Bool)1;
#line 99
      goto out;
    }
    {
#line 101
    tmp___3 = __errno_location();
#line 101
    tmp___4 = strerror(*tmp___3);
#line 101
    cc_log("lockfile_acquire: symlink %s: %s", lockfile, tmp___4);
#line 102
    tmp___5 = __errno_location();
    }
#line 102
    if (*tmp___5 == 1) {
#line 107
      acquired = (_Bool)1;
#line 108
      goto out;
    }
    {
#line 110
    tmp___6 = __errno_location();
    }
#line 110
    if (*tmp___6 != 17) {
#line 112
      goto out;
    }
    {
#line 114
    free((void *)content);
#line 115
    content = x_readlink((char const   *)lockfile);
    }
#line 116
    if (! content) {
      {
#line 117
      tmp___9 = __errno_location();
      }
#line 117
      if (*tmp___9 == 2) {
#line 122
        goto while_continue;
      } else {
        {
#line 124
        tmp___7 = __errno_location();
#line 124
        tmp___8 = strerror(*tmp___7);
#line 124
        cc_log("lockfile_acquire: readlink %s: %s", lockfile, tmp___8);
        }
#line 125
        goto out;
      }
    }
    {
#line 130
    tmp___10 = strcmp((char const   *)content, (char const   *)my_content);
    }
#line 130
    if (tmp___10 == 0) {
      {
#line 132
      cc_log("lockfile_acquire: symlink %s failed but we got the lock anyway", lockfile);
#line 134
      acquired = (_Bool)1;
      }
#line 135
      goto out;
    }
    {
#line 141
    cc_log("lockfile_acquire: lock info for %s: %s", lockfile, content);
    }
#line 142
    if (! initial_content) {
      {
#line 143
      initial_content = x_strdup((char const   *)content);
      }
    }
#line 145
    if (slept > staleness_limit) {
      {
#line 146
      tmp___12 = strcmp((char const   *)content, (char const   *)initial_content);
      }
#line 146
      if (tmp___12 == 0) {
        {
#line 148
        cc_log("lockfile_acquire: breaking %s", lockfile);
#line 149
        tmp___11 = lockfile_acquire((char const   *)lockfile, staleness_limit);
        }
#line 149
        if (tmp___11) {
          {
#line 150
          lockfile_release(path);
#line 151
          lockfile_release((char const   *)lockfile);
#line 152
          to_sleep = 1000U;
#line 153
          slept = 0U;
          }
#line 154
          goto while_continue;
        }
      }
      {
#line 157
      cc_log("lockfile_acquire: gave up acquiring %s", lockfile);
      }
#line 158
      goto out;
    }
    {
#line 160
    cc_log("lockfile_acquire: failed to acquire %s; sleeping %u microseconds", lockfile,
           to_sleep);
#line 162
    usleep(to_sleep);
#line 163
    slept += to_sleep;
#line 164
    to_sleep *= 2U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 168
  if (acquired) {
    {
#line 169
    cc_log("Acquired lock %s", lockfile);
    }
  } else {
    {
#line 171
    cc_log("Failed to acquire lock %s", lockfile);
    }
  }
  {
#line 173
  free((void *)lockfile);
#line 174
  free((void *)my_content);
#line 175
  free((void *)initial_content);
#line 176
  free((void *)content);
  }
#line 177
  return (acquired);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/lockfile.c"
void lockfile_release(char const   *path ) 
{ 
  char *lockfile ;
  char *tmp ;

  {
  {
#line 187
  tmp = format("%s.lock", path);
#line 187
  lockfile = tmp;
#line 188
  cc_log("Releasing lock %s", lockfile);
#line 189
  tmp_unlink((char const   *)lockfile);
#line 190
  free((void *)lockfile);
  }
#line 191
  return;
}
}
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.h"
_Bool compopt_short(_Bool (*fn)(char const   *option ) , char const   *option ) ;
#line 7
_Bool compopt_affects_cpp(char const   *option ) ;
#line 8
_Bool compopt_too_hard(char const   *option ) ;
#line 9
_Bool compopt_too_hard_for_direct_mode(char const   *option ) ;
#line 10
_Bool compopt_takes_path(char const   *option ) ;
#line 11
_Bool compopt_takes_arg(char const   *option ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
static struct compopt  const  compopts[43]  = 
#line 34 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
  {      {"--coverage", 1}, 
        {"--param", 1 << 2}, 
        {"-A", 1 << 2}, 
        {"-D", ((1 << 5) | (1 << 2)) | (1 << 3)}, 
        {"-E", 1}, 
        {"-F", (((1 << 5) | (1 << 2)) | (1 << 3)) | (1 << 4)}, 
        {"-G", 1 << 2}, 
        {"-I", (((1 << 5) | (1 << 2)) | (1 << 3)) | (1 << 4)}, 
        {"-L", 1 << 2}, 
        {"-M", 1}, 
        {"-MF", 1 << 2}, 
        {"-MM", 1}, 
        {"-MQ", 1 << 2}, 
        {"-MT", 1 << 2}, 
        {"-U", ((1 << 5) | (1 << 2)) | (1 << 3)}, 
        {"-V", 1 << 2}, 
        {"-Xassembler", 1 << 2}, 
        {"-Xlinker", 1 << 2}, 
        {"-Xpreprocessor", (1 << 1) | (1 << 2)}, 
        {"-aux-info", 1 << 2}, 
        {"-b", 1 << 2}, 
        {"-fbranch-probabilities", 1}, 
        {"-fprofile-arcs", 1}, 
        {"-fprofile-generate", 1}, 
        {"-fprofile-use", 1}, 
        {"-frepo", 1}, 
        {"-ftest-coverage", 1}, 
        {"-idirafter", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-iframework", (((1 << 5) | (1 << 2)) | (1 << 3)) | (1 << 4)}, 
        {"-imacros", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-imultilib", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-include", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-install_name", 1 << 2}, 
        {"-iprefix", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-iquote", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-isysroot", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-isystem", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-iwithprefix", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-iwithprefixbefore", ((1 << 5) | (1 << 2)) | (1 << 4)}, 
        {"-nostdinc", 1 << 5}, 
        {"-nostdinc++", 1 << 5}, 
        {"-save-temps", 1}, 
        {"-u", 1 << 2}};
#line 80 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
static int compare_compopts(void const   *key1 , void const   *key2 ) 
{ 
  struct compopt  const  *opt1 ;
  struct compopt  const  *opt2 ;
  int tmp ;

  {
  {
#line 83
  opt1 = (struct compopt  const  *)key1;
#line 84
  opt2 = (struct compopt  const  *)key2;
#line 85
  tmp = strcmp((char const   *)opt1->name, (char const   *)opt2->name);
  }
#line 85
  return (tmp);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
static struct compopt  const  *find(char const   *option ) 
{ 
  struct compopt key ;
  void *tmp ;

  {
  {
#line 92
  key.name = option;
#line 93
  tmp = bsearch((void const   *)(& key), (void const   *)(compopts), sizeof(compopts) / sizeof(compopts[0]),
                sizeof(compopts[0]), & compare_compopts);
  }
#line 93
  return ((struct compopt  const  *)tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_short(_Bool (*fn)(char const   *option ) , char const   *option ) 
{ 
  char *short_opt ;
  char *tmp ;
  _Bool retval ;
  _Bool tmp___0 ;

  {
  {
#line 102
  tmp = x_strndup(option, (size_t )2);
#line 102
  short_opt = tmp;
#line 103
  tmp___0 = (*fn)((char const   *)short_opt);
#line 103
  retval = tmp___0;
#line 104
  free((void *)short_opt);
  }
#line 105
  return (retval);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_verify_sortedness(void) 
{ 
  size_t i ;
  int tmp ;

  {
#line 113
  i = (size_t )1;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < sizeof(compopts) / sizeof(compopts[0]))) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp = strcmp((char const   *)compopts[i - 1UL].name, (char const   *)compopts[i].name);
    }
#line 114
    if (tmp >= 0) {
      {
#line 115
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"compopt_verify_sortedness: %s >= %s\n",
              compopts[i - 1UL].name, compopts[i].name);
      }
#line 119
      return ((_Bool)0);
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((_Bool)1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_affects_cpp(char const   *option ) 
{ 
  struct compopt  const  *co ;
  struct compopt  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 128
  tmp = find(option);
#line 128
  co = tmp;
  }
#line 129
  if (co) {
#line 129
    if (co->type & (int const   )(1 << 5)) {
#line 129
      tmp___0 = 1;
    } else {
#line 129
      tmp___0 = 0;
    }
  } else {
#line 129
    tmp___0 = 0;
  }
#line 129
  return ((_Bool )tmp___0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_too_hard(char const   *option ) 
{ 
  struct compopt  const  *co ;
  struct compopt  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 135
  tmp = find(option);
#line 135
  co = tmp;
  }
#line 136
  if (co) {
#line 136
    if (co->type & 1) {
#line 136
      tmp___0 = 1;
    } else {
#line 136
      tmp___0 = 0;
    }
  } else {
#line 136
    tmp___0 = 0;
  }
#line 136
  return ((_Bool )tmp___0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_too_hard_for_direct_mode(char const   *option ) 
{ 
  struct compopt  const  *co ;
  struct compopt  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 142
  tmp = find(option);
#line 142
  co = tmp;
  }
#line 143
  if (co) {
#line 143
    if (co->type & (int const   )(1 << 1)) {
#line 143
      tmp___0 = 1;
    } else {
#line 143
      tmp___0 = 0;
    }
  } else {
#line 143
    tmp___0 = 0;
  }
#line 143
  return ((_Bool )tmp___0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_takes_path(char const   *option ) 
{ 
  struct compopt  const  *co ;
  struct compopt  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 149
  tmp = find(option);
#line 149
  co = tmp;
  }
#line 150
  if (co) {
#line 150
    if (co->type & (int const   )(1 << 4)) {
#line 150
      tmp___0 = 1;
    } else {
#line 150
      tmp___0 = 0;
    }
  } else {
#line 150
    tmp___0 = 0;
  }
#line 150
  return ((_Bool )tmp___0);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/compopt.c"
_Bool compopt_takes_arg(char const   *option ) 
{ 
  struct compopt  const  *co ;
  struct compopt  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = find(option);
#line 156
  co = tmp;
  }
#line 157
  if (co) {
#line 157
    if (co->type & (int const   )(1 << 2)) {
#line 157
      tmp___0 = 1;
    } else {
#line 157
      tmp___0 = 0;
    }
  } else {
#line 157
    tmp___0 = 0;
  }
#line 157
  return ((_Bool )tmp___0);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void stats_get_limits(char const   *dir , unsigned int *maxfiles , unsigned int *maxsize ) ;
#line 162
void stats_set_sizes(char const   *dir , size_t num_files___0 , size_t total_size ) ;
#line 182
void cleanup_dir(char const   *dir , size_t maxfiles , size_t maxsize ) ;
#line 183
void cleanup_all(char const   *dir ) ;
#line 184
void wipe_all(char const   *dir ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static struct files **files  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static unsigned int allocated  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static unsigned int num_files  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static size_t cache_size  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static size_t files_in_cache  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static size_t cache_size_threshold  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static size_t files_in_cache_threshold  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static int files_compare(struct files **f1 , struct files **f2 ) 
{ 
  int tmp ;

  {
#line 46
  if ((*f2)->mtime == (*f1)->mtime) {
    {
#line 47
    tmp = strcmp((char const   *)(*f1)->fname, (char const   *)(*f2)->fname);
    }
#line 47
    return (tmp);
  }
#line 49
  if ((*f2)->mtime > (*f1)->mtime) {
#line 50
    return (-1);
  }
#line 52
  return (1);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static void traverse_fn(char const   *fname , struct stat *st ) 
{ 
  char *p ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 61
  if (! ((st->st_mode & 61440U) == 32768U)) {
#line 61
    return;
  }
  {
#line 63
  p = basename(fname);
#line 64
  tmp = strcmp((char const   *)p, "stats");
  }
#line 64
  if (tmp == 0) {
#line 65
    goto out;
  }
  {
#line 68
  tmp___0 = strlen(".nfs");
#line 68
  tmp___1 = strncmp((char const   *)p, ".nfs", tmp___0);
  }
#line 68
  if (tmp___1 == 0) {
#line 70
    goto out;
  }
  {
#line 73
  tmp___3 = strstr((char const   *)p, ".tmp.");
  }
#line 73
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 75
    tmp___2 = time((time_t *)((void *)0));
    }
#line 75
    if (st->st_mtim.tv_sec + 3600L < tmp___2) {
      {
#line 76
      x_unlink(fname);
      }
#line 77
      goto out;
    }
  }
#line 81
  if (num_files == allocated) {
    {
#line 82
    allocated = 10000U + num_files * 2U;
#line 83
    tmp___4 = x_realloc((void *)files, sizeof(struct files *) * (unsigned long )allocated);
#line 83
    files = (struct files **)tmp___4;
    }
  }
  {
#line 86
  tmp___5 = x_malloc(sizeof(struct files ));
#line 86
  *(files + num_files) = (struct files *)tmp___5;
#line 87
  (*(files + num_files))->fname = x_strdup(fname);
#line 88
  (*(files + num_files))->mtime = st->st_mtim.tv_sec;
#line 89
  tmp___6 = file_size(st);
#line 89
  (*(files + num_files))->size = tmp___6 / 1024UL;
#line 90
  cache_size += (*(files + num_files))->size;
#line 91
  files_in_cache ++;
#line 92
  num_files ++;
  }
  out: 
  {
#line 95
  free((void *)p);
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static void delete_file(char const   *path , size_t size ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 101
  tmp___2 = x_unlink(path);
  }
#line 101
  if (tmp___2 == 0) {
#line 102
    cache_size -= size;
#line 103
    files_in_cache --;
  } else {
    {
#line 104
    tmp___1 = __errno_location();
    }
#line 104
    if (*tmp___1 != 2) {
      {
#line 105
      tmp = __errno_location();
#line 105
      tmp___0 = strerror(*tmp);
#line 105
      cc_log("Failed to unlink %s (%s)", path, tmp___0);
      }
    }
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static void delete_sibling_file(char const   *base , char const   *extension ) 
{ 
  struct stat st ;
  char *path ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 115
  path = format("%s%s", base, extension);
#line 116
  tmp___3 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 116
  if (tmp___3 == 0) {
    {
#line 117
    tmp = file_size(& st);
#line 117
    delete_file((char const   *)path, tmp / 1024UL);
    }
  } else {
    {
#line 118
    tmp___2 = __errno_location();
    }
#line 118
    if (*tmp___2 != 2) {
      {
#line 119
      tmp___0 = __errno_location();
#line 119
      tmp___1 = strerror(*tmp___0);
#line 119
      cc_log("Failed to stat %s (%s)", path, tmp___1);
      }
    }
  }
  {
#line 121
  free((void *)path);
  }
#line 122
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static void sort_and_clean(void) 
{ 
  unsigned int i ;
  char const   *ext ;
  char *last_base ;
  char *tmp ;
  char *base ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 131
  tmp = x_strdup("");
#line 131
  last_base = tmp;
  }
#line 133
  if (num_files > 1U) {
    {
#line 135
    qsort((void *)files, (size_t )num_files, sizeof(struct files *), (int (*)(void const   * ,
                                                                              void const   * ))(& files_compare));
    }
  }
#line 139
  i = 0U;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < num_files)) {
#line 139
      goto while_break;
    }
#line 140
    if (cache_size_threshold == 0UL) {
#line 140
      goto _L;
    } else
#line 140
    if (cache_size <= cache_size_threshold) {
      _L: /* CIL Label */ 
#line 140
      if (files_in_cache_threshold == 0UL) {
#line 144
        goto while_break;
      } else
#line 140
      if (files_in_cache <= files_in_cache_threshold) {
#line 144
        goto while_break;
      }
    }
    {
#line 147
    ext = get_extension((char const   *)(*(files + i))->fname);
#line 148
    tmp___2 = strcmp(ext, ".o");
    }
#line 148
    if (tmp___2 == 0) {
#line 148
      goto _L___0;
    } else {
      {
#line 148
      tmp___3 = strcmp(ext, ".d");
      }
#line 148
      if (tmp___3 == 0) {
#line 148
        goto _L___0;
      } else {
        {
#line 148
        tmp___4 = strcmp(ext, ".stderr");
        }
#line 148
        if (tmp___4 == 0) {
#line 148
          goto _L___0;
        } else {
          {
#line 148
          tmp___5 = strcmp(ext, "");
          }
#line 148
          if (tmp___5 == 0) {
            _L___0: /* CIL Label */ 
            {
#line 152
            tmp___0 = remove_extension((char const   *)(*(files + i))->fname);
#line 152
            base = tmp___0;
#line 153
            tmp___1 = strcmp((char const   *)base, (char const   *)last_base);
            }
#line 153
            if (! (tmp___1 == 0)) {
              {
#line 161
              delete_sibling_file((char const   *)base, ".o");
#line 162
              delete_sibling_file((char const   *)base, ".d");
#line 163
              delete_sibling_file((char const   *)base, ".stderr");
#line 164
              delete_sibling_file((char const   *)base, "");
              }
            }
            {
#line 166
            free((void *)last_base);
#line 167
            last_base = base;
            }
          } else {
            {
#line 170
            delete_file((char const   *)(*(files + i))->fname, (*(files + i))->size);
            }
          }
        }
      }
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  free((void *)last_base);
  }
#line 174
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
void cleanup_dir(char const   *dir , size_t maxfiles , size_t maxsize ) 
{ 
  unsigned int i ;

  {
  {
#line 182
  cc_log("Cleaning up cache directory %s", dir);
#line 184
  cache_size_threshold = (size_t )((double )maxsize * 0.8);
#line 185
  files_in_cache_threshold = (size_t )((double )maxfiles * 0.8);
#line 187
  num_files = 0U;
#line 188
  cache_size = (size_t )0;
#line 189
  files_in_cache = (size_t )0;
#line 192
  traverse(dir, & traverse_fn);
#line 195
  sort_and_clean();
#line 197
  stats_set_sizes(dir, files_in_cache, cache_size);
#line 200
  i = 0U;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < num_files)) {
#line 200
      goto while_break;
    }
    {
#line 201
    free((void *)(*(files + i))->fname);
#line 202
    free((void *)*(files + i));
#line 203
    *(files + i) = (struct files *)((void *)0);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (files) {
    {
#line 206
    free((void *)files);
    }
  }
#line 208
  allocated = 0U;
#line 209
  files = (struct files **)((void *)0);
#line 211
  num_files = 0U;
#line 212
  cache_size = (size_t )0;
#line 213
  files_in_cache = (size_t )0;
#line 214
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
void cleanup_all(char const   *dir ) 
{ 
  unsigned int maxfiles ;
  unsigned int maxsize ;
  char *dname ;
  int i ;

  {
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i <= 15)) {
#line 223
      goto while_break;
    }
    {
#line 224
    dname = format("%s/%1x", dir, i);
#line 225
    stats_get_limits((char const   *)dname, & maxfiles, & maxsize);
#line 226
    cleanup_dir((char const   *)dname, (size_t )maxfiles, (size_t )maxsize);
#line 227
    free((void *)dname);
#line 223
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
static void wipe_fn(char const   *fname , struct stat *st ) 
{ 
  char *p ;
  int tmp ;

  {
#line 236
  if (! ((st->st_mode & 61440U) == 32768U)) {
#line 236
    return;
  }
  {
#line 238
  p = basename(fname);
#line 239
  tmp = strcmp((char const   *)p, "stats");
  }
#line 239
  if (tmp == 0) {
    {
#line 240
    free((void *)p);
    }
#line 241
    return;
  }
  {
#line 243
  free((void *)p);
#line 245
  x_unlink(fname);
  }
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/cleanup.c"
void wipe_all(char const   *dir ) 
{ 
  char *dname ;
  int i ;

  {
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i <= 15)) {
#line 254
      goto while_break;
    }
    {
#line 255
    dname = format("%s/%1x", dir, i);
#line 256
    traverse(dir, & wipe_fn);
#line 257
    free((void *)dname);
#line 254
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  cleanup_all(dir);
  }
#line 262
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/counters.h"
struct counters *counters_init(size_t initial_size ) ;
#line 29
void counters_resize(struct counters *c , size_t new_size ) ;
#line 30
void counters_free(struct counters *c ) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
void stats_update(enum stats stat___0 ) ;
#line 153
void stats_flush(void) ;
#line 154
unsigned int stats_get_pending(enum stats stat___0 ) ;
#line 155
void stats_zero(void) ;
#line 156
void stats_summary(void) ;
#line 157
void stats_update_size(enum stats stat___0 , size_t size , unsigned int files___0 ) ;
#line 159
int stats_set_limits(long maxfiles , long maxsize ) ;
#line 163
void stats_read(char const   *sfile , struct counters *counters ) ;
#line 164
void stats_write(char const   *path , struct counters *counters ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.h"
unsigned int hash_from_int(int i ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
char *stats_file ;
#line 37
char *cache_dir ;
#line 38
unsigned int lock_staleness_limit ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static struct counters *counter_updates  ;
#line 50
static void display_size(size_t v ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static struct __anonstruct_stats_info_57 stats_info[29]  = 
#line 53
  {      {(enum stats )22, (char *)"cache hit (direct)             ", (void (*)(size_t  ))((void *)0),
      2U}, 
        {(enum stats )8, (char *)"cache hit (preprocessed)       ", (void (*)(size_t  ))((void *)0),
      2U}, 
        {(enum stats )4, (char *)"cache miss                     ", (void (*)(size_t  ))((void *)0),
      2U}, 
        {(enum stats )10, (char *)"called for link                ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )28, (char *)"called for preprocessing       ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )18, (char *)"multiple source files          ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )1, (char *)"compiler produced stdout       ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )23, (char *)"compiler produced no output    ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )24, (char *)"compiler produced empty output ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )2, (char *)"compile failed                 ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )3, (char *)"ccache internal error          ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )5, (char *)"preprocessor error             ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )27, (char *)"can\'t use precompiled header   ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )6, (char *)"couldn\'t find the compiler     ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )7, (char *)"cache file missing             ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )9, (char *)"bad compiler arguments         ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )15, (char *)"unsupported source language    ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )26, (char *)"compiler check failed          ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )19, (char *)"autoconf compile/link          ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )20, (char *)"unsupported compiler option    ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )21, (char *)"output to stdout               ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )16, (char *)"output to a non-regular file   ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )17, (char *)"no input file                  ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )25, (char *)"error hashing extra file       ", (void (*)(size_t  ))((void *)0),
      0U}, 
        {(enum stats )11, (char *)"files in cache                 ", (void (*)(size_t  ))((void *)0),
      3U}, 
        {(enum stats )12, (char *)"cache size                     ", & display_size,
      3U}, 
        {(enum stats )13, (char *)"max files                      ", (void (*)(size_t  ))((void *)0),
      1U}, 
        {(enum stats )14, (char *)"max cache size                 ", & display_size,
      1U}, 
        {(enum stats )0, (char *)((void *)0), (void (*)(size_t  ))((void *)0), 0U}};
#line 90 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static void display_size(size_t v ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 93
  tmp = format_size(v);
#line 93
  s = tmp;
#line 94
  printf((char const   */* __restrict  */)"%15s", s);
#line 95
  free((void *)s);
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static void parse_stats(struct counters *counters , char const   *buf___0 ) 
{ 
  size_t i ;
  char const   *p ;
  char *p2 ;
  long val ;

  {
#line 102
  i = (size_t )0;
#line 107
  p = buf___0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    val = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p2),
                 10);
    }
#line 110
    if ((unsigned long )p2 == (unsigned long )p) {
#line 111
      goto while_break;
    }
#line 113
    if (counters->size < i + 1UL) {
      {
#line 114
      counters_resize(counters, i + 1UL);
      }
    }
#line 116
    *(counters->data + i) = (unsigned int )((long )*(counters->data + i) + val);
#line 117
    i ++;
#line 118
    p = (char const   *)p2;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_write(char const   *path , struct counters *counters ) 
{ 
  size_t i ;
  char *tmp_file ;
  FILE *f ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = tmp_string();
#line 130
  tmp_file = format("%s.tmp.%s", path, tmp);
#line 131
  f = fopen((char const   */* __restrict  */)tmp_file, (char const   */* __restrict  */)"wb");
  }
#line 132
  if (! f) {
    {
#line 133
    cc_log("Failed to open %s", tmp_file);
    }
#line 134
    goto end;
  }
#line 136
  i = (size_t )0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < counters->size)) {
#line 136
      goto while_break;
    }
    {
#line 137
    tmp___0 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%u\n",
                      *(counters->data + i));
    }
#line 137
    if (tmp___0 < 0) {
      {
#line 138
      fatal("Failed to write to %s", tmp_file);
      }
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  fclose(f);
#line 142
  x_rename((char const   *)tmp_file, path);
  }
  end: 
  {
#line 145
  free((void *)tmp_file);
  }
#line 146
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static void stats_default(struct counters *counters ) 
{ 


  {
#line 152
  *(counters->data + 14) += 65536U;
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
static void init_counter_updates(void) 
{ 


  {
#line 158
  if (! counter_updates) {
    {
#line 159
    counter_updates = counters_init((size_t )29);
    }
  }
#line 161
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_update_size(enum stats stat___0 , size_t size , unsigned int files___0 ) 
{ 


  {
  {
#line 170
  init_counter_updates();
  }
#line 171
  if ((unsigned int )stat___0 != 0U) {
#line 172
    (*(counter_updates->data + stat___0)) ++;
  }
#line 174
  *(counter_updates->data + 11) += files___0;
#line 175
  *(counter_updates->data + 12) = (unsigned int )((size_t )*(counter_updates->data + 12) + size);
#line 176
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_read(char const   *sfile , struct counters *counters ) 
{ 
  char *data ;
  char *tmp ;

  {
  {
#line 182
  tmp = read_text_file(sfile);
#line 182
  data = tmp;
  }
#line 183
  if (data) {
    {
#line 184
    parse_stats(counters, (char const   *)data);
    }
  } else {
    {
#line 186
    stats_default(counters);
    }
  }
  {
#line 188
  free((void *)data);
  }
#line 189
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_flush(void) 
{ 
  struct counters *counters ;
  _Bool need_cleanup ;
  _Bool should_flush ;
  int i ;
  char *tmp ;
  char *stats_dir ;
  __pid_t tmp___0 ;
  unsigned int tmp___1 ;
  _Bool tmp___2 ;
  char *p ;
  char *tmp___3 ;

  {
  {
#line 198
  need_cleanup = (_Bool)0;
#line 199
  should_flush = (_Bool)0;
#line 203
  tmp = getenv("CCACHE_NOSTATS");
  }
#line 203
  if (tmp) {
#line 203
    return;
  }
  {
#line 205
  init_counter_updates();
#line 207
  i = 0;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i < 29)) {
#line 207
      goto while_break;
    }
#line 208
    if (*(counter_updates->data + i) > 0U) {
#line 209
      should_flush = (_Bool)1;
#line 210
      goto while_break;
    }
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if (! should_flush) {
#line 213
    return;
  }
#line 215
  if (! stats_file) {
#line 222
    if (! cache_dir) {
#line 222
      return;
    }
    {
#line 223
    tmp___0 = getpid();
#line 223
    tmp___1 = hash_from_int(tmp___0);
#line 223
    stats_dir = format("%s/%x", cache_dir, tmp___1 % 16U);
#line 224
    stats_file = format("%s/stats", stats_dir);
#line 225
    create_dir((char const   *)stats_dir);
#line 226
    free((void *)stats_dir);
    }
  }
  {
#line 229
  tmp___2 = lockfile_acquire((char const   *)stats_file, lock_staleness_limit);
  }
#line 229
  if (! tmp___2) {
#line 230
    return;
  }
  {
#line 232
  counters = counters_init((size_t )29);
#line 233
  stats_read((char const   *)stats_file, counters);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 234
    if (! (i < 29)) {
#line 234
      goto while_break___0;
    }
#line 235
    *(counters->data + i) += *(counter_updates->data + i);
#line 234
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 237
  stats_write((char const   *)stats_file, counters);
#line 238
  lockfile_release((char const   *)stats_file);
  }
#line 240
  if (cache_logfile) {
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 241
      if (! (i < 29)) {
#line 241
        goto while_break___1;
      }
#line 242
      if (*(counter_updates->data + stats_info[i].stat) != 0U) {
#line 242
        if (! (stats_info[i].flags & 1U)) {
          {
#line 244
          cc_log("Result: %s", stats_info[i].message);
          }
        }
      }
#line 241
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 249
  if (*(counters->data + 13) != 0U) {
#line 249
    if (*(counters->data + 11) > *(counters->data + 13)) {
#line 251
      need_cleanup = (_Bool)1;
    }
  }
#line 253
  if (*(counters->data + 14) != 0U) {
#line 253
    if (*(counters->data + 12) > *(counters->data + 14)) {
#line 255
      need_cleanup = (_Bool)1;
    }
  }
#line 258
  if (need_cleanup) {
    {
#line 259
    tmp___3 = dirname(stats_file);
#line 259
    p = tmp___3;
#line 260
    cleanup_dir((char const   *)p, (size_t )*(counters->data + 13), (size_t )*(counters->data + 14));
#line 263
    free((void *)p);
    }
  }
#line 265
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_update(enum stats stat___0 ) 
{ 


  {
  {
#line 271
  stats_update_size(stat___0, (size_t )0, 0U);
  }
#line 272
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
unsigned int stats_get_pending(enum stats stat___0 ) 
{ 


  {
  {
#line 278
  init_counter_updates();
  }
#line 279
  return (*(counter_updates->data + stat___0));
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_summary(void) 
{ 
  int dir ;
  int i ;
  struct counters *counters ;
  struct counters *tmp ;
  char *fname ;
  enum stats stat___0 ;

  {
  {
#line 287
  tmp = counters_init((size_t )29);
#line 287
  counters = tmp;
#line 290
  dir = -1;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (dir <= 15)) {
#line 290
      goto while_break;
    }
#line 293
    if (dir == -1) {
      {
#line 294
      fname = format("%s/stats", cache_dir);
      }
    } else {
      {
#line 296
      fname = format("%s/%1x/stats", cache_dir, dir);
      }
    }
    {
#line 299
    stats_read((char const   *)fname, counters);
#line 300
    free((void *)fname);
    }
#line 303
    if (dir == -1) {
#line 304
      *(counters->data + 14) = 0U;
    }
#line 290
    dir ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  printf((char const   */* __restrict  */)"cache directory                     %s\n",
         cache_dir);
#line 311
  i = 0;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    if (! stats_info[i].message) {
#line 311
      goto while_break___0;
    }
#line 312
    stat___0 = stats_info[i].stat;
#line 314
    if (*(counters->data + stat___0) == 0U) {
#line 314
      if (! (stats_info[i].flags & 2U)) {
#line 315
        goto __Cont;
      }
    }
    {
#line 318
    printf((char const   */* __restrict  */)"%s ", stats_info[i].message);
    }
#line 319
    if (stats_info[i].fn) {
      {
#line 320
      (*(stats_info[i].fn))((size_t )*(counters->data + stat___0));
#line 321
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 323
      printf((char const   */* __restrict  */)"%8u\n", *(counters->data + stat___0));
      }
    }
    __Cont: /* CIL Label */ 
#line 311
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 327
  counters_free(counters);
  }
#line 328
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_zero(void) 
{ 
  int dir ;
  unsigned int i ;
  char *fname ;
  struct counters *counters ;
  struct counters *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 338
  fname = format("%s/stats", cache_dir);
#line 339
  x_unlink((char const   *)fname);
#line 340
  free((void *)fname);
#line 342
  dir = 0;
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (dir <= 15)) {
#line 342
      goto while_break;
    }
    {
#line 343
    tmp = counters_init((size_t )29);
#line 343
    counters = tmp;
#line 344
    fname = format("%s/%1x/stats", cache_dir, dir);
#line 345
    tmp___0 = lockfile_acquire((char const   *)fname, lock_staleness_limit);
    }
#line 345
    if (tmp___0) {
      {
#line 346
      stats_read((char const   *)fname, counters);
#line 347
      i = 0U;
      }
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! stats_info[i].message) {
#line 347
          goto while_break___0;
        }
#line 348
        if (! (stats_info[i].flags & 1U)) {
#line 349
          *(counters->data + stats_info[i].stat) = 0U;
        }
#line 347
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 352
      stats_write((char const   *)fname, counters);
#line 353
      lockfile_release((char const   *)fname);
      }
    }
    {
#line 355
    counters_free(counters);
#line 356
    free((void *)fname);
#line 342
    dir ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_get_limits(char const   *dir , unsigned int *maxfiles , unsigned int *maxsize ) 
{ 
  struct counters *counters ;
  struct counters *tmp ;
  char *sname ;
  char *tmp___0 ;

  {
  {
#line 364
  tmp = counters_init((size_t )29);
#line 364
  counters = tmp;
#line 365
  tmp___0 = format("%s/stats", dir);
#line 365
  sname = tmp___0;
#line 366
  stats_read((char const   *)sname, counters);
#line 367
  *maxfiles = *(counters->data + 13);
#line 368
  *maxsize = *(counters->data + 14);
#line 369
  free((void *)sname);
#line 370
  counters_free(counters);
  }
#line 371
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
int stats_set_limits(long maxfiles , long maxsize ) 
{ 
  int dir ;
  int tmp ;
  char *fname ;
  char *cdir ;
  int tmp___0 ;
  struct counters *counters ;
  struct counters *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 379
  if (maxfiles != -1L) {
#line 380
    maxfiles /= 16L;
  }
#line 382
  if (maxsize != -1L) {
#line 383
    maxsize /= 16L;
  }
  {
#line 386
  tmp = create_dir((char const   *)cache_dir);
  }
#line 386
  if (tmp != 0) {
#line 387
    return (1);
  }
#line 391
  dir = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (dir <= 15)) {
#line 391
      goto while_break;
    }
    {
#line 394
    cdir = format("%s/%1x", cache_dir, dir);
#line 395
    tmp___0 = create_dir((char const   *)cdir);
    }
#line 395
    if (tmp___0 != 0) {
      {
#line 396
      free((void *)cdir);
      }
#line 397
      return (1);
    }
    {
#line 399
    fname = format("%s/stats", cdir);
#line 400
    free((void *)cdir);
#line 402
    tmp___2 = lockfile_acquire((char const   *)fname, lock_staleness_limit);
    }
#line 402
    if (tmp___2) {
      {
#line 403
      tmp___1 = counters_init((size_t )29);
#line 403
      counters = tmp___1;
#line 404
      stats_read((char const   *)fname, counters);
      }
#line 405
      if (maxfiles != -1L) {
#line 406
        *(counters->data + 13) = (unsigned int )maxfiles;
      }
#line 408
      if (maxsize != -1L) {
#line 409
        *(counters->data + 14) = (unsigned int )maxsize;
      }
      {
#line 411
      stats_write((char const   *)fname, counters);
#line 412
      lockfile_release((char const   *)fname);
#line 413
      counters_free(counters);
      }
    }
    {
#line 415
    free((void *)fname);
#line 391
    dir ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return (0);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/stats.c"
void stats_set_sizes(char const   *dir , size_t num_files___0 , size_t total_size ) 
{ 
  struct counters *counters ;
  struct counters *tmp ;
  char *statsfile ;
  _Bool tmp___0 ;

  {
  {
#line 425
  tmp = counters_init((size_t )29);
#line 425
  counters = tmp;
#line 428
  create_dir(dir);
#line 429
  statsfile = format("%s/stats", dir);
#line 431
  tmp___0 = lockfile_acquire((char const   *)statsfile, lock_staleness_limit);
  }
#line 431
  if (tmp___0) {
    {
#line 432
    stats_read((char const   *)statsfile, counters);
#line 433
    *(counters->data + 11) = (unsigned int )num_files___0;
#line 434
    *(counters->data + 12) = (unsigned int )total_size;
#line 435
    stats_write((char const   *)statsfile, counters);
#line 436
    lockfile_release((char const   *)statsfile);
    }
  }
  {
#line 438
  free((void *)statsfile);
#line 439
  counters_free(counters);
  }
#line 440
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
struct args *args_init(int init_argc , char **init_args ) ;
#line 71
struct args *args_init_from_string(char const   *command ) ;
#line 72
struct args *args_copy(struct args *args ) ;
#line 73
void args_free(struct args *args ) ;
#line 74
void args_add(struct args *args , char const   *s ) ;
#line 75
void args_add_prefix(struct args *args , char const   *s ) ;
#line 76
void args_extend(struct args *args , struct args *to_append ) ;
#line 77
void args_pop(struct args *args , int n ) ;
#line 78
void args_set(struct args *args , int index___0 , char const   *value ) ;
#line 79
void args_strip(struct args *args , char const   *prefix ) ;
#line 80
void args_remove_first(struct args *args ) ;
#line 81
char *args_to_string(struct args *args ) ;
#line 82
_Bool args_equal(struct args *args1 , struct args *args2 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
struct args *args_init(int init_argc , char **init_args ) 
{ 
  struct args *args ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 26
  tmp = x_malloc(sizeof(struct args ));
#line 26
  args = (struct args *)tmp;
#line 27
  args->argc = 0;
#line 28
  tmp___0 = x_malloc(sizeof(char *));
#line 28
  args->argv = (char **)tmp___0;
#line 29
  *(args->argv + 0) = (char *)((void *)0);
#line 30
  i = 0;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < init_argc)) {
#line 30
      goto while_break;
    }
    {
#line 31
    args_add(args, (char const   *)*(init_args + i));
#line 30
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  return (args);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
struct args *args_init_from_string(char const   *command ) 
{ 
  struct args *args ;
  char *p ;
  char *tmp ;
  char *q ;
  char *word ;
  char *saveptr ;

  {
  {
#line 40
  tmp = x_strdup(command);
#line 40
  p = tmp;
#line 41
  q = p;
#line 42
  saveptr = (char *)((void *)0);
#line 44
  args = args_init(0, (char **)((void *)0));
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    word = strtok_r((char */* __restrict  */)q, (char const   */* __restrict  */)" \t\r\n",
                    (char **/* __restrict  */)(& saveptr));
    }
#line 45
    if (! word) {
#line 45
      goto while_break;
    }
    {
#line 46
    args_add(args, (char const   *)word);
#line 47
    q = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  free((void *)p);
  }
#line 51
  return (args);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
struct args *args_copy(struct args *args ) 
{ 
  struct args *tmp ;

  {
  {
#line 57
  tmp = args_init(args->argc, args->argv);
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_free(struct args *args ) 
{ 
  int i ;

  {
#line 64
  if (! args) {
#line 64
    return;
  }
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < args->argc)) {
#line 65
      goto while_break;
    }
#line 66
    if (*(args->argv + i)) {
      {
#line 67
      free((void *)*(args->argv + i));
      }
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  free((void *)args->argv);
#line 71
  free((void *)args);
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_add(struct args *args , char const   *s ) 
{ 
  void *tmp ;

  {
  {
#line 77
  tmp = x_realloc((void *)args->argv, (unsigned long )(args->argc + 2) * sizeof(char *));
#line 77
  args->argv = (char **)tmp;
#line 78
  *(args->argv + args->argc) = x_strdup(s);
#line 79
  (args->argc) ++;
#line 80
  *(args->argv + args->argc) = (char *)((void *)0);
  }
#line 81
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_extend(struct args *args , struct args *to_append ) 
{ 
  int i ;

  {
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < to_append->argc)) {
#line 88
      goto while_break;
    }
    {
#line 89
    args_add(args, (char const   *)*(to_append->argv + i));
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_pop(struct args *args , int n ) 
{ 
  int tmp ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    tmp = n;
#line 97
    n --;
#line 97
    if (! tmp) {
#line 97
      goto while_break;
    }
    {
#line 98
    (args->argc) --;
#line 99
    free((void *)*(args->argv + args->argc));
#line 100
    *(args->argv + args->argc) = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_set(struct args *args , int index___0 , char const   *value ) 
{ 


  {
#line 108
  if (! (index___0 < args->argc)) {
    {
#line 108
    __assert_fail("index < args->argc", "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c",
                  108U, "args_set");
    }
  }
  {
#line 109
  free((void *)*(args->argv + index___0));
#line 110
  *(args->argv + index___0) = x_strdup(value);
  }
#line 111
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_remove_first(struct args *args ) 
{ 


  {
  {
#line 117
  free((void *)*(args->argv + 0));
#line 118
  memmove((void *)(args->argv + 0), (void const   *)(args->argv + 1), (unsigned long )args->argc * sizeof(*(args->argv + 0)));
#line 119
  (args->argc) --;
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_add_prefix(struct args *args , char const   *s ) 
{ 
  void *tmp ;

  {
  {
#line 126
  tmp = x_realloc((void *)args->argv, (unsigned long )(args->argc + 2) * sizeof(char *));
#line 126
  args->argv = (char **)tmp;
#line 127
  memmove((void *)(args->argv + 1), (void const   *)(args->argv + 0), (unsigned long )(args->argc + 1) * sizeof(*(args->argv + 0)));
#line 129
  *(args->argv + 0) = x_strdup(s);
#line 130
  (args->argc) ++;
  }
#line 131
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
void args_strip(struct args *args , char const   *prefix ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < args->argc)) {
#line 138
      goto while_break;
    }
    {
#line 139
    tmp = strlen(prefix);
#line 139
    tmp___0 = strncmp((char const   *)*(args->argv + i), prefix, tmp);
    }
#line 139
    if (tmp___0 == 0) {
      {
#line 140
      free((void *)*(args->argv + i));
#line 141
      memmove((void *)(args->argv + i), (void const   *)(args->argv + (i + 1)), (unsigned long )(args->argc - i) * sizeof(*(args->argv + i)));
#line 144
      (args->argc) --;
      }
    } else {
#line 146
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
char *args_to_string(struct args *args ) 
{ 
  char *result ;
  char **p ;
  unsigned int size ;
  int pos ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 160
  size = 0U;
#line 162
  p = args->argv;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! *p) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = strlen((char const   *)*p);
#line 163
    size = (unsigned int )((size_t )size + (tmp + 1UL));
#line 162
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  tmp___0 = x_malloc((size_t )(size + 1U));
#line 165
  result = (char *)tmp___0;
#line 166
  pos = 0;
#line 167
  p = args->argv;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! *p) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    tmp___1 = sprintf((char */* __restrict  */)(result + pos), (char const   */* __restrict  */)"%s ",
                      *p);
#line 168
    pos += tmp___1;
#line 167
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  *(result + (pos - 1)) = (char )'\000';
#line 171
  return (result);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/args.c"
_Bool args_equal(struct args *args1 , struct args *args2 ) 
{ 
  int i ;
  int tmp ;

  {
#line 179
  if (args1->argc != args2->argc) {
#line 180
    return ((_Bool)0);
  }
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < args1->argc)) {
#line 182
      goto while_break;
    }
    {
#line 183
    tmp = strcmp((char const   *)*(args1->argv + i), (char const   *)*(args2->argv + i));
    }
#line 183
    if (! (tmp == 0)) {
#line 184
      return ((_Bool)0);
    }
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ((_Bool)1);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.h"
struct hashtable *create_hashtable(unsigned int minsize , unsigned int (*hashf)(void * ) ,
                                   int (*eqf)(void * , void * ) ) ;
#line 129
int hashtable_insert(struct hashtable *h , void *k , void *v ) ;
#line 147
void *hashtable_search(struct hashtable *h , void *k ) ;
#line 165
void *hashtable_remove(struct hashtable *h , void *k ) ;
#line 182
unsigned int hashtable_count(struct hashtable *h ) ;
#line 194
void hashtable_destroy(struct hashtable *h , int free_values ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_private.h"
unsigned int hash(struct hashtable *h , void *k ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_private.h"
__inline static unsigned int indexFor(unsigned int tablelength , unsigned int hashvalue ) 
{ 


  {
#line 34
  return (hashvalue % tablelength);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
static unsigned int const   primes[26]  = 
#line 44 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
  {      (unsigned int const   )53,      (unsigned int const   )97,      (unsigned int const   )193,      (unsigned int const   )389, 
        (unsigned int const   )769,      (unsigned int const   )1543,      (unsigned int const   )3079,      (unsigned int const   )6151, 
        (unsigned int const   )12289,      (unsigned int const   )24593,      (unsigned int const   )49157,      (unsigned int const   )98317, 
        (unsigned int const   )196613,      (unsigned int const   )393241,      (unsigned int const   )786433,      (unsigned int const   )1572869, 
        (unsigned int const   )3145739,      (unsigned int const   )6291469,      (unsigned int const   )12582917,      (unsigned int const   )25165843, 
        (unsigned int const   )50331653,      (unsigned int const   )100663319,      (unsigned int const   )201326611,      (unsigned int const   )402653189, 
        (unsigned int const   )805306457,      (unsigned int const   )1610612741};
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
unsigned int const   prime_table_length  =    (unsigned int const   )(sizeof(primes) / sizeof(primes[0]));
#line 54 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
float const   max_load_factor  =    (float const   )0.65;
#line 57 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
struct hashtable *create_hashtable(unsigned int minsize , unsigned int (*hashf)(void * ) ,
                                   int (*eqf)(void * , void * ) ) 
{ 
  struct hashtable *h ;
  unsigned int pindex ;
  unsigned int size ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 63
  size = (unsigned int )primes[0];
#line 65
  if (minsize > 1U << 30) {
#line 65
    return ((struct hashtable *)((void *)0));
  }
#line 67
  pindex = 0U;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (pindex < (unsigned int )prime_table_length)) {
#line 67
      goto while_break;
    }
#line 68
    if (primes[pindex] > (unsigned int const   )minsize) {
#line 68
      size = (unsigned int )primes[pindex];
#line 68
      goto while_break;
    }
#line 67
    pindex ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp = malloc(sizeof(struct hashtable ));
#line 70
  h = (struct hashtable *)tmp;
  }
#line 71
  if ((unsigned long )((void *)0) == (unsigned long )h) {
#line 71
    return ((struct hashtable *)((void *)0));
  }
  {
#line 72
  tmp___0 = malloc(sizeof(struct entry *) * (unsigned long )size);
#line 72
  h->table = (struct entry **)tmp___0;
  }
#line 73
  if ((unsigned long )((void *)0) == (unsigned long )h->table) {
    {
#line 73
    free((void *)h);
    }
#line 73
    return ((struct hashtable *)((void *)0));
  }
  {
#line 74
  memset((void *)h->table, 0, (unsigned long )size * sizeof(struct entry *));
#line 75
  h->tablelength = size;
#line 76
  h->primeindex = pindex;
#line 77
  h->entrycount = 0U;
#line 78
  h->hashfn = hashf;
#line 79
  h->eqfn = eqf;
#line 80
  tmp___1 = ceil((double )((float const   )size * max_load_factor));
#line 80
  h->loadlimit = (unsigned int )tmp___1;
  }
#line 81
  return (h);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
unsigned int hash(struct hashtable *h , void *k ) 
{ 
  unsigned int i ;
  unsigned int tmp ;

  {
  {
#line 90
  tmp = (*(h->hashfn))(k);
#line 90
  i = tmp;
#line 91
  i += ~ (i << 9);
#line 92
  i ^= (i >> 14) | (i << 18);
#line 93
  i += i << 4;
#line 94
  i ^= (i >> 10) | (i << 22);
  }
#line 95
  return (i);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
static int hashtable_expand(struct hashtable *h ) 
{ 
  struct entry **newtable ;
  struct entry *e ;
  struct entry **pE ;
  unsigned int newsize ;
  unsigned int i ;
  unsigned int index___0 ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 108
  if (h->primeindex == (unsigned int )(prime_table_length - 1U)) {
#line 108
    return (0);
  }
  {
#line 109
  (h->primeindex) ++;
#line 109
  newsize = (unsigned int )primes[h->primeindex];
#line 111
  tmp = malloc(sizeof(struct entry *) * (unsigned long )newsize);
#line 111
  newtable = (struct entry **)tmp;
  }
#line 112
  if ((unsigned long )((void *)0) != (unsigned long )newtable) {
    {
#line 114
    memset((void *)newtable, 0, (unsigned long )newsize * sizeof(struct entry *));
#line 117
    i = 0U;
    }
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! (i < h->tablelength)) {
#line 117
        goto while_break;
      }
      {
#line 118
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 118
        e = *(h->table + i);
#line 118
        if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 118
          goto while_break___0;
        }
        {
#line 119
        *(h->table + i) = e->next;
#line 120
        index___0 = indexFor(newsize, e->h);
#line 121
        e->next = *(newtable + index___0);
#line 122
        *(newtable + index___0) = e;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 117
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 125
    free((void *)h->table);
#line 126
    h->table = newtable;
    }
  } else {
    {
#line 131
    tmp___0 = realloc((void *)h->table, (unsigned long )newsize * sizeof(struct entry *));
#line 131
    newtable = (struct entry **)tmp___0;
    }
#line 133
    if ((unsigned long )((void *)0) == (unsigned long )newtable) {
#line 133
      (h->primeindex) --;
#line 133
      return (0);
    }
    {
#line 134
    h->table = newtable;
#line 135
    memset((void *)*(newtable + h->tablelength), 0, (size_t )(newsize - h->tablelength));
#line 136
    i = 0U;
    }
    {
#line 136
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      if (! (i < h->tablelength)) {
#line 136
        goto while_break___1;
      }
#line 137
      pE = newtable + i;
#line 137
      e = *pE;
      {
#line 137
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 137
        if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 137
          goto while_break___2;
        }
        {
#line 138
        index___0 = indexFor(newsize, e->h);
        }
#line 139
        if (index___0 == i) {
#line 141
          pE = & e->next;
        } else {
#line 145
          *pE = e->next;
#line 146
          e->next = *(newtable + index___0);
#line 147
          *(newtable + index___0) = e;
        }
#line 137
        e = *pE;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 136
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 152
  h->tablelength = newsize;
#line 153
  tmp___1 = ceil((double )((float const   )newsize * max_load_factor));
#line 153
  h->loadlimit = (unsigned int )tmp___1;
  }
#line 154
  return (-1);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
unsigned int hashtable_count(struct hashtable *h ) 
{ 


  {
#line 161
  return (h->entrycount);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
int hashtable_insert(struct hashtable *h , void *k , void *v ) 
{ 
  unsigned int index___0 ;
  struct entry *e ;
  void *tmp ;

  {
#line 171
  (h->entrycount) ++;
#line 171
  if (h->entrycount > h->loadlimit) {
    {
#line 177
    hashtable_expand(h);
    }
  }
  {
#line 179
  tmp = malloc(sizeof(struct entry ));
#line 179
  e = (struct entry *)tmp;
  }
#line 180
  if ((unsigned long )((void *)0) == (unsigned long )e) {
#line 180
    (h->entrycount) --;
#line 180
    return (0);
  }
  {
#line 181
  e->h = hash(h, k);
#line 182
  index___0 = indexFor(h->tablelength, e->h);
#line 183
  e->k = k;
#line 184
  e->v = v;
#line 185
  e->next = *(h->table + index___0);
#line 186
  *(h->table + index___0) = e;
  }
#line 187
  return (-1);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
void *hashtable_search(struct hashtable *h , void *k ) 
{ 
  struct entry *e ;
  unsigned int hashvalue ;
  unsigned int index___0 ;
  int tmp ;

  {
  {
#line 196
  hashvalue = hash(h, k);
#line 197
  index___0 = indexFor(h->tablelength, hashvalue);
#line 198
  e = *(h->table + index___0);
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 199
      goto while_break;
    }
#line 202
    if (hashvalue == e->h) {
      {
#line 202
      tmp = (*(h->eqfn))(k, e->k);
      }
#line 202
      if (tmp) {
#line 202
        return (e->v);
      }
    }
#line 203
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((void *)0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
void *hashtable_remove(struct hashtable *h , void *k ) 
{ 
  struct entry *e ;
  struct entry **pE ;
  void *v ;
  unsigned int hashvalue ;
  unsigned int index___0 ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 220
  hashvalue = hash(h, k);
#line 221
  tmp = hash(h, k);
#line 221
  index___0 = indexFor(h->tablelength, tmp);
#line 222
  pE = h->table + index___0;
#line 223
  e = *pE;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 224
      goto while_break;
    }
#line 227
    if (hashvalue == e->h) {
      {
#line 227
      tmp___0 = (*(h->eqfn))(k, e->k);
      }
#line 227
      if (tmp___0) {
        {
#line 229
        *pE = e->next;
#line 230
        (h->entrycount) --;
#line 231
        v = e->v;
#line 232
        free(e->k);
#line 233
        free((void *)e);
        }
#line 234
        return (v);
      }
    }
#line 236
    pE = & e->next;
#line 237
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return ((void *)0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable.c"
void hashtable_destroy(struct hashtable *h , int free_values ) 
{ 
  unsigned int i ;
  struct entry *e ;
  struct entry *f ;
  struct entry **table ;

  {
#line 249
  table = h->table;
#line 250
  if (free_values) {
#line 252
    i = 0U;
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! (i < h->tablelength)) {
#line 252
        goto while_break;
      }
#line 254
      e = *(table + i);
      {
#line 255
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 255
        if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 255
          goto while_break___0;
        }
        {
#line 256
        f = e;
#line 256
        e = e->next;
#line 256
        free(f->k);
#line 256
        free(f->v);
#line 256
        free((void *)f);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 252
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 261
    i = 0U;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! (i < h->tablelength)) {
#line 261
        goto while_break___1;
      }
#line 263
      e = *(table + i);
      {
#line 264
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 264
        if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 264
          goto while_break___2;
        }
        {
#line 265
        f = e;
#line 265
        e = e->next;
#line 265
        free(f->k);
#line 265
        free((void *)f);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 261
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 268
  free((void *)h->table);
#line 269
  free((void *)h);
  }
#line 270
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 790 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 169 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.h"
int unify_hash(struct mdfour *hash___0 , char const   *fname ) ;
#line 204
_Bool cc_process_args(struct args *orig_args___0 , struct args **preprocessor_args ,
                      struct args **compiler_args ) ;
#line 206
void cc_reset(void) ;
#line 207
_Bool is_precompiled_header(char const   *path ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.h"
__inline void *hashtable_iterator_key(struct hashtable_itr *i ) 
{ 


  {
#line 35
  return ((i->e)->k);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.h"
__inline void *hashtable_iterator_value(struct hashtable_itr *i ) 
{ 


  {
#line 49
  return ((i->e)->v);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.h"
unsigned int hash_from_string(void *str ) ;
#line 15
int strings_equal(void *str1 , void *str2 ) ;
#line 16
int file_hashes_equal(struct file_hash *fh1 , struct file_hash *fh2 ) ;
#line 23
int hash_source_code_string(struct mdfour *hash___0 , char const   *str , size_t len___0 ,
                            char const   *path ) ;
#line 25
int hash_source_code_file(struct mdfour *hash___0 , char const   *path ) ;
#line 28
_Bool hash_multicommand_output(struct mdfour *hash___0 , char const   *commands ,
                               char const   *compiler ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.h"
struct file_hash *manifest_get(char const   *manifest_path___0 ) ;
#line 8
_Bool manifest_put(char const   *manifest_path___0 , struct file_hash *object_hash ,
                   struct hashtable *included_files___0 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char const   VERSION_TEXT[338]  = 
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
  {      (char const   )'c',      (char const   )'c',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )'\n',      (char const   )'\n',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'C',      (char const   )')', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'7',      (char const   )' ',      (char const   )'A', 
        (char const   )'n',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'w',      (char const   )' ',      (char const   )'T',      (char const   )'r', 
        (char const   )'i',      (char const   )'d',      (char const   )'g',      (char const   )'e', 
        (char const   )'l',      (char const   )'l',      (char const   )'\n',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'C',      (char const   )')', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'9',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'1',      (char const   )'1',      (char const   )' ',      (char const   )'J', 
        (char const   )'o',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'R',      (char const   )'o',      (char const   )'s',      (char const   )'d', 
        (char const   )'a',      (char const   )'h',      (char const   )'l',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )'f',      (char const   )'t',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )';',      (char const   )' ', 
        (char const   )'y',      (char const   )'o',      (char const   )'u',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'b',      (char const   )'u',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'/', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'r',      (char const   )'\n',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'s', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'u', 
        (char const   )'b',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'h',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'F', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'S',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )'\n',      (char const   )'F',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )';', 
        (char const   )' ',      (char const   )'e',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'3',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'(',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )')',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\n', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char const   USAGE_TEXT[894]  = 
#line 46
  {      (char const   )'U',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'c',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'[',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )']',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'c',      (char const   )'c',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'[',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )']',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'[',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )']',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'(',      (char const   )'v',      (char const   )'i',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'y',      (char const   )'m', 
        (char const   )'b',      (char const   )'o',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )')',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'O',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )':',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'c', 
        (char const   )',',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'n',      (char const   )'u',      (char const   )'p',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'e', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'l',      (char const   )'d',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'c',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'(',      (char const   )'n',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )'y',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'n', 
        (char const   )'e',      (char const   )'e',      (char const   )'d',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'n', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'u', 
        (char const   )'t',      (char const   )'o',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'y',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'C',      (char const   )',', 
        (char const   )' ',      (char const   )'-',      (char const   )'-',      (char const   )'c', 
        (char const   )'l',      (char const   )'e',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'l',      (char const   )'e',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )'t',      (char const   )'e',      (char const   )'l', 
        (char const   )'y',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'F', 
        (char const   )',',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'m',      (char const   )'a',      (char const   )'x',      (char const   )'-', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'s',      (char const   )'=',      (char const   )'N',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'x',      (char const   )'i', 
        (char const   )'m',      (char const   )'u',      (char const   )'m',      (char const   )' ', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )'b', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'N',      (char const   )' ',      (char const   )'(',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'0', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'m',      (char const   )'i',      (char const   )'t',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'M',      (char const   )',', 
        (char const   )' ',      (char const   )'-',      (char const   )'-',      (char const   )'m', 
        (char const   )'a',      (char const   )'x',      (char const   )'-',      (char const   )'s', 
        (char const   )'i',      (char const   )'z',      (char const   )'e',      (char const   )'=', 
        (char const   )'S',      (char const   )'I',      (char const   )'Z',      (char const   )'E', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'x',      (char const   )'i',      (char const   )'m', 
        (char const   )'u',      (char const   )'m',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'z',      (char const   )'e',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'S',      (char const   )'I',      (char const   )'Z',      (char const   )'E', 
        (char const   )' ',      (char const   )'(',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'0',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'l',      (char const   )'i',      (char const   )'m', 
        (char const   )'i',      (char const   )'t',      (char const   )';',      (char const   )' ', 
        (char const   )'a',      (char const   )'v',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'u', 
        (char const   )'f',      (char const   )'f',      (char const   )'i',      (char const   )'x', 
        (char const   )'e',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'G',      (char const   )',',      (char const   )' ',      (char const   )'M', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'K',      (char const   )';',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'u', 
        (char const   )'f',      (char const   )'f',      (char const   )'i',      (char const   )'x', 
        (char const   )':',      (char const   )' ',      (char const   )'G',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'s',      (char const   )',', 
        (char const   )' ',      (char const   )'-',      (char const   )'-',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'w',      (char const   )'-', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'w',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'i', 
        (char const   )'c',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'u',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'r',      (char const   )'y',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'z',      (char const   )',',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'-',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'i',      (char const   )'c',      (char const   )'s', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'\n',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'h',      (char const   )',',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'h',      (char const   )'e',      (char const   )'l', 
        (char const   )'p',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'t',      (char const   )'e',      (char const   )'x', 
        (char const   )'t',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'V', 
        (char const   )',',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'S',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'s', 
        (char const   )'o',      (char const   )' ',      (char const   )'<',      (char const   )'h', 
        (char const   )'t',      (char const   )'t',      (char const   )'p',      (char const   )':', 
        (char const   )'/',      (char const   )'/',      (char const   )'c',      (char const   )'c', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'.',      (char const   )'s',      (char const   )'a',      (char const   )'m', 
        (char const   )'b',      (char const   )'a',      (char const   )'.',      (char const   )'o', 
        (char const   )'r',      (char const   )'g',      (char const   )'>',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
char *current_working_dir  =    (char *)((void *)0);
#line 73 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
char *cache_dir  =    (char *)((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *temp_dir  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
char *cache_logfile  =    (char *)((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
char *base_dir  =    (char *)((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct args *orig_args  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *input_file  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *output_obj  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *output_dep  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct file_hash *cached_obj_hash  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *cached_obj  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *cached_stderr  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *cached_dep  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *manifest_path  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static time_t time_of_compilation  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
unsigned int sloppiness  =    0U;
#line 139 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct hashtable *included_files  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool generating_dependencies  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char const   *i_extension  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *i_tmpfile  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool direct_i_file  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *cpp_stderr  ;
#line 160 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
char *stats_file  =    (char *)((void *)0);
#line 163 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool enable_unify  ;
#line 166 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool enable_direct  =    (_Bool)1;
#line 172 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool enable_compression  =    (_Bool)0;
#line 175 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static int nlevels  =    2;
#line 181 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool compile_preprocessed_source_code  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool output_is_precompiled_header  =    (_Bool)0;
#line 189 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool using_precompiled_header  =    (_Bool)0;
#line 192 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
unsigned int lock_staleness_limit  =    2000000U;
#line 207 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char const   HASH_PREFIX[2]  = {      (char const   )'3',      (char const   )'\000'};
#line 210 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void failed(void) 
{ 
  char *e ;
  char *p ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 216
  args_strip(orig_args, "--ccache-");
#line 218
  e = getenv("CCACHE_PREFIX");
  }
#line 218
  if (e) {
    {
#line 219
    tmp = find_executable((char const   *)e, "ccache");
#line 219
    p = tmp;
    }
#line 220
    if (! p) {
      {
#line 221
      tmp___0 = __errno_location();
#line 221
      tmp___1 = strerror(*tmp___0);
#line 221
      fatal("%s: %s", e, tmp___1);
      }
    }
    {
#line 223
    args_add_prefix(orig_args, (char const   *)p);
    }
  }
  {
#line 226
  cc_log("Failed; falling back to running the real compiler");
#line 227
  cc_log_argv("Executing ", orig_args->argv);
#line 228
  exitfn_call();
#line 229
  execv((char const   *)*(orig_args->argv + 0), (char * const  *)orig_args->argv);
#line 230
  tmp___2 = __errno_location();
#line 230
  tmp___3 = strerror(*tmp___2);
#line 230
  fatal("%s: execv returned (%s)", *(orig_args->argv + 0), tmp___3);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void clean_up_tmp_files(void) 
{ 


  {
#line 237
  if (i_tmpfile) {
#line 238
    if (! direct_i_file) {
      {
#line 239
      tmp_unlink((char const   *)i_tmpfile);
      }
    }
    {
#line 241
    free((void *)i_tmpfile);
#line 242
    i_tmpfile = (char *)((void *)0);
    }
  }
#line 246
  if (cpp_stderr) {
    {
#line 247
    tmp_unlink((char const   *)cpp_stderr);
#line 248
    free((void *)cpp_stderr);
#line 249
    cpp_stderr = (char *)((void *)0);
    }
  }
#line 251
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *get_path_in_cache(char const   *name , char const   *suffix ) 
{ 
  int i ;
  char *path ;
  char *result ;
  char *p ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 264
  path = x_strdup((char const   *)cache_dir);
#line 265
  i = 0;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (i < nlevels)) {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp = format("%s/%c", path, (int const   )*(name + i));
#line 266
    p = tmp;
#line 267
    free((void *)path);
#line 268
    path = p;
#line 269
    tmp___2 = getenv("CCACHE_READONLY");
    }
#line 269
    if (! tmp___2) {
      {
#line 269
      tmp___3 = create_dir((char const   *)path);
      }
#line 269
      if (tmp___3 != 0) {
        {
#line 270
        tmp___0 = __errno_location();
#line 270
        tmp___1 = strerror(*tmp___0);
#line 270
        fatal("Failed to create %s: %s", path, tmp___1);
        }
      }
    }
#line 265
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  result = format("%s/%s%s", path, name + nlevels, suffix);
#line 274
  free((void *)path);
  }
#line 275
  return (result);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void remember_include_file(char *path , size_t path_len , struct mdfour *cpp_hash ) 
{ 
  struct mdfour fhash ;
  struct stat st ;
  char *source ;
  size_t size ;
  int result ;
  _Bool is_pch ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct file_hash pch_hash ;
  _Bool tmp___4 ;
  struct file_hash *h ;
  _Bool tmp___5 ;
  void *tmp___6 ;

  {
#line 288
  source = (char *)((void *)0);
#line 293
  if (path_len >= 2UL) {
#line 293
    if ((int )*(path + 0) == 60) {
#line 293
      if ((int )*(path + (path_len - 1UL)) == 62) {
#line 295
        goto ignore;
      }
    }
  }
  {
#line 298
  tmp = strcmp((char const   *)path, (char const   *)input_file);
  }
#line 298
  if (tmp == 0) {
#line 300
    goto ignore;
  }
  {
#line 303
  tmp___0 = hashtable_search(included_files, (void *)path);
  }
#line 303
  if (tmp___0) {
#line 305
    goto ignore;
  }
  {
#line 308
  tmp___3 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 308
  if (tmp___3 != 0) {
    {
#line 309
    tmp___1 = __errno_location();
#line 309
    tmp___2 = strerror(*tmp___1);
#line 309
    cc_log("Failed to stat include file %s: %s", path, tmp___2);
    }
#line 310
    goto failure;
  }
#line 312
  if ((st.st_mode & 61440U) == 16384U) {
#line 314
    goto ignore;
  }
#line 316
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 318
    cc_log("Non-regular include file %s", path);
    }
#line 319
    goto failure;
  }
#line 323
  if (! (sloppiness & 1U)) {
#line 323
    if (st.st_mtim.tv_sec >= time_of_compilation) {
      {
#line 325
      cc_log("Include file %s too new", path);
      }
#line 326
      goto failure;
    }
  }
  {
#line 329
  hash_start(& fhash);
#line 331
  is_pch = is_precompiled_header((char const   *)path);
  }
#line 332
  if (is_pch) {
    {
#line 334
    tmp___4 = hash_file(& fhash, (char const   *)path);
    }
#line 334
    if (! tmp___4) {
#line 335
      goto failure;
    }
    {
#line 337
    hash_result_as_bytes(& fhash, pch_hash.hash);
#line 338
    pch_hash.size = (uint32_t )fhash.totalN;
#line 339
    hash_delimiter(cpp_hash, "pch_hash");
#line 340
    hash_buffer(cpp_hash, (void const   *)(pch_hash.hash), sizeof(pch_hash.hash));
    }
  }
#line 342
  if (enable_direct) {
#line 345
    if (! is_pch) {
#line 346
      if (st.st_size > 0L) {
        {
#line 347
        tmp___5 = read_file((char const   *)path, (size_t )st.st_size, & source, & size);
        }
#line 347
        if (! tmp___5) {
#line 348
          goto failure;
        }
      } else {
        {
#line 351
        source = x_strdup("");
#line 352
        size = (size_t )0;
        }
      }
      {
#line 355
      result = hash_source_code_string(& fhash, (char const   *)source, size, (char const   *)path);
      }
#line 356
      if (result & 1) {
#line 358
        goto failure;
      } else
#line 356
      if (result & 4) {
#line 358
        goto failure;
      }
    }
    {
#line 362
    tmp___6 = x_malloc(sizeof(*h));
#line 362
    h = (struct file_hash *)tmp___6;
#line 363
    hash_result_as_bytes(& fhash, h->hash);
#line 364
    h->size = (uint32_t )fhash.totalN;
#line 365
    hashtable_insert(included_files, (void *)path, (void *)h);
    }
  } else {
    {
#line 367
    free((void *)path);
    }
  }
  {
#line 370
  free((void *)source);
  }
#line 371
  return;
  failure: 
  {
#line 374
  cc_log("Disabling direct mode");
#line 375
  enable_direct = (_Bool)0;
  }
  ignore: 
  {
#line 378
  free((void *)path);
#line 379
  free((void *)source);
  }
#line 380
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static char *make_relative_path(char *path ) 
{ 
  char *relpath ;
  char *canon_path ;
  size_t tmp ;
  int tmp___0 ;
  char *cwd ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 391
  if (! base_dir) {
#line 392
    return (path);
  } else {
    {
#line 391
    tmp = strlen((char const   *)base_dir);
#line 391
    tmp___0 = strncmp((char const   *)path, (char const   *)base_dir, tmp);
    }
#line 391
    if (! (tmp___0 == 0)) {
#line 392
      return (path);
    }
  }
#line 395
  if (! current_working_dir) {
    {
#line 396
    tmp___1 = get_cwd();
#line 396
    cwd = tmp___1;
    }
#line 397
    if (cwd) {
      {
#line 398
      current_working_dir = x_realpath((char const   *)cwd);
#line 399
      free((void *)cwd);
      }
    }
#line 401
    if (! current_working_dir) {
      {
#line 402
      tmp___2 = __errno_location();
#line 402
      tmp___3 = strerror(*tmp___2);
#line 402
      cc_log("Unable to determine current working directory: %s", tmp___3);
#line 404
      failed();
      }
    }
  }
  {
#line 408
  canon_path = x_realpath((char const   *)path);
  }
#line 409
  if (canon_path) {
    {
#line 410
    free((void *)path);
#line 411
    path = canon_path;
    }
  }
  {
#line 416
  relpath = get_relative_path((char const   *)current_working_dir, (char const   *)path);
#line 417
  free((void *)path);
  }
#line 418
  return (relpath);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static _Bool process_preprocessed_file(struct mdfour *hash___0 , char const   *path ) 
{ 
  char *data ;
  char *p ;
  char *q ;
  char *end ;
  size_t size ;
  _Bool tmp ;
  char *path___0 ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 437
  tmp = read_file(path, (size_t )0, & data, & size);
  }
#line 437
  if (! tmp) {
#line 438
    return ((_Bool)0);
  }
  {
#line 441
  included_files = create_hashtable(1000U, & hash_from_string, & strings_equal);
#line 444
  end = data + size;
#line 445
  p = data;
#line 446
  q = data;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! ((unsigned long )q < (unsigned long )(end - 7))) {
#line 447
      goto while_break;
    }
#line 471
    if ((int )*(q + 0) == 35) {
#line 471
      if ((int )*(q + 1) == 32) {
#line 471
        if ((int )*(q + 2) >= 48) {
#line 471
          if ((int )*(q + 2) <= 57) {
#line 471
            goto _L___0;
          } else {
#line 471
            goto _L___3;
          }
        } else {
#line 471
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 471
      if ((int )*(q + 1) == 112) {
        {
#line 471
        tmp___0 = strlen("ragma GCC pch_preprocess ");
#line 471
        tmp___1 = strncmp((char const   *)(q + 2), "ragma GCC pch_preprocess ", tmp___0);
        }
#line 471
        if (tmp___1 == 0) {
#line 471
          goto _L___0;
        } else {
#line 471
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 471
      if ((int )*(q + 1) == 108) {
#line 471
        if ((int )*(q + 2) == 105) {
#line 471
          if ((int )*(q + 3) == 110) {
#line 471
            if ((int )*(q + 4) == 101) {
#line 471
              if ((int )*(q + 5) == 32) {
                _L___0: /* CIL Label */ 
#line 471
                if ((unsigned long )q == (unsigned long )data) {
#line 471
                  goto _L;
                } else
#line 471
                if ((int )*(q + -1) == 10) {
                  _L: /* CIL Label */ 
                  {
#line 483
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 483
                    if ((unsigned long )q < (unsigned long )end) {
#line 483
                      if ((int )*q != 34) {
#line 483
                        if (! ((int )*q != 10)) {
#line 483
                          goto while_break___0;
                        }
                      } else {
#line 483
                        goto while_break___0;
                      }
                    } else {
#line 483
                      goto while_break___0;
                    }
#line 484
                    q ++;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
#line 486
                  if ((unsigned long )q < (unsigned long )end) {
#line 486
                    if ((int )*q == 10) {
#line 488
                      goto while_continue;
                    }
                  }
#line 490
                  q ++;
#line 491
                  if ((unsigned long )q >= (unsigned long )end) {
                    {
#line 492
                    cc_log("Failed to parse included file path");
#line 493
                    free((void *)data);
                    }
#line 494
                    return ((_Bool)0);
                  }
                  {
#line 497
                  hash_buffer(hash___0, (void const   *)p, (size_t )(q - p));
#line 498
                  p = q;
                  }
                  {
#line 499
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 499
                    if ((unsigned long )q < (unsigned long )end) {
#line 499
                      if (! ((int )*q != 34)) {
#line 499
                        goto while_break___1;
                      }
                    } else {
#line 499
                      goto while_break___1;
                    }
#line 500
                    q ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                  {
#line 503
                  path___0 = x_strndup((char const   *)p, (size_t )(q - p));
#line 504
                  path___0 = make_relative_path(path___0);
#line 505
                  hash_string(hash___0, (char const   *)path___0);
#line 506
                  remember_include_file(path___0, (size_t )(q - p), hash___0);
#line 507
                  p = q;
                  }
                } else {
#line 509
                  q ++;
                }
              } else {
#line 509
                q ++;
              }
            } else {
#line 509
              q ++;
            }
          } else {
#line 509
            q ++;
          }
        } else {
#line 509
          q ++;
        }
      } else {
#line 509
        q ++;
      }
    } else {
#line 509
      q ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 513
  hash_buffer(hash___0, (void const   *)p, (size_t )(end - p));
#line 514
  free((void *)data);
  }
#line 515
  return ((_Bool)1);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void to_cache(struct args *args ) 
{ 
  char *tmp_stdout ;
  char *tmp_stderr ;
  char *tmp_obj ;
  struct stat st ;
  int status ;
  size_t added_bytes ;
  unsigned int added_files ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int fd_cpp_stderr ;
  int fd_real_stderr ;
  int fd_result ;
  char *tmp_stderr2 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int fd ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;

  {
  {
#line 525
  added_bytes = (size_t )0;
#line 526
  added_files = 0U;
#line 528
  tmp = tmp_string();
#line 528
  tmp_stdout = format("%s.tmp.stdout.%s", cached_obj, tmp);
#line 529
  tmp___0 = tmp_string();
#line 529
  tmp_stderr = format("%s.tmp.stderr.%s", cached_obj, tmp___0);
#line 530
  tmp___1 = tmp_string();
#line 530
  tmp_obj = format("%s.tmp.%s", cached_obj, tmp___1);
#line 532
  args_add(args, "-o");
#line 533
  args_add(args, (char const   *)tmp_obj);
#line 541
  putenv((char *)"DEPENDENCIES_OUTPUT");
  }
#line 543
  if (compile_preprocessed_source_code) {
    {
#line 544
    args_add(args, (char const   *)i_tmpfile);
    }
  } else {
    {
#line 546
    args_add(args, (char const   *)input_file);
    }
  }
  {
#line 549
  cc_log("Running real compiler");
#line 550
  status = execute(args->argv, (char const   *)tmp_stdout, (char const   *)tmp_stderr);
#line 551
  args_pop(args, 3);
#line 553
  tmp___4 = stat((char const   */* __restrict  */)tmp_stdout, (struct stat */* __restrict  */)(& st));
  }
#line 553
  if (tmp___4 != 0) {
    {
#line 555
    tmp___2 = __errno_location();
#line 555
    tmp___3 = strerror(*tmp___2);
#line 555
    cc_log("%s not found: %s", tmp_stdout, tmp___3);
#line 556
    stats_update((enum stats )7);
#line 557
    tmp_unlink((char const   *)tmp_stdout);
#line 558
    tmp_unlink((char const   *)tmp_stderr);
#line 559
    tmp_unlink((char const   *)tmp_obj);
#line 560
    failed();
    }
  }
#line 562
  if (st.st_size != 0L) {
    {
#line 563
    cc_log("Compiler produced stdout");
#line 564
    stats_update((enum stats )1);
#line 565
    tmp_unlink((char const   *)tmp_stdout);
#line 566
    tmp_unlink((char const   *)tmp_stderr);
#line 567
    tmp_unlink((char const   *)tmp_obj);
#line 568
    failed();
    }
  }
  {
#line 570
  tmp_unlink((char const   *)tmp_stdout);
  }
#line 576
  if (cpp_stderr) {
    {
#line 582
    tmp___5 = tmp_string();
#line 582
    tmp_stderr2 = format("%s.tmp.stderr2.%s", cached_obj, tmp___5);
#line 583
    tmp___8 = x_rename((char const   *)tmp_stderr, (char const   *)tmp_stderr2);
    }
#line 583
    if (tmp___8) {
      {
#line 584
      tmp___6 = __errno_location();
#line 584
      tmp___7 = strerror(*tmp___6);
#line 584
      cc_log("Failed to rename %s to %s: %s", tmp_stderr, tmp_stderr2, tmp___7);
#line 586
      failed();
      }
    }
    {
#line 588
    fd_cpp_stderr = open((char const   *)cpp_stderr, 0);
    }
#line 589
    if (fd_cpp_stderr == -1) {
      {
#line 590
      tmp___9 = __errno_location();
#line 590
      tmp___10 = strerror(*tmp___9);
#line 590
      cc_log("Failed opening %s: %s", cpp_stderr, tmp___10);
#line 591
      failed();
      }
    }
    {
#line 593
    fd_real_stderr = open((char const   *)tmp_stderr2, 0);
    }
#line 594
    if (fd_real_stderr == -1) {
      {
#line 595
      tmp___11 = __errno_location();
#line 595
      tmp___12 = strerror(*tmp___11);
#line 595
      cc_log("Failed opening %s: %s", tmp_stderr2, tmp___12);
#line 596
      failed();
      }
    }
    {
#line 598
    fd_result = open((char const   *)tmp_stderr, 577, 438);
    }
#line 599
    if (fd_result == -1) {
      {
#line 600
      tmp___13 = __errno_location();
#line 600
      tmp___14 = strerror(*tmp___13);
#line 600
      cc_log("Failed opening %s: %s", tmp_stderr, tmp___14);
#line 601
      failed();
      }
    }
    {
#line 603
    copy_fd(fd_cpp_stderr, fd_result);
#line 604
    copy_fd(fd_real_stderr, fd_result);
#line 605
    close(fd_cpp_stderr);
#line 606
    close(fd_real_stderr);
#line 607
    close(fd_result);
#line 608
    tmp_unlink((char const   *)tmp_stderr2);
#line 609
    free((void *)tmp_stderr2);
    }
  }
#line 612
  if (status != 0) {
    {
#line 614
    cc_log("Compiler gave exit status %d", status);
#line 615
    stats_update((enum stats )2);
#line 617
    fd = open((char const   *)tmp_stderr, 0);
    }
#line 618
    if (fd != -1) {
      {
#line 619
      tmp___15 = strcmp((char const   *)output_obj, "/dev/null");
      }
#line 619
      if (tmp___15 == 0) {
        {
#line 624
        copy_fd(fd, 2);
#line 625
        close(fd);
#line 626
        tmp_unlink((char const   *)tmp_stderr);
#line 627
        exit(status);
        }
      } else {
        {
#line 619
        tmp___16 = access((char const   *)tmp_obj, 4);
        }
#line 619
        if (tmp___16 == 0) {
          {
#line 619
          tmp___17 = move_file((char const   *)tmp_obj, (char const   *)output_obj,
                               0);
          }
#line 619
          if (tmp___17 == 0) {
            {
#line 624
            copy_fd(fd, 2);
#line 625
            close(fd);
#line 626
            tmp_unlink((char const   *)tmp_stderr);
#line 627
            exit(status);
            }
          } else {
#line 619
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 619
          tmp___18 = __errno_location();
          }
#line 619
          if (*tmp___18 == 2) {
            {
#line 624
            copy_fd(fd, 2);
#line 625
            close(fd);
#line 626
            tmp_unlink((char const   *)tmp_stderr);
#line 627
            exit(status);
            }
          }
        }
      }
    }
    {
#line 631
    tmp_unlink((char const   *)tmp_stderr);
#line 632
    tmp_unlink((char const   *)tmp_obj);
#line 633
    failed();
    }
  }
  {
#line 636
  tmp___19 = stat((char const   */* __restrict  */)tmp_obj, (struct stat */* __restrict  */)(& st));
  }
#line 636
  if (tmp___19 != 0) {
    {
#line 637
    cc_log("Compiler didn\'t produce an object file");
#line 638
    stats_update((enum stats )23);
#line 639
    failed();
    }
  }
#line 641
  if (st.st_size == 0L) {
    {
#line 642
    cc_log("Compiler produced an empty object file");
#line 643
    stats_update((enum stats )24);
#line 644
    failed();
    }
  }
  {
#line 647
  tmp___22 = stat((char const   */* __restrict  */)tmp_stderr, (struct stat */* __restrict  */)(& st));
  }
#line 647
  if (tmp___22 != 0) {
    {
#line 648
    tmp___20 = __errno_location();
#line 648
    tmp___21 = strerror(*tmp___20);
#line 648
    cc_log("Failed to stat %s: %s", tmp_stderr, tmp___21);
#line 649
    stats_update((enum stats )3);
#line 650
    failed();
    }
  }
#line 652
  if (st.st_size > 0L) {
    {
#line 653
    tmp___25 = move_uncompressed_file((char const   *)tmp_stderr, (char const   *)cached_stderr,
                                      (int )enable_compression);
    }
#line 653
    if (tmp___25 != 0) {
      {
#line 655
      tmp___23 = __errno_location();
#line 655
      tmp___24 = strerror(*tmp___23);
#line 655
      cc_log("Failed to move %s to %s: %s", tmp_stderr, cached_stderr, tmp___24);
#line 657
      stats_update((enum stats )3);
#line 658
      failed();
      }
    }
    {
#line 660
    cc_log("Stored in cache: %s", cached_stderr);
    }
#line 661
    if (enable_compression) {
      {
#line 662
      stat((char const   */* __restrict  */)cached_stderr, (struct stat */* __restrict  */)(& st));
      }
    }
    {
#line 664
    tmp___26 = file_size(& st);
#line 664
    added_bytes += tmp___26;
#line 665
    added_files ++;
    }
  } else {
    {
#line 667
    tmp_unlink((char const   *)tmp_stderr);
    }
  }
  {
#line 669
  tmp___30 = move_uncompressed_file((char const   *)tmp_obj, (char const   *)cached_obj,
                                    (int )enable_compression);
  }
#line 669
  if (tmp___30 != 0) {
    {
#line 670
    tmp___27 = __errno_location();
#line 670
    tmp___28 = strerror(*tmp___27);
#line 670
    cc_log("Failed to move %s to %s: %s", tmp_obj, cached_obj, tmp___28);
#line 671
    stats_update((enum stats )3);
#line 672
    failed();
    }
  } else {
    {
#line 674
    cc_log("Stored in cache: %s", cached_obj);
#line 675
    stat((char const   */* __restrict  */)cached_obj, (struct stat */* __restrict  */)(& st));
#line 676
    tmp___29 = file_size(& st);
#line 676
    added_bytes += tmp___29;
#line 677
    added_files ++;
    }
  }
  {
#line 684
  tmp___33 = stat((char const   */* __restrict  */)cached_obj, (struct stat */* __restrict  */)(& st));
  }
#line 684
  if (tmp___33 != 0) {
    {
#line 685
    tmp___31 = __errno_location();
#line 685
    tmp___32 = strerror(*tmp___31);
#line 685
    cc_log("Failed to stat %s: %s", cached_obj, tmp___32);
#line 686
    stats_update((enum stats )3);
#line 687
    failed();
    }
  }
  {
#line 690
  stats_update_size((enum stats )4, added_bytes / 1024UL, added_files);
#line 692
  free((void *)tmp_obj);
#line 693
  free((void *)tmp_stderr);
#line 694
  free((void *)tmp_stdout);
  }
#line 695
  return;
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct file_hash *get_object_name_from_cpp(struct args *args , struct mdfour *hash___0 ) 
{ 
  char *input_base ;
  char *tmp ;
  char *path_stdout ;
  char *path_stderr ;
  int status ;
  struct file_hash *result ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 714
  input_base = basename((char const   *)input_file);
#line 715
  tmp = strchr((char const   *)input_base, '.');
  }
#line 716
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 717
    *tmp = (char)0;
  }
  {
#line 719
  tmp___0 = strlen((char const   *)input_base);
  }
#line 719
  if (tmp___0 > 10UL) {
#line 720
    *(input_base + 10) = (char)0;
  }
  {
#line 724
  tmp___1 = tmp_string();
#line 724
  path_stdout = format("%s/%s.tmp.%s.%s", temp_dir, input_base, tmp___1, i_extension);
#line 726
  tmp___2 = tmp_string();
#line 726
  path_stderr = format("%s/tmp.cpp_stderr.%s", temp_dir, tmp___2);
#line 728
  time_of_compilation = time((time_t *)((void *)0));
  }
#line 730
  if (! direct_i_file) {
    {
#line 732
    args_add(args, "-E");
#line 733
    args_add(args, (char const   *)input_file);
#line 734
    status = execute(args->argv, (char const   *)path_stdout, (char const   *)path_stderr);
#line 735
    args_pop(args, 2);
    }
  } else {
    {
#line 740
    path_stdout = input_file;
#line 741
    tmp___5 = create_empty_file((char const   *)path_stderr);
    }
#line 741
    if (tmp___5 != 0) {
      {
#line 742
      tmp___3 = __errno_location();
#line 742
      tmp___4 = strerror(*tmp___3);
#line 742
      cc_log("Failed to create %s: %s", path_stderr, tmp___4);
#line 743
      stats_update((enum stats )3);
#line 744
      failed();
      }
    }
#line 746
    status = 0;
  }
#line 749
  if (status != 0) {
#line 750
    if (! direct_i_file) {
      {
#line 751
      tmp_unlink((char const   *)path_stdout);
      }
    }
    {
#line 753
    tmp_unlink((char const   *)path_stderr);
#line 754
    cc_log("Preprocessor gave exit status %d", status);
#line 755
    stats_update((enum stats )5);
#line 756
    failed();
    }
  }
#line 759
  if (enable_unify) {
    {
#line 764
    hash_delimiter(hash___0, "unifyfilename");
#line 765
    hash_string(hash___0, (char const   *)input_file);
#line 767
    hash_delimiter(hash___0, "unifycpp");
#line 768
    tmp___6 = unify_hash(hash___0, (char const   *)path_stdout);
    }
#line 768
    if (tmp___6 != 0) {
      {
#line 769
      stats_update((enum stats )3);
#line 770
      tmp_unlink((char const   *)path_stderr);
#line 771
      cc_log("Failed to unify %s", path_stdout);
#line 772
      failed();
      }
    }
  } else {
    {
#line 775
    hash_delimiter(hash___0, "cpp");
#line 776
    tmp___7 = process_preprocessed_file(hash___0, (char const   *)path_stdout);
    }
#line 776
    if (! tmp___7) {
      {
#line 777
      stats_update((enum stats )3);
#line 778
      tmp_unlink((char const   *)path_stderr);
#line 779
      failed();
      }
    }
  }
  {
#line 783
  hash_delimiter(hash___0, "cppstderr");
#line 784
  tmp___10 = hash_file(hash___0, (char const   *)path_stderr);
  }
#line 784
  if (! tmp___10) {
    {
#line 785
    tmp___8 = __errno_location();
#line 785
    tmp___9 = strerror(*tmp___8);
#line 785
    fatal("Failed to open %s: %s", path_stderr, tmp___9);
    }
  }
#line 788
  i_tmpfile = path_stdout;
#line 790
  if (compile_preprocessed_source_code) {
#line 796
    cpp_stderr = path_stderr;
  } else {
    {
#line 798
    tmp_unlink((char const   *)path_stderr);
#line 799
    free((void *)path_stderr);
    }
  }
  {
#line 802
  tmp___11 = x_malloc(sizeof(*result));
#line 802
  result = (struct file_hash *)tmp___11;
#line 803
  hash_result_as_bytes(hash___0, result->hash);
#line 804
  result->size = (uint32_t )hash___0->totalN;
  }
#line 805
  return (result);
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void update_cached_result_globals(struct file_hash *hash___0 ) 
{ 
  char *object_name ;

  {
  {
#line 813
  object_name = format_hash_as_string((unsigned char const   *)(hash___0->hash), hash___0->size);
#line 814
  cached_obj_hash = hash___0;
#line 815
  cached_obj = get_path_in_cache((char const   *)object_name, ".o");
#line 816
  cached_stderr = get_path_in_cache((char const   *)object_name, ".stderr");
#line 817
  cached_dep = get_path_in_cache((char const   *)object_name, ".d");
#line 818
  stats_file = format("%s/%c/stats", cache_dir, (int )*(object_name + 0));
#line 819
  free((void *)object_name);
  }
#line 820
  return;
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void hash_compiler(struct mdfour *hash___0 , struct stat *st , char const   *path ,
                          _Bool allow_command ) 
{ 
  char const   *compilercheck ;
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 832
  tmp = getenv("CCACHE_COMPILERCHECK");
#line 832
  compilercheck = (char const   *)tmp;
  }
#line 833
  if (! compilercheck) {
#line 834
    compilercheck = "mtime";
  }
  {
#line 836
  tmp___3 = strcmp(compilercheck, "none");
  }
#line 836
  if (! (tmp___3 == 0)) {
    {
#line 838
    tmp___2 = strcmp(compilercheck, "mtime");
    }
#line 838
    if (tmp___2 == 0) {
      {
#line 839
      hash_delimiter(hash___0, "cc_mtime");
#line 840
      hash_int(hash___0, (int )st->st_size);
#line 841
      hash_int(hash___0, (int )st->st_mtim.tv_sec);
      }
    } else {
      {
#line 842
      tmp___1 = strcmp(compilercheck, "content");
      }
#line 842
      if (tmp___1 == 0) {
        {
#line 843
        hash_delimiter(hash___0, "cc_content");
#line 844
        hash_file(hash___0, path);
        }
      } else
#line 842
      if (! allow_command) {
        {
#line 843
        hash_delimiter(hash___0, "cc_content");
#line 844
        hash_file(hash___0, path);
        }
      } else {
        {
#line 846
        tmp___0 = hash_multicommand_output(hash___0, compilercheck, (char const   *)*(orig_args->argv + 0));
        }
#line 846
        if (! tmp___0) {
          {
#line 847
          fatal("Failure running compiler check command: %s", compilercheck);
          }
        }
      }
    }
  }
#line 850
  return;
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void calculate_common_hash(struct args *args , struct mdfour *hash___0 ) 
{ 
  struct stat st ;
  char *p ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *cwd ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *path ;
  char *q ;
  char *saveptr ;
  _Bool tmp___4 ;

  {
  {
#line 862
  hash_string(hash___0, HASH_PREFIX);
#line 868
  hash_delimiter(hash___0, "ext");
#line 869
  hash_string(hash___0, i_extension);
#line 871
  tmp___1 = stat((char const   */* __restrict  */)*(args->argv + 0), (struct stat */* __restrict  */)(& st));
  }
#line 871
  if (tmp___1 != 0) {
    {
#line 872
    tmp = __errno_location();
#line 872
    tmp___0 = strerror(*tmp);
#line 872
    cc_log("Couldn\'t stat compiler %s: %s", *(args->argv + 0), tmp___0);
#line 873
    stats_update((enum stats )6);
#line 874
    failed();
    }
  }
  {
#line 880
  hash_compiler(hash___0, & st, (char const   *)*(args->argv + 0), (_Bool)1);
#line 886
  hash_delimiter(hash___0, "cc_name");
#line 887
  p = basename((char const   *)*(args->argv + 0));
#line 888
  hash_string(hash___0, (char const   *)p);
#line 889
  free((void *)p);
#line 892
  tmp___3 = getenv("CCACHE_HASHDIR");
  }
#line 892
  if (tmp___3) {
    {
#line 893
    tmp___2 = gnu_getcwd();
#line 893
    cwd = tmp___2;
    }
#line 894
    if (cwd) {
      {
#line 895
      hash_delimiter(hash___0, "cwd");
#line 896
      hash_string(hash___0, (char const   *)cwd);
#line 897
      free((void *)cwd);
      }
    }
  }
  {
#line 901
  p = getenv("CCACHE_EXTRAFILES");
  }
#line 902
  if (p) {
    {
#line 903
    saveptr = (char *)((void *)0);
#line 904
    p = x_strdup((char const   *)p);
#line 905
    q = p;
    }
    {
#line 906
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 906
      path = strtok_r((char */* __restrict  */)q, (char const   */* __restrict  */)":",
                      (char **/* __restrict  */)(& saveptr));
      }
#line 906
      if (! path) {
#line 906
        goto while_break;
      }
      {
#line 907
      cc_log("Hashing extra file %s", path);
#line 908
      hash_delimiter(hash___0, "extrafile");
#line 909
      tmp___4 = hash_file(hash___0, (char const   *)path);
      }
#line 909
      if (! tmp___4) {
        {
#line 910
        stats_update((enum stats )25);
#line 911
        failed();
        }
      }
#line 913
      q = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 915
    free((void *)p);
    }
  }
#line 917
  return;
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct file_hash *calculate_object_hash(struct args *args , struct mdfour *hash___0 ,
                                               int direct_mode ) 
{ 
  int i ;
  char *manifest_name ;
  struct stat st ;
  int result ;
  struct file_hash *object_hash ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   **p___0 ;
  char const   *envvars[6] ;
  char *v ;
  char *tmp___16 ;

  {
#line 931
  object_hash = (struct file_hash *)((void *)0);
#line 935
  i = 1;
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! (i < args->argc)) {
#line 935
      goto while_break;
    }
#line 937
    if (i < args->argc - 1) {
      {
#line 937
      tmp = strcmp((char const   *)*(args->argv + i), "-L");
      }
#line 937
      if (tmp == 0) {
#line 938
        i ++;
#line 939
        goto __Cont;
      }
    }
    {
#line 941
    tmp___0 = strlen("-L");
#line 941
    tmp___1 = strncmp((char const   *)*(args->argv + i), "-L", tmp___0);
    }
#line 941
    if (tmp___1 == 0) {
#line 942
      goto __Cont;
    }
#line 949
    if (! direct_mode) {
#line 949
      if (! output_is_precompiled_header) {
#line 949
        if (! using_precompiled_header) {
          {
#line 951
          tmp___2 = compopt_affects_cpp((char const   *)*(args->argv + i));
          }
#line 951
          if (tmp___2) {
#line 952
            i ++;
#line 953
            goto __Cont;
          }
          {
#line 955
          tmp___3 = compopt_short(& compopt_affects_cpp, (char const   *)*(args->argv + i));
          }
#line 955
          if (tmp___3) {
#line 956
            goto __Cont;
          }
        }
      }
    }
    {
#line 960
    p = (char *)((void *)0);
#line 961
    tmp___6 = strlen("-specs=");
#line 961
    tmp___7 = strncmp((char const   *)*(args->argv + i), "-specs=", tmp___6);
    }
#line 961
    if (tmp___7 == 0) {
#line 962
      p = *(args->argv + i) + 7;
    } else {
      {
#line 963
      tmp___4 = strlen("--specs=");
#line 963
      tmp___5 = strncmp((char const   *)*(args->argv + i), "--specs=", tmp___4);
      }
#line 963
      if (tmp___5 == 0) {
#line 964
        p = *(args->argv + i) + 8;
      }
    }
#line 966
    if (p) {
      {
#line 966
      tmp___8 = stat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& st));
      }
#line 966
      if (tmp___8 == 0) {
        {
#line 969
        hash_delimiter(hash___0, "specs");
#line 970
        hash_compiler(hash___0, & st, (char const   *)p, (_Bool)0);
        }
#line 971
        goto __Cont;
      }
    }
    {
#line 974
    tmp___9 = strlen("-fplugin=");
#line 974
    tmp___10 = strncmp((char const   *)*(args->argv + i), "-fplugin=", tmp___9);
    }
#line 974
    if (tmp___10 == 0) {
      {
#line 974
      tmp___11 = stat((char const   */* __restrict  */)(*(args->argv + i) + 9), (struct stat */* __restrict  */)(& st));
      }
#line 974
      if (tmp___11 == 0) {
        {
#line 976
        hash_delimiter(hash___0, "plugin");
#line 977
        hash_compiler(hash___0, & st, (char const   *)(*(args->argv + i) + 9), (_Bool)0);
        }
#line 978
        goto __Cont;
      }
    }
    {
#line 981
    tmp___12 = strcmp((char const   *)*(args->argv + i), "-Xclang");
    }
#line 981
    if (tmp___12 == 0) {
#line 981
      if (i + 3 < args->argc) {
        {
#line 981
        tmp___13 = strcmp((char const   *)*(args->argv + (i + 1)), "-load");
        }
#line 981
        if (tmp___13 == 0) {
          {
#line 981
          tmp___14 = strcmp((char const   *)*(args->argv + (i + 2)), "-Xclang");
          }
#line 981
          if (tmp___14 == 0) {
            {
#line 981
            tmp___15 = stat((char const   */* __restrict  */)*(args->argv + (i + 3)),
                            (struct stat */* __restrict  */)(& st));
            }
#line 981
            if (tmp___15 == 0) {
              {
#line 986
              hash_delimiter(hash___0, "plugin");
#line 987
              hash_compiler(hash___0, & st, (char const   *)*(args->argv + (i + 3)),
                            (_Bool)0);
              }
#line 988
              goto __Cont;
            }
          }
        }
      }
    }
    {
#line 992
    hash_delimiter(hash___0, "arg");
#line 993
    hash_string(hash___0, (char const   *)*(args->argv + i));
    }
    __Cont: /* CIL Label */ 
#line 935
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 996
  if (direct_mode) {
#line 999
    envvars[0] = "CPATH";
#line 999
    envvars[1] = "C_INCLUDE_PATH";
#line 999
    envvars[2] = "CPLUS_INCLUDE_PATH";
#line 999
    envvars[3] = "OBJC_INCLUDE_PATH";
#line 999
    envvars[4] = "OBJCPLUS_INCLUDE_PATH";
#line 999
    envvars[5] = (char const   *)((void *)0);
#line 1007
    p___0 = envvars;
    {
#line 1007
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1007
      if (! ((unsigned long )*p___0 != (unsigned long )((void *)0))) {
#line 1007
        goto while_break___0;
      }
      {
#line 1008
      tmp___16 = getenv(*p___0);
#line 1008
      v = tmp___16;
      }
#line 1009
      if (v) {
        {
#line 1010
        hash_delimiter(hash___0, *p___0);
#line 1011
        hash_string(hash___0, (char const   *)v);
        }
      }
#line 1007
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1015
    if (! (sloppiness & 2U)) {
      {
#line 1021
      hash_delimiter(hash___0, "inputfile");
#line 1022
      hash_string(hash___0, (char const   *)input_file);
      }
    }
    {
#line 1025
    hash_delimiter(hash___0, "sourcecode");
#line 1026
    result = hash_source_code_file(hash___0, (char const   *)input_file);
    }
#line 1027
    if (result & 1) {
      {
#line 1028
      failed();
      }
    }
#line 1030
    if (result & 4) {
      {
#line 1031
      cc_log("Disabling direct mode");
#line 1032
      enable_direct = (_Bool)0;
      }
#line 1033
      return ((struct file_hash *)((void *)0));
    }
    {
#line 1035
    manifest_name = hash_result(hash___0);
#line 1036
    manifest_path = get_path_in_cache((char const   *)manifest_name, ".manifest");
#line 1037
    free((void *)manifest_name);
#line 1038
    cc_log("Looking for object file hash in %s", manifest_path);
#line 1039
    object_hash = manifest_get((char const   *)manifest_path);
    }
#line 1040
    if (object_hash) {
      {
#line 1041
      cc_log("Got object file hash from manifest");
      }
    } else {
      {
#line 1043
      cc_log("Did not find object file hash in manifest");
      }
    }
  } else {
    {
#line 1046
    object_hash = get_object_name_from_cpp(args, hash___0);
#line 1047
    cc_log("Got object file hash from preprocessor");
    }
#line 1048
    if (generating_dependencies) {
      {
#line 1049
      cc_log("Preprocessor created %s", output_dep);
      }
    }
  }
#line 1053
  return (object_hash);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void from_cache(enum fromcache_call_mode mode , _Bool put_object_in_manifest ) 
{ 
  int fd_stderr ;
  int ret___0 ;
  struct stat st ;
  _Bool produce_dep_file ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  struct stat st___0 ;
  size_t old_size ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  _Bool tmp___20 ;
  char *tmp___21 ;

  {
#line 1069
  if ((unsigned int )mode != 2U) {
    {
#line 1069
    tmp = getenv("CCACHE_RECACHE");
    }
#line 1069
    if (tmp) {
#line 1070
      return;
    }
  }
  {
#line 1074
  tmp___0 = stat((char const   */* __restrict  */)cached_obj, (struct stat */* __restrict  */)(& st));
  }
#line 1074
  if (tmp___0 != 0) {
    {
#line 1075
    cc_log("Object file %s not in cache", cached_obj);
    }
#line 1076
    return;
  }
#line 1083
  if (generating_dependencies) {
#line 1083
    if ((unsigned int )mode == 0U) {
#line 1083
      tmp___1 = 1;
    } else {
#line 1083
      tmp___1 = 0;
    }
  } else {
#line 1083
    tmp___1 = 0;
  }
#line 1083
  produce_dep_file = (_Bool )tmp___1;
#line 1086
  if (produce_dep_file) {
    {
#line 1086
    tmp___2 = stat((char const   */* __restrict  */)cached_dep, (struct stat */* __restrict  */)(& st));
    }
#line 1086
    if (tmp___2 != 0) {
      {
#line 1087
      cc_log("Dependency file %s missing in cache", cached_dep);
      }
#line 1088
      return;
    }
  }
  {
#line 1091
  tmp___5 = strcmp((char const   *)output_obj, "/dev/null");
  }
#line 1091
  if (tmp___5 == 0) {
#line 1092
    ret___0 = 0;
  } else {
    {
#line 1094
    x_unlink((char const   *)output_obj);
#line 1096
    tmp___3 = getenv("CCACHE_HARDLINK");
    }
#line 1096
    if (tmp___3) {
      {
#line 1096
      tmp___4 = file_is_compressed((char const   *)cached_obj);
      }
#line 1096
      if (tmp___4) {
        {
#line 1099
        ret___0 = copy_file((char const   *)cached_obj, (char const   *)output_obj,
                            0);
        }
      } else {
        {
#line 1097
        ret___0 = link((char const   *)cached_obj, (char const   *)output_obj);
        }
      }
    } else {
      {
#line 1099
      ret___0 = copy_file((char const   *)cached_obj, (char const   *)output_obj,
                          0);
      }
    }
  }
#line 1103
  if (ret___0 == -1) {
    {
#line 1104
    tmp___8 = __errno_location();
    }
#line 1104
    if (*tmp___8 == 2) {
      {
#line 1106
      cc_log("Object file %s just disappeared from cache", cached_obj);
#line 1107
      stats_update((enum stats )7);
      }
    } else {
      {
#line 1109
      tmp___6 = __errno_location();
#line 1109
      tmp___7 = strerror(*tmp___6);
#line 1109
      cc_log("Failed to copy/link %s to %s: %s", cached_obj, output_obj, tmp___7);
#line 1111
      stats_update((enum stats )3);
#line 1112
      failed();
      }
    }
    {
#line 1114
    x_unlink((char const   *)output_obj);
#line 1115
    x_unlink((char const   *)cached_stderr);
#line 1116
    x_unlink((char const   *)cached_obj);
#line 1117
    x_unlink((char const   *)cached_dep);
    }
#line 1118
    return;
  } else {
    {
#line 1120
    cc_log("Created %s from %s", output_obj, cached_obj);
    }
  }
#line 1123
  if (produce_dep_file) {
    {
#line 1124
    x_unlink((char const   *)output_dep);
#line 1126
    tmp___9 = getenv("CCACHE_HARDLINK");
    }
#line 1126
    if (tmp___9) {
      {
#line 1126
      tmp___10 = file_is_compressed((char const   *)cached_dep);
      }
#line 1126
      if (tmp___10) {
        {
#line 1129
        ret___0 = copy_file((char const   *)cached_dep, (char const   *)output_dep,
                            0);
        }
      } else {
        {
#line 1127
        ret___0 = link((char const   *)cached_dep, (char const   *)output_dep);
        }
      }
    } else {
      {
#line 1129
      ret___0 = copy_file((char const   *)cached_dep, (char const   *)output_dep,
                          0);
      }
    }
#line 1131
    if (ret___0 == -1) {
      {
#line 1132
      tmp___13 = __errno_location();
      }
#line 1132
      if (*tmp___13 == 2) {
        {
#line 1137
        cc_log("Dependency file %s just disappeared from cache", output_obj);
#line 1138
        stats_update((enum stats )7);
        }
      } else {
        {
#line 1140
        tmp___11 = __errno_location();
#line 1140
        tmp___12 = strerror(*tmp___11);
#line 1140
        cc_log("Failed to copy/link %s to %s: %s", cached_dep, output_dep, tmp___12);
#line 1142
        stats_update((enum stats )3);
#line 1143
        failed();
        }
      }
      {
#line 1145
      x_unlink((char const   *)output_obj);
#line 1146
      x_unlink((char const   *)output_dep);
#line 1147
      x_unlink((char const   *)cached_stderr);
#line 1148
      x_unlink((char const   *)cached_obj);
#line 1149
      x_unlink((char const   *)cached_dep);
      }
#line 1150
      return;
    } else {
      {
#line 1152
      cc_log("Created %s from %s", output_dep, cached_dep);
      }
    }
  }
  {
#line 1158
  update_mtime((char const   *)cached_obj);
#line 1159
  update_mtime((char const   *)cached_stderr);
  }
#line 1160
  if (produce_dep_file) {
    {
#line 1161
    update_mtime((char const   *)cached_dep);
    }
  }
#line 1164
  if (generating_dependencies) {
#line 1164
    if ((unsigned int )mode != 0U) {
      {
#line 1166
      ret___0 = copy_file((char const   *)output_dep, (char const   *)cached_dep,
                          (int )enable_compression);
      }
#line 1167
      if (ret___0 == -1) {
        {
#line 1168
        tmp___14 = __errno_location();
#line 1168
        tmp___15 = strerror(*tmp___14);
#line 1168
        cc_log("Failed to copy %s to %s: %s", output_dep, cached_dep, tmp___15);
        }
      } else {
        {
#line 1172
        cc_log("Stored in cache: %s", cached_dep);
#line 1173
        stat((char const   */* __restrict  */)cached_dep, (struct stat */* __restrict  */)(& st));
#line 1174
        tmp___16 = file_size(& st);
#line 1174
        stats_update_size((enum stats )0, tmp___16 / 1024UL, 1U);
        }
      }
    }
  }
  {
#line 1179
  fd_stderr = open((char const   *)cached_stderr, 0);
  }
#line 1180
  if (fd_stderr != -1) {
    {
#line 1181
    copy_fd(fd_stderr, 2);
#line 1182
    close(fd_stderr);
    }
  }
#line 1186
  if (enable_direct) {
#line 1186
    if (put_object_in_manifest) {
#line 1186
      if (included_files) {
        {
#line 1186
        tmp___21 = getenv("CCACHE_READONLY");
        }
#line 1186
        if (! tmp___21) {
          {
#line 1191
          old_size = (size_t )0;
#line 1192
          tmp___17 = stat((char const   */* __restrict  */)manifest_path, (struct stat */* __restrict  */)(& st___0));
          }
#line 1192
          if (tmp___17 == 0) {
            {
#line 1193
            old_size = file_size(& st___0);
            }
          }
          {
#line 1195
          tmp___20 = manifest_put((char const   *)manifest_path, cached_obj_hash,
                                  included_files);
          }
#line 1195
          if (tmp___20) {
            {
#line 1196
            cc_log("Added object file hash to %s", manifest_path);
#line 1197
            update_mtime((char const   *)manifest_path);
#line 1198
            stat((char const   */* __restrict  */)manifest_path, (struct stat */* __restrict  */)(& st___0));
            }
#line 1199
            if (old_size == 0UL) {
#line 1199
              tmp___18 = 1;
            } else {
#line 1199
              tmp___18 = 0;
            }
            {
#line 1199
            tmp___19 = file_size(& st___0);
#line 1199
            stats_update_size((enum stats )0, (tmp___19 - old_size) / 1024UL, (unsigned int )tmp___18);
            }
          } else {
            {
#line 1203
            cc_log("Failed to add object file hash to %s", manifest_path);
            }
          }
        }
      }
    }
  }
  {
#line 1209
  if ((unsigned int )mode == 0U) {
#line 1209
    goto case_0;
  }
#line 1214
  if ((unsigned int )mode == 1U) {
#line 1214
    goto case_1;
  }
#line 1219
  if ((unsigned int )mode == 2U) {
#line 1219
    goto case_2;
  }
#line 1208
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1210
  cc_log("Succeded getting cached result");
#line 1211
  stats_update((enum stats )22);
  }
#line 1212
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1215
  cc_log("Succeded getting cached result");
#line 1216
  stats_update((enum stats )8);
  }
#line 1217
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1221
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1225
  exit(0);
  }
}
}
#line 1230 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void find_compiler(int argc , char **argv ) 
{ 
  char *base ;
  char *path ;
  char *compiler ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1237
  orig_args = args_init(argc, argv);
#line 1239
  base = basename((char const   *)*(argv + 0));
#line 1242
  tmp___0 = same_executable_name((char const   *)base, "ccache");
  }
#line 1242
  if (tmp___0) {
    {
#line 1243
    args_remove_first(orig_args);
#line 1244
    free((void *)base);
#line 1245
    tmp = is_full_path((char const   *)*(argv + 1));
    }
#line 1245
    if (tmp) {
#line 1247
      return;
    }
    {
#line 1249
    base = basename((char const   *)*(argv + 1));
    }
  }
  {
#line 1253
  path = getenv("CCACHE_CC");
  }
#line 1253
  if (path) {
    {
#line 1254
    base = x_strdup((char const   *)path);
    }
  }
  {
#line 1257
  compiler = find_executable((char const   *)base, "ccache");
  }
#line 1260
  if (! compiler) {
    {
#line 1261
    stats_update((enum stats )6);
#line 1262
    fatal("Could not find compiler \"%s\" in PATH", base);
    }
  }
  {
#line 1264
  tmp___1 = strcmp((char const   *)compiler, (char const   *)*(argv + 0));
  }
#line 1264
  if (tmp___1 == 0) {
    {
#line 1265
    fatal("Recursive invocation (the name of the ccache binary must be \"%s\")", "ccache");
    }
  }
#line 1268
  *(orig_args->argv + 0) = compiler;
#line 1269
  return;
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
_Bool is_precompiled_header(char const   *path ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 1274
  tmp = get_extension(path);
#line 1274
  tmp___0 = strcmp(tmp, ".gch");
  }
#line 1274
  return ((_Bool )(tmp___0 == 0));
}
}
#line 1282 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
_Bool cc_process_args(struct args *orig_args___0 , struct args **preprocessor_args ,
                      struct args **compiler_args ) 
{ 
  int i ;
  _Bool found_c_opt ;
  _Bool found_S_opt ;
  _Bool found_arch_opt ;
  _Bool found_pch ;
  _Bool found_fpch_preprocess ;
  char const   *explicit_language ;
  char const   *file_language ;
  char const   *actual_language ;
  char const   *input_charset ;
  struct stat st ;
  _Bool dependency_filename_specified ;
  _Bool dependency_target_specified ;
  struct args *stripped_args ;
  struct args *dep_args ;
  int argc ;
  char **argv ;
  _Bool result ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *arg ;
  _Bool separate_argument ;
  size_t tmp___25 ;
  char *tmp___26 ;
  char *option ;
  char *tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char *relpath ;
  char *tmp___30 ;
  char *arg_opt ;
  char *option___0 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  char *relpath___0 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *option___1 ;
  char *tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  size_t tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t tmp___53 ;
  int tmp___54 ;
  char *relpath___1 ;
  char *pchpath ;
  char *tmp___55 ;
  int tmp___56 ;
  _Bool tmp___57 ;
  char *relpath___2 ;
  char *option___2 ;
  char *tmp___58 ;
  _Bool tmp___59 ;
  _Bool tmp___60 ;
  int tmp___61 ;
  char *tmp___62 ;
  char const   *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  _Bool tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char const   *p_language ;
  char const   *tmp___71 ;
  char const   *tmp___72 ;
  int tmp___73 ;
  char *p ;
  int tmp___74 ;
  int tmp___75 ;
  char *default_depfile_name ;
  char *base_name ;
  char *tmp___76 ;
  char const   *tmp___77 ;

  {
  {
#line 1287
  found_c_opt = (_Bool)0;
#line 1288
  found_S_opt = (_Bool)0;
#line 1289
  found_arch_opt = (_Bool)0;
#line 1290
  found_pch = (_Bool)0;
#line 1291
  found_fpch_preprocess = (_Bool)0;
#line 1292
  explicit_language = (char const   *)((void *)0);
#line 1295
  input_charset = (char const   *)((void *)0);
#line 1298
  dependency_filename_specified = (_Bool)0;
#line 1300
  dependency_target_specified = (_Bool)0;
#line 1301
  stripped_args = (struct args *)((void *)0);
#line 1301
  dep_args = (struct args *)((void *)0);
#line 1302
  argc = orig_args___0->argc;
#line 1303
  argv = orig_args___0->argv;
#line 1304
  result = (_Bool)1;
#line 1306
  stripped_args = args_init(0, (char **)((void *)0));
#line 1307
  dep_args = args_init(0, (char **)((void *)0));
#line 1309
  args_add(stripped_args, (char const   *)*(argv + 0));
#line 1311
  i = 1;
  }
  {
#line 1311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1311
    if (! (i < argc)) {
#line 1311
      goto while_break;
    }
    {
#line 1313
    tmp = strcmp((char const   *)*(argv + i), "--ccache-skip");
    }
#line 1313
    if (tmp == 0) {
#line 1314
      i ++;
#line 1315
      if (i == argc) {
        {
#line 1316
        cc_log("--ccache-skip lacks an argument");
#line 1317
        result = (_Bool)0;
        }
#line 1318
        goto out;
      }
      {
#line 1320
      args_add(stripped_args, (char const   *)*(argv + i));
      }
#line 1321
      goto __Cont;
    }
    {
#line 1325
    tmp___0 = strcmp((char const   *)*(argv + i), "-E");
    }
#line 1325
    if (tmp___0 == 0) {
      {
#line 1326
      stats_update((enum stats )28);
#line 1327
      result = (_Bool)0;
      }
#line 1328
      goto out;
    }
    {
#line 1332
    tmp___1 = compopt_too_hard((char const   *)*(argv + i));
    }
#line 1332
    if (tmp___1) {
      {
#line 1335
      cc_log("Compiler option %s is unsupported", *(argv + i));
#line 1336
      stats_update((enum stats )20);
#line 1337
      result = (_Bool)0;
      }
#line 1338
      goto out;
    } else {
      {
#line 1332
      tmp___2 = strlen("@");
#line 1332
      tmp___3 = strncmp((char const   *)*(argv + i), "@", tmp___2);
      }
#line 1332
      if (tmp___3 == 0) {
        {
#line 1335
        cc_log("Compiler option %s is unsupported", *(argv + i));
#line 1336
        stats_update((enum stats )20);
#line 1337
        result = (_Bool)0;
        }
#line 1338
        goto out;
      } else {
        {
#line 1332
        tmp___4 = strlen("-fdump-");
#line 1332
        tmp___5 = strncmp((char const   *)*(argv + i), "-fdump-", tmp___4);
        }
#line 1332
        if (tmp___5 == 0) {
          {
#line 1335
          cc_log("Compiler option %s is unsupported", *(argv + i));
#line 1336
          stats_update((enum stats )20);
#line 1337
          result = (_Bool)0;
          }
#line 1338
          goto out;
        }
      }
    }
#line 1342
    if (enable_direct) {
      {
#line 1343
      tmp___6 = compopt_too_hard_for_direct_mode((char const   *)*(argv + i));
      }
#line 1343
      if (tmp___6) {
        {
#line 1344
        cc_log("Unsupported compiler option for direct mode: %s", *(argv + i));
#line 1345
        enable_direct = (_Bool)0;
        }
      }
    }
    {
#line 1350
    tmp___7 = strcmp((char const   *)*(argv + i), "-arch");
    }
#line 1350
    if (tmp___7 == 0) {
#line 1351
      if (found_arch_opt) {
        {
#line 1352
        cc_log("More than one -arch compiler option is unsupported");
#line 1353
        stats_update((enum stats )20);
#line 1354
        result = (_Bool)0;
        }
#line 1355
        goto out;
      } else {
#line 1357
        found_arch_opt = (_Bool)1;
      }
    }
    {
#line 1361
    tmp___8 = strcmp((char const   *)*(argv + i), "-fpch-preprocess");
    }
#line 1361
    if (tmp___8 == 0) {
#line 1362
      found_fpch_preprocess = (_Bool)1;
    }
    {
#line 1366
    tmp___9 = strcmp((char const   *)*(argv + i), "-c");
    }
#line 1366
    if (tmp___9 == 0) {
      {
#line 1367
      args_add(stripped_args, (char const   *)*(argv + i));
#line 1368
      found_c_opt = (_Bool)1;
      }
#line 1369
      goto __Cont;
    }
    {
#line 1373
    tmp___10 = strcmp((char const   *)*(argv + i), "-S");
    }
#line 1373
    if (tmp___10 == 0) {
      {
#line 1374
      args_add(stripped_args, (char const   *)*(argv + i));
#line 1375
      found_S_opt = (_Bool)1;
      }
#line 1376
      goto __Cont;
    }
    {
#line 1383
    tmp___11 = strcmp((char const   *)*(argv + i), "-x");
    }
#line 1383
    if (tmp___11 == 0) {
#line 1384
      if (i == argc - 1) {
        {
#line 1385
        cc_log("Missing argument to %s", *(argv + i));
#line 1386
        stats_update((enum stats )9);
#line 1387
        result = (_Bool)0;
        }
#line 1388
        goto out;
      }
#line 1390
      if (! input_file) {
#line 1391
        explicit_language = (char const   *)*(argv + (i + 1));
      }
#line 1393
      i ++;
#line 1394
      goto __Cont;
    }
    {
#line 1396
    tmp___12 = strlen("-x");
#line 1396
    tmp___13 = strncmp((char const   *)*(argv + i), "-x", tmp___12);
    }
#line 1396
    if (tmp___13 == 0) {
#line 1397
      if (! input_file) {
#line 1398
        explicit_language = (char const   *)(*(argv + i) + 2);
      }
#line 1400
      goto __Cont;
    }
    {
#line 1404
    tmp___15 = strcmp((char const   *)*(argv + i), "-o");
    }
#line 1404
    if (tmp___15 == 0) {
#line 1405
      if (i == argc - 1) {
        {
#line 1406
        cc_log("Missing argument to %s", *(argv + i));
#line 1407
        stats_update((enum stats )9);
#line 1408
        result = (_Bool)0;
        }
#line 1409
        goto out;
      }
      {
#line 1411
      tmp___14 = x_strdup((char const   *)*(argv + (i + 1)));
#line 1411
      output_obj = make_relative_path(tmp___14);
#line 1412
      i ++;
      }
#line 1413
      goto __Cont;
    }
    {
#line 1417
    tmp___17 = strlen("-o");
#line 1417
    tmp___18 = strncmp((char const   *)*(argv + i), "-o", tmp___17);
    }
#line 1417
    if (tmp___18 == 0) {
      {
#line 1418
      tmp___16 = x_strdup((char const   *)(*(argv + i) + 2));
#line 1418
      output_obj = make_relative_path(tmp___16);
      }
#line 1419
      goto __Cont;
    }
    {
#line 1425
    tmp___21 = strlen("-g");
#line 1425
    tmp___22 = strncmp((char const   *)*(argv + i), "-g", tmp___21);
    }
#line 1425
    if (tmp___22 == 0) {
      {
#line 1426
      args_add(stripped_args, (char const   *)*(argv + i));
      }
#line 1427
      if (enable_unify) {
        {
#line 1427
        tmp___19 = strcmp((char const   *)*(argv + i), "-g0");
        }
#line 1427
        if (! (tmp___19 == 0)) {
          {
#line 1428
          cc_log("%s used; disabling unify mode", *(argv + i));
#line 1429
          enable_unify = (_Bool)0;
          }
        }
      }
      {
#line 1431
      tmp___20 = strcmp((char const   *)*(argv + i), "-g3");
      }
#line 1431
      if (tmp___20 == 0) {
        {
#line 1436
        cc_log("%s used; not compiling preprocessed code", *(argv + i));
#line 1437
        compile_preprocessed_source_code = (_Bool)0;
        }
      }
#line 1439
      goto __Cont;
    }
    {
#line 1445
    tmp___23 = strcmp((char const   *)*(argv + i), "-MD");
    }
#line 1445
    if (tmp___23 == 0) {
      {
#line 1446
      generating_dependencies = (_Bool)1;
#line 1447
      args_add(dep_args, (char const   *)*(argv + i));
      }
#line 1448
      goto __Cont;
    } else {
      {
#line 1445
      tmp___24 = strcmp((char const   *)*(argv + i), "-MMD");
      }
#line 1445
      if (tmp___24 == 0) {
        {
#line 1446
        generating_dependencies = (_Bool)1;
#line 1447
        args_add(dep_args, (char const   *)*(argv + i));
        }
#line 1448
        goto __Cont;
      }
    }
    {
#line 1450
    tmp___28 = strlen("-MF");
#line 1450
    tmp___29 = strncmp((char const   *)*(argv + i), "-MF", tmp___28);
    }
#line 1450
    if (tmp___29 == 0) {
      {
#line 1452
      tmp___25 = strlen((char const   *)*(argv + i));
#line 1452
      separate_argument = (_Bool )(tmp___25 == 3UL);
#line 1453
      dependency_filename_specified = (_Bool)1;
#line 1454
      free((void *)output_dep);
      }
#line 1455
      if (separate_argument) {
#line 1457
        if (i >= argc - 1) {
          {
#line 1458
          cc_log("Missing argument to %s", *(argv + i));
#line 1459
          stats_update((enum stats )9);
#line 1460
          result = (_Bool)0;
          }
#line 1461
          goto out;
        }
#line 1463
        arg = *(argv + (i + 1));
#line 1464
        i ++;
      } else {
#line 1467
        arg = *(argv + i) + 3;
      }
      {
#line 1469
      tmp___26 = x_strdup((char const   *)arg);
#line 1469
      output_dep = make_relative_path(tmp___26);
      }
#line 1471
      if (separate_argument) {
        {
#line 1472
        args_add(dep_args, "-MF");
#line 1473
        args_add(dep_args, (char const   *)output_dep);
        }
      } else {
        {
#line 1475
        tmp___27 = format("-MF%s", output_dep);
#line 1475
        option = tmp___27;
#line 1476
        args_add(dep_args, (char const   *)option);
#line 1477
        free((void *)option);
        }
      }
#line 1479
      goto __Cont;
    }
    {
#line 1481
    tmp___33 = strlen("-MQ");
#line 1481
    tmp___34 = strncmp((char const   *)*(argv + i), "-MQ", tmp___33);
    }
#line 1481
    if (tmp___34 == 0) {
#line 1481
      goto _L;
    } else {
      {
#line 1481
      tmp___35 = strlen("-MT");
#line 1481
      tmp___36 = strncmp((char const   *)*(argv + i), "-MT", tmp___35);
      }
#line 1481
      if (tmp___36 == 0) {
        _L: /* CIL Label */ 
        {
#line 1483
        dependency_target_specified = (_Bool)1;
#line 1484
        tmp___32 = strlen((char const   *)*(argv + i));
        }
#line 1484
        if (tmp___32 == 3UL) {
#line 1486
          if (i >= argc - 1) {
            {
#line 1487
            cc_log("Missing argument to %s", *(argv + i));
#line 1488
            stats_update((enum stats )9);
#line 1489
            result = (_Bool)0;
            }
#line 1490
            goto out;
          }
          {
#line 1492
          args_add(dep_args, (char const   *)*(argv + i));
#line 1493
          tmp___30 = x_strdup((char const   *)*(argv + (i + 1)));
#line 1493
          relpath = make_relative_path(tmp___30);
#line 1494
          args_add(dep_args, (char const   *)relpath);
#line 1495
          free((void *)relpath);
#line 1496
          i ++;
          }
        } else {
          {
#line 1500
          arg_opt = x_strndup((char const   *)*(argv + i), (size_t )3);
#line 1501
          tmp___31 = x_strdup((char const   *)(*(argv + i) + 3));
#line 1501
          relpath = make_relative_path(tmp___31);
#line 1502
          option___0 = format("%s%s", arg_opt, relpath);
#line 1503
          args_add(dep_args, (char const   *)option___0);
#line 1504
          free((void *)arg_opt);
#line 1505
          free((void *)relpath);
#line 1506
          free((void *)option___0);
          }
        }
#line 1508
        goto __Cont;
      }
    }
    {
#line 1510
    tmp___40 = strlen("--sysroot=");
#line 1510
    tmp___41 = strncmp((char const   *)*(argv + i), "--sysroot=", tmp___40);
    }
#line 1510
    if (tmp___41 == 0) {
      {
#line 1511
      tmp___37 = x_strdup((char const   *)(*(argv + i) + 10));
#line 1511
      tmp___38 = make_relative_path(tmp___37);
#line 1511
      relpath___0 = tmp___38;
#line 1512
      tmp___39 = format("--sysroot=%s", relpath___0);
#line 1512
      option___1 = tmp___39;
#line 1513
      args_add(stripped_args, (char const   *)option___1);
#line 1514
      free((void *)relpath___0);
#line 1515
      free((void *)option___1);
      }
#line 1516
      goto __Cont;
    }
    {
#line 1518
    tmp___50 = strlen("-Wp,");
#line 1518
    tmp___51 = strncmp((char const   *)*(argv + i), "-Wp,", tmp___50);
    }
#line 1518
    if (tmp___51 == 0) {
      {
#line 1519
      tmp___47 = strlen("-Wp,-MD,");
#line 1519
      tmp___48 = strncmp((char const   *)*(argv + i), "-Wp,-MD,", tmp___47);
      }
#line 1519
      if (tmp___48 == 0) {
        {
#line 1519
        tmp___49 = strchr((char const   *)(*(argv + i) + 8), ',');
        }
#line 1519
        if (tmp___49) {
#line 1519
          goto _L___1;
        } else {
          {
#line 1520
          generating_dependencies = (_Bool)1;
#line 1521
          dependency_filename_specified = (_Bool)1;
#line 1522
          free((void *)output_dep);
#line 1523
          tmp___42 = x_strdup((char const   *)(*(argv + i) + 8));
#line 1523
          output_dep = make_relative_path(tmp___42);
#line 1524
          args_add(dep_args, (char const   *)*(argv + i));
          }
#line 1525
          goto __Cont;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1526
        tmp___44 = strlen("-Wp,-MMD,");
#line 1526
        tmp___45 = strncmp((char const   *)*(argv + i), "-Wp,-MMD,", tmp___44);
        }
#line 1526
        if (tmp___45 == 0) {
          {
#line 1526
          tmp___46 = strchr((char const   *)(*(argv + i) + 9), ',');
          }
#line 1526
          if (tmp___46) {
#line 1526
            goto _L___0;
          } else {
            {
#line 1528
            generating_dependencies = (_Bool)1;
#line 1529
            dependency_filename_specified = (_Bool)1;
#line 1530
            free((void *)output_dep);
#line 1531
            tmp___43 = x_strdup((char const   *)(*(argv + i) + 9));
#line 1531
            output_dep = make_relative_path(tmp___43);
#line 1532
            args_add(dep_args, (char const   *)*(argv + i));
            }
#line 1533
            goto __Cont;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1534
        if (enable_direct) {
          {
#line 1540
          cc_log("Unsupported compiler option for direct mode: %s", *(argv + i));
#line 1541
          enable_direct = (_Bool)0;
          }
        }
      }
    }
    {
#line 1544
    tmp___52 = strcmp((char const   *)*(argv + i), "-MP");
    }
#line 1544
    if (tmp___52 == 0) {
      {
#line 1545
      args_add(dep_args, (char const   *)*(argv + i));
      }
#line 1546
      goto __Cont;
    }
    {
#line 1550
    tmp___53 = strlen("-finput-charset=");
#line 1550
    tmp___54 = strncmp((char const   *)*(argv + i), "-finput-charset=", tmp___53);
    }
#line 1550
    if (tmp___54 == 0) {
#line 1551
      input_charset = (char const   *)*(argv + i);
#line 1552
      goto __Cont;
    }
    {
#line 1561
    tmp___57 = compopt_takes_path((char const   *)*(argv + i));
    }
#line 1561
    if (tmp___57) {
#line 1564
      if (i == argc - 1) {
        {
#line 1565
        cc_log("Missing argument to %s", *(argv + i));
#line 1566
        stats_update((enum stats )9);
#line 1567
        result = (_Bool)0;
        }
#line 1568
        goto out;
      }
      {
#line 1571
      args_add(stripped_args, (char const   *)*(argv + i));
#line 1572
      tmp___55 = x_strdup((char const   *)*(argv + (i + 1)));
#line 1572
      relpath___1 = make_relative_path(tmp___55);
#line 1573
      args_add(stripped_args, (char const   *)relpath___1);
#line 1576
      pchpath = format("%s.gch", *(argv + (i + 1)));
#line 1577
      tmp___56 = stat((char const   */* __restrict  */)pchpath, (struct stat */* __restrict  */)(& st));
      }
#line 1577
      if (tmp___56 == 0) {
        {
#line 1578
        cc_log("Detected use of precompiled header: %s", pchpath);
#line 1579
        found_pch = (_Bool)1;
        }
      }
      {
#line 1582
      free((void *)pchpath);
#line 1583
      free((void *)relpath___1);
#line 1584
      i ++;
      }
#line 1585
      goto __Cont;
    }
    {
#line 1589
    tmp___59 = compopt_short(& compopt_takes_path, (char const   *)*(argv + i));
    }
#line 1589
    if (tmp___59) {
      {
#line 1592
      tmp___58 = x_strdup((char const   *)(*(argv + i) + 2));
#line 1592
      relpath___2 = make_relative_path(tmp___58);
#line 1593
      option___2 = format("-%c%s", (int )*(*(argv + i) + 1), relpath___2);
#line 1594
      args_add(stripped_args, (char const   *)option___2);
#line 1595
      free((void *)relpath___2);
#line 1596
      free((void *)option___2);
      }
#line 1597
      goto __Cont;
    }
    {
#line 1601
    tmp___60 = compopt_takes_arg((char const   *)*(argv + i));
    }
#line 1601
    if (tmp___60) {
#line 1602
      if (i == argc - 1) {
        {
#line 1603
        cc_log("Missing argument to %s", *(argv + i));
#line 1604
        stats_update((enum stats )9);
#line 1605
        result = (_Bool)0;
        }
#line 1606
        goto out;
      }
      {
#line 1608
      args_add(stripped_args, (char const   *)*(argv + i));
#line 1609
      args_add(stripped_args, (char const   *)*(argv + (i + 1)));
#line 1610
      i ++;
      }
#line 1611
      goto __Cont;
    }
#line 1615
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 1616
      args_add(stripped_args, (char const   *)*(argv + i));
      }
#line 1617
      goto __Cont;
    }
    {
#line 1623
    tmp___61 = stat((char const   */* __restrict  */)*(argv + i), (struct stat */* __restrict  */)(& st));
    }
#line 1623
    if (tmp___61 != 0) {
      {
#line 1624
      cc_log("%s is not a regular file, not considering as input file", *(argv + i));
#line 1626
      args_add(stripped_args, (char const   *)*(argv + i));
      }
#line 1627
      goto __Cont;
    } else
#line 1623
    if (! ((st.st_mode & 61440U) == 32768U)) {
      {
#line 1624
      cc_log("%s is not a regular file, not considering as input file", *(argv + i));
#line 1626
      args_add(stripped_args, (char const   *)*(argv + i));
      }
#line 1627
      goto __Cont;
    }
#line 1630
    if (input_file) {
      {
#line 1631
      tmp___63 = language_for_file((char const   *)*(argv + i));
      }
#line 1631
      if (tmp___63) {
        {
#line 1632
        cc_log("Multiple input files: %s and %s", input_file, *(argv + i));
#line 1633
        stats_update((enum stats )18);
        }
      } else
#line 1634
      if (! found_c_opt) {
        {
#line 1635
        cc_log("Called for link with %s", *(argv + i));
#line 1636
        tmp___62 = strstr((char const   *)*(argv + i), "conftest.");
        }
#line 1636
        if (tmp___62) {
          {
#line 1637
          stats_update((enum stats )19);
          }
        } else {
          {
#line 1639
          stats_update((enum stats )10);
          }
        }
      } else {
        {
#line 1642
        cc_log("Unsupported source extension: %s", *(argv + i));
#line 1643
        stats_update((enum stats )15);
        }
      }
#line 1645
      result = (_Bool)0;
#line 1646
      goto out;
    }
    {
#line 1650
    tmp___64 = x_strdup((char const   *)*(argv + i));
#line 1650
    input_file = make_relative_path(tmp___64);
    }
    __Cont: /* CIL Label */ 
#line 1311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1653
  if (! input_file) {
    {
#line 1654
    cc_log("No input file found");
#line 1655
    stats_update((enum stats )17);
#line 1656
    result = (_Bool)0;
    }
#line 1657
    goto out;
  }
#line 1660
  if (found_pch) {
#line 1660
    goto _L___2;
  } else
#line 1660
  if (found_fpch_preprocess) {
    _L___2: /* CIL Label */ 
#line 1661
    using_precompiled_header = (_Bool)1;
#line 1662
    if (! (sloppiness & 4U)) {
      {
#line 1663
      cc_log("You have to specify \"time_macros\" sloppiness when using precompiled headers to get direct hits");
#line 1665
      cc_log("Disabling direct mode");
#line 1666
      stats_update((enum stats )27);
#line 1667
      result = (_Bool)0;
      }
#line 1668
      goto out;
    }
  }
#line 1672
  if (explicit_language) {
    {
#line 1672
    tmp___65 = strcmp(explicit_language, "none");
    }
#line 1672
    if (tmp___65 == 0) {
#line 1673
      explicit_language = (char const   *)((void *)0);
    }
  }
  {
#line 1675
  file_language = language_for_file((char const   *)input_file);
  }
#line 1676
  if (explicit_language) {
    {
#line 1677
    tmp___66 = language_is_supported(explicit_language);
    }
#line 1677
    if (! tmp___66) {
      {
#line 1678
      cc_log("Unsupported language: %s", explicit_language);
#line 1679
      stats_update((enum stats )15);
#line 1680
      result = (_Bool)0;
      }
#line 1681
      goto out;
    }
#line 1683
    actual_language = explicit_language;
  } else {
#line 1685
    actual_language = file_language;
  }
#line 1688
  if (actual_language) {
    {
#line 1688
    tmp___67 = strstr(actual_language, "-header");
    }
#line 1688
    if ((unsigned long )tmp___67 != (unsigned long )((void *)0)) {
#line 1688
      tmp___68 = 1;
    } else {
#line 1688
      tmp___68 = 0;
    }
  } else {
#line 1688
    tmp___68 = 0;
  }
#line 1688
  output_is_precompiled_header = (_Bool )tmp___68;
#line 1691
  if (! found_c_opt) {
#line 1692
    if (output_is_precompiled_header) {
      {
#line 1693
      args_add(stripped_args, "-c");
      }
    } else {
      {
#line 1695
      cc_log("No -c option found");
#line 1698
      tmp___69 = strstr((char const   *)input_file, "conftest.");
      }
#line 1698
      if (tmp___69) {
        {
#line 1699
        stats_update((enum stats )19);
        }
      } else {
        {
#line 1701
        stats_update((enum stats )10);
        }
      }
#line 1703
      result = (_Bool)0;
#line 1704
      goto out;
    }
  }
#line 1708
  if (! actual_language) {
    {
#line 1709
    cc_log("Unsupported source extension: %s", input_file);
#line 1710
    stats_update((enum stats )15);
#line 1711
    result = (_Bool)0;
    }
#line 1712
    goto out;
  }
  {
#line 1715
  direct_i_file = language_is_preprocessed(actual_language);
  }
#line 1717
  if (output_is_precompiled_header) {
    {
#line 1719
    cc_log("Creating precompiled header; not compiling preprocessed code");
#line 1720
    compile_preprocessed_source_code = (_Bool)0;
    }
  }
  {
#line 1723
  tmp___70 = getenv("CCACHE_EXTENSION");
#line 1723
  i_extension = (char const   *)tmp___70;
  }
#line 1724
  if (! i_extension) {
    {
#line 1725
    tmp___71 = p_language_for_language(actual_language);
#line 1725
    p_language = tmp___71;
#line 1726
    tmp___72 = extension_for_language(p_language);
#line 1726
    i_extension = tmp___72 + 1;
    }
  }
#line 1730
  if (output_obj) {
    {
#line 1730
    tmp___73 = strcmp((char const   *)output_obj, "-");
    }
#line 1730
    if (tmp___73 == 0) {
      {
#line 1731
      stats_update((enum stats )21);
#line 1732
      cc_log("Output file is -");
#line 1733
      result = (_Bool)0;
      }
#line 1734
      goto out;
    }
  }
#line 1737
  if (! output_obj) {
#line 1738
    if (output_is_precompiled_header) {
      {
#line 1739
      output_obj = format("%s.gch", input_file);
      }
    } else {
      {
#line 1742
      output_obj = x_strdup((char const   *)input_file);
#line 1743
      p = strrchr((char const   *)output_obj, '/');
      }
#line 1743
      if (p) {
#line 1744
        output_obj = p + 1;
      }
      {
#line 1746
      p = strrchr((char const   *)output_obj, '.');
      }
#line 1747
      if (! p) {
        {
#line 1748
        cc_log("Badly formed object filename");
#line 1749
        stats_update((enum stats )9);
#line 1750
        result = (_Bool)0;
        }
#line 1751
        goto out;
      } else
#line 1747
      if (! *(p + 1)) {
        {
#line 1748
        cc_log("Badly formed object filename");
#line 1749
        stats_update((enum stats )9);
#line 1750
        result = (_Bool)0;
        }
#line 1751
        goto out;
      }
#line 1753
      if (found_S_opt) {
#line 1753
        *(p + 1) = (char )'s';
      } else {
#line 1753
        *(p + 1) = (char )'o';
      }
#line 1754
      *(p + 2) = (char)0;
    }
  }
  {
#line 1759
  tmp___74 = strcmp((char const   *)output_obj, "/dev/null");
  }
#line 1759
  if (! (tmp___74 == 0)) {
    {
#line 1759
    tmp___75 = stat((char const   */* __restrict  */)output_obj, (struct stat */* __restrict  */)(& st));
    }
#line 1759
    if (tmp___75 == 0) {
#line 1759
      if (! ((st.st_mode & 61440U) == 32768U)) {
        {
#line 1762
        cc_log("Not a regular file: %s", output_obj);
#line 1763
        stats_update((enum stats )16);
#line 1764
        result = (_Bool)0;
        }
#line 1765
        goto out;
      }
    }
  }
  {
#line 1775
  *preprocessor_args = args_copy(stripped_args);
  }
#line 1776
  if (input_charset) {
    {
#line 1777
    args_add(*preprocessor_args, input_charset);
    }
  }
#line 1779
  if (found_pch) {
    {
#line 1780
    args_add(*preprocessor_args, "-fpch-preprocess");
    }
  }
#line 1782
  if (explicit_language) {
    {
#line 1783
    args_add(*preprocessor_args, "-x");
#line 1784
    args_add(*preprocessor_args, explicit_language);
    }
  }
#line 1790
  if (generating_dependencies) {
#line 1791
    if (! dependency_filename_specified) {
      {
#line 1795
      base_name = remove_extension((char const   *)output_obj);
#line 1796
      default_depfile_name = format("%s.d", base_name);
#line 1797
      free((void *)base_name);
#line 1798
      args_add(dep_args, "-MF");
#line 1799
      args_add(dep_args, (char const   *)default_depfile_name);
#line 1800
      tmp___76 = x_strdup((char const   *)default_depfile_name);
#line 1800
      output_dep = make_relative_path(tmp___76);
      }
    }
#line 1803
    if (! dependency_target_specified) {
      {
#line 1804
      args_add(dep_args, "-MQ");
#line 1805
      args_add(dep_args, (char const   *)output_obj);
      }
    }
  }
#line 1809
  if (compile_preprocessed_source_code) {
    {
#line 1810
    *compiler_args = args_copy(stripped_args);
    }
#line 1811
    if (explicit_language) {
      {
#line 1817
      args_add(*compiler_args, "-x");
#line 1818
      tmp___77 = p_language_for_language(explicit_language);
#line 1818
      args_add(*compiler_args, tmp___77);
      }
    }
  } else {
    {
#line 1821
    *compiler_args = args_copy(*preprocessor_args);
    }
  }
  {
#line 1829
  args_extend(*preprocessor_args, dep_args);
  }
  out: 
  {
#line 1832
  args_free(stripped_args);
#line 1833
  args_free(dep_args);
  }
#line 1834
  return (result);
}
}
#line 1838 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
void cc_reset(void) 
{ 


  {
  {
#line 1841
  free((void *)current_working_dir);
#line 1841
  current_working_dir = (char *)((void *)0);
#line 1842
  free((void *)cache_dir);
#line 1842
  cache_dir = (char *)((void *)0);
#line 1843
  cache_logfile = (char *)((void *)0);
#line 1844
  base_dir = (char *)((void *)0);
#line 1845
  args_free(orig_args);
#line 1845
  orig_args = (struct args *)((void *)0);
#line 1846
  free((void *)input_file);
#line 1846
  input_file = (char *)((void *)0);
#line 1847
  free((void *)output_obj);
#line 1847
  output_obj = (char *)((void *)0);
#line 1848
  free((void *)output_dep);
#line 1848
  output_dep = (char *)((void *)0);
#line 1849
  free((void *)cached_obj_hash);
#line 1849
  cached_obj_hash = (struct file_hash *)((void *)0);
#line 1850
  free((void *)cached_obj);
#line 1850
  cached_obj = (char *)((void *)0);
#line 1851
  free((void *)cached_stderr);
#line 1851
  cached_stderr = (char *)((void *)0);
#line 1852
  free((void *)cached_dep);
#line 1852
  cached_dep = (char *)((void *)0);
#line 1853
  free((void *)manifest_path);
#line 1853
  manifest_path = (char *)((void *)0);
#line 1854
  time_of_compilation = (time_t )0;
#line 1855
  sloppiness = 0U;
  }
#line 1856
  if (included_files) {
    {
#line 1857
    hashtable_destroy(included_files, 1);
#line 1857
    included_files = (struct hashtable *)((void *)0);
    }
  }
  {
#line 1859
  generating_dependencies = (_Bool)0;
#line 1860
  i_extension = (char const   *)((void *)0);
#line 1861
  i_tmpfile = (char *)((void *)0);
#line 1862
  direct_i_file = (_Bool)0;
#line 1863
  free((void *)cpp_stderr);
#line 1863
  cpp_stderr = (char *)((void *)0);
#line 1864
  free((void *)stats_file);
#line 1864
  stats_file = (char *)((void *)0);
#line 1865
  enable_unify = (_Bool)0;
#line 1866
  enable_direct = (_Bool)1;
#line 1867
  enable_compression = (_Bool)0;
#line 1868
  nlevels = 2;
#line 1869
  compile_preprocessed_source_code = (_Bool)0;
#line 1870
  output_is_precompiled_header = (_Bool)0;
  }
#line 1871
  return;
}
}
#line 1873 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static unsigned int parse_sloppiness(char *p ) 
{ 
  unsigned int result ;
  char *word ;
  char *q ;
  char *saveptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1876
  result = 0U;
#line 1877
  saveptr = (char *)((void *)0);
#line 1879
  if (! p) {
#line 1880
    return (result);
  }
  {
#line 1882
  p = x_strdup((char const   *)p);
#line 1883
  q = p;
  }
  {
#line 1884
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1884
    word = strtok_r((char */* __restrict  */)q, (char const   */* __restrict  */)", ",
                    (char **/* __restrict  */)(& saveptr));
    }
#line 1884
    if (! word) {
#line 1884
      goto while_break;
    }
    {
#line 1885
    tmp = strcmp((char const   *)word, "file_macro");
    }
#line 1885
    if (tmp == 0) {
      {
#line 1886
      cc_log("Being sloppy about __FILE__");
#line 1887
      result |= 2U;
      }
    }
    {
#line 1889
    tmp___0 = strcmp((char const   *)word, "include_file_mtime");
    }
#line 1889
    if (tmp___0 == 0) {
      {
#line 1890
      cc_log("Being sloppy about include file mtime");
#line 1891
      result |= 1U;
      }
    }
    {
#line 1893
    tmp___1 = strcmp((char const   *)word, "time_macros");
    }
#line 1893
    if (tmp___1 == 0) {
      {
#line 1894
      cc_log("Being sloppy about __DATE__ and __TIME__");
#line 1895
      result |= 4U;
      }
    }
#line 1897
    q = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1899
  free((void *)p);
  }
#line 1900
  return (result);
}
}
#line 1905 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void setup_uncached_err(void) 
{ 
  char *buf___0 ;
  int uncached_fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1911
  uncached_fd = dup(2);
  }
#line 1912
  if (uncached_fd == -1) {
    {
#line 1913
    tmp = __errno_location();
#line 1913
    tmp___0 = strerror(*tmp);
#line 1913
    cc_log("dup(2) failed: %s", tmp___0);
#line 1914
    failed();
    }
  }
  {
#line 1918
  buf___0 = format("UNCACHED_ERR_FD=%d", uncached_fd);
#line 1920
  tmp___3 = putenv(buf___0);
  }
#line 1920
  if (tmp___3 == -1) {
    {
#line 1921
    tmp___1 = __errno_location();
#line 1921
    tmp___2 = strerror(*tmp___1);
#line 1921
    cc_log("putenv failed: %s", tmp___2);
#line 1922
    failed();
    }
  }
#line 1924
  return;
}
}
#line 1927 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void ccache(int argc , char **argv ) 
{ 
  _Bool put_object_in_manifest ;
  struct file_hash *object_hash ;
  struct file_hash *object_hash_from_manifest ;
  char *env ;
  struct mdfour common_hash ;
  struct mdfour direct_hash ;
  struct mdfour cpp_hash ;
  struct args *preprocessor_args ;
  struct args *compiler_args ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *p ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 1930
  put_object_in_manifest = (_Bool)0;
#line 1932
  object_hash_from_manifest = (struct file_hash *)((void *)0);
#line 1944
  find_compiler(argc, argv);
#line 1945
  setup_uncached_err();
#line 1947
  tmp = getenv("CCACHE_DISABLE");
  }
#line 1947
  if (tmp) {
    {
#line 1948
    cc_log("ccache is disabled");
#line 1949
    failed();
    }
  }
  {
#line 1952
  tmp___3 = getenv("CCACHE_READONLY");
  }
#line 1952
  if (! tmp___3) {
    {
#line 1953
    tmp___2 = create_cachedirtag((char const   *)cache_dir);
    }
#line 1953
    if (tmp___2 != 0) {
      {
#line 1954
      tmp___0 = __errno_location();
#line 1954
      tmp___1 = strerror(*tmp___0);
#line 1954
      cc_log("failed to create %s/CACHEDIR.TAG (%s)\n", cache_dir, tmp___1);
#line 1956
      failed();
      }
    }
  }
  {
#line 1960
  tmp___4 = getenv("CCACHE_SLOPPINESS");
#line 1960
  sloppiness = parse_sloppiness(tmp___4);
#line 1962
  cc_log_argv("Command line: ", argv);
#line 1963
  tmp___5 = get_hostname();
#line 1963
  cc_log("Hostname: %s", tmp___5);
#line 1964
  cc_log("Working directory: %s", current_working_dir);
  }
#line 1966
  if (base_dir) {
    {
#line 1967
    cc_log("Base directory: %s", base_dir);
    }
  }
  {
#line 1970
  tmp___6 = getenv("CCACHE_UNIFY");
  }
#line 1970
  if (tmp___6) {
    {
#line 1971
    cc_log("Unify mode enabled");
#line 1972
    enable_unify = (_Bool)1;
    }
  }
  {
#line 1975
  tmp___7 = getenv("CCACHE_NODIRECT");
  }
#line 1975
  if (tmp___7) {
    {
#line 1976
    cc_log("Direct mode disabled");
#line 1977
    enable_direct = (_Bool)0;
    }
  } else
#line 1975
  if (enable_unify) {
    {
#line 1976
    cc_log("Direct mode disabled");
#line 1977
    enable_direct = (_Bool)0;
    }
  }
  {
#line 1980
  tmp___8 = getenv("CCACHE_COMPRESS");
  }
#line 1980
  if (tmp___8) {
    {
#line 1981
    cc_log("Compression enabled");
#line 1982
    enable_compression = (_Bool)1;
    }
  }
  {
#line 1985
  env = getenv("CCACHE_NLEVELS");
  }
#line 1985
  if (env) {
    {
#line 1986
    nlevels = atoi((char const   *)env);
    }
#line 1987
    if (nlevels < 1) {
#line 1987
      nlevels = 1;
    }
#line 1988
    if (nlevels > 8) {
#line 1988
      nlevels = 8;
    }
  }
  {
#line 1991
  tmp___9 = cc_process_args(orig_args, & preprocessor_args, & compiler_args);
  }
#line 1991
  if (! tmp___9) {
    {
#line 1992
    failed();
    }
  }
  {
#line 1995
  cc_log("Source file: %s", input_file);
  }
#line 1996
  if (generating_dependencies) {
    {
#line 1997
    cc_log("Dependency file: %s", output_dep);
    }
  }
  {
#line 1999
  cc_log("Object file: %s", output_obj);
#line 2001
  hash_start(& common_hash);
#line 2002
  calculate_common_hash(preprocessor_args, & common_hash);
#line 2005
  direct_hash = common_hash;
  }
#line 2006
  if (enable_direct) {
    {
#line 2007
    cc_log("Trying direct lookup");
#line 2008
    object_hash = calculate_object_hash(preprocessor_args, & direct_hash, 1);
    }
#line 2009
    if (object_hash) {
      {
#line 2010
      update_cached_result_globals(object_hash);
#line 2016
      from_cache((enum fromcache_call_mode )0, (_Bool)0);
#line 2023
      put_object_in_manifest = (_Bool)0;
#line 2025
      object_hash_from_manifest = object_hash;
      }
    } else {
#line 2028
      put_object_in_manifest = (_Bool)1;
    }
  }
  {
#line 2036
  cpp_hash = common_hash;
#line 2037
  cc_log("Running preprocessor");
#line 2038
  object_hash = calculate_object_hash(preprocessor_args, & cpp_hash, 0);
  }
#line 2039
  if (! object_hash) {
    {
#line 2040
    fatal("internal error: object hash from cpp returned NULL");
    }
  }
  {
#line 2042
  update_cached_result_globals(object_hash);
  }
#line 2044
  if (object_hash_from_manifest) {
    {
#line 2044
    tmp___10 = file_hashes_equal(object_hash_from_manifest, object_hash);
    }
#line 2044
    if (! tmp___10) {
      {
#line 2061
      cc_log("Hash from manifest doesn\'t match preprocessor output");
#line 2062
      cc_log("Likely reason: different CCACHE_BASEDIRs used");
#line 2063
      cc_log("Removing manifest as a safety measure");
#line 2064
      x_unlink((char const   *)manifest_path);
#line 2066
      put_object_in_manifest = (_Bool)1;
      }
    }
  }
  {
#line 2070
  from_cache((enum fromcache_call_mode )1, put_object_in_manifest);
#line 2072
  tmp___11 = getenv("CCACHE_READONLY");
  }
#line 2072
  if (tmp___11) {
    {
#line 2073
    cc_log("Read-only mode; running real compiler");
#line 2074
    failed();
    }
  }
  {
#line 2077
  env = getenv("CCACHE_PREFIX");
  }
#line 2078
  if (env) {
    {
#line 2079
    tmp___12 = find_executable((char const   *)env, "ccache");
#line 2079
    p = tmp___12;
    }
#line 2080
    if (! p) {
      {
#line 2081
      tmp___13 = __errno_location();
#line 2081
      tmp___14 = strerror(*tmp___13);
#line 2081
      fatal("%s: %s", env, tmp___14);
      }
    }
    {
#line 2083
    cc_log("Using command-line prefix %s", env);
#line 2084
    args_add_prefix(compiler_args, (char const   *)p);
    }
  }
  {
#line 2088
  to_cache(compiler_args);
#line 2091
  from_cache((enum fromcache_call_mode )2, put_object_in_manifest);
#line 2094
  cc_log("Secondary from_cache failed");
#line 2095
  stats_update((enum stats )3);
#line 2096
  failed();
  }
#line 2097
  return;
}
}
#line 2099 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static void check_cache_dir(void) 
{ 


  {
#line 2102
  if (! cache_dir) {
    {
#line 2103
    fatal("Unable to determine cache directory");
    }
  }
#line 2105
  return;
}
}
#line 2114
static int ccache_main_options(int argc , char **argv ) ;
#line 2114 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static struct option  const  options[9]  = 
#line 2114
  {      {"show-stats", 0, (int *)0, 's'}, 
        {"zero-stats", 0, (int *)0, 'z'}, 
        {"cleanup", 0, (int *)0, 'c'}, 
        {"clear", 0, (int *)0, 'C'}, 
        {"max-files", 1, (int *)0, 'F'}, 
        {"max-size", 1, (int *)0, 'M'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 2108 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
static int ccache_main_options(int argc , char **argv ) 
{ 
  int c ;
  size_t v ;
  int tmp ;
  int tmp___0 ;
  char *s ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2126
    c = getopt_long(argc, (char * const  *)argv, "hszcCF:M:V", options, (int *)((void *)0));
    }
#line 2126
    if (! (c != -1)) {
#line 2126
      goto while_break;
    }
    {
#line 2128
    if (c == 86) {
#line 2128
      goto case_86;
    }
#line 2132
    if (c == 104) {
#line 2132
      goto case_104;
    }
#line 2136
    if (c == 115) {
#line 2136
      goto case_115;
    }
#line 2141
    if (c == 99) {
#line 2141
      goto case_99;
    }
#line 2147
    if (c == 67) {
#line 2147
      goto case_67;
    }
#line 2153
    if (c == 122) {
#line 2153
      goto case_122;
    }
#line 2159
    if (c == 70) {
#line 2159
      goto case_70;
    }
#line 2174
    if (c == 77) {
#line 2174
      goto case_77;
    }
#line 2191
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 2129
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)(VERSION_TEXT),
            CCACHE_VERSION);
#line 2130
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 2133
    fputs((char const   */* __restrict  */)(USAGE_TEXT), (FILE */* __restrict  */)stdout);
#line 2134
    exit(0);
    }
    case_115: /* CIL Label */ 
    {
#line 2137
    check_cache_dir();
#line 2138
    stats_summary();
    }
#line 2139
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 2142
    check_cache_dir();
#line 2143
    cleanup_all((char const   *)cache_dir);
#line 2144
    printf((char const   */* __restrict  */)"Cleaned cache\n");
    }
#line 2145
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 2148
    check_cache_dir();
#line 2149
    wipe_all((char const   *)cache_dir);
#line 2150
    printf((char const   */* __restrict  */)"Cleared cache\n");
    }
#line 2151
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 2154
    check_cache_dir();
#line 2155
    stats_zero();
#line 2156
    printf((char const   */* __restrict  */)"Statistics cleared\n");
    }
#line 2157
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 2160
    check_cache_dir();
#line 2161
    tmp = atoi((char const   *)optarg);
#line 2161
    v = (size_t )tmp;
#line 2162
    tmp___0 = stats_set_limits((long )v, -1L);
    }
#line 2162
    if (tmp___0 == 0) {
#line 2163
      if (v == 0UL) {
        {
#line 2164
        printf((char const   */* __restrict  */)"Unset cache file limit\n");
        }
      } else {
        {
#line 2166
        printf((char const   */* __restrict  */)"Set cache file limit to %u\n", (unsigned int )v);
        }
      }
    } else {
      {
#line 2169
      printf((char const   */* __restrict  */)"Could not set cache file limit.\n");
#line 2170
      exit(1);
      }
    }
#line 2172
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 2175
    check_cache_dir();
#line 2176
    v = value_units((char const   *)optarg);
#line 2177
    tmp___2 = stats_set_limits(-1L, (long )v);
    }
#line 2177
    if (tmp___2 == 0) {
#line 2178
      if (v == 0UL) {
        {
#line 2179
        printf((char const   */* __restrict  */)"Unset cache size limit\n");
        }
      } else {
        {
#line 2181
        tmp___1 = format_size(v);
#line 2181
        s = tmp___1;
#line 2182
        printf((char const   */* __restrict  */)"Set cache size limit to %s\n", s);
#line 2183
        free((void *)s);
        }
      }
    } else {
      {
#line 2186
      printf((char const   */* __restrict  */)"Could not set cache size limit.\n");
#line 2187
      exit(1);
      }
    }
#line 2189
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2192
    fputs((char const   */* __restrict  */)(USAGE_TEXT), (FILE */* __restrict  */)stderr);
#line 2193
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2197
  return (0);
}
}
#line 2200 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/ccache.c"
int ccache_main(int argc , char **argv ) 
{ 
  char *p ;
  char *program_name ;
  mode_t mask ;
  int *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char const   *home_directory ;
  char const   *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 2206
  exitfn_init();
#line 2207
  exitfn_add_nullary(& stats_flush);
#line 2208
  exitfn_add_nullary(& clean_up_tmp_files);
#line 2211
  cache_logfile = getenv("CCACHE_LOGFILE");
#line 2212
  cc_log("=== CCACHE STARTED =========================================");
#line 2215
  p = getenv("CCACHE_UMASK");
  }
#line 2216
  if (p) {
    {
#line 2218
    tmp = __errno_location();
#line 2218
    *tmp = 0;
#line 2219
    tmp___0 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0),
                     8);
#line 2219
    mask = (mode_t )tmp___0;
#line 2220
    tmp___1 = __errno_location();
    }
#line 2220
    if (*tmp___1 == 0) {
      {
#line 2221
      umask(mask);
      }
    }
  }
  {
#line 2225
  cache_dir = getenv("CCACHE_DIR");
  }
#line 2226
  if (cache_dir) {
    {
#line 2227
    cache_dir = x_strdup((char const   *)cache_dir);
    }
  } else {
    {
#line 2229
    tmp___2 = get_home_directory();
#line 2229
    home_directory = tmp___2;
    }
#line 2230
    if (home_directory) {
      {
#line 2231
      cache_dir = format("%s/.ccache", home_directory);
      }
    }
  }
  {
#line 2236
  program_name = basename((char const   *)*(argv + 0));
#line 2237
  tmp___4 = same_executable_name((char const   *)program_name, "ccache");
  }
#line 2237
  if (tmp___4) {
#line 2238
    if (argc < 2) {
      {
#line 2239
      fputs((char const   */* __restrict  */)(USAGE_TEXT), (FILE */* __restrict  */)stderr);
#line 2240
      exit(1);
      }
    }
#line 2244
    if ((int )*(*(argv + 1) + 0) == 45) {
      {
#line 2245
      tmp___3 = ccache_main_options(argc, argv);
      }
#line 2245
      return (tmp___3);
    }
  }
  {
#line 2248
  free((void *)program_name);
#line 2250
  check_cache_dir();
#line 2252
  temp_dir = getenv("CCACHE_TEMPDIR");
  }
#line 2253
  if (! temp_dir) {
    {
#line 2254
    temp_dir = format("%s/tmp", cache_dir);
    }
  }
  {
#line 2257
  base_dir = getenv("CCACHE_BASEDIR");
  }
#line 2258
  if (base_dir) {
#line 2258
    if ((int )*(base_dir + 0) != 47) {
      {
#line 2259
      cc_log("Ignoring non-absolute base directory %s", base_dir);
#line 2260
      base_dir = (char *)((void *)0);
      }
    }
  }
  {
#line 2263
  tmp___5 = getenv("CCACHE_CPP2");
  }
#line 2263
  if (tmp___5) {
#line 2263
    tmp___6 = 0;
  } else {
#line 2263
    tmp___6 = 1;
  }
  {
#line 2263
  compile_preprocessed_source_code = (_Bool )tmp___6;
#line 2266
  tmp___9 = create_dir((char const   *)cache_dir);
  }
#line 2266
  if (tmp___9 != 0) {
    {
#line 2267
    tmp___7 = __errno_location();
#line 2267
    tmp___8 = strerror(*tmp___7);
#line 2267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ccache: failed to create %s (%s)\n",
            cache_dir, tmp___8);
#line 2270
    exit(1);
    }
  }
  {
#line 2274
  tmp___12 = create_dir((char const   *)temp_dir);
  }
#line 2274
  if (tmp___12 != 0) {
    {
#line 2275
    tmp___10 = __errno_location();
#line 2275
    tmp___11 = strerror(*tmp___10);
#line 2275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ccache: failed to create %s (%s)\n",
            temp_dir, tmp___11);
#line 2278
    exit(1);
    }
  }
  {
#line 2281
  ccache(argc, argv);
  }
#line 2282
  return (1);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.h"
struct hashtable_itr *hashtable_iterator(struct hashtable *h ) ;
#line 60
int hashtable_iterator_advance(struct hashtable_itr *itr ) ;
#line 1364 "/usr/include/zlib.h"
extern int gzputs(gzFile file , char const   *s ) ;
#line 1385
extern int gzputc(gzFile file , int c ) ;
#line 1391
extern int gzgetc(gzFile file ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static unsigned int const   MAGIC  =    (uint32_t const   )1665363270U;
#line 66 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static unsigned char const   VERSION  =    (uint8_t const   )0;
#line 67 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static unsigned int const   MAX_MANIFEST_ENTRIES  =    (uint32_t const   )100;
#line 107 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static unsigned int hash_from_file_info(void *key ) 
{ 
  unsigned int tmp ;

  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  tmp = murmurhashneutral2((void const   *)key, (int )sizeof(struct file_info ), 0U);
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static int file_infos_equal(void *key1 , void *key2 ) 
{ 
  struct file_info *fi1 ;
  struct file_info *fi2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 117
  fi1 = (struct file_info *)key1;
#line 118
  fi2 = (struct file_info *)key2;
#line 119
  if (fi1->index == fi2->index) {
    {
#line 119
    tmp = memcmp((void const   *)(fi1->hash), (void const   *)(fi2->hash), (size_t )16);
    }
#line 119
    if (tmp == 0) {
#line 119
      if (fi1->size == fi2->size) {
#line 119
        tmp___0 = 1;
      } else {
#line 119
        tmp___0 = 0;
      }
    } else {
#line 119
      tmp___0 = 0;
    }
  } else {
#line 119
    tmp___0 = 0;
  }
#line 119
  return (tmp___0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static void free_manifest(struct manifest *mf ) 
{ 
  uint16_t i ;

  {
#line 128
  i = (uint16_t )0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((uint32_t )i < mf->n_files)) {
#line 128
      goto while_break;
    }
    {
#line 129
    free((void *)*(mf->files + i));
#line 128
    i = (uint16_t )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  free((void *)mf->files);
#line 132
  free((void *)mf->file_infos);
#line 133
  i = (uint16_t )0;
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! ((uint32_t )i < mf->n_objects)) {
#line 133
      goto while_break___0;
    }
    {
#line 134
    free((void *)(mf->objects + i)->file_info_indexes);
#line 133
    i = (uint16_t )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 136
  free((void *)mf->objects);
#line 137
  free((void *)mf);
  }
#line 138
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static struct manifest *create_empty_manifest(void) 
{ 
  struct manifest *mf ;
  void *tmp ;

  {
  {
#line 194
  tmp = x_malloc(sizeof(*mf));
#line 194
  mf = (struct manifest *)tmp;
#line 195
  mf->hash_size = (uint8_t )16;
#line 196
  mf->n_files = (uint32_t )0;
#line 197
  mf->files = (char **)((void *)0);
#line 198
  mf->n_file_infos = (uint32_t )0;
#line 199
  mf->file_infos = (struct file_info *)((void *)0);
#line 200
  mf->n_objects = (uint32_t )0;
#line 201
  mf->objects = (struct object *)((void *)0);
  }
#line 203
  return (mf);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static struct manifest *read_manifest(gzFile f ) 
{ 
  struct manifest *mf ;
  uint16_t i ;
  uint16_t j ;
  uint32_t magic ;
  uint8_t version ;
  uint16_t dummy ;
  int ch_ ;
  size_t i_ ;
  unsigned char *tmp ;
  int tmp___0 ;
  int ch____0 ;
  size_t i____0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  int ch____1 ;
  size_t i____1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int ch____2 ;
  size_t i____2 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  int ch____3 ;
  size_t i____3 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char buf_[1024] ;
  size_t i____4 ;
  int ch____4 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  int ch____5 ;
  size_t i____5 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int ch____6 ;
  size_t i____6 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;
  size_t i____7 ;
  int ch____7 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  int ch____8 ;
  size_t i____8 ;
  unsigned char *tmp___19 ;
  int tmp___20 ;
  int ch____9 ;
  size_t i____9 ;
  unsigned char *tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  int ch____10 ;
  size_t i____10 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  int ch____11 ;
  size_t i____11 ;
  unsigned char *tmp___27 ;
  int tmp___28 ;
  size_t i____12 ;
  int ch____12 ;
  unsigned char *tmp___29 ;
  int tmp___30 ;
  int ch____13 ;
  size_t i____13 ;
  unsigned char *tmp___31 ;
  int tmp___32 ;

  {
  {
#line 215
  mf = create_empty_manifest();
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    magic = (uint32_t )0;
#line 217
    i_ = (size_t )0;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i_ < 4UL)) {
#line 217
        goto while_break___0;
      }
#line 217
      if (f->have) {
#line 217
        (f->have) --;
#line 217
        (f->pos) ++;
#line 217
        tmp = f->next;
#line 217
        (f->next) ++;
#line 217
        ch_ = (int )*tmp;
      } else {
        {
#line 217
        tmp___0 = gzgetc(f);
#line 217
        ch_ = tmp___0;
        }
      }
#line 217
      if (ch_ == -1) {
#line 217
        goto error;
      }
#line 217
      magic <<= 8;
#line 217
      magic |= (unsigned int )(ch_ & 255);
#line 217
      i_ ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 217
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if (magic != (uint32_t )MAGIC) {
    {
#line 219
    cc_log("Manifest file has bad magic number %u", magic);
#line 220
    free_manifest(mf);
    }
#line 221
    return ((struct manifest *)((void *)0));
  }
  {
#line 223
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 223
    version = (uint8_t )0;
#line 223
    i____0 = (size_t )0;
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 223
      if (! (i____0 < 1UL)) {
#line 223
        goto while_break___2;
      }
#line 223
      if (f->have) {
#line 223
        (f->have) --;
#line 223
        (f->pos) ++;
#line 223
        tmp___1 = f->next;
#line 223
        (f->next) ++;
#line 223
        ch____0 = (int )*tmp___1;
      } else {
        {
#line 223
        tmp___2 = gzgetc(f);
#line 223
        ch____0 = tmp___2;
        }
      }
#line 223
      if (ch____0 == -1) {
#line 223
        goto error;
      }
#line 223
      version = (uint8_t )((int )version << 8);
#line 223
      version = (uint8_t )((int )version | (ch____0 & 255));
#line 223
      i____0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 223
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 224
  if ((int )version != (int )VERSION) {
    {
#line 225
    cc_log("Manifest file has unknown version %u", (int )version);
#line 226
    free_manifest(mf);
    }
#line 227
    return ((struct manifest *)((void *)0));
  }
  {
#line 230
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 230
    mf->hash_size = (uint8_t )0;
#line 230
    i____1 = (size_t )0;
    {
#line 230
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 230
      if (! (i____1 < 1UL)) {
#line 230
        goto while_break___4;
      }
#line 230
      if (f->have) {
#line 230
        (f->have) --;
#line 230
        (f->pos) ++;
#line 230
        tmp___3 = f->next;
#line 230
        (f->next) ++;
#line 230
        ch____1 = (int )*tmp___3;
      } else {
        {
#line 230
        tmp___4 = gzgetc(f);
#line 230
        ch____1 = tmp___4;
        }
      }
#line 230
      if (ch____1 == -1) {
#line 230
        goto error;
      }
#line 230
      mf->hash_size = (uint8_t )((int )mf->hash_size << 8);
#line 230
      mf->hash_size = (uint8_t )((int )mf->hash_size | (ch____1 & 255));
#line 230
      i____1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 230
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 231
  if ((int )mf->hash_size != 16) {
    {
#line 233
    cc_log("Manifest file has unsupported hash size %u", (int )mf->hash_size);
#line 234
    free_manifest(mf);
    }
#line 235
    return ((struct manifest *)((void *)0));
  }
  {
#line 238
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 238
    dummy = (uint16_t )0;
#line 238
    i____2 = (size_t )0;
    {
#line 238
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 238
      if (! (i____2 < 2UL)) {
#line 238
        goto while_break___6;
      }
#line 238
      if (f->have) {
#line 238
        (f->have) --;
#line 238
        (f->pos) ++;
#line 238
        tmp___5 = f->next;
#line 238
        (f->next) ++;
#line 238
        ch____2 = (int )*tmp___5;
      } else {
        {
#line 238
        tmp___6 = gzgetc(f);
#line 238
        ch____2 = tmp___6;
        }
      }
#line 238
      if (ch____2 == -1) {
#line 238
        goto error;
      }
#line 238
      dummy = (uint16_t )((int )dummy << 8);
#line 238
      dummy = (uint16_t )((int )dummy | (ch____2 & 255));
#line 238
      i____2 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 238
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 240
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 240
    mf->n_files = (uint32_t )0;
#line 240
    i____3 = (size_t )0;
    {
#line 240
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 240
      if (! (i____3 < 4UL)) {
#line 240
        goto while_break___8;
      }
#line 240
      if (f->have) {
#line 240
        (f->have) --;
#line 240
        (f->pos) ++;
#line 240
        tmp___7 = f->next;
#line 240
        (f->next) ++;
#line 240
        ch____3 = (int )*tmp___7;
      } else {
        {
#line 240
        tmp___8 = gzgetc(f);
#line 240
        ch____3 = tmp___8;
        }
      }
#line 240
      if (ch____3 == -1) {
#line 240
        goto error;
      }
#line 240
      mf->n_files <<= 8;
#line 240
      mf->n_files |= (unsigned int )(ch____3 & 255);
#line 240
      i____3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 240
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 241
  tmp___9 = x_calloc((size_t )mf->n_files, sizeof(*(mf->files)));
#line 241
  mf->files = (char **)tmp___9;
#line 242
  i = (uint16_t )0;
  }
  {
#line 242
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 242
    if (! ((uint32_t )i < mf->n_files)) {
#line 242
      goto while_break___9;
    }
    {
#line 243
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 243
      i____4 = (size_t )0;
      {
#line 243
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 243
        if (! (i____4 < sizeof(buf_))) {
#line 243
          goto while_break___11;
        }
#line 243
        if (f->have) {
#line 243
          (f->have) --;
#line 243
          (f->pos) ++;
#line 243
          tmp___10 = f->next;
#line 243
          (f->next) ++;
#line 243
          ch____4 = (int )*tmp___10;
        } else {
          {
#line 243
          tmp___11 = gzgetc(f);
#line 243
          ch____4 = tmp___11;
          }
        }
#line 243
        if (ch____4 == -1) {
#line 243
          goto error;
        }
#line 243
        buf_[i____4] = (char )ch____4;
#line 243
        if (ch____4 == 0) {
#line 243
          goto while_break___11;
        }
#line 243
        i____4 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 243
      if (i____4 == sizeof(buf_)) {
#line 243
        goto error;
      }
      {
#line 243
      *(mf->files + i) = x_strdup((char const   *)(buf_));
      }
#line 243
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 242
    i = (uint16_t )((int )i + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 246
    mf->n_file_infos = (uint32_t )0;
#line 246
    i____5 = (size_t )0;
    {
#line 246
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 246
      if (! (i____5 < 4UL)) {
#line 246
        goto while_break___13;
      }
#line 246
      if (f->have) {
#line 246
        (f->have) --;
#line 246
        (f->pos) ++;
#line 246
        tmp___12 = f->next;
#line 246
        (f->next) ++;
#line 246
        ch____5 = (int )*tmp___12;
      } else {
        {
#line 246
        tmp___13 = gzgetc(f);
#line 246
        ch____5 = tmp___13;
        }
      }
#line 246
      if (ch____5 == -1) {
#line 246
        goto error;
      }
#line 246
      mf->n_file_infos <<= 8;
#line 246
      mf->n_file_infos |= (unsigned int )(ch____5 & 255);
#line 246
      i____5 ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 246
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 247
  tmp___14 = x_calloc((size_t )mf->n_file_infos, sizeof(*(mf->file_infos)));
#line 247
  mf->file_infos = (struct file_info *)tmp___14;
#line 248
  i = (uint16_t )0;
  }
  {
#line 248
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 248
    if (! ((uint32_t )i < mf->n_file_infos)) {
#line 248
      goto while_break___14;
    }
    {
#line 249
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 249
      (mf->file_infos + i)->index = (uint32_t )0;
#line 249
      i____6 = (size_t )0;
      {
#line 249
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 249
        if (! (i____6 < 4UL)) {
#line 249
          goto while_break___16;
        }
#line 249
        if (f->have) {
#line 249
          (f->have) --;
#line 249
          (f->pos) ++;
#line 249
          tmp___15 = f->next;
#line 249
          (f->next) ++;
#line 249
          ch____6 = (int )*tmp___15;
        } else {
          {
#line 249
          tmp___16 = gzgetc(f);
#line 249
          ch____6 = tmp___16;
          }
        }
#line 249
        if (ch____6 == -1) {
#line 249
          goto error;
        }
#line 249
        (mf->file_infos + i)->index <<= 8;
#line 249
        (mf->file_infos + i)->index |= (unsigned int )(ch____6 & 255);
#line 249
        i____6 ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 249
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 250
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 250
      i____7 = (size_t )0;
      {
#line 250
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 250
        if (! (i____7 < (size_t )mf->hash_size)) {
#line 250
          goto while_break___18;
        }
#line 250
        if (f->have) {
#line 250
          (f->have) --;
#line 250
          (f->pos) ++;
#line 250
          tmp___17 = f->next;
#line 250
          (f->next) ++;
#line 250
          ch____7 = (int )*tmp___17;
        } else {
          {
#line 250
          tmp___18 = gzgetc(f);
#line 250
          ch____7 = tmp___18;
          }
        }
#line 250
        if (ch____7 == -1) {
#line 250
          goto error;
        }
#line 250
        (mf->file_infos + i)->hash[i____7] = (uint8_t )ch____7;
#line 250
        i____7 ++;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 250
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 251
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 251
      (mf->file_infos + i)->size = (uint32_t )0;
#line 251
      i____8 = (size_t )0;
      {
#line 251
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 251
        if (! (i____8 < 4UL)) {
#line 251
          goto while_break___20;
        }
#line 251
        if (f->have) {
#line 251
          (f->have) --;
#line 251
          (f->pos) ++;
#line 251
          tmp___19 = f->next;
#line 251
          (f->next) ++;
#line 251
          ch____8 = (int )*tmp___19;
        } else {
          {
#line 251
          tmp___20 = gzgetc(f);
#line 251
          ch____8 = tmp___20;
          }
        }
#line 251
        if (ch____8 == -1) {
#line 251
          goto error;
        }
#line 251
        (mf->file_infos + i)->size <<= 8;
#line 251
        (mf->file_infos + i)->size |= (unsigned int )(ch____8 & 255);
#line 251
        i____8 ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 251
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 248
    i = (uint16_t )((int )i + 1);
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 254
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 254
    mf->n_objects = (uint32_t )0;
#line 254
    i____9 = (size_t )0;
    {
#line 254
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 254
      if (! (i____9 < 4UL)) {
#line 254
        goto while_break___22;
      }
#line 254
      if (f->have) {
#line 254
        (f->have) --;
#line 254
        (f->pos) ++;
#line 254
        tmp___21 = f->next;
#line 254
        (f->next) ++;
#line 254
        ch____9 = (int )*tmp___21;
      } else {
        {
#line 254
        tmp___22 = gzgetc(f);
#line 254
        ch____9 = tmp___22;
        }
      }
#line 254
      if (ch____9 == -1) {
#line 254
        goto error;
      }
#line 254
      mf->n_objects <<= 8;
#line 254
      mf->n_objects |= (unsigned int )(ch____9 & 255);
#line 254
      i____9 ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 254
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 255
  tmp___23 = x_calloc((size_t )mf->n_objects, sizeof(*(mf->objects)));
#line 255
  mf->objects = (struct object *)tmp___23;
#line 256
  i = (uint16_t )0;
  }
  {
#line 256
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 256
    if (! ((uint32_t )i < mf->n_objects)) {
#line 256
      goto while_break___23;
    }
    {
#line 257
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 257
      (mf->objects + i)->n_file_info_indexes = (uint32_t )0;
#line 257
      i____10 = (size_t )0;
      {
#line 257
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 257
        if (! (i____10 < 4UL)) {
#line 257
          goto while_break___25;
        }
#line 257
        if (f->have) {
#line 257
          (f->have) --;
#line 257
          (f->pos) ++;
#line 257
          tmp___24 = f->next;
#line 257
          (f->next) ++;
#line 257
          ch____10 = (int )*tmp___24;
        } else {
          {
#line 257
          tmp___25 = gzgetc(f);
#line 257
          ch____10 = tmp___25;
          }
        }
#line 257
        if (ch____10 == -1) {
#line 257
          goto error;
        }
#line 257
        (mf->objects + i)->n_file_info_indexes <<= 8;
#line 257
        (mf->objects + i)->n_file_info_indexes |= (unsigned int )(ch____10 & 255);
#line 257
        i____10 ++;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 257
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 258
    tmp___26 = x_calloc((size_t )(mf->objects + i)->n_file_info_indexes, sizeof(*((mf->objects + i)->file_info_indexes)));
#line 258
    (mf->objects + i)->file_info_indexes = (uint32_t *)tmp___26;
#line 261
    j = (uint16_t )0;
    }
    {
#line 261
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 261
      if (! ((uint32_t )j < (mf->objects + i)->n_file_info_indexes)) {
#line 261
        goto while_break___26;
      }
      {
#line 262
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 262
        *((mf->objects + i)->file_info_indexes + j) = (uint32_t )0;
#line 262
        i____11 = (size_t )0;
        {
#line 262
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 262
          if (! (i____11 < 4UL)) {
#line 262
            goto while_break___28;
          }
#line 262
          if (f->have) {
#line 262
            (f->have) --;
#line 262
            (f->pos) ++;
#line 262
            tmp___27 = f->next;
#line 262
            (f->next) ++;
#line 262
            ch____11 = (int )*tmp___27;
          } else {
            {
#line 262
            tmp___28 = gzgetc(f);
#line 262
            ch____11 = tmp___28;
            }
          }
#line 262
          if (ch____11 == -1) {
#line 262
            goto error;
          }
#line 262
          *((mf->objects + i)->file_info_indexes + j) <<= 8;
#line 262
          *((mf->objects + i)->file_info_indexes + j) |= (unsigned int )(ch____11 & 255);
#line 262
          i____11 ++;
        }
        while_break___28: /* CIL Label */ ;
        }
#line 262
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 261
      j = (uint16_t )((int )j + 1);
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 264
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 264
      i____12 = (size_t )0;
      {
#line 264
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 264
        if (! (i____12 < (size_t )mf->hash_size)) {
#line 264
          goto while_break___30;
        }
#line 264
        if (f->have) {
#line 264
          (f->have) --;
#line 264
          (f->pos) ++;
#line 264
          tmp___29 = f->next;
#line 264
          (f->next) ++;
#line 264
          ch____12 = (int )*tmp___29;
        } else {
          {
#line 264
          tmp___30 = gzgetc(f);
#line 264
          ch____12 = tmp___30;
          }
        }
#line 264
        if (ch____12 == -1) {
#line 264
          goto error;
        }
#line 264
        (mf->objects + i)->hash.hash[i____12] = (uint8_t )ch____12;
#line 264
        i____12 ++;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 264
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 265
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 265
      (mf->objects + i)->hash.size = (uint32_t )0;
#line 265
      i____13 = (size_t )0;
      {
#line 265
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 265
        if (! (i____13 < 4UL)) {
#line 265
          goto while_break___32;
        }
#line 265
        if (f->have) {
#line 265
          (f->have) --;
#line 265
          (f->pos) ++;
#line 265
          tmp___31 = f->next;
#line 265
          (f->next) ++;
#line 265
          ch____13 = (int )*tmp___31;
        } else {
          {
#line 265
          tmp___32 = gzgetc(f);
#line 265
          ch____13 = tmp___32;
          }
        }
#line 265
        if (ch____13 == -1) {
#line 265
          goto error;
        }
#line 265
        (mf->objects + i)->hash.size <<= 8;
#line 265
        (mf->objects + i)->hash.size |= (unsigned int )(ch____13 & 255);
#line 265
        i____13 ++;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 265
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
#line 256
    i = (uint16_t )((int )i + 1);
  }
  while_break___23: /* CIL Label */ ;
  }
#line 268
  return (mf);
  error: 
  {
#line 271
  cc_log("Corrupt manifest file");
#line 272
  free_manifest(mf);
  }
#line 273
  return ((struct manifest *)((void *)0));
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static int write_manifest(gzFile f , struct manifest  const  *mf ) 
{ 
  uint16_t i ;
  uint16_t j ;
  uint8_t ch_ ;
  size_t i_ ;
  int tmp ;
  uint8_t ch____0 ;
  size_t i____0 ;
  int tmp___0 ;
  uint8_t ch____1 ;
  size_t i____1 ;
  int tmp___1 ;
  uint8_t ch____2 ;
  size_t i____2 ;
  int tmp___2 ;
  uint8_t ch____3 ;
  size_t i____3 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint8_t ch____4 ;
  size_t i____4 ;
  int tmp___6 ;
  uint8_t ch____5 ;
  size_t i____5 ;
  int tmp___7 ;
  size_t i____6 ;
  int tmp___8 ;
  uint8_t ch____6 ;
  size_t i____7 ;
  int tmp___9 ;
  uint8_t ch____7 ;
  size_t i____8 ;
  int tmp___10 ;
  uint8_t ch____8 ;
  size_t i____9 ;
  int tmp___11 ;
  uint8_t ch____9 ;
  size_t i____10 ;
  int tmp___12 ;
  size_t i____11 ;
  int tmp___13 ;
  uint8_t ch____10 ;
  size_t i____12 ;
  int tmp___14 ;

  {
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    i_ = (size_t )0;
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 310
      if (! (i_ < 4UL)) {
#line 310
        goto while_break___0;
      }
      {
#line 310
      ch_ = (uint8_t )(MAGIC >> 8UL * ((4UL - i_) - 1UL));
#line 310
      tmp = gzputc(f, (int )ch_);
      }
#line 310
      if (tmp == -1) {
#line 310
        goto error;
      }
#line 310
      i_ ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 311
    i____0 = (size_t )0;
    {
#line 311
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 311
      if (! (i____0 < 1UL)) {
#line 311
        goto while_break___2;
      }
      {
#line 311
      ch____0 = (uint8_t )((int const   )VERSION >> 8UL * ((1UL - i____0) - 1UL));
#line 311
      tmp___0 = gzputc(f, (int )ch____0);
      }
#line 311
      if (tmp___0 == -1) {
#line 311
        goto error;
      }
#line 311
      i____0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 311
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 312
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 312
    i____1 = (size_t )0;
    {
#line 312
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 312
      if (! (i____1 < 1UL)) {
#line 312
        goto while_break___4;
      }
      {
#line 312
      ch____1 = (uint8_t )(16 >> 8UL * ((1UL - i____1) - 1UL));
#line 312
      tmp___1 = gzputc(f, (int )ch____1);
      }
#line 312
      if (tmp___1 == -1) {
#line 312
        goto error;
      }
#line 312
      i____1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 312
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 313
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 313
    i____2 = (size_t )0;
    {
#line 313
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 313
      if (! (i____2 < 2UL)) {
#line 313
        goto while_break___6;
      }
      {
#line 313
      ch____2 = (uint8_t )0;
#line 313
      tmp___2 = gzputc(f, (int )ch____2);
      }
#line 313
      if (tmp___2 == -1) {
#line 313
        goto error;
      }
#line 313
      i____2 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 313
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 315
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 315
    i____3 = (size_t )0;
    {
#line 315
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 315
      if (! (i____3 < 4UL)) {
#line 315
        goto while_break___8;
      }
      {
#line 315
      ch____3 = (uint8_t )(mf->n_files >> 8UL * ((4UL - i____3) - 1UL));
#line 315
      tmp___3 = gzputc(f, (int )ch____3);
      }
#line 315
      if (tmp___3 == -1) {
#line 315
        goto error;
      }
#line 315
      i____3 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 315
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 316
  i = (uint16_t )0;
  {
#line 316
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 316
    if (! ((uint32_t const   )i < mf->n_files)) {
#line 316
      goto while_break___9;
    }
    {
#line 317
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 317
      tmp___4 = gzputs(f, (char const   *)*(mf->files + i));
      }
#line 317
      if (tmp___4 == -1) {
#line 317
        goto error;
      } else {
        {
#line 317
        tmp___5 = gzputc(f, '\000');
        }
#line 317
        if (tmp___5 == -1) {
#line 317
          goto error;
        }
      }
#line 317
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 316
    i = (uint16_t )((int )i + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 320
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 320
    i____4 = (size_t )0;
    {
#line 320
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 320
      if (! (i____4 < 4UL)) {
#line 320
        goto while_break___12;
      }
      {
#line 320
      ch____4 = (uint8_t )(mf->n_file_infos >> 8UL * ((4UL - i____4) - 1UL));
#line 320
      tmp___6 = gzputc(f, (int )ch____4);
      }
#line 320
      if (tmp___6 == -1) {
#line 320
        goto error;
      }
#line 320
      i____4 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 320
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 321
  i = (uint16_t )0;
  {
#line 321
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 321
    if (! ((uint32_t const   )i < mf->n_file_infos)) {
#line 321
      goto while_break___13;
    }
    {
#line 322
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 322
      i____5 = (size_t )0;
      {
#line 322
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 322
        if (! (i____5 < 4UL)) {
#line 322
          goto while_break___15;
        }
        {
#line 322
        ch____5 = (uint8_t )((mf->file_infos + i)->index >> 8UL * ((4UL - i____5) - 1UL));
#line 322
        tmp___7 = gzputc(f, (int )ch____5);
        }
#line 322
        if (tmp___7 == -1) {
#line 322
          goto error;
        }
#line 322
        i____5 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 322
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 323
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 323
      i____6 = (size_t )0;
      {
#line 323
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 323
        if (! (i____6 < (size_t )mf->hash_size)) {
#line 323
          goto while_break___17;
        }
        {
#line 323
        tmp___8 = gzputc(f, (int )(mf->file_infos + i)->hash[i____6]);
        }
#line 323
        if (tmp___8 == -1) {
#line 323
          goto error;
        }
#line 323
        i____6 ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 323
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 324
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 324
      i____7 = (size_t )0;
      {
#line 324
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 324
        if (! (i____7 < 4UL)) {
#line 324
          goto while_break___19;
        }
        {
#line 324
        ch____6 = (uint8_t )((mf->file_infos + i)->size >> 8UL * ((4UL - i____7) - 1UL));
#line 324
        tmp___9 = gzputc(f, (int )ch____6);
        }
#line 324
        if (tmp___9 == -1) {
#line 324
          goto error;
        }
#line 324
        i____7 ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 324
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 321
    i = (uint16_t )((int )i + 1);
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 327
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 327
    i____8 = (size_t )0;
    {
#line 327
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 327
      if (! (i____8 < 4UL)) {
#line 327
        goto while_break___21;
      }
      {
#line 327
      ch____7 = (uint8_t )(mf->n_objects >> 8UL * ((4UL - i____8) - 1UL));
#line 327
      tmp___10 = gzputc(f, (int )ch____7);
      }
#line 327
      if (tmp___10 == -1) {
#line 327
        goto error;
      }
#line 327
      i____8 ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 327
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 328
  i = (uint16_t )0;
  {
#line 328
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 328
    if (! ((uint32_t const   )i < mf->n_objects)) {
#line 328
      goto while_break___22;
    }
    {
#line 329
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 329
      i____9 = (size_t )0;
      {
#line 329
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 329
        if (! (i____9 < 4UL)) {
#line 329
          goto while_break___24;
        }
        {
#line 329
        ch____8 = (uint8_t )((mf->objects + i)->n_file_info_indexes >> 8UL * ((4UL - i____9) - 1UL));
#line 329
        tmp___11 = gzputc(f, (int )ch____8);
        }
#line 329
        if (tmp___11 == -1) {
#line 329
          goto error;
        }
#line 329
        i____9 ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 329
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 330
    j = (uint16_t )0;
    {
#line 330
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 330
      if (! ((uint32_t )j < (mf->objects + i)->n_file_info_indexes)) {
#line 330
        goto while_break___25;
      }
      {
#line 331
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 331
        i____10 = (size_t )0;
        {
#line 331
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 331
          if (! (i____10 < 4UL)) {
#line 331
            goto while_break___27;
          }
          {
#line 331
          ch____9 = (uint8_t )(*((mf->objects + i)->file_info_indexes + j) >> 8UL * ((4UL - i____10) - 1UL));
#line 331
          tmp___12 = gzputc(f, (int )ch____9);
          }
#line 331
          if (tmp___12 == -1) {
#line 331
            goto error;
          }
#line 331
          i____10 ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 331
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 330
      j = (uint16_t )((int )j + 1);
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 333
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 333
      i____11 = (size_t )0;
      {
#line 333
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 333
        if (! (i____11 < (size_t )mf->hash_size)) {
#line 333
          goto while_break___29;
        }
        {
#line 333
        tmp___13 = gzputc(f, (int )(mf->objects + i)->hash.hash[i____11]);
        }
#line 333
        if (tmp___13 == -1) {
#line 333
          goto error;
        }
#line 333
        i____11 ++;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 333
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 334
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 334
      i____12 = (size_t )0;
      {
#line 334
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 334
        if (! (i____12 < 4UL)) {
#line 334
          goto while_break___31;
        }
        {
#line 334
        ch____10 = (uint8_t )((mf->objects + i)->hash.size >> 8UL * ((4UL - i____12) - 1UL));
#line 334
        tmp___14 = gzputc(f, (int )ch____10);
        }
#line 334
        if (tmp___14 == -1) {
#line 334
          goto error;
        }
#line 334
        i____12 ++;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 334
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 328
    i = (uint16_t )((int )i + 1);
  }
  while_break___22: /* CIL Label */ ;
  }
#line 337
  return (1);
  error: 
  {
#line 340
  cc_log("Error writing to manifest file");
  }
#line 341
  return (0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static int verify_object(struct manifest *mf , struct object *obj , struct hashtable *hashed_files ) 
{ 
  uint32_t i ;
  struct file_info *fi ;
  struct file_hash *actual ;
  struct mdfour hash___0 ;
  int result ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 354
  i = (uint32_t )0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (i < obj->n_file_info_indexes)) {
#line 354
      goto while_break;
    }
    {
#line 355
    fi = mf->file_infos + *(obj->file_info_indexes + i);
#line 356
    tmp = hashtable_search(hashed_files, (void *)*(mf->files + fi->index));
#line 356
    actual = (struct file_hash *)tmp;
    }
#line 357
    if (! actual) {
      {
#line 358
      tmp___0 = x_malloc(sizeof(*actual));
#line 358
      actual = (struct file_hash *)tmp___0;
#line 359
      hash_start(& hash___0);
#line 360
      result = hash_source_code_file(& hash___0, (char const   *)*(mf->files + fi->index));
      }
#line 361
      if (result & 1) {
        {
#line 362
        cc_log("Failed hashing %s", *(mf->files + fi->index));
#line 363
        free((void *)actual);
        }
#line 364
        return (0);
      }
#line 366
      if (result & 4) {
        {
#line 367
        free((void *)actual);
        }
#line 368
        return (0);
      }
      {
#line 370
      hash_result_as_bytes(& hash___0, actual->hash);
#line 371
      actual->size = (uint32_t )hash___0.totalN;
#line 372
      tmp___1 = x_strdup((char const   *)*(mf->files + fi->index));
#line 372
      hashtable_insert(hashed_files, (void *)tmp___1, (void *)actual);
      }
    }
    {
#line 374
    tmp___2 = memcmp((void const   *)(fi->hash), (void const   *)(actual->hash), (size_t )mf->hash_size);
    }
#line 374
    if (tmp___2 != 0) {
#line 376
      return (0);
    } else
#line 374
    if (fi->size != actual->size) {
#line 376
      return (0);
    }
#line 354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return (1);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static struct hashtable *create_string_index_map(char **strings , uint32_t len___0 ) 
{ 
  uint32_t i ;
  struct hashtable *h ;
  uint32_t *index___0 ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 390
  h = create_hashtable(1000U, & hash_from_string, & strings_equal);
#line 391
  i = (uint32_t )0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (i < len___0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    tmp = x_malloc(sizeof(*index___0));
#line 392
    index___0 = (uint32_t *)tmp;
#line 393
    *index___0 = i;
#line 394
    tmp___0 = x_strdup((char const   *)*(strings + i));
#line 394
    hashtable_insert(h, (void *)tmp___0, (void *)index___0);
#line 391
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return (h);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static struct hashtable *create_file_info_index_map(struct file_info *infos , uint32_t len___0 ) 
{ 
  uint32_t i ;
  struct hashtable *h ;
  struct file_info *fi ;
  uint32_t *index___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 407
  h = create_hashtable(1000U, & hash_from_file_info, & file_infos_equal);
#line 408
  i = (uint32_t )0;
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i < len___0)) {
#line 408
      goto while_break;
    }
    {
#line 409
    tmp = x_malloc(sizeof(*fi));
#line 409
    fi = (struct file_info *)tmp;
#line 410
    *fi = *(infos + i);
#line 411
    tmp___0 = x_malloc(sizeof(*index___0));
#line 411
    index___0 = (uint32_t *)tmp___0;
#line 412
    *index___0 = i;
#line 413
    hashtable_insert(h, (void *)fi, (void *)index___0);
#line 408
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return (h);
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static uint32_t get_include_file_index(struct manifest *mf , char *path , struct hashtable *mf_files ) 
{ 
  uint32_t *index___0 ;
  uint32_t n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 425
  tmp = hashtable_search(mf_files, (void *)path);
#line 425
  index___0 = (uint32_t *)tmp;
  }
#line 426
  if (index___0) {
#line 427
    return (*index___0);
  }
  {
#line 430
  n = mf->n_files;
#line 431
  tmp___0 = x_realloc((void *)mf->files, (unsigned long )(n + 1U) * sizeof(*(mf->files)));
#line 431
  mf->files = (char **)tmp___0;
#line 432
  (mf->n_files) ++;
#line 433
  *(mf->files + n) = x_strdup((char const   *)path);
  }
#line 435
  return (n);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static uint32_t get_file_hash_index(struct manifest *mf , char *path , struct file_hash *file_hash ,
                                    struct hashtable *mf_files , struct hashtable *mf_file_infos ) 
{ 
  struct file_info fi ;
  uint32_t *fi_index ;
  uint32_t n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 449
  fi.index = get_include_file_index(mf, path, mf_files);
#line 450
  memcpy((void */* __restrict  */)(fi.hash), (void const   */* __restrict  */)(file_hash->hash),
         sizeof(fi.hash));
#line 451
  fi.size = file_hash->size;
#line 453
  tmp = hashtable_search(mf_file_infos, (void *)(& fi));
#line 453
  fi_index = (uint32_t *)tmp;
  }
#line 454
  if (fi_index) {
#line 455
    return (*fi_index);
  }
  {
#line 458
  n = mf->n_file_infos;
#line 459
  tmp___0 = x_realloc((void *)mf->file_infos, (unsigned long )(n + 1U) * sizeof(*(mf->file_infos)));
#line 459
  mf->file_infos = (struct file_info *)tmp___0;
#line 460
  (mf->n_file_infos) ++;
#line 461
  *(mf->file_infos + n) = fi;
  }
#line 463
  return (n);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static void add_file_info_indexes(uint32_t *indexes , uint32_t size , struct manifest *mf ,
                                  struct hashtable *included_files___0 ) 
{ 
  struct hashtable_itr *iter ;
  uint32_t i ;
  char *path ;
  struct file_hash *file_hash ;
  struct hashtable *mf_files ;
  struct hashtable *mf_file_infos ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 477
  if (size == 0U) {
#line 478
    return;
  }
  {
#line 481
  mf_files = create_string_index_map(mf->files, mf->n_files);
#line 482
  mf_file_infos = create_file_info_index_map(mf->file_infos, mf->n_file_infos);
#line 483
  iter = hashtable_iterator(included_files___0);
#line 484
  i = (uint32_t )0;
  }
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 486
    tmp = hashtable_iterator_key(iter);
#line 486
    path = (char *)tmp;
#line 487
    tmp___0 = hashtable_iterator_value(iter);
#line 487
    file_hash = (struct file_hash *)tmp___0;
#line 488
    *(indexes + i) = get_file_hash_index(mf, path, file_hash, mf_files, mf_file_infos);
#line 490
    i ++;
#line 485
    tmp___1 = hashtable_iterator_advance(iter);
    }
#line 485
    if (! tmp___1) {
#line 485
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  if (! (i == size)) {
    {
#line 492
    __assert_fail("i == size", "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c",
                  492U, "add_file_info_indexes");
    }
  }
  {
#line 494
  hashtable_destroy(mf_file_infos, 1);
#line 495
  hashtable_destroy(mf_files, 1);
  }
#line 496
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
static void add_object_entry(struct manifest *mf , struct file_hash *object_hash ,
                             struct hashtable *included_files___0 ) 
{ 
  struct object *obj ;
  uint32_t n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 506
  n = mf->n_objects;
#line 507
  tmp = x_realloc((void *)mf->objects, (unsigned long )(n + 1U) * sizeof(*(mf->objects)));
#line 507
  mf->objects = (struct object *)tmp;
#line 508
  (mf->n_objects) ++;
#line 509
  obj = mf->objects + n;
#line 511
  n = hashtable_count(included_files___0);
#line 512
  obj->n_file_info_indexes = n;
#line 513
  tmp___0 = x_malloc((unsigned long )n * sizeof(*(obj->file_info_indexes)));
#line 513
  obj->file_info_indexes = (uint32_t *)tmp___0;
#line 514
  add_file_info_indexes(obj->file_info_indexes, n, mf, included_files___0);
#line 515
  memcpy((void */* __restrict  */)(obj->hash.hash), (void const   */* __restrict  */)(object_hash->hash),
         (size_t )mf->hash_size);
#line 516
  obj->hash.size = object_hash->size;
  }
#line 517
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
struct file_hash *manifest_get(char const   *manifest_path___0 ) 
{ 
  int fd ;
  gzFile f ;
  struct manifest *mf ;
  struct hashtable *hashed_files ;
  uint32_t i ;
  struct file_hash *fh ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 527
  f = (gzFile )((void *)0);
#line 528
  mf = (struct manifest *)((void *)0);
#line 529
  hashed_files = (struct hashtable *)((void *)0);
#line 531
  fh = (struct file_hash *)((void *)0);
#line 533
  fd = open(manifest_path___0, 0);
  }
#line 534
  if (fd == -1) {
    {
#line 536
    cc_log("No such manifest file");
    }
#line 537
    goto out;
  }
  {
#line 539
  f = gzdopen(fd, "rb");
  }
#line 540
  if (! f) {
    {
#line 541
    close(fd);
#line 542
    cc_log("Failed to gzdopen manifest file");
    }
#line 543
    goto out;
  }
  {
#line 545
  mf = read_manifest(f);
  }
#line 546
  if (! mf) {
    {
#line 547
    cc_log("Error reading manifest file");
    }
#line 548
    goto out;
  }
  {
#line 551
  hashed_files = create_hashtable(1000U, & hash_from_string, & strings_equal);
#line 554
  i = mf->n_objects;
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (i > 0U)) {
#line 554
      goto while_break;
    }
    {
#line 555
    tmp___0 = verify_object(mf, mf->objects + (i - 1U), hashed_files);
    }
#line 555
    if (tmp___0) {
      {
#line 556
      tmp = x_malloc(sizeof(*fh));
#line 556
      fh = (struct file_hash *)tmp;
#line 557
      *fh = (mf->objects + (i - 1U))->hash;
      }
#line 558
      goto out;
    }
#line 554
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 563
  if (hashed_files) {
    {
#line 564
    hashtable_destroy(hashed_files, 1);
    }
  }
#line 566
  if (f) {
    {
#line 567
    gzclose(f);
    }
  }
#line 569
  if (mf) {
    {
#line 570
    free_manifest(mf);
    }
  }
#line 572
  return (fh);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/manifest.c"
_Bool manifest_put(char const   *manifest_path___0 , struct file_hash *object_hash ,
                   struct hashtable *included_files___0 ) 
{ 
  int ret___0 ;
  int fd1 ;
  int fd2 ;
  gzFile f2 ;
  struct manifest *mf ;
  char *tmp_file ;
  gzFile f1 ;
  gzFile tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 583
  ret___0 = 0;
#line 586
  f2 = (gzFile )((void *)0);
#line 587
  mf = (struct manifest *)((void *)0);
#line 588
  tmp_file = (char *)((void *)0);
#line 596
  fd1 = open(manifest_path___0, 0);
  }
#line 597
  if (fd1 == -1) {
    {
#line 599
    mf = create_empty_manifest();
    }
  } else {
    {
#line 601
    tmp = gzdopen(fd1, "rb");
#line 601
    f1 = tmp;
    }
#line 602
    if (! f1) {
      {
#line 603
      cc_log("Failed to gzdopen manifest file");
#line 604
      close(fd1);
      }
#line 605
      goto out;
    }
    {
#line 607
    mf = read_manifest(f1);
#line 608
    gzclose(f1);
    }
#line 609
    if (! mf) {
      {
#line 610
      cc_log("Failed to read manifest file; deleting it");
#line 611
      x_unlink(manifest_path___0);
#line 612
      mf = create_empty_manifest();
      }
    }
  }
#line 616
  if (mf->n_objects > (uint32_t )MAX_MANIFEST_ENTRIES) {
    {
#line 629
    cc_log("More than %u entries in manifest file; discarding", MAX_MANIFEST_ENTRIES);
#line 631
    free_manifest(mf);
#line 632
    mf = create_empty_manifest();
    }
  }
  {
#line 635
  tmp___0 = tmp_string();
#line 635
  tmp_file = format("%s.tmp.%s", manifest_path___0, tmp___0);
#line 636
  fd2 = safe_open((char const   *)tmp_file);
  }
#line 637
  if (fd2 == -1) {
    {
#line 638
    cc_log("Failed to open %s", tmp_file);
    }
#line 639
    goto out;
  }
  {
#line 641
  f2 = gzdopen(fd2, "wb");
  }
#line 642
  if (! f2) {
    {
#line 643
    cc_log("Failed to gzdopen %s", tmp_file);
    }
#line 644
    goto out;
  }
  {
#line 647
  add_object_entry(mf, object_hash, included_files___0);
#line 648
  tmp___2 = write_manifest(f2, (struct manifest  const  *)mf);
  }
#line 648
  if (tmp___2) {
    {
#line 649
    gzclose(f2);
#line 650
    f2 = (gzFile )((void *)0);
#line 651
    tmp___1 = x_rename((char const   *)tmp_file, manifest_path___0);
    }
#line 651
    if (tmp___1 == 0) {
#line 652
      ret___0 = 1;
    } else {
      {
#line 654
      cc_log("Failed to rename %s to %s", tmp_file, manifest_path___0);
      }
#line 655
      goto out;
    }
  } else {
    {
#line 658
    cc_log("Failed to write manifest file");
    }
#line 659
    goto out;
  }
  out: 
#line 663
  if (mf) {
    {
#line 664
    free_manifest(mf);
    }
  }
#line 666
  if (tmp_file) {
    {
#line 667
    free((void *)tmp_file);
    }
  }
#line 669
  if (f2) {
    {
#line 670
    gzclose(f2);
    }
  }
#line 672
  return ((_Bool )ret___0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.h"
int hashtable_iterator_remove(struct hashtable_itr *itr ) ;
#line 77
int hashtable_iterator_search(struct hashtable_itr *itr , struct hashtable *h , void *k ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.c"
struct hashtable_itr *hashtable_iterator(struct hashtable *h ) 
{ 
  unsigned int i ;
  unsigned int tablelength ;
  struct hashtable_itr *itr ;
  void *tmp ;

  {
  {
#line 15
  tmp = malloc(sizeof(struct hashtable_itr ));
#line 15
  itr = (struct hashtable_itr *)tmp;
  }
#line 17
  if ((unsigned long )((void *)0) == (unsigned long )itr) {
#line 17
    return ((struct hashtable_itr *)((void *)0));
  }
#line 18
  itr->h = h;
#line 19
  itr->e = (struct entry *)((void *)0);
#line 20
  itr->parent = (struct entry *)((void *)0);
#line 21
  tablelength = h->tablelength;
#line 22
  itr->index = tablelength;
#line 23
  if (0U == h->entrycount) {
#line 23
    return (itr);
  }
#line 25
  i = 0U;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < tablelength)) {
#line 25
      goto while_break;
    }
#line 27
    if ((unsigned long )((void *)0) != (unsigned long )*(h->table + i)) {
#line 29
      itr->e = *(h->table + i);
#line 30
      itr->index = i;
#line 31
      goto while_break;
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return (itr);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.c"
int hashtable_iterator_advance(struct hashtable_itr *itr ) 
{ 
  unsigned int j ;
  unsigned int tablelength ;
  struct entry **table ;
  struct entry *next ;

  {
#line 59
  if ((unsigned long )((void *)0) == (unsigned long )itr->e) {
#line 59
    return (0);
  }
#line 61
  next = (itr->e)->next;
#line 62
  if ((unsigned long )((void *)0) != (unsigned long )next) {
#line 64
    itr->parent = itr->e;
#line 65
    itr->e = next;
#line 66
    return (-1);
  }
#line 68
  tablelength = (itr->h)->tablelength;
#line 69
  itr->parent = (struct entry *)((void *)0);
#line 70
  (itr->index) ++;
#line 70
  j = itr->index;
#line 70
  if (tablelength <= j) {
#line 72
    itr->e = (struct entry *)((void *)0);
#line 73
    return (0);
  }
#line 75
  table = (itr->h)->table;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    next = *(table + j);
#line 76
    if (! ((unsigned long )((void *)0) == (unsigned long )next)) {
#line 76
      goto while_break;
    }
#line 78
    j ++;
#line 78
    if (j >= tablelength) {
#line 80
      itr->index = tablelength;
#line 81
      itr->e = (struct entry *)((void *)0);
#line 82
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  itr->index = j;
#line 86
  itr->e = next;
#line 87
  return (-1);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.c"
int hashtable_iterator_remove(struct hashtable_itr *itr ) 
{ 
  struct entry *remember_e ;
  struct entry *remember_parent ;
  int ret___0 ;

  {
#line 105
  if ((unsigned long )((void *)0) == (unsigned long )itr->parent) {
#line 108
    *((itr->h)->table + itr->index) = (itr->e)->next;
  } else {
#line 111
    (itr->parent)->next = (itr->e)->next;
  }
  {
#line 114
  remember_e = itr->e;
#line 115
  ((itr->h)->entrycount) --;
#line 116
  free(remember_e->k);
#line 119
  remember_parent = itr->parent;
#line 120
  ret___0 = hashtable_iterator_advance(itr);
  }
#line 121
  if ((unsigned long )itr->parent == (unsigned long )remember_e) {
#line 121
    itr->parent = remember_parent;
  }
  {
#line 122
  free((void *)remember_e);
  }
#line 123
  return (ret___0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashtable_itr.c"
int hashtable_iterator_search(struct hashtable_itr *itr , struct hashtable *h , void *k ) 
{ 
  struct entry *e ;
  struct entry *parent ;
  unsigned int hashvalue ;
  unsigned int index ;
  int tmp ;

  {
  {
#line 134
  hashvalue = hash(h, k);
#line 135
  index = indexFor(h->tablelength, hashvalue);
#line 137
  e = *(h->table + index);
#line 138
  parent = (struct entry *)((void *)0);
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )((void *)0) != (unsigned long )e)) {
#line 139
      goto while_break;
    }
#line 142
    if (hashvalue == e->h) {
      {
#line 142
      tmp = (*(h->eqfn))(k, e->k);
      }
#line 142
      if (tmp) {
#line 144
        itr->index = index;
#line 145
        itr->e = e;
#line 146
        itr->parent = parent;
#line 147
        itr->h = h;
#line 148
        return (-1);
      }
    }
#line 150
    parent = e;
#line 151
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static char const   * const  s_tokens[51]  = 
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
  {      (char const   */* const  */)"...",      (char const   */* const  */)">>=",      (char const   */* const  */)"<<=",      (char const   */* const  */)"+=", 
        (char const   */* const  */)"-=",      (char const   */* const  */)"*=",      (char const   */* const  */)"/=",      (char const   */* const  */)"%=", 
        (char const   */* const  */)"&=",      (char const   */* const  */)"^=",      (char const   */* const  */)"|=",      (char const   */* const  */)">>", 
        (char const   */* const  */)"<<",      (char const   */* const  */)"++",      (char const   */* const  */)"--",      (char const   */* const  */)"->", 
        (char const   */* const  */)"&&",      (char const   */* const  */)"||",      (char const   */* const  */)"<=",      (char const   */* const  */)">=", 
        (char const   */* const  */)"==",      (char const   */* const  */)"!=",      (char const   */* const  */)";",      (char const   */* const  */)"{", 
        (char const   */* const  */)"<%",      (char const   */* const  */)"}",      (char const   */* const  */)"%>",      (char const   */* const  */)",", 
        (char const   */* const  */)":",      (char const   */* const  */)"=",      (char const   */* const  */)"(",      (char const   */* const  */)")", 
        (char const   */* const  */)"[",      (char const   */* const  */)"<:",      (char const   */* const  */)"]",      (char const   */* const  */)":>", 
        (char const   */* const  */)".",      (char const   */* const  */)"&",      (char const   */* const  */)"!",      (char const   */* const  */)"~", 
        (char const   */* const  */)"-",      (char const   */* const  */)"+",      (char const   */* const  */)"*",      (char const   */* const  */)"/", 
        (char const   */* const  */)"%",      (char const   */* const  */)"<",      (char const   */* const  */)">",      (char const   */* const  */)"^", 
        (char const   */* const  */)"|",      (char const   */* const  */)"?",      (char const   */* const  */)0};
#line 53 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static struct __anonstruct_tokens_57 tokens[256]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static _Bool done  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static void build_table(void) 
{ 
  unsigned char c ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 67
  if (done) {
#line 67
    return;
  }
  {
#line 68
  done = (_Bool)1;
#line 70
  memset((void *)(tokens), 0, sizeof(tokens));
#line 71
  c = (unsigned char)0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((int )c < 128)) {
#line 71
      goto while_break;
    }
    {
#line 72
    tmp = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp + (int )c) & 1024) {
#line 72
      tokens[c].type = (unsigned char )((int )tokens[c].type | 1);
    } else
#line 72
    if ((int )c == 95) {
#line 72
      tokens[c].type = (unsigned char )((int )tokens[c].type | 1);
    }
    {
#line 73
    tmp___0 = __ctype_b_loc();
    }
#line 73
    if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 73
      tokens[c].type = (unsigned char )((int )tokens[c].type | 16);
    }
    {
#line 74
    tmp___1 = __ctype_b_loc();
    }
#line 74
    if ((int const   )*(*tmp___1 + (int )c) & 8192) {
#line 74
      tokens[c].type = (unsigned char )((int )tokens[c].type | 2);
    }
    {
#line 75
    tmp___2 = __ctype_b_loc();
    }
#line 75
    if ((int const   )*(*tmp___2 + (int )c) & 4096) {
#line 75
      tokens[c].type = (unsigned char )((int )tokens[c].type | 32);
    }
#line 71
    c = (unsigned char )((int )c + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  tokens['\''].type = (unsigned char )((int )tokens[39].type | 8);
#line 78
  tokens['\"'].type = (unsigned char )((int )tokens[34].type | 8);
#line 79
  tokens['l'].type = (unsigned char )((int )tokens[108].type | 64);
#line 80
  tokens['L'].type = (unsigned char )((int )tokens[76].type | 64);
#line 81
  tokens['f'].type = (unsigned char )((int )tokens[102].type | 64);
#line 82
  tokens['F'].type = (unsigned char )((int )tokens[70].type | 64);
#line 83
  tokens['U'].type = (unsigned char )((int )tokens[85].type | 64);
#line 84
  tokens['u'].type = (unsigned char )((int )tokens[117].type | 64);
#line 86
  tokens['-'].type = (unsigned char )((int )tokens[45].type | 128);
#line 87
  tokens['+'].type = (unsigned char )((int )tokens[43].type | 128);
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! s_tokens[i]) {
#line 89
      goto while_break___0;
    }
#line 90
    c = (unsigned char )*(s_tokens[i] + 0);
#line 91
    tokens[c].type = (unsigned char )((int )tokens[c].type | 4);
#line 92
    tokens[c].toks[tokens[c].num_toks] = (char const   *)s_tokens[i];
#line 93
    tokens[c].num_toks = (unsigned char )((int )tokens[c].num_toks + 1);
#line 89
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static unsigned char buf[64]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static size_t len  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static void pushchar(struct mdfour *hash___0 , unsigned char c ) 
{ 
  size_t tmp ;

  {
#line 104
  if ((int )c == 0) {
#line 105
    if (len > 0UL) {
      {
#line 106
      hash_buffer(hash___0, (void const   *)((char *)(buf)), len);
#line 107
      len = (size_t )0;
      }
    }
    {
#line 109
    hash_buffer(hash___0, (void const   *)((void *)0), (size_t )0);
    }
#line 110
    return;
  }
#line 113
  tmp = len;
#line 113
  len ++;
#line 113
  buf[tmp] = c;
#line 114
  if (len == 64UL) {
    {
#line 115
    hash_buffer(hash___0, (void const   *)((char *)(buf)), len);
#line 116
    len = (size_t )0;
    }
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
static void unify(struct mdfour *hash___0 , unsigned char *p , size_t size ) 
{ 
  size_t ofs ;
  unsigned char q ;
  int i ;
  unsigned short const   **tmp ;
  unsigned char *s ;
  int len___0 ;
  size_t tmp___0 ;
  int j ;
  int tmp___1 ;

  {
  {
#line 128
  build_table();
#line 130
  ofs = (size_t )0;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (ofs < size)) {
#line 130
      goto while_break;
    }
#line 131
    if ((int )*(p + ofs) == 35) {
#line 132
      if (size - ofs > 2UL) {
#line 132
        if ((int )*(p + (ofs + 1UL)) == 32) {
          {
#line 132
          tmp = __ctype_b_loc();
          }
#line 132
          if ((int const   )*(*tmp + (int )*(p + (ofs + 2UL))) & 2048) {
            {
#line 133
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 134
              ofs ++;
#line 133
              if (ofs < size) {
#line 133
                if (! ((int )*(p + ofs) != 10)) {
#line 133
                  goto while_break___0;
                }
              } else {
#line 133
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 136
            ofs ++;
          } else {
#line 132
            goto _L___0;
          }
        } else {
#line 132
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 138
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 139
          pushchar(hash___0, *(p + ofs));
#line 140
          ofs ++;
          }
#line 138
          if (ofs < size) {
#line 138
            if (! ((int )*(p + ofs) != 10)) {
#line 138
              goto while_break___1;
            }
          } else {
#line 138
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 142
        pushchar(hash___0, (unsigned char )'\n');
#line 143
        ofs ++;
        }
      }
#line 145
      goto __Cont;
    }
#line 148
    if ((int )tokens[*(p + ofs)].type & 1) {
      {
#line 149
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 150
        pushchar(hash___0, *(p + ofs));
#line 151
        ofs ++;
        }
#line 149
        if (ofs < size) {
#line 149
          if (! ((int )tokens[*(p + ofs)].type & 17)) {
#line 149
            goto while_break___2;
          }
        } else {
#line 149
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 153
      pushchar(hash___0, (unsigned char )'\n');
      }
#line 154
      goto __Cont;
    }
#line 157
    if ((int )tokens[*(p + ofs)].type & 16) {
      {
#line 158
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 159
        pushchar(hash___0, *(p + ofs));
#line 160
        ofs ++;
        }
#line 158
        if (ofs < size) {
#line 158
          if (! ((int )tokens[*(p + ofs)].type & 16)) {
#line 158
            if (! ((int )*(p + ofs) == 46)) {
#line 158
              goto while_break___3;
            }
          }
        } else {
#line 158
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 163
      if (ofs < size) {
#line 163
        if ((int )*(p + ofs) == 120) {
#line 163
          goto _L___1;
        } else
#line 163
        if ((int )*(p + ofs) == 88) {
          _L___1: /* CIL Label */ 
          {
#line 164
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 165
            pushchar(hash___0, *(p + ofs));
#line 166
            ofs ++;
            }
#line 164
            if (ofs < size) {
#line 164
              if (! ((int )tokens[*(p + ofs)].type & 32)) {
#line 164
                goto while_break___4;
              }
            } else {
#line 164
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
#line 169
      if (ofs < size) {
#line 169
        if ((int )*(p + ofs) == 69) {
#line 169
          goto _L___2;
        } else
#line 169
        if ((int )*(p + ofs) == 101) {
          _L___2: /* CIL Label */ 
          {
#line 170
          pushchar(hash___0, *(p + ofs));
#line 171
          ofs ++;
          }
          {
#line 172
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 172
            if (ofs < size) {
#line 172
              if (! ((int )tokens[*(p + ofs)].type & 144)) {
#line 172
                goto while_break___5;
              }
            } else {
#line 172
              goto while_break___5;
            }
            {
#line 173
            pushchar(hash___0, *(p + ofs));
#line 174
            ofs ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
      {
#line 177
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 177
        if (ofs < size) {
#line 177
          if (! ((int )tokens[*(p + ofs)].type & 64)) {
#line 177
            goto while_break___6;
          }
        } else {
#line 177
          goto while_break___6;
        }
        {
#line 178
        pushchar(hash___0, *(p + ofs));
#line 179
        ofs ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 181
      pushchar(hash___0, (unsigned char )'\n');
      }
#line 182
      goto __Cont;
    }
#line 185
    if ((int )tokens[*(p + ofs)].type & 2) {
      {
#line 186
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 187
        ofs ++;
#line 186
        if (ofs < size) {
#line 186
          if (! ((int )tokens[*(p + ofs)].type & 2)) {
#line 186
            goto while_break___7;
          }
        } else {
#line 186
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 189
      goto __Cont;
    }
#line 192
    if ((int )tokens[*(p + ofs)].type & 8) {
      {
#line 193
      q = *(p + ofs);
#line 194
      pushchar(hash___0, *(p + ofs));
      }
      {
#line 195
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 196
        ofs ++;
        {
#line 197
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 197
          if (ofs < size - 1UL) {
#line 197
            if (! ((int )*(p + ofs) == 92)) {
#line 197
              goto while_break___9;
            }
          } else {
#line 197
            goto while_break___9;
          }
          {
#line 198
          pushchar(hash___0, *(p + ofs));
#line 199
          pushchar(hash___0, *(p + (ofs + 1UL)));
#line 200
          ofs += 2UL;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 202
        pushchar(hash___0, *(p + ofs));
        }
#line 195
        if (ofs < size) {
#line 195
          if (! ((int )*(p + ofs) != (int )q)) {
#line 195
            goto while_break___8;
          }
        } else {
#line 195
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 204
      pushchar(hash___0, (unsigned char )'\n');
#line 205
      ofs ++;
      }
#line 206
      goto __Cont;
    }
#line 209
    if ((int )tokens[*(p + ofs)].type & 4) {
#line 210
      q = *(p + ofs);
#line 211
      i = 0;
      {
#line 211
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 211
        if (! (i < (int )tokens[q].num_toks)) {
#line 211
          goto while_break___10;
        }
        {
#line 212
        s = (unsigned char *)tokens[q].toks[i];
#line 213
        tmp___0 = strlen((char const   *)((char *)s));
#line 213
        len___0 = (int )tmp___0;
        }
#line 214
        if (size >= ofs + (size_t )len___0) {
          {
#line 214
          tmp___1 = memcmp((void const   *)(p + ofs), (void const   *)s, (size_t )len___0);
          }
#line 214
          if (tmp___1 == 0) {
#line 216
            j = 0;
            {
#line 216
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 216
              if (! *(s + j)) {
#line 216
                goto while_break___11;
              }
              {
#line 217
              pushchar(hash___0, *(s + j));
#line 218
              ofs ++;
#line 216
              j ++;
              }
            }
            while_break___11: /* CIL Label */ ;
            }
            {
#line 220
            pushchar(hash___0, (unsigned char )'\n');
            }
#line 221
            goto while_break___10;
          }
        }
#line 211
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 224
      if (i < (int )tokens[q].num_toks) {
#line 225
        goto __Cont;
      }
    }
    {
#line 229
    pushchar(hash___0, *(p + ofs));
#line 230
    pushchar(hash___0, (unsigned char )'\n');
#line 231
    ofs ++;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  pushchar(hash___0, (unsigned char)0);
  }
#line 234
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/unify.c"
int unify_hash(struct mdfour *hash___0 , char const   *fname ) 
{ 
  char *data ;
  size_t size ;
  _Bool tmp ;

  {
  {
#line 246
  tmp = read_file(fname, (size_t )0, & data, & size);
  }
#line 246
  if (! tmp) {
    {
#line 247
    stats_update((enum stats )5);
    }
#line 248
    return (-1);
  }
  {
#line 250
  unify(hash___0, (unsigned char *)data, size);
#line 251
  free((void *)data);
  }
#line 252
  return (0);
}
}
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.h"
_Bool hash_command_output(struct mdfour *hash___0 , char const   *command , char const   *compiler ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
unsigned int hash_from_string(void *str ) 
{ 
  size_t tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 26
  tmp = strlen((char const   *)str);
#line 26
  tmp___0 = murmurhashneutral2((void const   *)str, (int )tmp, 0U);
  }
#line 26
  return (tmp___0);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
unsigned int hash_from_int(int i ) 
{ 
  unsigned int tmp ;

  {
  {
#line 32
  tmp = murmurhashneutral2((void const   *)(& i), (int )sizeof(int ), 0U);
  }
#line 32
  return (tmp);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
int strings_equal(void *str1 , void *str2 ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = strcmp((char const   *)str1, (char const   *)str2);
  }
#line 38
  return (tmp == 0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
int file_hashes_equal(struct file_hash *fh1 , struct file_hash *fh2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 44
  tmp = memcmp((void const   *)(fh1->hash), (void const   *)(fh2->hash), (size_t )16);
  }
#line 44
  if (tmp == 0) {
#line 44
    if (fh1->size == fh2->size) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return (tmp___0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
int hash_source_code_string(struct mdfour *hash___0 , char const   *str , size_t len___0 ,
                            char const   *path ) 
{ 
  char const   *p ;
  char const   *end ;
  char hashbuf[64] ;
  size_t hashbuflen ;
  int result ;
  _Bool seen_backslash ;
  time_t t ;
  time_t tmp ;
  struct tm *now ;
  struct tm *tmp___0 ;

  {
#line 69
  hashbuflen = (size_t )0;
#line 70
  result = 0;
#line 74
  p = str;
#line 75
  end = str + len___0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if ((unsigned long )p >= (unsigned long )end) {
#line 78
      goto end;
    }
    {
#line 82
    if ((int const   )*p == 47) {
#line 82
      goto case_47;
    }
#line 116
    if ((int const   )*p == 34) {
#line 116
      goto case_34;
    }
#line 140
    if ((int const   )*p == 95) {
#line 140
      goto case_95;
    }
#line 163
    goto switch_default___0;
    case_47: /* CIL Label */ 
#line 83
    if ((unsigned long )(p + 1) == (unsigned long )end) {
#line 84
      goto switch_break;
    }
    {
#line 87
    if ((int const   )*(p + 1) == 42) {
#line 87
      goto case_42;
    }
#line 103
    if ((int const   )*(p + 1) == 47) {
#line 103
      goto case_47___0;
    }
#line 110
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      hashbuf[hashbuflen] = (char )' ';
#line 88
      hashbuflen ++;
#line 88
      if (hashbuflen == sizeof(hashbuf)) {
        {
#line 88
        hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 88
        hashbuflen = (size_t )0;
        }
      }
#line 88
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 89
    p += 2;
    {
#line 90
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 90
      if ((unsigned long )(p + 1) < (unsigned long )end) {
#line 90
        if (! ((int const   )*p != 42)) {
#line 90
          if (! ((int const   )*(p + 1) != 47)) {
#line 90
            goto while_break___1;
          }
        }
      } else {
#line 90
        goto while_break___1;
      }
#line 91
      if ((int const   )*p == 10) {
        {
#line 93
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 93
          hashbuf[hashbuflen] = (char )'\n';
#line 93
          hashbuflen ++;
#line 93
          if (hashbuflen == sizeof(hashbuf)) {
            {
#line 93
            hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 93
            hashbuflen = (size_t )0;
            }
          }
#line 93
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 95
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 97
    if ((unsigned long )(p + 1) == (unsigned long )end) {
#line 98
      goto end;
    }
#line 100
    p += 2;
#line 101
    goto while_continue;
    case_47___0: /* CIL Label */ 
#line 104
    p += 2;
    {
#line 105
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 105
      if ((unsigned long )p < (unsigned long )end) {
#line 105
        if (! ((int const   )*p != 10)) {
#line 105
          if (! ((int const   )*(p - 1) == 92)) {
#line 105
            goto while_break___3;
          }
        }
      } else {
#line 105
        goto while_break___3;
      }
#line 106
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 108
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 111
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 113
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 117
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 117
      hashbuf[hashbuflen] = (char )*p;
#line 117
      hashbuflen ++;
#line 117
      if (hashbuflen == sizeof(hashbuf)) {
        {
#line 117
        hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 117
        hashbuflen = (size_t )0;
        }
      }
#line 117
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 118
    p ++;
#line 119
    seen_backslash = (_Bool)0;
    {
#line 120
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )p < (unsigned long )end)) {
#line 120
        goto while_break___5;
      }
#line 121
      if (seen_backslash) {
#line 122
        seen_backslash = (_Bool)0;
      } else
#line 123
      if ((int const   )*p == 34) {
        {
#line 125
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 125
          hashbuf[hashbuflen] = (char )*p;
#line 125
          hashbuflen ++;
#line 125
          if (hashbuflen == sizeof(hashbuf)) {
            {
#line 125
            hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 125
            hashbuflen = (size_t )0;
            }
          }
#line 125
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 126
        p ++;
#line 127
        goto while_break___5;
      } else
#line 128
      if ((int const   )*p == 92) {
#line 129
        seen_backslash = (_Bool)1;
      }
      {
#line 131
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 131
        hashbuf[hashbuflen] = (char )*p;
#line 131
        hashbuflen ++;
#line 131
        if (hashbuflen == sizeof(hashbuf)) {
          {
#line 131
          hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 131
          hashbuflen = (size_t )0;
          }
        }
#line 131
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 132
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 134
    if ((unsigned long )p == (unsigned long )end) {
#line 135
      goto end;
    }
#line 137
    goto switch_break;
    case_95: /* CIL Label */ 
#line 141
    if ((unsigned long )(p + 7) < (unsigned long )end) {
#line 141
      if ((int const   )*(p + 1) == 95) {
#line 141
        if ((int const   )*(p + 5) == 69) {
#line 141
          if ((int const   )*(p + 6) == 95) {
#line 141
            if ((int const   )*(p + 7) == 95) {
#line 144
              if ((int const   )*(p + 2) == 68) {
#line 144
                if ((int const   )*(p + 3) == 65) {
#line 144
                  if ((int const   )*(p + 4) == 84) {
#line 146
                    result |= 2;
                  } else {
#line 144
                    goto _L___0;
                  }
                } else {
#line 144
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 147
              if ((int const   )*(p + 2) == 84) {
#line 147
                if ((int const   )*(p + 3) == 73) {
#line 147
                  if ((int const   )*(p + 4) == 77) {
#line 149
                    result |= 4;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 161
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 167
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 167
      hashbuf[hashbuflen] = (char )*p;
#line 167
      hashbuflen ++;
#line 167
      if (hashbuflen == sizeof(hashbuf)) {
        {
#line 167
        hash_buffer(hash___0, (void const   *)(hashbuf), sizeof(hashbuf));
#line 167
        hashbuflen = (size_t )0;
        }
      }
#line 167
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 168
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  end: 
  {
#line 172
  hash_buffer(hash___0, (void const   *)(hashbuf), hashbuflen);
  }
#line 174
  if (sloppiness & 4U) {
#line 175
    return (0);
  }
#line 177
  if (result & 2) {
    {
#line 182
    tmp = time((time_t *)((void *)0));
#line 182
    t = tmp;
#line 183
    tmp___0 = localtime((time_t const   *)(& t));
#line 183
    now = tmp___0;
#line 184
    cc_log("Found __DATE__ in %s", path);
#line 185
    hash_delimiter(hash___0, "date");
#line 186
    hash_buffer(hash___0, (void const   *)(& now->tm_year), sizeof(now->tm_year));
#line 187
    hash_buffer(hash___0, (void const   *)(& now->tm_mon), sizeof(now->tm_mon));
#line 188
    hash_buffer(hash___0, (void const   *)(& now->tm_mday), sizeof(now->tm_mday));
    }
  }
#line 190
  if (result & 4) {
    {
#line 199
    cc_log("Found __TIME__ in %s", path);
    }
  }
#line 202
  return (result);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
int hash_source_code_file(struct mdfour *hash___0 , char const   *path ) 
{ 
  char *data ;
  size_t size ;
  int result ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 216
  tmp___1 = is_precompiled_header(path);
  }
#line 216
  if (tmp___1) {
    {
#line 217
    tmp = hash_file(hash___0, path);
    }
#line 217
    if (tmp) {
#line 218
      return (0);
    } else {
#line 220
      return (1);
    }
  } else {
    {
#line 223
    tmp___0 = read_file(path, (size_t )0, & data, & size);
    }
#line 223
    if (! tmp___0) {
#line 224
      return (1);
    }
    {
#line 226
    result = hash_source_code_string(hash___0, (char const   *)data, size, path);
#line 227
    free((void *)data);
    }
#line 228
    return (result);
  }
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
_Bool hash_command_output(struct mdfour *hash___0 , char const   *command , char const   *compiler ) 
{ 
  pid_t pid ;
  int pipefd[2] ;
  struct args *args ;
  struct args *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int status ;
  _Bool ok ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  union __anonunion_57___0 __constr_expr_3 ;
  union __anonunion_58___0 __constr_expr_4 ;
  union __anonunion_59___0 __constr_expr_5 ;

  {
  {
#line 239
  tmp = args_init_from_string(command);
#line 239
  args = tmp;
#line 241
  i = 0;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (i < args->argc)) {
#line 241
      goto while_break;
    }
    {
#line 242
    tmp___0 = strcmp((char const   *)*(args->argv + i), "%compiler%");
    }
#line 242
    if (tmp___0 == 0) {
      {
#line 243
      args_set(args, i, compiler);
      }
    }
#line 241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  cc_log_argv("Executing compiler check command ", args->argv);
#line 248
  tmp___1 = pipe((int *)(pipefd));
  }
#line 248
  if (tmp___1 == -1) {
    {
#line 249
    fatal("pipe failed");
    }
  }
  {
#line 251
  pid = fork();
  }
#line 252
  if (pid == -1) {
    {
#line 253
    fatal("fork failed");
    }
  }
#line 256
  if (pid == 0) {
    {
#line 258
    close(pipefd[0]);
#line 259
    close(0);
#line 260
    dup2(pipefd[1], 1);
#line 261
    dup2(pipefd[1], 2);
#line 262
    tmp___2 = execvp((char const   *)*(args->argv + 0), (char * const  *)args->argv);
#line 262
    _exit(tmp___2);
    }
#line 263
    return ((_Bool)0);
  } else {
    {
#line 268
    args_free(args);
#line 269
    close(pipefd[1]);
#line 270
    ok = hash_fd(hash___0, pipefd[0]);
    }
#line 271
    if (! ok) {
      {
#line 272
      tmp___3 = __errno_location();
#line 272
      tmp___4 = strerror(*tmp___3);
#line 272
      cc_log("Error hashing compiler check command output: %s", tmp___4);
#line 273
      stats_update((enum stats )26);
      }
    }
    {
#line 275
    close(pipefd[0]);
#line 276
    tmp___5 = waitpid(pid, & status, 0);
    }
#line 276
    if (tmp___5 != pid) {
      {
#line 277
      cc_log("waitpid failed");
      }
#line 278
      return ((_Bool)0);
    }
#line 280
    __constr_expr_4.__in = status;
#line 280
    if ((__constr_expr_4.__i & 127) == 0) {
#line 280
      __constr_expr_5.__in = status;
#line 280
      if ((__constr_expr_5.__i & 65280) >> 8 != 0) {
        {
#line 281
        __constr_expr_3.__in = status;
#line 281
        cc_log("Compiler check command returned %d", (__constr_expr_3.__i & 65280) >> 8);
#line 282
        stats_update((enum stats )26);
        }
#line 283
        return ((_Bool)0);
      }
    } else {
      {
#line 281
      __constr_expr_3.__in = status;
#line 281
      cc_log("Compiler check command returned %d", (__constr_expr_3.__i & 65280) >> 8);
#line 282
      stats_update((enum stats )26);
      }
#line 283
      return ((_Bool)0);
    }
#line 285
    return (ok);
  }
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/hashutil.c"
_Bool hash_multicommand_output(struct mdfour *hash___0 , char const   *commands ,
                               char const   *compiler ) 
{ 
  char *command_string ;
  char *command ;
  char *p ;
  char *saveptr ;
  _Bool ok ;
  _Bool tmp ;

  {
  {
#line 293
  saveptr = (char *)((void *)0);
#line 294
  ok = (_Bool)1;
#line 296
  command_string = x_strdup(commands);
#line 297
  p = command_string;
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    command = strtok_r((char */* __restrict  */)p, (char const   */* __restrict  */)";",
                       (char **/* __restrict  */)(& saveptr));
    }
#line 298
    if (! command) {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp = hash_command_output(hash___0, (char const   *)command, compiler);
    }
#line 299
    if (! tmp) {
#line 300
      ok = (_Bool)0;
    }
#line 302
    p = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  free((void *)command_string);
  }
#line 305
  return (ok);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/counters.c"
struct counters *counters_init(size_t initial_size ) 
{ 
  struct counters *c ;
  void *tmp ;

  {
  {
#line 30
  tmp = x_malloc(sizeof(*c));
#line 30
  c = (struct counters *)tmp;
#line 31
  c->data = (unsigned int *)((void *)0);
#line 32
  c->size = (size_t )0;
#line 33
  c->allocated = (size_t )0;
#line 34
  counters_resize(c, initial_size);
  }
#line 35
  return (c);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/counters.c"
void counters_free(struct counters *c ) 
{ 


  {
  {
#line 44
  free((void *)c->data);
#line 45
  free((void *)c);
  }
#line 46
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ccache-3.1.9/counters.c"
void counters_resize(struct counters *c , size_t new_size ) 
{ 
  size_t i ;
  _Bool realloc___0 ;
  void *tmp ;

  {
#line 54
  if (new_size > c->size) {
#line 56
    realloc___0 = (_Bool)0;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! (c->allocated < new_size)) {
#line 58
        goto while_break;
      }
#line 59
      c->allocated += 32UL + c->allocated;
#line 60
      realloc___0 = (_Bool)1;
    }
    while_break: /* CIL Label */ ;
    }
#line 62
    if (realloc___0) {
      {
#line 63
      tmp = x_realloc((void *)c->data, c->allocated * sizeof(*(c->data + 0)));
#line 63
      c->data = (unsigned int *)tmp;
      }
    }
#line 65
    i = c->size;
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      if (! (i < new_size)) {
#line 65
        goto while_break___0;
      }
#line 66
      *(c->data + i) = 0U;
#line 65
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 70
  c->size = new_size;
#line 71
  return;
}
}
