/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_16 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_16 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/usage.h"
void usage(void) ;
#line 32
void License(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/usage.c"
void usage(void) 
{ 


  {
  {
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"------------------------------------------------\n");
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spinner 1.2.4 by Joe Laffey, LAFFEY Computer Imaging.\n");
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Visit http://www.laffeycomputer.com/ for updates.\n");
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This software comes with ABSOLUTELY NO WARRANTY. spinner -L for license.\n");
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:  spinner[-IntTuvl<path>[f<path>|F][p<prio>|P]] [delay]\n");
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -f   <path> Set pid file path (default is ~/.spinner.pid)\n");
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -F   Do *not* create a pid file\n");
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -I   Do *not* use inverse video for spinner\n");
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -l   <path> Set log file path (for debugging). Off by default.\n");
#line 46
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -L   Display the license\n");
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -n   Send only null characters. (No visible output.)\n");
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -p   <priority> Specify process priority to use (default is %d)\n",
          10);
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -P   Do *not* change process priority (default is to make nice)\n");
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -r   Reset term on quit (Use if you get left in inverse a lot.)\n");
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -R   Reset the term and Quit immediately. (nothing else)\n");
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -t   <tty path> Specify path of TTY to which to write\n");
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -T   Ignore incompatible TERM environment var setting\n");
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -u   Delay is in microseconds instead of seconds\n");
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        -v   Verbose mode (lots of output)\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Returns: 0 on success, non-zero on failure.\n");
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Launches into the background on success.\n");
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use: kill `cat <pidfile>` to stop.\n");
#line 62
  exit(64);
  }
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/usage.c"
void License(void) 
{ 


  {
  {
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"------------------------------------------------\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spinner 1.2.4 by Joe Laffey, LAFFEY Computer Imaging.\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Visit http:// www.laffeycomputer.com/ for updates.\n");
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This software is copyright 2002, 2003 by Joe Laffey.\n\n");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s comes with ABSOLUTELY NO WARRANTY; for details see the COPYING file\nthat accompained this distribution. ",
          "spinner");
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This is free software, and you are welcome\nto redistribute it");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" under the terms of GNU PUBLIC LICENSE.\n");
#line 81
  exit(64);
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 86 "/usr/include/termios.h"
extern int tcdrain(int __fd ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static void DoInterrupt(void) ;
#line 62
static int Daemonize(int verbose , char *logFileName , int logFileSet , FILE *logfile ,
                     int doPidFile , char *pidFileName ) ;
#line 63
static void WritePidFile(int verbose , pid_t pid , FILE *logfile , char *pidFileName ) ;
#line 64
static void InterruptBlockedOpen(void) ;
#line 65
__inline static int OpenTTY(int logFileSet , FILE *logfile , char *whichTTY , char *ttyName ) ;
#line 66
static void ResetTerm(int verbose , int logFileSet , FILE *logfile , char *whichTTY ,
                      char *ttyName ) ;
#line 67
static int SpinnerLoop(int verbose , int inverse , int time , int microTime , int logFileSet ,
                       FILE *logfile , char *whichTTY , char *ttyName , char *failMsg ) ;
#line 68
static int NullLoop(int verbose , int time , int microTime , int logFileSet , FILE *logfile ,
                    char *whichTTY , char *ttyName , char *failMsg ) ;
#line 69
static int GetHomePath(int verbose , FILE *logfile , char *fullHomePath ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int gInterrupted  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static sigjmp_buf gAlarmJump  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int volatile   gCanJump  =    (sig_atomic_t volatile   )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static void DoInterrupt(void) 
{ 


  {
#line 95
  gInterrupted ++;
#line 97
  if (gInterrupted > 1) {
    {
#line 101
    _exit(75);
    }
  }
#line 104
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static void InterruptBlockedOpen(void) 
{ 


  {
#line 111
  if (gCanJump == (int volatile   )0) {
#line 112
    return;
  }
  {
#line 115
  gCanJump = (int volatile   )0;
#line 117
  siglongjmp((struct __jmp_buf_tag *)(gAlarmJump), 1);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int Daemonize(int verbose , char *logFileName , int logFileSet , FILE *logfile ,
                     int doPidFile , char *pidFileName ) 
{ 
  pid_t pid ;

  {
  {
#line 129
  pid = fork();
  }
#line 129
  if (pid < 0) {
#line 130
    return (-1);
  } else
#line 131
  if (pid != 0) {
#line 133
    if (doPidFile) {
      {
#line 136
      WritePidFile(verbose, pid, logfile, pidFileName);
      }
    }
#line 141
    if (verbose) {
#line 143
      if (logFileSet) {
        {
#line 145
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Parent process terminating.\n",
                "spinner");
#line 146
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Child process ( pid %d ) continuing...\n",
                "spinner", pid);
#line 147
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Further output to %s\n",
                "spinner", logFileName);
        }
      }
    }
    {
#line 150
    exit(0);
    }
  }
  {
#line 154
  setsid();
#line 156
  chdir("/");
#line 158
  umask((__mode_t )0);
#line 164
  close(0);
#line 165
  close(1);
#line 166
  close(2);
  }
#line 168
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static void WritePidFile(int verbose , pid_t pid , FILE *logfile , char *pidFileName ) 
{ 
  FILE *pidFile ;
  int pidFileDes ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 182
  pidFileDes = open((char const   *)pidFileName, 577, 384);
  }
#line 182
  if (0 > pidFileDes) {
    {
#line 184
    tmp = __errno_location();
#line 184
    tmp___0 = strerror(*tmp);
#line 184
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: Unable to open pid file %s for writing.\n%s: %s\n%s: WARNING: No pid file will be written.\n",
            "spinner", pidFileName, "spinner", tmp___0, "spinner");
    }
#line 185
    return;
  }
  {
#line 189
  pidFile = fdopen(pidFileDes, "w");
  }
#line 190
  if ((unsigned long )pidFile == (unsigned long )((void *)0)) {
    {
#line 192
    tmp___1 = __errno_location();
#line 192
    tmp___2 = strerror(*tmp___1);
#line 192
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: Unable to fdopen pid file %s for writing.\n%s: %s\n",
            "spinner", pidFileName, "spinner", tmp___2);
#line 193
    exit(1);
    }
  } else {
#line 197
    if (verbose) {
      {
#line 198
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Writing daemon\'s pid to pid file %s.\n",
              "spinner", pidFileName);
      }
    }
    {
#line 201
    fprintf((FILE */* __restrict  */)pidFile, (char const   */* __restrict  */)"%d\n",
            pid);
#line 203
    fclose(pidFile);
    }
  }
#line 206
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
__inline static int OpenTTY(int logFileSet , FILE *logfile , char *whichTTY , char *ttyName ) 
{ 
  int ttyFileDes ;
  int *tmp ;
  char *tmp___0 ;
  __sighandler_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __sighandler_t tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 218
  tmp___1 = signal(14, (void (*)(int  ))((void *)(& InterruptBlockedOpen)));
  }
#line 218
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___1) {
#line 220
    if (logFileSet) {
      {
#line 221
      tmp = __errno_location();
#line 221
      tmp___0 = strerror(*tmp);
#line 221
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGALRM signal handler to interrupt blocks to open()!\n%s: %s\n",
              "spinner", "spinner", tmp___0);
      }
    }
    {
#line 222
    exit(1);
    }
  }
  {
#line 232
  tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(gAlarmJump), 1);
  }
#line 232
  if (0 != tmp___2) {
#line 237
    if (logFileSet) {
      {
#line 238
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: The attempt to open the TTY %s\n%s: for writing timed out after %d seconds.\n%s: Perhaps that is not an active TTY...\n",
              "spinner", whichTTY, "spinner", 8, "spinner");
      }
    }
    {
#line 239
    exit(1);
    }
  }
  {
#line 243
  gCanJump = (int volatile   )1;
#line 246
  alarm(8U);
#line 249
  ttyFileDes = open((char const   *)whichTTY, 1);
  }
#line 250
  if (ttyFileDes < 0) {
#line 252
    if (logFileSet) {
      {
#line 253
      tmp___3 = __errno_location();
#line 253
      tmp___4 = strerror(*tmp___3);
#line 253
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to open %s for writing!\n%s: %s\n",
              "spinner", whichTTY, "spinner", tmp___4);
      }
    }
    {
#line 254
    exit(1);
    }
  }
  {
#line 258
  alarm(0U);
#line 261
  tmp___7 = signal(14, (void (*)(int  ))0);
  }
#line 261
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___7) {
#line 263
    if (logFileSet) {
      {
#line 264
      tmp___5 = __errno_location();
#line 264
      tmp___6 = strerror(*tmp___5);
#line 264
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to set SIGALRM signal handler to default!\n%s: %s\n",
              "spinner", "spinner", tmp___6);
      }
    }
    {
#line 265
    exit(1);
    }
  }
  {
#line 271
  tmp___8 = isatty(ttyFileDes);
  }
#line 271
  if (! tmp___8) {
#line 273
    if (logFileSet) {
      {
#line 274
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: %s is not an active terminal!\n",
              "spinner", whichTTY);
      }
    }
    {
#line 275
    exit(1);
    }
  }
  {
#line 279
  tmp___9 = ttyname(ttyFileDes);
#line 279
  strncpy((char */* __restrict  */)ttyName, (char const   */* __restrict  */)tmp___9,
          (size_t )256);
#line 280
  *(ttyName + 256) = (char )'\000';
  }
#line 282
  return (ttyFileDes);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static void ResetTerm(int verbose , int logFileSet , FILE *logfile , char *whichTTY ,
                      char *ttyName ) 
{ 
  int ttyDes ;
  int tmp ;

  {
#line 295
  if (verbose) {
#line 297
    if (logFileSet) {
      {
#line 298
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Attempting to reset terminal...\n",
              "spinner");
      }
    }
    {
#line 299
    sleep(1U);
    }
  }
  {
#line 303
  ttyDes = OpenTTY(logFileSet, logfile, whichTTY, ttyName);
#line 305
  write(ttyDes, (void const   *)"\033c", sizeof("\033c"));
#line 307
  tmp = close(ttyDes);
  }
#line 307
  if (0 != tmp) {
#line 309
    if (logFileSet) {
      {
#line 310
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to close TTY %s!\n",
              "spinner", ttyName);
      }
    }
    {
#line 311
    _exit(1);
    }
  }
#line 314
  if (verbose) {
#line 316
    if (logFileSet) {
      {
#line 317
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Terminal reset code written.\n",
              "spinner");
      }
    }
  }
#line 320
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int GetHomePath(int verbose , FILE *logfile , char *fullHomePath ) 
{ 
  char *homePath ;
  struct passwd *pwdPtr ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  __uid_t tmp___5 ;

  {
  {
#line 336
  tmp___5 = getuid();
#line 336
  pwdPtr = getpwuid(tmp___5);
  }
#line 336
  if ((unsigned long )((void *)0) == (unsigned long )pwdPtr) {
    {
#line 338
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: Unable to determine HOME directory.\n%s: WARNING: No pid file will be written.\n",
            "spinner", "spinner");
    }
  } else
#line 343
  if ((unsigned long )pwdPtr->pw_dir == (unsigned long )((void *)0)) {
    {
#line 345
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Home dir entry (pw_dir) from passwd database was null. Aborting.\n",
            "spinner");
    }
#line 346
    return (1);
  } else {
    {
#line 352
    tmp___2 = strlen((char const   *)pwdPtr->pw_dir);
    }
#line 352
    if (tmp___2 + 1UL > 257UL) {
      {
#line 352
      tmp___0 = strlen((char const   *)pwdPtr->pw_dir);
#line 352
      tmp___1 = tmp___0 + 1UL;
      }
    } else {
#line 352
      tmp___1 = (size_t )257;
    }
    {
#line 352
    tmp___3 = malloc(tmp___1);
#line 352
    homePath = (char *)tmp___3;
    }
#line 353
    if ((unsigned long )homePath == (unsigned long )((void *)0)) {
      {
#line 355
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to allocate memory for home directory string!\n",
              "spinner");
      }
#line 356
      return (1);
    }
    {
#line 360
    strncpy((char */* __restrict  */)homePath, (char const   */* __restrict  */)pwdPtr->pw_dir,
            (size_t )256);
#line 361
    *(homePath + 256) = (char )'\000';
    }
#line 363
    if (verbose) {
      {
#line 364
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Retrieved HOME directory from passwd database.\n",
              "spinner");
      }
    }
    {
#line 367
    strncpy((char */* __restrict  */)fullHomePath, (char const   */* __restrict  */)homePath,
            (size_t )256);
#line 370
    free((void *)homePath);
#line 373
    tmp___4 = strlen((char const   *)fullHomePath);
#line 373
    len = (int )tmp___4;
    }
#line 375
    if ((int )*(fullHomePath + len) != 47) {
#line 377
      if (len < 256) {
#line 380
        *(fullHomePath + len) = (char )'/';
#line 381
        *(fullHomePath + (len + 1)) = (char )'\000';
      } else {
        {
#line 385
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Length of retrieved home directory is too long!!\n",
                "spinner");
        }
#line 386
        return (1);
      }
    }
  }
#line 397
  return (0);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int SpinnerLoop(int verbose , int inverse , int time , int microTime , int logFileSet ,
                       FILE *logfile , char *whichTTY , char *ttyName , char *failMsg ) 
{ 
  int ttyDes ;
  char chars[8] ;
  int numChars ;
  char cache[sizeof(chars)][17] ;
  int strLen ;
  unsigned int i ;
  sigset_t sigFilledSet ;
  sigset_t sigSavedSet ;
  int exitCode ;
  char const   *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __sighandler_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __sighandler_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  __sighandler_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  ssize_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 411
  chars[0] = (char )'-';
#line 411
  chars[1] = (char )'\\';
#line 411
  chars[2] = (char )'|';
#line 411
  chars[3] = (char )'/';
#line 411
  chars[4] = (char )'-';
#line 411
  chars[5] = (char )'\\';
#line 411
  chars[6] = (char )'|';
#line 411
  chars[7] = (char )'/';
#line 414
  numChars = (int )sizeof(chars);
#line 420
  strLen = 0;
#line 423
  i = 0U;
#line 429
  exitCode = 0;
#line 432
  if (verbose) {
#line 434
    if (logFileSet) {
      {
#line 435
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Generating display strings for spinner.\n",
              "spinner");
      }
    }
  }
#line 440
  i = 0U;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i < (unsigned int )numChars)) {
#line 440
      goto while_break;
    }
#line 445
    if (inverse) {
#line 445
      tmp = "\033[7m";
    } else {
#line 445
      tmp = "";
    }
    {
#line 445
    sprintf((char */* __restrict  */)(cache[i]), (char const   */* __restrict  */)"%s%s%s%c%s",
            "\0337", "\033[H", tmp, (int )chars[i], "\0338");
#line 440
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  tmp___0 = strlen((char const   *)(cache[0]));
#line 457
  strLen = (int )tmp___0;
  }
#line 459
  if (verbose) {
#line 461
    if (logFileSet) {
      {
#line 462
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Setting up signal handlers...\n",
              "spinner");
      }
    }
  }
  {
#line 466
  tmp___3 = signal(2, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 466
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___3) {
#line 468
    if (logFileSet) {
      {
#line 469
      tmp___1 = __errno_location();
#line 469
      tmp___2 = strerror(*tmp___1);
#line 469
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGINT signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___2);
      }
    }
    {
#line 470
    exit(1);
    }
  }
  {
#line 473
  tmp___6 = signal(15, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 473
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___6) {
#line 475
    if (logFileSet) {
      {
#line 476
      tmp___4 = __errno_location();
#line 476
      tmp___5 = strerror(*tmp___4);
#line 476
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGTERM signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___5);
      }
    }
    {
#line 477
    exit(1);
    }
  }
  {
#line 481
  tmp___9 = signal(1, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 481
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___9) {
#line 483
    if (logFileSet) {
      {
#line 484
      tmp___7 = __errno_location();
#line 484
      tmp___8 = strerror(*tmp___7);
#line 484
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGHUP signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___8);
      }
    }
    {
#line 485
    exit(1);
    }
  }
  {
#line 491
  tmp___10 = sigfillset(& sigFilledSet);
  }
#line 491
  if (0 != tmp___10) {
#line 493
    if (logFileSet) {
      {
#line 494
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to fill in signal mask!\n",
              "spinner");
      }
    }
    {
#line 495
    _exit(1);
    }
  }
#line 499
  if (verbose) {
#line 501
    if (logFileSet) {
      {
#line 502
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Commencing loop to display spinner...\n",
              "spinner");
      }
    }
  }
  {
#line 507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 507
    if (! (! gInterrupted)) {
#line 507
      goto while_break___0;
    }
#line 509
    if (i < ~ (1U << (8UL * sizeof(int ) - 1UL))) {
#line 510
      i ++;
    } else {
#line 512
      i = 0U;
    }
    {
#line 518
    ttyDes = OpenTTY(logFileSet, logfile, whichTTY, ttyName);
#line 522
    tmp___11 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigFilledSet),
                           (sigset_t */* __restrict  */)(& sigSavedSet));
    }
#line 522
    if (0 > tmp___11) {
#line 524
      if (logFileSet) {
        {
#line 525
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to set process signal mask!\n",
                "spinner");
        }
      }
      {
#line 526
      _exit(1);
      }
    }
    {
#line 531
    tmp___12 = isatty(ttyDes);
    }
#line 531
    if (! tmp___12) {
#line 533
      if (logFileSet) {
        {
#line 534
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: %s is no longer an active terminal!\n",
                "spinner", ttyName);
        }
      }
      {
#line 537
      _exit(1);
      }
    }
    {
#line 544
    tmp___13 = tcdrain(ttyDes);
    }
#line 544
    if (-1 == tmp___13) {
#line 546
      if (logFileSet) {
        {
#line 547
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to drain terminal output!\n",
                "spinner");
        }
      }
      {
#line 548
      _exit(1);
      }
    }
    {
#line 552
    tmp___17 = write(ttyDes, (void const   *)(cache[i % (unsigned int )numChars]),
                     (size_t )strLen);
    }
#line 552
    if (-1L == tmp___17) {
      {
#line 556
      tmp___16 = __errno_location();
      }
#line 556
      if (! (*tmp___16 == 11)) {
        {
#line 562
        tmp___14 = __errno_location();
#line 562
        tmp___15 = strerror(*tmp___14);
#line 562
        snprintf((char */* __restrict  */)failMsg, (size_t )256, (char const   */* __restrict  */)"%s: write failed!\n%s: %s\n",
                 "spinner", "spinner", tmp___15);
#line 563
        *(failMsg + 256) = (char )'\000';
#line 564
        gInterrupted = 1;
#line 565
        exitCode = 1;
        }
      }
    }
    {
#line 571
    tmp___18 = tcdrain(ttyDes);
    }
#line 571
    if (-1 == tmp___18) {
      {
#line 573
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to drain terminal output!\n",
              "spinner");
#line 574
      _exit(1);
      }
    }
    {
#line 579
    tmp___19 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigSavedSet),
                           (sigset_t */* __restrict  */)((void *)0));
    }
#line 579
    if (0 > tmp___19) {
#line 581
      if (logFileSet) {
        {
#line 582
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to set process signal mask!\n",
                "spinner");
        }
      }
      {
#line 583
      _exit(1);
      }
    }
    {
#line 586
    tmp___20 = close(ttyDes);
    }
#line 586
    if (0 != tmp___20) {
#line 588
      if (logFileSet) {
        {
#line 589
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to close TTY %s!\n",
                "spinner", ttyName);
        }
      }
      {
#line 590
      _exit(1);
      }
    }
#line 593
    if (microTime) {
      {
#line 594
      usleep((__useconds_t )time);
      }
    } else {
      {
#line 596
      sleep((unsigned int )time);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 602
  return (exitCode);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
static int NullLoop(int verbose , int time , int microTime , int logFileSet , FILE *logfile ,
                    char *whichTTY , char *ttyName , char *failMsg ) 
{ 
  char theNull[1] ;
  int exitCode ;
  int ttyDes ;
  int *tmp ;
  char *tmp___0 ;
  __sighandler_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  __sighandler_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __sighandler_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  ssize_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 611
  theNull[0] = (char )'\000';
#line 612
  exitCode = 0;
#line 617
  if (verbose) {
#line 619
    if (logFileSet) {
      {
#line 620
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Setting up signal handlers...\n",
              "spinner");
      }
    }
  }
  {
#line 624
  tmp___1 = signal(2, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 624
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___1) {
#line 626
    if (logFileSet) {
      {
#line 627
      tmp = __errno_location();
#line 627
      tmp___0 = strerror(*tmp);
#line 627
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGINT signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___0);
      }
    }
    {
#line 628
    exit(1);
    }
  }
  {
#line 631
  tmp___4 = signal(15, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 631
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___4) {
#line 633
    if (logFileSet) {
      {
#line 634
      tmp___2 = __errno_location();
#line 634
      tmp___3 = strerror(*tmp___2);
#line 634
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGTERM signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___3);
      }
    }
    {
#line 635
    exit(1);
    }
  }
  {
#line 639
  tmp___7 = signal(1, (void (*)(int  ))((void *)(& DoInterrupt)));
  }
#line 639
  if ((unsigned long )((void (*)(int  ))-1) == (unsigned long )tmp___7) {
#line 641
    if (logFileSet) {
      {
#line 642
      tmp___5 = __errno_location();
#line 642
      tmp___6 = strerror(*tmp___5);
#line 642
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to install SIGHUP signal handler!\n%s: %s\n",
              "spinner", "spinner", tmp___6);
      }
    }
    {
#line 643
    exit(1);
    }
  }
#line 646
  if (verbose) {
#line 648
    if (logFileSet) {
      {
#line 649
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Commencing loop to send nulls...\n",
              "spinner");
      }
    }
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (! gInterrupted)) {
#line 652
      goto while_break;
    }
    {
#line 659
    ttyDes = OpenTTY(logFileSet, logfile, whichTTY, ttyName);
#line 662
    tmp___8 = isatty(ttyDes);
    }
#line 662
    if (! tmp___8) {
#line 664
      if (logFileSet) {
        {
#line 665
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: %s is no longer an active terminal!\n",
                "spinner", ttyName);
        }
      }
      {
#line 668
      _exit(1);
      }
    }
    {
#line 674
    tmp___9 = tcdrain(ttyDes);
    }
#line 674
    if (-1 == tmp___9) {
#line 676
      if (logFileSet) {
        {
#line 677
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to drain terminal output!\n",
                "spinner");
        }
      }
      {
#line 679
      _exit(1);
      }
    }
    {
#line 682
    tmp___13 = write(ttyDes, (void const   *)(theNull), sizeof(theNull));
    }
#line 682
    if (-1L == tmp___13) {
      {
#line 686
      tmp___12 = __errno_location();
      }
#line 686
      if (! (*tmp___12 == 11)) {
        {
#line 692
        tmp___10 = __errno_location();
#line 692
        tmp___11 = strerror(*tmp___10);
#line 692
        snprintf((char */* __restrict  */)failMsg, (size_t )256, (char const   */* __restrict  */)"%s: write failed!\n%s: %s\n",
                 "spinner", "spinner", tmp___11);
#line 693
        *(failMsg + 256) = (char )'\000';
#line 694
        gInterrupted = 1;
#line 695
        exitCode = 1;
        }
      }
    }
    {
#line 702
    tmp___14 = tcdrain(ttyDes);
    }
#line 702
    if (-1 == tmp___14) {
#line 704
      if (logFileSet) {
        {
#line 705
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to drain terminal output!\n",
                "spinner");
        }
      }
      {
#line 706
      _exit(1);
      }
    }
    {
#line 709
    tmp___15 = close(ttyDes);
    }
#line 709
    if (0 != tmp___15) {
#line 711
      if (logFileSet) {
        {
#line 712
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to close TTY %s!\n",
                "spinner", ttyName);
        }
      }
      {
#line 713
      _exit(1);
      }
    }
#line 716
    if (microTime) {
      {
#line 717
      usleep((__useconds_t )time);
      }
    } else {
      {
#line 719
      sleep((unsigned int )time);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  return (exitCode);
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/spinner-1.2.4/spinner.c"
int main(int argc , char **argv ) 
{ 
  char ttyName[257] ;
  int sendNulls ;
  int time ;
  char whichTTY[257] ;
  int ch ;
  int microTime ;
  int inverse ;
  int useTTY ;
  int verbose ;
  int setPriority ;
  int priority ;
  int doPidFile ;
  char pidFileName[257] ;
  unsigned int tmp ;
  char logFileName[257] ;
  unsigned int tmp___0 ;
  char fullHomePath[257] ;
  unsigned int tmp___1 ;
  int pidFileSet ;
  int logFileSet ;
  char failMsg[257] ;
  unsigned int tmp___2 ;
  int exitCode ;
  int resetOnQuit ;
  int resetOnly ;
  int checkTermType ;
  char *termType ;
  FILE *logfile ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;
  __gid_t tmp___5 ;
  __gid_t tmp___6 ;
  __gid_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  __gid_t tmp___18 ;
  int tmp___19 ;
  __gid_t tmp___20 ;
  __gid_t tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;

  {
#line 738
  sendNulls = 0;
#line 751
  microTime = 0;
#line 754
  inverse = 1;
#line 757
  useTTY = 0;
#line 760
  verbose = 0;
#line 763
  setPriority = 1;
#line 766
  priority = 10;
#line 769
  doPidFile = 1;
#line 772
  pidFileName[0] = (char )'\000';
#line 772
  tmp = 1U;
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 772
    if (tmp >= 257U) {
#line 772
      goto while_break;
    }
#line 772
    pidFileName[tmp] = (char)0;
#line 772
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 775
  logFileName[0] = (char )'\000';
#line 775
  tmp___0 = 1U;
  {
#line 775
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 775
    if (tmp___0 >= 257U) {
#line 775
      goto while_break___0;
    }
#line 775
    logFileName[tmp___0] = (char)0;
#line 775
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 778
  fullHomePath[0] = (char )'\000';
#line 778
  tmp___1 = 1U;
  {
#line 778
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 778
    if (tmp___1 >= 257U) {
#line 778
      goto while_break___1;
    }
#line 778
    fullHomePath[tmp___1] = (char)0;
#line 778
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 781
  pidFileSet = 0;
#line 784
  logFileSet = 0;
#line 787
  failMsg[0] = (char )'\000';
#line 787
  tmp___2 = 1U;
  {
#line 787
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 787
    if (tmp___2 >= 257U) {
#line 787
      goto while_break___2;
    }
#line 787
    failMsg[tmp___2] = (char)0;
#line 787
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 790
  exitCode = 0;
#line 793
  resetOnQuit = 0;
#line 796
  resetOnly = 0;
#line 799
  checkTermType = 1;
  {
#line 812
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 812
    ch = getopt(argc, (char * const  *)argv, "Iut:vp:Pf:l:FRTLn");
    }
#line 812
    if (! (ch != -1)) {
#line 812
      goto while_break___3;
    }
    {
#line 814
    if (ch == 73) {
#line 814
      goto case_73;
    }
#line 817
    if (ch == 117) {
#line 817
      goto case_117;
    }
#line 821
    if (ch == 116) {
#line 821
      goto case_116;
    }
#line 826
    if (ch == 118) {
#line 826
      goto case_118;
    }
#line 829
    if (ch == 80) {
#line 829
      goto case_80;
    }
#line 832
    if (ch == 110) {
#line 832
      goto case_110;
    }
#line 838
    if (ch == 112) {
#line 838
      goto case_112;
    }
#line 841
    if (ch == 70) {
#line 841
      goto case_70;
    }
#line 844
    if (ch == 102) {
#line 844
      goto case_102;
    }
#line 850
    if (ch == 108) {
#line 850
      goto case_108;
    }
#line 856
    if (ch == 82) {
#line 856
      goto case_82;
    }
#line 861
    if (ch == 114) {
#line 861
      goto case_114;
    }
#line 864
    if (ch == 84) {
#line 864
      goto case_84;
    }
#line 868
    if (ch == 76) {
#line 868
      goto case_76;
    }
#line 872
    goto switch_default;
    case_73: /* CIL Label */ 
#line 815
    inverse = 0;
#line 816
    goto switch_break;
    case_117: /* CIL Label */ 
#line 819
    microTime = 1;
#line 820
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 822
    useTTY = 1;
#line 823
    strncpy((char */* __restrict  */)(whichTTY), (char const   */* __restrict  */)optarg,
            (size_t )256);
#line 824
    whichTTY[256] = (char )'\000';
    }
#line 825
    goto switch_break;
    case_118: /* CIL Label */ 
#line 827
    verbose = 1;
#line 828
    goto switch_break;
    case_80: /* CIL Label */ 
#line 830
    setPriority = 0;
#line 831
    goto switch_break;
    case_110: /* CIL Label */ 
#line 833
    sendNulls = 1;
#line 836
    checkTermType = 0;
#line 837
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 839
    priority = atoi((char const   *)optarg);
    }
#line 840
    goto switch_break;
    case_70: /* CIL Label */ 
#line 842
    doPidFile = 0;
#line 843
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 846
    pidFileSet = 1;
#line 847
    strncpy((char */* __restrict  */)(pidFileName), (char const   */* __restrict  */)optarg,
            (size_t )256);
#line 848
    pidFileName[256] = (char )'\000';
    }
#line 849
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 852
    logFileSet = 1;
#line 853
    strncpy((char */* __restrict  */)(logFileName), (char const   */* __restrict  */)optarg,
            (size_t )256);
#line 854
    logFileName[256] = (char )'\000';
    }
#line 855
    goto switch_break;
    case_82: /* CIL Label */ 
#line 858
    resetOnly = 1;
#line 859
    doPidFile = 0;
#line 860
    goto switch_break;
    case_114: /* CIL Label */ 
#line 862
    resetOnQuit = 1;
#line 863
    goto switch_break;
    case_84: /* CIL Label */ 
#line 865
    checkTermType = 0;
#line 866
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 869
    License();
    }
#line 870
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 873
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 875
  argc -= optind;
#line 876
  argv += optind;
#line 879
  if (argc > 2) {
    {
#line 880
    usage();
    }
  }
  {
#line 883
  logfile = stderr;
#line 886
  tmp___3 = getuid();
#line 886
  tmp___4 = geteuid();
  }
#line 886
  if (tmp___3 != tmp___4) {
    {
#line 889
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: **** This program is setuid! ****\n%s: **** Terminating due to security concerns! ****\n%s: If you *must* you could use setgid, but this is not recommened either.\n",
            "spinner", "spinner", "spinner");
#line 890
    exit(1);
    }
  }
  {
#line 894
  tmp___6 = getgid();
#line 894
  tmp___7 = getegid();
  }
#line 894
  if (tmp___6 != tmp___7) {
    {
#line 897
    tmp___5 = getegid();
#line 897
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: *** This program is setgid to gid %d ! ****\n%s: WARNING: Pid file has been disabled for security reasons.\n",
            "spinner", tmp___5, "spinner");
#line 900
    doPidFile = 0;
    }
  }
#line 906
  if (checkTermType) {
    {
#line 909
    termType = getenv("TERM");
    }
#line 909
    if ((unsigned long )((void *)0) == (unsigned long )termType) {
      {
#line 911
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to determine TERM type from the environment.\n%s: Use -T switch to override check and use VT100 codes anyway.\n",
              "spinner", "spinner");
#line 912
      exit(1);
      }
    }
    {
#line 916
    tmp___8 = strncasecmp((char const   *)termType, "VT100", sizeof("VT100") - 1UL);
    }
#line 916
    if (! (0 == tmp___8)) {
      {
#line 916
      tmp___9 = strncasecmp((char const   *)termType, "VT102", sizeof("VT102") - 1UL);
      }
#line 916
      if (! (0 == tmp___9)) {
        {
#line 916
        tmp___10 = strncasecmp((char const   *)termType, "XTERM", sizeof("XTERM") - 1UL);
        }
#line 916
        if (! (0 == tmp___10)) {
          {
#line 916
          tmp___11 = strncasecmp((char const   *)termType, "RXVT", sizeof("RXVT") - 1UL);
          }
#line 916
          if (! (0 == tmp___11)) {
            {
#line 916
            tmp___12 = strncasecmp((char const   *)termType, "SCREEN", sizeof("SCREEN") - 1UL);
            }
#line 916
            if (! (0 == tmp___12)) {
              {
#line 916
              tmp___13 = strncasecmp((char const   *)termType, "ANSI", sizeof("ANSI") - 1UL);
              }
#line 916
              if (! (0 == tmp___13)) {
                {
#line 926
                fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: I cannot determine if your TERM type from the environment (%s)\n%s: is VT100 compatible.\n%s: Use -T switch to override this check and use VT100 codes anyway.\n%s: In most cases this is fine (unless you have a \"dumb\" terminal).\n",
                        "spinner", termType, "spinner", "spinner", "spinner");
#line 927
                exit(1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 932
  if (doPidFile) {
#line 932
    if (! pidFileSet) {
      {
#line 935
      tmp___14 = GetHomePath(verbose, logfile, fullHomePath);
      }
#line 935
      if (0 != tmp___14) {
        {
#line 937
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to retrieve path to HOME directory from /etc/passwd!.\n",
                "spinner");
#line 938
        exit(1);
        }
      }
      {
#line 941
      strncpy((char */* __restrict  */)(pidFileName), (char const   */* __restrict  */)(fullHomePath),
              (size_t )256);
#line 942
      tmp___15 = strlen((char const   *)(pidFileName));
#line 942
      strncat((char */* __restrict  */)(pidFileName), (char const   */* __restrict  */)".spinner.pid",
              (256UL - tmp___15) - 1UL);
#line 943
      pidFileName[256] = (char )'\000';
      }
    }
  }
#line 948
  if (verbose) {
#line 950
    if (inverse) {
#line 950
      tmp___16 = "enabled";
    } else {
#line 950
      tmp___16 = "disabled";
    }
    {
#line 950
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Inverse mode %s.\n",
            "spinner", tmp___16);
    }
#line 951
    if (useTTY) {
      {
#line 952
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Using user-selected TTY: %s.\n",
              "spinner", whichTTY);
      }
    }
#line 954
    if (resetOnQuit) {
      {
#line 955
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Will attempt to reset the terminal on quit.\n",
              "spinner");
      }
    } else {
      {
#line 957
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Will not attempt to reset the terminal on quit.\n",
              "spinner");
      }
    }
#line 959
    if (setPriority) {
      {
#line 960
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Will attempt to set process priority to %d.\n",
              "spinner", priority);
      }
    } else {
      {
#line 962
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Will not alter process priority.\n",
              "spinner");
      }
    }
  }
#line 965
  if (argc < 1) {
#line 968
    time = 2;
#line 971
    microTime = 0;
#line 972
    if (verbose) {
      {
#line 973
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: No delay specified. Using default delay.\n",
              "spinner");
      }
    }
  } else {
    {
#line 979
    time = atoi((char const   *)*(argv + 0));
    }
#line 980
    if (time < 0) {
      {
#line 982
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Delay values must be between 0 and %d inclusive\n",
              "spinner", 65000);
#line 983
      exit(1);
      }
    } else
#line 980
    if (time > 65000) {
      {
#line 982
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Delay values must be between 0 and %d inclusive\n",
              "spinner", 65000);
#line 983
      exit(1);
      }
    }
  }
#line 987
  if (verbose) {
#line 988
    if (microTime) {
#line 988
      tmp___17 = "u";
    } else {
#line 988
      tmp___17 = "";
    }
    {
#line 988
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Using %d %ssec delay.\n",
            "spinner", time, tmp___17);
    }
  }
  {
#line 996
  tmp___20 = getgid();
#line 996
  tmp___21 = getegid();
  }
#line 996
  if (tmp___20 != tmp___21) {
    {
#line 998
    tmp___18 = getgid();
#line 998
    tmp___19 = setgid(tmp___18);
    }
#line 998
    if (0 != tmp___19) {
      {
#line 1000
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Unable to drop group priviledges!\n%s,: Aborting...",
              "spinner", "spinner");
#line 1001
      exit(1);
      }
    }
  }
#line 1008
  if (! useTTY) {
    {
#line 1012
    tmp___22 = ttyname(0);
#line 1012
    strncpy((char */* __restrict  */)(whichTTY), (char const   */* __restrict  */)tmp___22,
            (size_t )256);
#line 1013
    whichTTY[256] = (char )'\000';
    }
  }
#line 1017
  if (resetOnly) {
    {
#line 1020
    ResetTerm(verbose, 1, logfile, whichTTY, ttyName);
#line 1021
    exit(0);
    }
  }
#line 1026
  if (setPriority) {
#line 1028
    if (verbose) {
      {
#line 1029
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Setting process priority to %d.\n",
              "spinner", priority);
      }
    }
    {
#line 1031
    tmp___25 = setpriority(0, (id_t )0, priority);
    }
#line 1031
    if (-1 == tmp___25) {
      {
#line 1033
      tmp___23 = __errno_location();
#line 1033
      tmp___24 = strerror(*tmp___23);
#line 1033
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: Unable to set process priority to %d.\n%s: WARNING: %s\n",
              "spinner", priority, "spinner", tmp___24);
      }
    }
  }
#line 1039
  if (verbose) {
    {
#line 1040
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Launching into the background.  (Daemonizing...)\n",
            "spinner");
    }
  }
#line 1044
  if (logFileSet) {
    {
#line 1046
    logfile = fopen((char const   */* __restrict  */)(logFileName), (char const   */* __restrict  */)"a");
    }
#line 1047
    if ((unsigned long )logfile == (unsigned long )((void *)0)) {
      {
#line 1049
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unable to open logfile for appending! Location: %s\n",
              "spinner", logFileName);
#line 1050
      exit(1);
      }
    }
    {
#line 1054
    setvbuf((FILE */* __restrict  */)logfile, (char */* __restrict  */)((void *)0),
            1, (size_t )0);
    }
  }
  {
#line 1060
  tmp___26 = Daemonize(verbose, logFileName, logFileSet, stderr, doPidFile, pidFileName);
  }
#line 1060
  if (tmp___26 != 0) {
    {
#line 1062
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unable to become a daemon!\n",
            "spinner");
#line 1063
    exit(1);
    }
  }
#line 1066
  if (verbose) {
#line 1068
    if (logFileSet) {
      {
#line 1069
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n%s: Begin output to logfile.\n",
              "spinner");
      }
    }
  }
#line 1073
  if (sendNulls) {
    {
#line 1075
    exitCode = NullLoop(verbose, time, microTime, logFileSet, logfile, whichTTY, ttyName,
                        failMsg);
    }
  } else {
    {
#line 1079
    exitCode = SpinnerLoop(verbose, inverse, time, microTime, logFileSet, logfile,
                           whichTTY, ttyName, failMsg);
    }
  }
#line 1084
  if (doPidFile) {
    {
#line 1086
    tmp___29 = unlink((char const   *)(pidFileName));
    }
#line 1086
    if (0 != tmp___29) {
#line 1089
      if (logFileSet) {
        {
#line 1090
        tmp___27 = __errno_location();
#line 1090
        tmp___28 = strerror(*tmp___27);
#line 1090
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: WARNING: Unable to delete pid file %s.\n%s: WARNING: %s\n",
                "spinner", pidFileName, "spinner", tmp___28);
        }
      }
    }
  }
#line 1101
  if (resetOnQuit) {
    {
#line 1103
    ResetTerm(verbose, logFileSet, logfile, whichTTY, ttyName);
    }
  }
#line 1108
  if (logFileSet) {
    {
#line 1110
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s",
            failMsg);
    }
#line 1112
    if (verbose) {
      {
#line 1113
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: Exiting normally..\n",
              "spinner");
      }
    }
    {
#line 1116
    fclose(logfile);
    }
  }
#line 1118
  return (exitCode);
}
}
