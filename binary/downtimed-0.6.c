/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.h"
struct downtimedb {
   uint8_t what ;
   uint8_t _padding[7] ;
   int64_t when ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
struct _code {
   char *c_name ;
   int c_val ;
};
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
typedef struct _code CODE;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 46 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 50
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.h"
int downtimedb_read(int fd , struct downtimedb *buf ) ;
#line 82
char *timestr_abs(time_t t , char const   *fmt , int utc ) ;
#line 83
char *timestr_int(time_t t ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
int main(int argc , char **argv ) ;
#line 82
static void report(int64_t td , int crashed , int64_t tu ) ;
#line 83
static void version(void) ;
#line 84
static void usage(void) ;
#line 85
static void parseargs(int argc , char **argv ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static long cf_sleep  =    0L;
#line 90 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static char *cf_downtimedbfile  =    (char *)"/var/lib/downtimed/downtimedb";
#line 91 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static long cf_n  =    -1L;
#line 92 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static char *cf_timefmt  =    (char *)"%F %T";
#line 93 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static int cf_utc  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
int main(int argc , char **argv ) 
{ 
  struct downtimedb dbent ;
  struct stat sb ;
  int64_t tdown ;
  int64_t tadjust ;
  int fd ;
  int ret ;
  int crashed ;
  int tmp ;
  __off_t tmp___0 ;
  int64_t tmp___1 ;

  {
  {
#line 108
  parseargs(argc, argv);
#line 110
  fd = open((char const   *)cf_downtimedbfile, 0);
  }
#line 110
  if (fd < 0) {
    {
#line 111
    fputs((char const   */* __restrict  */)"Maybe the system has not been down yet?\n",
          (FILE */* __restrict  */)stderr);
#line 112
    err(66, "can not open %s", cf_downtimedbfile);
    }
  }
  {
#line 115
  tmp = fstat(fd, & sb);
  }
#line 115
  if (tmp < 0) {
    {
#line 116
    err(66, "can not stat %s", cf_downtimedbfile);
    }
  }
#line 118
  if ((unsigned long )sb.st_size % sizeof(struct downtimedb ) != 0UL) {
    {
#line 119
    errx(65, "%s is corrupted", cf_downtimedbfile);
    }
  }
#line 121
  if (cf_n == -1L) {
#line 123
    cf_n = (long )(((unsigned long )sb.st_size / sizeof(struct downtimedb )) / 2UL);
  } else
#line 121
  if ((unsigned long )cf_n > ((unsigned long )sb.st_size / sizeof(struct downtimedb )) / 2UL) {
#line 123
    cf_n = (long )(((unsigned long )sb.st_size / sizeof(struct downtimedb )) / 2UL);
  }
  {
#line 125
  tmp___0 = lseek(fd, (__off_t )((unsigned long )sb.st_size - ((unsigned long )cf_n * sizeof(struct downtimedb )) * 2UL),
                  0);
  }
#line 125
  if (tmp___0 < 0L) {
    {
#line 127
    err(65, "can not seek %s", cf_downtimedbfile);
    }
  }
#line 129
  tdown = (int64_t )0;
#line 130
  tadjust = cf_sleep / 2L;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    ret = downtimedb_read(fd, & dbent);
    }
#line 132
    if (! (ret > 0)) {
#line 132
      goto while_break;
    }
    {
#line 134
    if ((int )dbent.what == 2) {
#line 134
      goto case_2;
    }
#line 140
    if ((int )dbent.what == 3) {
#line 140
      goto case_3;
    }
#line 146
    if ((int )dbent.what == 1) {
#line 146
      goto case_1;
    }
#line 152
    goto switch_default;
    case_2: /* CIL Label */ 
#line 135
    if (tdown != 0L) {
      {
#line 136
      report(dbent.when, 0, (int64_t )0);
      }
    }
#line 137
    tdown = dbent.when;
#line 138
    crashed = 0;
#line 139
    goto switch_break;
    case_3: /* CIL Label */ 
#line 141
    if (tdown != 0L) {
      {
#line 142
      report(dbent.when + tadjust, 1, (int64_t )0);
      }
    }
#line 143
    tdown = dbent.when;
#line 144
    crashed = 1;
#line 145
    goto switch_break;
    case_1: /* CIL Label */ 
#line 147
    if (crashed) {
#line 147
      tmp___1 = tdown + tadjust;
    } else {
#line 147
      tmp___1 = tdown;
    }
    {
#line 147
    report(tmp___1, crashed, dbent.when);
#line 149
    tdown = (int64_t )0;
    }
#line 150
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 153
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (tdown != 0L) {
    {
#line 158
    report(tdown, crashed, (int64_t )0);
    }
  }
#line 160
  if (ret < 0) {
    {
#line 161
    err(65, "error reading %s", cf_downtimedbfile);
    }
  }
  {
#line 163
  close(fd);
#line 164
  exit(0);
  }
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static void report(int64_t td , int crashed , int64_t tu ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 172
  tmp = timestr_abs(td, (char const   *)cf_timefmt, cf_utc);
  }
#line 172
  if (crashed) {
#line 172
    tmp___0 = "crash";
  } else {
#line 172
    tmp___0 = "down ";
  }
  {
#line 172
  printf((char const   */* __restrict  */)"%s %s -> ", tmp___0, tmp);
#line 179
  tmp___1 = timestr_abs(tu, (char const   *)cf_timefmt, cf_utc);
#line 179
  printf((char const   */* __restrict  */)"up %s ", tmp___1);
  }
#line 184
  if (tu != 0L) {
#line 184
    if (td != 0L) {
      {
#line 185
      tmp___2 = timestr_int(tu - td);
#line 185
      printf((char const   */* __restrict  */)"= %11s (%lu s)\n", tmp___2, tu - td);
      }
    } else {
      {
#line 188
      printf((char const   */* __restrict  */)"= %11s (? s)\n", "unknown");
      }
    }
  } else {
    {
#line 188
    printf((char const   */* __restrict  */)"= %11s (? s)\n", "unknown");
    }
  }
#line 189
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static void usage(void) 
{ 


  {
  {
#line 197
  fputs((char const   */* __restrict  */)"usage: downtimes [-v] [-d downtimedbfile] [-f timefmt] [-n num] [-s sleep] [-u]\n",
        (FILE */* __restrict  */)stderr);
#line 199
  exit(64);
  }
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static void version(void) 
{ 


  {
  {
#line 208
  puts("downtimes 0.6 - display system downtime records made by downtimed(8)\n");
#line 211
  puts("Copyright (c) 2009-2013 EPIPE Communications. All rights reserved.");
#line 213
  puts("This software is licensed under the terms and conditions of the FreeBSD");
#line 215
  puts("License which is also known as the Simplified BSD License. You should have ");
#line 217
  puts("received a copy of that license along with this software.\n");
#line 219
  puts("Default settings:");
#line 220
  printf((char const   */* __restrict  */)"  downtimedbfile = %s\n", cf_downtimedbfile);
#line 221
  printf((char const   */* __restrict  */)"  num = %ld\n", cf_n);
#line 222
  printf((char const   */* __restrict  */)"  sleep = %ld\n", cf_sleep);
#line 223
  printf((char const   */* __restrict  */)"  timefmt = %s\n", cf_timefmt);
#line 224
  printf((char const   */* __restrict  */)"  utc = %d\n", cf_utc);
#line 227
  puts("\nSee the following web site for more information and updates:");
#line 228
  puts("  http://dist.epipe.com/downtimed/\n");
#line 230
  exit(0);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimes.c"
static void parseargs(int argc , char **argv ) 
{ 
  int c ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 241
  tmp = strlen((char const   *)*(argv + 0));
  }
#line 241
  if (tmp > 0UL) {
    {
#line 241
    tmp___0 = strlen((char const   *)*(argv + 0));
    }
#line 241
    if ((int )*(*(argv + 0) + (tmp___0 - 1UL)) != 115) {
#line 242
      cf_n = 1L;
    }
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 244
    c = getopt(argc, (char * const  *)argv, "d:f:n:s:uvh?");
    }
#line 244
    if (! (c != -1)) {
#line 244
      goto while_break;
    }
    {
#line 246
    if (c == 100) {
#line 246
      goto case_100;
    }
#line 249
    if (c == 102) {
#line 249
      goto case_102;
    }
#line 252
    if (c == 110) {
#line 252
      goto case_110;
    }
#line 259
    if (c == 115) {
#line 259
      goto case_115;
    }
#line 266
    if (c == 117) {
#line 266
      goto case_117;
    }
#line 269
    if (c == 118) {
#line 269
      goto case_118;
    }
#line 275
    goto switch_default;
    case_100: /* CIL Label */ 
#line 247
    cf_downtimedbfile = optarg;
#line 248
    goto switch_break;
    case_102: /* CIL Label */ 
#line 250
    cf_timefmt = optarg;
#line 251
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 253
    p = (char *)((void *)0);
#line 254
    tmp___1 = __errno_location();
#line 254
    *tmp___1 = 0;
#line 255
    cf_n = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                  10);
    }
#line 256
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 256
      if ((int )*p != 0) {
        {
#line 257
        errx(64, "-n argument is not a number");
        }
      } else {
#line 256
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 256
      tmp___2 = __errno_location();
      }
#line 256
      if (*tmp___2 != 0) {
        {
#line 257
        errx(64, "-n argument is not a number");
        }
      }
    }
#line 258
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 260
    p = (char *)((void *)0);
#line 261
    tmp___3 = __errno_location();
#line 261
    *tmp___3 = 0;
#line 262
    cf_sleep = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                      10);
    }
#line 263
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 263
      if ((int )*p != 0) {
        {
#line 264
        errx(64, "-s argument is not a number");
        }
      } else {
#line 263
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 263
      tmp___4 = __errno_location();
      }
#line 263
      if (*tmp___4 != 0) {
        {
#line 264
        errx(64, "-s argument is not a number");
        }
      }
    }
#line 265
    goto switch_break;
    case_117: /* CIL Label */ 
#line 267
    cf_utc = 1;
#line 268
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 270
    version();
    }
#line 272
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 276
    usage();
    }
#line 278
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  if (argc != optind) {
    {
#line 282
    usage();
    }
  }
#line 283
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.h"
int downtimedb_write(int fd , struct downtimedb *buf ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
int downtimedb_read(int fd , struct downtimedb *buf ) 
{ 
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 98
  tmp = __errno_location();
#line 98
  *tmp = 0;
#line 99
  tmp___1 = read(fd, (void *)buf, sizeof(struct downtimedb ));
#line 99
  ret = (int )tmp___1;
  }
#line 99
  if ((unsigned long )ret < sizeof(struct downtimedb )) {
#line 101
    if (ret == 0) {
#line 102
      return (0);
    } else {
#line 104
      if (ret != -1) {
        {
#line 106
        tmp___0 = __errno_location();
#line 106
        *tmp___0 = 84;
        }
      }
#line 108
      return (-1);
    }
  }
#line 113
  buf->when = (int64_t )(((((((((uint64_t )buf->when << 56) | (((uint64_t )buf->when & 65280UL) << 40)) | (((uint64_t )buf->when & 16711680UL) << 24)) | (((uint64_t )buf->when & 4278190080UL) << 8)) | (((uint64_t )buf->when >> 8) & 4278190080UL)) | (((uint64_t )buf->when >> 24) & 16711680UL)) | (((uint64_t )buf->when >> 40) & 65280UL)) | ((uint64_t )buf->when >> 56));
#line 116
  return (1);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
int downtimedb_write(int fd , struct downtimedb *buf ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 128
  buf->when = (int64_t )(((((((((uint64_t )buf->when << 56) | (((uint64_t )buf->when & 65280UL) << 40)) | (((uint64_t )buf->when & 16711680UL) << 24)) | (((uint64_t )buf->when & 4278190080UL) << 8)) | (((uint64_t )buf->when >> 8) & 4278190080UL)) | (((uint64_t )buf->when >> 24) & 16711680UL)) | (((uint64_t )buf->when >> 40) & 65280UL)) | ((uint64_t )buf->when >> 56));
#line 131
  tmp = __errno_location();
#line 131
  *tmp = 0;
#line 132
  tmp___0 = write(fd, (void const   *)((void *)buf), sizeof(struct downtimedb ));
  }
#line 132
  if ((unsigned long )tmp___0 < sizeof(struct downtimedb )) {
#line 134
    return (-1);
  }
#line 136
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
static char str[256]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
char *timestr_abs(time_t t , char const   *fmt , int utc ) 
{ 
  struct tm *lt ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  size_t tmp___1 ;

  {
#line 150
  if (t != 0L) {
#line 151
    if (utc) {
      {
#line 151
      tmp = gmtime((time_t const   *)(& t));
#line 151
      lt = tmp;
      }
    } else {
      {
#line 151
      tmp___0 = localtime((time_t const   *)(& t));
#line 151
      lt = tmp___0;
      }
    }
#line 151
    if ((unsigned long )lt == (unsigned long )((void *)0)) {
#line 152
      goto err;
    }
    {
#line 153
    tmp___1 = strftime((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)fmt,
                       (struct tm  const  */* __restrict  */)lt);
    }
#line 153
    if (tmp___1 == 0UL) {
#line 154
      goto err;
    }
#line 156
    return (str);
  }
  err: 
#line 160
  return ((char *)"????-??-?? ??:??:??");
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
static char str___0[100]  ;
#line 168 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
char *timestr_int(time_t t ) 
{ 
  int days ;
  int hrs ;
  int mins ;
  int secs ;

  {
#line 174
  days = (int )(t / 86400L);
#line 175
  t %= 86400L;
#line 176
  hrs = (int )(t / 3600L);
#line 177
  t %= 3600L;
#line 178
  mins = (int )(t / 60L);
#line 179
  secs = (int )(t % 60L);
#line 181
  if (days > 0) {
    {
#line 182
    snprintf((char */* __restrict  */)(str___0), sizeof(str___0), (char const   */* __restrict  */)"%d+%02d:%02d:%02d",
             days, hrs, mins, secs);
    }
  } else {
    {
#line 185
    snprintf((char */* __restrict  */)(str___0), sizeof(str___0), (char const   */* __restrict  */)"%02d:%02d:%02d",
             hrs, mins, secs);
    }
  }
#line 188
  return (str___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 138 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimes)(int __fd ,
                                                                              struct timeval  const  *__tvp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 956
extern int fsync(int __fd ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE prioritynames[13]  = 
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
  {      {(char *)"alert", 1}, 
        {(char *)"crit", 2}, 
        {(char *)"debug", 7}, 
        {(char *)"emerg", 0}, 
        {(char *)"err", 3}, 
        {(char *)"error", 3}, 
        {(char *)"info", 6}, 
        {(char *)"none", 16}, 
        {(char *)"notice", 5}, 
        {(char *)"panic", 0}, 
        {(char *)"warn", 4}, 
        {(char *)"warning", 4}, 
        {(char *)((void *)0), -1}};
#line 122 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE facilitynames[23]  = 
#line 122
  {      {(char *)"auth", 4 << 3}, 
        {(char *)"authpriv", 10 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"ftp", 11 << 3}, 
        {(char *)"kern", 0}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"mark", 24 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"security", 4 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), -1}};
#line 175
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static time_t getboottime(void) ;
#line 133
static void updatedowntimedb(time_t up , int crashed , time_t down ) ;
#line 134
static void report___0(void) ;
#line 135
static void sighandler(int signum ) ;
#line 136
static void touch(char const   *fn , time_t t ) ;
#line 137
static void loginit(void) ;
#line 138
static void logdeinit(void) ;
#line 139
static void logwr(int pri , char const   *fmt  , ...) ;
#line 140
static void version___0(void) ;
#line 141
static void usage___0(void) ;
#line 142
static void parseargs___0(int argc , char **argv ) ;
#line 143
static int makepidfile(void) ;
#line 144
static void removepidfile(void) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *cf_log  =    (char *)"daemon";
#line 153 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *cf_pidfile  =    (char *)"/var/run/downtimed.pid";
#line 154 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *cf_datadir  =    (char *)"/var/lib/downtimed/";
#line 155 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static long cf_sleep___0  =    15L;
#line 157 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int cf_fsync  =    1;
#line 159 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int cf_downtimedb  =    1;
#line 160 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *cf_downtimedbfile___0  =    (char *)"/var/lib/downtimed/downtimedb";
#line 161 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *cf_timefmt___0  =    (char *)"%F %T";
#line 165 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int cf_logfacility  =    0;
#line 166 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int cf_logfd  =    -1;
#line 170 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *ts_stamp  =    (char *)((void *)0);
#line 171 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *ts_shutdown  =    (char *)((void *)0);
#line 172 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static char *ts_boot  =    (char *)((void *)0);
#line 173 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static time_t boottime  =    (time_t )0;
#line 174 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static time_t starttime  =    (time_t )0;
#line 178 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int volatile   exiting  =    (sig_atomic_t volatile   )0;
#line 179 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int volatile   reopenlog  =    (sig_atomic_t volatile   )0;
#line 292 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static time_t getboottime(void) 
{ 
  char str___3[1024] ;
  FILE *fp ;
  unsigned long bt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 319
  bt = 0UL;
#line 321
  fp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 321
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 322
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 322
      tmp___1 = fgets((char */* __restrict  */)(str___3), (int )sizeof(str___3), (FILE */* __restrict  */)fp);
      }
#line 322
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 322
        goto while_break;
      }
      {
#line 323
      tmp___0 = strncmp((char const   *)(str___3), "btime ", (size_t )6);
      }
#line 323
      if (tmp___0 == 0) {
        {
#line 324
        tmp = sscanf((char const   */* __restrict  */)(str___3), (char const   */* __restrict  */)"btime %lu",
                     & bt);
        }
#line 324
        if (tmp == 1) {
#line 324
          if (bt != 0UL) {
            {
#line 326
            fclose(fp);
            }
#line 327
            return ((time_t )bt);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 329
    fclose(fp);
    }
  }
  {
#line 359
  logwr(3, "can not determine system boot time on this OS");
  }
#line 361
  return (starttime);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void updatedowntimedb(time_t up , int crashed , time_t down ) 
{ 
  struct downtimedb dbent ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 372
  fd = open((char const   *)cf_downtimedbfile___0, 1089, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
  }
#line 372
  if (fd < 0) {
    {
#line 374
    tmp = __errno_location();
#line 374
    tmp___0 = strerror(*tmp);
#line 374
    logwr(3, "can not open %s: %s", cf_downtimedbfile___0, tmp___0);
    }
#line 376
    return;
  }
  {
#line 380
  memset((void *)(& dbent), 0, sizeof(struct downtimedb ));
  }
#line 382
  if (crashed) {
#line 382
    dbent.what = (uint8_t )3;
  } else {
#line 382
    dbent.what = (uint8_t )2;
  }
  {
#line 384
  dbent.when = (int64_t )((uint64_t )down);
#line 386
  tmp___3 = downtimedb_write(fd, & dbent);
  }
#line 386
  if (tmp___3 < 0) {
    {
#line 387
    tmp___1 = __errno_location();
#line 387
    tmp___2 = strerror(*tmp___1);
#line 387
    logwr(3, "can not write to %s: %s", cf_downtimedbfile___0, tmp___2);
    }
  }
  {
#line 391
  memset((void *)(& dbent), 0, sizeof(struct downtimedb ));
#line 393
  dbent.what = (uint8_t )1;
#line 394
  dbent.when = (int64_t )((uint64_t )up);
#line 396
  tmp___6 = downtimedb_write(fd, & dbent);
  }
#line 396
  if (tmp___6 < 0) {
    {
#line 397
    tmp___4 = __errno_location();
#line 397
    tmp___5 = strerror(*tmp___4);
#line 397
    logwr(3, "can not write to %s: %s", cf_downtimedbfile___0, tmp___5);
    }
  }
  {
#line 400
  close(fd);
  }
#line 401
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void report___0(void) 
{ 
  struct stat sb_stamp ;
  struct stat sb_shutdown ;
  struct stat sb_oldboot ;
  int have_stamp ;
  int have_shutdown ;
  int have_oldboot ;
  time_t olduptime ;
  time_t downtime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __time_t tmp___2 ;
  __time_t tmp___3 ;
  __time_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 409
  have_stamp = 0;
#line 409
  have_shutdown = 0;
#line 409
  have_oldboot = 0;
#line 412
  tmp = stat((char const   */* __restrict  */)ts_stamp, (struct stat */* __restrict  */)(& sb_stamp));
  }
#line 412
  if (tmp == 0) {
#line 413
    have_stamp = 1;
  }
  {
#line 415
  tmp___0 = stat((char const   */* __restrict  */)ts_shutdown, (struct stat */* __restrict  */)(& sb_shutdown));
  }
#line 415
  if (tmp___0 == 0) {
#line 416
    have_shutdown = 1;
  }
  {
#line 418
  tmp___1 = stat((char const   */* __restrict  */)ts_boot, (struct stat */* __restrict  */)(& sb_oldboot));
  }
#line 418
  if (tmp___1 == 0) {
#line 419
    have_oldboot = 1;
  }
#line 421
  if (! have_stamp) {
#line 421
    if (! have_shutdown) {
#line 421
      if (! have_oldboot) {
        {
#line 422
        logwr(5, "starting up first time, no knowledge of downtime");
        }
#line 424
        return;
      }
    }
  }
#line 426
  if (! have_stamp) {
    {
#line 427
    logwr(3, "no old run-time stamp (%s)", ts_stamp);
    }
#line 428
    return;
  }
#line 430
  if (! have_oldboot) {
    {
#line 431
    logwr(3, "no old boot-time stamp (%s)", ts_boot);
    }
#line 432
    return;
  }
#line 434
  if (have_stamp) {
#line 434
    if (have_shutdown) {
#line 434
      if (sb_shutdown.st_mtim.tv_sec < sb_stamp.st_mtim.tv_sec) {
#line 436
        have_shutdown = 0;
      }
    }
  }
#line 438
  if (have_shutdown) {
#line 438
    tmp___2 = sb_shutdown.st_mtim.tv_sec;
  } else {
#line 438
    tmp___2 = sb_stamp.st_mtim.tv_sec;
  }
#line 438
  olduptime = tmp___2 - sb_oldboot.st_mtim.tv_sec;
#line 442
  if (have_shutdown) {
#line 442
    tmp___3 = sb_shutdown.st_mtim.tv_sec;
  } else {
#line 442
    tmp___3 = sb_stamp.st_mtim.tv_sec;
  }
#line 442
  downtime = boottime - tmp___3;
#line 445
  if (downtime < 0L) {
    {
#line 450
    logwr(5, "restarted, system was not down");
    }
#line 451
    return;
  }
  {
#line 454
  logwr(5, "started %d seconds after boot", starttime - boottime);
  }
#line 457
  if (cf_downtimedb) {
#line 458
    if (have_shutdown) {
#line 458
      tmp___4 = sb_shutdown.st_mtim.tv_sec;
    } else {
#line 458
      tmp___4 = sb_stamp.st_mtim.tv_sec;
    }
    {
#line 458
    updatedowntimedb(boottime, ! have_shutdown, tmp___4);
    }
  }
#line 462
  if (have_shutdown) {
    {
#line 463
    tmp___5 = timestr_abs(sb_shutdown.st_mtim.tv_sec, (char const   *)cf_timefmt___0,
                          0);
#line 463
    logwr(5, "system shutdown at %s", tmp___5);
    }
  } else {
    {
#line 466
    tmp___6 = timestr_abs(sb_stamp.st_mtim.tv_sec, (char const   *)cf_timefmt___0,
                          0);
#line 466
    logwr(5, "system crashed at %s", tmp___6);
    }
  }
  {
#line 470
  tmp___7 = timestr_int(olduptime);
#line 470
  logwr(5, "previous uptime was %s (%d seconds)", tmp___7, olduptime);
#line 473
  tmp___8 = timestr_int(downtime);
#line 473
  logwr(5, "downtime was %s (%d seconds)", tmp___8, downtime);
  }
#line 475
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void sighandler(int signum ) 
{ 


  {
#line 483
  if (signum == 2) {
#line 484
    exiting = (int volatile   )1;
  } else
#line 483
  if (signum == 15) {
#line 484
    exiting = (int volatile   )1;
  }
#line 486
  if (signum == 1) {
#line 487
    reopenlog = (int volatile   )1;
  }
#line 488
  return;
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void touch(char const   *fn , time_t t ) 
{ 
  struct stat sb ;
  struct timeval tv[2] ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct timeval *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  struct timeval *tmp___16 ;
  int tmp___17 ;

  {
#line 499
  if (t != 0L) {
#line 500
    tv[0].tv_sec = t;
#line 501
    tv[0].tv_usec = (__suseconds_t )0;
#line 502
    tv[1].tv_sec = t;
#line 503
    tv[1].tv_usec = (__suseconds_t )0;
  }
#line 507
  if (cf_fsync) {
    {
#line 509
    fd = open(fn, 577, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
    }
#line 509
    if (fd < 0) {
      {
#line 511
      tmp = __errno_location();
#line 511
      tmp___0 = strerror(*tmp);
#line 511
      logwr(3, "%s: %s", fn, tmp___0);
      }
#line 512
      return;
    }
#line 514
    if (t == 0L) {
#line 514
      tmp___3 = (struct timeval *)((void *)0);
    } else {
#line 514
      tmp___3 = tv;
    }
    {
#line 514
    tmp___4 = futimes(fd, (struct timeval  const  *)tmp___3);
    }
#line 514
    if (tmp___4 < 0) {
      {
#line 515
      tmp___1 = __errno_location();
#line 515
      tmp___2 = strerror(*tmp___1);
#line 515
      logwr(3, "%s: %s", fn, tmp___2);
      }
    } else {
      {
#line 517
      fsync(fd);
      }
    }
    {
#line 519
    tmp___7 = close(fd);
    }
#line 519
    if (tmp___7 < 0) {
      {
#line 520
      tmp___5 = __errno_location();
#line 520
      tmp___6 = strerror(*tmp___5);
#line 520
      logwr(3, "%s: %s", fn, tmp___6);
      }
    }
  } else {
    {
#line 524
    tmp___13 = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& sb));
    }
#line 524
    if (tmp___13 < 0) {
      {
#line 525
      fd = open(fn, 577, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
      }
#line 525
      if (fd < 0) {
        {
#line 527
        tmp___8 = __errno_location();
#line 527
        tmp___9 = strerror(*tmp___8);
#line 527
        logwr(3, "%s: %s", fn, tmp___9);
        }
#line 528
        return;
      }
      {
#line 530
      tmp___12 = close(fd);
      }
#line 530
      if (tmp___12 < 0) {
        {
#line 531
        tmp___10 = __errno_location();
#line 531
        tmp___11 = strerror(*tmp___10);
#line 531
        logwr(3, "%s: %s", fn, tmp___11);
        }
      }
    }
#line 533
    if (t == 0L) {
#line 533
      tmp___16 = (struct timeval *)((void *)0);
    } else {
#line 533
      tmp___16 = tv;
    }
    {
#line 533
    tmp___17 = utimes(fn, (struct timeval  const  *)tmp___16);
    }
#line 533
    if (tmp___17 < 0) {
      {
#line 534
      tmp___14 = __errno_location();
#line 534
      tmp___15 = strerror(*tmp___14);
#line 534
      logwr(3, "%s: %s", fn, tmp___15);
      }
    }
  }
#line 538
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void loginit(void) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 615
  tmp___0 = strchr((char const   *)cf_log, '/');
  }
#line 615
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 618
    i = 0;
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
#line 618
      if (! ((unsigned long )facilitynames[i].c_name != (unsigned long )((void *)0))) {
#line 618
        goto while_break;
      }
      {
#line 619
      tmp = strcmp((char const   *)facilitynames[i].c_name, (char const   *)cf_log);
      }
#line 619
      if (tmp == 0) {
#line 620
        cf_logfacility = facilitynames[i].c_val;
      }
#line 618
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 622
    if (cf_logfacility == 0) {
      {
#line 623
      errx(64, "-l argument is not syslog facility or file path");
      }
    }
    {
#line 626
    openlog("downtimed", 1, cf_logfacility);
    }
  } else {
    {
#line 630
    cf_logfd = open((char const   *)cf_log, 1089, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
    }
#line 630
    if (cf_logfd < 0) {
      {
#line 632
      err(73, "%s", cf_log);
      }
    }
  }
#line 634
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void logdeinit(void) 
{ 


  {
#line 642
  if (cf_logfd < 0) {
    {
#line 643
    closelog();
    }
  } else {
    {
#line 645
    close(cf_logfd);
#line 646
    cf_logfd = -1;
    }
  }
#line 648
  return;
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void logwr(int pri , char const   *fmt  , ...) 
{ 
  char *str___3 ;
  char *str2 ;
  va_list ap ;
  int tmp ;
  time_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 659
  __builtin_va_start(ap, fmt);
  }
#line 661
  if (cf_logfd < 0) {
    {
#line 662
    vsyslog(pri, fmt, ap);
    }
  } else {
    {
#line 664
    tmp = vasprintf((char **/* __restrict  */)(& str___3), (char const   */* __restrict  */)fmt,
                    ap);
    }
#line 664
    if (tmp < 0) {
#line 665
      goto err;
    }
    {
#line 667
    tmp___0 = time((time_t *)((void *)0));
#line 667
    tmp___1 = timestr_abs(tmp___0, (char const   *)cf_timefmt___0, 0);
#line 667
    tmp___2 = asprintf((char **/* __restrict  */)(& str2), (char const   */* __restrict  */)"%s: %s\n",
                       tmp___1, str___3);
    }
#line 667
    if (tmp___2 < 0) {
      {
#line 670
      free((void *)str___3);
      }
#line 671
      goto err;
    }
    {
#line 681
    tmp___3 = strlen((char const   *)str2);
#line 681
    tmp___4 = write(cf_logfd, (void const   *)str2, tmp___3);
#line 685
    free((void *)str2);
#line 686
    free((void *)str___3);
    }
  }
  err: 
  {
#line 689
  __builtin_va_end(ap);
  }
#line 690
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void usage___0(void) 
{ 


  {
  {
#line 698
  fputs((char const   */* __restrict  */)"usage: downtimed [-DvS] [-d datadir] [-f timefmt] [-l log] [-p pidfile] [-s sleep]\n",
        (FILE */* __restrict  */)stderr);
#line 700
  exit(64);
  }
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void version___0(void) 
{ 


  {
  {
#line 709
  puts("downtimed 0.6 - system downtime reporting daemon\n");
#line 711
  puts("Copyright (c) 2009-2013 EPIPE Communications. All rights reserved.");
#line 713
  puts("This software is licensed under the terms and conditions of the FreeBSD");
#line 715
  puts("License which is also known as the Simplified BSD License. You should have ");
#line 717
  puts("received a copy of that license along with this software.\n");
#line 719
  puts("Default settings:");
#line 720
  printf((char const   */* __restrict  */)"  log = %s\n", cf_log);
#line 721
  printf((char const   */* __restrict  */)"  pidfile = %s\n", cf_pidfile);
#line 722
  printf((char const   */* __restrict  */)"  datadir = %s\n", cf_datadir);
#line 723
  printf((char const   */* __restrict  */)"  downtimedbfile = %s\n", cf_downtimedbfile___0);
#line 724
  printf((char const   */* __restrict  */)"  sleep = %ld\n", cf_sleep___0);
#line 726
  printf((char const   */* __restrict  */)"  fsync = %d\n", cf_fsync);
#line 730
  puts("\nSee the following web site for more information and updates:");
#line 731
  puts("  http://dist.epipe.com/downtimed/\n");
#line 733
  exit(0);
  }
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void parseargs___0(int argc , char **argv ) 
{ 
  int c ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 744
    c = getopt(argc, (char * const  *)argv, "Dd:f:l:p:s:Svh?");
    }
#line 744
    if (! (c != -1)) {
#line 744
      goto while_break;
    }
    {
#line 746
    if (c == 68) {
#line 746
      goto case_68;
    }
#line 749
    if (c == 100) {
#line 749
      goto case_100;
    }
#line 752
    if (c == 102) {
#line 752
      goto case_102;
    }
#line 755
    if (c == 108) {
#line 755
      goto case_108;
    }
#line 758
    if (c == 112) {
#line 758
      goto case_112;
    }
#line 761
    if (c == 115) {
#line 761
      goto case_115;
    }
#line 768
    if (c == 83) {
#line 768
      goto case_83;
    }
#line 773
    if (c == 118) {
#line 773
      goto case_118;
    }
#line 779
    goto switch_default;
    case_68: /* CIL Label */ 
#line 747
    cf_downtimedb = 0;
#line 748
    goto switch_break;
    case_100: /* CIL Label */ 
#line 750
    cf_datadir = optarg;
#line 751
    goto switch_break;
    case_102: /* CIL Label */ 
#line 753
    cf_timefmt___0 = optarg;
#line 754
    goto switch_break;
    case_108: /* CIL Label */ 
#line 756
    cf_log = optarg;
#line 757
    goto switch_break;
    case_112: /* CIL Label */ 
#line 759
    cf_pidfile = optarg;
#line 760
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 762
    p = (char *)((void *)0);
#line 763
    tmp = __errno_location();
#line 763
    *tmp = 0;
#line 764
    cf_sleep___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                          10);
    }
#line 765
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 765
      if ((int )*p != 0) {
        {
#line 766
        errx(64, "-s argument is not a number");
        }
      } else {
#line 765
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 765
      tmp___0 = __errno_location();
      }
#line 765
      if (*tmp___0 != 0) {
        {
#line 766
        errx(64, "-s argument is not a number");
        }
      }
    }
#line 767
    goto switch_break;
    case_83: /* CIL Label */ 
#line 770
    cf_fsync = 0;
#line 772
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 774
    version___0();
    }
#line 776
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 780
    usage___0();
    }
#line 782
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  if (argc != optind) {
    {
#line 786
    usage___0();
    }
  }
#line 787
  return;
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static int makepidfile(void) 
{ 
  char str___3[100] ;
  struct stat sb ;
  struct stat sb2 ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  __pid_t tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  ssize_t tmp___18 ;
  size_t tmp___19 ;

  {
  retry: 
  {
#line 802
  fd = open((char const   *)cf_pidfile, 65, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
  }
#line 802
  if (fd < 0) {
    {
#line 803
    tmp = __errno_location();
#line 803
    tmp___0 = strerror(*tmp);
#line 803
    logwr(3, "can not open pid file %s: %s", cf_pidfile, tmp___0);
    }
#line 805
    return (-1);
  }
  {
#line 808
  tmp___6 = flock(fd, 6);
  }
#line 808
  if (tmp___6 < 0) {
    {
#line 812
    tmp___3 = __errno_location();
    }
#line 812
    if (*tmp___3 == 11) {
      {
#line 813
      logwr(3, "another process is running already");
      }
    } else {
      {
#line 812
      tmp___4 = __errno_location();
      }
#line 812
      if (*tmp___4 == 11) {
        {
#line 813
        logwr(3, "another process is running already");
        }
      } else {
        {
#line 812
        tmp___5 = __errno_location();
        }
#line 812
        if (*tmp___5 == 13) {
          {
#line 813
          logwr(3, "another process is running already");
          }
        } else {
          {
#line 815
          tmp___1 = __errno_location();
#line 815
          tmp___2 = strerror(*tmp___1);
#line 815
          logwr(3, "can not lock pid file %s: %s", cf_pidfile, tmp___2);
          }
        }
      }
    }
    {
#line 817
    close(fd);
    }
#line 818
    return (-1);
  }
  {
#line 820
  tmp___7 = stat((char const   */* __restrict  */)cf_pidfile, (struct stat */* __restrict  */)(& sb));
  }
#line 820
  if (tmp___7 < 0) {
    {
#line 822
    close(fd);
    }
#line 823
    goto retry;
  }
  {
#line 825
  tmp___10 = fstat(fd, & sb2);
  }
#line 825
  if (tmp___10 < 0) {
    {
#line 827
    tmp___8 = __errno_location();
#line 827
    tmp___9 = strerror(*tmp___8);
#line 827
    logwr(3, "can not fstat pid file %s: %s", cf_pidfile, tmp___9);
#line 829
    close(fd);
    }
#line 830
    return (-1);
  }
#line 832
  if (sb.st_dev != sb2.st_dev) {
    {
#line 834
    close(fd);
    }
#line 835
    goto retry;
  } else
#line 832
  if (sb.st_ino != sb2.st_ino) {
    {
#line 834
    close(fd);
    }
#line 835
    goto retry;
  }
  {
#line 837
  tmp___13 = ftruncate(fd, (__off_t )0);
  }
#line 837
  if (tmp___13 < 0) {
    {
#line 839
    tmp___11 = __errno_location();
#line 839
    tmp___12 = strerror(*tmp___11);
#line 839
    logwr(3, "can not ftruncate pid file %s: %s", cf_pidfile, tmp___12);
#line 841
    close(fd);
    }
#line 842
    return (-1);
  }
  {
#line 844
  tmp___14 = getpid();
#line 844
  snprintf((char */* __restrict  */)(str___3), sizeof(str___3), (char const   */* __restrict  */)"%ld\n",
           (long )tmp___14);
#line 845
  tmp___17 = strlen((char const   *)(str___3));
#line 845
  tmp___18 = write(fd, (void const   *)(str___3), tmp___17);
#line 845
  tmp___19 = strlen((char const   *)(str___3));
  }
#line 845
  if ((size_t )tmp___18 != tmp___19) {
    {
#line 846
    tmp___15 = __errno_location();
#line 846
    tmp___16 = strerror(*tmp___15);
#line 846
    logwr(3, "can not write pid file %s: %s", cf_pidfile, tmp___16);
#line 848
    close(fd);
    }
#line 849
    return (-1);
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimed.c"
static void removepidfile(void) 
{ 


  {
  {
#line 873
  unlink((char const   *)cf_pidfile);
  }
#line 874
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
static char str___1[256]  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/downtimed-0.6/downtimedb.c"
static char str___2[100]  ;
