/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 385 "/usr/include/linux/hdreg.h"
struct hd_driveid {
   unsigned short config ;
   unsigned short cyls ;
   unsigned short reserved2 ;
   unsigned short heads ;
   unsigned short track_bytes ;
   unsigned short sector_bytes ;
   unsigned short sectors ;
   unsigned short vendor0 ;
   unsigned short vendor1 ;
   unsigned short vendor2 ;
   unsigned char serial_no[20] ;
   unsigned short buf_type ;
   unsigned short buf_size ;
   unsigned short ecc_bytes ;
   unsigned char fw_rev[8] ;
   unsigned char model[40] ;
   unsigned char max_multsect ;
   unsigned char vendor3 ;
   unsigned short dword_io ;
   unsigned char vendor4 ;
   unsigned char capability ;
   unsigned short reserved50 ;
   unsigned char vendor5 ;
   unsigned char tPIO ;
   unsigned char vendor6 ;
   unsigned char tDMA ;
   unsigned short field_valid ;
   unsigned short cur_cyls ;
   unsigned short cur_heads ;
   unsigned short cur_sectors ;
   unsigned short cur_capacity0 ;
   unsigned short cur_capacity1 ;
   unsigned char multsect ;
   unsigned char multsect_valid ;
   unsigned int lba_capacity ;
   unsigned short dma_1word ;
   unsigned short dma_mword ;
   unsigned short eide_pio_modes ;
   unsigned short eide_dma_min ;
   unsigned short eide_dma_time ;
   unsigned short eide_pio ;
   unsigned short eide_pio_iordy ;
   unsigned short words69_70[2] ;
   unsigned short words71_74[4] ;
   unsigned short queue_depth ;
   unsigned short words76_79[4] ;
   unsigned short major_rev_num ;
   unsigned short minor_rev_num ;
   unsigned short command_set_1 ;
   unsigned short command_set_2 ;
   unsigned short cfsse ;
   unsigned short cfs_enable_1 ;
   unsigned short cfs_enable_2 ;
   unsigned short csf_default ;
   unsigned short dma_ultra ;
   unsigned short trseuc ;
   unsigned short trsEuc ;
   unsigned short CurAPMvalues ;
   unsigned short mprc ;
   unsigned short hw_config ;
   unsigned short acoustic ;
   unsigned short msrqs ;
   unsigned short sxfert ;
   unsigned short sal ;
   unsigned int spg ;
   unsigned long long lba_capacity_2 ;
   unsigned short words104_125[22] ;
   unsigned short last_lun ;
   unsigned short word127 ;
   unsigned short dlf ;
   unsigned short csfo ;
   unsigned short words130_155[26] ;
   unsigned short word156 ;
   unsigned short words157_159[3] ;
   unsigned short cfa_power ;
   unsigned short words161_175[15] ;
   unsigned short words176_205[30] ;
   unsigned short words206_254[49] ;
   unsigned short integrity_word ;
};
#line 8 "/home/june/collector/temp/aoetools-30/dat.h"
typedef unsigned char uchar;
#line 9
struct Aoehdr;
#line 9 "/home/june/collector/temp/aoetools-30/dat.h"
typedef struct Aoehdr Aoehdr;
#line 10
struct Ata;
#line 10 "/home/june/collector/temp/aoetools-30/dat.h"
typedef struct Ata Ata;
#line 11
struct Conf;
#line 11 "/home/june/collector/temp/aoetools-30/dat.h"
typedef struct Conf Conf;
#line 20 "/home/june/collector/temp/aoetools-30/dat.h"
typedef uint32_t u32;
#line 21 "/home/june/collector/temp/aoetools-30/dat.h"
typedef uint16_t u16;
#line 32 "/home/june/collector/temp/aoetools-30/dat.h"
struct Aoehdr {
   uchar dst[6] ;
   uchar src[6] ;
   u16 type ;
   uchar flags ;
   uchar error ;
   u16 maj ;
   uchar min ;
   uchar cmd ;
   uchar tag[4] ;
};
#line 44 "/home/june/collector/temp/aoetools-30/dat.h"
struct Ata {
   Aoehdr h ;
   uchar aflag ;
   uchar err ;
   uchar sectors ;
   uchar cmd ;
   uchar lba[6] ;
   uchar resvd[2] ;
   uchar data[1024] ;
};
#line 55 "/home/june/collector/temp/aoetools-30/dat.h"
struct Conf {
   Aoehdr h ;
   u16 bufcnt ;
   u16 firmware ;
   uchar scnt ;
   uchar vercmd ;
   u16 len ;
   uchar data[1024] ;
};
#line 18 "/home/june/collector/temp/aoetools-30/aoeping.c"
struct progopts {
   int shelf ;
   int slot ;
   char *netif ;
   int verbose ;
   int timeout ;
   u32 tag ;
   char *smart ;
   char ata_ident ;
   char pp_ataid ;
};
#line 43 "/home/june/collector/temp/aoetools-30/aoeping.c"
struct smartcmd {
   char *name ;
   int cmd ;
   char data ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 28 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 12 "/usr/include/linux/if_packet.h"
struct sockaddr_ll {
   unsigned short sll_family ;
   __be16 sll_protocol ;
   int sll_ifindex ;
   unsigned short sll_hatype ;
   unsigned char sll_pkttype ;
   unsigned char sll_halen ;
   unsigned char sll_addr[8] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_37 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_38 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_37 ifr_ifrn ;
   union __anonunion_ifr_ifru_38 ifr_ifru ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 171 "/home/june/collector/temp/aoetools-30/aoecfg.c"
struct __anonstruct_Tab_37 {
   char *s ;
   int cmd ;
};
#line 171 "/home/june/collector/temp/aoetools-30/aoecfg.c"
typedef struct __anonstruct_Tab_37 Tab;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 2 "/home/june/collector/temp/aoetools-30/fns.h"
int dial(char *eth ) ;
#line 3
int getea(int s , char *name , uchar *ea ) ;
#line 30 "/home/june/collector/temp/aoetools-30/aoeping.c"
static struct progopts defaults  = 
#line 30 "/home/june/collector/temp/aoetools-30/aoeping.c"
     {0, 0, (char *)((void *)0), 0, 0, (u32 )0, (char *)((void *)0), (char)0, (char)0};
#line 41 "/home/june/collector/temp/aoetools-30/aoeping.c"
static struct progopts opts  ;
#line 48 "/home/june/collector/temp/aoetools-30/aoeping.c"
static struct smartcmd smarts[7]  = {      {(char *)"read_data", 208, (char)16}, 
        {(char *)"offline_immediate", 212, (char)0}, 
        {(char *)"read_log", 213, (char)16}, 
        {(char *)"write_log", 214, (char)1}, 
        {(char *)"enable", 216, (char)0}, 
        {(char *)"disable", 217, (char)0}, 
        {(char *)"return_status", 218, (char)0}};
#line 59 "/home/june/collector/temp/aoetools-30/aoeping.c"
static char *progname  ;
#line 60 "/home/june/collector/temp/aoetools-30/aoeping.c"
static int sfd___0  ;
#line 61 "/home/june/collector/temp/aoetools-30/aoeping.c"
static uchar mac___0[6]  ;
#line 63 "/home/june/collector/temp/aoetools-30/aoeping.c"
void usage(void) 
{ 


  {
  {
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage:\t%s [options] {shelf} {slot} {netif}\n",
          progname);
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n\t%s\n\t%s\n\t%s\n\t%s\n",
          "options:", "-i\tdo ATA device identify dump as raw hex", "-I\tdo ATA device identify print fields",
          "-v\tbe verbose", "-h\tshow this usage summary");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n\t%s\n\t%s\n\t%s\n",
          "options taking arguments:", "-s\ttimeout in seconds", "-S\tperform SMART command",
          "-t\tspecify number for starting AoE tag");
  }
#line 80
  return;
}
}
#line 82 "/home/june/collector/temp/aoetools-30/aoeping.c"
void hex_print(FILE *out , uchar *buf , int n , char *sep ) 
{ 
  int i ;
  int per_line ;
  uchar *tmp ;

  {
#line 86
  per_line = 16;
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i < n)) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp = buf;
#line 89
    buf ++;
#line 89
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%02x%s",
            (int )*tmp & 255, sep);
#line 90
    i ++;
    }
#line 90
    if (! (i % per_line)) {
      {
#line 91
      _IO_putc('\n', out);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/june/collector/temp/aoetools-30/aoeping.c"
void find_blade(Conf *c , struct progopts *opts___0 ) 
{ 
  int n ;
  uchar buf[1400] ;
  u32 tag ;
  Aoehdr *h ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 102
  h = & c->h;
#line 104
  memset((void *)h, 0, sizeof(*h));
#line 105
  memset((void *)(h->dst), 255, sizeof(h->dst));
#line 106
  memmove((void *)(h->src), (void const   *)(mac___0), sizeof(h->src));
#line 108
  h->type = htons((uint16_t )34978);
#line 109
  h->flags = (uchar )(1 << 4);
#line 110
  h->maj = htons((uint16_t )opts___0->shelf);
#line 111
  h->min = (uchar )opts___0->slot;
#line 112
  h->cmd = (uchar )1;
#line 113
  tag = htonl(opts___0->tag);
#line 114
  memmove((void *)(h->tag), (void const   *)(& tag), sizeof(h->tag));
#line 115
  c->bufcnt = (u16 )0;
#line 116
  c->firmware = (u16 )0;
#line 117
  c->scnt = (uchar )0;
#line 118
  c->vercmd = (uchar )0;
#line 119
  c->len = htons((uint16_t )1024);
#line 120
  memset((void *)(c->data), 237, sizeof(c->data));
#line 121
  tmp = write(sfd___0, (void const   *)c, sizeof(*c));
  }
#line 121
  if (tmp == -1L) {
    {
#line 122
    perror("send config query");
#line 123
    exit(1);
    }
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp___0 = read(sfd___0, (void *)(buf), sizeof(buf));
#line 126
    n = (int )tmp___0;
    }
#line 127
    if (n < 0) {
      {
#line 128
      perror("read network");
#line 129
      exit(1);
      }
    }
#line 131
    if (n < 60) {
#line 132
      goto __Cont;
    }
    {
#line 133
    h = (Aoehdr *)(buf);
#line 134
    tmp___1 = ntohs(h->type);
    }
#line 134
    if ((int )tmp___1 != 34978) {
#line 138
      goto __Cont;
    } else {
      {
#line 134
      tmp___2 = ntohs(h->maj);
      }
#line 134
      if ((int )tmp___2 != opts___0->shelf) {
#line 138
        goto __Cont;
      } else
#line 134
      if ((int )h->min != opts___0->slot) {
#line 138
        goto __Cont;
      } else {
        {
#line 134
        tmp___3 = memcmp((void const   *)(h->tag), (void const   *)(& tag), sizeof(h->tag));
        }
#line 134
        if (tmp___3) {
#line 138
          goto __Cont;
        }
      }
    }
#line 139
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (opts___0->verbose) {
    {
#line 142
    puts("config query response:");
#line 143
    hex_print(stdout, buf, n, (char *)" ");
#line 144
    putchar('\n');
    }
  }
  {
#line 146
  memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)(buf), sizeof(*c));
  }
#line 147
  return;
}
}
#line 151 "/home/june/collector/temp/aoetools-30/aoeping.c"
int aoe_pkt_read(uchar *buf , size_t siz , Conf *c , u32 tag ) 
{ 
  Aoehdr *h ;
  int n ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 157
  tag = htonl(tag);
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    tmp = read(sfd___0, (void *)buf, siz);
#line 159
    n = (int )tmp;
    }
#line 160
    if (n < 0) {
      {
#line 161
      perror("read network");
#line 162
      exit(1);
      }
    }
#line 164
    if (n < 60) {
#line 165
      goto __Cont;
    }
    {
#line 166
    h = (Aoehdr *)buf;
#line 167
    tmp___0 = ntohs(h->type);
    }
#line 167
    if ((int )tmp___0 != 34978) {
#line 171
      goto __Cont;
    } else
#line 167
    if ((int )h->maj != (int )c->h.maj) {
#line 171
      goto __Cont;
    } else
#line 167
    if ((int )h->min != (int )c->h.min) {
#line 171
      goto __Cont;
    } else {
      {
#line 167
      tmp___1 = memcmp((void const   *)(& tag), (void const   *)(h->tag), sizeof(h->tag));
      }
#line 167
      if (tmp___1) {
#line 171
        goto __Cont;
      }
    }
#line 172
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (n);
}
}
#line 179 "/home/june/collector/temp/aoetools-30/aoeping.c"
void ata_prep(Ata *a , Conf *c , u32 tag ) 
{ 


  {
  {
#line 182
  memset((void *)a, 0, sizeof(*a));
#line 183
  memcpy((void */* __restrict  */)(a->h.dst), (void const   */* __restrict  */)(c->h.src),
         sizeof(a->h.dst));
#line 184
  memcpy((void */* __restrict  */)(a->h.src), (void const   */* __restrict  */)(mac___0),
         sizeof(a->h.src));
#line 185
  a->h.type = htons((uint16_t )34978);
#line 186
  a->h.flags = (uchar )(1 << 4);
#line 187
  a->h.maj = c->h.maj;
#line 188
  a->h.min = c->h.min;
#line 189
  a->h.cmd = (uchar )0;
#line 190
  tag = htonl(tag);
#line 191
  memmove((void *)(a->h.tag), (void const   *)(& tag), sizeof(a->h.tag));
  }
#line 192
  return;
}
}
#line 197 "/home/june/collector/temp/aoetools-30/aoeping.c"
void pp_idtext(char *prefix , unsigned char *p , size_t len ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
  {
#line 202
  fputs((char const   */* __restrict  */)prefix, (FILE */* __restrict  */)stdout);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((size_t )i < len)) {
#line 203
      goto while_break;
    }
#line 204
    if ((int )*p == 0) {
#line 205
      goto while_break;
    }
    {
#line 206
    tmp = __ctype_b_loc();
    }
#line 206
    if (! ((int const   )*(*tmp + (int )*p) & 32768)) {
#line 206
      if ((int )*p != 32) {
#line 207
        goto while_break;
      }
    }
    {
#line 208
    putchar((int )*p);
#line 203
    i ++;
#line 203
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  putchar('\n');
  }
#line 211
  return;
}
}
#line 213 "/home/june/collector/temp/aoetools-30/aoeping.c"
int smart_supported(unsigned char *p ) 
{ 
  u16 w ;
  unsigned char *tmp ;

  {
#line 217
  p += 164;
#line 218
  tmp = p;
#line 218
  p ++;
#line 218
  w = (u16 )*tmp;
#line 219
  w = (u16 )((int )w | ((int )*p << 8));
#line 222
  return (! (! ((int )w & 1)));
}
}
#line 225 "/home/june/collector/temp/aoetools-30/aoeping.c"
void disk_identify(Conf *c , struct progopts *opts___0 , int *smart___0 ) 
{ 
  int n ;
  uchar buf[1400] ;
  Ata a ;
  Ata *p ;
  struct hd_driveid *id ;
  ssize_t tmp ;
  unsigned char ch ;

  {
  {
#line 234
  ata_prep(& a, c, opts___0->tag);
#line 235
  a.sectors = (uchar )1;
#line 236
  a.cmd = (uchar )236;
#line 237
  a.lba[3] = (uchar )160;
#line 239
  tmp = write(sfd___0, (void const   *)(& a), sizeof(a));
  }
#line 239
  if (tmp == -1L) {
    {
#line 240
    perror("send ATA identify device");
#line 241
    exit(1);
    }
  }
  {
#line 244
  n = aoe_pkt_read(buf, sizeof(buf), c, opts___0->tag);
#line 245
  p = (Ata *)(buf);
#line 247
  *smart___0 = smart_supported(p->data);
  }
#line 249
  if (opts___0->ata_ident) {
#line 249
    if (! opts___0->pp_ataid) {
      {
#line 250
      puts("device identify response:");
#line 251
      hex_print(stdout, p->data, 512, (char *)" ");
      }
#line 252
      return;
    }
  }
#line 254
  if (! opts___0->pp_ataid) {
#line 255
    return;
  }
#line 257
  n = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (n < 1024)) {
#line 257
      goto while_break;
    }
#line 259
    ch = p->data[n];
#line 260
    p->data[n] = p->data[n + 1];
#line 261
    p->data[n + 1] = ch;
#line 257
    n += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  id = (struct hd_driveid *)(p->data);
#line 264
  puts("device identify fields:");
#line 265
  printf((char const   */* __restrict  */)"vendor_specific_0: 0x%X\n", (int )id->vendor0);
#line 266
  printf((char const   */* __restrict  */)"vendor_specific_1: 0x%X\n", (int )id->vendor1);
#line 267
  printf((char const   */* __restrict  */)"vendor_specific_2: 0x%X\n", (int )id->vendor2);
#line 268
  pp_idtext((char *)"serial_number: ", id->serial_no, sizeof(id->serial_no));
#line 269
  pp_idtext((char *)"firmware_rev: ", id->fw_rev, sizeof(id->fw_rev));
#line 270
  pp_idtext((char *)"model: ", id->model, sizeof(id->model));
  }
#line 271
  return;
}
}
#line 273 "/home/june/collector/temp/aoetools-30/aoeping.c"
struct smartcmd *smartcmd_lookup(char *nam ) 
{ 
  int n ;
  int i ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  n = (int )(sizeof(smarts) / sizeof(smarts[0]));
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < n)) {
#line 279
      goto while_break;
    }
    {
#line 280
    tmp = strchr((char const   *)nam, ':');
#line 280
    p = tmp;
    }
#line 282
    if (p) {
      {
#line 282
      tmp___1 = strncmp((char const   *)smarts[i].name, (char const   *)nam, (size_t )(p - nam));
      }
#line 282
      if (tmp___1) {
#line 282
        goto _L;
      } else {
#line 283
        return (& smarts[i]);
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 284
      tmp___0 = strcmp((char const   *)smarts[i].name, (char const   *)nam);
      }
#line 284
      if (! tmp___0) {
#line 285
        return (& smarts[i]);
      }
    }
#line 279
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return ((struct smartcmd *)((void *)0));
}
}
#line 290 "/home/june/collector/temp/aoetools-30/aoeping.c"
void smart_registers(Ata *a , char *opts___0 , struct smartcmd *s ) 
{ 
  long tmp ;
  char *tmp___0 ;

  {
#line 293
  a->err = (uchar )s->cmd;
#line 294
  a->lba[1] = (uchar )79;
#line 295
  a->lba[2] = (uchar )194;
#line 296
  tmp___0 = opts___0;
#line 296
  opts___0 ++;
#line 296
  if (tmp___0) {
    {
#line 297
    tmp = strtol((char const   */* __restrict  */)opts___0, (char **/* __restrict  */)((void *)0),
                 0);
#line 297
    a->lba[0] = (uchar )tmp;
    }
  }
#line 298
  return;
}
}
#line 300 "/home/june/collector/temp/aoetools-30/aoeping.c"
int show_smart_regs(Ata *a ) 
{ 
  char *names[6] ;
  int regs[6] ;
  int i ;

  {
#line 303
  if ((int )a->err & 4) {
    {
#line 304
    fputs((char const   */* __restrict  */)"SMART command aborted on target.\n", (FILE */* __restrict  */)stderr);
    }
#line 306
    return (-1);
  }
  {
#line 309
  puts("ATA registers:");
#line 310
  names[0] = (char *)"Features";
#line 310
  names[1] = (char *)"Sector Count";
#line 310
  names[2] = (char *)"LBA Low";
#line 310
  names[3] = (char *)"LBA Mid";
#line 310
  names[4] = (char *)"LBA High";
#line 310
  names[5] = (char *)"Status";
#line 315
  regs[0] = (int )a->err;
#line 315
  regs[1] = (int )a->sectors;
#line 315
  regs[2] = (int )a->lba[0];
#line 315
  regs[3] = (int )a->lba[1];
#line 315
  regs[4] = (int )a->lba[2];
#line 315
  regs[5] = (int )a->cmd;
#line 322
  i = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! ((unsigned long )i < sizeof(regs) / sizeof(regs[0]))) {
#line 322
      goto while_break;
    }
    {
#line 323
    printf((char const   */* __restrict  */)"%20s: 0x%02x\n", names[i], regs[i]);
#line 322
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (0);
}
}
#line 328 "/home/june/collector/temp/aoetools-30/aoeping.c"
void smart(Conf *c , u32 tag , char *smart_cmd ) 
{ 
  int n ;
  uchar buf[1400] ;
  Ata a ;
  Ata *p ;
  struct smartcmd *s ;
  struct smartcmd *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 335
  tmp = smartcmd_lookup(smart_cmd);
#line 335
  s = tmp;
  }
#line 337
  if (! s) {
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s Error: no such SMART command: %s\n",
            progname, smart_cmd);
#line 341
    exit(1);
    }
  }
  {
#line 344
  ata_prep(& a, c, tag);
#line 345
  a.sectors = (uchar )(! (! s->data));
#line 346
  a.cmd = (uchar )176;
#line 347
  tmp___0 = strchr((char const   *)smart_cmd, ':');
#line 347
  smart_registers(& a, tmp___0, s);
  }
#line 348
  if ((int )s->data & 1) {
    {
#line 349
    tmp___1 = read(0, (void *)(a.data), (size_t )512);
    }
#line 349
    if (tmp___1 == -1L) {
      {
#line 350
      perror("reading smart data from stdin");
#line 351
      exit(1);
      }
    }
#line 353
    a.h.flags = (uchar )((int )a.h.flags | 1);
  }
  {
#line 356
  tmp___2 = write(sfd___0, (void const   *)(& a), sizeof(a));
  }
#line 356
  if (tmp___2 == -1L) {
    {
#line 357
    perror("send ATA identify device");
#line 358
    exit(1);
    }
  }
  {
#line 360
  n = aoe_pkt_read(buf, sizeof(buf), c, tag);
#line 361
  p = (Ata *)(buf);
#line 362
  tmp___3 = show_smart_regs(p);
  }
#line 362
  if (tmp___3 != 0) {
    {
#line 363
    exit(1);
    }
  }
#line 364
  if ((int )s->data & 16) {
    {
#line 365
    puts("SMART data:");
#line 366
    hex_print(stdout, p->data, 512, (char *)" ");
    }
  }
#line 368
  return;
}
}
#line 370 "/home/june/collector/temp/aoetools-30/aoeping.c"
void bad_option(char c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 373
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s Error: unrecognized option: ",
          progname);
#line 374
  tmp = __ctype_b_loc();
  }
#line 374
  if ((int const   )*(*tmp + (int )c) & 16384) {
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c\n",
            (int )c);
    }
  } else {
    {
#line 377
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%02x\n",
            (int )c & 255);
    }
  }
#line 378
  return;
}
}
#line 380 "/home/june/collector/temp/aoetools-30/aoeping.c"
void check_timeout(int secs ) 
{ 


  {
#line 383
  if (secs < 1) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s Error: timeout seconds must be one or more\n",
            progname);
#line 387
    exit(1);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/june/collector/temp/aoetools-30/aoeping.c"
void init_opts(struct progopts *opts___0 , int argc , char **argv ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 396
    c = getopt(argc, (char * const  *)argv, "hviIt:s:S:");
    }
#line 396
    if (! (c != -1)) {
#line 396
      goto while_break;
    }
    {
#line 398
    if (c == 104) {
#line 398
      goto case_104;
    }
#line 402
    if (c == 118) {
#line 402
      goto case_118;
    }
#line 405
    if (c == 105) {
#line 405
      goto case_105;
    }
#line 408
    if (c == 73) {
#line 408
      goto case_73;
    }
#line 412
    if (c == 116) {
#line 412
      goto case_116;
    }
#line 415
    if (c == 115) {
#line 415
      goto case_115;
    }
#line 419
    if (c == 83) {
#line 419
      goto case_83;
    }
#line 422
    if (c == 63) {
#line 422
      goto case_63;
    }
#line 427
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 399
    usage();
#line 400
    exit(0);
    }
#line 401
    goto switch_break;
    case_118: /* CIL Label */ 
#line 403
    (opts___0->verbose) ++;
#line 404
    goto switch_break;
    case_105: /* CIL Label */ 
#line 406
    opts___0->ata_ident = (char)1;
#line 407
    goto switch_break;
    case_73: /* CIL Label */ 
#line 409
    opts___0->ata_ident = (char)1;
#line 410
    opts___0->pp_ataid = (char)1;
#line 411
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 413
    tmp = atoi((char const   *)optarg);
#line 413
    opts___0->tag = (u32 )tmp;
    }
#line 414
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 416
    opts___0->timeout = atoi((char const   *)optarg);
#line 417
    check_timeout(opts___0->timeout);
    }
#line 418
    goto switch_break;
    case_83: /* CIL Label */ 
#line 420
    opts___0->smart = optarg;
#line 421
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 423
    bad_option((char )optopt);
#line 424
    usage();
#line 425
    exit(1);
    }
#line 426
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 428
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if (argc - optind != 3) {
    {
#line 432
    usage();
#line 433
    exit(1);
    }
  }
  {
#line 435
  opts___0->shelf = atoi((char const   *)*(argv + optind));
#line 436
  opts___0->slot = atoi((char const   *)*(argv + (optind + 1)));
#line 437
  opts___0->netif = *(argv + (optind + 2));
  }
#line 438
  return;
}
}
#line 440 "/home/june/collector/temp/aoetools-30/aoeping.c"
int main(int argc , char **argv ) 
{ 
  Conf c ;
  int smartable ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 444
  smartable = 0;
#line 446
  opts = defaults;
#line 447
  progname = strrchr((char const   *)*(argv + 0), '/');
  }
#line 448
  if (progname) {
#line 449
    progname ++;
  } else {
#line 451
    progname = *(argv + 0);
  }
  {
#line 453
  init_opts(& opts, argc, argv);
#line 454
  opts.tag = (u32 )((unsigned long )opts.tag | (1UL << 31));
  }
#line 456
  if (opts.verbose) {
    {
#line 457
    printf((char const   */* __restrict  */)"tag: %x\neth: %s\nshelf: %u\nslot: %u\n",
           opts.tag, opts.netif, opts.shelf, opts.slot);
#line 459
    fflush(stdout);
    }
  }
  {
#line 461
  sfd___0 = dial(opts.netif);
#line 462
  tmp = getea(sfd___0, opts.netif, mac___0);
  }
#line 462
  if (! tmp) {
    {
#line 463
    exit(1);
    }
  }
  {
#line 465
  alarm((unsigned int )opts.timeout);
#line 466
  find_blade(& c, & opts);
#line 467
  (opts.tag) ++;
#line 468
  alarm(0U);
  }
#line 469
  if (opts.verbose) {
    {
#line 470
    tmp___0 = ntohs(c.h.maj);
#line 470
    printf((char const   */* __restrict  */)"found e%d.%d with mac ", (int )tmp___0,
           (int )c.h.min);
#line 472
    hex_print(stdout, c.h.src, (int )sizeof(c.h.src), (char *)"");
#line 473
    putchar('\n');
#line 474
    fflush(stdout);
    }
  }
#line 477
  if (opts.ata_ident) {
    {
#line 478
    alarm((unsigned int )opts.timeout);
#line 479
    disk_identify(& c, & opts, & smartable);
#line 480
    alarm(0U);
#line 481
    (opts.tag) ++;
    }
  } else
#line 477
  if (opts.smart) {
    {
#line 478
    alarm((unsigned int )opts.timeout);
#line 479
    disk_identify(& c, & opts, & smartable);
#line 480
    alarm(0U);
#line 481
    (opts.tag) ++;
    }
  }
#line 484
  if (opts.smart) {
#line 485
    if (! smartable) {
      {
#line 486
      tmp___1 = ntohs(c.h.maj);
#line 486
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: e%d.%d does not support SMART\n",
              (int )tmp___1, (int )c.h.min);
#line 489
      exit(1);
      }
    }
    {
#line 491
    alarm((unsigned int )opts.timeout);
#line 492
    smart(& c, opts.tag, opts.smart);
#line 493
    alarm(0U);
#line 494
    (opts.tag) ++;
    }
  }
#line 497
  return (0);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 31 "/home/june/collector/temp/aoetools-30/linux.c"
static int getindx(int s , char *name ) 
{ 
  struct ifreq xx ;
  int n ;

  {
  {
#line 37
  strcpy((char */* __restrict  */)(xx.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)name);
#line 38
  n = ioctl(s, 35123UL, & xx);
  }
#line 39
  if (n == -1) {
#line 40
    return (-1);
  }
#line 41
  return (xx.ifr_ifru.ifru_ivalue);
}
}
#line 44 "/home/june/collector/temp/aoetools-30/linux.c"
int dial(char *eth ) 
{ 
  int i ;
  int n ;
  int s ;
  struct sockaddr_ll sa ;
  uint16_t tmp ;

  {
  {
#line 52
  memset((void *)(& sa), 0, sizeof(sa));
#line 53
  tmp = htons((uint16_t )34978);
#line 53
  s = socket(17, 3, (int )tmp);
  }
#line 54
  if (s == -1) {
    {
#line 55
    perror("got bad socket");
    }
#line 56
    return (-1);
  }
  {
#line 58
  i = getindx(s, eth);
#line 59
  sa.sll_family = (unsigned short)17;
#line 60
  sa.sll_protocol = htons((uint16_t )34978);
#line 61
  sa.sll_ifindex = i;
#line 62
  n = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 63
  if (n == -1) {
    {
#line 64
    perror("bind funky");
    }
#line 65
    return (-1);
  }
#line 67
  return (s);
}
}
#line 70 "/home/june/collector/temp/aoetools-30/linux.c"
int getea(int s , char *name , uchar *ea ) 
{ 
  struct ifreq xx ;
  int n ;

  {
  {
#line 76
  strcpy((char */* __restrict  */)(xx.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)name);
#line 77
  n = ioctl(s, 35111UL, & xx);
  }
#line 78
  if (n == -1) {
    {
#line 79
    perror("Can\'t get hw addr");
    }
#line 80
    return (0);
  }
  {
#line 82
  memmove((void *)ea, (void const   *)(xx.ifr_ifru.ifru_hwaddr.sa_data), (size_t )6);
  }
#line 83
  return (1);
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 19 "/home/june/collector/temp/aoetools-30/aoecfg.c"
int sfd  ;
#line 20 "/home/june/collector/temp/aoetools-30/aoecfg.c"
uchar mac[6]  ;
#line 21 "/home/june/collector/temp/aoetools-30/aoecfg.c"
int timeout  ;
#line 22 "/home/june/collector/temp/aoetools-30/aoecfg.c"
u16 shelf  =    (u16 )65535;
#line 23 "/home/june/collector/temp/aoetools-30/aoecfg.c"
uchar slot  =    (uchar )255;
#line 24 "/home/june/collector/temp/aoetools-30/aoecfg.c"
char *net  =    (char *)"eth0";
#line 25 "/home/june/collector/temp/aoetools-30/aoecfg.c"
char *cfgstr  ;
#line 26 "/home/june/collector/temp/aoetools-30/aoecfg.c"
int cfgstrlen  ;
#line 28 "/home/june/collector/temp/aoetools-30/aoecfg.c"
char *errtab[7]  = {      (char *)"*GOK*",      (char *)"*badcmd*",      (char *)"*badarg*",      (char *)"*baddev*", 
        (char *)"*badcfg*",      (char *)"*badvers*",      (char *)"*GOK*"};
#line 38 "/home/june/collector/temp/aoetools-30/aoecfg.c"
void resp(Conf *c ) 
{ 
  Aoehdr *h ;
  char *s ;
  int l ;
  size_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 45
  h = (Aoehdr *)c;
#line 46
  if ((int )h->flags & 4) {
    {
#line 47
    s = errtab[(int )h->error & 7];
#line 48
    tmp = strlen((char const   *)s);
#line 48
    l = (int )tmp;
    }
  } else {
    {
#line 50
    s = (char *)(c->data);
#line 51
    tmp___0 = ntohs(c->len);
#line 51
    l = (int )tmp___0;
    }
  }
#line 53
  if ((int )shelf != 65535) {
#line 53
    if ((int )slot != 255) {
      {
#line 54
      printf((char const   */* __restrict  */)"%.*s\n", l, s);
      }
    } else {
      {
#line 56
      tmp___1 = ntohs(h->maj);
#line 56
      printf((char const   */* __restrict  */)"%d.%d\t%.*s\n", (int )tmp___1, (int )h->min,
             l, s);
      }
    }
  } else {
    {
#line 56
    tmp___1 = ntohs(h->maj);
#line 56
    printf((char const   */* __restrict  */)"%d.%d\t%.*s\n", (int )tmp___1, (int )h->min,
           l, s);
    }
  }
#line 57
  return;
}
}
#line 64 "/home/june/collector/temp/aoetools-30/aoecfg.c"
static int to  ;
#line 59 "/home/june/collector/temp/aoetools-30/aoecfg.c"
int readto(int fd , void *buf , int size ) 
{ 
  fd_set rfd ;
  struct timeval tv ;
  time_t tmp ;
  int __d0 ;
  int __d1 ;
  time_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 66
  if (timeout == 0) {
#line 67
    goto f1;
  }
#line 68
  if (to == 0) {
    {
#line 69
    tmp = time((time_t *)0);
#line 69
    to = (int )(tmp + (time_t )timeout);
    }
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfd.__fds_bits[0]): "memory");
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  rfd.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 73
  tmp___0 = time((time_t *)0);
#line 73
  tv.tv_sec = (time_t )to - tmp___0;
#line 74
  tv.tv_usec = (__suseconds_t )0;
#line 76
  tmp___1 = select(fd + 1, (fd_set */* __restrict  */)(& rfd), (fd_set */* __restrict  */)0,
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
  }
  {
#line 77
  if (tmp___1 == -1) {
#line 77
    goto case_neg_1;
  }
#line 80
  if (tmp___1 == 0) {
#line 80
    goto case_0;
  }
#line 76
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 78
  perror("select");
#line 79
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 81
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
  f1: 
  {
#line 84
  tmp___2 = read(fd, buf, (size_t )size);
  }
#line 84
  return ((int )tmp___2);
}
}
#line 87 "/home/june/collector/temp/aoetools-30/aoecfg.c"
u32 aoe_tag(void) 
{ 
  u32 n ;
  struct timeval t ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 91
  t.tv_sec = (__time_t )0;
#line 91
  t.tv_usec = (__suseconds_t )0;
#line 97
  tmp = gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )((void *)0));
  }
#line 97
  if (tmp) {
    {
#line 98
    perror("gettimeofday");
#line 99
    exit(1);
    }
  }
  {
#line 101
  n = (u32 )((unsigned long )t.tv_usec | (1UL << 31));
#line 102
  tmp___0 = htonl(n);
  }
#line 102
  return (tmp___0);
}
}
#line 105 "/home/june/collector/temp/aoetools-30/aoecfg.c"
void cfgquery(int cmd , int shelf___0 , int slot___0 ) 
{ 
  int n ;
  Aoehdr *h ;
  Conf *c ;
  uchar buf[1024UL + sizeof(*h)] ;
  u32 tag ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 114
  c = (Conf *)(buf);
#line 115
  h = (Aoehdr *)c;
#line 116
  memset((void *)h, 0, sizeof(*h));
#line 117
  memset((void *)(h->dst), 255, sizeof(h->dst));
#line 118
  memmove((void *)(h->src), (void const   *)(mac), sizeof(h->src));
#line 120
  h->type = htons((uint16_t )34978);
#line 121
  h->flags = (uchar )(1 << 4);
#line 122
  h->maj = htons((uint16_t )shelf___0);
#line 123
  h->min = (uchar )slot___0;
#line 124
  h->cmd = (uchar )1;
#line 125
  tag = aoe_tag();
#line 126
  memmove((void *)(h->tag), (void const   *)(& tag), sizeof(h->tag));
#line 127
  c->bufcnt = (u16 )0;
#line 128
  c->firmware = (u16 )0;
#line 129
  c->scnt = (uchar )0;
#line 130
  c->vercmd = (uchar )cmd;
#line 131
  memmove((void *)(c->data), (void const   *)cfgstr, (size_t )cfgstrlen);
#line 132
  c->len = htons((uint16_t )cfgstrlen);
#line 133
  tmp = write(sfd, (void const   *)c, sizeof(*c));
  }
#line 133
  if (tmp == -1L) {
    {
#line 134
    perror("send config query");
#line 135
    exit(1);
    }
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 138
    n = readto(sfd, (void *)(buf), (int )sizeof(buf));
    }
#line 139
    if (n < 0) {
      {
#line 140
      perror("read network");
#line 141
      exit(1);
      }
    }
#line 143
    if (n < 60) {
#line 144
      goto __Cont;
    }
    {
#line 145
    h = (Aoehdr *)(buf);
#line 146
    tmp___0 = ntohs(h->type);
    }
#line 146
    if ((int )tmp___0 != 34978) {
#line 147
      goto __Cont;
    }
    {
#line 148
    tmp___1 = ntohs(h->maj);
    }
#line 148
    if ((int )tmp___1 == 65535) {
#line 149
      goto __Cont;
    } else
#line 148
    if ((int )h->min == 255) {
#line 149
      goto __Cont;
    }
#line 150
    if (shelf___0 != 65535) {
      {
#line 150
      tmp___2 = ntohs(h->maj);
      }
#line 150
      if ((int )tmp___2 != shelf___0) {
#line 151
        goto __Cont;
      }
    }
#line 152
    if (slot___0 != 255) {
#line 152
      if ((int )h->min != slot___0) {
#line 153
        goto __Cont;
      }
    }
    {
#line 154
    tmp___3 = memcmp((void const   *)(h->tag), (void const   *)(& tag), sizeof(h->tag));
    }
#line 154
    if (tmp___3) {
#line 155
      goto __Cont;
    }
    {
#line 156
    resp((Conf *)(buf));
    }
#line 157
    if (shelf___0 != 65535) {
#line 157
      if (slot___0 != 255) {
#line 158
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 176 "/home/june/collector/temp/aoetools-30/aoecfg.c"
Tab tab[5]  = {      {(char *)"read", 0}, 
        {(char *)"test", 1}, 
        {(char *)"prefix", 2}, 
        {(char *)"set", 3}, 
        {(char *)"fset", 4}};
#line 184 "/home/june/collector/temp/aoetools-30/aoecfg.c"
int xlatecmd(char *s ) 
{ 
  int i ;
  int tmp ;

  {
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((unsigned long )i < sizeof(tab) / sizeof(tab[0]))) {
#line 189
      goto while_break;
    }
    {
#line 190
    tmp = strcmp((char const   *)tab[i].s, (char const   *)s);
    }
#line 190
    if (tmp == 0) {
#line 191
      return (tab[i].cmd);
    }
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  usage();
  }
#line 193
  return (-1);
}
}
#line 31 "/home/june/collector/temp/aoetools-30/linux.c"
static int getindx___0(int s , char *name ) 
{ 
  struct ifreq xx ;
  int n ;

  {
  {
#line 37
  strcpy((char */* __restrict  */)(xx.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)name);
#line 38
  n = ioctl(s, 35123UL, & xx);
  }
#line 39
  if (n == -1) {
#line 40
    return (-1);
  }
#line 41
  return (xx.ifr_ifru.ifru_ivalue);
}
}
