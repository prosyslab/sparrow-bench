/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 32 "../datrie/typedefs.h"
enum __anonenum_Bool_25 {
    FALSE = 0,
    TRUE = 1
} ;
#line 32 "../datrie/typedefs.h"
typedef enum __anonenum_Bool_25 Bool;
#line 79 "../datrie/typedefs.h"
typedef unsigned int uint32;
#line 86 "../datrie/typedefs.h"
typedef int int32;
#line 51 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/triedefs.h"
typedef unsigned char TrieChar;
#line 61 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/triedefs.h"
typedef int32 TrieIndex;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.h"
struct _TrieString;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.h"
typedef struct _TrieString TrieString;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.h"
struct _Symbols;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.h"
typedef struct _Symbols Symbols;
#line 52
struct _DArray;
#line 52 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.h"
typedef struct _DArray DArray;
#line 42 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
struct _Symbols {
   short num_symbols ;
   TrieChar symbols[256] ;
};
#line 151 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
struct __anonstruct_DACell_26 {
   TrieIndex base ;
   TrieIndex check ;
};
#line 151 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
typedef struct __anonstruct_DACell_26 DACell;
#line 156 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
struct _DArray {
   TrieIndex num_cells ;
   DACell *cells ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.h"
struct _DString;
#line 32 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.h"
typedef struct _DString DString;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring-private.h"
struct _DString {
   int char_size ;
   int str_len ;
   int alloc_size ;
   void *val ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
struct _TrieString {
   DString ds ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/triedefs.h"
typedef uint32 AlphaChar;
#line 66 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.h"
struct _AlphaMap;
#line 66 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.h"
typedef struct _AlphaMap AlphaMap;
#line 83 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
struct _AlphaRange {
   struct _AlphaRange *next ;
   AlphaChar begin ;
   AlphaChar end ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
typedef struct _AlphaRange AlphaRange;
#line 90 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
struct _AlphaMap {
   AlphaRange *first_range ;
};
#line 72 "../datrie/typedefs.h"
typedef short int16;
#line 74 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/triedefs.h"
typedef int32 TrieData;
#line 40 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.h"
struct _Tail;
#line 40 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.h"
typedef struct _Tail Tail;
#line 58 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
struct __anonstruct_TailBlock_26 {
   TrieIndex next_free ;
   TrieData data ;
   TrieChar *suffix ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
typedef struct __anonstruct_TailBlock_26 TailBlock;
#line 64 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
struct _Tail {
   TrieIndex num_tails ;
   TailBlock *tails ;
   TrieIndex first_free ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.h"
struct _Trie;
#line 85 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.h"
typedef struct _Trie Trie;
#line 103
struct _TrieState;
#line 103 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.h"
typedef struct _TrieState TrieState;
#line 109
struct _TrieIterator;
#line 109 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.h"
typedef struct _TrieIterator TrieIterator;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
struct _Trie {
   AlphaMap *alpha_map ;
   DArray *da ;
   Tail *tail ;
   Bool is_dirty ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
struct _TrieState {
   Trie const   *trie ;
   TrieIndex index ;
   short suffix_idx ;
   short is_suffix ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
struct _TrieIterator {
   TrieState const   *root ;
   TrieState *state ;
   TrieString *key ;
};
#line 44 "../datrie/typedefs.h"
typedef signed char int8;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
struct __anonstruct_ProgEnv_28 {
   char const   *path ;
   char const   *trie_name ;
   iconv_t to_alpha_conv ;
   iconv_t from_alpha_conv ;
   Trie *trie ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
typedef struct __anonstruct_ProgEnv_28 ProgEnv;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.h"
Bool trie_string_append_char(TrieString *ts , TrieChar tc ) ;
#line 57
Bool trie_string_cut_last(TrieString *ts ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.h"
Symbols *symbols_new(void) ;
#line 44
void symbols_free(Symbols *syms ) ;
#line 45
void symbols_add(Symbols *syms , TrieChar c ) ;
#line 46
int symbols_num(Symbols const   *syms ) ;
#line 47
TrieChar symbols_get(Symbols const   *syms , int index___0 ) ;
#line 55
DArray *da_new(void) ;
#line 57
DArray *da_fread(FILE *file ) ;
#line 59
void da_free(DArray *d ) ;
#line 61
int da_fwrite(DArray const   *d , FILE *file ) ;
#line 64
TrieIndex da_get_root(DArray const   *d ) ;
#line 67
TrieIndex da_get_base(DArray const   *d , TrieIndex s ) ;
#line 69
TrieIndex da_get_check(DArray const   *d , TrieIndex s ) ;
#line 72
void da_set_base(DArray *d , TrieIndex s , TrieIndex val ) ;
#line 74
void da_set_check(DArray *d , TrieIndex s , TrieIndex val ) ;
#line 76
Bool da_walk(DArray const   *d , TrieIndex *s , TrieChar c ) ;
#line 78
Symbols *da_output_symbols(DArray const   *d , TrieIndex s ) ;
#line 97
TrieIndex da_insert_branch(DArray *d , TrieIndex s , TrieChar c ) ;
#line 99
void da_prune(DArray *d , TrieIndex s ) ;
#line 101
void da_prune_upto(DArray *d , TrieIndex p , TrieIndex s ) ;
#line 103
TrieIndex da_first_separate(DArray *d , TrieIndex root , TrieString *keybuff ) ;
#line 105
TrieIndex da_next_separate(DArray *d , TrieIndex root , TrieIndex sep , TrieString *keybuff ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.h"
Bool file_read_int32(FILE *file , int32 *o_val ) ;
#line 34
Bool file_write_int32(FILE *file , int32 val ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_check_free_cell(DArray *d , TrieIndex s ) ;
#line 58
static Bool da_has_children(DArray const   *d , TrieIndex s ) ;
#line 61
static TrieIndex da_find_free_base(DArray *d , Symbols const   *symbols ) ;
#line 64
static Bool da_fit_symbols(DArray *d , TrieIndex base , Symbols const   *symbols ) ;
#line 68
static void da_relocate_base(DArray *d , TrieIndex s , TrieIndex new_base ) ;
#line 72
static Bool da_extend_pool(DArray *d , TrieIndex to_index ) ;
#line 75
static void da_alloc_cell(DArray *d , TrieIndex cell ) ;
#line 78
static void da_free_cell(DArray *d , TrieIndex cell ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
Symbols *symbols_new(void) 
{ 
  Symbols *syms ;
  void *tmp ;

  {
  {
#line 92
  tmp = malloc(sizeof(Symbols ));
#line 92
  syms = (Symbols *)tmp;
  }
#line 94
  if (! syms) {
#line 95
    return ((Symbols *)((void *)0));
  }
#line 97
  syms->num_symbols = (short)0;
#line 99
  return (syms);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void symbols_free(Symbols *syms ) 
{ 


  {
  {
#line 105
  free((void *)syms);
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void symbols_add(Symbols *syms , TrieChar c ) 
{ 
  short lower ;
  short upper ;
  short middle ;

  {
#line 113
  lower = (short)0;
#line 114
  upper = syms->num_symbols;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((int )lower < (int )upper)) {
#line 115
      goto while_break;
    }
#line 118
    middle = (short )(((int )lower + (int )upper) / 2);
#line 119
    if ((int )c > (int )syms->symbols[middle]) {
#line 120
      lower = (short )((int )middle + 1);
    } else
#line 121
    if ((int )c < (int )syms->symbols[middle]) {
#line 122
      upper = middle;
    } else {
#line 124
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if ((int )lower < (int )syms->num_symbols) {
    {
#line 127
    memmove((void *)((syms->symbols + (int )lower) + 1), (void const   *)(syms->symbols + (int )lower),
            (size_t )((int )syms->num_symbols - (int )lower));
    }
  }
#line 130
  syms->symbols[lower] = c;
#line 131
  syms->num_symbols = (short )((int )syms->num_symbols + 1);
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
int symbols_num(Symbols const   *syms ) 
{ 


  {
#line 137
  return ((int )syms->num_symbols);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieChar symbols_get(Symbols const   *syms , int index___0 ) 
{ 


  {
#line 143
  return (syms->symbols[index___0]);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
DArray *da_new(void) 
{ 
  DArray *d ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 185
  tmp = malloc(sizeof(DArray ));
#line 185
  d = (DArray *)tmp;
  }
#line 186
  if (! d) {
#line 187
    return ((DArray *)((void *)0));
  }
  {
#line 189
  d->num_cells = 3;
#line 190
  tmp___0 = malloc((unsigned long )d->num_cells * sizeof(DACell ));
#line 190
  d->cells = (DACell *)tmp___0;
  }
#line 191
  if (! d->cells) {
#line 192
    goto exit_da_created;
  }
#line 193
  (d->cells + 0)->base = (TrieIndex )3674004220U;
#line 194
  (d->cells + 0)->check = d->num_cells;
#line 195
  (d->cells + 1)->base = -1;
#line 196
  (d->cells + 1)->check = -1;
#line 197
  (d->cells + 2)->base = 3;
#line 198
  (d->cells + 2)->check = 0;
#line 200
  return (d);
  exit_da_created: 
  {
#line 203
  free((void *)d);
  }
#line 204
  return ((DArray *)((void *)0));
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
DArray *da_fread(FILE *file ) 
{ 
  long save_pos ;
  DArray *d ;
  TrieIndex n ;
  Bool tmp ;
  void *tmp___0 ;
  Bool tmp___1 ;
  void *tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;

  {
  {
#line 222
  d = (DArray *)((void *)0);
#line 226
  save_pos = ftell(file);
#line 227
  tmp = file_read_int32(file, & n);
  }
#line 227
  if (tmp) {
#line 227
    if (3674004220U != (uint32 )n) {
#line 228
      goto exit_file_read;
    }
  } else {
#line 228
    goto exit_file_read;
  }
  {
#line 230
  tmp___0 = malloc(sizeof(DArray ));
#line 230
  d = (DArray *)tmp___0;
  }
#line 230
  if ((unsigned long )((void *)0) == (unsigned long )d) {
#line 231
    goto exit_file_read;
  }
  {
#line 234
  tmp___1 = file_read_int32(file, & d->num_cells);
  }
#line 234
  if (! tmp___1) {
#line 235
    goto exit_da_created;
  }
#line 236
  if ((unsigned long )d->num_cells > 0xffffffffffffffffUL / sizeof(DACell )) {
#line 237
    goto exit_da_created;
  }
  {
#line 238
  tmp___2 = malloc((unsigned long )d->num_cells * sizeof(DACell ));
#line 238
  d->cells = (DACell *)tmp___2;
  }
#line 239
  if (! d->cells) {
#line 240
    goto exit_da_created;
  }
#line 241
  (d->cells + 0)->base = (TrieIndex )3674004220U;
#line 242
  (d->cells + 0)->check = d->num_cells;
#line 243
  n = 1;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (n < d->num_cells)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp___3 = file_read_int32(file, & (d->cells + n)->base);
    }
#line 244
    if (tmp___3) {
      {
#line 244
      tmp___4 = file_read_int32(file, & (d->cells + n)->check);
      }
#line 244
      if (! tmp___4) {
#line 247
        goto exit_da_cells_created;
      }
    } else {
#line 247
      goto exit_da_cells_created;
    }
#line 243
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return (d);
  exit_da_cells_created: 
  {
#line 254
  free((void *)d->cells);
  }
  exit_da_created: 
  {
#line 256
  free((void *)d);
  }
  exit_file_read: 
  {
#line 258
  fseek(file, save_pos, 0);
  }
#line 259
  return ((DArray *)((void *)0));
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void da_free(DArray *d ) 
{ 


  {
  {
#line 272
  free((void *)d->cells);
#line 273
  free((void *)d);
  }
#line 274
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
int da_fwrite(DArray const   *d , FILE *file ) 
{ 
  TrieIndex i ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < (TrieIndex )d->num_cells)) {
#line 293
      goto while_break;
    }
    {
#line 294
    tmp = file_write_int32(file, (d->cells + i)->base);
    }
#line 294
    if (tmp) {
      {
#line 294
      tmp___0 = file_write_int32(file, (d->cells + i)->check);
      }
#line 294
      if (! tmp___0) {
#line 297
        return (-1);
      }
    } else {
#line 297
      return (-1);
    }
#line 293
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_get_root(DArray const   *d ) 
{ 


  {
#line 318
  return (2);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_get_base(DArray const   *d , TrieIndex s ) 
{ 
  TrieIndex tmp ;

  {
#line 335
  if (s < (TrieIndex )d->num_cells) {
#line 335
    tmp = (d->cells + s)->base;
  } else {
#line 335
    tmp = 0;
  }
#line 335
  return (tmp);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_get_check(DArray const   *d , TrieIndex s ) 
{ 
  TrieIndex tmp ;

  {
#line 351
  if (s < (TrieIndex )d->num_cells) {
#line 351
    tmp = (d->cells + s)->check;
  } else {
#line 351
    tmp = 0;
  }
#line 351
  return (tmp);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void da_set_base(DArray *d , TrieIndex s , TrieIndex val ) 
{ 


  {
#line 367
  if (s < d->num_cells) {
#line 368
    (d->cells + s)->base = val;
  }
#line 370
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void da_set_check(DArray *d , TrieIndex s , TrieIndex val ) 
{ 


  {
#line 384
  if (s < d->num_cells) {
#line 385
    (d->cells + s)->check = val;
  }
#line 387
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
Bool da_walk(DArray const   *d , TrieIndex *s , TrieChar c ) 
{ 
  TrieIndex next ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;

  {
  {
#line 408
  tmp = da_get_base(d, *s);
#line 408
  next = tmp + (TrieIndex )c;
#line 409
  tmp___0 = da_get_check(d, next);
  }
#line 409
  if (tmp___0 == *s) {
#line 410
    *s = next;
#line 411
    return ((Bool )1);
  }
#line 413
  return ((Bool )0);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_insert_branch(DArray *d , TrieIndex s , TrieChar c ) 
{ 
  TrieIndex base ;
  TrieIndex next ;
  TrieIndex tmp ;
  Symbols *symbols ;
  TrieIndex new_base ;
  Bool tmp___0 ;
  Symbols *symbols___0 ;
  TrieIndex new_base___0 ;

  {
  {
#line 434
  base = da_get_base((DArray const   *)d, s);
  }
#line 436
  if (base > 0) {
    {
#line 437
    next = base + (TrieIndex )c;
#line 440
    tmp = da_get_check((DArray const   *)d, next);
    }
#line 440
    if (tmp == s) {
#line 441
      return (next);
    }
#line 446
    if (base > 2147483647 - (int )c) {
#line 446
      goto _L;
    } else {
      {
#line 446
      tmp___0 = da_check_free_cell(d, next);
      }
#line 446
      if (! tmp___0) {
        _L: /* CIL Label */ 
        {
#line 451
        symbols = da_output_symbols((DArray const   *)d, s);
#line 452
        symbols_add(symbols, c);
#line 453
        new_base = da_find_free_base(d, (Symbols const   *)symbols);
#line 454
        symbols_free(symbols);
        }
#line 456
        if (0 == new_base) {
#line 457
          return (0);
        }
        {
#line 459
        da_relocate_base(d, s, new_base);
#line 460
        next = new_base + (TrieIndex )c;
        }
      }
    }
  } else {
    {
#line 466
    symbols___0 = symbols_new();
#line 467
    symbols_add(symbols___0, c);
#line 468
    new_base___0 = da_find_free_base(d, (Symbols const   *)symbols___0);
#line 469
    symbols_free(symbols___0);
    }
#line 471
    if (0 == new_base___0) {
#line 472
      return (0);
    }
    {
#line 474
    da_set_base(d, s, new_base___0);
#line 475
    next = new_base___0 + (TrieIndex )c;
    }
  }
  {
#line 477
  da_alloc_cell(d, next);
#line 478
  da_set_check(d, next, s);
  }
#line 480
  return (next);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_check_free_cell(DArray *d , TrieIndex s ) 
{ 
  Bool tmp ;
  TrieIndex tmp___0 ;
  int tmp___1 ;

  {
  {
#line 487
  tmp = da_extend_pool(d, s);
  }
#line 487
  if (tmp) {
    {
#line 487
    tmp___0 = da_get_check((DArray const   *)d, s);
    }
#line 487
    if (tmp___0 < 0) {
#line 487
      tmp___1 = 1;
    } else {
#line 487
      tmp___1 = 0;
    }
  } else {
#line 487
    tmp___1 = 0;
  }
#line 487
  return ((Bool )tmp___1);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_has_children(DArray const   *d , TrieIndex s ) 
{ 
  TrieIndex base ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp ;

  {
  {
#line 497
  base = da_get_base(d, s);
  }
#line 498
  if (0 == base) {
#line 499
    return ((Bool )0);
  } else
#line 498
  if (base < 0) {
#line 499
    return ((Bool )0);
  }
#line 501
  if (255 < (int )(d->num_cells - (TrieIndex const   )base)) {
#line 501
    max_c = 255;
  } else {
#line 501
    max_c = (TrieIndex )(d->num_cells - (TrieIndex const   )base);
  }
#line 502
  c = 0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (c <= max_c)) {
#line 502
      goto while_break;
    }
    {
#line 503
    tmp = da_get_check(d, base + c);
    }
#line 503
    if (tmp == s) {
#line 504
      return ((Bool )1);
    }
#line 502
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  return ((Bool )0);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
Symbols *da_output_symbols(DArray const   *d , TrieIndex s ) 
{ 
  Symbols *syms ;
  TrieIndex base ;
  TrieIndex c ;
  TrieIndex max_c ;
  short tmp ;
  TrieIndex tmp___0 ;

  {
  {
#line 518
  syms = symbols_new();
#line 520
  base = da_get_base(d, s);
  }
#line 521
  if (255 < (int )(d->num_cells - (TrieIndex const   )base)) {
#line 521
    max_c = 255;
  } else {
#line 521
    max_c = (TrieIndex )(d->num_cells - (TrieIndex const   )base);
  }
#line 522
  c = 0;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! (c <= max_c)) {
#line 522
      goto while_break;
    }
    {
#line 523
    tmp___0 = da_get_check(d, base + c);
    }
#line 523
    if (tmp___0 == s) {
#line 524
      tmp = syms->num_symbols;
#line 524
      syms->num_symbols = (short )((int )syms->num_symbols + 1);
#line 524
      syms->symbols[tmp] = (TrieChar )c;
    }
#line 522
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  return (syms);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static TrieIndex da_find_free_base(DArray *d , Symbols const   *symbols ) 
{ 
  TrieChar first_sym ;
  TrieIndex s ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  Bool tmp___1 ;
  TrieIndex tmp___2 ;
  Bool tmp___3 ;
  TrieIndex tmp___4 ;
  TrieIndex tmp___5 ;
  Bool tmp___6 ;

  {
  {
#line 538
  first_sym = symbols_get(symbols, 0);
#line 539
  tmp = da_get_check((DArray const   *)d, 1);
#line 539
  s = - tmp;
  }
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (s != 1) {
#line 540
      if (! (s < (TrieIndex )first_sym + 3)) {
#line 540
        goto while_break;
      }
    } else {
#line 540
      goto while_break;
    }
    {
#line 543
    tmp___0 = da_get_check((DArray const   *)d, s);
#line 543
    s = - tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  if (s == 1) {
#line 546
    s = (int )first_sym + 3;
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 547
      tmp___1 = da_extend_pool(d, s);
      }
#line 547
      if (! tmp___1) {
#line 548
        return (0);
      }
      {
#line 549
      tmp___2 = da_get_check((DArray const   *)d, s);
      }
#line 549
      if (tmp___2 < 0) {
#line 550
        goto while_break___0;
      }
#line 546
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 555
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 555
    tmp___6 = da_fit_symbols(d, s - (TrieIndex )first_sym, symbols);
    }
#line 555
    if (tmp___6) {
#line 555
      goto while_break___1;
    }
    {
#line 557
    tmp___4 = da_get_check((DArray const   *)d, s);
    }
#line 557
    if (- tmp___4 == 1) {
      {
#line 558
      tmp___3 = da_extend_pool(d, d->num_cells);
      }
#line 558
      if (! tmp___3) {
#line 559
        return (0);
      }
    }
    {
#line 562
    tmp___5 = da_get_check((DArray const   *)d, s);
#line 562
    s = - tmp___5;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 565
  return (s - (TrieIndex )first_sym);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_fit_symbols(DArray *d , TrieIndex base , Symbols const   *symbols ) 
{ 
  int i ;
  TrieChar sym ;
  TrieChar tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
#line 575
  i = 0;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 575
    tmp___1 = symbols_num(symbols);
    }
#line 575
    if (! (i < tmp___1)) {
#line 575
      goto while_break;
    }
    {
#line 576
    tmp = symbols_get(symbols, i);
#line 576
    sym = tmp;
    }
#line 581
    if (base > 2147483647 - (int )sym) {
#line 582
      return ((Bool )0);
    } else {
      {
#line 581
      tmp___0 = da_check_free_cell(d, base + (TrieIndex )sym);
      }
#line 581
      if (! tmp___0) {
#line 582
        return ((Bool )0);
      }
    }
#line 575
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  return ((Bool )1);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_relocate_base(DArray *d , TrieIndex s , TrieIndex new_base ) 
{ 
  TrieIndex old_base ;
  Symbols *symbols ;
  int i ;
  TrieIndex old_next ;
  TrieIndex new_next ;
  TrieIndex old_next_base ;
  TrieChar tmp ;
  TrieChar tmp___0 ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp___1 ;
  int tmp___2 ;

  {
  {
#line 596
  old_base = da_get_base((DArray const   *)d, s);
#line 597
  symbols = da_output_symbols((DArray const   *)d, s);
#line 599
  i = 0;
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 599
    tmp___2 = symbols_num((Symbols const   *)symbols);
    }
#line 599
    if (! (i < tmp___2)) {
#line 599
      goto while_break;
    }
    {
#line 602
    tmp = symbols_get((Symbols const   *)symbols, i);
#line 602
    old_next = old_base + (TrieIndex )tmp;
#line 603
    tmp___0 = symbols_get((Symbols const   *)symbols, i);
#line 603
    new_next = new_base + (TrieIndex )tmp___0;
#line 604
    old_next_base = da_get_base((DArray const   *)d, old_next);
#line 607
    da_alloc_cell(d, new_next);
#line 608
    da_set_check(d, new_next, s);
#line 609
    da_set_base(d, new_next, old_next_base);
    }
#line 616
    if (old_next_base > 0) {
#line 619
      if (255 < d->num_cells - old_next_base) {
#line 619
        max_c = 255;
      } else {
#line 619
        max_c = d->num_cells - old_next_base;
      }
#line 620
      c = 0;
      {
#line 620
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 620
        if (! (c <= max_c)) {
#line 620
          goto while_break___0;
        }
        {
#line 621
        tmp___1 = da_get_check((DArray const   *)d, old_next_base + c);
        }
#line 621
        if (tmp___1 == old_next) {
          {
#line 622
          da_set_check(d, old_next_base + c, new_next);
          }
        }
#line 620
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 627
    da_free_cell(d, old_next);
#line 599
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 630
  symbols_free(symbols);
#line 633
  da_set_base(d, s, new_base);
  }
#line 634
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_extend_pool(DArray *d , TrieIndex to_index ) 
{ 
  TrieIndex new_begin ;
  TrieIndex i ;
  TrieIndex free_tail ;
  void *tmp ;
  TrieIndex tmp___0 ;

  {
#line 644
  if (to_index <= 0) {
#line 645
    return ((Bool )0);
  } else
#line 644
  if (2147483647 <= to_index) {
#line 645
    return ((Bool )0);
  }
#line 647
  if (to_index < d->num_cells) {
#line 648
    return ((Bool )1);
  }
  {
#line 650
  tmp = realloc((void *)d->cells, (unsigned long )(to_index + 1) * sizeof(DACell ));
#line 650
  d->cells = (DACell *)tmp;
#line 651
  new_begin = d->num_cells;
#line 652
  d->num_cells = to_index + 1;
#line 655
  i = new_begin;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! (i < to_index)) {
#line 655
      goto while_break;
    }
    {
#line 656
    da_set_check(d, i, - (i + 1));
#line 657
    da_set_base(d, i + 1, - i);
#line 655
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 661
  tmp___0 = da_get_base((DArray const   *)d, 1);
#line 661
  free_tail = - tmp___0;
#line 662
  da_set_check(d, free_tail, - new_begin);
#line 663
  da_set_base(d, new_begin, - free_tail);
#line 664
  da_set_check(d, to_index, -1);
#line 665
  da_set_base(d, 1, - to_index);
#line 668
  (d->cells + 0)->check = d->num_cells;
  }
#line 670
  return ((Bool )1);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void da_prune(DArray *d , TrieIndex s ) 
{ 
  TrieIndex tmp ;

  {
  {
#line 686
  tmp = da_get_root((DArray const   *)d);
#line 686
  da_prune_upto(d, tmp, s);
  }
#line 687
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
void da_prune_upto(DArray *d , TrieIndex p , TrieIndex s ) 
{ 
  TrieIndex parent ;
  Bool tmp ;

  {
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (p != s) {
      {
#line 703
      tmp = da_has_children((DArray const   *)d, s);
      }
#line 703
      if (tmp) {
#line 703
        goto while_break;
      }
    } else {
#line 703
      goto while_break;
    }
    {
#line 706
    parent = da_get_check((DArray const   *)d, s);
#line 707
    da_free_cell(d, s);
#line 708
    s = parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_alloc_cell(DArray *d , TrieIndex cell ) 
{ 
  TrieIndex prev ;
  TrieIndex next ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;

  {
  {
#line 718
  tmp = da_get_base((DArray const   *)d, cell);
#line 718
  prev = - tmp;
#line 719
  tmp___0 = da_get_check((DArray const   *)d, cell);
#line 719
  next = - tmp___0;
#line 722
  da_set_check(d, prev, - next);
#line 723
  da_set_base(d, next, - prev);
  }
#line 724
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_free_cell(DArray *d , TrieIndex cell ) 
{ 
  TrieIndex i ;
  TrieIndex prev ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  TrieIndex tmp___1 ;

  {
  {
#line 733
  tmp = da_get_check((DArray const   *)d, 1);
#line 733
  i = - tmp;
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (i != 1) {
#line 734
      if (! (i < cell)) {
#line 734
        goto while_break;
      }
    } else {
#line 734
      goto while_break;
    }
    {
#line 735
    tmp___0 = da_get_check((DArray const   *)d, i);
#line 735
    i = - tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 737
  tmp___1 = da_get_base((DArray const   *)d, i);
#line 737
  prev = - tmp___1;
#line 740
  da_set_check(d, cell, - i);
#line 741
  da_set_base(d, cell, - prev);
#line 742
  da_set_check(d, prev, - cell);
#line 743
  da_set_base(d, i, - cell);
  }
#line 744
  return;
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_first_separate(DArray *d , TrieIndex root , TrieString *keybuff ) 
{ 
  TrieIndex base ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp ;

  {
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 770
    base = da_get_base((DArray const   *)d, root);
    }
#line 770
    if (! (base >= 0)) {
#line 770
      goto while_break;
    }
#line 771
    if (255 < d->num_cells - base) {
#line 771
      max_c = 255;
    } else {
#line 771
      max_c = d->num_cells - base;
    }
#line 772
    c = 0;
    {
#line 772
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 772
      if (! (c <= max_c)) {
#line 772
        goto while_break___0;
      }
      {
#line 773
      tmp = da_get_check((DArray const   *)d, base + c);
      }
#line 773
      if (tmp == root) {
#line 774
        goto while_break___0;
      }
#line 772
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 777
    if (c == max_c) {
#line 778
      return (0);
    }
    {
#line 780
    trie_string_append_char(keybuff, (TrieChar )c);
#line 781
    root = base + c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  return (root);
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
TrieIndex da_next_separate(DArray *d , TrieIndex root , TrieIndex sep , TrieString *keybuff ) 
{ 
  TrieIndex parent ;
  TrieIndex base ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;

  {
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (sep != root)) {
#line 816
      goto while_break;
    }
    {
#line 817
    parent = da_get_check((DArray const   *)d, sep);
#line 818
    base = da_get_base((DArray const   *)d, parent);
#line 819
    c = sep - base;
#line 821
    trie_string_cut_last(keybuff);
    }
#line 824
    if (255 < d->num_cells - base) {
#line 824
      max_c = 255;
    } else {
#line 824
      max_c = d->num_cells - base;
    }
    {
#line 825
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 825
      c ++;
#line 825
      if (! (c <= max_c)) {
#line 825
        goto while_break___0;
      }
      {
#line 826
      tmp___0 = da_get_check((DArray const   *)d, base + c);
      }
#line 826
      if (tmp___0 == parent) {
        {
#line 827
        trie_string_append_char(keybuff, (TrieChar )c);
#line 828
        tmp = da_first_separate(d, base + c, keybuff);
        }
#line 828
        return (tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 832
    sep = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  return (0);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.h"
DString *dstring_new(int char_size , int n_elm ) ;
#line 36
void dstring_free(DString *ds ) ;
#line 38
int dstring_length(DString const   *ds ) ;
#line 40
void const   *dstring_get_val(DString const   *ds ) ;
#line 42
void *dstring_get_val_rw(DString *ds ) ;
#line 44
void dstring_clear(DString *ds ) ;
#line 46
Bool dstring_copy(DString *dst , DString const   *src ) ;
#line 48
Bool dstring_append(DString *dst , DString const   *src ) ;
#line 50
Bool dstring_append_string(DString *ds , void const   *data , int len ) ;
#line 52
Bool dstring_append_char(DString *ds , void const   *data ) ;
#line 54
Bool dstring_terminate(DString *ds ) ;
#line 56
Bool dstring_cut_last(DString *ds ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.h"
TrieString *trie_string_new(int n_elm ) ;
#line 37
void trie_string_free(TrieString *ts ) ;
#line 39
int trie_string_length(TrieString const   *ts ) ;
#line 41
void const   *trie_string_get_val(TrieString const   *ts ) ;
#line 43
void *trie_string_get_val_rw(TrieString *ts ) ;
#line 45
void trie_string_clear(TrieString *ts ) ;
#line 47
Bool trie_string_copy(TrieString *dst , TrieString const   *src ) ;
#line 49
Bool trie_string_append(TrieString *dst , TrieString const   *src ) ;
#line 51
Bool trie_string_append_string(TrieString *ts , TrieChar const   *str ) ;
#line 55
Bool trie_string_terminate(TrieString *ts ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
TrieString *trie_string_new(int n_elm ) 
{ 
  DString *tmp ;

  {
  {
#line 42
  tmp = dstring_new((int )sizeof(TrieChar ), n_elm);
  }
#line 42
  return ((TrieString *)tmp);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
void trie_string_free(TrieString *ts ) 
{ 


  {
  {
#line 48
  dstring_free((DString *)ts);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
int trie_string_length(TrieString const   *ts ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = dstring_length((DString const   *)((DString *)ts));
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
void const   *trie_string_get_val(TrieString const   *ts ) 
{ 
  void const   *tmp ;

  {
  {
#line 60
  tmp = dstring_get_val((DString const   *)((DString *)ts));
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
void *trie_string_get_val_rw(TrieString *ts ) 
{ 
  void *tmp ;

  {
  {
#line 66
  tmp = dstring_get_val_rw((DString *)ts);
  }
#line 66
  return (tmp);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
void trie_string_clear(TrieString *ts ) 
{ 


  {
  {
#line 72
  dstring_clear((DString *)ts);
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_copy(TrieString *dst , TrieString const   *src ) 
{ 
  Bool tmp ;

  {
  {
#line 78
  tmp = dstring_copy((DString *)dst, (DString const   *)src);
  }
#line 78
  return (tmp);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_append(TrieString *dst , TrieString const   *src ) 
{ 
  Bool tmp ;

  {
  {
#line 84
  tmp = dstring_append((DString *)dst, (DString const   *)src);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_append_string(TrieString *ts , TrieChar const   *str ) 
{ 
  size_t tmp ;
  Bool tmp___0 ;

  {
  {
#line 90
  tmp = strlen((char const   *)str);
#line 90
  tmp___0 = dstring_append_string((DString *)ts, (void const   *)str, (int )tmp);
  }
#line 90
  return (tmp___0);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_append_char(TrieString *ts , TrieChar tc ) 
{ 
  Bool tmp ;

  {
  {
#line 97
  tmp = dstring_append_char((DString *)ts, (void const   *)(& tc));
  }
#line 97
  return (tmp);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_terminate(TrieString *ts ) 
{ 
  Bool tmp ;

  {
  {
#line 103
  tmp = dstring_terminate((DString *)ts);
  }
#line 103
  return (tmp);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie-string.c"
Bool trie_string_cut_last(TrieString *ts ) 
{ 
  Bool tmp ;

  {
  {
#line 109
  tmp = dstring_cut_last((DString *)ts);
  }
#line 109
  return (tmp);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.h"
AlphaMap *alpha_map_new(void) ;
#line 70
AlphaMap *alpha_map_clone(AlphaMap const   *a_map ) ;
#line 72
void alpha_map_free(AlphaMap *alpha_map ) ;
#line 74
int alpha_map_add_range(AlphaMap *alpha_map , AlphaChar begin , AlphaChar end ) ;
#line 78
int alpha_char_strlen(AlphaChar const   *str ) ;
#line 79
int alpha_char_strcmp(AlphaChar const   *str1 , AlphaChar const   *str2 ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map-private.h"
AlphaMap *alpha_map_fread_bin(FILE *file ) ;
#line 35
int alpha_map_fwrite_bin(AlphaMap const   *alpha_map , FILE *file ) ;
#line 37
TrieIndex alpha_map_char_to_trie(AlphaMap const   *alpha_map , AlphaChar ac ) ;
#line 40
AlphaChar alpha_map_trie_to_char(AlphaMap const   *alpha_map , TrieChar tc ) ;
#line 43
TrieChar *alpha_map_char_to_trie_str(AlphaMap const   *alpha_map , AlphaChar const   *str ) ;
#line 46
AlphaChar *alpha_map_trie_to_char_str(AlphaMap const   *alpha_map , TrieChar const   *str ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
int alpha_char_strlen(AlphaChar const   *str ) 
{ 
  AlphaChar const   *p ;

  {
#line 49
  p = str;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! *p) {
#line 49
      goto while_break;
    }
#line 49
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((int )(p - str));
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
int alpha_char_strcmp(AlphaChar const   *str1 , AlphaChar const   *str2 ) 
{ 


  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (*str1) {
#line 69
      if (! (*str1 == *str2)) {
#line 69
        goto while_break;
      }
    } else {
#line 69
      goto while_break;
    }
#line 70
    str1 ++;
#line 70
    str2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (*str1 < *str2) {
#line 73
    return (-1);
  }
#line 74
  if (*str1 > *str2) {
#line 75
    return (1);
  }
#line 76
  return (0);
}
}
#line 97
static int alpha_map_get_total_ranges(AlphaMap const   *alpha_map ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
AlphaMap *alpha_map_new(void) 
{ 
  AlphaMap *alpha_map ;
  void *tmp ;

  {
  {
#line 129
  tmp = malloc(sizeof(AlphaMap ));
#line 129
  alpha_map = (AlphaMap *)tmp;
  }
#line 130
  if (! alpha_map) {
#line 131
    return ((AlphaMap *)((void *)0));
  }
#line 133
  alpha_map->first_range = (AlphaRange *)((void *)0);
#line 135
  return (alpha_map);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
AlphaMap *alpha_map_clone(AlphaMap const   *a_map ) 
{ 
  AlphaMap *alpha_map ;
  AlphaRange *range ;
  int tmp ;

  {
  {
#line 153
  alpha_map = alpha_map_new();
  }
#line 154
  if (! alpha_map) {
#line 155
    return ((AlphaMap *)((void *)0));
  }
#line 157
  range = (AlphaRange *)a_map->first_range;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! range) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = alpha_map_add_range(alpha_map, range->begin, range->end);
    }
#line 158
    if (tmp != 0) {
      {
#line 159
      alpha_map_free(alpha_map);
      }
#line 160
      return ((AlphaMap *)((void *)0));
    }
#line 157
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (alpha_map);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
void alpha_map_free(AlphaMap *alpha_map ) 
{ 
  AlphaRange *p ;
  AlphaRange *q ;

  {
#line 179
  p = alpha_map->first_range;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! p) {
#line 180
      goto while_break;
    }
    {
#line 181
    q = p->next;
#line 182
    free((void *)p);
#line 183
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  free((void *)alpha_map);
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
AlphaMap *alpha_map_fread_bin(FILE *file ) 
{ 
  long save_pos ;
  uint32 sig ;
  int32 total ;
  int32 i ;
  AlphaMap *alpha_map ;
  Bool tmp ;
  Bool tmp___0 ;
  int32 b ;
  int32 e ;
  Bool tmp___1 ;
  Bool tmp___2 ;

  {
  {
#line 198
  save_pos = ftell(file);
#line 199
  tmp = file_read_int32(file, (int32 *)(& sig));
  }
#line 199
  if (tmp) {
#line 199
    if (3657226748U != sig) {
#line 200
      goto exit_file_read;
    }
  } else {
#line 200
    goto exit_file_read;
  }
  {
#line 202
  alpha_map = alpha_map_new();
  }
#line 202
  if ((unsigned long )((void *)0) == (unsigned long )alpha_map) {
#line 203
    goto exit_file_read;
  }
  {
#line 206
  tmp___0 = file_read_int32(file, & total);
  }
#line 206
  if (! tmp___0) {
#line 207
    goto exit_map_created;
  }
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < total)) {
#line 210
      goto while_break;
    }
    {
#line 213
    tmp___1 = file_read_int32(file, & b);
    }
#line 213
    if (tmp___1) {
      {
#line 213
      tmp___2 = file_read_int32(file, & e);
      }
#line 213
      if (! tmp___2) {
#line 214
        goto exit_map_created;
      }
    } else {
#line 214
      goto exit_map_created;
    }
    {
#line 215
    alpha_map_add_range(alpha_map, (AlphaChar )b, (AlphaChar )e);
#line 210
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return (alpha_map);
  exit_map_created: 
  {
#line 221
  alpha_map_free(alpha_map);
  }
  exit_file_read: 
  {
#line 223
  fseek(file, save_pos, 0);
  }
#line 224
  return ((AlphaMap *)((void *)0));
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
static int alpha_map_get_total_ranges(AlphaMap const   *alpha_map ) 
{ 
  int n ;
  AlphaRange *range ;

  {
#line 233
  n = 0;
#line 233
  range = (AlphaRange *)alpha_map->first_range;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! range) {
#line 233
      goto while_break;
    }
#line 234
    n ++;
#line 233
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (n);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
int alpha_map_fwrite_bin(AlphaMap const   *alpha_map , FILE *file ) 
{ 
  AlphaRange *range ;
  Bool tmp ;
  int tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  Bool tmp___3 ;

  {
  {
#line 245
  tmp = file_write_int32(file, (int32 )3657226748U);
  }
#line 245
  if (tmp) {
    {
#line 245
    tmp___0 = alpha_map_get_total_ranges(alpha_map);
#line 245
    tmp___1 = file_write_int32(file, tmp___0);
    }
#line 245
    if (! tmp___1) {
#line 248
      return (-1);
    }
  } else {
#line 248
    return (-1);
  }
#line 251
  range = (AlphaRange *)alpha_map->first_range;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! range) {
#line 251
      goto while_break;
    }
    {
#line 252
    tmp___2 = file_write_int32(file, (int32 )range->begin);
    }
#line 252
    if (tmp___2) {
      {
#line 252
      tmp___3 = file_write_int32(file, (int32 )range->end);
      }
#line 252
      if (! tmp___3) {
#line 255
        return (-1);
      }
    } else {
#line 255
      return (-1);
    }
#line 251
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
int alpha_map_add_range(AlphaMap *alpha_map , AlphaChar begin , AlphaChar end ) 
{ 
  AlphaRange *q ;
  AlphaRange *r ;
  AlphaRange *begin_node ;
  AlphaRange *end_node ;
  AlphaRange *range ;
  void *tmp ;

  {
#line 279
  if (begin > end) {
#line 280
    return (-1);
  }
#line 282
  end_node = (AlphaRange *)0;
#line 282
  begin_node = end_node;
#line 285
  q = (AlphaRange *)0;
#line 285
  r = alpha_map->first_range;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (r) {
#line 285
      if (! (r->begin <= begin)) {
#line 285
        goto while_break;
      }
    } else {
#line 285
      goto while_break;
    }
#line 289
    if (begin <= r->end) {
#line 291
      begin_node = r;
#line 292
      goto while_break;
    }
#line 294
    if (r->end + 1U == begin) {
#line 298
      r->end = begin;
#line 299
      begin_node = r;
#line 300
      goto while_break;
    }
#line 285
    q = r;
#line 285
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (! begin_node) {
#line 303
    if (r) {
#line 303
      if (r->begin <= end + 1U) {
#line 308
        r->begin = begin;
#line 309
        begin_node = r;
      }
    }
  }
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (r) {
#line 312
      if (! (r->begin <= end + 1U)) {
#line 312
        goto while_break___0;
      }
    } else {
#line 312
      goto while_break___0;
    }
#line 313
    if (end <= r->end) {
#line 315
      end_node = r;
    } else
#line 316
    if ((unsigned long )r != (unsigned long )begin_node) {
#line 318
      if (q) {
        {
#line 319
        q->next = r->next;
#line 320
        free((void *)r);
#line 321
        r = q->next;
        }
      } else {
        {
#line 323
        alpha_map->first_range = r->next;
#line 324
        free((void *)r);
#line 325
        r = alpha_map->first_range;
        }
      }
#line 327
      goto while_continue___0;
    }
#line 329
    q = r;
#line 330
    r = r->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 332
  if (! end_node) {
#line 332
    if (q) {
#line 332
      if (begin <= q->end) {
#line 336
        q->end = end;
#line 337
        end_node = q;
      }
    }
  }
#line 340
  if (begin_node) {
#line 340
    if (end_node) {
#line 341
      if ((unsigned long )begin_node != (unsigned long )end_node) {
#line 343
        if (! ((unsigned long )begin_node->next == (unsigned long )end_node)) {
          {
#line 343
          __assert_fail("begin_node->next == end_node", "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c",
                        343U, "alpha_map_add_range");
          }
        }
        {
#line 344
        begin_node->end = end_node->end;
#line 345
        begin_node->next = end_node->next;
#line 346
        free((void *)end_node);
        }
      }
    } else {
#line 340
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 348
  if (! begin_node) {
#line 348
    if (! end_node) {
      {
#line 352
      tmp = malloc(sizeof(AlphaRange ));
#line 352
      range = (AlphaRange *)tmp;
      }
#line 354
      if (! range) {
#line 355
        return (-1);
      }
#line 357
      range->begin = begin;
#line 358
      range->end = end;
#line 361
      if (q) {
#line 362
        q->next = range;
      } else {
#line 364
        alpha_map->first_range = range;
      }
#line 366
      range->next = r;
    }
  }
#line 369
  return (0);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
TrieIndex alpha_map_char_to_trie(AlphaMap const   *alpha_map , AlphaChar ac ) 
{ 
  TrieIndex alpha_begin ;
  AlphaRange *range ;

  {
#line 378
  if (0U == ac) {
#line 379
    return (0);
  }
#line 381
  alpha_begin = 1;
#line 382
  range = (AlphaRange *)alpha_map->first_range;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! range) {
#line 382
      goto while_break;
    }
#line 383
    if (range->begin <= ac) {
#line 383
      if (ac <= range->end) {
#line 384
        return ((TrieIndex )((AlphaChar )alpha_begin + (ac - range->begin)));
      }
    }
#line 386
    alpha_begin = (TrieIndex )((AlphaChar )alpha_begin + ((range->end - range->begin) + 1U));
#line 382
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (2147483647);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
AlphaChar alpha_map_trie_to_char(AlphaMap const   *alpha_map , TrieChar tc ) 
{ 
  TrieChar alpha_begin ;
  AlphaRange *range ;

  {
#line 398
  if (0 == (int )tc) {
#line 399
    return ((AlphaChar )0);
  }
#line 401
  alpha_begin = (TrieChar )1;
#line 402
  range = (AlphaRange *)alpha_map->first_range;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! range) {
#line 402
      goto while_break;
    }
#line 403
    if ((AlphaChar )tc <= (AlphaChar )alpha_begin + (range->end - range->begin)) {
#line 404
      return (range->begin + (AlphaChar )((int )tc - (int )alpha_begin));
    }
#line 406
    alpha_begin = (TrieChar )((AlphaChar )alpha_begin + ((range->end - range->begin) + 1U));
#line 402
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return (~ ((AlphaChar )0));
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
TrieChar *alpha_map_char_to_trie_str(AlphaMap const   *alpha_map , AlphaChar const   *str ) 
{ 
  TrieChar *trie_str ;
  TrieChar *p ;
  int tmp ;
  void *tmp___0 ;
  TrieIndex tc ;
  TrieIndex tmp___1 ;

  {
  {
#line 417
  tmp = alpha_char_strlen(str);
#line 417
  tmp___0 = malloc((size_t )(tmp + 1));
#line 417
  trie_str = (TrieChar *)tmp___0;
  }
#line 418
  if (! trie_str) {
#line 419
    return ((TrieChar *)((void *)0));
  }
#line 421
  p = trie_str;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! *str) {
#line 421
      goto while_break;
    }
    {
#line 422
    tmp___1 = alpha_map_char_to_trie(alpha_map, (AlphaChar )*str);
#line 422
    tc = tmp___1;
    }
#line 423
    if (2147483647 == tc) {
#line 424
      goto error_str_allocated;
    }
#line 425
    *p = (TrieChar )tc;
#line 421
    p ++;
#line 421
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  *p = (TrieChar )0;
#line 429
  return (trie_str);
  error_str_allocated: 
  {
#line 432
  free((void *)trie_str);
  }
#line 433
  return ((TrieChar *)((void *)0));
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
AlphaChar *alpha_map_trie_to_char_str(AlphaMap const   *alpha_map , TrieChar const   *str ) 
{ 
  AlphaChar *alpha_str ;
  AlphaChar *p ;
  size_t tmp ;
  void *tmp___0 ;
  AlphaChar tmp___1 ;

  {
  {
#line 441
  tmp = strlen((char const   *)str);
#line 441
  tmp___0 = malloc((tmp + 1UL) * sizeof(AlphaChar ));
#line 441
  alpha_str = (AlphaChar *)tmp___0;
  }
#line 443
  if (! alpha_str) {
#line 444
    return ((AlphaChar *)((void *)0));
  }
#line 446
  p = alpha_str;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! *str) {
#line 446
      goto while_break;
    }
    {
#line 447
    tmp___1 = alpha_map_trie_to_char(alpha_map, (TrieChar )*str);
#line 447
    *p = tmp___1;
#line 446
    p ++;
#line 446
    str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  *p = (AlphaChar )0;
#line 451
  return (alpha_str);
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.h"
Tail *tail_new(void) ;
#line 44
Tail *tail_fread(FILE *file ) ;
#line 46
void tail_free(Tail *t ) ;
#line 48
int tail_fwrite(Tail const   *t , FILE *file ) ;
#line 51
TrieChar const   *tail_get_suffix(Tail const   *t , TrieIndex index___0 ) ;
#line 53
Bool tail_set_suffix(Tail *t , TrieIndex index___0 , TrieChar const   *suffix ) ;
#line 55
TrieIndex tail_add_suffix(Tail *t , TrieChar const   *suffix ) ;
#line 57
TrieData tail_get_data(Tail const   *t , TrieIndex index___0 ) ;
#line 59
Bool tail_set_data(Tail *t , TrieIndex index___0 , TrieData data ) ;
#line 61
void tail_delete(Tail *t , TrieIndex index___0 ) ;
#line 63
int tail_walk_str(Tail const   *t , TrieIndex s , short *suffix_idx , TrieChar const   *str ,
                  int len ) ;
#line 69
Bool tail_walk_char(Tail const   *t , TrieIndex s , short *suffix_idx , TrieChar c ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.h"
Bool file_read_int16(FILE *file , int16 *o_val ) ;
#line 37
Bool file_write_int16(FILE *file , int16 val ) ;
#line 42
Bool file_read_chars(FILE *file , char *buff , int len ) ;
#line 43
Bool file_write_chars(FILE *file , char const   *buff , int len ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static TrieIndex tail_alloc_block(Tail *t ) ;
#line 46
static void tail_free_block(Tail *t , TrieIndex block ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
Tail *tail_new(void) 
{ 
  Tail *t ;
  void *tmp ;

  {
  {
#line 99
  tmp = malloc(sizeof(Tail ));
#line 99
  t = (Tail *)tmp;
  }
#line 100
  if (! t) {
#line 101
    return ((Tail *)((void *)0));
  }
#line 103
  t->first_free = 0;
#line 104
  t->num_tails = 0;
#line 105
  t->tails = (TailBlock *)((void *)0);
#line 107
  return (t);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
Tail *tail_fread(FILE *file ) 
{ 
  long save_pos ;
  Tail *t ;
  TrieIndex i ;
  uint32 sig ;
  Bool tmp ;
  void *tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  void *tmp___3 ;
  int16 length ;
  Bool tmp___4 ;
  Bool tmp___5 ;
  Bool tmp___6 ;
  void *tmp___7 ;
  Bool tmp___8 ;

  {
  {
#line 130
  save_pos = ftell(file);
#line 131
  tmp = file_read_int32(file, (int32 *)(& sig));
  }
#line 131
  if (tmp) {
#line 131
    if (3757891580U != sig) {
#line 132
      goto exit_file_read;
    }
  } else {
#line 132
    goto exit_file_read;
  }
  {
#line 134
  tmp___0 = malloc(sizeof(Tail ));
#line 134
  t = (Tail *)tmp___0;
  }
#line 134
  if ((unsigned long )((void *)0) == (unsigned long )t) {
#line 135
    goto exit_file_read;
  }
  {
#line 137
  tmp___1 = file_read_int32(file, & t->first_free);
  }
#line 137
  if (tmp___1) {
    {
#line 137
    tmp___2 = file_read_int32(file, & t->num_tails);
    }
#line 137
    if (! tmp___2) {
#line 140
      goto exit_tail_created;
    }
  } else {
#line 140
    goto exit_tail_created;
  }
#line 142
  if ((unsigned long )t->num_tails > 0xffffffffffffffffUL / sizeof(TailBlock )) {
#line 143
    goto exit_tail_created;
  }
  {
#line 144
  tmp___3 = malloc((unsigned long )t->num_tails * sizeof(TailBlock ));
#line 144
  t->tails = (TailBlock *)tmp___3;
  }
#line 145
  if (! t->tails) {
#line 146
    goto exit_tail_created;
  }
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i < t->num_tails)) {
#line 147
      goto while_break;
    }
    {
#line 150
    tmp___4 = file_read_int32(file, & (t->tails + i)->next_free);
    }
#line 150
    if (tmp___4) {
      {
#line 150
      tmp___5 = file_read_int32(file, & (t->tails + i)->data);
      }
#line 150
      if (tmp___5) {
        {
#line 150
        tmp___6 = file_read_int16(file, & length);
        }
#line 150
        if (! tmp___6) {
#line 154
          goto exit_in_loop;
        }
      } else {
#line 154
        goto exit_in_loop;
      }
    } else {
#line 154
      goto exit_in_loop;
    }
    {
#line 157
    tmp___7 = malloc((size_t )((int )length + 1));
#line 157
    (t->tails + i)->suffix = (TrieChar *)tmp___7;
    }
#line 158
    if ((int )length > 0) {
      {
#line 159
      tmp___8 = file_read_chars(file, (char *)(t->tails + i)->suffix, (int )length);
      }
#line 159
      if (! tmp___8) {
        {
#line 160
        free((void *)(t->tails + i)->suffix);
        }
#line 161
        goto exit_in_loop;
      }
    }
#line 164
    *((t->tails + i)->suffix + length) = (TrieChar )'\000';
#line 147
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (t);
  exit_in_loop: 
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! (i > 0)) {
#line 170
      goto while_break___0;
    }
    {
#line 171
    i --;
#line 171
    free((void *)(t->tails + i)->suffix);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  free((void *)t->tails);
  }
  exit_tail_created: 
  {
#line 175
  free((void *)t);
  }
  exit_file_read: 
  {
#line 177
  fseek(file, save_pos, 0);
  }
#line 178
  return ((Tail *)((void *)0));
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
void tail_free(Tail *t ) 
{ 
  TrieIndex i ;

  {
#line 195
  if (t->tails) {
#line 196
    i = 0;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! (i < t->num_tails)) {
#line 196
        goto while_break;
      }
#line 197
      if ((t->tails + i)->suffix) {
        {
#line 198
        free((void *)(t->tails + i)->suffix);
        }
      }
#line 196
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 199
    free((void *)t->tails);
    }
  }
  {
#line 201
  free((void *)t);
  }
#line 202
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
int tail_fwrite(Tail const   *t , FILE *file ) 
{ 
  TrieIndex i ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  int16 length ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  size_t tmp___4 ;
  Bool tmp___5 ;
  Bool tmp___6 ;

  {
  {
#line 220
  tmp = file_write_int32(file, (int32 )3757891580U);
  }
#line 220
  if (tmp) {
    {
#line 220
    tmp___0 = file_write_int32(file, (int32 )t->first_free);
    }
#line 220
    if (tmp___0) {
      {
#line 220
      tmp___1 = file_write_int32(file, (int32 )t->num_tails);
      }
#line 220
      if (! tmp___1) {
#line 224
        return (-1);
      }
    } else {
#line 224
      return (-1);
    }
  } else {
#line 224
    return (-1);
  }
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < (TrieIndex )t->num_tails)) {
#line 226
      goto while_break;
    }
    {
#line 229
    tmp___2 = file_write_int32(file, (t->tails + i)->next_free);
    }
#line 229
    if (tmp___2) {
      {
#line 229
      tmp___3 = file_write_int32(file, (t->tails + i)->data);
      }
#line 229
      if (! tmp___3) {
#line 232
        return (-1);
      }
    } else {
#line 232
      return (-1);
    }
#line 235
    if ((t->tails + i)->suffix) {
      {
#line 235
      tmp___4 = strlen((char const   *)(t->tails + i)->suffix);
#line 235
      length = (int16 )tmp___4;
      }
    } else {
#line 235
      length = (int16 )0;
    }
    {
#line 237
    tmp___5 = file_write_int16(file, length);
    }
#line 237
    if (! tmp___5) {
#line 238
      return (-1);
    }
#line 239
    if ((int )length > 0) {
      {
#line 239
      tmp___6 = file_write_chars(file, (char const   *)((char *)(t->tails + i)->suffix),
                                 (int )length);
      }
#line 239
      if (! tmp___6) {
#line 242
        return (-1);
      }
    }
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (0);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
TrieChar const   *tail_get_suffix(Tail const   *t , TrieIndex index___0 ) 
{ 
  TrieChar *tmp ;

  {
#line 265
  index___0 --;
#line 266
  if (index___0 < (TrieIndex )t->num_tails) {
#line 266
    tmp = (t->tails + index___0)->suffix;
  } else {
#line 266
    tmp = (TrieChar *)((void *)0);
  }
#line 266
  return ((TrieChar const   *)tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
Bool tail_set_suffix(Tail *t , TrieIndex index___0 , TrieChar const   *suffix ) 
{ 
  TrieChar *tmp ;
  char *tmp___0 ;

  {
#line 281
  index___0 --;
#line 282
  if (index___0 < t->num_tails) {
#line 286
    tmp = (TrieChar *)((void *)0);
#line 287
    if (suffix) {
      {
#line 288
      tmp___0 = strdup((char const   *)suffix);
#line 288
      tmp = (TrieChar *)tmp___0;
      }
    }
#line 289
    if ((t->tails + index___0)->suffix) {
      {
#line 290
      free((void *)(t->tails + index___0)->suffix);
      }
    }
#line 291
    (t->tails + index___0)->suffix = tmp;
#line 293
    return ((Bool )1);
  }
#line 295
  return ((Bool )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
TrieIndex tail_add_suffix(Tail *t , TrieChar const   *suffix ) 
{ 
  TrieIndex new_block ;

  {
  {
#line 313
  new_block = tail_alloc_block(t);
#line 314
  tail_set_suffix(t, new_block, suffix);
  }
#line 316
  return (new_block);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static TrieIndex tail_alloc_block(Tail *t ) 
{ 
  TrieIndex block ;
  void *tmp ;

  {
#line 324
  if (0 != t->first_free) {
#line 325
    block = t->first_free;
#line 326
    t->first_free = (t->tails + block)->next_free;
  } else {
    {
#line 328
    block = t->num_tails;
#line 329
    (t->num_tails) ++;
#line 329
    tmp = realloc((void *)t->tails, (unsigned long )t->num_tails * sizeof(TailBlock ));
#line 329
    t->tails = (TailBlock *)tmp;
    }
  }
#line 332
  (t->tails + block)->next_free = -1;
#line 333
  (t->tails + block)->data = -1;
#line 334
  (t->tails + block)->suffix = (TrieChar *)((void *)0);
#line 336
  return (block + 1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static void tail_free_block(Tail *t , TrieIndex block ) 
{ 
  TrieIndex i ;
  TrieIndex j ;

  {
#line 344
  block --;
#line 346
  if (block >= t->num_tails) {
#line 347
    return;
  }
#line 349
  (t->tails + block)->data = -1;
#line 350
  if ((unsigned long )((void *)0) != (unsigned long )(t->tails + block)->suffix) {
    {
#line 351
    free((void *)(t->tails + block)->suffix);
#line 352
    (t->tails + block)->suffix = (TrieChar *)((void *)0);
    }
  }
#line 356
  j = 0;
#line 357
  i = t->first_free;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (i != 0) {
#line 357
      if (! (i < block)) {
#line 357
        goto while_break;
      }
    } else {
#line 357
      goto while_break;
    }
#line 358
    j = i;
#line 357
    i = (t->tails + i)->next_free;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  (t->tails + block)->next_free = i;
#line 362
  if (0 != j) {
#line 363
    (t->tails + j)->next_free = block;
  } else {
#line 365
    t->first_free = block;
  }
#line 366
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
TrieData tail_get_data(Tail const   *t , TrieIndex index___0 ) 
{ 
  TrieData tmp ;

  {
#line 381
  index___0 --;
#line 382
  if (index___0 < (TrieIndex )t->num_tails) {
#line 382
    tmp = (t->tails + index___0)->data;
  } else {
#line 382
    tmp = -1;
  }
#line 382
  return (tmp);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
Bool tail_set_data(Tail *t , TrieIndex index___0 , TrieData data ) 
{ 


  {
#line 399
  index___0 --;
#line 400
  if (index___0 < t->num_tails) {
#line 401
    (t->tails + index___0)->data = data;
#line 402
    return ((Bool )1);
  }
#line 404
  return ((Bool )0);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
void tail_delete(Tail *t , TrieIndex index___0 ) 
{ 


  {
  {
#line 418
  tail_free_block(t, index___0);
  }
#line 419
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
int tail_walk_str(Tail const   *t , TrieIndex s , short *suffix_idx , TrieChar const   *str ,
                  int len ) 
{ 
  TrieChar const   *suffix ;
  int i ;
  short j ;

  {
  {
#line 448
  suffix = tail_get_suffix(t, s);
  }
#line 449
  if (! suffix) {
#line 450
    return (0);
  }
#line 452
  i = 0;
#line 452
  j = *suffix_idx;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < len)) {
#line 453
      goto while_break;
    }
#line 454
    if ((int const   )*(str + i) != (int const   )*(suffix + j)) {
#line 455
      goto while_break;
    }
#line 456
    i ++;
#line 458
    if (0 == (int )*(suffix + j)) {
#line 459
      goto while_break;
    }
#line 460
    j = (short )((int )j + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  *suffix_idx = j;
#line 463
  return (i);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
Bool tail_walk_char(Tail const   *t , TrieIndex s , short *suffix_idx , TrieChar c ) 
{ 
  TrieChar const   *suffix ;
  TrieChar suffix_char ;

  {
  {
#line 490
  suffix = tail_get_suffix(t, s);
  }
#line 491
  if (! suffix) {
#line 492
    return ((Bool )0);
  }
#line 494
  suffix_char = (TrieChar )*(suffix + *suffix_idx);
#line 495
  if ((int )suffix_char == (int )c) {
#line 496
    if (0 != (int )suffix_char) {
#line 497
      *suffix_idx = (short )((int )*suffix_idx + 1);
    }
#line 498
    return ((Bool )1);
  }
#line 500
  return ((Bool )0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.h"
Trie *trie_new(AlphaMap const   *alpha_map ) ;
#line 117
Trie *trie_new_from_file(char const   *path ) ;
#line 119
Trie *trie_fread(FILE *file ) ;
#line 121
void trie_free(Trie *trie ) ;
#line 123
int trie_save(Trie *trie , char const   *path ) ;
#line 125
int trie_fwrite(Trie *trie , FILE *file ) ;
#line 127
Bool trie_is_dirty(Trie const   *trie ) ;
#line 134
Bool trie_retrieve(Trie const   *trie , AlphaChar const   *key , TrieData *o_data ) ;
#line 138
Bool trie_store(Trie *trie , AlphaChar const   *key , TrieData data ) ;
#line 140
Bool trie_store_if_absent(Trie *trie , AlphaChar const   *key , TrieData data ) ;
#line 142
Bool trie_delete(Trie *trie , AlphaChar const   *key ) ;
#line 144
Bool trie_enumerate(Trie const   *trie , Bool (*enum_func)(AlphaChar const   *key ,
                                                           TrieData key_data , void *user_data ) ,
                    void *user_data ) ;
#line 153
TrieState *trie_root(Trie const   *trie ) ;
#line 160
TrieState *trie_state_clone(TrieState const   *s ) ;
#line 162
void trie_state_copy(TrieState *dst , TrieState const   *src ) ;
#line 164
void trie_state_free(TrieState *s ) ;
#line 166
void trie_state_rewind(TrieState *s ) ;
#line 168
Bool trie_state_walk(TrieState *s , AlphaChar c ) ;
#line 170
Bool trie_state_is_walkable(TrieState const   *s , AlphaChar c ) ;
#line 172
int trie_state_walkable_chars(TrieState const   *s , AlphaChar *chars , int chars_nelm ) ;
#line 188
Bool trie_state_is_single(TrieState const   *s ) ;
#line 203
TrieData trie_state_get_data(TrieState const   *s ) ;
#line 210
TrieIterator *trie_iterator_new(TrieState *s ) ;
#line 212
void trie_iterator_free(TrieIterator *iter ) ;
#line 214
Bool trie_iterator_next(TrieIterator *iter ) ;
#line 216
AlphaChar *trie_iterator_get_key(TrieIterator const   *iter ) ;
#line 218
TrieData trie_iterator_get_data(TrieIterator const   *iter ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static TrieState *trie_state_new(Trie const   *trie , TrieIndex index___0 , short suffix_idx ,
                                 short is_suffix ) ;
#line 82
static Bool trie_store_conditionally(Trie *trie , AlphaChar const   *key , TrieData data ,
                                     Bool is_overwrite ) ;
#line 87
static Bool trie_branch_in_branch(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                  TrieData data ) ;
#line 92
static Bool trie_branch_in_tail(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                TrieData data ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Trie *trie_new(AlphaMap const   *alpha_map ) 
{ 
  Trie *trie ;
  void *tmp ;

  {
  {
#line 119
  tmp = malloc(sizeof(Trie ));
#line 119
  trie = (Trie *)tmp;
  }
#line 120
  if (! trie) {
#line 121
    return ((Trie *)((void *)0));
  }
  {
#line 123
  trie->alpha_map = alpha_map_clone(alpha_map);
  }
#line 124
  if (! trie->alpha_map) {
#line 125
    goto exit_trie_created;
  }
  {
#line 127
  trie->da = da_new();
  }
#line 128
  if (! trie->da) {
#line 129
    goto exit_alpha_map_created;
  }
  {
#line 131
  trie->tail = tail_new();
  }
#line 132
  if (! trie->tail) {
#line 133
    goto exit_da_created;
  }
#line 135
  trie->is_dirty = (Bool )1;
#line 136
  return (trie);
  exit_da_created: 
  {
#line 139
  da_free(trie->da);
  }
  exit_alpha_map_created: 
  {
#line 141
  alpha_map_free(trie->alpha_map);
  }
  exit_trie_created: 
  {
#line 143
  free((void *)trie);
  }
#line 144
  return ((Trie *)((void *)0));
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Trie *trie_new_from_file(char const   *path ) 
{ 
  Trie *trie ;
  FILE *trie_file ;

  {
  {
#line 165
  trie_file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 166
  if (! trie_file) {
#line 167
    return ((Trie *)((void *)0));
  }
  {
#line 169
  trie = trie_fread(trie_file);
#line 170
  fclose(trie_file);
  }
#line 171
  return (trie);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Trie *trie_fread(FILE *file ) 
{ 
  Trie *trie ;
  void *tmp ;
  AlphaMap *tmp___0 ;
  DArray *tmp___1 ;
  Tail *tmp___2 ;

  {
  {
#line 194
  tmp = malloc(sizeof(Trie ));
#line 194
  trie = (Trie *)tmp;
  }
#line 195
  if (! trie) {
#line 196
    return ((Trie *)((void *)0));
  }
  {
#line 198
  tmp___0 = alpha_map_fread_bin(file);
#line 198
  trie->alpha_map = tmp___0;
  }
#line 198
  if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
#line 199
    goto exit_trie_created;
  }
  {
#line 200
  tmp___1 = da_fread(file);
#line 200
  trie->da = tmp___1;
  }
#line 200
  if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
#line 201
    goto exit_alpha_map_created;
  }
  {
#line 202
  tmp___2 = tail_fread(file);
#line 202
  trie->tail = tmp___2;
  }
#line 202
  if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
#line 203
    goto exit_da_created;
  }
#line 205
  trie->is_dirty = (Bool )0;
#line 206
  return (trie);
  exit_da_created: 
  {
#line 209
  da_free(trie->da);
  }
  exit_alpha_map_created: 
  {
#line 211
  alpha_map_free(trie->alpha_map);
  }
  exit_trie_created: 
  {
#line 213
  free((void *)trie);
  }
#line 214
  return ((Trie *)((void *)0));
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
void trie_free(Trie *trie ) 
{ 


  {
  {
#line 227
  alpha_map_free(trie->alpha_map);
#line 228
  da_free(trie->da);
#line 229
  tail_free(trie->tail);
#line 230
  free((void *)trie);
  }
#line 231
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
int trie_save(Trie *trie , char const   *path ) 
{ 
  FILE *file ;
  int res ;

  {
  {
#line 249
  res = 0;
#line 251
  file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w+");
  }
#line 252
  if (! file) {
#line 253
    return (-1);
  }
  {
#line 255
  res = trie_fwrite(trie, file);
#line 256
  fclose(file);
  }
#line 257
  return (res);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
int trie_fwrite(Trie *trie , FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  tmp = alpha_map_fwrite_bin((AlphaMap const   *)trie->alpha_map, file);
  }
#line 278
  if (tmp != 0) {
#line 279
    return (-1);
  }
  {
#line 281
  tmp___0 = da_fwrite((DArray const   *)trie->da, file);
  }
#line 281
  if (tmp___0 != 0) {
#line 282
    return (-1);
  }
  {
#line 284
  tmp___1 = tail_fwrite((Tail const   *)trie->tail, file);
  }
#line 284
  if (tmp___1 != 0) {
#line 285
    return (-1);
  }
#line 287
  trie->is_dirty = (Bool )0;
#line 289
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_is_dirty(Trie const   *trie ) 
{ 


  {
#line 305
  return ((Bool )trie->is_dirty);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_retrieve(Trie const   *trie , AlphaChar const   *key , TrieData *o_data ) 
{ 
  TrieIndex s ;
  short suffix_idx ;
  AlphaChar const   *p ;
  TrieIndex tc ;
  TrieIndex tmp ;
  Bool tmp___0 ;
  TrieIndex tmp___1 ;
  TrieIndex tmp___2 ;
  TrieIndex tc___0 ;
  TrieIndex tmp___3 ;
  Bool tmp___4 ;

  {
  {
#line 334
  s = da_get_root((DArray const   *)trie->da);
#line 335
  p = key;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 335
    tmp___1 = da_get_base((DArray const   *)trie->da, s);
    }
#line 335
    if (tmp___1 < 0) {
#line 335
      goto while_break;
    }
    {
#line 336
    tmp = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 336
    tc = tmp;
    }
#line 337
    if (2147483647 == tc) {
#line 338
      return ((Bool )0);
    }
    {
#line 339
    tmp___0 = da_walk((DArray const   *)trie->da, & s, (TrieChar )tc);
    }
#line 339
    if (! tmp___0) {
#line 340
      return ((Bool )0);
    }
#line 341
    if (0U == *p) {
#line 342
      goto while_break;
    }
#line 335
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 346
  tmp___2 = da_get_base((DArray const   *)trie->da, s);
#line 346
  s = - tmp___2;
#line 347
  suffix_idx = (short)0;
  }
  {
#line 348
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 349
    tmp___3 = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 349
    tc___0 = tmp___3;
    }
#line 350
    if (2147483647 == tc___0) {
#line 351
      return ((Bool )0);
    }
    {
#line 352
    tmp___4 = tail_walk_char((Tail const   *)trie->tail, s, & suffix_idx, (TrieChar )tc___0);
    }
#line 352
    if (! tmp___4) {
#line 353
      return ((Bool )0);
    }
#line 354
    if (0U == *p) {
#line 355
      goto while_break___0;
    }
#line 348
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 359
  if (o_data) {
    {
#line 360
    *o_data = tail_get_data((Tail const   *)trie->tail, s);
    }
  }
#line 361
  return ((Bool )1);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_store(Trie *trie , AlphaChar const   *key , TrieData data ) 
{ 
  Bool tmp ;

  {
  {
#line 380
  tmp = trie_store_conditionally(trie, key, data, (Bool )1);
  }
#line 380
  return (tmp);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_store_if_absent(Trie *trie , AlphaChar const   *key , TrieData data ) 
{ 
  Bool tmp ;

  {
  {
#line 404
  tmp = trie_store_conditionally(trie, key, data, (Bool )0);
  }
#line 404
  return (tmp);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_store_conditionally(Trie *trie , AlphaChar const   *key , TrieData data ,
                                     Bool is_overwrite ) 
{ 
  TrieIndex s ;
  TrieIndex t ;
  short suffix_idx ;
  AlphaChar const   *p ;
  AlphaChar const   *sep ;
  TrieIndex tc ;
  TrieIndex tmp ;
  TrieChar *key_str ;
  Bool res ;
  Bool tmp___0 ;
  TrieIndex tmp___1 ;
  TrieIndex tmp___2 ;
  TrieIndex tc___0 ;
  TrieIndex tmp___3 ;
  TrieChar *tail_str ;
  Bool res___0 ;
  Bool tmp___4 ;

  {
  {
#line 418
  s = da_get_root((DArray const   *)trie->da);
#line 419
  p = key;
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    tmp___1 = da_get_base((DArray const   *)trie->da, s);
    }
#line 419
    if (tmp___1 < 0) {
#line 419
      goto while_break;
    }
    {
#line 420
    tmp = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 420
    tc = tmp;
    }
#line 421
    if (2147483647 == tc) {
#line 422
      return ((Bool )0);
    }
    {
#line 423
    tmp___0 = da_walk((DArray const   *)trie->da, & s, (TrieChar )tc);
    }
#line 423
    if (! tmp___0) {
      {
#line 427
      key_str = alpha_map_char_to_trie_str((AlphaMap const   *)trie->alpha_map, p);
      }
#line 428
      if (! key_str) {
#line 429
        return ((Bool )0);
      }
      {
#line 430
      res = trie_branch_in_branch(trie, s, (TrieChar const   *)key_str, data);
#line 431
      free((void *)key_str);
      }
#line 433
      return (res);
    }
#line 435
    if (0U == *p) {
#line 436
      goto while_break;
    }
#line 419
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  sep = p;
#line 441
  tmp___2 = da_get_base((DArray const   *)trie->da, s);
#line 441
  t = - tmp___2;
#line 442
  suffix_idx = (short)0;
  }
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 444
    tmp___3 = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 444
    tc___0 = tmp___3;
    }
#line 445
    if (2147483647 == tc___0) {
#line 446
      return ((Bool )0);
    }
    {
#line 447
    tmp___4 = tail_walk_char((Tail const   *)trie->tail, t, & suffix_idx, (TrieChar )tc___0);
    }
#line 447
    if (! tmp___4) {
      {
#line 451
      tail_str = alpha_map_char_to_trie_str((AlphaMap const   *)trie->alpha_map, sep);
      }
#line 452
      if (! tail_str) {
#line 453
        return ((Bool )0);
      }
      {
#line 454
      res___0 = trie_branch_in_tail(trie, s, (TrieChar const   *)tail_str, data);
#line 455
      free((void *)tail_str);
      }
#line 457
      return (res___0);
    }
#line 459
    if (0U == *p) {
#line 460
      goto while_break___0;
    }
#line 443
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 464
  if (! is_overwrite) {
#line 465
    return ((Bool )0);
  }
  {
#line 467
  tail_set_data(trie->tail, t, data);
#line 468
  trie->is_dirty = (Bool )1;
  }
#line 469
  return ((Bool )1);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_branch_in_branch(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                  TrieData data ) 
{ 
  TrieIndex new_da ;
  TrieIndex new_tail ;

  {
  {
#line 480
  new_da = da_insert_branch(trie->da, sep_node, (TrieChar )*suffix);
  }
#line 481
  if (0 == new_da) {
#line 482
    return ((Bool )0);
  }
#line 484
  if (0 != (int )*suffix) {
#line 485
    suffix ++;
  }
  {
#line 487
  new_tail = tail_add_suffix(trie->tail, suffix);
#line 488
  tail_set_data(trie->tail, new_tail, data);
#line 489
  da_set_base(trie->da, new_da, - new_tail);
#line 491
  trie->is_dirty = (Bool )1;
  }
#line 492
  return ((Bool )1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_branch_in_tail(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                TrieData data ) 
{ 
  TrieIndex old_tail ;
  TrieIndex old_da ;
  TrieIndex s ;
  TrieChar const   *old_suffix ;
  TrieChar const   *p ;
  TrieIndex tmp ;
  TrieIndex t ;
  TrieIndex tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 505
  tmp = da_get_base((DArray const   *)trie->da, sep_node);
#line 505
  old_tail = - tmp;
#line 506
  old_suffix = tail_get_suffix((Tail const   *)trie->tail, old_tail);
  }
#line 507
  if (! old_suffix) {
#line 508
    return ((Bool )0);
  }
#line 510
  p = old_suffix;
#line 510
  s = sep_node;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int const   )*p == (int const   )*suffix)) {
#line 510
      goto while_break;
    }
    {
#line 511
    tmp___0 = da_insert_branch(trie->da, s, (TrieChar )*p);
#line 511
    t = tmp___0;
    }
#line 512
    if (0 == t) {
#line 513
      goto fail;
    }
#line 514
    s = t;
#line 510
    p ++;
#line 510
    suffix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  old_da = da_insert_branch(trie->da, s, (TrieChar )*p);
  }
#line 518
  if (0 == old_da) {
#line 519
    goto fail;
  }
#line 521
  if (0 != (int )*p) {
#line 522
    p ++;
  }
  {
#line 523
  tail_set_suffix(trie->tail, old_tail, p);
#line 524
  da_set_base(trie->da, old_da, - old_tail);
#line 527
  tmp___1 = trie_branch_in_branch(trie, s, suffix, data);
  }
#line 527
  return (tmp___1);
  fail: 
  {
#line 531
  da_prune_upto(trie->da, sep_node, s);
#line 532
  da_set_base(trie->da, sep_node, - old_tail);
  }
#line 533
  return ((Bool )0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_delete(Trie *trie , AlphaChar const   *key ) 
{ 
  TrieIndex s ;
  TrieIndex t ;
  short suffix_idx ;
  AlphaChar const   *p ;
  TrieIndex tc ;
  TrieIndex tmp ;
  Bool tmp___0 ;
  TrieIndex tmp___1 ;
  TrieIndex tmp___2 ;
  TrieIndex tc___0 ;
  TrieIndex tmp___3 ;
  Bool tmp___4 ;

  {
  {
#line 554
  s = da_get_root((DArray const   *)trie->da);
#line 555
  p = key;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 555
    tmp___1 = da_get_base((DArray const   *)trie->da, s);
    }
#line 555
    if (tmp___1 < 0) {
#line 555
      goto while_break;
    }
    {
#line 556
    tmp = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 556
    tc = tmp;
    }
#line 557
    if (2147483647 == tc) {
#line 558
      return ((Bool )0);
    }
    {
#line 559
    tmp___0 = da_walk((DArray const   *)trie->da, & s, (TrieChar )tc);
    }
#line 559
    if (! tmp___0) {
#line 560
      return ((Bool )0);
    }
#line 561
    if (0U == *p) {
#line 562
      goto while_break;
    }
#line 555
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  tmp___2 = da_get_base((DArray const   *)trie->da, s);
#line 566
  t = - tmp___2;
#line 567
  suffix_idx = (short)0;
  }
  {
#line 568
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 569
    tmp___3 = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 569
    tc___0 = tmp___3;
    }
#line 570
    if (2147483647 == tc___0) {
#line 571
      return ((Bool )0);
    }
    {
#line 572
    tmp___4 = tail_walk_char((Tail const   *)trie->tail, t, & suffix_idx, (TrieChar )tc___0);
    }
#line 572
    if (! tmp___4) {
#line 573
      return ((Bool )0);
    }
#line 574
    if (0U == *p) {
#line 575
      goto while_break___0;
    }
#line 568
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 578
  tail_delete(trie->tail, t);
#line 579
  da_set_base(trie->da, s, 0);
#line 580
  da_prune(trie->da, s);
#line 582
  trie->is_dirty = (Bool )1;
  }
#line 583
  return ((Bool )1);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_enumerate(Trie const   *trie , Bool (*enum_func)(AlphaChar const   *key ,
                                                           TrieData key_data , void *user_data ) ,
                    void *user_data ) 
{ 
  TrieState *root ;
  TrieIterator *iter ;
  Bool cont ;
  AlphaChar *key ;
  AlphaChar *tmp ;
  TrieData data ;
  TrieData tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 604
  cont = (Bool )1;
#line 606
  root = trie_root(trie);
  }
#line 607
  if (! root) {
#line 608
    return ((Bool )0);
  }
  {
#line 610
  iter = trie_iterator_new(root);
  }
#line 611
  if (! iter) {
#line 612
    goto exit_root_created;
  }
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    if (cont) {
      {
#line 614
      tmp___1 = trie_iterator_next(iter);
      }
#line 614
      if (! tmp___1) {
#line 614
        goto while_break;
      }
    } else {
#line 614
      goto while_break;
    }
    {
#line 615
    tmp = trie_iterator_get_key((TrieIterator const   *)iter);
#line 615
    key = tmp;
#line 616
    tmp___0 = trie_iterator_get_data((TrieIterator const   *)iter);
#line 616
    data = tmp___0;
#line 617
    cont = (*enum_func)((AlphaChar const   *)key, data, user_data);
#line 618
    free((void *)key);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 621
  trie_iterator_free(iter);
#line 622
  trie_state_free(root);
  }
#line 624
  return (cont);
  exit_root_created: 
  {
#line 627
  trie_state_free(root);
  }
#line 628
  return ((Bool )0);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
TrieState *trie_root(Trie const   *trie ) 
{ 
  TrieIndex tmp ;
  TrieState *tmp___0 ;

  {
  {
#line 650
  tmp = da_get_root((DArray const   *)trie->da);
#line 650
  tmp___0 = trie_state_new(trie, tmp, (short)0, (short)0);
  }
#line 650
  return (tmp___0);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static TrieState *trie_state_new(Trie const   *trie , TrieIndex index___0 , short suffix_idx ,
                                 short is_suffix ) 
{ 
  TrieState *s ;
  void *tmp ;

  {
  {
#line 665
  tmp = malloc(sizeof(TrieState ));
#line 665
  s = (TrieState *)tmp;
  }
#line 666
  if (! s) {
#line 667
    return ((TrieState *)((void *)0));
  }
#line 669
  s->trie = trie;
#line 670
  s->index = index___0;
#line 671
  s->suffix_idx = suffix_idx;
#line 672
  s->is_suffix = is_suffix;
#line 674
  return (s);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
void trie_state_copy(TrieState *dst , TrieState const   *src ) 
{ 


  {
#line 690
  *dst = (TrieState )*src;
#line 691
  return;
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
TrieState *trie_state_clone(TrieState const   *s ) 
{ 
  TrieState *tmp ;

  {
  {
#line 707
  tmp = trie_state_new((Trie const   *)s->trie, (TrieIndex )s->index, (short )s->suffix_idx,
                       (short )s->is_suffix);
  }
#line 707
  return (tmp);
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
void trie_state_free(TrieState *s ) 
{ 


  {
  {
#line 720
  free((void *)s);
  }
#line 721
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
void trie_state_rewind(TrieState *s ) 
{ 


  {
  {
#line 733
  s->index = da_get_root((DArray const   *)(s->trie)->da);
#line 734
  s->is_suffix = (short)0;
  }
#line 735
  return;
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_state_walk(TrieState *s , AlphaChar c ) 
{ 
  TrieIndex tc ;
  TrieIndex tmp ;
  Bool ret ;
  TrieIndex tmp___0 ;
  TrieIndex tmp___1 ;
  Bool tmp___2 ;

  {
  {
#line 751
  tmp = alpha_map_char_to_trie((AlphaMap const   *)(s->trie)->alpha_map, c);
#line 751
  tc = tmp;
  }
#line 752
  if (2147483647 == tc) {
#line 753
    return ((Bool )0);
  }
#line 755
  if (! s->is_suffix) {
    {
#line 758
    ret = da_walk((DArray const   *)(s->trie)->da, & s->index, (TrieChar )tc);
    }
#line 760
    if (ret) {
      {
#line 760
      tmp___1 = da_get_base((DArray const   *)(s->trie)->da, s->index);
      }
#line 760
      if (tmp___1 < 0) {
        {
#line 761
        tmp___0 = da_get_base((DArray const   *)(s->trie)->da, s->index);
#line 761
        s->index = - tmp___0;
#line 762
        s->suffix_idx = (short)0;
#line 763
        s->is_suffix = (short)1;
        }
      }
    }
#line 766
    return (ret);
  } else {
    {
#line 768
    tmp___2 = tail_walk_char((Tail const   *)(s->trie)->tail, s->index, & s->suffix_idx,
                             (TrieChar )tc);
    }
#line 768
    return (tmp___2);
  }
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_state_is_walkable(TrieState const   *s , AlphaChar c ) 
{ 
  TrieIndex tc ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  TrieIndex tmp___1 ;
  TrieChar const   *tmp___2 ;

  {
  {
#line 786
  tmp = alpha_map_char_to_trie((AlphaMap const   *)(s->trie)->alpha_map, c);
#line 786
  tc = tmp;
  }
#line 787
  if (2147483647 == tc) {
#line 788
    return ((Bool )0);
  }
#line 790
  if (! s->is_suffix) {
    {
#line 791
    tmp___0 = da_get_base((DArray const   *)(s->trie)->da, (TrieIndex )s->index);
#line 791
    tmp___1 = da_get_check((DArray const   *)(s->trie)->da, tmp___0 + (TrieIndex )((TrieChar )tc));
    }
#line 791
    return ((Bool )(tmp___1 == (TrieIndex )s->index));
  } else {
    {
#line 793
    tmp___2 = tail_get_suffix((Tail const   *)(s->trie)->tail, (TrieIndex )s->index);
    }
#line 793
    return ((Bool )((int const   )*(tmp___2 + s->suffix_idx) == (int const   )((TrieChar )tc)));
  }
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
int trie_state_walkable_chars(TrieState const   *s , AlphaChar *chars , int chars_nelm ) 
{ 
  int syms_num ;
  Symbols *syms ;
  Symbols *tmp ;
  int i ;
  TrieChar tc ;
  TrieChar tmp___0 ;
  TrieChar const   *suffix ;
  TrieChar const   *tmp___1 ;

  {
#line 820
  syms_num = 0;
#line 822
  if (! s->is_suffix) {
    {
#line 823
    tmp = da_output_symbols((DArray const   *)(s->trie)->da, (TrieIndex )s->index);
#line 823
    syms = tmp;
#line 826
    syms_num = symbols_num((Symbols const   *)syms);
#line 827
    i = 0;
    }
    {
#line 827
    while (1) {
      while_continue: /* CIL Label */ ;
#line 827
      if (i < syms_num) {
#line 827
        if (! (i < chars_nelm)) {
#line 827
          goto while_break;
        }
      } else {
#line 827
        goto while_break;
      }
      {
#line 828
      tmp___0 = symbols_get((Symbols const   *)syms, i);
#line 828
      tc = tmp___0;
#line 829
      *(chars + i) = alpha_map_trie_to_char((AlphaMap const   *)(s->trie)->alpha_map,
                                            tc);
#line 827
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 832
    symbols_free(syms);
    }
  } else {
    {
#line 834
    tmp___1 = tail_get_suffix((Tail const   *)(s->trie)->tail, (TrieIndex )s->index);
#line 834
    suffix = tmp___1;
#line 835
    *(chars + 0) = alpha_map_trie_to_char((AlphaMap const   *)(s->trie)->alpha_map,
                                          (TrieChar )*(suffix + s->suffix_idx));
#line 837
    syms_num = 1;
    }
  }
#line 840
  return (syms_num);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_state_is_single(TrieState const   *s ) 
{ 


  {
#line 856
  return ((Bool )s->is_suffix);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
TrieData trie_state_get_data(TrieState const   *s ) 
{ 
  TrieData tmp___1 ;
  TrieData tmp___2 ;
  Bool tmp___3 ;
  Bool tmp___4 ;

  {
  {
#line 873
  tmp___3 = trie_state_is_single(s);
  }
#line 873
  if (tmp___3) {
    {
#line 873
    tmp___4 = trie_state_is_walkable(s, (AlphaChar )'\000');
    }
#line 873
    if (tmp___4) {
      {
#line 873
      tmp___1 = tail_get_data((Tail const   *)(s->trie)->tail, (TrieIndex )s->index);
#line 873
      tmp___2 = tmp___1;
      }
    } else {
#line 873
      tmp___2 = -1;
    }
  } else {
#line 873
    tmp___2 = -1;
  }
#line 873
  return (tmp___2);
}
}
#line 898 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
TrieIterator *trie_iterator_new(TrieState *s ) 
{ 
  TrieIterator *iter ;
  void *tmp ;

  {
  {
#line 903
  tmp = malloc(sizeof(TrieIterator ));
#line 903
  iter = (TrieIterator *)tmp;
  }
#line 904
  if (! iter) {
#line 905
    return ((TrieIterator *)((void *)0));
  }
#line 907
  iter->root = (TrieState const   *)s;
#line 908
  iter->state = (TrieState *)((void *)0);
#line 909
  iter->key = (TrieString *)((void *)0);
#line 911
  return (iter);
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
void trie_iterator_free(TrieIterator *iter ) 
{ 


  {
#line 926
  if (iter->state) {
    {
#line 927
    trie_state_free(iter->state);
    }
  }
#line 929
  if (iter->key) {
    {
#line 930
    trie_string_free(iter->key);
    }
  }
  {
#line 932
  free((void *)iter);
  }
#line 933
  return;
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
Bool trie_iterator_next(TrieIterator *iter ) 
{ 
  TrieState *s ;
  TrieIndex sep ;
  TrieState *tmp ;

  {
#line 951
  s = iter->state;
#line 955
  if (! s) {
    {
#line 956
    tmp = trie_state_clone(iter->root);
#line 956
    iter->state = tmp;
#line 956
    s = tmp;
    }
#line 959
    if (s->is_suffix) {
#line 960
      return ((Bool )1);
    }
    {
#line 962
    iter->key = trie_string_new(20);
#line 963
    sep = da_first_separate((DArray *)(s->trie)->da, s->index, iter->key);
    }
#line 964
    if (0 == sep) {
#line 965
      return ((Bool )0);
    }
#line 967
    s->index = sep;
#line 968
    return ((Bool )1);
  }
#line 972
  if (s->is_suffix) {
#line 973
    return ((Bool )0);
  }
  {
#line 976
  sep = da_next_separate((DArray *)(s->trie)->da, (TrieIndex )(iter->root)->index,
                         s->index, iter->key);
  }
#line 978
  if (0 == sep) {
#line 979
    return ((Bool )0);
  }
#line 981
  s->index = sep;
#line 982
  return ((Bool )1);
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
AlphaChar *trie_iterator_get_key(TrieIterator const   *iter ) 
{ 
  TrieState const   *s ;
  TrieChar const   *tail_str ;
  AlphaChar *alpha_key ;
  AlphaChar *alpha_p ;
  size_t tmp ;
  void *tmp___0 ;
  TrieIndex tail_idx ;
  int i ;
  int key_len ;
  TrieChar const   *key_p ;
  TrieIndex tmp___1 ;
  void const   *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  AlphaChar *tmp___5 ;
  TrieChar const   *tmp___6 ;
  AlphaChar *tmp___7 ;
  TrieChar const   *tmp___8 ;

  {
#line 1005
  s = (TrieState const   *)iter->state;
#line 1006
  if (! s) {
#line 1007
    return ((AlphaChar *)((void *)0));
  }
#line 1010
  if (s->is_suffix) {
    {
#line 1011
    tail_str = tail_get_suffix((Tail const   *)(s->trie)->tail, (TrieIndex )s->index);
    }
#line 1012
    if (! tail_str) {
#line 1013
      return ((AlphaChar *)((void *)0));
    }
    {
#line 1015
    tail_str += (int const   )s->suffix_idx;
#line 1017
    tmp = strlen((char const   *)tail_str);
#line 1017
    tmp___0 = malloc(sizeof(AlphaChar ) * (tmp + 1UL));
#line 1017
    alpha_key = (AlphaChar *)tmp___0;
#line 1020
    alpha_p = alpha_key;
    }
  } else {
    {
#line 1026
    tmp___1 = da_get_base((DArray const   *)(s->trie)->da, (TrieIndex )s->index);
#line 1026
    tail_idx = - tmp___1;
#line 1027
    tail_str = tail_get_suffix((Tail const   *)(s->trie)->tail, tail_idx);
    }
#line 1028
    if (! tail_str) {
#line 1029
      return ((AlphaChar *)((void *)0));
    }
    {
#line 1031
    key_len = trie_string_length((TrieString const   *)iter->key);
#line 1032
    tmp___2 = trie_string_get_val((TrieString const   *)iter->key);
#line 1032
    key_p = (TrieChar const   *)tmp___2;
#line 1033
    tmp___3 = strlen((char const   *)tail_str);
#line 1033
    tmp___4 = malloc(sizeof(AlphaChar ) * (((size_t )key_len + tmp___3) + 1UL));
#line 1033
    alpha_key = (AlphaChar *)tmp___4;
#line 1037
    alpha_p = alpha_key;
#line 1038
    i = key_len;
    }
    {
#line 1038
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1038
      if (! (i > 0)) {
#line 1038
        goto while_break;
      }
      {
#line 1039
      tmp___5 = alpha_p;
#line 1039
      alpha_p ++;
#line 1039
      tmp___6 = key_p;
#line 1039
      key_p ++;
#line 1039
      *tmp___5 = alpha_map_trie_to_char((AlphaMap const   *)(s->trie)->alpha_map,
                                        (TrieChar )*tmp___6);
#line 1038
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1043
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1043
    if (! *tail_str) {
#line 1043
      goto while_break___0;
    }
    {
#line 1044
    tmp___7 = alpha_p;
#line 1044
    alpha_p ++;
#line 1044
    tmp___8 = tail_str;
#line 1044
    tail_str ++;
#line 1044
    *tmp___7 = alpha_map_trie_to_char((AlphaMap const   *)(s->trie)->alpha_map, (TrieChar )*tmp___8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1046
  *alpha_p = (AlphaChar )0;
#line 1048
  return (alpha_key);
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
TrieData trie_iterator_get_data(TrieIterator const   *iter ) 
{ 
  TrieState const   *s ;
  TrieIndex tail_index ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  TrieData tmp___1 ;

  {
#line 1068
  s = (TrieState const   *)iter->state;
#line 1071
  if (! s) {
#line 1072
    return (-1);
  }
#line 1074
  if (! s->is_suffix) {
    {
#line 1075
    tmp = da_get_base((DArray const   *)(s->trie)->da, (TrieIndex )s->index);
    }
#line 1075
    if (! (tmp < 0)) {
#line 1076
      return (-1);
    }
    {
#line 1078
    tmp___0 = da_get_base((DArray const   *)(s->trie)->da, (TrieIndex )s->index);
#line 1078
    tail_index = - tmp___0;
    }
  } else {
#line 1080
    tail_index = (TrieIndex )s->index;
  }
  {
#line 1083
  tmp___1 = tail_get_data((Tail const   *)(s->trie)->tail, tail_index);
  }
#line 1083
  return (tmp___1);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.h"
Bool file_read_int8(FILE *file , int8 *o_val ) ;
#line 40
Bool file_write_int8(FILE *file , int8 val ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_read_int32(FILE *file , int32 *o_val ) 
{ 
  unsigned char buff[4] ;
  size_t tmp ;

  {
  {
#line 43
  tmp = fread((void */* __restrict  */)(buff), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 43
  if (tmp == 1UL) {
#line 44
    *o_val = ((((int )buff[0] << 24) | ((int )buff[1] << 16)) | ((int )buff[2] << 8)) | (int )buff[3];
#line 45
    return ((Bool )1);
  }
#line 48
  return ((Bool )0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_write_int32(FILE *file , int32 val ) 
{ 
  unsigned char buff[4] ;
  size_t tmp ;

  {
  {
#line 56
  buff[0] = (unsigned char )((val >> 24) & 255);
#line 57
  buff[1] = (unsigned char )((val >> 16) & 255);
#line 58
  buff[2] = (unsigned char )((val >> 8) & 255);
#line 59
  buff[3] = (unsigned char )(val & 255);
#line 61
  tmp = fwrite((void const   */* __restrict  */)(buff), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 61
  return ((Bool )(tmp == 1UL));
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_read_int16(FILE *file , int16 *o_val ) 
{ 
  unsigned char buff[2] ;
  size_t tmp ;

  {
  {
#line 69
  tmp = fread((void */* __restrict  */)(buff), (size_t )2, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 69
  if (tmp == 1UL) {
#line 70
    *o_val = (int16 )(((int )buff[0] << 8) | (int )buff[1]);
#line 71
    return ((Bool )1);
  }
#line 74
  return ((Bool )0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_write_int16(FILE *file , int16 val ) 
{ 
  unsigned char buff[2] ;
  size_t tmp ;

  {
  {
#line 82
  buff[0] = (unsigned char )((int )val >> 8);
#line 83
  buff[1] = (unsigned char )((int )val & 255);
#line 85
  tmp = fwrite((void const   */* __restrict  */)(buff), (size_t )2, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 85
  return ((Bool )(tmp == 1UL));
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_read_int8(FILE *file , int8 *o_val ) 
{ 
  size_t tmp ;

  {
  {
#line 91
  tmp = fread((void */* __restrict  */)o_val, sizeof(int8 ), (size_t )1, (FILE */* __restrict  */)file);
  }
#line 91
  return ((Bool )(tmp == 1UL));
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_write_int8(FILE *file , int8 val ) 
{ 
  size_t tmp ;

  {
  {
#line 97
  tmp = fwrite((void const   */* __restrict  */)(& val), sizeof(int8 ), (size_t )1,
               (FILE */* __restrict  */)file);
  }
#line 97
  return ((Bool )(tmp == 1UL));
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_read_chars(FILE *file , char *buff , int len ) 
{ 
  size_t tmp ;

  {
  {
#line 103
  tmp = fread((void */* __restrict  */)buff, sizeof(char ), (size_t )len, (FILE */* __restrict  */)file);
  }
#line 103
  return ((Bool )(tmp == (size_t )len));
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/fileutils.c"
Bool file_write_chars(FILE *file , char const   *buff , int len ) 
{ 
  size_t tmp ;

  {
  {
#line 109
  tmp = fwrite((void const   */* __restrict  */)buff, sizeof(char ), (size_t )len,
               (FILE */* __restrict  */)file);
  }
#line 109
  return ((Bool )(tmp == (size_t )len));
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
DString *dstring_new(int char_size , int n_elm ) 
{ 
  DString *ds ;
  void *tmp ;

  {
  {
#line 40
  tmp = malloc(sizeof(DString ));
#line 40
  ds = (DString *)tmp;
  }
#line 41
  if (! ds) {
#line 42
    return ((DString *)((void *)0));
  }
  {
#line 44
  ds->alloc_size = char_size * n_elm;
#line 45
  ds->val = malloc((size_t )ds->alloc_size);
  }
#line 46
  if (! ds->val) {
    {
#line 47
    free((void *)ds);
    }
#line 48
    return ((DString *)((void *)0));
  }
#line 51
  ds->char_size = char_size;
#line 52
  ds->str_len = 0;
#line 54
  return (ds);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
void dstring_free(DString *ds ) 
{ 


  {
  {
#line 60
  free(ds->val);
#line 61
  free((void *)ds);
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
int dstring_length(DString const   *ds ) 
{ 


  {
#line 67
  return ((int )ds->str_len);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
void const   *dstring_get_val(DString const   *ds ) 
{ 


  {
#line 73
  return ((void const   *)ds->val);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
void *dstring_get_val_rw(DString *ds ) 
{ 


  {
#line 79
  return (ds->val);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
void dstring_clear(DString *ds ) 
{ 


  {
#line 85
  ds->str_len = 0;
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
static Bool dstring_ensure_space(DString *ds , int size ) 
{ 
  int re_size ;
  int tmp ;
  void *re_ptr ;
  void *tmp___0 ;

  {
#line 91
  if (ds->alloc_size < size) {
#line 92
    if (ds->alloc_size * 2 > size) {
#line 92
      tmp = ds->alloc_size * 2;
    } else {
#line 92
      tmp = size;
    }
    {
#line 92
    re_size = tmp;
#line 93
    tmp___0 = realloc(ds->val, (size_t )re_size);
#line 93
    re_ptr = tmp___0;
    }
#line 94
    if (! re_ptr) {
#line 95
      return ((Bool )0);
    }
#line 96
    ds->val = re_ptr;
#line 97
    ds->alloc_size = re_size;
  }
#line 100
  return ((Bool )1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_copy(DString *dst , DString const   *src ) 
{ 
  Bool tmp ;

  {
  {
#line 106
  tmp = dstring_ensure_space(dst, (int )((src->str_len + 1) * src->char_size));
  }
#line 106
  if (! tmp) {
#line 107
    return ((Bool )0);
  }
  {
#line 109
  memcpy((void */* __restrict  */)dst->val, (void const   */* __restrict  */)src->val,
         (size_t )((src->str_len + 1) * src->char_size));
#line 111
  dst->char_size = (int )src->char_size;
#line 112
  dst->str_len = (int )src->str_len;
  }
#line 114
  return ((Bool )1);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_append(DString *dst , DString const   *src ) 
{ 
  Bool tmp ;

  {
#line 120
  if (dst->char_size != (int )src->char_size) {
#line 121
    return ((Bool )0);
  }
  {
#line 123
  tmp = dstring_ensure_space(dst, ((dst->str_len + (int )src->str_len) + 1) * dst->char_size);
  }
#line 123
  if (! tmp) {
#line 126
    return ((Bool )0);
  }
  {
#line 129
  memcpy((void */* __restrict  */)((char *)dst->val + dst->char_size * dst->str_len),
         (void const   */* __restrict  */)src->val, (size_t )((src->str_len + 1) * (int const   )dst->char_size));
#line 132
  dst->str_len += (int )src->str_len;
  }
#line 134
  return ((Bool )1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_append_string(DString *ds , void const   *data , int len ) 
{ 
  Bool tmp ;

  {
  {
#line 140
  tmp = dstring_ensure_space(ds, ((ds->str_len + len) + 1) * ds->char_size);
  }
#line 140
  if (! tmp) {
#line 141
    return ((Bool )0);
  }
  {
#line 143
  memcpy((void */* __restrict  */)((char *)ds->val + ds->char_size * ds->str_len),
         (void const   */* __restrict  */)data, (size_t )(ds->char_size * len));
#line 146
  ds->str_len += len;
  }
#line 148
  return ((Bool )1);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_append_char(DString *ds , void const   *data ) 
{ 
  Bool tmp ;

  {
  {
#line 154
  tmp = dstring_ensure_space(ds, (ds->str_len + 2) * ds->char_size);
  }
#line 154
  if (! tmp) {
#line 155
    return ((Bool )0);
  }
  {
#line 157
  memcpy((void */* __restrict  */)((char *)ds->val + ds->char_size * ds->str_len),
         (void const   */* __restrict  */)data, (size_t )ds->char_size);
#line 160
  (ds->str_len) ++;
  }
#line 162
  return ((Bool )1);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_terminate(DString *ds ) 
{ 
  Bool tmp ;

  {
  {
#line 168
  tmp = dstring_ensure_space(ds, (ds->str_len + 2) * ds->char_size);
  }
#line 168
  if (! tmp) {
#line 169
    return ((Bool )0);
  }
  {
#line 171
  memset((void *)((char *)ds->val + ds->char_size * ds->str_len), 0, (size_t )ds->char_size);
  }
#line 173
  return ((Bool )1);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
Bool dstring_cut_last(DString *ds ) 
{ 


  {
#line 179
  if (0 == ds->str_len) {
#line 180
    return ((Bool )0);
  }
#line 182
  (ds->str_len) --;
#line 184
  return ((Bool )1);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static void init_conv(ProgEnv *env ) ;
#line 41
static size_t conv_to_alpha(ProgEnv *env , char const   *in , AlphaChar *out , size_t out_size ) ;
#line 45
static size_t conv_from_alpha(ProgEnv *env , AlphaChar const   *in , char *out , size_t out_size ) ;
#line 49
static void close_conv(ProgEnv *env ) ;
#line 51
static int prepare_trie(ProgEnv *env ) ;
#line 52
static int close_trie(ProgEnv *env ) ;
#line 54
static int decode_switch(int argc , char **argv , ProgEnv *env ) ;
#line 55
static int decode_command(int argc , char **argv , ProgEnv *env ) ;
#line 57
static int command_add(int argc , char **argv , ProgEnv *env ) ;
#line 58
static int command_add_list(int argc , char **argv , ProgEnv *env ) ;
#line 59
static int command_delete(int argc , char **argv , ProgEnv *env ) ;
#line 60
static int command_delete_list(int argc , char **argv , ProgEnv *env ) ;
#line 61
static int command_query(int argc , char **argv , ProgEnv *env ) ;
#line 62
static int command_list(int argc , char **argv , ProgEnv *env ) ;
#line 64
static void usage(char const   *prog_name , int exit_status ) ;
#line 66
static char *string_trim(char *s ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  ProgEnv env ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  env.path = ".";
#line 77
  init_conv(& env);
#line 79
  i = decode_switch(argc, argv, & env);
  }
#line 80
  if (i == argc) {
    {
#line 81
    usage((char const   *)*(argv + 0), 1);
    }
  }
  {
#line 83
  tmp = i;
#line 83
  i ++;
#line 83
  env.trie_name = (char const   *)*(argv + tmp);
#line 85
  tmp___0 = prepare_trie(& env);
  }
#line 85
  if (tmp___0 != 0) {
    {
#line 86
    exit(1);
    }
  }
  {
#line 88
  ret = decode_command(argc - i, argv + i, & env);
#line 90
  tmp___1 = close_trie(& env);
  }
#line 90
  if (tmp___1 != 0) {
    {
#line 91
    exit(1);
    }
  }
  {
#line 93
  close_conv(& env);
  }
#line 95
  return (ret);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static void init_conv(ProgEnv *env ) 
{ 
  char const   *prev_locale ;
  char const   *locale_codeset ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 104
  tmp = setlocale(0, "");
#line 104
  prev_locale = (char const   *)tmp;
#line 105
  tmp___0 = nl_langinfo(14);
#line 105
  locale_codeset = (char const   *)tmp___0;
#line 106
  setlocale(0, prev_locale);
#line 108
  env->to_alpha_conv = iconv_open("UCS-4LE", locale_codeset);
#line 109
  env->from_alpha_conv = iconv_open(locale_codeset, "UCS-4LE");
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static size_t conv_to_alpha(ProgEnv *env , char const   *in , AlphaChar *out , size_t out_size ) 
{ 
  char *in_p ;
  char *out_p ;
  size_t in_left ;
  size_t tmp ;
  size_t out_left ;
  size_t res ;
  unsigned char const   *byte_p ;
  size_t tmp___0 ;

  {
  {
#line 115
  in_p = (char *)in;
#line 116
  out_p = (char *)out;
#line 117
  tmp = strlen(in);
#line 117
  in_left = tmp;
#line 118
  out_left = out_size * sizeof(AlphaChar );
  }
#line 122
  if (! (sizeof(AlphaChar ) == 4UL)) {
    {
#line 122
    __assert_fail("sizeof (AlphaChar) == 4", "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c",
                  122U, "conv_to_alpha");
    }
  }
  {
#line 125
  res = iconv(env->to_alpha_conv, (char **/* __restrict  */)(& in_p), (size_t */* __restrict  */)(& in_left),
              (char **/* __restrict  */)(& out_p), (size_t */* __restrict  */)(& out_left));
  }
#line 128
  if (res < 0UL) {
#line 129
    return (res);
  }
#line 132
  res = (size_t )0;
#line 133
  byte_p = (unsigned char const   *)out;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (res < out_size) {
#line 133
      if (! ((unsigned long )(byte_p + 3) < (unsigned long )((unsigned char *)out_p))) {
#line 133
        goto while_break;
      }
    } else {
#line 133
      goto while_break;
    }
#line 137
    tmp___0 = res;
#line 137
    res ++;
#line 137
    *(out + tmp___0) = (AlphaChar )((((int const   )*(byte_p + 0) | ((int const   )*(byte_p + 1) << 8)) | ((int const   )*(byte_p + 2) << 16)) | ((int const   )*(byte_p + 3) << 24));
#line 133
    byte_p += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (res < out_size) {
#line 143
    *(out + res) = (AlphaChar )0;
  }
#line 146
  return (res);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static size_t conv_from_alpha(ProgEnv *env , AlphaChar const   *in , char *out , size_t out_size ) 
{ 
  size_t in_left ;
  int tmp ;
  size_t res ;
  unsigned char b[4] ;

  {
  {
#line 152
  tmp = alpha_char_strlen(in);
#line 152
  in_left = (unsigned long )tmp * sizeof(AlphaChar );
  }
#line 155
  if (! (sizeof(AlphaChar ) == 4UL)) {
    {
#line 155
    __assert_fail("sizeof (AlphaChar) == 4", "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c",
                  155U, "conv_from_alpha");
    }
  }
#line 158
  res = (size_t )0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! *(in + res)) {
#line 158
      goto while_break;
    }
    {
#line 161
    b[0] = (unsigned char )(*(in + res) & 255U);
#line 162
    b[1] = (unsigned char )((*(in + res) >> 8) & 255U);
#line 163
    b[2] = (unsigned char )((*(in + res) >> 16) & 255U);
#line 164
    b[3] = (unsigned char )((*(in + res) >> 24) & 255U);
#line 166
    memcpy((void */* __restrict  */)((char *)(in + res)), (void const   */* __restrict  */)(b),
           (size_t )4);
#line 158
    res ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  res = iconv(env->from_alpha_conv, (char **/* __restrict  */)((char **)(& in)), (size_t */* __restrict  */)(& in_left),
              (char **/* __restrict  */)(& out), (size_t */* __restrict  */)(& out_size));
#line 172
  *out = (char)0;
  }
#line 174
  return (res);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static void close_conv(ProgEnv *env ) 
{ 


  {
  {
#line 180
  iconv_close(env->to_alpha_conv);
#line 181
  iconv_close(env->from_alpha_conv);
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int prepare_trie(ProgEnv *env ) 
{ 
  char buff[256] ;
  FILE *sbm ;
  AlphaMap *alpha_map ;
  int b ;
  int e ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 189
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s/%s.tri",
           env->path, env->trie_name);
#line 191
  env->trie = trie_new_from_file((char const   *)(buff));
  }
#line 193
  if (! env->trie) {
    {
#line 197
    snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s/%s.abm",
             env->path, env->trie_name);
#line 199
    sbm = fopen((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"r");
    }
#line 200
    if (! sbm) {
      {
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open alphabet map file %s\n",
              buff);
      }
#line 202
      return (-1);
    }
    {
#line 205
    alpha_map = alpha_map_new();
    }
    {
#line 207
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 207
      tmp___0 = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)sbm);
      }
#line 207
      if (! tmp___0) {
#line 207
        goto while_break;
      }
      {
#line 214
      tmp = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)" [ %x , %x ] ",
                   & b, & e);
      }
#line 214
      if (tmp != 2) {
#line 215
        goto while_continue;
      }
#line 216
      if (b > e) {
        {
#line 217
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Range begin (%x) > range end (%x)\n",
                b, e);
        }
#line 218
        goto while_continue;
      }
      {
#line 221
      alpha_map_add_range(alpha_map, (AlphaChar )b, (AlphaChar )e);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 224
    env->trie = trie_new((AlphaMap const   *)alpha_map);
#line 226
    alpha_map_free(alpha_map);
#line 227
    fclose(sbm);
    }
  }
#line 230
  return (0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int close_trie(ProgEnv *env ) 
{ 
  char path[256] ;
  int tmp ;
  Bool tmp___0 ;

  {
  {
#line 236
  tmp___0 = trie_is_dirty((Trie const   *)env->trie);
  }
#line 236
  if (tmp___0) {
    {
#line 239
    snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s.tri",
             env->path, env->trie_name);
#line 241
    tmp = trie_save(env->trie, (char const   *)(path));
    }
#line 241
    if (tmp != 0) {
      {
#line 242
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot save trie to %s\n",
              path);
      }
#line 243
      return (-1);
    }
  }
  {
#line 247
  trie_free(env->trie);
  }
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int decode_switch(int argc , char **argv , ProgEnv *env ) 
{ 
  int opt_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 256
  opt_idx = 1;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (opt_idx < argc) {
#line 256
      if (! ((int )*(*(argv + opt_idx)) == 45)) {
#line 256
        goto while_break;
      }
    } else {
#line 256
      goto while_break;
    }
    {
#line 257
    tmp___4 = strcmp((char const   *)*(argv + opt_idx), "-h");
    }
#line 257
    if (tmp___4 == 0) {
      {
#line 260
      usage((char const   *)*(argv + 0), 1);
      }
    } else {
      {
#line 257
      tmp___5 = strcmp((char const   *)*(argv + opt_idx), "--help");
      }
#line 257
      if (tmp___5 == 0) {
        {
#line 260
        usage((char const   *)*(argv + 0), 1);
        }
      } else {
        {
#line 261
        tmp___2 = strcmp((char const   *)*(argv + opt_idx), "-V");
        }
#line 261
        if (tmp___2 == 0) {
          {
#line 264
          printf((char const   */* __restrict  */)"%s\n", "0.2.8");
#line 265
          exit(1);
          }
        } else {
          {
#line 261
          tmp___3 = strcmp((char const   *)*(argv + opt_idx), "--version");
          }
#line 261
          if (tmp___3 == 0) {
            {
#line 264
            printf((char const   */* __restrict  */)"%s\n", "0.2.8");
#line 265
            exit(1);
            }
          } else {
            {
#line 266
            tmp___0 = strcmp((char const   *)*(argv + opt_idx), "-p");
            }
#line 266
            if (tmp___0 == 0) {
#line 269
              opt_idx ++;
#line 269
              env->path = (char const   *)*(argv + opt_idx);
            } else {
              {
#line 266
              tmp___1 = strcmp((char const   *)*(argv + opt_idx), "--path");
              }
#line 266
              if (tmp___1 == 0) {
#line 269
                opt_idx ++;
#line 269
                env->path = (char const   *)*(argv + opt_idx);
              } else {
                {
#line 270
                tmp = strcmp((char const   *)*(argv + opt_idx), "--");
                }
#line 270
                if (tmp == 0) {
#line 271
                  opt_idx ++;
#line 272
                  goto while_break;
                } else {
                  {
#line 274
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option: %s\n",
                          *(argv + opt_idx));
#line 275
                  exit(1);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 256
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return (opt_idx);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int decode_command(int argc , char **argv , ProgEnv *env ) 
{ 
  int opt_idx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 287
  opt_idx = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (opt_idx < argc)) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp___10 = strcmp((char const   *)*(argv + opt_idx), "add");
    }
#line 288
    if (tmp___10 == 0) {
      {
#line 289
      opt_idx ++;
#line 290
      tmp = command_add(argc - opt_idx, argv + opt_idx, env);
#line 290
      opt_idx += tmp;
      }
    } else {
      {
#line 291
      tmp___9 = strcmp((char const   *)*(argv + opt_idx), "add-list");
      }
#line 291
      if (tmp___9 == 0) {
        {
#line 292
        opt_idx ++;
#line 293
        tmp___0 = command_add_list(argc - opt_idx, argv + opt_idx, env);
#line 293
        opt_idx += tmp___0;
        }
      } else {
        {
#line 294
        tmp___8 = strcmp((char const   *)*(argv + opt_idx), "delete");
        }
#line 294
        if (tmp___8 == 0) {
          {
#line 295
          opt_idx ++;
#line 296
          tmp___1 = command_delete(argc - opt_idx, argv + opt_idx, env);
#line 296
          opt_idx += tmp___1;
          }
        } else {
          {
#line 297
          tmp___7 = strcmp((char const   *)*(argv + opt_idx), "delete-list");
          }
#line 297
          if (tmp___7 == 0) {
            {
#line 298
            opt_idx ++;
#line 299
            tmp___2 = command_delete_list(argc - opt_idx, argv + opt_idx, env);
#line 299
            opt_idx += tmp___2;
            }
          } else {
            {
#line 300
            tmp___6 = strcmp((char const   *)*(argv + opt_idx), "query");
            }
#line 300
            if (tmp___6 == 0) {
              {
#line 301
              opt_idx ++;
#line 302
              tmp___3 = command_query(argc - opt_idx, argv + opt_idx, env);
#line 302
              opt_idx += tmp___3;
              }
            } else {
              {
#line 303
              tmp___5 = strcmp((char const   *)*(argv + opt_idx), "list");
              }
#line 303
              if (tmp___5 == 0) {
                {
#line 304
                opt_idx ++;
#line 305
                tmp___4 = command_list(argc - opt_idx, argv + opt_idx, env);
#line 305
                opt_idx += tmp___4;
                }
              } else {
                {
#line 307
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown command: %s\n",
                        *(argv + opt_idx));
                }
#line 308
                return (1);
              }
            }
          }
        }
      }
    }
#line 287
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_add(int argc , char **argv , ProgEnv *env ) 
{ 
  int opt_idx ;
  char const   *key ;
  AlphaChar key_alpha[256] ;
  TrieData data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Bool tmp___2 ;

  {
#line 320
  opt_idx = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (opt_idx < argc)) {
#line 321
      goto while_break;
    }
#line 326
    tmp = opt_idx;
#line 326
    opt_idx ++;
#line 326
    key = (char const   *)*(argv + tmp);
#line 327
    if (opt_idx < argc) {
      {
#line 327
      tmp___0 = opt_idx;
#line 327
      opt_idx ++;
#line 327
      tmp___1 = atoi((char const   *)*(argv + tmp___0));
#line 327
      data = tmp___1;
      }
    } else {
#line 327
      data = -1;
    }
    {
#line 329
    conv_to_alpha(env, key, key_alpha, sizeof(key_alpha) / sizeof(key_alpha[0]));
#line 330
    tmp___2 = trie_store(env->trie, (AlphaChar const   *)(key_alpha), data);
    }
#line 330
    if (! tmp___2) {
      {
#line 331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to add entry \'%s\' with data %d\n",
              key, data);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return (opt_idx);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_add_list(int argc , char **argv , ProgEnv *env ) 
{ 
  char const   *enc_name ;
  char const   *input_name ;
  int opt_idx ;
  iconv_t saved_conv ;
  FILE *input ;
  char line[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  iconv_t conv ;
  iconv_t tmp___3 ;
  char *key ;
  char *data ;
  AlphaChar key_alpha[256] ;
  TrieData data_val ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  Bool tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 348
  enc_name = (char const   *)0;
#line 349
  opt_idx = 0;
#line 350
  saved_conv = env->to_alpha_conv;
#line 351
  tmp___0 = strcmp((char const   *)*(argv + 0), "-e");
  }
#line 351
  if (tmp___0 == 0) {
#line 351
    goto _L;
  } else {
    {
#line 351
    tmp___1 = strcmp((char const   *)*(argv + 0), "--encoding");
    }
#line 351
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 354
      opt_idx ++;
#line 354
      if (opt_idx >= argc) {
        {
#line 355
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"add-list option \"%s\" requires encoding name",
                *(argv + 0));
        }
#line 357
        return (opt_idx);
      }
#line 359
      tmp = opt_idx;
#line 359
      opt_idx ++;
#line 359
      enc_name = (char const   *)*(argv + tmp);
    }
  }
#line 361
  if (opt_idx >= argc) {
    {
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"add-list requires input word list file name\n");
    }
#line 363
    return (opt_idx);
  }
#line 365
  tmp___2 = opt_idx;
#line 365
  opt_idx ++;
#line 365
  input_name = (char const   *)*(argv + tmp___2);
#line 367
  if (enc_name) {
    {
#line 368
    tmp___3 = iconv_open("UCS-4LE", enc_name);
#line 368
    conv = tmp___3;
    }
#line 369
    if ((unsigned long )((iconv_t )-1) == (unsigned long )conv) {
      {
#line 370
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Conversion from \"%s\" to \"%s\" is not supported.\n",
              enc_name, "UCS-4LE");
      }
#line 373
      return (opt_idx);
    }
#line 376
    env->to_alpha_conv = conv;
  }
  {
#line 379
  input = fopen((char const   */* __restrict  */)input_name, (char const   */* __restrict  */)"r");
  }
#line 380
  if (! input) {
    {
#line 381
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"add-list: Cannot open input file \"%s\"\n",
            input_name);
    }
#line 383
    goto exit_iconv_openned;
  }
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 386
    tmp___9 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)input);
    }
#line 386
    if (! tmp___9) {
#line 386
      goto while_break;
    }
    {
#line 391
    key = string_trim(line);
    }
#line 392
    if (0 != (int )*key) {
#line 394
      data = key;
      {
#line 394
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 394
        if (*data) {
          {
#line 394
          tmp___4 = strchr("\t,", (int )*data);
          }
#line 394
          if (tmp___4) {
#line 394
            goto while_break___0;
          }
        } else {
#line 394
          goto while_break___0;
        }
#line 394
        data ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 397
      if (0 != (int )*data) {
#line 398
        tmp___5 = data;
#line 398
        data ++;
#line 398
        *tmp___5 = (char )'\000';
        {
#line 399
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 399
          tmp___6 = __ctype_b_loc();
          }
#line 399
          if (! ((int const   )*(*tmp___6 + (int )*data) & 8192)) {
#line 399
            goto while_break___1;
          }
#line 400
          data ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 403
      if (0 != (int )*data) {
        {
#line 403
        tmp___7 = atoi((char const   *)data);
#line 403
        data_val = tmp___7;
        }
      } else {
#line 403
        data_val = -1;
      }
      {
#line 406
      conv_to_alpha(env, (char const   *)key, key_alpha, sizeof(key_alpha) / sizeof(key_alpha[0]));
#line 407
      tmp___8 = trie_store(env->trie, (AlphaChar const   *)(key_alpha), data_val);
      }
#line 407
      if (! tmp___8) {
        {
#line 408
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to add key \'%s\' with data %d.\n",
                key, data_val);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  fclose(input);
  }
  exit_iconv_openned: 
#line 416
  if (enc_name) {
    {
#line 417
    iconv_close(env->to_alpha_conv);
#line 418
    env->to_alpha_conv = saved_conv;
    }
  }
#line 421
  return (opt_idx);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_delete(int argc , char **argv , ProgEnv *env ) 
{ 
  int opt_idx ;
  AlphaChar key_alpha[256] ;
  Bool tmp ;

  {
#line 429
  opt_idx = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (opt_idx < argc)) {
#line 429
      goto while_break;
    }
    {
#line 432
    conv_to_alpha(env, (char const   *)*(argv + opt_idx), key_alpha, sizeof(key_alpha) / sizeof(key_alpha[0]));
#line 433
    tmp = trie_delete(env->trie, (AlphaChar const   *)(key_alpha));
    }
#line 433
    if (! tmp) {
      {
#line 434
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No entry \'%s\'. Not deleted.\n",
              *(argv + opt_idx));
      }
    }
#line 429
    opt_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  return (opt_idx);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_delete_list(int argc , char **argv , ProgEnv *env ) 
{ 
  char const   *enc_name ;
  char const   *input_name ;
  int opt_idx ;
  iconv_t saved_conv ;
  FILE *input ;
  char line[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  iconv_t conv ;
  iconv_t tmp___3 ;
  char *p ;
  AlphaChar key_alpha[256] ;
  Bool tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 450
  enc_name = (char const   *)0;
#line 451
  opt_idx = 0;
#line 452
  saved_conv = env->to_alpha_conv;
#line 453
  tmp___0 = strcmp((char const   *)*(argv + 0), "-e");
  }
#line 453
  if (tmp___0 == 0) {
#line 453
    goto _L;
  } else {
    {
#line 453
    tmp___1 = strcmp((char const   *)*(argv + 0), "--encoding");
    }
#line 453
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 456
      opt_idx ++;
#line 456
      if (opt_idx >= argc) {
        {
#line 457
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"delete-list option \"%s\" requires encoding name",
                *(argv + 0));
        }
#line 459
        return (opt_idx);
      }
#line 461
      tmp = opt_idx;
#line 461
      opt_idx ++;
#line 461
      enc_name = (char const   *)*(argv + tmp);
    }
  }
#line 463
  if (opt_idx >= argc) {
    {
#line 464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"delete-list requires input word list file name\n");
    }
#line 465
    return (opt_idx);
  }
#line 467
  tmp___2 = opt_idx;
#line 467
  opt_idx ++;
#line 467
  input_name = (char const   *)*(argv + tmp___2);
#line 469
  if (enc_name) {
    {
#line 470
    tmp___3 = iconv_open("UCS-4LE", enc_name);
#line 470
    conv = tmp___3;
    }
#line 471
    if ((unsigned long )((iconv_t )-1) == (unsigned long )conv) {
      {
#line 472
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Conversion from \"%s\" to \"%s\" is not supported.\n",
              enc_name, "UCS-4LE");
      }
#line 475
      return (opt_idx);
    }
#line 478
    env->to_alpha_conv = conv;
  }
  {
#line 481
  input = fopen((char const   */* __restrict  */)input_name, (char const   */* __restrict  */)"r");
  }
#line 482
  if (! input) {
    {
#line 483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"delete-list: Cannot open input file \"%s\"\n",
            input_name);
    }
#line 485
    goto exit_iconv_openned;
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 488
    tmp___5 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)input);
    }
#line 488
    if (! tmp___5) {
#line 488
      goto while_break;
    }
    {
#line 491
    p = string_trim(line);
    }
#line 492
    if (0 != (int )*p) {
      {
#line 495
      conv_to_alpha(env, (char const   *)p, key_alpha, sizeof(key_alpha) / sizeof(key_alpha[0]));
#line 496
      tmp___4 = trie_delete(env->trie, (AlphaChar const   *)(key_alpha));
      }
#line 496
      if (! tmp___4) {
        {
#line 497
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No entry \'%s\'. Not deleted.\n",
                p);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  fclose(input);
  }
  exit_iconv_openned: 
#line 505
  if (enc_name) {
    {
#line 506
    iconv_close(env->to_alpha_conv);
#line 507
    env->to_alpha_conv = saved_conv;
    }
  }
#line 510
  return (opt_idx);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_query(int argc , char **argv , ProgEnv *env ) 
{ 
  AlphaChar key_alpha[256] ;
  TrieData data ;
  Bool tmp ;

  {
#line 519
  if (argc == 0) {
    {
#line 520
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"query: No key specified.\n");
    }
#line 521
    return (0);
  }
  {
#line 524
  conv_to_alpha(env, (char const   *)*(argv + 0), key_alpha, sizeof(key_alpha) / sizeof(key_alpha[0]));
#line 525
  tmp = trie_retrieve((Trie const   *)env->trie, (AlphaChar const   *)(key_alpha),
                      & data);
  }
#line 525
  if (tmp) {
    {
#line 526
    printf((char const   */* __restrict  */)"%d\n", data);
    }
  } else {
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"query: Key \'%s\' not found.\n",
            *(argv + 0));
    }
  }
#line 531
  return (1);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static Bool list_enum_func(AlphaChar const   *key , TrieData key_data , void *user_data ) 
{ 
  ProgEnv *env ;
  char key_locale[1024] ;

  {
  {
#line 537
  env = (ProgEnv *)user_data;
#line 540
  conv_from_alpha(env, key, key_locale, sizeof(key_locale) / sizeof(key_locale[0]));
#line 541
  printf((char const   */* __restrict  */)"%s\t%d\n", key_locale, key_data);
  }
#line 542
  return ((Bool )1);
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static int command_list(int argc , char **argv , ProgEnv *env ) 
{ 


  {
  {
#line 548
  trie_enumerate((Trie const   *)env->trie, & list_enum_func, (void *)env);
  }
#line 549
  return (0);
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static void usage(char const   *prog_name , int exit_status ) 
{ 


  {
  {
#line 556
  printf((char const   */* __restrict  */)"%s - double-array trie manipulator\n",
         prog_name);
#line 557
  printf((char const   */* __restrict  */)"Usage: %s [OPTION]... TRIE CMD ARG ...\n",
         prog_name);
#line 558
  printf((char const   */* __restrict  */)"Options:\n  -p, --path DIR           set trie directory to DIR [default=.]\n  -h, --help               display this help and exit\n  -V, --version            output version information and exit\n\nCommands:\n  add  WORD DATA ...\n      Add WORD with DATA to trie\n  add-list [OPTION] LISTFILE\n      Add words and data listed in LISTFILE to trie\n      Options:\n          -e, --encoding ENC    specify character encoding of LISTFILE\n  delete WORD ...\n      Delete WORD from trie\n  delete-list [OPTION] LISTFILE\n      Delete words listed in LISTFILE from trie\n      Options:\n          -e, --encoding ENC    specify character encoding of LISTFILE\n  query WORD\n      Query WORD data from trie\n  list\n      List all words in trie\n");
#line 583
  exit(exit_status);
  }
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/tools/trietool.c"
static char *string_trim(char *s ) 
{ 
  char *p ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (*s) {
      {
#line 592
      tmp = __ctype_b_loc();
      }
#line 592
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 592
        goto while_break;
      }
    } else {
#line 592
      goto while_break;
    }
#line 593
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 596
  tmp___0 = strlen((char const   *)s);
#line 596
  p = (s + tmp___0) - 1;
  }
  {
#line 597
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 597
    tmp___1 = __ctype_b_loc();
    }
#line 597
    if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 597
      goto while_break___0;
    }
#line 598
    p --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 599
  p ++;
#line 599
  *p = (char )'\000';
#line 601
  return (s);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static TrieIndex tail_alloc_block___0(Tail *t ) ;
#line 46
static void tail_free_block___0(Tail *t , TrieIndex block ) ;
#line 319 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static TrieIndex tail_alloc_block___0(Tail *t ) 
{ 
  TrieIndex block ;
  void *tmp ;

  {
#line 324
  if (0 != t->first_free) {
#line 325
    block = t->first_free;
#line 326
    t->first_free = (t->tails + block)->next_free;
  } else {
    {
#line 328
    block = t->num_tails;
#line 329
    (t->num_tails) ++;
#line 329
    tmp = realloc((void *)t->tails, (unsigned long )t->num_tails * sizeof(TailBlock ));
#line 329
    t->tails = (TailBlock *)tmp;
    }
  }
#line 332
  (t->tails + block)->next_free = -1;
#line 333
  (t->tails + block)->data = -1;
#line 334
  (t->tails + block)->suffix = (TrieChar *)((void *)0);
#line 336
  return (block + 1);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/tail.c"
static void tail_free_block___0(Tail *t , TrieIndex block ) 
{ 
  TrieIndex i ;
  TrieIndex j ;

  {
#line 344
  block --;
#line 346
  if (block >= t->num_tails) {
#line 347
    return;
  }
#line 349
  (t->tails + block)->data = -1;
#line 350
  if ((unsigned long )((void *)0) != (unsigned long )(t->tails + block)->suffix) {
    {
#line 351
    free((void *)(t->tails + block)->suffix);
#line 352
    (t->tails + block)->suffix = (TrieChar *)((void *)0);
    }
  }
#line 356
  j = 0;
#line 357
  i = t->first_free;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (i != 0) {
#line 357
      if (! (i < block)) {
#line 357
        goto while_break;
      }
    } else {
#line 357
      goto while_break;
    }
#line 358
    j = i;
#line 357
    i = (t->tails + i)->next_free;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  (t->tails + block)->next_free = i;
#line 362
  if (0 != j) {
#line 363
    (t->tails + j)->next_free = block;
  } else {
#line 365
    t->first_free = block;
  }
#line 366
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/dstring.c"
static Bool dstring_ensure_space___0(DString *ds , int size ) 
{ 
  int re_size ;
  int tmp ;
  void *re_ptr ;
  void *tmp___0 ;

  {
#line 91
  if (ds->alloc_size < size) {
#line 92
    if (ds->alloc_size * 2 > size) {
#line 92
      tmp = ds->alloc_size * 2;
    } else {
#line 92
      tmp = size;
    }
    {
#line 92
    re_size = tmp;
#line 93
    tmp___0 = realloc(ds->val, (size_t )re_size);
#line 93
    re_ptr = tmp___0;
    }
#line 94
    if (! re_ptr) {
#line 95
      return ((Bool )0);
    }
#line 96
    ds->val = re_ptr;
#line 97
    ds->alloc_size = re_size;
  }
#line 100
  return ((Bool )1);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
static int alpha_map_get_total_ranges___0(AlphaMap const   *alpha_map ) ;
#line 227 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/alpha-map.c"
static int alpha_map_get_total_ranges___0(AlphaMap const   *alpha_map ) 
{ 
  int n ;
  AlphaRange *range ;

  {
#line 233
  n = 0;
#line 233
  range = (AlphaRange *)alpha_map->first_range;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! range) {
#line 233
      goto while_break;
    }
#line 234
    n ++;
#line 233
    range = range->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (n);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_check_free_cell___0(DArray *d , TrieIndex s ) ;
#line 58
static Bool da_has_children___0(DArray const   *d , TrieIndex s ) ;
#line 61
static TrieIndex da_find_free_base___0(DArray *d , Symbols const   *symbols ) ;
#line 64
static Bool da_fit_symbols___0(DArray *d , TrieIndex base , Symbols const   *symbols ) ;
#line 68
static void da_relocate_base___0(DArray *d , TrieIndex s , TrieIndex new_base ) ;
#line 72
static Bool da_extend_pool___0(DArray *d , TrieIndex to_index ) ;
#line 75
static void da_alloc_cell___0(DArray *d , TrieIndex cell ) ;
#line 78
static void da_free_cell___0(DArray *d , TrieIndex cell ) ;
#line 483 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_check_free_cell___0(DArray *d , TrieIndex s ) 
{ 
  Bool tmp ;
  TrieIndex tmp___0 ;
  int tmp___1 ;

  {
  {
#line 487
  tmp = da_extend_pool___0(d, s);
  }
#line 487
  if (tmp) {
    {
#line 487
    tmp___0 = da_get_check((DArray const   *)d, s);
    }
#line 487
    if (tmp___0 < 0) {
#line 487
      tmp___1 = 1;
    } else {
#line 487
      tmp___1 = 0;
    }
  } else {
#line 487
    tmp___1 = 0;
  }
#line 487
  return ((Bool )tmp___1);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_has_children___0(DArray const   *d , TrieIndex s ) 
{ 
  TrieIndex base ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp ;

  {
  {
#line 497
  base = da_get_base(d, s);
  }
#line 498
  if (0 == base) {
#line 499
    return ((Bool )0);
  } else
#line 498
  if (base < 0) {
#line 499
    return ((Bool )0);
  }
#line 501
  if (255 < (int )(d->num_cells - (TrieIndex const   )base)) {
#line 501
    max_c = 255;
  } else {
#line 501
    max_c = (TrieIndex )(d->num_cells - (TrieIndex const   )base);
  }
#line 502
  c = 0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (c <= max_c)) {
#line 502
      goto while_break;
    }
    {
#line 503
    tmp = da_get_check(d, base + c);
    }
#line 503
    if (tmp == s) {
#line 504
      return ((Bool )1);
    }
#line 502
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  return ((Bool )0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static TrieIndex da_find_free_base___0(DArray *d , Symbols const   *symbols ) 
{ 
  TrieChar first_sym ;
  TrieIndex s ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  Bool tmp___1 ;
  TrieIndex tmp___2 ;
  Bool tmp___3 ;
  TrieIndex tmp___4 ;
  TrieIndex tmp___5 ;
  Bool tmp___6 ;

  {
  {
#line 538
  first_sym = symbols_get(symbols, 0);
#line 539
  tmp = da_get_check((DArray const   *)d, 1);
#line 539
  s = - tmp;
  }
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (s != 1) {
#line 540
      if (! (s < (TrieIndex )first_sym + 3)) {
#line 540
        goto while_break;
      }
    } else {
#line 540
      goto while_break;
    }
    {
#line 543
    tmp___0 = da_get_check((DArray const   *)d, s);
#line 543
    s = - tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  if (s == 1) {
#line 546
    s = (int )first_sym + 3;
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 547
      tmp___1 = da_extend_pool___0(d, s);
      }
#line 547
      if (! tmp___1) {
#line 548
        return (0);
      }
      {
#line 549
      tmp___2 = da_get_check((DArray const   *)d, s);
      }
#line 549
      if (tmp___2 < 0) {
#line 550
        goto while_break___0;
      }
#line 546
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 555
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 555
    tmp___6 = da_fit_symbols___0(d, s - (TrieIndex )first_sym, symbols);
    }
#line 555
    if (tmp___6) {
#line 555
      goto while_break___1;
    }
    {
#line 557
    tmp___4 = da_get_check((DArray const   *)d, s);
    }
#line 557
    if (- tmp___4 == 1) {
      {
#line 558
      tmp___3 = da_extend_pool___0(d, d->num_cells);
      }
#line 558
      if (! tmp___3) {
#line 559
        return (0);
      }
    }
    {
#line 562
    tmp___5 = da_get_check((DArray const   *)d, s);
#line 562
    s = - tmp___5;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 565
  return (s - (TrieIndex )first_sym);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_fit_symbols___0(DArray *d , TrieIndex base , Symbols const   *symbols ) 
{ 
  int i ;
  TrieChar sym ;
  TrieChar tmp ;
  Bool tmp___0 ;
  int tmp___1 ;

  {
#line 575
  i = 0;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 575
    tmp___1 = symbols_num(symbols);
    }
#line 575
    if (! (i < tmp___1)) {
#line 575
      goto while_break;
    }
    {
#line 576
    tmp = symbols_get(symbols, i);
#line 576
    sym = tmp;
    }
#line 581
    if (base > 2147483647 - (int )sym) {
#line 582
      return ((Bool )0);
    } else {
      {
#line 581
      tmp___0 = da_check_free_cell___0(d, base + (TrieIndex )sym);
      }
#line 581
      if (! tmp___0) {
#line 582
        return ((Bool )0);
      }
    }
#line 575
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  return ((Bool )1);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_relocate_base___0(DArray *d , TrieIndex s , TrieIndex new_base ) 
{ 
  TrieIndex old_base ;
  Symbols *symbols ;
  int i ;
  TrieIndex old_next ;
  TrieIndex new_next ;
  TrieIndex old_next_base ;
  TrieChar tmp ;
  TrieChar tmp___0 ;
  TrieIndex c ;
  TrieIndex max_c ;
  TrieIndex tmp___1 ;
  int tmp___2 ;

  {
  {
#line 596
  old_base = da_get_base((DArray const   *)d, s);
#line 597
  symbols = da_output_symbols((DArray const   *)d, s);
#line 599
  i = 0;
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 599
    tmp___2 = symbols_num((Symbols const   *)symbols);
    }
#line 599
    if (! (i < tmp___2)) {
#line 599
      goto while_break;
    }
    {
#line 602
    tmp = symbols_get((Symbols const   *)symbols, i);
#line 602
    old_next = old_base + (TrieIndex )tmp;
#line 603
    tmp___0 = symbols_get((Symbols const   *)symbols, i);
#line 603
    new_next = new_base + (TrieIndex )tmp___0;
#line 604
    old_next_base = da_get_base((DArray const   *)d, old_next);
#line 607
    da_alloc_cell___0(d, new_next);
#line 608
    da_set_check(d, new_next, s);
#line 609
    da_set_base(d, new_next, old_next_base);
    }
#line 616
    if (old_next_base > 0) {
#line 619
      if (255 < d->num_cells - old_next_base) {
#line 619
        max_c = 255;
      } else {
#line 619
        max_c = d->num_cells - old_next_base;
      }
#line 620
      c = 0;
      {
#line 620
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 620
        if (! (c <= max_c)) {
#line 620
          goto while_break___0;
        }
        {
#line 621
        tmp___1 = da_get_check((DArray const   *)d, old_next_base + c);
        }
#line 621
        if (tmp___1 == old_next) {
          {
#line 622
          da_set_check(d, old_next_base + c, new_next);
          }
        }
#line 620
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 627
    da_free_cell___0(d, old_next);
#line 599
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 630
  symbols_free(symbols);
#line 633
  da_set_base(d, s, new_base);
  }
#line 634
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static Bool da_extend_pool___0(DArray *d , TrieIndex to_index ) 
{ 
  TrieIndex new_begin ;
  TrieIndex i ;
  TrieIndex free_tail ;
  void *tmp ;
  TrieIndex tmp___0 ;

  {
#line 644
  if (to_index <= 0) {
#line 645
    return ((Bool )0);
  } else
#line 644
  if (2147483647 <= to_index) {
#line 645
    return ((Bool )0);
  }
#line 647
  if (to_index < d->num_cells) {
#line 648
    return ((Bool )1);
  }
  {
#line 650
  tmp = realloc((void *)d->cells, (unsigned long )(to_index + 1) * sizeof(DACell ));
#line 650
  d->cells = (DACell *)tmp;
#line 651
  new_begin = d->num_cells;
#line 652
  d->num_cells = to_index + 1;
#line 655
  i = new_begin;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! (i < to_index)) {
#line 655
      goto while_break;
    }
    {
#line 656
    da_set_check(d, i, - (i + 1));
#line 657
    da_set_base(d, i + 1, - i);
#line 655
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 661
  tmp___0 = da_get_base((DArray const   *)d, 1);
#line 661
  free_tail = - tmp___0;
#line 662
  da_set_check(d, free_tail, - new_begin);
#line 663
  da_set_base(d, new_begin, - free_tail);
#line 664
  da_set_check(d, to_index, -1);
#line 665
  da_set_base(d, 1, - to_index);
#line 668
  (d->cells + 0)->check = d->num_cells;
  }
#line 670
  return ((Bool )1);
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_alloc_cell___0(DArray *d , TrieIndex cell ) 
{ 
  TrieIndex prev ;
  TrieIndex next ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;

  {
  {
#line 718
  tmp = da_get_base((DArray const   *)d, cell);
#line 718
  prev = - tmp;
#line 719
  tmp___0 = da_get_check((DArray const   *)d, cell);
#line 719
  next = - tmp___0;
#line 722
  da_set_check(d, prev, - next);
#line 723
  da_set_base(d, next, - prev);
  }
#line 724
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/darray.c"
static void da_free_cell___0(DArray *d , TrieIndex cell ) 
{ 
  TrieIndex i ;
  TrieIndex prev ;
  TrieIndex tmp ;
  TrieIndex tmp___0 ;
  TrieIndex tmp___1 ;

  {
  {
#line 733
  tmp = da_get_check((DArray const   *)d, 1);
#line 733
  i = - tmp;
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (i != 1) {
#line 734
      if (! (i < cell)) {
#line 734
        goto while_break;
      }
    } else {
#line 734
      goto while_break;
    }
    {
#line 735
    tmp___0 = da_get_check((DArray const   *)d, i);
#line 735
    i = - tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 737
  tmp___1 = da_get_base((DArray const   *)d, i);
#line 737
  prev = - tmp___1;
#line 740
  da_set_check(d, cell, - i);
#line 741
  da_set_base(d, cell, - prev);
#line 742
  da_set_check(d, prev, - cell);
#line 743
  da_set_base(d, i, - cell);
  }
#line 744
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static TrieState *trie_state_new___0(Trie const   *trie , TrieIndex index___0 , short suffix_idx ,
                                     short is_suffix ) ;
#line 82
static Bool trie_store_conditionally___0(Trie *trie , AlphaChar const   *key , TrieData data ,
                                         Bool is_overwrite ) ;
#line 87
static Bool trie_branch_in_branch___0(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                      TrieData data ) ;
#line 92
static Bool trie_branch_in_tail___0(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                    TrieData data ) ;
#line 407 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_store_conditionally___0(Trie *trie , AlphaChar const   *key , TrieData data ,
                                         Bool is_overwrite ) 
{ 
  TrieIndex s ;
  TrieIndex t ;
  short suffix_idx ;
  AlphaChar const   *p ;
  AlphaChar const   *sep ;
  TrieIndex tc ;
  TrieIndex tmp ;
  TrieChar *key_str ;
  Bool res ;
  Bool tmp___0 ;
  TrieIndex tmp___1 ;
  TrieIndex tmp___2 ;
  TrieIndex tc___0 ;
  TrieIndex tmp___3 ;
  TrieChar *tail_str ;
  Bool res___0 ;
  Bool tmp___4 ;

  {
  {
#line 418
  s = da_get_root((DArray const   *)trie->da);
#line 419
  p = key;
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    tmp___1 = da_get_base((DArray const   *)trie->da, s);
    }
#line 419
    if (tmp___1 < 0) {
#line 419
      goto while_break;
    }
    {
#line 420
    tmp = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 420
    tc = tmp;
    }
#line 421
    if (2147483647 == tc) {
#line 422
      return ((Bool )0);
    }
    {
#line 423
    tmp___0 = da_walk((DArray const   *)trie->da, & s, (TrieChar )tc);
    }
#line 423
    if (! tmp___0) {
      {
#line 427
      key_str = alpha_map_char_to_trie_str((AlphaMap const   *)trie->alpha_map, p);
      }
#line 428
      if (! key_str) {
#line 429
        return ((Bool )0);
      }
      {
#line 430
      res = trie_branch_in_branch___0(trie, s, (TrieChar const   *)key_str, data);
#line 431
      free((void *)key_str);
      }
#line 433
      return (res);
    }
#line 435
    if (0U == *p) {
#line 436
      goto while_break;
    }
#line 419
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  sep = p;
#line 441
  tmp___2 = da_get_base((DArray const   *)trie->da, s);
#line 441
  t = - tmp___2;
#line 442
  suffix_idx = (short)0;
  }
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 444
    tmp___3 = alpha_map_char_to_trie((AlphaMap const   *)trie->alpha_map, (AlphaChar )*p);
#line 444
    tc___0 = tmp___3;
    }
#line 445
    if (2147483647 == tc___0) {
#line 446
      return ((Bool )0);
    }
    {
#line 447
    tmp___4 = tail_walk_char((Tail const   *)trie->tail, t, & suffix_idx, (TrieChar )tc___0);
    }
#line 447
    if (! tmp___4) {
      {
#line 451
      tail_str = alpha_map_char_to_trie_str((AlphaMap const   *)trie->alpha_map, sep);
      }
#line 452
      if (! tail_str) {
#line 453
        return ((Bool )0);
      }
      {
#line 454
      res___0 = trie_branch_in_tail___0(trie, s, (TrieChar const   *)tail_str, data);
#line 455
      free((void *)tail_str);
      }
#line 457
      return (res___0);
    }
#line 459
    if (0U == *p) {
#line 460
      goto while_break___0;
    }
#line 443
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 464
  if (! is_overwrite) {
#line 465
    return ((Bool )0);
  }
  {
#line 467
  tail_set_data(trie->tail, t, data);
#line 468
  trie->is_dirty = (Bool )1;
  }
#line 469
  return ((Bool )1);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_branch_in_branch___0(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                      TrieData data ) 
{ 
  TrieIndex new_da ;
  TrieIndex new_tail ;

  {
  {
#line 480
  new_da = da_insert_branch(trie->da, sep_node, (TrieChar )*suffix);
  }
#line 481
  if (0 == new_da) {
#line 482
    return ((Bool )0);
  }
#line 484
  if (0 != (int )*suffix) {
#line 485
    suffix ++;
  }
  {
#line 487
  new_tail = tail_add_suffix(trie->tail, suffix);
#line 488
  tail_set_data(trie->tail, new_tail, data);
#line 489
  da_set_base(trie->da, new_da, - new_tail);
#line 491
  trie->is_dirty = (Bool )1;
  }
#line 492
  return ((Bool )1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static Bool trie_branch_in_tail___0(Trie *trie , TrieIndex sep_node , TrieChar const   *suffix ,
                                    TrieData data ) 
{ 
  TrieIndex old_tail ;
  TrieIndex old_da ;
  TrieIndex s ;
  TrieChar const   *old_suffix ;
  TrieChar const   *p ;
  TrieIndex tmp ;
  TrieIndex t ;
  TrieIndex tmp___0 ;
  Bool tmp___1 ;

  {
  {
#line 505
  tmp = da_get_base((DArray const   *)trie->da, sep_node);
#line 505
  old_tail = - tmp;
#line 506
  old_suffix = tail_get_suffix((Tail const   *)trie->tail, old_tail);
  }
#line 507
  if (! old_suffix) {
#line 508
    return ((Bool )0);
  }
#line 510
  p = old_suffix;
#line 510
  s = sep_node;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int const   )*p == (int const   )*suffix)) {
#line 510
      goto while_break;
    }
    {
#line 511
    tmp___0 = da_insert_branch(trie->da, s, (TrieChar )*p);
#line 511
    t = tmp___0;
    }
#line 512
    if (0 == t) {
#line 513
      goto fail;
    }
#line 514
    s = t;
#line 510
    p ++;
#line 510
    suffix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  old_da = da_insert_branch(trie->da, s, (TrieChar )*p);
  }
#line 518
  if (0 == old_da) {
#line 519
    goto fail;
  }
#line 521
  if (0 != (int )*p) {
#line 522
    p ++;
  }
  {
#line 523
  tail_set_suffix(trie->tail, old_tail, p);
#line 524
  da_set_base(trie->da, old_da, - old_tail);
#line 527
  tmp___1 = trie_branch_in_branch___0(trie, s, suffix, data);
  }
#line 527
  return (tmp___1);
  fail: 
  {
#line 531
  da_prune_upto(trie->da, sep_node, s);
#line 532
  da_set_base(trie->da, sep_node, - old_tail);
  }
#line 533
  return ((Bool )0);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/libdatrie-0.2.8/datrie/trie.c"
static TrieState *trie_state_new___0(Trie const   *trie , TrieIndex index___0 , short suffix_idx ,
                                     short is_suffix ) 
{ 
  TrieState *s ;
  void *tmp ;

  {
  {
#line 665
  tmp = malloc(sizeof(TrieState ));
#line 665
  s = (TrieState *)tmp;
  }
#line 666
  if (! s) {
#line 667
    return ((TrieState *)((void *)0));
  }
#line 669
  s->trie = trie;
#line 670
  s->index = index___0;
#line 671
  s->suffix_idx = suffix_idx;
#line 672
  s->is_suffix = is_suffix;
#line 674
  return (s);
}
}
