/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 111 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct __anonstruct_interface_41 {
   char *name ;
   char *option ;
   char *storage ;
   int (*open)() ;
   int (*close)() ;
   int (*refreshIO)() ;
   int (*plotPiece)() ;
   int (*displayComment)() ;
   int (*clearComment)() ;
   int (*initializeBoard)() ;
   int (*clearScreen)() ;
   int (*idle)() ;
   int (*drawTree)() ;
   int (*highlightLast)() ;
   int (*readEnv)() ;
   int (*notifyMessage)() ;
   int (*notifyClear)() ;
   int (*queryStr)() ;
   int (*setCursor)() ;
   int (*plotMark)() ;
   int (*plotLetter)() ;
   int (*getPoint)() ;
   int (*editComment)() ;
   int (*askYN)() ;
   int (*notifyError)() ;
   int (*displayInfo)() ;
   int (*getInfoToChange)() ;
   int (*editInfo)() ;
};
#line 111 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct __anonstruct_interface_41 interface;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
struct __anonstruct_argType_48 {
   char *arg ;
   int *flag ;
   char **str ;
};
#line 29 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
typedef struct __anonstruct_argType_48 argType;
#line 22 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef int boolean;
#line 53
enum __anonenum_Token_2 {
    t_White = 0,
    t_Black = 1,
    t_Open = 2,
    t_Close = 3,
    t_NewNode = 4,
    t_Comment = 5,
    t_AddWhite = 6,
    t_AddBlack = 7,
    t_Letter = 8,
    t_Mark = 9,
    t_AddEmpty = 10,
    t_Name = 11,
    t_Pass = 12,
    t_Player = 13,
    t_Size = 14,
    t_Handicap = 15,
    t_PlayerBlack = 16,
    t_BlackRank = 17,
    t_PlayerWhite = 18,
    t_WhiteRank = 19,
    t_GameName = 20,
    t_Event = 21,
    t_Round = 22,
    t_Date = 23,
    t_Place = 24,
    t_TimeLimit = 25,
    t_Result = 26,
    t_GameComment = 27,
    t_Source = 28,
    t_User = 29,
    t_Komi = 30,
    t_WS = 31,
    t_EOF = 32
} ;
#line 53 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef enum __anonenum_Token_2 Token;
#line 131 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct coordstruct {
   char x ;
   char y ;
   struct coordstruct *next ;
};
#line 131 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct coordstruct coordList;
#line 137 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
union __anonunion_data_7 {
   coordList *stones ;
   char *comment ;
   Token player ;
};
#line 137 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct propertyRec {
   struct propertyRec *next ;
   Token t ;
   union __anonunion_data_7 data ;
};
#line 137 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct propertyRec property;
#line 149 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct noderec {
   property *p ;
   int nodeNum ;
   struct noderec *parent ;
   struct noderec *child ;
   struct noderec *nextSibling ;
   struct noderec *lastSibling ;
};
#line 149 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct noderec node;
#line 149 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct noderec *nodep;
#line 96
enum __anonenum_piece_3 {
    P_NOTHING = 0,
    P_BLACK = 1,
    P_WHITE = 2,
    P_DAME = 3,
    P_BLACKTERR = 4,
    P_WHITETERR = 5,
    P_CHECKED = 6
} ;
#line 96 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef enum __anonenum_piece_3 piece;
#line 101 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef piece boardType[19][19];
#line 103 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct __anonstruct_board_4 {
   boardType b ;
};
#line 103 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct __anonstruct_board_4 board;
#line 103 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct __anonstruct_board_4 *pBoard;
#line 125 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
struct __anonstruct_coord_6 {
   char x ;
   char y ;
};
#line 125 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef struct __anonstruct_coord_6 coord;
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
struct __anonstruct_tokens_13 {
   char *str ;
   Token val ;
};
#line 10 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
typedef char clinetype[50];
#line 24 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
enum __anonenum_command_3 {
    C_QUIT = 0,
    C_DOWN = 1,
    C_UP = 2,
    C_WALKDOWN = 3,
    C_WALKUP = 4,
    C_END = 5,
    C_BEGINNING = 6,
    C_SEARCHCOMMENT = 7,
    C_SEARCHBACKCOMMENT = 8,
    C_DOWNFORK = 9,
    C_UPFORK = 10,
    C_GOTO = 11,
    C_WRITE = 12,
    C_ADDBLACK = 13,
    C_ADDWHITE = 14,
    C_ADDVAR = 15,
    C_TREECUT = 16,
    C_ADDLETTER = 17,
    C_ADDMARK = 18,
    C_LOAD = 19,
    C_PASTE = 20,
    C_EDCOMMENT = 21,
    C_DELNODE = 22,
    C_ADDNAME = 23,
    C_SCORE = 24,
    C_PASSMOVE = 25,
    C_TOPLAY = 26,
    C_TOGGLESTONE = 27,
    C_BACKFILE = 28,
    C_NEXTFILE = 29,
    C_REDRAW = 30,
    C_SAVESHORT = 31,
    C_TUTORSWAP = 32,
    C_SAVESCREEN = 33,
    C_INFO = 34,
    C_MOVE = 35,
    C_DOWNLEFT = 36,
    C_CURDOWN = 37,
    C_DOWNRIGHT = 38,
    C_CURLEFT = 39,
    C_CURRIGHT = 40,
    C_UPLEFT = 41,
    C_CURUP = 42,
    C_UPRIGHT = 43,
    C_LASTCOMMAND = 44,
    C_UNDO = 45
} ;
#line 24 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
typedef enum __anonenum_command_3 command;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 21 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void doit(void) ;
#line 39
int main(int argc , char **argv ) ;
#line 40
void die(void) ;
#line 41
void myexit(void) ;
#line 42
void openfile(char *f ) ;
#line 43
void barf(char *s ) ;
#line 44
void initEnv(void) ;
#line 45
void init(char **argv , int *argc ) ;
#line 46
void helpCommandLine(char *errMesg ) ;
#line 47
void parseLine(int argc , char **argv ) ;
#line 48
void readInit(void) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 171 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
char *info[15]  ;
#line 172 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int handicap  ;
#line 174 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int prisoners[2]  ;
#line 175 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
interface *io  ;
#line 176 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int boardsize  ;
#line 177
FILE *input ;
#line 180
int mailFlag ;
#line 181
int saveShort ;
#line 182
int tutor ;
#line 183 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
char *saveName  ;
#line 184
int retVal ;
#line 185 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
char name_buf[512]  ;
#line 186 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int filecount  ;
#line 186 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int currentfile  ;
#line 187 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
char *files[200]  ;
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
int retVal  =    0;
#line 12 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
char *commentBuf  ;
#line 13
interface asciiInterface ;
#line 15 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
FILE *input  =    (FILE *)0;
#line 36 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
int mailFlag  =    0;
#line 37 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
int saveShort  =    0;
#line 38 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
int tutor  =    0;
#line 43 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
static argType argTable[3]  = {      {(char *)"-m", & mailFlag, & saveName}, 
        {(char *)"-s", & saveShort, (char **)((void *)0)}, 
        {(char *)"-t", & tutor, (char **)((void *)0)}};
#line 51 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 60
  io = & asciiInterface;
#line 61
  input = stdin;
#line 62
  init(argv, & argc);
#line 63
  parseLine(argc, argv);
#line 64
  doit();
#line 65
  myexit();
  }
#line 66
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void die(void) 
{ 


  {
  {
#line 72
  signal(2, (void (*)(int  ))0);
#line 73
  myexit();
  }
#line 74
  return;
}
}
#line 83
extern int ( /* missing proto */  exit)() ;
#line 77 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void myexit(void) 
{ 


  {
  {
#line 79
  (*(io->clearScreen))();
#line 80
  (*(io->refreshIO))();
#line 81
  (*(io->close))();
#line 82
  printf((char const   */* __restrict  */)"Thank you for using mgt\n");
#line 83
  exit(retVal);
  }
}
}
#line 92 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
static char game_lib[20]  = 
#line 92
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'l',      (char )'i',      (char )'b', 
        (char )'/',      (char )'g',      (char )'a',      (char )'m', 
        (char )'e',      (char )'s',      (char )'/',      (char )'m', 
        (char )'g',      (char )'t',      (char )'/',      (char )'\000'};
#line 94
extern int ( /* missing proto */  strcpy)() ;
#line 101
extern int ( /* missing proto */  strcat)() ;
#line 88 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void openfile(char *f ) 
{ 


  {
  {
#line 94
  strcpy(name_buf, f);
#line 95
  input = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
  }
#line 95
  if (! input) {
    {
#line 96
    strcpy(name_buf, "");
    }
  }
#line 99
  if (! input) {
    {
#line 100
    strcpy(name_buf, game_lib);
#line 101
    strcat(name_buf, f);
#line 102
    input = fopen((char const   */* __restrict  */)(name_buf), (char const   */* __restrict  */)"r");
    }
  }
#line 105
  return;
}
}
#line 108 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void barf(char *s ) 
{ 
  int i ;
  int tmp ;

  {
#line 112
  i = 24;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    tmp = i;
#line 112
    i --;
#line 112
    if (! tmp) {
#line 112
      goto while_break;
    }
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          s);
#line 115
  exit(1);
  }
}
}
#line 121
extern char *getenv() ;
#line 119 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void initEnv(void) 
{ 
  char *env ;

  {
  {
#line 124
  env = getenv("MGT");
  }
#line 124
  if (env) {
    {
#line 125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 125
      if (! *env) {
#line 125
        goto while_break;
      }
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (*env) {
#line 126
          if (! ((int )*env != 95)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
#line 127
        env ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 128
      if (*env) {
#line 129
        env ++;
      }
#line 130
      if (*env) {
        {
#line 131
        (*(io->readEnv))(& env);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 133
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void init(char **argv , int *argc ) 
{ 


  {
  {
#line 140
  initEnv();
#line 141
  (*(io->open))(argv, argc);
#line 142
  signal(2, (void (*)(int  ))(& die));
#line 143
  readInit();
  }
#line 144
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void helpCommandLine(char *errMesg ) 
{ 


  {
  {
#line 151
  (*(io->close))();
#line 152
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nERROR: %s\n\n",
          errMesg);
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                   MGT %s\n",
          "2.31");
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: mgt [opts] [files]\n");
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[opts] is any of:\n");
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-m filename        mail mode.  Autosave on quit.\n");
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-s                 use short format when saving.\n\n");
#line 158
  exit(2);
  }
}
}
#line 177
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 162 "/home/wheatley/newnew/temp/mgt-2.31/mgt.c"
void parseLine(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 168
  filecount = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    argv ++;
#line 170
    argc --;
#line 170
    if (! (argc > 0)) {
#line 170
      goto while_break;
    }
#line 171
    if ((int )*(*argv) != 45) {
#line 172
      tmp = filecount;
#line 172
      filecount ++;
#line 172
      files[tmp] = *argv;
#line 173
      if (filecount == 200) {
        {
#line 174
        helpCommandLine((char *)"Too many files specified");
        }
      }
    } else {
#line 176
      i = 0;
      {
#line 176
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 176
        if (! ((unsigned long )i < sizeof(argTable) / sizeof(argType ))) {
#line 176
          goto while_break___0;
        }
        {
#line 177
        tmp___0 = strcmp(argTable[i].arg, *argv);
        }
#line 177
        if (! tmp___0) {
#line 178
          if (argTable[i].str) {
#line 179
            argc --;
#line 179
            if (argc) {
#line 180
              argv ++;
#line 180
              *(argTable[i].str) = *argv;
            } else {
              {
#line 182
              helpCommandLine((char *)"String expected on option");
              }
            }
          }
#line 183
          (*(argTable[i].flag)) --;
#line 184
          goto while_break___0;
        }
#line 176
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 186
      if ((unsigned long )i == sizeof(argTable) / sizeof(argType )) {
        {
#line 187
        helpCommandLine((char *)"Bad option");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if (! filecount) {
#line 191
    input = stdin;
  } else {
    {
#line 193
    currentfile = 0;
#line 194
    openfile(files[0]);
    }
#line 195
    if (! input) {
      {
#line 196
      helpCommandLine((char *)"File not found");
      }
    }
  }
#line 199
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
boolean getCoord(int x , int y , coordList *list ) ;
#line 64
coordList *addCoord(int x , int y ) ;
#line 65
void setCoord(int x , int y , coordList **startlist ) ;
#line 66
void clearCoord(int x , int y , coordList **startlist ) ;
#line 67
void initNodes(void) ;
#line 68
nodep newNode(void) ;
#line 69
void freeNode(nodep n ) ;
#line 70
char *dupStr(char *s ) ;
#line 71
void freeProps(nodep n ) ;
#line 72
void delNode(nodep n ) ;
#line 73
void addprop(nodep n , property *p ) ;
#line 74
property *getprop(nodep n , Token t ) ;
#line 75
int treeCountSiblings(nodep n ) ;
#line 76
nodep nthChild(nodep n , int c ) ;
#line 77
nodep parent(nodep n ) ;
#line 78
nodep child(nodep n ) ;
#line 79
nodep lastSibling(nodep n ) ;
#line 80
nodep nextSibling(nodep n ) ;
#line 81
nodep treeLastSibling(nodep n ) ;
#line 82
nodep treeDown(nodep n ) ;
#line 83
nodep treeUp(nodep n ) ;
#line 84
nodep treeNextUp(nodep n ) ;
#line 85
nodep treeNext(nodep n ) ;
#line 86
nodep lastChildOfLastSibling(nodep n ) ;
#line 87
nodep treeLast(nodep n ) ;
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
static int newNodeNum  ;
#line 9 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
boolean getCoord(int x , int y , coordList *list ) 
{ 


  {
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! list) {
#line 13
      goto while_break;
    }
#line 14
    if ((int )list->x == x) {
#line 14
      if ((int )list->y == y) {
#line 15
        return (1);
      }
    }
#line 13
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  return (0);
}
}
#line 26
extern int ( /* missing proto */  malloc)() ;
#line 21 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
coordList *addCoord(int x , int y ) 
{ 
  coordList *co ;
  int tmp ;

  {
  {
#line 26
  tmp = malloc(sizeof(coordList ));
#line 26
  co = (coordList *)tmp;
  }
#line 26
  if (! co) {
    {
#line 27
    barf("Memory allocation failure (addCoord)");
    }
  }
#line 28
  co->next = (struct coordstruct *)0;
#line 29
  co->x = (char )x;
#line 30
  co->y = (char )y;
#line 31
  return (co);
}
}
#line 36 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void setCoord(int x , int y , coordList **startlist ) 
{ 
  coordList *list ;

  {
#line 41
  if (! *startlist) {
    {
#line 42
    *startlist = addCoord(x, y);
    }
  } else {
#line 44
    list = *startlist;
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! list->next) {
#line 44
        goto while_break;
      }
#line 45
      if (x == (int )list->x) {
#line 45
        if (y == (int )list->y) {
#line 46
          return;
        }
      }
#line 44
      list = list->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 47
    list->next = addCoord(x, y);
    }
  }
#line 49
  return;
}
}
#line 70
extern int ( /* missing proto */  free)() ;
#line 52 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void clearCoord(int x , int y , coordList **startlist ) 
{ 
  coordList *last ;
  coordList *list ;

  {
#line 59
  last = (coordList *)0;
#line 60
  list = *startlist;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (list) {
#line 61
      if (! (x != (int )list->x)) {
#line 61
        if (! (y != (int )list->y)) {
#line 61
          goto while_break;
        }
      }
    } else {
#line 61
      goto while_break;
    }
#line 62
    last = list;
#line 63
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (list) {
#line 66
    if (last) {
#line 67
      last->next = list->next;
    } else {
#line 69
      *startlist = list->next;
    }
    {
#line 70
    free(list);
    }
  }
#line 72
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void initNodes(void) 
{ 


  {
#line 77
  newNodeNum = 0;
#line 78
  return;
}
}
#line 87
extern int ( /* missing proto */  calloc)() ;
#line 80 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep newNode(void) 
{ 
  nodep new ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 87
  tmp = calloc(1, sizeof(node ));
#line 87
  new = (nodep )tmp;
  }
#line 88
  if (! new) {
    {
#line 89
    barf("Memory allocation failure (newnode)");
    }
  }
#line 90
  tmp___0 = newNodeNum;
#line 90
  newNodeNum ++;
#line 90
  new->nodeNum = tmp___0;
#line 91
  return (new);
}
}
#line 94 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void freeNode(nodep n ) 
{ 


  {
#line 97
  if (n) {
    {
#line 98
    freeNode(n->nextSibling);
#line 99
    freeNode(n->child);
#line 100
    delNode(n);
    }
  }
#line 102
  return;
}
}
#line 112
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 104 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
char *dupStr(char *s ) 
{ 
  char *c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 112
  tmp = (int )strlen(s);
#line 112
  tmp___0 = malloc((unsigned int )tmp + 1U);
#line 112
  c = (char *)tmp___0;
  }
#line 113
  if (! c) {
    {
#line 114
    barf("Memory allocation failure (dupstr)");
    }
  }
  {
#line 115
  strcpy(c, s);
  }
#line 116
  return (c);
}
}
#line 121 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void freeProps(nodep n ) 
{ 
  property *prop ;
  property *lastprop ;
  coordList *cl ;
  coordList *lastcl ;

  {
#line 126
  prop = n->p;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! prop) {
#line 127
      goto while_break;
    }
    {
#line 135
    if ((unsigned int )prop->t == 0U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 1U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 8U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 9U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 6U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 7U) {
#line 135
      goto case_0;
    }
#line 135
    if ((unsigned int )prop->t == 10U) {
#line 135
      goto case_0;
    }
#line 144
    if ((unsigned int )prop->t == 5U) {
#line 144
      goto case_5;
    }
#line 144
    if ((unsigned int )prop->t == 11U) {
#line 144
      goto case_5;
    }
#line 128
    goto switch_break;
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 136
    cl = prop->data.stones;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! cl) {
#line 137
        goto while_break___0;
      }
      {
#line 138
      lastcl = cl;
#line 139
      cl = cl->next;
#line 140
      free(lastcl);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 142
    goto switch_break;
    case_5: /* CIL Label */ 
    case_11: /* CIL Label */ 
    {
#line 145
    free(prop->data.comment);
    }
#line 146
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 150
    lastprop = prop;
#line 151
    prop = prop->next;
#line 152
    free(lastprop);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void delNode(nodep n ) 
{ 


  {
  {
#line 160
  freeProps(n);
#line 161
  free(n);
  }
#line 162
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
void addprop(nodep n , property *p ) 
{ 


  {
#line 168
  p->next = n->p;
#line 169
  n->p = p;
#line 170
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
property *getprop(nodep n , Token t ) 
{ 
  property *p ;

  {
#line 177
  p = n->p;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (p) {
#line 178
      if (! ((unsigned int )p->t != (unsigned int )t)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
#line 179
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (p);
}
}
#line 183 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
int treeCountSiblings(nodep n ) 
{ 
  int i ;
  nodep n1 ;

  {
#line 189
  n1 = n->child;
#line 190
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! n1) {
#line 191
      goto while_break;
    }
#line 192
    n1 = n1->nextSibling;
#line 193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (i);
}
}
#line 198 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep nthChild(nodep n , int c ) 
{ 
  int tmp ;

  {
#line 203
  if (n->child) {
    {
#line 204
    n = child(n);
    }
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      tmp = c;
#line 205
      c --;
#line 205
      if (tmp) {
#line 205
        if (! n) {
#line 205
          goto while_break;
        }
      } else {
#line 205
        goto while_break;
      }
      {
#line 206
      n = nextSibling(n);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 208
    n = (nodep )0;
  }
#line 210
  return (n);
}
}
#line 215 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep parent(nodep n ) 
{ 


  {
#line 218
  return (n->parent);
}
}
#line 221 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep child(nodep n ) 
{ 


  {
#line 224
  return (n->child);
}
}
#line 227 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep lastSibling(nodep n ) 
{ 


  {
#line 230
  return (n->lastSibling);
}
}
#line 233 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep nextSibling(nodep n ) 
{ 


  {
#line 236
  return (n->nextSibling);
}
}
#line 239 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeLastSibling(nodep n ) 
{ 


  {
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! n->nextSibling) {
#line 242
      goto while_break;
    }
#line 243
    n = n->nextSibling;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (n);
}
}
#line 249 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeDown(nodep n ) 
{ 
  nodep tmp ;

  {
#line 252
  if (n->child) {
    {
#line 254
    tmp = child(n);
    }
#line 254
    return (tmp);
  } else {
#line 257
    return (n);
  }
}
}
#line 262 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeUp(nodep n ) 
{ 
  nodep tmp ;

  {
#line 265
  if (n->parent) {
    {
#line 267
    tmp = parent(n);
    }
#line 267
    return (tmp);
  } else {
#line 270
    return (n);
  }
}
}
#line 276 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeNextUp(nodep n ) 
{ 
  nodep tmp ;
  nodep tmp___0 ;
  nodep tmp___1 ;

  {
#line 279
  if (n->nextSibling) {
    {
#line 281
    tmp = nextSibling(n);
    }
#line 281
    return (tmp);
  } else
#line 282
  if (n->parent) {
    {
#line 284
    while (1) {
      while_continue: /* CIL Label */ ;
#line 284
      if (n->parent) {
#line 284
        if (! (! n->nextSibling)) {
#line 284
          goto while_break;
        }
      } else {
#line 284
        goto while_break;
      }
      {
#line 285
      n = parent(n);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 286
    if (n->nextSibling) {
      {
#line 287
      tmp___0 = nextSibling(n);
      }
#line 287
      return (tmp___0);
    } else {
#line 289
      return (n);
    }
  } else
#line 290
  if (n->child) {
    {
#line 292
    tmp___1 = child(n);
    }
#line 292
    return (tmp___1);
  } else {
#line 295
    return (n);
  }
}
}
#line 301 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeNext(nodep n ) 
{ 
  nodep r ;

  {
  {
#line 307
  r = treeDown(n);
  }
#line 307
  if (! ((unsigned long )n != (unsigned long )r)) {
    {
#line 311
    r = treeNextUp(n);
    }
  }
#line 314
  return (r);
}
}
#line 319 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep lastChildOfLastSibling(nodep n ) 
{ 
  nodep tmp ;
  nodep tmp___0 ;

  {
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! n->nextSibling) {
#line 323
      goto while_break;
    }
    {
#line 324
    n = nextSibling(n);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if (n->child) {
    {
#line 326
    tmp = child(n);
#line 326
    tmp___0 = lastChildOfLastSibling(tmp);
    }
#line 326
    return (tmp___0);
  } else {
#line 328
    return (n);
  }
}
}
#line 332 "/home/wheatley/newnew/temp/mgt-2.31/tree.c"
nodep treeLast(nodep n ) 
{ 
  nodep r ;
  nodep tmp ;
  nodep tmp___0 ;

  {
#line 337
  if (n->lastSibling) {
    {
#line 338
    n = lastSibling(n);
    }
#line 339
    if (n->child) {
      {
#line 340
      tmp = child(n);
#line 340
      r = lastChildOfLastSibling(tmp);
      }
    } else {
#line 342
      r = n;
    }
  } else
#line 343
  if (n->parent) {
    {
#line 344
    r = parent(n);
    }
  } else
#line 345
  if (n->child) {
    {
#line 346
    tmp___0 = child(n);
#line 346
    r = lastChildOfLastSibling(tmp___0);
    }
  } else {
#line 348
    r = n;
  }
#line 350
  return (r);
}
}
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void buildTree0(nodep n , pBoard b ) ;
#line 51
int legal(pBoard b , nodep n , Token player , int i , int j ) ;
#line 52
boolean inRange(int i , int j ) ;
#line 53
boolean alive0(pBoard b , pBoard m , int i , int j , piece t ) ;
#line 54
boolean alive(pBoard b , int i , int j ) ;
#line 55
void removeStones(pBoard b , int i , int j ) ;
#line 56
boolean tryKill(pBoard b , int i , int j , piece t ) ;
#line 57
void placeStone(pBoard b , int i , int j , piece t ) ;
#line 58
void boardSet(pBoard b , int i , int j , piece p ) ;
#line 59
piece boardGet(pBoard b , int i , int j ) ;
#line 60
void boardClear(pBoard b ) ;
#line 61
void copyBoard(pBoard a , pBoard b ) ;
#line 62
void scoreBoard(pBoard b , int *score ) ;
#line 178 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int xcur ;
#line 178
int ycur ;
#line 179
Token curPlayer ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 26 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
int moveNum ;
#line 17 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
int legal(pBoard b , nodep n , Token player , int i , int j ) 
{ 
  board a ;
  board copy ;
  int same ;
  int x ;
  int y ;
  int savex ;
  int savey ;
  int savemove ;
  boolean islegal ;
  int savepris[2] ;
  Token savecurPlayer ;
  int tmp ;
  boolean tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 30
  savemove = moveNum;
#line 31
  savecurPlayer = curPlayer;
#line 32
  savex = xcur;
#line 33
  savey = ycur;
#line 34
  savepris[0] = prisoners[0];
#line 35
  savepris[1] = prisoners[1];
#line 36
  copyBoard(b, & copy);
#line 38
  islegal = 1;
  }
#line 40
  if ((unsigned int )b->b[i][j] != 0U) {
    {
#line 41
    (*(io->notifyError))("There\'s already a piece there.");
    }
#line 42
    return (0);
  }
#line 44
  if ((unsigned int )player == 1U) {
#line 44
    tmp = 1;
  } else {
#line 44
    tmp = 2;
  }
  {
#line 44
  placeStone(& copy, i, j, tmp);
#line 45
  tmp___0 = alive(& copy, i, j);
  }
#line 45
  if (! tmp___0) {
    {
#line 46
    (*(io->notifyError))("That move is suicide.");
#line 47
    islegal = 0;
    }
  }
#line 49
  if (islegal) {
#line 49
    n = n->parent;
#line 49
    if (n) {
      {
#line 50
      boardClear(& a);
#line 51
      buildTree0(n, & a);
#line 52
      same = 1;
#line 53
      x = boardsize;
      }
      {
#line 53
      while (1) {
        while_continue: /* CIL Label */ ;
#line 53
        if (same) {
#line 53
          tmp___2 = x;
#line 53
          x --;
#line 53
          if (! tmp___2) {
#line 53
            goto while_break;
          }
        } else {
#line 53
          goto while_break;
        }
#line 54
        y = boardsize;
        {
#line 54
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 54
          if (same) {
#line 54
            tmp___1 = y;
#line 54
            y --;
#line 54
            if (! tmp___1) {
#line 54
              goto while_break___0;
            }
          } else {
#line 54
            goto while_break___0;
          }
#line 55
          same = (unsigned int )copy.b[x][y] == (unsigned int )a.b[x][y];
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 57
      if (same) {
        {
#line 58
        (*(io->notifyError))("Can\'t retake the ko yet.");
#line 59
        islegal = 0;
        }
      }
    }
  }
#line 62
  xcur = savex;
#line 63
  ycur = savey;
#line 64
  prisoners[0] = savepris[0];
#line 65
  moveNum = savemove;
#line 66
  prisoners[1] = savepris[1];
#line 67
  curPlayer = savecurPlayer;
#line 69
  return (islegal);
}
}
#line 75 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
boolean inRange(int i , int j ) 
{ 
  int tmp ;

  {
#line 77
  if (i >= 0) {
#line 77
    if (i < boardsize) {
#line 77
      if (j >= 0) {
#line 77
        if (j < boardsize) {
#line 77
          tmp = 1;
        } else {
#line 77
          tmp = 0;
        }
      } else {
#line 77
        tmp = 0;
      }
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  return (tmp);
}
}
#line 80 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
boolean alive0(pBoard b , pBoard m , int i , int j , piece t ) 
{ 
  piece pt ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;
  int tmp___3 ;

  {
#line 88
  pt = b->b[i][j];
#line 89
  if ((unsigned int )pt != 0U) {
#line 89
    if ((unsigned int )pt != (unsigned int )t) {
#line 90
      return (0);
    } else {
#line 89
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 89
  if ((unsigned int )m->b[i][j] != 0U) {
#line 90
    return (0);
  }
#line 91
  if ((unsigned int )pt == (unsigned int )t) {
#line 91
    m->b[i][j] = (piece )1;
  } else {
#line 91
    m->b[i][j] = (piece )2;
  }
#line 92
  if ((unsigned int )pt == 0U) {
#line 93
    return (1);
  }
#line 94
  if (j < boardsize - 1) {
    {
#line 94
    tmp = alive0(b, m, i, j + 1, t);
    }
#line 94
    if (tmp) {
#line 94
      tmp___3 = 1;
    } else {
#line 94
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 94
  if (i < boardsize - 1) {
    {
#line 94
    tmp___0 = alive0(b, m, i + 1, j, t);
    }
#line 94
    if (tmp___0) {
#line 94
      tmp___3 = 1;
    } else {
#line 94
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 94
  if (i) {
    {
#line 94
    tmp___1 = alive0(b, m, i - 1, j, t);
    }
#line 94
    if (tmp___1) {
#line 94
      tmp___3 = 1;
    } else {
#line 94
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 94
  if (j) {
    {
#line 94
    tmp___2 = alive0(b, m, i, j - 1, t);
    }
#line 94
    if (tmp___2) {
#line 94
      tmp___3 = 1;
    } else {
#line 94
      tmp___3 = 0;
    }
  } else {
#line 94
    tmp___3 = 0;
  }
#line 94
  return (tmp___3);
}
}
#line 101 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
boolean alive(pBoard b , int i , int j ) 
{ 
  board m ;
  boolean tmp ;

  {
  {
#line 107
  boardClear(& m);
#line 108
  tmp = alive0(b, & m, i, j, b->b[i][j]);
  }
#line 108
  return (tmp);
}
}
#line 111 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void removeStones0(pBoard b , int i , int j , piece t ) 
{ 


  {
#line 116
  if ((unsigned int )b->b[i][j] != (unsigned int )t) {
#line 117
    return;
  }
#line 118
  b->b[i][j] = (piece )0;
#line 119
  (prisoners[(int )t - 1]) ++;
#line 120
  if (j < boardsize - 1) {
    {
#line 121
    removeStones0(b, i, j + 1, t);
    }
  }
#line 122
  if (i < boardsize - 1) {
    {
#line 123
    removeStones0(b, i + 1, j, t);
    }
  }
#line 124
  if (i) {
    {
#line 125
    removeStones0(b, i - 1, j, t);
    }
  }
#line 126
  if (j) {
    {
#line 127
    removeStones0(b, i, j - 1, t);
    }
  }
#line 128
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void removeStones(pBoard b , int i , int j ) 
{ 


  {
  {
#line 136
  removeStones0(b, i, j, b->b[i][j]);
  }
#line 137
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
boolean tryKill(pBoard b , int i , int j , piece t ) 
{ 
  piece w ;
  boolean tmp ;
  boolean tmp___0 ;

  {
  {
#line 145
  tmp = inRange(i, j);
  }
#line 145
  if (! tmp) {
#line 146
    return (0);
  }
#line 147
  w = b->b[i][j];
#line 148
  if ((unsigned int )w != 0U) {
#line 148
    if ((unsigned int )w != (unsigned int )t) {
      {
#line 148
      tmp___0 = alive(b, i, j);
      }
#line 148
      if (! tmp___0) {
        {
#line 149
        removeStones(b, i, j);
        }
#line 150
        return (1);
      }
    }
  }
#line 152
  return (0);
}
}
#line 155 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void placeStone(pBoard b , int i , int j , piece t ) 
{ 
  boolean tmp ;

  {
  {
#line 160
  tmp = inRange(i, j);
  }
#line 160
  if (tmp) {
#line 161
    b->b[i][j] = t;
#line 162
    xcur = i;
#line 163
    ycur = j;
#line 164
    if (j) {
      {
#line 165
      tryKill(b, i, j - 1, t);
      }
    }
#line 166
    if (j < boardsize - 1) {
      {
#line 167
      tryKill(b, i, j + 1, t);
      }
    }
#line 168
    if (i) {
      {
#line 169
      tryKill(b, i - 1, j, t);
      }
    }
#line 170
    if (i < boardsize - 1) {
      {
#line 171
      tryKill(b, i + 1, j, t);
      }
    }
  }
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void boardSet(pBoard b , int i , int j , piece p ) 
{ 


  {
#line 180
  b->b[i][j] = p;
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
piece boardGet(pBoard b , int i , int j ) 
{ 


  {
#line 187
  return (b->b[i][j]);
}
}
#line 191 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void boardClear(pBoard b ) 
{ 


  {
  {
#line 194
  memset((void *)((char *)(b->b)), 0, 361UL * sizeof(piece ));
  }
#line 198
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void copyBoard(pBoard a , pBoard b ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 204
  i = boardsize;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    tmp___0 = i;
#line 204
    i --;
#line 204
    if (! tmp___0) {
#line 204
      goto while_break;
    }
#line 205
    j = boardsize;
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      tmp = j;
#line 205
      j --;
#line 205
      if (! tmp) {
#line 205
        goto while_break___0;
      }
#line 206
      b->b[i][j] = a->b[i][j];
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
int look(int stone , int *array , int *index___0 , int i ) 
{ 
  int tmp ;

  {
#line 213
  if (stone == 0) {
#line 214
    tmp = *index___0;
#line 214
    (*index___0) ++;
#line 214
    *(array + tmp) = i;
  } else
#line 215
  if (stone == 1) {
#line 216
    return (1);
  } else
#line 217
  if (stone == 2) {
#line 218
    return (2);
  }
#line 219
  return (0);
}
}
#line 223 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
int fillregion(pBoard b , int x , int y ) 
{ 
  int goup[19] ;
  int godown[19] ;
  int up ;
  int down ;
  int found ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 227
  up = 0;
#line 227
  down = 0;
#line 227
  found = 0;
#line 229
  i = x;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (i < boardsize) {
#line 229
      if (! ((unsigned int )b->b[i][y] == 0U)) {
#line 229
        goto while_break;
      }
    } else {
#line 229
      goto while_break;
    }
#line 230
    b->b[i][y] = (piece )6;
#line 231
    if (y > 0) {
      {
#line 232
      tmp = look((int )b->b[i][y - 1], goup, & up, i);
#line 232
      found |= tmp;
      }
    }
#line 233
    if (y < boardsize - 1) {
      {
#line 234
      tmp___0 = look((int )b->b[i][y + 1], godown, & down, i);
#line 234
      found |= tmp___0;
      }
    }
#line 229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (i != boardsize) {
#line 237
    if ((unsigned int )b->b[i][y] == 1U) {
#line 238
      found |= 1;
    }
#line 239
    if ((unsigned int )b->b[i][y] == 2U) {
#line 240
      found |= 2;
    }
  }
#line 242
  i = x - 1;
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (i >= 0) {
#line 242
      if (! ((unsigned int )b->b[i][y] == 0U)) {
#line 242
        goto while_break___0;
      }
    } else {
#line 242
      goto while_break___0;
    }
#line 243
    b->b[i][y] = (piece )6;
#line 244
    if (y > 0) {
      {
#line 245
      tmp___1 = look((int )b->b[i][y - 1], goup, & up, i);
#line 245
      found |= tmp___1;
      }
    }
#line 246
    if (y < boardsize - 1) {
      {
#line 247
      tmp___2 = look((int )b->b[i][y + 1], godown, & down, i);
#line 247
      found |= tmp___2;
      }
    }
#line 242
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 249
  if (i != -1) {
#line 250
    if ((unsigned int )b->b[i][y] == 1U) {
#line 251
      found |= 1;
    }
#line 252
    if ((unsigned int )b->b[i][y] == 2U) {
#line 253
      found |= 2;
    }
  }
  {
#line 255
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 255
    if (! up) {
#line 255
      goto while_break___1;
    }
    {
#line 256
    up --;
#line 256
    tmp___3 = fillregion(b, goup[up], y - 1);
#line 256
    found |= tmp___3;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 257
    if (! down) {
#line 257
      goto while_break___2;
    }
    {
#line 258
    down --;
#line 258
    tmp___4 = fillregion(b, godown[down], y + 1);
#line 258
    found |= tmp___4;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 259
  return (found);
}
}
#line 263 "/home/wheatley/newnew/temp/mgt-2.31/play.c"
void scoreBoard(pBoard b , int *score ) 
{ 
  int x ;
  int y ;
  int i ;
  int j ;
  int owner ;
  piece newval ;

  {
#line 270
  *(score + 0) = 0;
#line 271
  *(score + 1) = 0;
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < boardsize)) {
#line 272
      goto while_break;
    }
#line 273
    j = 0;
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! (j < boardsize)) {
#line 273
        goto while_break___0;
      }
      {
#line 274
      owner = fillregion(b, i, j);
      }
#line 275
      if (! owner) {
#line 276
        owner = 3;
      }
      {
#line 278
      if (owner == 3) {
#line 278
        goto case_3;
      }
#line 281
      if (owner == 2) {
#line 281
        goto case_2;
      }
#line 284
      if (owner == 1) {
#line 284
        goto case_1;
      }
#line 277
      goto switch_break;
      case_3: /* CIL Label */ 
#line 279
      newval = (piece )3;
#line 280
      goto switch_break;
      case_2: /* CIL Label */ 
#line 282
      newval = (piece )5;
#line 283
      goto switch_break;
      case_1: /* CIL Label */ 
#line 285
      newval = (piece )4;
#line 286
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 288
      x = 0;
      {
#line 288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 288
        if (! (x < boardsize)) {
#line 288
          goto while_break___1;
        }
#line 289
        y = 0;
        {
#line 289
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 289
          if (! (y < boardsize)) {
#line 289
            goto while_break___2;
          }
#line 290
          if ((unsigned int )b->b[x][y] == 6U) {
#line 291
            b->b[x][y] = newval;
#line 292
            if (owner != 3) {
#line 293
              (*(score + (owner - 1))) ++;
            }
          }
#line 289
          y ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 288
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 273
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void addChild(nodep n , nodep c ) ;
#line 50
nodep parse(int lev ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
struct __anonstruct_tokens_13 tokens[27]  = 
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
  {      {(char *)"W", (Token )0}, 
        {(char *)"B", (Token )1}, 
        {(char *)"C", (Token )5}, 
        {(char *)"AW", (Token )6}, 
        {(char *)"AB", (Token )7}, 
        {(char *)"L", (Token )8}, 
        {(char *)"AE", (Token )10}, 
        {(char *)"N", (Token )11}, 
        {(char *)"M", (Token )9}, 
        {(char *)"SZ", (Token )14}, 
        {(char *)"GN", (Token )20}, 
        {(char *)"GC", (Token )27}, 
        {(char *)"EV", (Token )21}, 
        {(char *)"RO", (Token )22}, 
        {(char *)"DT", (Token )23}, 
        {(char *)"PC", (Token )24}, 
        {(char *)"PB", (Token )16}, 
        {(char *)"PW", (Token )18}, 
        {(char *)"RE", (Token )26}, 
        {(char *)"US", (Token )29}, 
        {(char *)"TM", (Token )25}, 
        {(char *)"SO", (Token )28}, 
        {(char *)"BR", (Token )17}, 
        {(char *)"WR", (Token )19}, 
        {(char *)"HA", (Token )15}, 
        {(char *)"KM", (Token )30}, 
        {(char *)"PL", (Token )13}};
#line 95 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
char buf[1028]  ;
#line 95 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
char *curin  ;
#line 95 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
char started  ;
#line 97 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
void readInit(void) 
{ 
  int p ;

  {
#line 100
  buf[0] = (char )'\000';
#line 101
  curin = & buf[0];
#line 102
  started = (char)1;
#line 103
  boardsize = 19;
#line 104
  handicap = 0;
#line 105
  p = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (p <= 14)) {
#line 105
      goto while_break;
    }
#line 106
    if (info[p]) {
      {
#line 107
      free(info[p]);
      }
    }
#line 108
    info[p] = (char *)0;
#line 105
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static char *readLine(void) 
{ 
  char *tmp ;

  {
  {
#line 115
  curin = & buf[0];
#line 116
  buf[0] = (char )'\000';
#line 117
  tmp = fgets((char */* __restrict  */)(& buf[0]), 1023, (FILE */* __restrict  */)input);
  }
#line 117
  return (tmp);
}
}
#line 121 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static char readChar(void) 
{ 
  char *tmp ;

  {
#line 123
  if (*curin) {
#line 124
    tmp = curin;
#line 124
    curin ++;
#line 124
    return (*tmp);
  }
  {
#line 125
  curin = & buf[0];
#line 126
  buf[0] = (char )'\000';
#line 127
  fgets((char */* __restrict  */)(& buf[0]), 1023, (FILE */* __restrict  */)input);
  }
#line 128
  return ((char)0);
}
}
#line 133 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static int getCoordStr(coord *co ) 
{ 
  char *dest ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 136
  tmp = strlen((char const   *)curin);
  }
#line 136
  if (tmp < 4UL) {
    {
#line 136
    tmp___0 = strlen((char const   *)curin);
    }
#line 136
    if ((int )*(curin + (tmp___0 - 1UL)) != 10) {
#line 138
      dest = buf;
      {
#line 138
      while (1) {
        while_continue: /* CIL Label */ ;
#line 138
        if (! *curin) {
#line 138
          goto while_break;
        }
#line 139
        *dest = *curin;
#line 138
        curin ++;
#line 138
        dest ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 140
      *dest = (char)0;
#line 141
      fgets((char */* __restrict  */)dest, 1023, (FILE */* __restrict  */)input);
#line 142
      curin = buf;
      }
    }
  }
#line 144
  if ((int )*(curin + 0) == 91) {
#line 144
    if ((int )*(curin + 1) >= 97) {
#line 144
      if ((int )*(curin + 1) <= 115) {
#line 144
        if ((int )*(curin + 2) >= 97) {
#line 144
          if ((int )*(curin + 2) <= 115) {
#line 144
            if ((int )*(curin + 3) == 93) {
#line 146
              co->x = (char )((int )*(curin + 1) - 97);
#line 147
              co->y = (char )((int )*(curin + 2) - 97);
#line 148
              curin += 4;
              {
#line 149
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 149
                if (! ((int )*curin == 32)) {
#line 149
                  if (! ((int )*curin == 9)) {
#line 149
                    goto while_break___0;
                  }
                }
#line 150
                curin ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 151
              if ((int )*curin == 10) {
                {
#line 152
                readLine();
                }
              }
#line 153
              return (1);
            } else {
#line 155
              return (0);
            }
          } else {
#line 155
            return (0);
          }
        } else {
#line 155
          return (0);
        }
      } else {
#line 155
        return (0);
      }
    } else {
#line 155
      return (0);
    }
  } else {
#line 155
    return (0);
  }
}
}
#line 159 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void getCoordList(coordList **clp ) 
{ 
  coord co ;
  int tmp ;

  {
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    tmp = getCoordStr(& co);
    }
#line 163
    if (! tmp) {
#line 163
      goto while_break;
    }
    {
#line 164
    setCoord((int )co.x, (int )co.y, clp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void addPass(nodep n , Token t ) 
{ 
  property *p ;
  int tmp ;

  {
  {
#line 173
  tmp = calloc(1, sizeof(property ));
#line 173
  p = (property *)tmp;
  }
#line 173
  if (! p) {
    {
#line 174
    barf("Memory allocation error (addPass)");
    }
  }
  {
#line 175
  p->t = (Token )12;
#line 176
  p->data.player = t;
#line 177
  addprop(n, p);
  }
#line 179
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void doPlayer(nodep n ) 
{ 
  property *p ;
  int tmp ;

  {
#line 189
  if ((int )*(curin + 0) == 91) {
#line 189
    if ((int )*(curin + 2) == 93) {
#line 189
      if ((int )*(curin + 1) == 66) {
#line 189
        goto _L;
      } else
#line 189
      if ((int )*(curin + 1) == 87) {
        _L: /* CIL Label */ 
        {
#line 190
        tmp = calloc(1, sizeof(property ));
#line 190
        p = (property *)tmp;
        }
#line 191
        if (! p) {
          {
#line 192
          barf("Memory allocation failure (doPlayer)");
          }
        }
#line 193
        p->t = (Token )13;
#line 194
        if ((int )*(curin + 1) == 66) {
#line 194
          p->data.player = (Token )1;
        } else {
#line 194
          p->data.player = (Token )0;
        }
        {
#line 195
        curin += 3;
#line 196
        addprop(n, p);
        }
      }
    }
  }
#line 198
  return;
}
}
#line 201 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static Token tokenize(void) 
{ 
  int i ;
  int len ;
  char buf___0[4] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 206
  len = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! *curin) {
#line 208
      goto _L;
    } else
#line 208
    if ((int )*curin == 10) {
      _L: /* CIL Label */ 
      {
#line 209
      tmp = readLine();
      }
#line 209
      if (! tmp) {
#line 210
        return ((Token )32);
      }
    }
#line 212
    if ((int )*curin == 41) {
#line 213
      curin ++;
#line 214
      return ((Token )3);
    }
#line 216
    if ((int )*curin == 40) {
#line 217
      curin ++;
#line 218
      return ((Token )2);
    }
#line 220
    if ((int )*curin == 59) {
#line 221
      curin ++;
#line 222
      return ((Token )4);
    }
#line 224
    if ((int )*curin >= 65) {
#line 224
      if ((int )*curin <= 90) {
#line 225
        tmp___0 = len;
#line 225
        len ++;
#line 225
        buf___0[tmp___0] = *curin;
      }
    }
#line 226
    curin ++;
#line 207
    if (len < 3) {
#line 207
      if (! ((int )*curin != 91)) {
#line 207
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  buf___0[len] = (char)0;
#line 229
  if (len == 1) {
#line 229
    goto _L___0;
  } else
#line 229
  if (len == 2) {
    _L___0: /* CIL Label */ 
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      if (! ((unsigned long )i < sizeof(tokens) / sizeof(tokens[0]))) {
#line 230
        goto while_break___0;
      }
      {
#line 231
      tmp___1 = strcmp((char const   *)(buf___0), (char const   *)tokens[i].str);
      }
#line 231
      if (! tmp___1) {
#line 232
        return (tokens[i].val);
      }
#line 230
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 233
    if (! ((int )*curin != 93)) {
#line 233
      goto while_break___1;
    }
#line 234
    curin ++;
#line 234
    if (! *curin) {
      {
#line 235
      tmp___2 = readLine();
      }
#line 235
      if (! tmp___2) {
#line 236
        return ((Token )32);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 239
  return ((Token )31);
}
}
#line 244 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void addMoveArrayProp(Token t , nodep n ) 
{ 
  property *p ;
  int tmp ;

  {
  {
#line 254
  p = getprop(n, (unsigned int )t);
  }
#line 254
  if (! p) {
    {
#line 255
    tmp = calloc(1, sizeof(property ));
#line 255
    p = (property *)tmp;
    }
#line 262
    if (! p) {
      {
#line 263
      barf("Memory allocation failure (addMoveArrayProp)");
      }
    }
    {
#line 265
    p->data.stones = (coordList *)0;
#line 266
    p->t = t;
#line 267
    addprop(n, p);
    }
  }
  {
#line 269
  getCoordList(& p->data.stones);
  }
#line 270
  return;
}
}
#line 283
extern int ( /* missing proto */  atoi)() ;
#line 273 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void doSize(void) 
{ 
  int size ;
  char *s ;
  char c ;
  char b[25] ;
  char *tmp ;

  {
  {
#line 277
  s = & b[0];
#line 278
  readChar();
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    c = readChar();
    }
#line 279
    if (! ((int )c != 93)) {
#line 279
      goto while_break;
    }
#line 280
    if (c) {
#line 280
      if ((int )c != 92) {
#line 281
        tmp = s;
#line 281
        s ++;
#line 281
        *tmp = c;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  *s = (char)0;
#line 283
  size = atoi(b);
  }
#line 284
  if (size > 1) {
#line 284
    if (size <= 19) {
#line 285
      boardsize = size;
    }
  }
#line 286
  return;
}
}
#line 290 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void doHandicap(void) 
{ 
  int size ;
  char *s ;
  char c ;
  char b[25] ;
  char *tmp ;

  {
  {
#line 294
  s = & b[0];
#line 295
  readChar();
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    c = readChar();
    }
#line 296
    if (! ((int )c != 93)) {
#line 296
      goto while_break;
    }
#line 297
    if (c) {
#line 297
      if ((int )c != 92) {
#line 298
        tmp = s;
#line 298
        s ++;
#line 298
        *tmp = c;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 299
  *s = (char)0;
#line 300
  size = atoi(b);
  }
#line 301
  if (size > 1) {
#line 301
    if (size <= 17) {
#line 302
      handicap = size;
    }
  }
#line 303
  return;
}
}
#line 330
extern int ( /* missing proto */  realloc)() ;
#line 309 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static char *getText(void) 
{ 
  int c ;
  char *s ;
  char *buffer___0 ;
  int space ;
  int blocks ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 314
  space = 4096;
#line 315
  blocks = 1;
#line 317
  tmp = malloc(4096);
#line 317
  buffer___0 = (char *)tmp;
  }
#line 318
  if (! buffer___0) {
    {
#line 319
    barf("Memory Allocation Failure (getText)");
    }
  }
  {
#line 320
  s = buffer___0;
#line 322
  readChar();
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 323
    tmp___4 = readChar();
#line 323
    c = (int )tmp___4;
    }
#line 323
    if (! (c != 93)) {
#line 323
      goto while_break;
    }
#line 324
    if (! c) {
      {
#line 325
      tmp___0 = readChar();
#line 325
      c = (int )tmp___0;
      }
#line 326
      if (! c) {
#line 327
        goto while_break;
      } else
#line 326
      if (c == 93) {
#line 327
        goto while_break;
      }
    }
#line 329
    if (space <= 1) {
      {
#line 330
      blocks ++;
#line 330
      tmp___1 = realloc(buffer___0, blocks * 4096);
#line 330
      buffer___0 = (char *)tmp___1;
      }
#line 331
      if (! buffer___0) {
        {
#line 332
        barf("Memory Allocation Failure (getText)");
        }
      }
#line 333
      s = (buffer___0 - space) + (blocks - 1) * 4096;
#line 334
      space += 4096;
    }
#line 336
    if (c == 92) {
      {
#line 337
      tmp___2 = readChar();
#line 337
      c = (int )tmp___2;
      }
    }
#line 338
    if (c) {
#line 339
      tmp___3 = s;
#line 339
      s ++;
#line 339
      *tmp___3 = (char )c;
#line 340
      space --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if ((unsigned long )s != (unsigned long )buffer___0) {
#line 343
    if ((int )*(s - 1) == 10) {
#line 344
      s --;
    }
  }
#line 345
  *s = (char)0;
#line 346
  return (buffer___0);
}
}
#line 350 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void doComment(nodep n , Token t ) 
{ 
  property *p ;
  char *buffer___0 ;
  int tmp ;

  {
  {
#line 357
  tmp = calloc(1, sizeof(property ));
#line 357
  p = (property *)tmp;
  }
#line 358
  if (! p) {
    {
#line 359
    barf("Memory Allocation Failure (doComment)");
    }
  }
  {
#line 360
  buffer___0 = getText();
#line 361
  p->t = t;
#line 362
  p->data.comment = dupStr(buffer___0);
#line 363
  addprop(n, p);
#line 364
  free(buffer___0);
  }
#line 365
  return;
}
}
#line 368 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
static void doInfo(Token t ) 
{ 
  char *buffer___0 ;

  {
  {
#line 373
  buffer___0 = getText();
#line 374
  info[(int )t - 16] = dupStr(buffer___0);
#line 375
  free(buffer___0);
  }
#line 376
  return;
}
}
#line 379 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
void addChild(nodep n , nodep c ) 
{ 
  nodep s ;
  nodep tmp ;

  {
#line 382
  if (n) {
#line 383
    if (n->child) {
      {
#line 385
      tmp = child(n);
#line 385
      s = treeLastSibling(tmp);
#line 386
      s->nextSibling = c;
#line 387
      c->lastSibling = s;
#line 388
      c->parent = n;
      }
    } else {
#line 390
      n->child = c;
#line 391
      c->parent = n;
    }
  }
#line 394
  return;
}
}
#line 397 "/home/wheatley/newnew/temp/mgt-2.31/parse.c"
nodep parse(int lev ) 
{ 
  nodep r ;
  nodep n ;
  nodep new ;
  Token t ;
  char *tmp ;
  char *ch ;
  char *end ;

  {
#line 403
  if (started) {
#line 404
    started = (char)0;
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 406
      if (! ((int )*curin != 40)) {
#line 406
        goto while_break;
      }
      {
#line 407
      tmp = readLine();
      }
#line 407
      if (! tmp) {
#line 408
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 411
  n = (nodep )0;
#line 411
  r = n;
  {
#line 412
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 413
    t = tokenize();
    }
    {
#line 415
    if ((unsigned int )t == 14U) {
#line 415
      goto case_14;
    }
#line 419
    if ((unsigned int )t == 1U) {
#line 419
      goto case_1;
    }
#line 419
    if ((unsigned int )t == 0U) {
#line 419
      goto case_1;
    }
#line 428
    if ((unsigned int )t == 8U) {
#line 428
      goto case_8;
    }
#line 428
    if ((unsigned int )t == 9U) {
#line 428
      goto case_8;
    }
#line 428
    if ((unsigned int )t == 10U) {
#line 428
      goto case_8;
    }
#line 428
    if ((unsigned int )t == 7U) {
#line 428
      goto case_8;
    }
#line 428
    if ((unsigned int )t == 6U) {
#line 428
      goto case_8;
    }
#line 434
    if ((unsigned int )t == 13U) {
#line 434
      goto case_13;
    }
#line 441
    if ((unsigned int )t == 5U) {
#line 441
      goto case_5;
    }
#line 441
    if ((unsigned int )t == 11U) {
#line 441
      goto case_5;
    }
#line 447
    if ((unsigned int )t == 4U) {
#line 447
      goto case_4;
    }
#line 455
    if ((unsigned int )t == 2U) {
#line 455
      goto case_2;
    }
#line 465
    if ((unsigned int )t == 32U) {
#line 465
      goto case_32;
    }
#line 465
    if ((unsigned int )t == 3U) {
#line 465
      goto case_32;
    }
#line 481
    if ((unsigned int )t == 19U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 17U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 28U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 25U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 29U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 26U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 18U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 16U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 24U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 23U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 22U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 21U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 27U) {
#line 481
      goto case_19;
    }
#line 481
    if ((unsigned int )t == 20U) {
#line 481
      goto case_19;
    }
#line 485
    if ((unsigned int )t == 30U) {
#line 485
      goto case_30;
    }
#line 495
    if ((unsigned int )t == 15U) {
#line 495
      goto case_15;
    }
#line 498
    goto switch_default;
    case_14: /* CIL Label */ 
    {
#line 416
    doSize();
    }
#line 417
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 420
    if ((int )*(curin + 1) == 116) {
#line 420
      if ((int )*(curin + 2) == 116) {
#line 420
        if ((int )*(curin + 0) == 91) {
#line 420
          if ((int )*(curin + 3) == 93) {
            {
#line 421
            addPass(n, t);
            }
#line 422
            goto switch_break;
          }
        }
      }
    }
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 429
    if (n) {
      {
#line 430
      addMoveArrayProp(t, n);
      }
    } else {
      {
#line 432
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - property w/o node in data\n");
      }
    }
#line 433
    goto switch_break;
    case_13: /* CIL Label */ 
#line 435
    if (n) {
      {
#line 436
      doPlayer(n);
      }
    } else {
      {
#line 438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - property w/o node in data\n");
      }
    }
#line 439
    goto switch_break;
    case_5: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 442
    if (n) {
      {
#line 443
      doComment(n, t);
      }
    } else {
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - property w/o node in data\n");
      }
    }
#line 446
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 448
    new = newNode();
    }
#line 449
    if (! r) {
#line 450
      r = new;
    } else {
      {
#line 452
      addChild(n, new);
      }
    }
#line 453
    n = new;
#line 454
    goto switch_break;
    case_2: /* CIL Label */ 
#line 456
    if (lev == 1) {
#line 456
      if (! r) {
        {
#line 457
        r = newNode();
#line 457
        n = r;
        }
      }
    }
    {
#line 458
    new = parse(lev + 1);
    }
#line 458
    if (new) {
      {
#line 459
      addChild(n, new);
      }
#line 460
      if (! r) {
#line 461
        r = new;
      }
    }
#line 463
    goto switch_break;
    case_32: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 466
    return (r);
    case_19: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_20: /* CIL Label */ 
    {
#line 483
    doInfo(t);
    }
#line 484
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 487
    doInfo((Token )30);
#line 488
    ch = info[14];
#line 488
    end = ch;
    }
    {
#line 489
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 489
      if (! *end) {
#line 489
        goto while_break___1;
      }
#line 490
      end ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 491
    end --;
    {
#line 491
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 491
      if ((int )*end == 48) {
#line 491
        if (! ((unsigned long )end != (unsigned long )ch)) {
#line 491
          goto while_break___2;
        }
      } else {
#line 491
        goto while_break___2;
      }
#line 491
      end --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 492
    end ++;
#line 492
    *end = (char)0;
#line 494
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 496
    doHandicap();
    }
#line 497
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 499
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 10 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
char *commentGet(int line ) ;
#line 11
int commentLines(void) ;
#line 12
void formatComment(char *comment , int width ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 12 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
static int nlines  =    0;
#line 13 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
int clines  =    0;
#line 14 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
clinetype *cbuf  =    (clinetype *)0;
#line 15 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
char *empty  =    (char *)"";
#line 17 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
char *commentGet(int line ) 
{ 


  {
#line 20
  if (cbuf) {
#line 20
    if (line < clines) {
#line 21
      return (*(cbuf + line));
    } else {
#line 23
      return (empty);
    }
  } else {
#line 23
    return (empty);
  }
}
}
#line 27 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
int commentLines(void) 
{ 


  {
#line 29
  return (clines);
}
}
#line 33 "/home/wheatley/newnew/temp/mgt-2.31/comment.c"
void formatComment(char *comment , int width ) 
{ 
  char *partstart ;
  char *dest ;
  char c ;
  int len ;
  int partlen ;
  int wordlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 40
  clines = 0;
#line 41
  if (width < 49) {
#line 41
    width = width;
  } else {
#line 41
    width = 49;
  }
#line 42
  len = 0;
#line 42
  partlen = len;
#line 42
  wordlen = partlen;
#line 43
  dest = *cbuf;
#line 44
  if ((int )*comment == 10) {
#line 45
    comment ++;
  }
#line 46
  partstart = comment;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (clines >= nlines) {
#line 49
      nlines += 20;
#line 50
      if (cbuf) {
        {
#line 50
        tmp = realloc(cbuf, (unsigned long )nlines * sizeof(clinetype ));
#line 50
        tmp___1 = tmp;
        }
      } else {
        {
#line 50
        tmp___0 = malloc((unsigned long )nlines * sizeof(clinetype ));
#line 50
        tmp___1 = tmp___0;
        }
      }
#line 50
      cbuf = (clinetype *)tmp___1;
#line 52
      if (! cbuf) {
        {
#line 53
        barf("Memory allocation failure (formatComment)");
        }
      }
#line 54
      dest = *(cbuf + clines);
    }
#line 56
    tmp___2 = comment;
#line 56
    comment ++;
#line 56
    c = *tmp___2;
#line 57
    len ++;
#line 58
    partlen ++;
#line 59
    wordlen ++;
#line 60
    if ((int )c == 32) {
#line 61
      wordlen = 0;
    } else
#line 62
    if ((int )c == 10) {
#line 62
      if ((int )*(comment - 2) == 32) {
#line 62
        if ((int )*comment != 10) {
          {
#line 64
          partlen --;
#line 65
          len --;
#line 66
          strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)partstart,
                  (size_t )partlen);
#line 67
          dest += partlen;
#line 68
          partstart = comment;
#line 69
          partlen = 0;
#line 69
          wordlen = partlen;
          }
        } else {
#line 62
          goto _L___1;
        }
      } else {
#line 62
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 70
    if ((int )c == 10) {
#line 70
      goto _L;
    } else
#line 70
    if (! c) {
      _L: /* CIL Label */ 
      {
#line 71
      strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)partstart,
              (size_t )(partlen - 1));
#line 72
      *((dest + partlen) - 1) = (char)0;
#line 73
      wordlen = 0;
#line 73
      partlen = wordlen;
#line 73
      len = partlen;
#line 74
      clines ++;
#line 74
      dest = *(cbuf + clines);
#line 75
      partstart = comment;
      }
    }
#line 77
    if (len == width) {
#line 79
      if (len == wordlen) {
#line 80
        wordlen = 0;
      } else {
#line 83
        len = partlen - wordlen;
      }
      {
#line 85
      strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)partstart,
              (size_t )len);
#line 86
      partstart += len;
#line 87
      *(dest + len) = (char)0;
#line 88
      partlen = wordlen;
#line 88
      len = partlen;
#line 90
      clines ++;
#line 90
      dest = *(cbuf + clines);
      }
    }
#line 47
    if (! c) {
#line 47
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/help.c"
char *helpStr[45]  = 
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/help.c"
  {      (char *)"Quit mgt",      (char *)"Move forward",      (char *)"Move backward",      (char *)"Next node", 
        (char *)"Previous node",      (char *)"End of the current variation",      (char *)"Beginning of file",      (char *)"Next comment", 
        (char *)"Previous comment",      (char *)"Next variation branch",      (char *)"Last variation branch",      (char *)"Jump to a specific node number", 
        (char *)"Write Smart-Go file",      (char *)"Set black stone",      (char *)"Set white stone",      (char *)"Make variation", 
        (char *)"Cut tree into buffer",      (char *)"Add letter",      (char *)"Add mark",      (char *)"Load new file", 
        (char *)"Paste buffer in",      (char *)"Edit comment",      (char *)"Delete current node",      (char *)"Name the current node", 
        (char *)"Score the game",      (char *)"Pass move",      (char *)"Other player\'s turn (permanent)",      (char *)"Toggle stone", 
        (char *)"Reverse through files",      (char *)"Forward through files",      (char *)"Redraw screen",      (char *)"Toggle save format", 
        (char *)"Toggle tutor mode",      (char *)"Save screen image",      (char *)"Show game info",      (char *)"Make a move", 
        (char *)"Cursor down left",      (char *)"Cursor down",      (char *)"Cursor down right",      (char *)"Cursor left", 
        (char *)"Cursor right",      (char *)"Cursor up left",      (char *)"Cursor up",      (char *)"Cursor up right", 
        (char *)"___last command marker___"};
#line 22 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void writeStrEscaped(FILE *output , char *s ) ;
#line 23
void writeNode(FILE *output , nodep n ) ;
#line 24
void WriteSubTree(FILE *output , nodep root , int sib ) ;
#line 25
int writeCoordList(coordList *list , char *str ) ;
#line 26
int writeTree(char *name , nodep root ) ;
#line 27
int addMark(nodep n , Token t , int x , int y ) ;
#line 28
void addStone(nodep n , Token t , int x , int y ) ;
#line 29
int makeMove(nodep n , Token t , int x , int y ) ;
#line 30
int passMove(nodep n , Token t ) ;
#line 31
void addPlayer(nodep n , Token t ) ;
#line 32
void makeVariation(nodep n ) ;
#line 33
void cutTree(nodep n ) ;
#line 34
boolean pasteTree(nodep n ) ;
#line 35
void edComment(nodep n ) ;
#line 36
void deleteNode(nodep *n ) ;
#line 37
void makeName(nodep n ) ;
#line 38
void replaceComment(nodep n , char *str ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 5 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int first  ;
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
nodep buffer  =    (nodep )0;
#line 9 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void writeStrEscaped(FILE *output , char *s ) 
{ 
  char *tmp ;

  {
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! *s) {
#line 13
      goto while_break;
    }
#line 14
    if ((int )*s == 41) {
      {
#line 15
      fputc('\\', output);
      }
    } else
#line 14
    if ((int )*s == 40) {
      {
#line 15
      fputc('\\', output);
      }
    } else
#line 14
    if ((int )*s == 93) {
      {
#line 15
      fputc('\\', output);
      }
    } else
#line 14
    if ((int )*s == 91) {
      {
#line 15
      fputc('\\', output);
      }
    }
    {
#line 16
    tmp = s;
#line 16
    s ++;
#line 16
    fputc((int )*tmp, output);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return;
}
}
#line 24 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
static char *infoshort[15]  = 
#line 24
  {      (char *)"PB",      (char *)"BR",      (char *)"PW",      (char *)"WR", 
        (char *)"GN",      (char *)"EV",      (char *)"RO",      (char *)"DT", 
        (char *)"PC",      (char *)"TM",      (char *)"RE",      (char *)"GC", 
        (char *)"SO",      (char *)"US",      (char *)"KM"};
#line 29 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
static char *infolong[15]  = 
#line 29
  {      (char *)"PlayerBlack",      (char *)"BlackRank",      (char *)"PlayerWhite",      (char *)"WhiteRank", 
        (char *)"GameName",      (char *)"EVent",      (char *)"ROund",      (char *)"DaTe", 
        (char *)"PlaCe",      (char *)"TiMe",      (char *)"REsult",      (char *)"GameComment", 
        (char *)"SOurce",      (char *)"USer",      (char *)"KoMi"};
#line 36 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
static void writeFirst(FILE *output ) 
{ 
  int p ;

  {
#line 40
  if (saveShort) {
    {
#line 41
    fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"FF[1]GM[1]VW[]SZ[%d]",
            boardsize);
    }
#line 42
    if (handicap) {
      {
#line 43
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"HA[%d]",
              handicap);
      }
    }
  } else {
    {
#line 45
    fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"FileFormat[1]GaMe[1]\nVieW[]\nSiZe[%d]\n",
            boardsize);
    }
#line 46
    if (handicap) {
      {
#line 47
      fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"HAndicap[%d]\n",
              handicap);
      }
    }
  }
#line 50
  p = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (p <= 14)) {
#line 50
      goto while_break;
    }
#line 51
    if (info[p]) {
#line 52
      if (saveShort) {
        {
#line 52
        fputs((char const   */* __restrict  */)infoshort[p], (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 52
        fputs((char const   */* __restrict  */)infolong[p], (FILE */* __restrict  */)output);
        }
      }
      {
#line 53
      fputc('[', output);
#line 54
      writeStrEscaped(output, info[p]);
      }
#line 55
      if (saveShort) {
        {
#line 55
        fputs((char const   */* __restrict  */)"]", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 55
        fputs((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)output);
        }
      }
    }
#line 50
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void writeNode(FILE *output , nodep n ) 
{ 
  property *prop ;
  char str[1445] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 69
  if (saveShort) {
    {
#line 69
    fputs((char const   */* __restrict  */)";", (FILE */* __restrict  */)output);
    }
  } else {
    {
#line 69
    fputs((char const   */* __restrict  */)";\n", (FILE */* __restrict  */)output);
    }
  }
#line 70
  if (first) {
    {
#line 71
    writeFirst(output);
#line 72
    first = 0;
    }
  }
#line 74
  prop = n->p;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! prop) {
#line 75
      goto while_break;
    }
    {
#line 77
    if ((unsigned int )prop->t == 7U) {
#line 77
      goto case_7;
    }
#line 83
    if ((unsigned int )prop->t == 6U) {
#line 83
      goto case_6;
    }
#line 89
    if ((unsigned int )prop->t == 0U) {
#line 89
      goto case_0;
    }
#line 95
    if ((unsigned int )prop->t == 1U) {
#line 95
      goto case_1;
    }
#line 101
    if ((unsigned int )prop->t == 10U) {
#line 101
      goto case_10;
    }
#line 107
    if ((unsigned int )prop->t == 9U) {
#line 107
      goto case_9;
    }
#line 113
    if ((unsigned int )prop->t == 8U) {
#line 113
      goto case_8;
    }
#line 119
    if ((unsigned int )prop->t == 11U) {
#line 119
      goto case_11;
    }
#line 126
    if ((unsigned int )prop->t == 12U) {
#line 126
      goto case_12;
    }
#line 134
    if ((unsigned int )prop->t == 13U) {
#line 134
      goto case_13;
    }
#line 142
    if ((unsigned int )prop->t == 5U) {
#line 142
      goto case_5;
    }
#line 76
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 78
    tmp = writeCoordList(prop->data.stones, str);
    }
#line 78
    if (tmp) {
#line 79
      if (saveShort) {
        {
#line 79
        fputs((char const   */* __restrict  */)"AB", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 79
        fputs((char const   */* __restrict  */)"AddBlack", (FILE */* __restrict  */)output);
        }
      }
      {
#line 80
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 82
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 84
    tmp___0 = writeCoordList(prop->data.stones, str);
    }
#line 84
    if (tmp___0) {
#line 85
      if (saveShort) {
        {
#line 85
        fputs((char const   */* __restrict  */)"AW", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 85
        fputs((char const   */* __restrict  */)"AddWhite", (FILE */* __restrict  */)output);
        }
      }
      {
#line 86
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 88
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 90
    tmp___1 = writeCoordList(prop->data.stones, str);
    }
#line 90
    if (tmp___1) {
#line 91
      if (saveShort) {
        {
#line 91
        fputs((char const   */* __restrict  */)"W", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 91
        fputs((char const   */* __restrict  */)"White", (FILE */* __restrict  */)output);
        }
      }
      {
#line 92
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 94
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 96
    tmp___2 = writeCoordList(prop->data.stones, str);
    }
#line 96
    if (tmp___2) {
#line 97
      if (saveShort) {
        {
#line 97
        fputs((char const   */* __restrict  */)"B", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 97
        fputs((char const   */* __restrict  */)"Black", (FILE */* __restrict  */)output);
        }
      }
      {
#line 98
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 100
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 102
    tmp___3 = writeCoordList(prop->data.stones, str);
    }
#line 102
    if (tmp___3) {
#line 103
      if (saveShort) {
        {
#line 103
        fputs((char const   */* __restrict  */)"AE", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 103
        fputs((char const   */* __restrict  */)"AddEmpty", (FILE */* __restrict  */)output);
        }
      }
      {
#line 104
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 106
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 108
    tmp___4 = writeCoordList(prop->data.stones, str);
    }
#line 108
    if (tmp___4) {
#line 109
      if (saveShort) {
        {
#line 109
        fputs((char const   */* __restrict  */)"M", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 109
        fputs((char const   */* __restrict  */)"Mark", (FILE */* __restrict  */)output);
        }
      }
      {
#line 110
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 112
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 114
    tmp___5 = writeCoordList(prop->data.stones, str);
    }
#line 114
    if (tmp___5) {
#line 115
      if (saveShort) {
        {
#line 115
        fputs((char const   */* __restrict  */)"L", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 115
        fputs((char const   */* __restrict  */)"Letter", (FILE */* __restrict  */)output);
        }
      }
      {
#line 116
      fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)output);
      }
    }
#line 118
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 120
    tmp___6 = (int )strlen(prop->data.comment);
    }
#line 120
    if (tmp___6) {
#line 121
      if (saveShort) {
        {
#line 121
        fputs((char const   */* __restrict  */)"N[", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 121
        fputs((char const   */* __restrict  */)"Name[", (FILE */* __restrict  */)output);
        }
      }
      {
#line 122
      writeStrEscaped(output, prop->data.comment);
      }
#line 123
      if (saveShort) {
        {
#line 123
        fputs((char const   */* __restrict  */)"]", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 123
        fputs((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)output);
        }
      }
    }
#line 125
    goto switch_break;
    case_12: /* CIL Label */ 
#line 127
    if ((unsigned int )prop->data.player == 1U) {
#line 128
      if (saveShort) {
        {
#line 128
        fputs((char const   */* __restrict  */)"B", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 128
        fputs((char const   */* __restrict  */)"Black", (FILE */* __restrict  */)output);
        }
      }
    } else
#line 130
    if (saveShort) {
      {
#line 130
      fputs((char const   */* __restrict  */)"W", (FILE */* __restrict  */)output);
      }
    } else {
      {
#line 130
      fputs((char const   */* __restrict  */)"White", (FILE */* __restrict  */)output);
      }
    }
#line 131
    if (saveShort) {
      {
#line 131
      fputs((char const   */* __restrict  */)"[tt]", (FILE */* __restrict  */)output);
      }
    } else {
      {
#line 131
      fputs((char const   */* __restrict  */)"[tt]\n", (FILE */* __restrict  */)output);
      }
    }
#line 132
    goto switch_break;
    case_13: /* CIL Label */ 
#line 135
    if (saveShort) {
      {
#line 135
      fputs((char const   */* __restrict  */)"PL[", (FILE */* __restrict  */)output);
      }
    } else {
      {
#line 135
      fputs((char const   */* __restrict  */)"PLayer[", (FILE */* __restrict  */)output);
      }
    }
#line 136
    if ((unsigned int )prop->data.player == 1U) {
      {
#line 137
      fputc('B', output);
      }
    } else {
      {
#line 139
      fputc('W', output);
      }
    }
#line 140
    if (saveShort) {
      {
#line 140
      fputs((char const   */* __restrict  */)"]", (FILE */* __restrict  */)output);
      }
    } else {
      {
#line 140
      fputs((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)output);
      }
    }
#line 141
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 143
    tmp___7 = (int )strlen(prop->data.comment);
    }
#line 143
    if (tmp___7) {
#line 144
      if (saveShort) {
        {
#line 144
        fputs((char const   */* __restrict  */)"C[", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 144
        fputs((char const   */* __restrict  */)"Comment[", (FILE */* __restrict  */)output);
        }
      }
      {
#line 145
      writeStrEscaped(output, prop->data.comment);
      }
#line 146
      if (saveShort) {
        {
#line 146
        fputs((char const   */* __restrict  */)"]", (FILE */* __restrict  */)output);
        }
      } else {
        {
#line 146
        fputs((char const   */* __restrict  */)"]\n", (FILE */* __restrict  */)output);
        }
      }
    }
#line 148
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 150
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void WriteSubTree(FILE *output , nodep root , int sib ) 
{ 


  {
#line 161
  if (saveShort) {
    {
#line 161
    fputs((char const   */* __restrict  */)"(", (FILE */* __restrict  */)output);
    }
  } else {
    {
#line 161
    fputs((char const   */* __restrict  */)"(\n", (FILE */* __restrict  */)output);
    }
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (sib) {
#line 163
      if (root->nextSibling) {
        {
#line 164
        WriteSubTree(output, root, 0);
        }
        {
#line 165
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 165
          if (! root->nextSibling) {
#line 165
            goto while_break___0;
          }
          {
#line 166
          root = root->nextSibling;
#line 167
          WriteSubTree(output, root, 0);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 169
        root = (nodep )((void *)0);
      } else {
        {
#line 171
        writeNode(output, root);
#line 172
        root = root->child;
#line 173
        sib = 1;
        }
      }
    } else {
      {
#line 171
      writeNode(output, root);
#line 172
      root = root->child;
#line 173
      sib = 1;
      }
    }
#line 162
    if (! root) {
#line 162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (saveShort) {
    {
#line 177
    fputs((char const   */* __restrict  */)")", (FILE */* __restrict  */)output);
    }
  } else {
    {
#line 177
    fputs((char const   */* __restrict  */)")\n", (FILE */* __restrict  */)output);
    }
  }
#line 178
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int writeCoordList(coordList *list , char *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 186
  *str = (char)0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! list) {
#line 187
      goto while_break;
    }
    {
#line 188
    tmp = (int )strlen(str);
#line 188
    sprintf((char */* __restrict  */)(str + tmp), (char const   */* __restrict  */)"[%c%c]",
            (int )list->x + 97, (int )list->y + 97);
#line 189
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  tmp___0 = (int )strlen(str);
  }
#line 191
  if (! tmp___0) {
#line 192
    return (0);
  }
#line 193
  if (! saveShort) {
    {
#line 194
    strcat(str, "\n");
    }
  }
#line 195
  return (1);
}
}
#line 200 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int writeTree(char *name , nodep root ) 
{ 
  FILE *output ;

  {
  {
#line 206
  output = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"w");
  }
#line 206
  if (output) {
    {
#line 207
    first = 1;
#line 208
    WriteSubTree(output, root, 1);
#line 209
    fclose(output);
    }
#line 210
    return (0);
  } else {
    {
#line 212
    (*(io->notifyError))("Error saving file.");
    }
#line 213
    return (1);
  }
}
}
#line 219 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
static void clearSpace(property *prop , int x , int y ) 
{ 


  {
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! prop) {
#line 223
      goto while_break;
    }
    {
#line 231
    if ((unsigned int )prop->t == 8U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 9U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 0U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 1U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 6U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 7U) {
#line 231
      goto case_8;
    }
#line 231
    if ((unsigned int )prop->t == 10U) {
#line 231
      goto case_8;
    }
#line 224
    goto switch_break;
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 232
    clearCoord(x, y, & prop->data.stones);
    }
#line 233
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 235
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return;
}
}
#line 240 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int addMark(nodep n , Token t , int x , int y ) 
{ 
  property *prop ;
  boolean tmp ;
  int tmp___0 ;

  {
  {
#line 247
  prop = getprop(n, (unsigned int )t);
  }
#line 247
  if (prop) {
    {
#line 248
    tmp = getCoord(x, y, prop->data.stones);
    }
#line 248
    if (tmp) {
      {
#line 249
      clearCoord(x, y, & prop->data.stones);
      }
#line 250
      return (1);
    }
  } else {
    {
#line 253
    tmp___0 = malloc(sizeof(property ));
#line 253
    prop = (property *)tmp___0;
    }
#line 254
    if (! prop) {
      {
#line 255
      barf("Memory allocation failure (markStone)");
      }
    }
#line 256
    prop->next = n->p;
#line 257
    n->p = prop;
#line 258
    prop->data.stones = (coordList *)0;
#line 259
    prop->t = t;
  }
  {
#line 262
  setCoord(x, y, & prop->data.stones);
  }
#line 263
  return (0);
}
}
#line 269 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void addStone(nodep n , Token t , int x , int y ) 
{ 
  property *prop ;
  int tmp ;

  {
  {
#line 276
  clearSpace(n->p, x, y);
#line 277
  prop = getprop(n, (unsigned int )t);
  }
#line 277
  if (! prop) {
    {
#line 278
    tmp = calloc(1, sizeof(property ));
#line 278
    prop = (property *)tmp;
    }
#line 279
    if (! prop) {
      {
#line 280
      barf("Memory allocation failure (addStone)");
      }
    }
#line 281
    prop->next = n->p;
#line 282
    n->p = prop;
#line 283
    prop->data.stones = (coordList *)0;
#line 284
    prop->t = t;
  }
  {
#line 286
  setCoord(x, y, & prop->data.stones);
  }
#line 288
  return;
}
}
#line 290 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int makeMove(nodep n , Token t , int x , int y ) 
{ 
  nodep new ;
  property *prop ;
  int ret ;
  int tmp ;

  {
#line 298
  ret = 0;
#line 300
  if (! n->p) {
#line 301
    new = n;
#line 302
    ret = 1;
  } else {
    {
#line 305
    new = newNode();
    }
#line 306
    if (n->child) {
#line 307
      (n->child)->parent = new;
    }
#line 308
    new->parent = n;
#line 309
    new->child = n->child;
#line 310
    n->child = new;
  }
  {
#line 314
  tmp = calloc(1, sizeof(property ));
#line 314
  prop = (property *)tmp;
  }
#line 315
  if (! prop) {
    {
#line 316
    barf("Memory allocation failure (makeMove)");
    }
  }
  {
#line 317
  new->p = prop;
#line 318
  prop->data.stones = (coordList *)0;
#line 319
  prop->t = t;
#line 321
  setCoord(x, y, & prop->data.stones);
  }
#line 322
  return (ret);
}
}
#line 326 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
int passMove(nodep n , Token t ) 
{ 
  nodep new ;
  property *prop ;
  int ret ;
  int tmp ;

  {
#line 333
  ret = 0;
#line 335
  if (! n->p) {
#line 336
    new = n;
#line 337
    ret = 1;
  } else {
    {
#line 340
    new = newNode();
    }
#line 341
    if (n->child) {
#line 342
      (n->child)->parent = new;
    }
#line 343
    new->parent = n;
#line 344
    new->child = n->child;
#line 345
    n->child = new;
  }
  {
#line 349
  tmp = calloc(1, sizeof(property ));
#line 349
  prop = (property *)tmp;
  }
#line 350
  if (! prop) {
    {
#line 351
    barf("Memory allocation failure (passMove)");
    }
  }
#line 352
  new->p = prop;
#line 353
  prop->data.player = t;
#line 354
  prop->t = (Token )12;
#line 356
  return (ret);
}
}
#line 361 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void addPlayer(nodep n , Token t ) 
{ 
  property *prop ;
  int tmp ;

  {
  {
#line 366
  prop = getprop(n, 13);
  }
#line 366
  if (! prop) {
    {
#line 367
    tmp = calloc(1, sizeof(property ));
#line 367
    prop = (property *)tmp;
    }
#line 368
    if (! prop) {
      {
#line 369
      barf("Memory allocation failure (addPlayer)");
      }
    }
    {
#line 370
    addprop(n, prop);
    }
  }
#line 372
  prop->data.player = t;
#line 373
  prop->t = (Token )13;
#line 374
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void makeVariation(nodep n ) 
{ 
  nodep new ;
  nodep last ;

  {
#line 382
  if (! n->child) {
    {
#line 383
    new = newNode();
#line 384
    new->parent = n;
#line 385
    n->child = new;
    }
  } else {
    {
#line 387
    new = newNode();
#line 388
    new->parent = n;
#line 389
    last = treeLastSibling(n->child);
#line 390
    last->nextSibling = new;
#line 391
    new->lastSibling = last;
    }
  }
#line 393
  return;
}
}
#line 396 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void cutTree(nodep n ) 
{ 


  {
  {
#line 399
  freeNode(buffer);
  }
#line 400
  if (n->nextSibling) {
#line 401
    (n->nextSibling)->lastSibling = n->lastSibling;
  }
#line 402
  if (n->lastSibling) {
#line 403
    (n->lastSibling)->nextSibling = n->nextSibling;
  } else
#line 404
  if (n->parent) {
#line 405
    (n->parent)->child = n->nextSibling;
  }
#line 406
  n->nextSibling = (struct noderec *)0;
#line 407
  n->lastSibling = (struct noderec *)0;
#line 408
  buffer = n;
#line 409
  return;
}
}
#line 412 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
boolean pasteTree(nodep n ) 
{ 
  nodep last ;
  nodep sib ;

  {
#line 416
  if (buffer) {
#line 417
    last = buffer;
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (! last->child) {
#line 417
        goto while_break;
      }
#line 417
      last = last->child;
    }
    while_break: /* CIL Label */ ;
    }
#line 418
    if (n->child) {
#line 419
      (n->child)->parent = last;
#line 420
      sib = (n->child)->nextSibling;
      {
#line 420
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 420
        if (! sib) {
#line 420
          goto while_break___0;
        }
#line 421
        sib->parent = last;
#line 420
        sib = sib->nextSibling;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 422
      last->child = n->child;
    }
#line 424
    n->child = buffer;
#line 425
    buffer->parent = n;
#line 426
    buffer = (nodep )0;
#line 427
    return (1);
  }
#line 429
  return (0);
}
}
#line 433 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void edComment(nodep n ) 
{ 
  property *prop ;
  int tmp ;

  {
  {
#line 438
  prop = getprop(n, 5);
  }
#line 438
  if (! prop) {
    {
#line 439
    tmp = calloc(1, sizeof(property ));
#line 439
    prop = (property *)tmp;
#line 440
    prop->t = (Token )5;
#line 441
    prop->next = n->p;
#line 442
    n->p = prop;
    }
  }
  {
#line 444
  (*(io->editComment))(prop->data.comment, & prop->data.comment);
  }
#line 445
  if (! prop->data.comment) {
    {
#line 446
    n->p = prop->next;
#line 447
    free(prop);
    }
  }
#line 449
  return;
}
}
#line 453 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void deleteNode(nodep *n ) 
{ 
  nodep last ;

  {
#line 457
  if (! (*n)->child) {
    {
#line 458
    freeProps(*n);
#line 459
    (*n)->p = (property *)0;
    }
  } else {
#line 461
    if ((*n)->parent) {
#line 461
      if ((unsigned long )((*n)->parent)->child == (unsigned long )*n) {
#line 462
        ((*n)->parent)->child = (*n)->child;
      }
    }
#line 463
    if ((*n)->lastSibling) {
#line 464
      ((*n)->child)->lastSibling = (*n)->lastSibling;
#line 465
      ((*n)->lastSibling)->nextSibling = (*n)->child;
    }
#line 469
    last = (*n)->child;
    {
#line 469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 469
      if (! last->nextSibling) {
#line 469
        goto while_break;
      }
#line 470
      last->parent = (*n)->parent;
#line 469
      last = last->nextSibling;
    }
    while_break: /* CIL Label */ ;
    }
#line 471
    last->parent = (*n)->parent;
#line 474
    last->nextSibling = (*n)->nextSibling;
#line 476
    if ((*n)->nextSibling) {
#line 477
      (*n)->nextSibling = last;
    }
    {
#line 478
    last = *n;
#line 479
    *n = (*n)->child;
#line 480
    delNode(last);
    }
  }
#line 482
  return;
}
}
#line 485 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void makeName(nodep n ) 
{ 
  char newname[41] ;
  property *prop ;
  int tmp ;

  {
  {
#line 491
  (*(io->queryStr))("Name: ", newname, 40);
#line 493
  prop = getprop(n, 11);
  }
#line 493
  if (prop) {
    {
#line 494
    free(prop->data.comment);
    }
  } else {
    {
#line 496
    tmp = calloc(1, sizeof(property ));
#line 496
    prop = (property *)tmp;
#line 497
    addprop(n, prop);
#line 498
    prop->t = (Token )11;
    }
  }
  {
#line 500
  prop->data.comment = dupStr(newname);
  }
#line 501
  return;
}
}
#line 504 "/home/wheatley/newnew/temp/mgt-2.31/edit.c"
void replaceComment(nodep n , char *str ) 
{ 
  property *prop ;
  int tmp ;

  {
  {
#line 510
  prop = getprop(n, 5);
  }
#line 510
  if (prop) {
    {
#line 516
    free(prop->data.comment);
    }
  } else {
    {
#line 511
    tmp = calloc(1, sizeof(property ));
#line 511
    prop = (property *)tmp;
#line 512
    prop->t = (Token )5;
#line 513
    prop->next = n->p;
#line 514
    n->p = prop;
    }
  }
  {
#line 517
  prop->data.comment = dupStr(str);
  }
#line 518
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 2 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void highlightLast(void) ;
#line 73 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static boolean commentExists  ;
#line 74 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int commentLine  ;
#line 75 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int treeLine  ;
#line 76 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int inverseFlag  =    0;
#line 77
static char boardPiece(int x , int y ) ;
#line 78
static int getLine(char *query , char *dst , int maxLen ) ;
#line 79
static void drawPiece(int i , int j , char c ) ;
#line 80
static void printstatus(char *mesg ) ;
#line 81
static void setCursor(int x , int y ) ;
#line 83 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char keys[50]  = 
#line 83
  {      (char )'q',      (char )'>',      (char )'<',      (char )'.', 
        (char )',',      (char )'e',      (char )'b',      (char )'}', 
        (char )'{',      (char )']',      (char )'[',      (char )'g', 
        (char )'w',      (char )'z',      (char )'x',      (char )'v', 
        (char )'!',      (char )'l',      (char )'m',      (char )'#', 
        (char )'^',      (char )'c',      (char )'d',      (char )'n', 
        (char )'s',      (char )'p',      (char )'o',      (char )'t', 
        (char )'r',      (char )'f',      (char )'L',      (char )'W', 
        (char )'T',      (char )'F',      (char )'I',      (char )'0', 
        (char )'1',      (char )'2',      (char )'3',      (char )'4', 
        (char )'6',      (char )'7',      (char )'8',      (char )'9', 
        (char )'k',      (char )'i',      (char )'j',      (char )'u', 
        (char )'&',      (char )'\000'};
#line 84 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char edcmds[16]  = 
#line 84
  {      (char )'P',      (char )'N',      (char )'p',      (char )'n', 
        (char )'B',      (char )'F',      (char )'A',      (char )'E', 
        (char )'<',      (char )'>',      (char )'D',      (char )'K', 
        (char )'I',      (char )'z',      (char )'W',      (char )'\000'};
#line 85 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char emacscmds[16]  = 
#line 85
  {      (char )'P',      (char )'N',      (char )'p',      (char )'n', 
        (char )'B',      (char )'F',      (char )'A',      (char )'E', 
        (char )'<',      (char )'>',      (char )'D',      (char )'K', 
        (char )'I',      (char )'z',      (char )'W',      (char )'\000'};
#line 86 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char vicmds[16]  = 
#line 86
  {      (char )'k',      (char )'j',      (char )'\002',      (char )'\006', 
        (char )'h',      (char )'l',      (char )'0',      (char )'$', 
        (char )'H',      (char )'L',      (char )'x',      (char )'D', 
        (char )'R',      (char )'w',      (char )'q',      (char )'\000'};
#line 88 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
int edvi  =    0;
#line 90 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char xAxisChars[26]  = 
#line 90
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'J',      (char )'K',      (char )'L',      (char )'M', 
        (char )'N',      (char )'O',      (char )'P',      (char )'Q', 
        (char )'R',      (char )'S',      (char )'T',      (char )'U', 
        (char )'V',      (char )'W',      (char )'X',      (char )'Y', 
        (char )'Z',      (char )'\000'};
#line 91 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char helpMsg[11]  = 
#line 91
  {      (char )'?',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )'\000'};
#line 93 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void fixedkeys(void) 
{ 
  char *ptr ;

  {
#line 96
  if (! edvi) {
#line 97
    ptr = edcmds;
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;
#line 97
      if (! *ptr) {
#line 97
        goto while_break;
      }
#line 98
      if ((int )*ptr >= 65) {
#line 98
        if ((int )*ptr <= 90) {
#line 99
          *ptr = (char )((int )*ptr - 64);
        } else {
#line 101
          *ptr = (char )((int )*ptr | 128);
        }
      } else {
#line 101
        *ptr = (char )((int )*ptr | 128);
      }
#line 97
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 102
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char *dispedkey(char key , char *keystr ) 
{ 


  {
#line 109
  if ((int )key & 128) {
#line 110
    *(keystr + 0) = (char )']';
#line 111
    *(keystr + 1) = (char )((int )key & 127);
#line 112
    *(keystr + 2) = (char)0;
  } else
#line 113
  if ((int )key < 32) {
#line 114
    *(keystr + 0) = (char )'^';
#line 115
    *(keystr + 1) = (char )((int )key + 64);
#line 116
    *(keystr + 2) = (char)0;
  } else {
#line 118
    *(keystr + 0) = key;
#line 119
    *(keystr + 1) = (char)0;
  }
#line 121
  return (keystr);
}
}
#line 125 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void fixkeys(void) 
{ 
  char *keyptr ;

  {
#line 128
  keyptr = keys;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! *keyptr) {
#line 128
      goto while_break;
    }
#line 129
    if ((int )*keyptr >= 65) {
#line 129
      if ((int )*keyptr <= 90) {
#line 130
        *keyptr = (char )((int )*keyptr - 64);
      }
    }
#line 128
    keyptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 590
extern int clearok(WINDOW * , _Bool  ) ;
#line 603
extern int delwin(WINDOW * ) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 717
extern int overwrite(WINDOW const   * , WINDOW * ) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 766
extern WINDOW *subwin(WINDOW * , int  , int  , int  , int  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1386
extern WINDOW *stdscr ;
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
char chars[14]  = 
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
  {      (char )'#',      (char )'O',      (char )'=',      (char )'+', 
        (char )'-',      (char )'.',      (char )'+',      (char )'|', 
        (char )'-',      (char )'+',      (char )'+',      (char )'+', 
        (char )'+',      (char )'\000'};
#line 35 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static char getKeyEdit(void) 
{ 
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  tmp = wgetch(stdscr);
#line 38
  c = (char )tmp;
  }
#line 39
  if (! edvi) {
#line 39
    if ((int )c == 27) {
      {
#line 40
      tmp___0 = wgetch(stdscr);
#line 40
      c = (char )(128 | tmp___0);
      }
    }
  }
#line 42
  if ((int )c == -37) {
    {
#line 43
    tmp___1 = wgetch(stdscr);
#line 43
    c = (char )tmp___1;
    }
#line 44
    if ((int )c == 65) {
#line 45
      c = edcmds[0];
    }
#line 46
    if ((int )c == 66) {
#line 47
      c = edcmds[1];
    }
#line 48
    if ((int )c == 67) {
#line 49
      c = edcmds[5];
    }
#line 50
    if ((int )c == 68) {
#line 51
      c = edcmds[4];
    }
  }
#line 53
  return (c);
}
}
#line 58
int ispl ;
#line 56 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void drawPrisoners(void) 
{ 
  char a ;
  char b ;
  char c ;
  char d ;

  {
#line 60
  if ((unsigned int )curPlayer == 1U) {
#line 61
    if (ispl) {
#line 61
      a = (char )'}';
    } else {
#line 61
      a = (char )'>';
    }
#line 62
    if (ispl) {
#line 62
      b = (char )'{';
    } else {
#line 62
      b = (char )'<';
    }
#line 63
    d = (char )' ';
#line 63
    c = d;
  } else {
#line 65
    b = (char )' ';
#line 65
    a = b;
#line 66
    if (ispl) {
#line 66
      c = (char )'}';
    } else {
#line 66
      c = (char )'>';
    }
#line 67
    if (ispl) {
#line 67
      d = (char )'{';
    } else {
#line 67
      d = (char )'<';
    }
  }
  {
#line 69
  wmove(stdscr, 23, 50);
#line 70
  printw("%c %c: %d %c    %c %c: %d %c ", (int )a, (int )chars[0], prisoners[0], (int )b,
         (int )c, (int )chars[1], prisoners[1], (int )d);
#line 73
  wclrtoeol(stdscr);
  }
#line 74
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void initAscii(void) 
{ 


  {
  {
#line 80
  fixkeys();
#line 81
  fixedkeys();
#line 82
  initscr();
#line 83
  noecho();
#line 84
  cbreak();
  }
#line 85
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void plotMarkAscii(pBoard b , int i , int j ) 
{ 
  piece p ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 95
  p = boardGet(b, i, j);
#line 96
  inverseFlag = ! inverseFlag;
  }
#line 98
  if ((unsigned int )p == 0U) {
    {
#line 98
    tmp = boardPiece(i, j);
#line 98
    tmp___1 = (int )tmp;
    }
  } else {
#line 98
    if ((unsigned int )p == 1U) {
#line 98
      tmp___0 = (int )chars[0];
    } else {
#line 98
      tmp___0 = (int )chars[1];
    }
#line 98
    tmp___1 = tmp___0;
  }
  {
#line 98
  drawPiece(i, j, tmp___1);
#line 101
  inverseFlag = ! inverseFlag;
  }
#line 102
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static int xpos(WINDOW *win ) 
{ 
  int x ;
  int y ;

  {
#line 108
  if (win) {
#line 108
    y = (int )win->_cury;
  } else {
#line 108
    y = -1;
  }
#line 108
  if (win) {
#line 108
    x = (int )win->_curx;
  } else {
#line 108
    x = -1;
  }
#line 109
  return (x);
}
}
#line 113 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static int ypos(WINDOW *win ) 
{ 
  int y ;
  int x ;

  {
#line 117
  if (win) {
#line 117
    y = (int )win->_cury;
  } else {
#line 117
    y = -1;
  }
#line 117
  if (win) {
#line 117
    x = (int )win->_curx;
  } else {
#line 117
    x = -1;
  }
#line 118
  return (y);
}
}
#line 122 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static command specialKeysIdle(char c ) 
{ 


  {
#line 125
  return ((command )0);
}
}
#line 128 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void set_inverse(void) 
{ 


  {
#line 131
  if (inverseFlag) {
#line 132
    if (stdscr) {
#line 132
      stdscr->_attrs = 1UL << 16;
    }
  }
#line 133
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void unset_inverse(void) 
{ 


  {
#line 137
  if (stdscr) {
#line 137
    stdscr->_attrs = 0UL;
  }
#line 138
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void drawPiece(int i , int j , char c ) 
{ 


  {
  {
#line 146
  wmove(stdscr, 2 + j, 4 + 2 * i);
#line 147
  set_inverse();
#line 148
  waddch(stdscr, (chtype const   )c);
#line 149
  unset_inverse();
  }
#line 150
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/mgt-2.31/asc_unix.inc"
static void initBoardAscii(void) 
{ 
  int i ;
  int j ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 157
  wclear(stdscr);
  }
#line 158
  if (inverseFlag) {
    {
#line 159
    set_inverse();
#line 160
    i = 5;
    }
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (i < (4 + boardsize * 2) - 2)) {
#line 160
        goto while_break;
      }
#line 161
      j = 2;
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 161
        if (! (j < 2 + boardsize)) {
#line 161
          goto while_break___0;
        }
        {
#line 162
        tmp = wmove(stdscr, j, i);
        }
#line 162
        if (! (tmp == -1)) {
          {
#line 162
          waddch(stdscr, (chtype const   )' ');
          }
        }
#line 161
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 160
      i += 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 163
    unset_inverse();
    }
  }
#line 165
  i = boardsize;
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 165
    tmp___2 = i;
#line 165
    i --;
#line 165
    if (! tmp___2) {
#line 165
      goto while_break___1;
    }
    {
#line 167
    wmove(stdscr, 2 + i, 1);
#line 168
    printw("%2d", boardsize - i);
#line 169
    set_inverse();
#line 170
    waddch(stdscr, (chtype const   )chars[7]);
#line 173
    wmove(stdscr, 2 + i, (4 + boardsize * 2) - 1);
#line 174
    waddch(stdscr, (chtype const   )chars[7]);
#line 175
    unset_inverse();
#line 176
    printw("%2d", boardsize - i);
#line 180
    wmove(stdscr, 0, 4 + i * 2);
#line 181
    waddch(stdscr, (chtype const   )xAxisChars[i]);
#line 182
    wmove(stdscr, 1, (4 + i * 2) - 1);
#line 183
    set_inverse();
#line 184
    printw("%c%c", (int )chars[8], (int )chars[8]);
#line 187
    wmove(stdscr, 2 + boardsize, (4 + i * 2) - 1);
#line 188
    printw("%c%c", (int )chars[8], (int )chars[8]);
#line 189
    unset_inverse();
#line 190
    wmove(stdscr, (2 + boardsize) + 1, 4 + i * 2);
#line 191
    waddch(stdscr, (chtype const   )xAxisChars[i]);
#line 192
    j = boardsize;
    }
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      tmp___1 = j;
#line 192
      j --;
#line 192
      if (! tmp___1) {
#line 192
        goto while_break___2;
      }
      {
#line 193
      tmp___0 = boardPiece(i, j);
#line 193
      drawPiece(i, j, tmp___0);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 195
  set_inverse();
#line 196
  wmove(stdscr, 1, 3);
#line 197
  waddch(stdscr, (chtype const   )chars[9]);
#line 198
  wmove(stdscr, 1, (4 + boardsize * 2) - 1);
#line 199
  waddch(stdscr, (chtype const   )chars[10]);
#line 200
  wmove(stdscr, 2 + boardsize, 3);
#line 201
  waddch(stdscr, (chtype const   )chars[11]);
#line 202
  wmove(stdscr, 2 + boardsize, (4 + boardsize * 2) - 1);
#line 203
  waddch(stdscr, (chtype const   )chars[12]);
#line 204
  unset_inverse();
#line 205
  tmp___3 = wmove(stdscr, 21, 46);
  }
#line 205
  if (! (tmp___3 == -1)) {
    {
#line 205
    waddnstr(stdscr, (char const   *)(helpMsg), -1);
    }
  }
  {
#line 206
  printstatus(name_buf);
  }
#line 207
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void notifyClearAscii(void) 
{ 


  {
  {
#line 145
  wmove(stdscr, 23, 1);
#line 146
  wclrtoeol(stdscr);
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void notifyMessageAscii(char *s ) 
{ 
  int tmp ;

  {
  {
#line 152
  tmp = wmove(stdscr, 23, 1);
  }
#line 152
  if (! (tmp == -1)) {
    {
#line 152
    waddnstr(stdscr, (char const   *)s, -1);
    }
  }
  {
#line 153
  wrefresh(stdscr);
  }
#line 154
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void notifyErrorAscii(char *s ) 
{ 
  int tmp ;

  {
  {
#line 159
  tmp = wmove(stdscr, 23, 1);
  }
#line 159
  if (! (tmp == -1)) {
    {
#line 159
    waddnstr(stdscr, (char const   *)s, -1);
    }
  }
  {
#line 160
  printw("  Hit a key.");
#line 161
  wrefresh(stdscr);
#line 162
  wgetch(stdscr);
#line 163
  notifyClearAscii();
  }
#line 164
  return;
}
}
#line 166 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void clearScreenAscii(void) 
{ 


  {
  {
#line 168
  wclear(stdscr);
  }
#line 169
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void printstatus(char *mesg ) 
{ 
  int i ;

  {
  {
#line 176
  wmove(stdscr, 0, 45);
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (i < 34) {
#line 177
      if (! *(mesg + i)) {
#line 177
        goto while_break;
      }
    } else {
#line 177
      goto while_break;
    }
    {
#line 178
    waddch(stdscr, (chtype const   )*(mesg + i));
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int getLine(char *query , char *dst , int maxLen ) 
{ 
  int qLen ;
  int dLen ;
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 188
  tmp = wmove(stdscr, 23, 1);
  }
#line 188
  if (! (tmp == -1)) {
    {
#line 188
    waddnstr(stdscr, (char const   *)query, -1);
    }
  }
  {
#line 189
  wclrtoeol(stdscr);
#line 190
  dLen = 0;
#line 191
  qLen = (int )strlen(query);
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    wmove(stdscr, 23, (qLen + 1) + dLen);
#line 194
    wrefresh(stdscr);
#line 195
    tmp___0 = wgetch(stdscr);
#line 195
    c = (char )tmp___0;
#line 196
    tmp___2 = __ctype_b_loc();
    }
#line 196
    if ((int const   )*(*tmp___2 + (int )c) & 16384) {
#line 196
      if (dLen < maxLen) {
        {
#line 197
        wmove(stdscr, 23, (qLen + dLen) + 1);
#line 198
        wrefresh(stdscr);
#line 199
        waddch(stdscr, (chtype const   )c);
#line 200
        tmp___1 = dLen;
#line 200
        dLen ++;
#line 200
        *(dst + tmp___1) = c;
        }
      } else {
#line 196
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 201
    if (dLen) {
#line 201
      if ((int )c == 8) {
        {
#line 202
        dLen --;
#line 203
        wmove(stdscr, 23, (qLen + dLen) + 1);
#line 204
        waddch(stdscr, (chtype const   )' ');
        }
      } else
#line 201
      if ((int )c == 127) {
        {
#line 202
        dLen --;
#line 203
        wmove(stdscr, 23, (qLen + dLen) + 1);
#line 204
        waddch(stdscr, (chtype const   )' ');
        }
      }
    }
#line 192
    if ((int )c != 10) {
#line 192
      if (! ((int )c != 13)) {
#line 192
        goto while_break;
      }
    } else {
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  *(dst + dLen) = (char)0;
#line 209
  wmove(stdscr, 23, 1);
#line 210
  wclrtoeol(stdscr);
  }
#line 211
  return (dLen);
}
}
#line 219
static int askYNAscii(char *query , int def ) ;
#line 219 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char *yn[2]  = {      (char *)" (y/N)? ",      (char *)" (Y/n)? "};
#line 215 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int askYNAscii(char *query , int def ) 
{ 
  char line[80] ;
  char buf___0[3] ;
  int tmp ;

  {
  {
#line 224
  strcpy(line, query);
#line 225
  strcat(line, yn[def]);
#line 226
  tmp = getLine(line, buf___0, 2);
  }
#line 226
  if (tmp) {
#line 227
    if ((int )buf___0[0] == 89) {
#line 228
      return (1);
    } else
#line 227
    if ((int )buf___0[0] == 121) {
#line 228
      return (1);
    }
#line 229
    if ((int )buf___0[0] == 78) {
#line 230
      return (0);
    } else
#line 229
    if ((int )buf___0[0] == 110) {
#line 230
      return (0);
    }
  }
#line 232
  return (def);
}
}
#line 236 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void setCursor(int x , int y ) 
{ 


  {
  {
#line 239
  wmove(stdscr, 2 + y, 4 + 2 * x);
  }
#line 240
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void printNStr(char *s , int n ) 
{ 
  int i ;

  {
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (i < n) {
#line 248
      if (! *(s + i)) {
#line 248
        goto while_break;
      }
    } else {
#line 248
      goto while_break;
    }
    {
#line 249
    waddch(stdscr, (chtype const   )*(s + i));
#line 248
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void drawTreeAscii0(nodep n ) 
{ 
  property *p ;
  int num ;
  int width ;
  int temp ;
  int tmp ;
  nodep ch ;
  int index ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 258
  wmove(stdscr, 15, 47);
#line 259
  printw(" Node #%d: ", n->nodeNum);
#line 260
  p = getprop(n, 11);
  }
#line 260
  if (p) {
#line 263
    width = 23;
#line 264
    num = n->nodeNum;
    {
#line 265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 266
      num /= 10;
#line 267
      width --;
#line 265
      if (! num) {
#line 265
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 269
    printNStr(p->data.comment, width);
    }
  }
  {
#line 271
  wclrtoeol(stdscr);
  }
#line 274
  if (treeLine < 0) {
#line 275
    treeLine = 0;
  } else {
    {
#line 277
    tmp = treeCountSiblings(n);
#line 277
    temp = (tmp - 6) + 1;
    }
#line 278
    if (temp > 0) {
#line 278
      temp = temp;
    } else {
#line 278
      temp = 0;
    }
#line 279
    if (treeLine > temp) {
#line 279
      treeLine = temp;
    } else {
#line 279
      treeLine = treeLine;
    }
  }
  {
#line 285
  index = 0;
#line 286
  ch = nthChild(n, treeLine);
  }
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (ch) {
#line 287
      if (! (index < 5)) {
#line 287
        goto while_break___0;
      }
    } else {
#line 287
      goto while_break___0;
    }
    {
#line 288
    wmove(stdscr, (index + 15) + 1, 46);
#line 289
    printw("%c:", (65 + index) + treeLine);
#line 290
    wclrtoeol(stdscr);
#line 291
    p = getprop(ch, 11);
    }
#line 291
    if (p) {
      {
#line 292
      printNStr(p->data.comment, 31);
      }
    }
#line 293
    ch = ch->nextSibling;
#line 294
    index ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 296
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 296
    if (! (index < 5)) {
#line 296
      goto while_break___1;
    }
    {
#line 297
    tmp___0 = index;
#line 297
    index ++;
#line 297
    wmove(stdscr, (tmp___0 + 15) + 1, 46);
#line 298
    wclrtoeol(stdscr);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 300
  wmove(stdscr, 20, 45);
  }
#line 301
  if (ch) {
#line 301
    tmp___1 = '+';
  } else {
#line 301
    tmp___1 = ' ';
  }
  {
#line 301
  waddch(stdscr, (chtype const   )tmp___1);
#line 302
  wmove(stdscr, 16, 45);
  }
#line 303
  if (treeLine) {
#line 303
    tmp___2 = '-';
  } else {
#line 303
    tmp___2 = ' ';
  }
  {
#line 303
  waddch(stdscr, (chtype const   )tmp___2);
#line 305
  wrefresh(stdscr);
  }
#line 306
  return;
}
}
#line 310 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void drawTreeAscii(nodep n ) 
{ 


  {
  {
#line 313
  treeLine = 0;
#line 314
  drawTreeAscii0(n);
  }
#line 315
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void closeAscii(void) 
{ 


  {
  {
#line 320
  endwin();
  }
#line 321
  return;
}
}
#line 324 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void refreshAscii(void) 
{ 


  {
  {
#line 326
  wrefresh(stdscr);
  }
#line 327
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char boardPiece(int x , int y ) 
{ 
  int tmp ;

  {
#line 332
  if (boardsize == 19) {
#line 332
    if (x == 9) {
#line 332
      goto _L___2;
    } else {
#line 332
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 332
  if (boardsize >= 10) {
#line 332
    if (x == 3) {
#line 332
      goto _L___2;
    } else
#line 332
    if (x == boardsize - 4) {
#line 332
      goto _L___2;
    } else {
#line 332
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 332
  if (boardsize > 6) {
#line 332
    if (boardsize < 10) {
#line 332
      if (x == 2) {
#line 332
        goto _L___2;
      } else
#line 332
      if (x == boardsize - 3) {
        _L___2: /* CIL Label */ 
#line 332
        if (boardsize == 19) {
#line 332
          if (y == 9) {
#line 332
            tmp = (int )chars[6];
          } else {
#line 332
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 332
        if (boardsize >= 10) {
#line 332
          if (y == 3) {
#line 332
            tmp = (int )chars[6];
          } else
#line 332
          if (y == boardsize - 4) {
#line 332
            tmp = (int )chars[6];
          } else {
#line 332
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 332
        if (boardsize > 6) {
#line 332
          if (boardsize < 10) {
#line 332
            if (y == 2) {
#line 332
              tmp = (int )chars[6];
            } else
#line 332
            if (y == boardsize - 3) {
#line 332
              tmp = (int )chars[6];
            } else {
#line 332
              tmp = (int )chars[5];
            }
          } else {
#line 332
            tmp = (int )chars[5];
          }
        } else {
#line 332
          tmp = (int )chars[5];
        }
      } else {
#line 332
        tmp = (int )chars[5];
      }
    } else {
#line 332
      tmp = (int )chars[5];
    }
  } else {
#line 332
    tmp = (int )chars[5];
  }
#line 332
  return ((char )tmp);
}
}
#line 346 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void plotPieceAscii(pBoard b , int i , int j ) 
{ 
  piece p ;
  char c ;

  {
  {
#line 352
  p = boardGet(b, i, j);
  }
  {
#line 354
  if ((unsigned int )p == 0U) {
#line 354
    goto case_0;
  }
#line 357
  if ((unsigned int )p == 1U) {
#line 357
    goto case_1;
  }
#line 360
  if ((unsigned int )p == 2U) {
#line 360
    goto case_2;
  }
#line 363
  if ((unsigned int )p == 3U) {
#line 363
    goto case_3;
  }
#line 366
  if ((unsigned int )p == 4U) {
#line 366
    goto case_4;
  }
#line 369
  if ((unsigned int )p == 5U) {
#line 369
    goto case_5;
  }
#line 353
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 355
  c = boardPiece(i, j);
  }
#line 356
  goto switch_break;
  case_1: /* CIL Label */ 
#line 358
  c = chars[0];
#line 359
  goto switch_break;
  case_2: /* CIL Label */ 
#line 361
  c = chars[1];
#line 362
  goto switch_break;
  case_3: /* CIL Label */ 
#line 364
  c = chars[2];
#line 365
  goto switch_break;
  case_4: /* CIL Label */ 
#line 367
  c = chars[3];
#line 368
  goto switch_break;
  case_5: /* CIL Label */ 
#line 370
  c = chars[4];
#line 371
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 373
  drawPiece(i, j, c);
  }
#line 374
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char *savetype[2]  = {      (char *)"long ",      (char *)"short"};
#line 383
int madechanges ;
#line 380 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void highlightAscii(int x , int y , int movenum , int turn ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 384
  if (turn != -1) {
    {
#line 385
    wmove(stdscr, 23, 1);
    }
#line 386
    if (turn) {
#line 386
      tmp = "White";
    } else {
#line 386
      tmp = "Black";
    }
    {
#line 386
    printw("%s #%d ", tmp, movenum);
    }
#line 387
    if (x == 25) {
#line 387
      if (y == 25) {
        {
#line 388
        printw("Pass      ");
        }
      } else {
        {
#line 390
        printw("at %c%d  ", (int )xAxisChars[x], boardsize - y);
        }
      }
    } else {
      {
#line 390
      printw("at %c%d  ", (int )xAxisChars[x], boardsize - y);
      }
    }
  } else {
    {
#line 392
    wmove(stdscr, 23, 1);
#line 393
    wclrtoeol(stdscr);
    }
  }
  {
#line 395
  drawPrisoners();
#line 396
  wmove(stdscr, 21, 61);
  }
#line 397
  if (tutor) {
    {
#line 398
    printw("tutor");
    }
  } else
#line 399
  if (madechanges) {
    {
#line 400
    printw("edit ");
    }
  } else {
    {
#line 402
    printw("read ");
    }
  }
#line 403
  if (saveShort) {
#line 403
    tmp___0 = 1;
  } else {
#line 403
    tmp___0 = 0;
  }
  {
#line 403
  printw("    %s", savetype[tmp___0]);
#line 404
  wrefresh(stdscr);
  }
#line 405
  return;
}
}
#line 407 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void showCommentAscii(int i ) 
{ 
  short line ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  short tmp___5 ;

  {
  {
#line 413
  line = (short)12;
#line 415
  wmove(stdscr, 2, 45);
  }
#line 416
  if (i) {
#line 416
    tmp = '-';
  } else {
#line 416
    tmp = ' ';
  }
  {
#line 416
  waddch(stdscr, (chtype const   )tmp);
#line 417
  wmove(stdscr, 13, 45);
#line 418
  tmp___2 = commentLines();
  }
#line 418
  if (tmp___2 - i > 12) {
#line 418
    tmp___1 = '+';
  } else {
#line 418
    tmp___1 = ' ';
  }
  {
#line 418
  waddch(stdscr, (chtype const   )tmp___1);
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    tmp___5 = line;
#line 420
    line = (short )((int )line - 1);
#line 420
    if (! tmp___5) {
#line 420
      goto while_break;
    }
    {
#line 421
    tmp___4 = wmove(stdscr, (int )line + 2, 46);
    }
#line 421
    if (! (tmp___4 == -1)) {
      {
#line 421
      tmp___3 = commentGet((int )line + i);
#line 421
      waddnstr(stdscr, (char const   *)tmp___3, -1);
      }
    }
    {
#line 422
    wclrtoeol(stdscr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  wrefresh(stdscr);
  }
#line 425
  return;
}
}
#line 427 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void clearCommentAscii(void) 
{ 
  int line ;

  {
#line 431
  commentExists = 0;
#line 432
  line = 2;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (line < 14)) {
#line 432
      goto while_break;
    }
    {
#line 433
    wmove(stdscr, line, 46);
#line 433
    wclrtoeol(stdscr);
#line 432
    line ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  wmove(stdscr, 2, 45);
#line 435
  waddch(stdscr, (chtype const   )' ');
#line 436
  wmove(stdscr, 13, 45);
#line 437
  waddch(stdscr, (chtype const   )' ');
#line 438
  wrefresh(stdscr);
  }
#line 439
  return;
}
}
#line 441 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void displayCommentAscii(char *s ) 
{ 


  {
  {
#line 444
  commentExists = 1;
#line 445
  commentLine = 0;
#line 446
  formatComment(s, 33);
#line 447
  showCommentAscii(0);
#line 448
  wrefresh(stdscr);
  }
#line 449
  return;
}
}
#line 452 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static command charToCommand(char c ) 
{ 
  int i ;
  int tmp ;

  {
#line 456
  if ((int )c == 27) {
#line 457
    return ((command )0);
  } else
#line 456
  if ((int )c == 3) {
#line 457
    return ((command )0);
  }
#line 458
  i = 49;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    tmp = i;
#line 458
    i --;
#line 458
    if (! tmp) {
#line 458
      goto while_break;
    }
#line 459
    if ((int )c == (int )keys[i]) {
#line 460
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return ((command )i);
}
}
#line 466 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int getPointAscii(void) 
{ 
  char c ;
  int tmp ;
  command tmp___0 ;

  {
  {
#line 470
  setCursor(xcur, ycur);
#line 471
  wrefresh(stdscr);
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 473
    tmp = wgetch(stdscr);
#line 473
    c = (char )tmp;
    }
#line 474
    if ((int )c == 117) {
#line 475
      return (45);
    }
#line 476
    if ((int )c == 27) {
#line 477
      return (0);
    } else
#line 476
    if ((int )c == (int )keys[0]) {
#line 477
      return (0);
    }
#line 478
    if ((int )c == 12) {
#line 479
      return (30);
    }
#line 480
    if ((int )c == 13) {
#line 481
      return (24);
    } else
#line 480
    if ((int )c == 10) {
#line 481
      return (24);
    }
#line 482
    if ((int )c == 32) {
#line 483
      return (35);
    } else
#line 482
    if ((int )c == (int )keys[35]) {
#line 483
      return (35);
    }
    {
#line 484
    tmp___0 = charToCommand(c);
    }
    {
#line 485
    if ((unsigned int )tmp___0 == 39U) {
#line 485
      goto case_39;
    }
#line 490
    if ((unsigned int )tmp___0 == 40U) {
#line 490
      goto case_40;
    }
#line 495
    if ((unsigned int )tmp___0 == 42U) {
#line 495
      goto case_42;
    }
#line 500
    if ((unsigned int )tmp___0 == 37U) {
#line 500
      goto case_37;
    }
#line 505
    if ((unsigned int )tmp___0 == 41U) {
#line 505
      goto case_41;
    }
#line 511
    if ((unsigned int )tmp___0 == 43U) {
#line 511
      goto case_43;
    }
#line 517
    if ((unsigned int )tmp___0 == 36U) {
#line 517
      goto case_36;
    }
#line 523
    if ((unsigned int )tmp___0 == 38U) {
#line 523
      goto case_38;
    }
#line 484
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 486
    xcur = ((xcur - 1) + boardsize) % boardsize;
#line 487
    setCursor(xcur, ycur);
#line 488
    wrefresh(stdscr);
    }
#line 489
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 491
    xcur = (xcur + 1) % boardsize;
#line 492
    setCursor(xcur, ycur);
#line 493
    wrefresh(stdscr);
    }
#line 494
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 496
    ycur = ((ycur - 1) + boardsize) % boardsize;
#line 497
    setCursor(xcur, ycur);
#line 498
    wrefresh(stdscr);
    }
#line 499
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 501
    ycur = (ycur + 1) % boardsize;
#line 502
    setCursor(xcur, ycur);
#line 503
    wrefresh(stdscr);
    }
#line 504
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 506
    ycur = ((ycur - 1) + boardsize) % boardsize;
#line 507
    xcur = ((xcur - 1) + boardsize) % boardsize;
#line 508
    setCursor(xcur, ycur);
#line 509
    wrefresh(stdscr);
    }
#line 510
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 512
    xcur = (xcur + 1) % boardsize;
#line 513
    ycur = ((ycur - 1) + boardsize) % boardsize;
#line 514
    setCursor(xcur, ycur);
#line 515
    wrefresh(stdscr);
    }
#line 516
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 518
    xcur = ((xcur - 1) + boardsize) % boardsize;
#line 519
    ycur = (ycur + 1) % boardsize;
#line 520
    setCursor(xcur, ycur);
#line 521
    wrefresh(stdscr);
    }
#line 522
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 524
    xcur = (xcur + 1) % boardsize;
#line 525
    ycur = (ycur + 1) % boardsize;
#line 526
    setCursor(xcur, ycur);
#line 527
    wrefresh(stdscr);
    }
#line 528
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 536 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char *edhelp[22]  = 
#line 536
  {      (char *)"                Comment Editor Help",      (char *)"",      (char *)" Cursor control (\'^\' control, \']\' <esc>/<meta>):",      (char *)"    %s: Previous line         %s: Next line", 
        (char *)"    %s: Previous page         %s: Next page",      (char *)"    %s: Back one character    %s: Forward one character",      (char *)"    %s: Beginning of line     %s: End of line",      (char *)"    %s: Beginning of comment  %s: End of comment", 
        (char *)"    %s: Delete one character  %s: Delete to end of line",      (char *)" Press %s to toggle insert mode",      (char *)" Press %s to exit and write your comment",      (char *)" Press %s to exit and keep the old comment", 
        (char *)"",      (char *)"  (Warning:  comments longer than 120 lines",      (char *)"             will be truncated if edited)",      (char *)"", 
        (char *)"                    Other Notes",      (char *)"",      (char *)"  When saving a file, * stands for the current file",      (char *)"       (printed in the upper right corner)", 
        (char *)"",      (char *)"               Hit any key to return"};
#line 568 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char *fixkey(char key , char *keystr ) 
{ 


  {
#line 572
  if ((int )key == (int )keys[0]) {
    {
#line 573
    printw("ESC or ");
    }
  }
#line 574
  if ((int )key == (int )keys[35]) {
    {
#line 575
    printw("Space or ");
    }
  }
#line 576
  if ((int )key < 32) {
#line 577
    *(keystr + 0) = (char )'^';
#line 578
    *(keystr + 1) = (char )((int )key + 64);
#line 579
    *(keystr + 2) = (char)0;
  } else {
#line 581
    *(keystr + 0) = key;
#line 582
    *(keystr + 1) = (char)0;
  }
#line 584
  return (keystr);
}
}
#line 588 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void helpAscii(void) 
{ 
  int i ;
  char keystr[3] ;
  char kstr[3] ;
  char ch ;
  WINDOW *wi___0 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 597
  wi___0 = newwin(0, 0, 0, 0);
#line 597
  overwrite((WINDOW const   *)stdscr, wi___0);
  }
#line 597
  if (stdscr) {
#line 597
    tmp = (int )stdscr->_maxy + 1;
  } else {
#line 597
    tmp = -1;
  }
  {
#line 597
  wtouchln(stdscr, 0, tmp, 1);
#line 598
  wclear(stdscr);
#line 599
  wmove(stdscr, 0, 33);
#line 600
  printw("MGT Version %s", "2.31");
#line 601
  wmove(stdscr, 1, 12);
#line 602
  printw("Written by Greg Hale        Enhancements by Adrian Mariano");
#line 603
  wmove(stdscr, 2, 11);
#line 604
  printw("(hale@scam.Berkely.edu)      (adrian@bsdserver.ucsf.edu)");
#line 605
  i = 0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < 18)) {
#line 605
      goto while_break;
    }
    {
#line 606
    wmove(stdscr, i + 3, 8);
#line 607
    tmp___0 = fixkey(keys[i], keystr);
#line 607
    printw("%s: %s", tmp___0, helpStr[i]);
#line 608
    wmove(stdscr, i + 3, 46);
#line 609
    tmp___1 = fixkey(keys[i + 18], keystr);
#line 609
    printw("%s: %s", tmp___1, helpStr[i + 18]);
#line 605
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 611
  wmove(stdscr, 21, 8);
#line 612
  tmp___2 = fixkey(keys[(command )47], keystr);
#line 612
  printw("%s", tmp___2);
#line 613
  tmp___3 = fixkey(keys[(command )46], keystr);
#line 613
  printw(", %s: Scroll tree window", tmp___3);
#line 614
  wmove(stdscr, 21, 46);
#line 615
  tmp___4 = fixkey(keys[(command )45], keystr);
#line 615
  printw("%s", tmp___4);
#line 616
  tmp___5 = fixkey(keys[44], keystr);
#line 616
  printw(", %s: Scroll comment window", tmp___5);
#line 617
  wmove(stdscr, 22, 8);
#line 618
  printw("Uppercase letters visit variations");
#line 619
  wmove(stdscr, 22, 46);
#line 620
  i = 36;
  }
  {
#line 620
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 620
    if (! (i <= 43)) {
#line 620
      goto while_break___0;
    }
    {
#line 621
    waddch(stdscr, (chtype const   )keys[i]);
#line 620
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 622
  printw(": Cursor movement");
#line 623
  wmove(stdscr, 23, 21);
#line 624
  printw("Hit return to return, any key to continue");
#line 625
  wrefresh(stdscr);
#line 626
  tmp___6 = wgetch(stdscr);
#line 626
  ch = (char )tmp___6;
  }
#line 627
  if ((int )ch != 13) {
#line 627
    if ((int )ch != 10) {
      {
#line 628
      wclear(stdscr);
#line 629
      i = 0;
      }
      {
#line 629
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 629
        if (! (i < 3)) {
#line 629
          goto while_break___1;
        }
        {
#line 630
        wmove(stdscr, i, 10);
#line 631
        printw((char const   *)edhelp[i]);
#line 629
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 633
      i = 0;
      {
#line 633
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 633
        if (! (i < 12)) {
#line 633
          goto while_break___2;
        }
        {
#line 634
        wmove(stdscr, i / 2 + 3, 10);
#line 635
        tmp___7 = dispedkey(edcmds[i + 1], keystr);
#line 635
        tmp___8 = dispedkey(edcmds[i], kstr);
#line 635
        printw((char const   *)edhelp[i / 2 + 3], tmp___8, tmp___7);
#line 633
        i += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 637
      wmove(stdscr, 9, 10);
#line 638
      tmp___9 = dispedkey(edcmds[12], kstr);
#line 638
      printw((char const   *)edhelp[9], tmp___9);
#line 639
      wmove(stdscr, 10, 10);
#line 640
      tmp___10 = dispedkey(edcmds[13], kstr);
#line 640
      printw((char const   *)edhelp[10], tmp___10);
#line 641
      wmove(stdscr, 11, 10);
#line 642
      tmp___11 = dispedkey(edcmds[14], kstr);
#line 642
      printw((char const   *)edhelp[11], tmp___11);
#line 643
      i = 12;
      }
      {
#line 643
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 643
        if (! ((unsigned long )i < sizeof(edhelp) / sizeof(char *))) {
#line 643
          goto while_break___3;
        }
        {
#line 644
        tmp___12 = wmove(stdscr, i, 10);
        }
#line 644
        if (! (tmp___12 == -1)) {
          {
#line 644
          waddnstr(stdscr, (char const   *)edhelp[i], -1);
          }
        }
#line 643
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 645
      wrefresh(stdscr);
#line 646
      tmp___13 = wgetch(stdscr);
#line 646
      ch = (char )tmp___13;
      }
#line 647
      if ((int )ch != 13) {
#line 647
        if ((int )ch != 10) {
#line 647
          tmp___14 = 1;
        } else {
#line 647
          tmp___14 = 0;
        }
      } else {
#line 647
        tmp___14 = 0;
      }
    }
  }
  {
#line 650
  overwrite((WINDOW const   *)wi___0, stdscr);
#line 650
  wrefresh(stdscr);
#line 650
  delwin(wi___0);
  }
#line 651
  return;
}
}
#line 655 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int idleAscii(nodep curnode ) 
{ 
  char c ;
  command r ;
  command com ;
  int tmp ;
  char buf___0[5] ;
  int tmp___0 ;

  {
  {
#line 662
  highlightLast();
#line 663
  setCursor(xcur, ycur);
#line 664
  wrefresh(stdscr);
#line 666
  tmp = wgetch(stdscr);
#line 666
  c = (char )tmp;
#line 667
  r = specialKeysIdle(c);
  }
#line 667
  if (r) {
#line 668
    return ((int )r);
  }
#line 669
  r = (command )75;
#line 670
  if ((int )c >= 65) {
#line 670
    if ((int )c <= 90) {
#line 671
      r = (command )((int )((char )((command )76)) + ((int )c - 65));
    } else {
#line 670
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 674
    if ((int )c == 32) {
#line 674
      goto case_32;
    }
#line 676
    if ((int )c == 63) {
#line 676
      goto case_63;
    }
#line 679
    goto switch_default;
    case_32: /* CIL Label */ 
#line 675
    return (35);
    case_63: /* CIL Label */ 
    {
#line 677
    helpAscii();
    }
#line 678
    return ((int )((command )75));
    switch_default: /* CIL Label */ 
    {
#line 680
    com = charToCommand(c);
    }
    {
#line 682
    if ((unsigned int )com == 0U) {
#line 682
      goto case_0;
    }
#line 693
    if ((unsigned int )com == (unsigned int )((command )48)) {
#line 693
      goto case_48;
    }
#line 696
    if ((unsigned int )com == 44U) {
#line 696
      goto case_44;
    }
#line 703
    if ((unsigned int )com == (unsigned int )((command )45)) {
#line 703
      goto case_45;
    }
#line 709
    if ((unsigned int )com == (unsigned int )((command )46)) {
#line 709
      goto case_46;
    }
#line 713
    if ((unsigned int )com == (unsigned int )((command )47)) {
#line 713
      goto case_47;
    }
#line 717
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 685
    if ((int )c != 27) {
      {
#line 686
      getLine((char *)"Quit (y/N)?", buf___0, 1);
      }
#line 687
      if ((int )buf___0[0] == 121) {
#line 688
        r = (command )0;
      }
    } else {
#line 690
      r = (command )0;
    }
#line 692
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 694
    inverseFlag = ! inverseFlag;
#line 695
    return (30);
    case_44: /* CIL Label */ 
#line 697
    if (commentExists) {
      {
#line 698
      tmp___0 = commentLines();
      }
#line 698
      if (commentLine < tmp___0 - 12) {
#line 699
        commentLine += 9;
      }
      {
#line 700
      showCommentAscii(commentLine);
      }
    }
#line 702
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 704
    if (commentExists) {
#line 704
      if (commentLine) {
        {
#line 705
        commentLine -= 9;
#line 706
        showCommentAscii(commentLine);
        }
      }
    }
#line 708
    goto switch_break___0;
    case_46: /* CIL Label */ 
    {
#line 710
    treeLine ++;
#line 711
    drawTreeAscii0(curnode);
    }
#line 712
    goto switch_break___0;
    case_47: /* CIL Label */ 
    {
#line 714
    treeLine --;
#line 715
    drawTreeAscii0(curnode);
    }
#line 716
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 718
    r = com;
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 721
  return ((int )r);
}
}
#line 738
extern int ( /* missing proto */  strncmp)() ;
#line 730 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void readEnvAscii(char **env ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 733
  tmp___15 = (int )strlen("ASCCOM:");
#line 733
  tmp___16 = strncmp(*env, "ASCCOM:", tmp___15);
  }
#line 733
  if (tmp___16) {
    {
#line 734
    tmp___13 = (int )strlen("ASCCHAR:");
#line 734
    tmp___14 = strncmp(*env, "ASCCHAR:", tmp___13);
    }
#line 734
    if (tmp___14) {
      {
#line 735
      tmp___11 = (int )strlen("ASCED:");
#line 735
      tmp___12 = strncmp(*env, "ASCED:", tmp___11);
      }
#line 735
      if (tmp___12) {
        {
#line 736
        tmp___9 = (int )strlen("ASCINV");
#line 736
        tmp___10 = strncmp(*env, "ASCINV", tmp___9);
        }
#line 736
        if (tmp___10) {
          {
#line 737
          tmp___7 = (int )strlen("ASCEDVI");
#line 737
          tmp___8 = strncmp(*env, "ASCEDVI", tmp___7);
          }
#line 737
          if (tmp___8) {
            {
#line 738
            tmp___5 = (int )strlen("ASCEDEMACS");
#line 738
            tmp___6 = strncmp(*env, "ASCEDEMACS", tmp___5);
            }
#line 738
            if (! tmp___6) {
              {
#line 738
              tmp___4 = (int )strlen("ASCEDEMACS");
#line 738
              *env += tmp___4;
#line 738
              edvi = 0;
#line 738
              strncpy(edcmds, emacscmds, 15);
              }
            }
          } else {
            {
#line 737
            tmp___3 = (int )strlen("ASCEDVI");
#line 737
            *env += tmp___3;
#line 737
            edvi = 1;
#line 737
            strncpy(edcmds, vicmds, 15);
            }
          }
        } else {
          {
#line 736
          tmp___2 = (int )strlen("ASCINV");
#line 736
          *env += tmp___2;
#line 736
          inverseFlag = 1;
          }
        }
      } else {
        {
#line 735
        tmp___1 = (int )strlen("ASCED:");
#line 735
        *env += tmp___1;
#line 735
        strncpy(edcmds, *env, 15);
        }
      }
    } else {
      {
#line 734
      tmp___0 = (int )strlen("ASCCHAR:");
#line 734
      *env += tmp___0;
#line 734
      strncpy(chars, *env, 13);
      }
    }
  } else {
    {
#line 733
    tmp = (int )strlen("ASCCOM:");
#line 733
    *env += tmp;
#line 733
    strncpy(keys, *env, 49);
    }
  }
#line 761
  return;
}
}
#line 765 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
char screen[121][33]  ;
#line 766 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
int yoffset  ;
#line 766 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
int cmplus  ;
#line 766 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
int cmminus  ;
#line 770 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void showcommentindicator(void) 
{ 
  int rfr ;
  int tmp ;
  int tmp___0 ;

  {
#line 773
  rfr = 0;
#line 775
  if (! ((yoffset > 0) == cmminus)) {
    {
#line 776
    cmminus = ! cmminus;
#line 777
    wmove(stdscr, 2, 45);
    }
#line 778
    if (cmminus) {
#line 778
      tmp = '-';
    } else {
#line 778
      tmp = ' ';
    }
    {
#line 778
    waddch(stdscr, (chtype const   )tmp);
#line 779
    rfr = 1;
    }
  }
#line 781
  if (! (((int )screen[(yoffset + 11) + 1][0] > 0) == cmplus)) {
    {
#line 782
    cmplus = ! cmplus;
#line 783
    wmove(stdscr, 13, 45);
    }
#line 784
    if (cmplus) {
#line 784
      tmp___0 = '+';
    } else {
#line 784
      tmp___0 = ' ';
    }
    {
#line 784
    waddch(stdscr, (chtype const   )tmp___0);
#line 785
    rfr = 1;
    }
  }
#line 787
  if (rfr) {
    {
#line 788
    wrefresh(stdscr);
    }
  }
#line 790
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void adjustwin(WINDOW *win , int yloc ) 
{ 
  int x ;
  int y ;
  int tmp ;

  {
#line 798
  if (yloc < yoffset) {
#line 798
    goto _L;
  } else
#line 798
  if (yloc > yoffset + 11) {
    _L: /* CIL Label */ 
#line 799
    if (yloc < yoffset) {
#line 800
      yoffset = (yloc - 11) + 3;
    }
#line 801
    if (yloc > yoffset + 11) {
#line 802
      yoffset = yloc - 3;
    }
#line 803
    if (yoffset < 0) {
#line 804
      yoffset = 0;
    }
#line 805
    if (yoffset > 109) {
#line 806
      yoffset = 109;
    }
    {
#line 807
    while (1) {
      while_continue: /* CIL Label */ ;
#line 807
      if (yoffset > 0) {
#line 807
        if (! (! screen[yoffset + 11][0])) {
#line 807
          goto while_break;
        }
      } else {
#line 807
        goto while_break;
      }
#line 807
      yoffset --;
    }
    while_break: /* CIL Label */ ;
    }
#line 808
    y = yoffset;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 808
      if (y <= yoffset + 11) {
#line 808
        if (! screen[y][0]) {
#line 808
          goto while_break___0;
        }
      } else {
#line 808
        goto while_break___0;
      }
#line 809
      x = 0;
      {
#line 809
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 809
        if (x <= 32) {
#line 809
          if (! screen[y][x]) {
#line 809
            goto while_break___1;
          }
        } else {
#line 809
          goto while_break___1;
        }
        {
#line 810
        wmove(win, y - yoffset, x);
        }
#line 811
        if ((int )screen[y][x] < 32) {
#line 811
          tmp = ' ';
        } else {
#line 811
          tmp = (int )screen[y][x];
        }
        {
#line 811
        waddch(win, (chtype const   )tmp);
#line 809
        x ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 813
      if (x <= 32) {
        {
#line 814
        wmove(win, y - yoffset, x);
#line 815
        wclrtoeol(win);
        }
      }
#line 808
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    if (y <= yoffset + 11) {
      {
#line 819
      wmove(win, y - yoffset, 0);
#line 820
      wclrtobot(win);
      }
    }
  }
  {
#line 823
  showcommentindicator();
  }
#line 824
  return;
}
}
#line 827 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void fixnewline(WINDOW *win , int xloc , int yloc ) 
{ 
  int myx ;
  int myy ;
  int tmp ;
  int tmp___0 ;

  {
#line 831
  if (xloc < 32) {
#line 831
    if ((int )screen[yloc][xloc] == 10) {
#line 831
      if (screen[yloc][xloc + 1]) {
#line 834
        myy = 119;
        {
#line 834
        while (1) {
          while_continue: /* CIL Label */ ;
#line 834
          if (myy > yloc) {
#line 834
            if (! (! screen[myy][0])) {
#line 834
              goto while_break;
            }
          } else {
#line 834
            goto while_break;
          }
#line 834
          myy --;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 835
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 835
          if (! (myy > yloc)) {
#line 835
            goto while_break___0;
          }
#line 836
          myx = 0;
          {
#line 836
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 836
            if (myx <= 32) {
#line 836
              if (! screen[myy + 1][myx]) {
#line 836
                if (! screen[myy][myx]) {
#line 836
                  goto while_break___1;
                }
              }
            } else {
#line 836
              goto while_break___1;
            }
#line 837
            screen[myy + 1][myx] = screen[myy][myx];
#line 838
            if (myy + 1 <= 11 + yoffset) {
#line 838
              if (myy + 1 >= yoffset) {
                {
#line 839
                wmove(win, (myy - yoffset) + 1, myx);
                }
#line 840
                if ((int )screen[myy][myx] >= 32) {
#line 840
                  tmp = (int )screen[myy][myx];
                } else {
#line 840
                  tmp = ' ';
                }
                {
#line 840
                waddch(win, (chtype const   )tmp);
                }
              }
            }
#line 836
            myx ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 835
          myy --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 844
        myx = xloc + 1;
        {
#line 844
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 844
          if (myx <= 32) {
#line 844
            if (! screen[myy][myx]) {
#line 844
              goto while_break___2;
            }
          } else {
#line 844
            goto while_break___2;
          }
#line 845
          screen[myy + 1][(myx - xloc) - 1] = screen[myy][myx];
#line 846
          if (myy <= 11 + yoffset) {
#line 846
            if (myy >= yoffset) {
              {
#line 847
              wmove(win, myy - yoffset, myx);
#line 848
              waddch(win, (chtype const   )' ');
              }
            }
          }
#line 850
          if (myy + 1 <= 11 + yoffset) {
#line 850
            if (myy + 1 >= yoffset) {
              {
#line 851
              wmove(win, (myy - yoffset) + 1, (myx - xloc) - 1);
              }
#line 852
              if ((int )screen[myy][myx] >= 32) {
#line 852
                tmp___0 = (int )screen[myy][myx];
              } else {
#line 852
                tmp___0 = ' ';
              }
              {
#line 852
              waddch(win, (chtype const   )tmp___0);
              }
            }
          }
#line 855
          screen[myy][myx] = (char)0;
#line 844
          myx ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 857
        myx = (myx - xloc) - 1;
        {
#line 857
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 857
          if (myx <= 32) {
#line 857
            if (! screen[myy + 1][myx]) {
#line 857
              goto while_break___3;
            }
          } else {
#line 857
            goto while_break___3;
          }
#line 858
          screen[myy + 1][myx] = (char)0;
#line 859
          if (myy + 1 <= 11 + yoffset) {
#line 859
            if (myy + 1 >= yoffset) {
              {
#line 860
              wmove(win, (myy - yoffset) + 1, myx);
#line 861
              waddch(win, (chtype const   )' ');
              }
            }
          }
#line 857
          myx ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 864
        wrefresh(win);
        }
      }
    }
  }
#line 866
  return;
}
}
#line 869 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void deletechar(WINDOW *win , int x , int y , int x1 , int y1 ) 
{ 
  char c ;
  int tmp ;
  int tmp___0 ;

  {
#line 874
  c = (char )' ';
  {
#line 875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 875
    if (c) {
#line 875
      if (! ((int )c == 10)) {
#line 875
        if (x1 <= 32) {
#line 875
          if (! (y1 <= 120)) {
#line 875
            goto while_break;
          }
        } else {
#line 875
          goto while_break;
        }
      } else {
#line 875
        goto while_break;
      }
    } else {
#line 875
      goto while_break;
    }
#line 876
    c = screen[y1][x1];
#line 877
    screen[y][x] = c;
#line 878
    if (y <= 11 + yoffset) {
#line 878
      if (y >= yoffset) {
        {
#line 879
        wmove(win, y - yoffset, x);
        }
#line 880
        if ((int )c < 32) {
#line 880
          tmp = ' ';
        } else {
#line 880
          tmp = (int )c;
        }
        {
#line 880
        waddch(win, (chtype const   )tmp);
        }
      }
    }
#line 882
    screen[y1][x1] = (char)0;
#line 883
    if (x < 32) {
#line 884
      x ++;
    } else {
#line 886
      x = 0;
#line 887
      y ++;
    }
#line 889
    if (x1 < 32) {
#line 890
      x1 ++;
    } else {
#line 892
      x1 = 0;
#line 893
      y1 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 896
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 896
    if (! (x <= 32)) {
#line 896
      goto while_break___0;
    }
#line 897
    screen[y][x] = (char)0;
#line 898
    if (y <= 11 + yoffset) {
#line 898
      if (y >= yoffset) {
        {
#line 899
        wmove(win, y - yoffset, x);
#line 900
        waddch(win, (chtype const   )' ');
        }
      }
    }
#line 896
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 903
  if (! (y == y1)) {
#line 904
    y ++;
#line 905
    y1 ++;
    {
#line 906
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 906
      if (y1 <= 120) {
#line 906
        if (! screen[y1][0]) {
#line 906
          goto while_break___1;
        }
      } else {
#line 906
        goto while_break___1;
      }
#line 907
      x = 0;
      {
#line 907
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 907
        if (! (x <= 32)) {
#line 907
          goto while_break___2;
        }
#line 908
        screen[y][x] = screen[y1][x];
#line 909
        if (y <= 11 + yoffset) {
#line 909
          if (y >= yoffset) {
            {
#line 910
            wmove(win, y - yoffset, x);
            }
#line 911
            if ((int )screen[y][x] < 32) {
#line 911
              tmp___0 = ' ';
            } else {
#line 911
              tmp___0 = (int )screen[y][x];
            }
            {
#line 911
            waddch(win, (chtype const   )tmp___0);
            }
          }
        }
#line 907
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 906
      y ++;
#line 906
      y1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 914
    x = 0;
    {
#line 914
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 914
      if (! (x <= 32)) {
#line 914
        goto while_break___3;
      }
#line 915
      screen[y1 - 1][x] = (char)0;
#line 916
      if (y1 - 1 <= 11 + yoffset) {
#line 916
        if (y1 - 1 >= yoffset) {
          {
#line 917
          wmove(win, (y1 - 1) - yoffset, x);
#line 918
          waddch(win, (chtype const   )' ');
          }
        }
      }
#line 914
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 922
  return;
}
}
#line 925 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void insertchar(WINDOW *win , char c , int x , int y , char mflag ) 
{ 
  int xend ;
  int yend ;
  char k ;
  char nlflag ;
  int tmp ;

  {
#line 932
  xend = -1;
#line 934
  nlflag = (char)0;
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (c) {
#line 935
      if (x <= 32) {
#line 935
        if (! (y <= 120)) {
#line 935
          goto while_break;
        }
      } else {
#line 935
        goto while_break;
      }
    } else {
#line 935
      goto while_break;
    }
#line 936
    k = screen[y][x];
#line 937
    screen[y][x] = c;
#line 938
    if (y <= 11 + yoffset) {
#line 938
      if (y >= yoffset) {
#line 938
        if (! nlflag) {
          {
#line 939
          wmove(win, y - yoffset, x);
          }
#line 940
          if ((int )c >= 32) {
#line 940
            tmp = (int )c;
          } else {
#line 940
            tmp = ' ';
          }
          {
#line 940
          waddch(win, (chtype const   )tmp);
          }
        }
      }
    }
#line 942
    if ((int )c == 10) {
#line 943
      nlflag = (char)1;
    }
#line 944
    if (x < 32) {
#line 945
      x ++;
    } else {
#line 947
      x = 0;
#line 948
      y ++;
    }
#line 950
    c = k;
#line 951
    if (xend == -1) {
#line 952
      xend = x;
#line 953
      yend = y;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  y = 0;
  {
#line 956
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 956
    if (! (y <= 120)) {
#line 956
      goto while_break___0;
    }
#line 957
    x = 0;
    {
#line 957
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 957
      if (! (x <= 32)) {
#line 957
        goto while_break___1;
      }
#line 958
      if ((int )screen[y][x] == 10) {
        {
#line 959
        fixnewline(win, x, y);
        }
      }
#line 957
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 956
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 960
  if (mflag) {
    {
#line 961
    adjustwin(win, yend + 1);
#line 962
    wmove(win, (yend - yoffset) + 1, 0);
    }
  } else {
    {
#line 964
    adjustwin(win, yend);
#line 965
    wmove(win, yend - yoffset, xend);
    }
  }
#line 967
  return;
}
}
#line 971 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void edit(char *inp , char **out , char *mesg ) 
{ 
  int x ;
  int y ;
  int x1 ;
  int y1 ;
  int insert ;
  int cmdmode ;
  char c ;
  char str[3994] ;
  char *s ;
  WINDOW *win ;
  char edithelp[80] ;
  char kstr[10] ;
  char keystr[10] ;
  char tmp ;
  int tmp___0 ;
  int xsave ;

  {
  {
#line 982
  dispedkey(edcmds[13], keystr);
  }
#line 983
  if ((int )keystr[0] == 93) {
    {
#line 984
    sprintf((char */* __restrict  */)(keystr), (char const   */* __restrict  */)"ESC-%c",
            (int )edcmds[13] & 127);
    }
  }
  {
#line 985
  dispedkey(edcmds[14], kstr);
  }
#line 986
  if ((int )keystr[0] == 93) {
    {
#line 987
    sprintf((char */* __restrict  */)(kstr), (char const   */* __restrict  */)"ESC-%c",
            (int )edcmds[14] & 127);
    }
  }
  {
#line 988
  sprintf((char */* __restrict  */)(edithelp), (char const   */* __restrict  */)"%s - write %s   %s - keep old %s",
          keystr, mesg, kstr, mesg);
#line 989
  notifyMessageAscii(edithelp);
#line 990
  win = subwin(stdscr, 12, 33, 2, 46);
#line 991
  cmplus = 0;
#line 992
  cmminus = 0;
#line 993
  insert = 1;
#line 994
  cmdmode = 0;
#line 995
  yoffset = 1;
#line 996
  y = 0;
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (! (y < 121)) {
#line 996
      goto while_break;
    }
#line 997
    x = 0;
    {
#line 997
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 997
      if (! (x < 33)) {
#line 997
        goto while_break___0;
      }
#line 998
      screen[y][x] = (char)0;
#line 997
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 996
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1000
  if (inp) {
#line 1001
    s = inp;
#line 1001
    y = 0;
#line 1001
    x = y;
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (*s) {
#line 1001
        if (x <= 32) {
#line 1001
          if (! (y <= 120)) {
#line 1001
            goto while_break___1;
          }
        } else {
#line 1001
          goto while_break___1;
        }
      } else {
#line 1001
        goto while_break___1;
      }
#line 1002
      tmp = *s;
#line 1002
      screen[y][x] = tmp;
#line 1002
      c = tmp;
#line 1003
      if ((int )*s == 10) {
#line 1004
        x = 0;
#line 1005
        y ++;
      } else
#line 1006
      if (x < 32) {
#line 1007
        x ++;
      } else {
#line 1009
        x = 0;
#line 1010
        y ++;
      }
#line 1001
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1013
    if (! ((int )c == 10)) {
#line 1013
      if (x == 32) {
#line 1013
        if (! (y == 120)) {
#line 1014
          screen[y][x] = (char )'\n';
        }
      } else {
#line 1014
        screen[y][x] = (char )'\n';
      }
    }
  }
  {
#line 1016
  adjustwin(win, 0);
#line 1017
  wmove(win, 0, 0);
#line 1018
  wrefresh(win);
  }
#line 1019
  if (! screen[0][0]) {
#line 1020
    screen[0][0] = (char )'\n';
  }
  {
#line 1021
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1023
    c = getKeyEdit();
#line 1024
    x = xpos(win);
#line 1025
    tmp___0 = ypos(win);
#line 1025
    y = tmp___0 + yoffset;
    }
#line 1026
    if (edvi) {
#line 1026
      if (! cmdmode) {
#line 1026
        goto _L;
      } else {
#line 1026
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1026
    if (! edvi) {
      _L: /* CIL Label */ 
#line 1026
      if ((int )c >= 32) {
#line 1026
        if ((int )c < 127) {
#line 1027
          if (insert) {
            {
#line 1028
            insertchar(win, c, x, y, (char)0);
            }
          } else
#line 1030
          if ((int )screen[y][x] == 10) {
            {
#line 1031
            insertchar(win, c, x, y, (char)0);
            }
          } else {
            {
#line 1033
            screen[y][x] = c;
#line 1034
            waddch(win, (chtype const   )c);
            }
          }
          {
#line 1037
          wrefresh(win);
          }
        }
      }
    }
#line 1039
    if ((int )c == 12) {
      {
#line 1040
      clearok(stdscr, (_Bool)1);
#line 1040
      wrefresh(stdscr);
#line 1040
      clearok(stdscr, (_Bool)0);
#line 1041
      wmove(win, y - yoffset, x);
#line 1042
      wrefresh(win);
      }
    }
#line 1044
    if (! edvi) {
#line 1044
      if ((int )c == (int )edcmds[12]) {
#line 1045
        insert = ! insert;
      }
    }
#line 1046
    if (edvi) {
#line 1046
      if (cmdmode) {
#line 1046
        if ((int )c == (int )edcmds[12]) {
#line 1047
          cmdmode = ! cmdmode;
        }
      }
    }
#line 1048
    if (edvi) {
#line 1048
      if (! cmdmode) {
#line 1048
        if ((int )c == 27) {
#line 1049
          cmdmode = ! cmdmode;
#line 1050
          c = (char )' ';
        }
      }
    }
#line 1052
    if (edvi) {
#line 1052
      if (cmdmode) {
#line 1052
        goto _L___1;
      } else {
#line 1052
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1052
    if (! edvi) {
      _L___1: /* CIL Label */ 
#line 1052
      if ((int )c == (int )edcmds[11]) {
        {
#line 1053
        x1 = x;
#line 1054
        y1 = y;
#line 1055
        wmove(win, y - yoffset, x);
#line 1056
        wclrtoeol(win);
        }
        {
#line 1057
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1057
          if (! (x <= 32)) {
#line 1057
            goto while_break___3;
          }
#line 1058
          screen[y][x] = (char)0;
#line 1057
          x ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1059
        screen[y1][x1] = (char )'\n';
#line 1060
        adjustwin(win, y1);
#line 1061
        wmove(win, y1 - yoffset, x1);
#line 1062
        wrefresh(win);
        }
      }
    }
#line 1064
    if (edvi) {
#line 1064
      if (! cmdmode) {
#line 1064
        goto _L___4;
      } else {
#line 1064
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1064
    if (! edvi) {
      _L___4: /* CIL Label */ 
#line 1064
      if ((int )c == 10) {
#line 1064
        goto _L___3;
      } else
#line 1064
      if ((int )c == 13) {
        _L___3: /* CIL Label */ 
#line 1065
        if (y < 120) {
          {
#line 1066
          insertchar(win, (char )'\n', x, y, (char)1);
          }
        } else {
          {
#line 1069
          xsave = x;
#line 1070
          screen[y][x] = (char )'\n';
#line 1071
          waddch(win, (chtype const   )' ');
#line 1072
          x ++;
          }
          {
#line 1072
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1072
            if (! (x <= 32)) {
#line 1072
              goto while_break___4;
            }
            {
#line 1073
            screen[y][x] = (char)0;
#line 1074
            waddch(win, (chtype const   )' ');
#line 1072
            x ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 1076
          adjustwin(win, y);
#line 1077
          wmove(win, y - yoffset, xsave);
          }
        }
        {
#line 1079
        wrefresh(win);
        }
      }
    }
#line 1081
    if (edvi) {
#line 1081
      if (cmdmode) {
#line 1081
        goto _L___6;
      } else {
#line 1081
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 1081
    if (! edvi) {
      _L___6: /* CIL Label */ 
#line 1081
      if ((int )c == (int )edcmds[10]) {
#line 1082
        y1 = y;
#line 1083
        x1 = x;
#line 1084
        if (x1 < 32) {
#line 1085
          x1 ++;
#line 1086
          if (! screen[y1][x1]) {
#line 1087
            x1 = 0;
#line 1088
            y1 ++;
          }
        } else {
#line 1091
          x1 = 0;
#line 1092
          y1 ++;
        }
        {
#line 1094
        deletechar(win, x, y, x1, y1);
#line 1095
        adjustwin(win, y);
#line 1096
        wmove(win, y - yoffset, x);
#line 1097
        wrefresh(win);
        }
      }
    }
#line 1099
    if (edvi) {
#line 1099
      if (cmdmode) {
#line 1099
        goto _L___10;
      } else {
#line 1099
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 1099
    if (! edvi) {
      _L___10: /* CIL Label */ 
#line 1099
      if ((int )c == 8) {
#line 1099
        goto _L___9;
      } else
#line 1099
      if ((int )c == 127) {
        _L___9: /* CIL Label */ 
#line 1099
        if (y) {
#line 1099
          goto _L___8;
        } else
#line 1099
        if (x) {
          _L___8: /* CIL Label */ 
#line 1100
          y1 = y;
#line 1101
          x1 = x;
#line 1102
          if (x) {
#line 1103
            x --;
          } else {
#line 1105
            y --;
#line 1106
            x = 32;
            {
#line 1106
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1106
              if (! (! screen[y][x])) {
#line 1106
                goto while_break___5;
              }
#line 1106
              x --;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
          {
#line 1108
          deletechar(win, x, y, x1, y1);
#line 1109
          adjustwin(win, y);
#line 1110
          wmove(win, y - yoffset, x);
#line 1111
          wrefresh(win);
          }
        }
      }
    }
#line 1113
    if (edvi) {
#line 1113
      if (cmdmode) {
#line 1113
        goto _L___12;
      } else {
#line 1113
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 1113
    if (! edvi) {
      _L___12: /* CIL Label */ 
#line 1113
      if ((int )c == (int )edcmds[0]) {
#line 1113
        if (y) {
#line 1114
          y --;
          {
#line 1115
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1115
            if (x > 0) {
#line 1115
              if (! (! screen[y][x])) {
#line 1115
                goto while_break___6;
              }
            } else {
#line 1115
              goto while_break___6;
            }
#line 1115
            x --;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1116
          adjustwin(win, y);
#line 1117
          wmove(win, y - yoffset, x);
#line 1118
          wrefresh(win);
          }
        }
      }
    }
#line 1120
    if (edvi) {
#line 1120
      if (cmdmode) {
#line 1120
        goto _L___14;
      } else {
#line 1120
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 1120
    if (! edvi) {
      _L___14: /* CIL Label */ 
#line 1120
      if ((int )c == (int )edcmds[2]) {
#line 1121
        y = yoffset - 1;
#line 1122
        if (y < 0) {
#line 1123
          y = 0;
        }
        {
#line 1124
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1124
          if (x > 0) {
#line 1124
            if (! (! screen[y][x])) {
#line 1124
              goto while_break___7;
            }
          } else {
#line 1124
            goto while_break___7;
          }
#line 1124
          x --;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1125
        adjustwin(win, y);
#line 1126
        wmove(win, y - yoffset, x);
#line 1127
        wrefresh(win);
        }
      }
    }
#line 1129
    if (edvi) {
#line 1129
      if (cmdmode) {
#line 1129
        goto _L___16;
      } else {
#line 1129
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 1129
    if (! edvi) {
      _L___16: /* CIL Label */ 
#line 1129
      if ((int )c == (int )edcmds[8]) {
        {
#line 1130
        x = 0;
#line 1130
        y = x;
#line 1131
        adjustwin(win, y);
#line 1132
        wmove(win, 0, 0);
#line 1133
        wrefresh(win);
        }
      }
    }
#line 1135
    if (edvi) {
#line 1135
      if (cmdmode) {
#line 1135
        goto _L___18;
      } else {
#line 1135
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 1135
    if (! edvi) {
      _L___18: /* CIL Label */ 
#line 1135
      if ((int )c == (int )edcmds[1]) {
#line 1135
        if (y < 120) {
#line 1136
          y ++;
          {
#line 1137
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1137
            if (x > 0) {
#line 1137
              if (! (! screen[y][x])) {
#line 1137
                goto while_break___8;
              }
            } else {
#line 1137
              goto while_break___8;
            }
#line 1137
            x --;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 1138
          if (! screen[y][x]) {
#line 1139
            screen[y][x] = (char )'\n';
          }
          {
#line 1140
          adjustwin(win, y);
#line 1141
          wmove(win, y - yoffset, x);
#line 1142
          wrefresh(win);
          }
        }
      }
    }
#line 1144
    if (edvi) {
#line 1144
      if (cmdmode) {
#line 1144
        goto _L___20;
      } else {
#line 1144
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 1144
    if (! edvi) {
      _L___20: /* CIL Label */ 
#line 1144
      if ((int )c == (int )edcmds[3]) {
#line 1145
        y = (yoffset + 11) + 1;
#line 1146
        if (y > 120) {
#line 1147
          y = 120;
        }
        {
#line 1148
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1148
          if (y > 0) {
#line 1148
            if (! (! screen[y][0])) {
#line 1148
              goto while_break___9;
            }
          } else {
#line 1148
            goto while_break___9;
          }
#line 1148
          y --;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 1149
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1149
          if (x > 0) {
#line 1149
            if (! (! screen[y][x])) {
#line 1149
              goto while_break___10;
            }
          } else {
#line 1149
            goto while_break___10;
          }
#line 1149
          x --;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 1150
        adjustwin(win, y);
#line 1151
        wmove(win, y - yoffset, x);
#line 1152
        wrefresh(win);
        }
      }
    }
#line 1154
    if (edvi) {
#line 1154
      if (cmdmode) {
#line 1154
        goto _L___22;
      } else {
#line 1154
        goto _L___23;
      }
    } else
    _L___23: /* CIL Label */ 
#line 1154
    if (! edvi) {
      _L___22: /* CIL Label */ 
#line 1154
      if ((int )c == (int )edcmds[9]) {
#line 1155
        y = 120;
        {
#line 1155
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1155
          if (y > 0) {
#line 1155
            if (! (! screen[y][0])) {
#line 1155
              goto while_break___11;
            }
          } else {
#line 1155
            goto while_break___11;
          }
#line 1155
          y --;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1156
        x = 32;
        {
#line 1156
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1156
          if (x > 0) {
#line 1156
            if (! (! screen[y][x])) {
#line 1156
              goto while_break___12;
            }
          } else {
#line 1156
            goto while_break___12;
          }
#line 1156
          x --;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 1157
        adjustwin(win, y);
#line 1158
        wmove(win, y - yoffset, x);
#line 1159
        wrefresh(win);
        }
      }
    }
#line 1161
    if (edvi) {
#line 1161
      if (cmdmode) {
#line 1161
        goto _L___25;
      } else {
#line 1161
        goto _L___26;
      }
    } else
    _L___26: /* CIL Label */ 
#line 1161
    if (! edvi) {
      _L___25: /* CIL Label */ 
#line 1161
      if ((int )c == (int )edcmds[4]) {
#line 1161
        if (y) {
#line 1161
          goto _L___24;
        } else
#line 1161
        if (x) {
          _L___24: /* CIL Label */ 
#line 1162
          if (x) {
#line 1163
            x --;
          } else {
#line 1165
            y --;
#line 1166
            x = 32;
            {
#line 1167
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1167
              if (x > 0) {
#line 1167
                if (! (! screen[y][x])) {
#line 1167
                  goto while_break___13;
                }
              } else {
#line 1167
                goto while_break___13;
              }
#line 1167
              x --;
            }
            while_break___13: /* CIL Label */ ;
            }
          }
          {
#line 1169
          adjustwin(win, y);
#line 1170
          wmove(win, y - yoffset, x);
#line 1171
          wrefresh(win);
          }
        }
      }
    }
#line 1173
    if (edvi) {
#line 1173
      if (cmdmode) {
#line 1173
        goto _L___28;
      } else {
#line 1173
        goto _L___29;
      }
    } else
    _L___29: /* CIL Label */ 
#line 1173
    if (! edvi) {
      _L___28: /* CIL Label */ 
#line 1173
      if ((int )c == (int )edcmds[5]) {
#line 1173
        if (x == 32) {
#line 1173
          if (! (y == 120)) {
#line 1173
            goto _L___27;
          }
        } else {
          _L___27: /* CIL Label */ 
#line 1175
          if (x < 32) {
#line 1176
            x ++;
#line 1177
            if (! screen[y][x]) {
#line 1178
              y ++;
#line 1179
              x = 0;
            }
          } else {
#line 1182
            y ++;
#line 1183
            x = 0;
          }
          {
#line 1185
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1185
            if (x > 0) {
#line 1185
              if (! (! screen[y][x])) {
#line 1185
                goto while_break___14;
              }
            } else {
#line 1185
              goto while_break___14;
            }
#line 1185
            x --;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 1186
          if (! screen[y][x]) {
#line 1187
            screen[y][x] = (char )'\n';
          }
          {
#line 1188
          adjustwin(win, y);
#line 1189
          wmove(win, y - yoffset, x);
#line 1190
          wrefresh(win);
          }
        }
      }
    }
#line 1192
    if (edvi) {
#line 1192
      if (cmdmode) {
#line 1192
        goto _L___30;
      } else {
#line 1192
        goto _L___31;
      }
    } else
    _L___31: /* CIL Label */ 
#line 1192
    if (! edvi) {
      _L___30: /* CIL Label */ 
#line 1192
      if ((int )c == (int )edcmds[7]) {
#line 1193
        x = 32;
        {
#line 1193
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1193
          if (x > 0) {
#line 1193
            if (! (! screen[y][x])) {
#line 1193
              goto while_break___15;
            }
          } else {
#line 1193
            goto while_break___15;
          }
#line 1193
          x --;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1194
        if (x < 32) {
#line 1194
          if (screen[y][x]) {
#line 1194
            if ((int )screen[y][x] != 10) {
#line 1195
              x ++;
            }
          }
        }
        {
#line 1196
        wmove(win, y - yoffset, x);
#line 1197
        wrefresh(win);
        }
      }
    }
#line 1199
    if (edvi) {
#line 1199
      if (cmdmode) {
#line 1199
        goto _L___32;
      } else {
#line 1199
        goto _L___33;
      }
    } else
    _L___33: /* CIL Label */ 
#line 1199
    if (! edvi) {
      _L___32: /* CIL Label */ 
#line 1199
      if ((int )c == (int )edcmds[6]) {
        {
#line 1201
        wmove(win, y - yoffset, 0);
#line 1202
        wrefresh(win);
        }
      }
    }
#line 1021
    if (edvi) {
#line 1021
      if (cmdmode) {
#line 1021
        goto _L___37;
      } else {
#line 1021
        goto _L___38;
      }
    } else
    _L___38: /* CIL Label */ 
#line 1021
    if (! edvi) {
      _L___37: /* CIL Label */ 
#line 1021
      if ((int )c != (int )edcmds[13]) {
#line 1021
        if ((int )c != (int )edcmds[14]) {
#line 1021
          if (! ((int )c != 27)) {
#line 1021
            goto _L___36;
          }
        } else {
#line 1021
          goto _L___36;
        }
      } else {
#line 1021
        goto _L___36;
      }
    } else
    _L___36: /* CIL Label */ 
#line 1021
    if (edvi) {
#line 1021
      if (! (! cmdmode)) {
#line 1021
        goto while_break___2;
      }
    } else {
#line 1021
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1208
  delwin(win);
#line 1209
  notifyClearAscii();
  }
#line 1210
  if ((int )c == (int )edcmds[14]) {
#line 1211
    *out = inp;
  } else {
#line 1213
    y = 120;
    {
#line 1213
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1213
      if (! (y >= 0)) {
#line 1213
        goto while_break___16;
      }
#line 1214
      x = 32;
      {
#line 1214
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 1214
        if (! (x >= 0)) {
#line 1214
          goto while_break___17;
        }
#line 1215
        if ((int )screen[y][x] == 0) {
#line 1216
          screen[y][x] = (char)0;
        } else
#line 1215
        if ((int )screen[y][x] == 10) {
#line 1216
          screen[y][x] = (char)0;
        } else {
#line 1218
          x = 0;
#line 1218
          y = x;
        }
#line 1214
        x --;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 1213
      y --;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 1219
    strcpy(str, "");
#line 1220
    s = str;
#line 1221
    y = 0;
    }
    {
#line 1221
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1221
      if (! (y <= 120)) {
#line 1221
        goto while_break___18;
      }
#line 1222
      x = 0;
      {
#line 1222
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 1222
        if (x <= 32) {
#line 1222
          if (! screen[y][x]) {
#line 1222
            goto while_break___19;
          }
        } else {
#line 1222
          goto while_break___19;
        }
#line 1223
        *s = screen[y][x];
#line 1222
        x ++;
#line 1222
        s ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 1221
      y ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1224
    *s = (char)0;
#line 1225
    if (inp) {
      {
#line 1226
      free(inp);
      }
    }
    {
#line 1227
    *out = dupStr(str);
    }
  }
#line 1230
  return;
}
}
#line 1234 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char *names[17]  = 
#line 1234
  {      (char *)" Size        ",      (char *)" Handicap    ",      (char *)" Komi        ",      (char *)" playerBlack ", 
        (char *)" bLackrank   ",      (char *)" playerWhite ",      (char *)" whIterank   ",      (char *)" Gamename    ", 
        (char *)" Event       ",      (char *)" rouNd       ",      (char *)" Date        ",      (char *)" Place       ", 
        (char *)" Time        ",      (char *)" Result      ",      (char *)" gameComment ",      (char *)" sOurce      ", 
        (char *)" User        "};
#line 1260
int getInfoToChange(void) ;
#line 1260 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char convert[18]  = 
#line 1260
  {      (char )'S',      (char )'H',      (char )'B',      (char )'L', 
        (char )'W',      (char )'I',      (char )'G',      (char )'E', 
        (char )'N',      (char )'D',      (char )'P',      (char )'T', 
        (char )'R',      (char )'C',      (char )'O',      (char )'U', 
        (char )'K',      (char )'\000'};
#line 1261 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static int flag  =    0;
#line 1263 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static WINDOW *wi  ;
#line 1264 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char didhelp  =    (char)0;
#line 1258 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
int getInfoToChange(void) 
{ 
  char ch ;
  int con ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1268
  if (flag == 1) {
#line 1269
    flag = 0;
#line 1270
    return (17);
  }
#line 1272
  if (flag == 2) {
#line 1273
    flag = 0;
#line 1274
    return (19);
  }
  {
#line 1276
  notifyClearAscii();
#line 1277
  notifyMessageAscii((char *)"Press capital letter to edit info field (? for list) or return to exit");
  }
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1279
    tmp = wgetch(stdscr);
#line 1279
    ch = (char )tmp;
    }
#line 1280
    if ((int )ch == 87) {
#line 1281
      flag = 2;
    }
#line 1282
    if ((int )ch == 66) {
#line 1283
      flag = 1;
    }
#line 1284
    if ((int )ch == 63) {
      {
#line 1285
      wi = newwin(0, 0, 0, 0);
#line 1285
      overwrite((WINDOW const   *)stdscr, wi);
      }
#line 1285
      if (stdscr) {
#line 1285
        tmp___0 = (int )stdscr->_maxy + 1;
      } else {
#line 1285
        tmp___0 = -1;
      }
      {
#line 1285
      wtouchln(stdscr, 0, tmp___0, 1);
#line 1286
      ch = (char)0;
      }
      {
#line 1286
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1286
        if (! ((int )ch < 17)) {
#line 1286
          goto while_break___0;
        }
        {
#line 1287
        tmp___1 = wmove(stdscr, (int )ch + 3, 16);
        }
#line 1287
        if (! (tmp___1 == -1)) {
          {
#line 1287
          waddnstr(stdscr, (char const   *)names[ch], -1);
          }
        }
#line 1286
        ch = (char )((int )ch + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1288
      wrefresh(stdscr);
#line 1289
      didhelp = (char)1;
      }
    }
#line 1291
    if ((int )ch == (int )keys[44]) {
      {
#line 1292
      tmp___2 = commentLines();
      }
#line 1292
      if (commentLine < tmp___2 - 12) {
#line 1293
        commentLine += 11;
      }
      {
#line 1294
      showCommentAscii(commentLine);
      }
    } else
#line 1295
    if ((int )ch == (int )keys[(command )45]) {
#line 1296
      if (commentLine) {
        {
#line 1297
        commentLine -= 11;
#line 1298
        showCommentAscii(commentLine);
        }
      }
    }
    {
#line 1300
    con = (int )strlen(convert);
    }
    {
#line 1300
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1300
      tmp___3 = con;
#line 1300
      con --;
#line 1300
      if (! tmp___3) {
#line 1300
        goto while_break___1;
      }
#line 1301
      if ((int )ch == (int )convert[con]) {
        {
#line 1302
        notifyClearAscii();
        }
#line 1303
        return (14 + con);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1305
    if ((int )ch == 10) {
#line 1305
      goto _L;
    } else
#line 1305
    if ((int )ch == 13) {
#line 1305
      goto _L;
    } else
#line 1305
    if ((int )ch == 27) {
      _L: /* CIL Label */ 
      {
#line 1306
      notifyClearAscii();
      }
#line 1307
      if (didhelp) {
        {
#line 1308
        overwrite((WINDOW const   *)wi, stdscr);
#line 1308
        wrefresh(stdscr);
#line 1308
        delwin(wi);
#line 1309
        didhelp = (char)0;
        }
      }
#line 1311
      return (32);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1317 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static char *editName[17]  = 
#line 1317
  {      (char *)"Size: ",      (char *)"Handicap: ",      (char *)"black\'s name",      (char *)"Black\'s rank: ", 
        (char *)"white\'s name",      (char *)"White\'s rank: ",      (char *)"game name",      (char *)"event", 
        (char *)"round",      (char *)"date",      (char *)"place",      (char *)"time", 
        (char *)"result",      (char *)"game comment",      (char *)"source",      (char *)"user", 
        (char *)"Komi: "};
#line 1321 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void editInfo(char *in , char **out , Token prop ) 
{ 
  int tmp ;

  {
#line 1325
  if ((unsigned int )prop == 14U) {
#line 1325
    goto _L;
  } else
#line 1325
  if ((unsigned int )prop == 15U) {
#line 1325
    goto _L;
  } else
#line 1325
  if ((unsigned int )prop == 17U) {
#line 1325
    goto _L;
  } else
#line 1325
  if ((unsigned int )prop == 19U) {
#line 1325
    goto _L;
  } else
#line 1325
  if ((unsigned int )prop == 30U) {
    _L: /* CIL Label */ 
#line 1327
    if (in) {
      {
#line 1328
      free(in);
      }
    }
    {
#line 1329
    tmp = malloc(21);
#line 1329
    *out = (char *)tmp;
#line 1330
    getLine(editName[((unsigned int )prop - 16U) + 2U], *out, 20);
    }
  } else {
    {
#line 1332
    edit(in, out, editName[((unsigned int )prop - 16U) + 2U]);
    }
  }
#line 1333
  return;
}
}
#line 1336 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
static void commentEdit(char *in , char **out ) 
{ 


  {
  {
#line 1339
  edit(in, out, (char *)"comment");
  }
#line 1340
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/mgt-2.31/ascii.c"
interface asciiInterface  = 
#line 1344
     {(char *)0, (char *)0, (char *)0, (int (*)())(& initAscii), (int (*)())(& closeAscii),
    (int (*)())(& refreshAscii), (int (*)())(& plotPieceAscii), (int (*)())(& displayCommentAscii),
    (int (*)())(& clearCommentAscii), (int (*)())(& initBoardAscii), (int (*)())(& clearScreenAscii),
    (int (*)())(& idleAscii), (int (*)())(& drawTreeAscii), (int (*)())(& highlightAscii),
    (int (*)())(& readEnvAscii), (int (*)())(& notifyMessageAscii), (int (*)())(& notifyClearAscii),
    (int (*)())(& getLine), (int (*)())(& setCursor), (int (*)())(& plotMarkAscii),
    (int (*)())(& drawPiece), & getPointAscii, (int (*)())(& commentEdit), (int (*)())(& askYNAscii),
    (int (*)())(& notifyErrorAscii), (int (*)())(& displayCommentAscii), & getInfoToChange,
    (int (*)())(& editInfo)};
#line 1 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
void clearLast(void) ;
#line 3
void doPlace(property *p , pBoard b , piece t ) ;
#line 4
void doProps(property *p , pBoard b ) ;
#line 5
void doPropComment(nodep n ) ;
#line 7
void buildTree(nodep n , pBoard b ) ;
#line 8
void setPiece(pBoard b , int i , int j , piece p ) ;
#line 9
void updateBoard(pBoard dst , pBoard new ) ;
#line 5 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
int lastMoveX  ;
#line 5 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
int lastMoveY  ;
#line 5 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
int moveNum  ;
#line 5 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
int lastTurn  ;
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
coordList *lastletters  =    (coordList *)0;
#line 6 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
coordList *lastmarks  ;
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
coordList *marks  =    (coordList *)0;
#line 8 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
coordList *letters  =    (coordList *)0;
#line 11 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void clearLast(void) 
{ 


  {
#line 13
  lastMoveY = -1;
#line 13
  lastMoveX = lastMoveY;
#line 14
  lastTurn = -1;
#line 15
  moveNum = 0;
#line 16
  curPlayer = (Token )1;
#line 17
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void highlightLast(void) 
{ 


  {
  {
#line 21
  (*(io->highlightLast))(lastMoveX, lastMoveY, moveNum, lastTurn);
  }
#line 22
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
static void setLastMovePos(property *p ) 
{ 
  Token player ;

  {
#line 30
  if ((unsigned int )p->t == 12U) {
#line 30
    player = p->data.player;
  } else {
#line 31
    player = p->t;
  }
#line 33
  if ((unsigned int )player == 0U) {
#line 33
    lastTurn = 1;
#line 33
    curPlayer = (Token )1;
  } else
#line 34
  if ((unsigned int )player == 1U) {
#line 34
    lastTurn = 0;
#line 34
    curPlayer = (Token )0;
  } else {
#line 35
    lastTurn = -1;
  }
#line 37
  if ((unsigned int )p->t == 12U) {
#line 38
    lastMoveY = 25;
#line 38
    lastMoveX = lastMoveY;
  } else
#line 39
  if (p->data.stones) {
#line 40
    lastMoveX = (int )(p->data.stones)->x;
#line 41
    lastMoveY = (int )(p->data.stones)->y;
  } else {
#line 43
    lastMoveY = -1;
#line 43
    lastMoveX = lastMoveY;
  }
#line 44
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void doPlace(property *p , pBoard b , piece t ) 
{ 
  coordList *list ;

  {
#line 54
  list = p->data.stones;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! list) {
#line 55
      goto while_break;
    }
    {
#line 56
    placeStone(b, (int )list->x, (int )list->y, (unsigned int )t);
#line 57
    list = list->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if ((unsigned int )p->t == 1U) {
    {
#line 60
    moveNum ++;
#line 61
    setLastMovePos(p);
    }
  } else
#line 59
  if ((unsigned int )p->t == 0U) {
    {
#line 60
    moveNum ++;
#line 61
    setLastMovePos(p);
    }
  }
#line 64
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void doProps(property *p , pBoard b ) 
{ 


  {
#line 73
  letters = (coordList *)((void *)0);
#line 74
  marks = (coordList *)((void *)0);
#line 75
  lastTurn = -1;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! p) {
#line 76
      goto while_break;
    }
    {
#line 78
    if ((unsigned int )p->t == 0U) {
#line 78
      goto case_0;
    }
#line 82
    if ((unsigned int )p->t == 1U) {
#line 82
      goto case_1;
    }
#line 86
    if ((unsigned int )p->t == 6U) {
#line 86
      goto case_6;
    }
#line 90
    if ((unsigned int )p->t == 7U) {
#line 90
      goto case_7;
    }
#line 94
    if ((unsigned int )p->t == 10U) {
#line 94
      goto case_10;
    }
#line 98
    if ((unsigned int )p->t == 5U) {
#line 98
      goto case_5;
    }
#line 100
    if ((unsigned int )p->t == 12U) {
#line 100
      goto case_12;
    }
#line 104
    if ((unsigned int )p->t == 9U) {
#line 104
      goto case_9;
    }
#line 107
    if ((unsigned int )p->t == 8U) {
#line 107
      goto case_8;
    }
#line 111
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 80
    doPlace(p, b, (piece )2);
    }
#line 81
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 84
    doPlace(p, b, (piece )1);
    }
#line 85
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 88
    doPlace(p, b, (piece )2);
    }
#line 89
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 92
    doPlace(p, b, (piece )1);
    }
#line 93
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 96
    doPlace(p, b, (piece )0);
    }
#line 97
    goto switch_break;
    case_5: /* CIL Label */ 
#line 99
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 101
    moveNum ++;
#line 102
    setLastMovePos(p);
    }
#line 103
    goto switch_break;
    case_9: /* CIL Label */ 
#line 105
    marks = p->data.stones;
#line 106
    goto switch_break;
    case_8: /* CIL Label */ 
#line 108
    letters = p->data.stones;
#line 110
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 114
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void doPropComment(nodep n ) 
{ 
  property *p ;

  {
  {
#line 125
  p = getprop(n, 5);
  }
#line 125
  if (p) {
    {
#line 126
    (*(io->displayComment))(p->data.comment);
    }
  }
#line 127
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void buildTree0(nodep n , pBoard b ) 
{ 


  {
#line 135
  if (n) {
    {
#line 136
    buildTree0(n->parent, b);
#line 138
    doProps(n->p, b);
    }
  }
#line 140
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void buildTree(nodep n , pBoard b ) 
{ 


  {
  {
#line 148
  prisoners[0] = 0;
#line 149
  prisoners[1] = 0;
#line 150
  boardClear(b);
#line 151
  (*(io->clearComment))();
#line 153
  clearLast();
#line 154
  buildTree0(n, b);
#line 155
  doPropComment(n);
  }
#line 156
  return;
}
}
#line 159 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void setPiece(pBoard b , int i , int j , piece p ) 
{ 


  {
  {
#line 164
  boardSet(b, i, j, (unsigned int )p);
#line 165
  (*(io->plotPiece))(b, i, j);
  }
#line 166
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/mgt-2.31/build.c"
void updateBoard(pBoard dst , pBoard new ) 
{ 
  int i ;
  int j ;
  coordList *cl ;
  piece tmp ;
  piece tmp___0 ;
  piece tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 174
  cl = lastmarks;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! cl) {
#line 174
      goto while_break;
    }
    {
#line 175
    (*(io->plotPiece))(new, (int )cl->x, (int )cl->y);
#line 174
    cl = cl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  cl = lastletters;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! cl) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    (*(io->plotPiece))(new, (int )cl->x, (int )cl->y);
#line 177
    cl = cl->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 179
  lastmarks = marks;
#line 180
  lastletters = letters;
#line 181
  i = boardsize;
  {
#line 181
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 181
    tmp___3 = i;
#line 181
    i --;
#line 181
    if (! tmp___3) {
#line 181
      goto while_break___1;
    }
#line 182
    j = boardsize;
    {
#line 182
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 182
      tmp___2 = j;
#line 182
      j --;
#line 182
      if (! tmp___2) {
#line 182
        goto while_break___2;
      }
      {
#line 183
      tmp___0 = boardGet(new, i, j);
#line 183
      tmp___1 = boardGet(dst, i, j);
      }
#line 183
      if ((unsigned int )tmp___0 != (unsigned int )tmp___1) {
        {
#line 184
        tmp = boardGet(new, i, j);
#line 184
        setPiece(dst, i, j, tmp);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 187
  if (marks) {
#line 188
    cl = marks;
    {
#line 188
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 188
      if (! cl) {
#line 188
        goto while_break___3;
      }
      {
#line 189
      (*(io->plotMark))(new, (int )cl->x, (int )cl->y);
#line 188
      cl = cl->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 190
    marks = (coordList *)((void *)0);
  }
#line 192
  if (letters) {
#line 193
    i = 0;
#line 193
    cl = letters;
    {
#line 193
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 193
      if (! cl) {
#line 193
        goto while_break___4;
      }
      {
#line 194
      (*(io->plotLetter))((int )cl->x, (int )cl->y, i % 26 + 97);
#line 193
      cl = cl->next;
#line 193
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 195
    letters = (coordList *)((void *)0);
  }
#line 197
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/mgt-2.31/proto.h"
int okChange(void) ;
#line 14
int okExit(nodep root ) ;
#line 15
nodep search(nodep n ) ;
#line 16
void step(nodep n , pBoard b ) ;
#line 17
void stepDown(nodep n , pBoard b ) ;
#line 18
void doScore(pBoard b , nodep curNode ) ;
#line 19
nodep loadFile(char *filename , nodep root , board *b ) ;
#line 20
nodep makeTutor(nodep nod , Token tok , int x , int y ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 178 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int xcur  ;
#line 178 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
int ycur  ;
#line 179 "/home/wheatley/newnew/temp/mgt-2.31/mgt.h"
Token curPlayer  ;
#line 7 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int change  ;
#line 8 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int madechanges  ;
#line 9 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int searchNodeNum  ;
#line 10 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int ispl  =    0;
#line 12 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int okChange(void) 
{ 
  int tmp ;

  {
#line 14
  if (tutor) {
    {
#line 15
    (*(io->notifyError))("Can\'t edit in tutor mode.");
    }
#line 16
    return (0);
  }
#line 18
  if (! change) {
    {
#line 18
    tmp = (*(io->askYN))("Modify tree", 0);
    }
#line 18
    if (tmp) {
#line 19
      change = 1;
    }
  }
#line 20
  if (change) {
#line 21
    madechanges = 1;
  }
#line 22
  return (change);
}
}
#line 27 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int okExit(nodep root ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 30
  if (mailFlag) {
#line 31
    if (madechanges) {
      {
#line 32
      tmp = (*(io->askYN))("Save", 1);
      }
#line 32
      if (! tmp) {
#line 33
        retVal = 1;
#line 34
        return (1);
      }
      {
#line 36
      tmp___0 = writeTree(saveName, root);
      }
#line 36
      if (tmp___0) {
#line 37
        return (0);
      }
#line 38
      return (1);
    }
#line 40
    retVal = 1;
#line 41
    return (1);
  }
#line 43
  if (madechanges) {
    {
#line 44
    tmp___1 = (*(io->askYN))("Unsaved changes.  Exit without saving", 0);
    }
#line 44
    if (tmp___1) {
#line 45
      return (1);
    }
#line 46
    return (0);
  }
#line 48
  return (1);
}
}
#line 53 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
nodep search(nodep n ) 
{ 
  nodep s ;
  nodep tmp ;
  nodep tmp___0 ;

  {
#line 57
  if (! n) {
#line 58
    return (n);
  } else
#line 57
  if (n->nodeNum == searchNodeNum) {
#line 58
    return (n);
  }
  {
#line 59
  tmp = child(n);
#line 59
  s = search(tmp);
  }
#line 60
  if (s) {
#line 60
    if (s->nodeNum == searchNodeNum) {
#line 61
      return (s);
    }
  }
  {
#line 62
  tmp___0 = nextSibling(n);
#line 62
  s = search(tmp___0);
  }
#line 63
  if (s) {
#line 63
    if (s->nodeNum == searchNodeNum) {
#line 64
      return (s);
    }
  }
#line 65
  return ((nodep )0);
}
}
#line 68 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
void step(nodep n , pBoard b ) 
{ 
  board temp ;

  {
  {
#line 73
  buildTree(n, & temp);
#line 74
  updateBoard(b, & temp);
#line 75
  (*(io->drawTree))(n);
#line 76
  (*(io->refreshIO))();
#line 77
  highlightLast();
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
void stepDown(nodep n , pBoard b ) 
{ 
  board temp ;

  {
  {
#line 85
  (*(io->clearComment))();
#line 86
  copyBoard(b, & temp);
#line 87
  doProps(n->p, & temp);
#line 88
  doPropComment(n);
#line 89
  updateBoard(b, & temp);
#line 90
  (*(io->drawTree))(n);
#line 91
  (*(io->refreshIO))();
#line 92
  highlightLast();
  }
#line 93
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static char *color[2]  = {      (char *)"Black",      (char *)"White"};
#line 102 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
int adjust(int val , int halfk , int ksign ) 
{ 


  {
#line 105
  if (! halfk) {
#line 106
    return (val);
  }
#line 107
  if (val * ksign >= 0) {
#line 108
    return (val);
  }
#line 109
  return (val + ksign);
}
}
#line 212
extern int ( /* missing proto */  abs)() ;
#line 113 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
void doScore(pBoard b , nodep curNode ) 
{ 
  int savepris[2] ;
  int lastpris[2] ;
  char out[200] ;
  command c ;
  property *p ;
  board new ;
  board old ;
  board last ;
  int score[2] ;
  int scored ;
  char komicopy[10] ;
  int intkomi ;
  int halfkomi ;
  int kptr ;
  int komisign ;
  int winner ;
  int diff ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 126
  winner = -1;
#line 127
  scored = 0;
#line 128
  savepris[1] = prisoners[1];
#line 128
  lastpris[1] = savepris[1];
#line 129
  savepris[0] = prisoners[0];
#line 129
  lastpris[0] = savepris[0];
#line 130
  copyBoard(b, & old);
#line 131
  copyBoard(b, & last);
#line 132
  copyBoard(b, & new);
#line 133
  (*(io->notifyClear))();
#line 134
  (*(io->notifyMessage))("return score, space kill, u undo, q quit");
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    tmp = (*(io->getPoint))();
#line 136
    c = (command )tmp;
    }
#line 137
    if ((unsigned int )c == 35U) {
#line 137
      if ((unsigned int )new.b[xcur][ycur] == 2U) {
#line 137
        goto _L;
      } else
#line 137
      if ((unsigned int )new.b[xcur][ycur] == 1U) {
        _L: /* CIL Label */ 
#line 140
        if (scored) {
          {
#line 141
          scored = 0;
#line 142
          copyBoard(& last, & new);
#line 143
          prisoners[1] = lastpris[1];
#line 144
          prisoners[0] = lastpris[0];
          }
        }
        {
#line 146
        copyBoard(& new, & last);
#line 147
        lastpris[1] = prisoners[1];
#line 148
        lastpris[0] = prisoners[0];
#line 149
        removeStones(& new, xcur, ycur);
#line 150
        updateBoard(b, & new);
        }
      }
    }
#line 152
    if ((unsigned int )c == 45U) {
      {
#line 153
      copyBoard(& last, & new);
#line 154
      prisoners[1] = lastpris[1];
#line 155
      prisoners[0] = lastpris[0];
#line 156
      updateBoard(b, & new);
      }
    }
#line 158
    if ((unsigned int )c == 24U) {
#line 158
      if (! scored) {
        {
#line 159
        copyBoard(& new, & last);
#line 160
        lastpris[1] = prisoners[1];
#line 161
        lastpris[0] = prisoners[0];
#line 162
        scoreBoard(& new, score);
#line 163
        updateBoard(b, & new);
        }
#line 164
        if (info[14]) {
#line 165
          halfkomi = 0;
#line 166
          kptr = 0;
          {
#line 166
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 166
            if (! *(info[14] + kptr)) {
#line 166
              goto while_break___0;
            }
#line 167
            if ((int )*(info[14] + kptr) == 46) {
#line 168
              kptr ++;
#line 169
              if ((int )*(info[14] + kptr) >= 49) {
#line 169
                if ((int )*(info[14] + kptr) <= 57) {
#line 170
                  halfkomi = 1;
                }
              }
#line 171
              goto while_break___0;
            }
#line 173
            komicopy[kptr] = *(info[14] + kptr);
#line 166
            kptr ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 175
          komicopy[kptr] = (char)0;
#line 176
          intkomi = atoi(komicopy);
#line 177
          komisign = 0;
          }
#line 178
          if ((int )komicopy[0] == 45) {
#line 179
            komisign = -1;
          } else
#line 178
          if (intkomi < 0) {
#line 179
            komisign = -1;
          } else
#line 180
          if (intkomi > 0) {
#line 181
            komisign = 1;
          } else
#line 180
          if (halfkomi) {
#line 181
            komisign = 1;
          }
          {
#line 182
          sprintf((char */* __restrict  */)(komicopy), (char const   */* __restrict  */)"+ %s ",
                  info[14]);
          }
        } else {
          {
#line 184
          halfkomi = 0;
#line 184
          intkomi = halfkomi;
#line 184
          komisign = intkomi;
#line 185
          strcpy(komicopy, "");
          }
        }
#line 188
        diff = (((score[1] + prisoners[0]) - score[0]) - prisoners[1]) + intkomi;
#line 190
        if (! diff) {
#line 191
          if (halfkomi) {
#line 192
            if (komisign > 0) {
#line 193
              winner = 1;
            } else
#line 194
            if (komisign < 0) {
#line 195
              winner = 0;
            }
          } else {
#line 197
            winner = 2;
          }
        } else
#line 199
        if (diff > 0) {
#line 199
          winner = 1;
        } else {
#line 199
          winner = 0;
        }
        {
#line 202
        diff = adjust(diff, halfkomi, komisign);
        }
#line 203
        if (halfkomi) {
#line 203
          tmp___0 = ".5";
        } else {
#line 203
          tmp___0 = "";
        }
        {
#line 203
        tmp___1 = adjust((score[1] + prisoners[0]) + intkomi, halfkomi, komisign);
        }
#line 203
        if (! diff) {
#line 203
          if (halfkomi) {
#line 203
            if (komisign == -1) {
#line 203
              tmp___2 = "-";
            } else {
#line 203
              tmp___2 = "";
            }
          } else {
#line 203
            tmp___2 = "";
          }
        } else {
#line 203
          tmp___2 = "";
        }
        {
#line 203
        sprintf((char */* __restrict  */)(out), (char const   */* __restrict  */)"Black: %d + %d = %d\n\nWhite: %d + %d %s= %s%d%s\n\n",
                score[0], prisoners[1], score[0] + prisoners[1], score[1], prisoners[0],
                komicopy, tmp___2, tmp___1, tmp___0);
        }
#line 209
        if (winner == 2) {
          {
#line 210
          tmp___3 = (int )strlen(out);
#line 210
          sprintf((char */* __restrict  */)(out + tmp___3), (char const   */* __restrict  */)"Tie game.");
          }
        } else {
#line 212
          if (halfkomi) {
#line 212
            tmp___4 = ".5";
          } else {
#line 212
            tmp___4 = "";
          }
          {
#line 212
          tmp___5 = abs(diff);
#line 212
          tmp___6 = (int )strlen(out);
#line 212
          sprintf((char */* __restrict  */)(out + tmp___6), (char const   */* __restrict  */)"%s wins by %d%s",
                  color[winner], tmp___5, tmp___4);
          }
        }
        {
#line 216
        (*(io->clearComment))();
#line 217
        (*(io->displayComment))(out);
#line 218
        scored = 1;
        }
      }
    }
#line 135
    if (! ((unsigned int )c != 0U)) {
#line 135
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (scored) {
    {
#line 223
    tmp___7 = (*(io->askYN))("Keep comment", 1);
    }
#line 223
    if (tmp___7) {
      {
#line 223
      tmp___8 = okChange();
      }
#line 223
      if (tmp___8) {
        {
#line 224
        replaceComment(curNode, out);
        }
      } else {
#line 223
        goto _L___1;
      }
    } else {
#line 223
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 226
    (*(io->clearComment))();
#line 227
    p = getprop(curNode, 5);
    }
#line 227
    if (p) {
      {
#line 228
      (*(io->displayComment))(p->data.comment);
      }
    }
  }
  {
#line 231
  prisoners[0] = savepris[0];
#line 232
  prisoners[1] = savepris[1];
#line 234
  (*(io->notifyClear))();
#line 235
  updateBoard(b, & old);
  }
#line 236
  return;
}
}
#line 240 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static void initBoard(pBoard b ) 
{ 


  {
  {
#line 245
  boardClear(b);
#line 246
  (*(io->initializeBoard))();
#line 247
  lastmarks = (coordList *)0;
#line 247
  lastletters = lastmarks;
  }
#line 248
  return;
}
}
#line 252 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
nodep loadFile(char *filename , nodep root , board *b ) 
{ 


  {
  {
#line 257
  openfile(filename);
  }
#line 258
  if (input) {
    {
#line 259
    change = 0;
#line 259
    madechanges = change;
#line 260
    freeNode(root);
#line 261
    initNodes();
#line 262
    readInit();
#line 263
    root = parse(0);
#line 264
    fclose(input);
    }
#line 265
    if (! root) {
      {
#line 266
      root = newNode();
      }
    }
    {
#line 267
    initBoard(b);
#line 268
    (*(io->setCursor))(xcur, ycur);
#line 269
    (*(io->refreshIO))();
#line 270
    ycur = 0;
#line 270
    xcur = ycur;
    }
  } else {
    {
#line 272
    (*(io->notifyError))("Unable to load file.");
    }
  }
#line 273
  return (root);
}
}
#line 277 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
nodep makeTutor(nodep nod , Token tok , int x , int y ) 
{ 
  property *prop ;
  boolean tmp ;

  {
#line 283
  if (! nod->child) {
#line 284
    return ((nodep )0);
  }
#line 285
  nod = nod->child;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    prop = getprop(nod, (unsigned int )tok);
    }
#line 286
    if (prop) {
      {
#line 286
      tmp = getCoord(x, y, prop->data.stones);
      }
#line 286
      if (tmp) {
#line 286
        goto while_break;
      }
    }
#line 287
    if (! nod->nextSibling) {
#line 288
      return ((nodep )0);
    }
#line 289
    nod = nod->nextSibling;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return (nod);
}
}
#line 298 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static char *infotitle[11]  = 
#line 298
  {      (char *)"Game name: ",      (char *)"Event: ",      (char *)"rouNd: ",      (char *)"Date: ", 
        (char *)"Place: ",      (char *)"Time limit: ",      (char *)"Result: ",      (char *)"Comment: ", 
        (char *)"sOurce: ",      (char *)"User: ",      (char *)"Komi: "};
#line 316 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static void showinfo(void) 
{ 
  char infoarray[4000] ;
  char *infostr ;
  int p ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 322
  infostr = infoarray;
#line 324
  sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"Size: %d",
          boardsize);
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! *infostr) {
#line 325
      goto while_break;
    }
#line 326
    infostr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (info[14]) {
    {
#line 328
    sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"  Komi: %s",
            info[14]);
    }
    {
#line 329
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 329
      if (! *infostr) {
#line 329
        goto while_break___0;
      }
#line 330
      infostr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 332
  if (handicap) {
    {
#line 333
    sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"  Handicap: %d",
            handicap);
    }
    {
#line 334
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 334
      if (! *infostr) {
#line 334
        goto while_break___1;
      }
#line 335
      infostr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 337
  *infostr = (char )'\n';
#line 338
  infostr ++;
#line 340
  if (info[0]) {
#line 340
    goto _L;
  } else
#line 340
  if (info[1]) {
    _L: /* CIL Label */ 
#line 341
    if (info[1]) {
#line 341
      tmp = (char const   *)info[1];
    } else {
#line 341
      tmp = "";
    }
#line 341
    if (info[0]) {
#line 341
      if (info[1]) {
#line 341
        tmp___0 = ", ";
      } else {
#line 341
        tmp___0 = "";
      }
    } else {
#line 341
      tmp___0 = "";
    }
#line 341
    if (info[0]) {
#line 341
      tmp___1 = (char const   *)info[0];
    } else {
#line 341
      tmp___1 = "";
    }
    {
#line 341
    sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"Black: %s%s%s\n",
            tmp___1, tmp___0, tmp);
    }
    {
#line 344
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 344
      if (! *infostr) {
#line 344
        goto while_break___2;
      }
#line 345
      infostr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 347
  if (info[2]) {
#line 347
    goto _L___0;
  } else
#line 347
  if (info[3]) {
    _L___0: /* CIL Label */ 
#line 348
    if (info[3]) {
#line 348
      tmp___2 = (char const   *)info[3];
    } else {
#line 348
      tmp___2 = "";
    }
#line 348
    if (info[2]) {
#line 348
      if (info[3]) {
#line 348
        tmp___3 = ", ";
      } else {
#line 348
        tmp___3 = "";
      }
    } else {
#line 348
      tmp___3 = "";
    }
#line 348
    if (info[2]) {
#line 348
      tmp___4 = (char const   *)info[2];
    } else {
#line 348
      tmp___4 = "";
    }
    {
#line 348
    sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"White: %s%s%s\n",
            tmp___4, tmp___3, tmp___2);
    }
    {
#line 351
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 351
      if (! *infostr) {
#line 351
        goto while_break___3;
      }
#line 352
      infostr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 354
  p = 0;
  {
#line 354
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 354
    if (! (p <= 9)) {
#line 354
      goto while_break___4;
    }
#line 355
    if (info[p + 4]) {
      {
#line 356
      sprintf((char */* __restrict  */)infostr, (char const   */* __restrict  */)"%s%s\n",
              infotitle[p], info[p + 4]);
      }
      {
#line 357
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 357
        if (! *infostr) {
#line 357
          goto while_break___5;
        }
#line 358
        infostr ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 354
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 361
  *infostr = (char)0;
#line 362
  (*(io->displayInfo))(infoarray);
  }
#line 364
  return;
}
}
#line 370 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static int doinfo(void) 
{ 
  Token change___0 ;
  int sizechanged ;
  int value ;
  char buffer___0[51] ;
  char *current ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 377
  sizechanged = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    showinfo();
#line 380
    tmp = (*(io->getInfoToChange))();
#line 380
    change___0 = (Token )tmp;
    }
#line 381
    if ((unsigned int )change___0 == 32U) {
#line 382
      goto while_break;
    }
    {
#line 383
    tmp___0 = okChange();
    }
#line 383
    if (! tmp___0) {
#line 384
      goto __Cont;
    }
#line 385
    if ((unsigned int )change___0 == 14U) {
      {
#line 386
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%d",
              boardsize);
#line 387
      current = dupStr(buffer___0);
#line 388
      (*(io->editInfo))(current, & current, 14);
      }
#line 389
      if (current) {
        {
#line 390
        value = atoi(current);
        }
#line 391
        if (value > 1) {
#line 391
          if (value < 20) {
#line 392
            if (value != boardsize) {
#line 393
              sizechanged = 1;
            }
#line 394
            boardsize = value;
          }
        }
        {
#line 395
        free(current);
        }
      }
    } else
#line 397
    if ((unsigned int )change___0 == 15U) {
      {
#line 398
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%d",
              handicap);
#line 399
      current = dupStr(buffer___0);
#line 400
      (*(io->editInfo))(current, & current, 15);
      }
#line 401
      if (current) {
        {
#line 402
        handicap = atoi(current);
#line 403
        free(current);
        }
      }
    } else {
      {
#line 407
      (*(io->editInfo))(info[(int )change___0 - 16], & info[(int )change___0 - 16],
                        (unsigned int )change___0);
#line 409
      tmp___1 = (int )strlen(info[(int )change___0 - 16]);
      }
#line 409
      if (! tmp___1) {
        {
#line 410
        free(info[(int )change___0 - 16]);
#line 411
        info[(int )change___0 - 16] = (char *)0;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return (sizechanged);
}
}
#line 424 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
static void savescreen(board *bord ) 
{ 
  char fname[75] ;
  int i ;
  int j ;
  FILE *out ;
  coordList *let ;
  char local[19][19] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 434
  tmp___4 = (*(io->queryStr))("Save screen: ", fname, 74);
  }
#line 434
  if (tmp___4) {
    {
#line 435
    out = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"a+t");
    }
#line 435
    if (out) {
#line 436
      if ((unsigned int )curPlayer == 1U) {
#line 436
        tmp = "Black";
      } else {
#line 436
        tmp = "White";
      }
      {
#line 436
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s to play.\n\n",
              tmp);
#line 437
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)out);
#line 438
      i = 0;
      }
      {
#line 438
      while (1) {
        while_continue: /* CIL Label */ ;
#line 438
        if (! (i < boardsize)) {
#line 438
          goto while_break;
        }
        {
#line 439
        fputc(' ', out);
        }
#line 440
        if (i + 65 >= 73) {
#line 440
          tmp___0 = 1;
        } else {
#line 440
          tmp___0 = 0;
        }
        {
#line 440
        fputc((i + 65) + tmp___0, out);
#line 438
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 442
      fputc('\n', out);
#line 445
      j = 0;
      }
      {
#line 445
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 445
        if (! (j < boardsize)) {
#line 445
          goto while_break___0;
        }
#line 446
        i = 0;
        {
#line 446
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 446
          if (! (i < boardsize)) {
#line 446
            goto while_break___1;
          }
#line 447
          local[i][j] = (char )' ';
          {
#line 450
          if ((unsigned int )bord->b[i][j] == 2U) {
#line 450
            goto case_2;
          }
#line 453
          if ((unsigned int )bord->b[i][j] == 1U) {
#line 453
            goto case_1;
          }
#line 458
          goto switch_default;
          case_2: /* CIL Label */ 
#line 451
          local[i][j] = (char )'O';
#line 452
          goto switch_break;
          case_1: /* CIL Label */ 
#line 454
          local[i][j] = (char )'#';
#line 455
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 459
          local[i][j] = (char )'.';
#line 460
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 446
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 445
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 463
      let = lastletters;
#line 464
      i = 0;
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 465
        if (! let) {
#line 465
          goto while_break___2;
        }
#line 466
        local[let->x][let->y] = (char )(i + 97);
#line 467
        i ++;
#line 468
        i %= 26;
#line 469
        let = let->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 474
      j = 0;
      {
#line 474
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 474
        if (! (j < boardsize)) {
#line 474
          goto while_break___3;
        }
        {
#line 475
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%2d ",
                boardsize - j);
#line 476
        i = 0;
        }
        {
#line 476
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 476
          if (! (i < boardsize)) {
#line 476
            goto while_break___4;
          }
          {
#line 477
          fputc((int )local[i][j], out);
#line 478
          fputc(' ', out);
#line 476
          i ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 481
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%2d",
                boardsize - j);
        }
#line 482
        if (j == boardsize / 2) {
#line 482
          if (prisoners[0]) {
            {
#line 484
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  Captured #: %d   Captured O: %d",
                    prisoners[0], prisoners[1]);
            }
          } else
#line 482
          if (prisoners[1]) {
            {
#line 484
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  Captured #: %d   Captured O: %d",
                    prisoners[0], prisoners[1]);
            }
          }
        }
        {
#line 485
        fputc('\n', out);
#line 474
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 487
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)out);
#line 488
      i = 0;
      }
      {
#line 488
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 488
        if (! (i < boardsize)) {
#line 488
          goto while_break___5;
        }
        {
#line 489
        fputc(' ', out);
        }
#line 490
        if (i + 65 >= 73) {
#line 490
          tmp___1 = 1;
        } else {
#line 490
          tmp___1 = 0;
        }
        {
#line 490
        fputc((i + 65) + tmp___1, out);
#line 488
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 493
      fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)out);
#line 494
      i = 0;
      }
      {
#line 494
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 494
        tmp___3 = commentLines();
        }
#line 494
        if (! (i < tmp___3)) {
#line 494
          goto while_break___6;
        }
        {
#line 495
        tmp___2 = commentGet(i);
#line 495
        fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)out);
#line 496
        _IO_putc('\n', out);
#line 494
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 499
      fclose(out);
      }
    } else {
      {
#line 501
      (*(io->notifyError))("Unable to open file.");
      }
    }
  }
#line 503
  return;
}
}
#line 509 "/home/wheatley/newnew/temp/mgt-2.31/doit.c"
void doit(void) 
{ 
  int quitflg ;
  int i ;
  nodep root ;
  nodep curNode ;
  board theBoard ;
  nodep tNode ;
  command c ;
  property *prop ;
  int tmp ;
  nodep new ;
  char filename[50] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int savex ;
  int savey ;
  int tmp___5 ;
  int tmp___6 ;
  int mod_cur_node ;
  int tmp___7 ;
  nodep save ;
  int mod_cur_node___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  boolean tmp___12 ;
  int tmp___13 ;
  nodep prevNode ;
  int savex___0 ;
  int savey___0 ;
  int tmp___14 ;
  coordList *cl ;
  property *prop___0 ;
  piece tmp___15 ;
  int tmp___16 ;
  coordList *cl___0 ;
  property *prop___1 ;
  piece tmp___17 ;
  int tmp___18 ;
  int sx ;
  int sy ;
  int tmp___19 ;
  int tmp___20 ;
  int sx___0 ;
  int sy___0 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  nodep tBegin ;
  property *tmp___25 ;
  property *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char buf___0[7] ;
  nodep new___0 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char filename___0[50] ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 516
  curPlayer = (Token )1;
#line 517
  quitflg = 0;
#line 517
  ycur = quitflg;
#line 517
  xcur = ycur;
#line 518
  root = (nodep )0;
#line 519
  madechanges = 0;
#line 520
  change = 1;
#line 521
  if ((unsigned long )input != (unsigned long )stdin) {
    {
#line 522
    root = parse(0);
#line 523
    fclose(input);
#line 524
    change = 0;
    }
  }
#line 526
  if (! root) {
    {
#line 527
    root = newNode();
    }
  }
  {
#line 528
  curNode = root;
#line 529
  initBoard(& theBoard);
#line 530
  (*(io->setCursor))(xcur, ycur);
#line 531
  (*(io->refreshIO))();
  }
#line 532
  if (mailFlag) {
    {
#line 533
    while (1) {
      while_continue: /* CIL Label */ ;
#line 533
      if (! curNode->child) {
#line 533
        goto while_break;
      }
      {
#line 534
      curNode = treeDown(curNode);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 535
    change = 1;
  }
  {
#line 537
  step(curNode, & theBoard);
  }
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! (! quitflg)) {
#line 538
      goto while_break___0;
    }
    {
#line 543
    prop = getprop(curNode, 13);
    }
#line 543
    if (prop) {
#line 544
      curPlayer = prop->data.player;
#line 545
      ispl = 1;
    } else {
#line 547
      ispl = 0;
    }
    {
#line 549
    tmp = (*(io->idle))(curNode);
#line 549
    c = (command )tmp;
    }
#line 551
    if ((int )c >= (int )((command )76)) {
#line 551
      if ((int )c < (int )((command )127)) {
        {
#line 553
        new = nthChild(curNode, (int )c - (int )((command )76));
        }
#line 554
        if (new) {
          {
#line 555
          curNode = nthChild(curNode, (int )c - (int )((command )76));
#line 556
          step(curNode, & theBoard);
          }
        }
      } else {
#line 551
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 560
      if ((unsigned int )c == 19U) {
#line 560
        goto case_19;
      }
#line 569
      if ((unsigned int )c == 28U) {
#line 569
        goto case_28;
      }
#line 580
      if ((unsigned int )c == 29U) {
#line 580
        goto case_29;
      }
#line 589
      if ((unsigned int )c == 34U) {
#line 589
        goto case_34;
      }
#line 598
      if ((unsigned int )c == 33U) {
#line 598
        goto case_33;
      }
#line 601
      if ((unsigned int )c == 30U) {
#line 601
        goto case_30;
      }
#line 613
      if ((unsigned int )c == (unsigned int )((command )75)) {
#line 613
        goto case_75;
      }
#line 615
      if ((unsigned int )c == 26U) {
#line 615
        goto case_26;
      }
#line 619
      if ((unsigned int )c == 25U) {
#line 619
        goto case_25;
      }
#line 630
      if ((unsigned int )c == 27U) {
#line 630
        goto case_27;
      }
#line 633
      if ((unsigned int )c == 32U) {
#line 633
        goto case_32;
      }
#line 636
      if ((unsigned int )c == 35U) {
#line 636
        goto case_35;
      }
#line 660
      if ((unsigned int )c == 15U) {
#line 660
        goto case_15;
      }
#line 666
      if ((unsigned int )c == 22U) {
#line 666
        goto case_22;
      }
#line 672
      if ((unsigned int )c == 20U) {
#line 672
        goto case_20;
      }
#line 680
      if ((unsigned int )c == 16U) {
#line 680
        goto case_16;
      }
#line 698
      if ((unsigned int )c == 13U) {
#line 698
        goto case_13;
      }
#line 715
      if ((unsigned int )c == 14U) {
#line 715
        goto case_14;
      }
#line 734
      if ((unsigned int )c == 17U) {
#line 734
        goto case_17;
      }
#line 756
      if ((unsigned int )c == 18U) {
#line 756
        goto case_18;
      }
#line 774
      if ((unsigned int )c == 21U) {
#line 774
        goto case_21;
      }
#line 780
      if ((unsigned int )c == 23U) {
#line 780
        goto case_23;
      }
#line 786
      if ((unsigned int )c == 1U) {
#line 786
        goto case_1;
      }
#line 793
      if ((unsigned int )c == 2U) {
#line 793
        goto case_2;
      }
#line 797
      if ((unsigned int )c == 3U) {
#line 797
        goto case_3;
      }
#line 806
      if ((unsigned int )c == 4U) {
#line 806
        goto case_4;
      }
#line 810
      if ((unsigned int )c == 7U) {
#line 810
        goto case_7;
      }
#line 829
      if ((unsigned int )c == 8U) {
#line 829
        goto case_8;
      }
#line 838
      if ((unsigned int )c == 10U) {
#line 838
        goto case_10;
      }
#line 846
      if ((unsigned int )c == 9U) {
#line 846
        goto case_9;
      }
#line 856
      if ((unsigned int )c == 5U) {
#line 856
        goto case_5;
      }
#line 862
      if ((unsigned int )c == 6U) {
#line 862
        goto case_6;
      }
#line 866
      if ((unsigned int )c == 24U) {
#line 866
        goto case_24;
      }
#line 869
      if ((unsigned int )c == 11U) {
#line 869
        goto case_11;
      }
#line 891
      if ((unsigned int )c == 0U) {
#line 891
        goto case_0;
      }
#line 895
      if ((unsigned int )c == 12U) {
#line 895
        goto case_12;
      }
#line 909
      if ((unsigned int )c == 31U) {
#line 909
        goto case_31;
      }
#line 912
      if ((unsigned int )c == 39U) {
#line 912
        goto case_39;
      }
#line 917
      if ((unsigned int )c == 40U) {
#line 917
        goto case_40;
      }
#line 922
      if ((unsigned int )c == 42U) {
#line 922
        goto case_42;
      }
#line 927
      if ((unsigned int )c == 37U) {
#line 927
        goto case_37;
      }
#line 932
      if ((unsigned int )c == 41U) {
#line 932
        goto case_41;
      }
#line 938
      if ((unsigned int )c == 43U) {
#line 938
        goto case_43;
      }
#line 944
      if ((unsigned int )c == 36U) {
#line 944
        goto case_36;
      }
#line 950
      if ((unsigned int )c == 38U) {
#line 950
        goto case_38;
      }
#line 559
      goto switch_break;
      case_19: /* CIL Label */ 
      {
#line 561
      tmp___1 = okExit(root);
      }
#line 561
      if (tmp___1) {
        {
#line 563
        tmp___0 = (*(io->queryStr))("Load file? ", filename, 48);
        }
#line 563
        if (tmp___0) {
          {
#line 564
          curNode = loadFile(filename, root, & theBoard);
#line 564
          root = curNode;
#line 565
          step(curNode, & theBoard);
          }
        }
      }
#line 568
      goto switch_break;
      case_28: /* CIL Label */ 
#line 571
      if (currentfile > 0) {
        {
#line 571
        tmp___2 = okExit(root);
        }
#line 571
        if (tmp___2) {
          {
#line 572
          currentfile --;
#line 573
          curNode = loadFile(files[currentfile], root, & theBoard);
#line 573
          root = curNode;
#line 574
          step(curNode, & theBoard);
          }
        } else {
          {
#line 576
          (*(io->notifyError))("No previous file.");
          }
        }
      } else {
        {
#line 576
        (*(io->notifyError))("No previous file.");
        }
      }
#line 577
      goto switch_break;
      case_29: /* CIL Label */ 
#line 581
      if (currentfile + 1 < filecount) {
        {
#line 581
        tmp___3 = okExit(root);
        }
#line 581
        if (tmp___3) {
          {
#line 582
          currentfile ++;
#line 583
          curNode = loadFile(files[currentfile], root, & theBoard);
#line 583
          root = curNode;
#line 584
          step(curNode, & theBoard);
          }
        } else {
          {
#line 586
          (*(io->notifyError))("No next file.");
          }
        }
      } else {
        {
#line 586
        (*(io->notifyError))("No next file.");
        }
      }
#line 587
      goto switch_break;
      case_34: /* CIL Label */ 
      {
#line 590
      tmp___4 = doinfo();
      }
#line 590
      if (tmp___4) {
        {
#line 591
        initBoard(& theBoard);
        }
      }
      {
#line 592
      step(curNode, & theBoard);
      }
#line 593
      if (xcur >= boardsize) {
#line 594
        xcur = boardsize - 1;
      }
#line 595
      if (ycur >= boardsize) {
#line 596
        ycur = boardsize - 1;
      }
#line 597
      goto switch_break;
      case_33: /* CIL Label */ 
      {
#line 599
      savescreen(& theBoard);
      }
#line 600
      goto switch_break;
      case_30: /* CIL Label */ 
      {
#line 604
      savex = xcur;
#line 605
      savey = ycur;
#line 606
      initBoard(& theBoard);
#line 607
      (*(io->refreshIO))();
#line 608
      step(curNode, & theBoard);
#line 609
      xcur = savex;
#line 610
      ycur = savey;
      }
#line 611
      goto switch_break;
      case_75: /* CIL Label */ 
#line 614
      goto switch_break;
      case_26: /* CIL Label */ 
      {
#line 616
      tmp___6 = okChange();
      }
#line 616
      if (tmp___6) {
#line 617
        if ((unsigned int )curPlayer == 1U) {
#line 617
          tmp___5 = 0;
        } else {
#line 617
          tmp___5 = 1;
        }
        {
#line 617
        addPlayer(curNode, tmp___5);
        }
      }
#line 618
      goto switch_break;
      case_25: /* CIL Label */ 
      {
#line 619
      tmp___7 = okChange();
      }
#line 619
      if (tmp___7) {
        {
#line 621
        mod_cur_node = passMove(curNode, (unsigned int )curPlayer);
        }
#line 622
        if (mod_cur_node) {
          {
#line 623
          step(curNode, & theBoard);
          }
        } else {
          {
#line 625
          curNode = treeDown(curNode);
#line 626
          stepDown(curNode, & theBoard);
          }
        }
      }
#line 629
      goto switch_break;
      case_27: /* CIL Label */ 
#line 631
      if ((unsigned int )curPlayer == 1U) {
#line 631
        curPlayer = (Token )0;
      } else {
#line 631
        curPlayer = (Token )1;
      }
#line 632
      goto switch_break;
      case_32: /* CIL Label */ 
#line 634
      tutor = ! tutor;
#line 635
      goto switch_break;
      case_35: /* CIL Label */ 
#line 637
      if (tutor) {
        {
#line 639
        save = curNode;
#line 640
        curNode = makeTutor(curNode, curPlayer, xcur, ycur);
        }
#line 640
        if (curNode) {
          {
#line 641
          step(curNode, & theBoard);
          }
        } else {
          {
#line 643
          (*(io->notifyError))("Wrong move.");
#line 644
          curNode = save;
          }
        }
      } else {
        {
#line 647
        tmp___8 = okChange();
        }
#line 647
        if (tmp___8) {
          {
#line 647
          tmp___9 = legal(& theBoard, curNode, (unsigned int )curPlayer, xcur, ycur);
          }
#line 647
          if (tmp___9) {
            {
#line 649
            mod_cur_node___0 = makeMove(curNode, (unsigned int )curPlayer, xcur, ycur);
            }
#line 650
            if (mod_cur_node___0) {
              {
#line 651
              step(curNode, & theBoard);
              }
            } else {
              {
#line 653
              curNode = treeDown(curNode);
#line 654
              stepDown(curNode, & theBoard);
              }
            }
          }
        }
      }
#line 659
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 661
      tmp___10 = okChange();
      }
#line 661
      if (tmp___10) {
        {
#line 662
        makeVariation(curNode);
#line 663
        step(curNode, & theBoard);
        }
      }
#line 665
      goto switch_break;
      case_22: /* CIL Label */ 
      {
#line 667
      tmp___11 = okChange();
      }
#line 667
      if (tmp___11) {
        {
#line 668
        deleteNode(& curNode);
#line 669
        step(curNode, & theBoard);
        }
      }
#line 671
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 673
      tmp___13 = okChange();
      }
#line 673
      if (tmp___13) {
        {
#line 674
        tmp___12 = pasteTree(curNode);
        }
#line 674
        if (tmp___12) {
          {
#line 675
          step(curNode, & theBoard);
          }
        } else {
          {
#line 677
          (*(io->notifyError))("Nothing to paste.");
          }
        }
      }
#line 678
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 681
      tmp___14 = okChange();
      }
#line 681
      if (tmp___14) {
        {
#line 684
        savex___0 = xcur;
#line 685
        savey___0 = ycur;
#line 686
        prevNode = curNode->parent;
#line 687
        cutTree(curNode);
#line 688
        curNode = prevNode;
        }
#line 689
        if (! curNode) {
          {
#line 690
          initNodes();
#line 691
          curNode = newNode();
#line 691
          root = curNode;
          }
        }
        {
#line 693
        step(curNode, & theBoard);
#line 694
        xcur = savex___0;
#line 695
        ycur = savey___0;
        }
#line 696
        goto switch_break;
      }
      case_13: /* CIL Label */ 
      {
#line 699
      tmp___16 = okChange();
      }
#line 699
      if (tmp___16) {
        {
#line 702
        tmp___15 = boardGet(& theBoard, xcur, ycur);
        }
#line 702
        if ((unsigned int )tmp___15 == 1U) {
          {
#line 703
          addStone(curNode, 10, xcur, ycur);
#line 704
          setPiece(& theBoard, xcur, ycur, 0);
          }
        } else {
          {
#line 706
          addStone(curNode, 7, xcur, ycur);
#line 707
          setPiece(& theBoard, xcur, ycur, 1);
          }
        }
        {
#line 709
        prop___0 = getprop(curNode, 8);
        }
#line 709
        if (prop___0) {
#line 710
          lastletters = prop___0->data.stones;
        }
#line 711
        i = 0;
#line 711
        cl = lastletters;
        {
#line 711
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 711
          if (! cl) {
#line 711
            goto while_break___1;
          }
          {
#line 712
          (*(io->plotLetter))((int )cl->x, (int )cl->y, i % 26 + 97);
#line 711
          i ++;
#line 711
          cl = cl->next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 714
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 716
      tmp___18 = okChange();
      }
#line 716
      if (tmp___18) {
        {
#line 719
        tmp___17 = boardGet(& theBoard, xcur, ycur);
        }
#line 719
        if ((unsigned int )tmp___17 == 2U) {
          {
#line 720
          addStone(curNode, 10, xcur, ycur);
#line 721
          setPiece(& theBoard, xcur, ycur, 0);
          }
        } else {
          {
#line 723
          addStone(curNode, 6, xcur, ycur);
#line 724
          setPiece(& theBoard, xcur, ycur, 2);
          }
        }
        {
#line 726
        prop___1 = getprop(curNode, 8);
        }
#line 726
        if (prop___1) {
#line 727
          lastletters = prop___1->data.stones;
        }
#line 729
        i = 0;
#line 729
        cl___0 = lastletters;
        {
#line 729
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 729
          if (! cl___0) {
#line 729
            goto while_break___2;
          }
          {
#line 730
          (*(io->plotLetter))((int )cl___0->x, (int )cl___0->y, i % 26 + 97);
#line 729
          i ++;
#line 729
          cl___0 = cl___0->next;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 733
      goto switch_break;
      case_17: /* CIL Label */ 
      {
#line 735
      tmp___20 = okChange();
      }
#line 735
      if (tmp___20) {
        {
#line 741
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 741
          if (! lastletters) {
#line 741
            goto while_break___3;
          }
          {
#line 742
          (*(io->plotPiece))(& theBoard, (int )lastletters->x, (int )lastletters->y);
#line 741
          lastletters = lastletters->next;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 743
        lastletters = (coordList *)0;
#line 745
        sx = xcur;
#line 746
        sy = ycur;
#line 749
        tmp___19 = addMark(curNode, 8, xcur, ycur);
        }
#line 749
        if (tmp___19) {
          {
#line 750
          (*(io->plotPiece))(& theBoard, xcur, ycur);
          }
        }
        {
#line 751
        stepDown(curNode, & theBoard);
#line 752
        xcur = sx;
#line 753
        ycur = sy;
        }
      }
#line 755
      goto switch_break;
      case_18: /* CIL Label */ 
      {
#line 757
      tmp___22 = okChange();
      }
#line 757
      if (tmp___22) {
        {
#line 760
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 760
          if (! lastmarks) {
#line 760
            goto while_break___4;
          }
          {
#line 761
          (*(io->plotPiece))(& theBoard, (int )lastmarks->x, (int )lastmarks->y);
#line 760
          lastmarks = lastmarks->next;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 762
        lastmarks = (coordList *)0;
#line 764
        sx___0 = xcur;
#line 765
        sy___0 = ycur;
#line 766
        tmp___21 = addMark(curNode, 9, xcur, ycur);
        }
#line 766
        if (tmp___21) {
          {
#line 767
          (*(io->plotPiece))(& theBoard, xcur, ycur);
          }
        }
        {
#line 769
        stepDown(curNode, & theBoard);
#line 770
        xcur = sx___0;
#line 771
        ycur = sy___0;
        }
      }
#line 773
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 775
      tmp___23 = okChange();
      }
#line 775
      if (tmp___23) {
        {
#line 776
        edComment(curNode);
#line 777
        step(curNode, & theBoard);
        }
      }
#line 779
      goto switch_break;
      case_23: /* CIL Label */ 
      {
#line 781
      tmp___24 = okChange();
      }
#line 781
      if (tmp___24) {
        {
#line 782
        makeName(curNode);
#line 783
        step(curNode, & theBoard);
        }
      }
#line 785
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 787
      tNode = treeDown(curNode);
      }
#line 788
      if ((unsigned long )tNode != (unsigned long )curNode) {
        {
#line 789
        curNode = tNode;
#line 790
        stepDown(curNode, & theBoard);
        }
      }
#line 792
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 794
      curNode = treeUp(curNode);
#line 795
      step(curNode, & theBoard);
      }
#line 796
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 798
      tNode = treeNext(curNode);
      }
#line 799
      if ((unsigned long )tNode->parent == (unsigned long )curNode) {
        {
#line 800
        stepDown(tNode, & theBoard);
        }
      } else {
        {
#line 802
        step(tNode, & theBoard);
        }
      }
#line 804
      curNode = tNode;
#line 805
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 807
      curNode = treeLast(curNode);
#line 808
      step(curNode, & theBoard);
      }
#line 809
      goto switch_break;
      case_7: /* CIL Label */ 
#line 813
      tBegin = curNode;
#line 814
      tNode = curNode;
      {
#line 815
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 816
        tNode = treeNext(tNode);
        }
#line 815
        if ((unsigned long )tNode != (unsigned long )tBegin) {
          {
#line 815
          tmp___25 = getprop(tNode, 5);
          }
#line 815
          if (tmp___25) {
#line 815
            goto while_break___5;
          }
        } else {
#line 815
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 819
      if ((unsigned long )tNode != (unsigned long )curNode) {
#line 820
        if ((unsigned long )tNode->parent == (unsigned long )curNode) {
          {
#line 821
          stepDown(tNode, & theBoard);
          }
        } else {
          {
#line 823
          step(tNode, & theBoard);
          }
        }
#line 825
        curNode = tNode;
      }
#line 828
      goto switch_break;
      case_8: /* CIL Label */ 
#line 830
      tNode = curNode;
#line 831
      curNode = curNode;
      {
#line 832
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 833
        curNode = treeLast(curNode);
        }
#line 832
        if ((unsigned long )curNode != (unsigned long )tNode) {
          {
#line 832
          tmp___26 = getprop(curNode, 5);
          }
#line 832
          if (tmp___26) {
#line 832
            goto while_break___6;
          }
        } else {
#line 832
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 836
      step(curNode, & theBoard);
      }
#line 837
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 839
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 839
        if (! curNode->parent) {
#line 839
          goto while_break___7;
        }
        {
#line 840
        curNode = curNode->parent;
#line 841
        tmp___27 = treeCountSiblings(curNode);
        }
#line 841
        if (tmp___27 > 1) {
#line 842
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 844
      step(curNode, & theBoard);
      }
#line 845
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 848
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 848
        if (! curNode->child) {
#line 848
          goto while_break___8;
        }
        {
#line 849
        curNode = treeDown(curNode);
#line 850
        tmp___28 = treeCountSiblings(curNode);
        }
#line 850
        if (tmp___28 > 1) {
#line 851
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 853
      step(curNode, & theBoard);
      }
#line 855
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 857
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 857
        if (! curNode->child) {
#line 857
          goto while_break___9;
        }
        {
#line 858
        curNode = treeDown(curNode);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 860
      step(curNode, & theBoard);
      }
#line 861
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 863
      curNode = root;
#line 864
      step(curNode, & theBoard);
      }
#line 865
      goto switch_break;
      case_24: /* CIL Label */ 
      {
#line 867
      doScore(& theBoard, curNode);
      }
#line 868
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 873
      tmp___30 = (*(io->queryStr))("Move to node # ?", buf___0, 5);
      }
#line 873
      if (tmp___30) {
        {
#line 874
        searchNodeNum = atoi(buf___0);
        }
#line 875
        if (searchNodeNum == 0) {
          {
#line 875
          tmp___29 = strcmp(buf___0, "0");
          }
#line 875
          if (tmp___29) {
#line 876
            searchNodeNum = -1;
          }
        }
#line 877
        if (searchNodeNum >= 0) {
          {
#line 878
          new___0 = search(root);
          }
#line 878
          if (new___0) {
            {
#line 879
            curNode = new___0;
#line 880
            step(curNode, & theBoard);
#line 881
            (*(io->notifyClear))();
            }
          } else {
            {
#line 883
            (*(io->notifyClear))();
#line 884
            (*(io->notifyError))("Node not found.");
            }
          }
        }
      }
#line 890
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 892
      tmp___31 = okExit(root);
      }
#line 892
      if (tmp___31) {
#line 893
        quitflg ++;
      }
#line 894
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 898
      tmp___35 = (*(io->queryStr))("Save name? ", filename___0, 48);
      }
#line 898
      if (tmp___35) {
        {
#line 899
        tmp___34 = strcmp("*", filename___0);
        }
#line 899
        if (tmp___34) {
          {
#line 903
          tmp___33 = writeTree(filename___0, root);
          }
#line 903
          if (! tmp___33) {
#line 904
            madechanges = 0;
          }
        } else {
          {
#line 900
          tmp___32 = writeTree(name_buf, root);
          }
#line 900
          if (! tmp___32) {
#line 901
            madechanges = 0;
          }
        }
      }
#line 908
      goto switch_break;
      case_31: /* CIL Label */ 
#line 910
      saveShort = ! saveShort;
#line 911
      goto switch_break;
      case_39: /* CIL Label */ 
      {
#line 913
      xcur = ((xcur - 1) + boardsize) % boardsize;
#line 914
      (*(io->setCursor))(xcur, ycur);
#line 915
      (*(io->refreshIO))();
      }
#line 916
      goto switch_break;
      case_40: /* CIL Label */ 
      {
#line 918
      xcur = (xcur + 1) % boardsize;
#line 919
      (*(io->setCursor))(xcur, ycur);
#line 920
      (*(io->refreshIO))();
      }
#line 921
      goto switch_break;
      case_42: /* CIL Label */ 
      {
#line 923
      ycur = ((ycur - 1) + boardsize) % boardsize;
#line 924
      (*(io->setCursor))(xcur, ycur);
#line 925
      (*(io->refreshIO))();
      }
#line 926
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 928
      ycur = (ycur + 1) % boardsize;
#line 929
      (*(io->setCursor))(xcur, ycur);
#line 930
      (*(io->refreshIO))();
      }
#line 931
      goto switch_break;
      case_41: /* CIL Label */ 
      {
#line 933
      ycur = ((ycur - 1) + boardsize) % boardsize;
#line 934
      xcur = ((xcur - 1) + boardsize) % boardsize;
#line 935
      (*(io->setCursor))(xcur, ycur);
#line 936
      (*(io->refreshIO))();
      }
#line 937
      goto switch_break;
      case_43: /* CIL Label */ 
      {
#line 939
      xcur = (xcur + 1) % boardsize;
#line 940
      ycur = ((ycur - 1) + boardsize) % boardsize;
#line 941
      (*(io->setCursor))(xcur, ycur);
#line 942
      (*(io->refreshIO))();
      }
#line 943
      goto switch_break;
      case_36: /* CIL Label */ 
      {
#line 945
      xcur = ((xcur - 1) + boardsize) % boardsize;
#line 946
      ycur = (ycur + 1) % boardsize;
#line 947
      (*(io->setCursor))(xcur, ycur);
#line 948
      (*(io->refreshIO))();
      }
#line 949
      goto switch_break;
      case_38: /* CIL Label */ 
      {
#line 951
      xcur = (xcur + 1) % boardsize;
#line 952
      ycur = (ycur + 1) % boardsize;
#line 953
      (*(io->setCursor))(xcur, ycur);
#line 954
      (*(io->refreshIO))();
      }
#line 955
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 958
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 538
extern int getchar(void) ;
#line 580
extern int putchar(int __c ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
