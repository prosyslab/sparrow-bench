/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 80 "/usr/include/glob.h"
struct stat;
#line 82
struct dirent;
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_60 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , struct stat * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , struct stat * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_60 glob_t;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 22 "/usr/include/linux/input.h"
struct input_event {
   struct timeval time ;
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
struct evdev {
   char *name ;
   int fd ;
   struct evdev *next ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
typedef struct evdev evdev_t;
#line 54 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
struct client {
   int fd ;
   struct client *next ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
typedef struct client client_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 524 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/names.h"
static char const   *KEY_NAME[767]  = 
#line 524 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/names.h"
  {      "KEY_RESERVED",      "KEY_ESC",      "KEY_1",      "KEY_2", 
        "KEY_3",      "KEY_4",      "KEY_5",      "KEY_6", 
        "KEY_7",      "KEY_8",      "KEY_9",      "KEY_0", 
        "KEY_MINUS",      "KEY_EQUAL",      "KEY_BACKSPACE",      "KEY_TAB", 
        "KEY_Q",      "KEY_W",      "KEY_E",      "KEY_R", 
        "KEY_T",      "KEY_Y",      "KEY_U",      "KEY_I", 
        "KEY_O",      "KEY_P",      "KEY_LEFTBRACE",      "KEY_RIGHTBRACE", 
        "KEY_ENTER",      "KEY_LEFTCTRL",      "KEY_A",      "KEY_S", 
        "KEY_D",      "KEY_F",      "KEY_G",      "KEY_H", 
        "KEY_J",      "KEY_K",      "KEY_L",      "KEY_SEMICOLON", 
        "KEY_APOSTROPHE",      "KEY_GRAVE",      "KEY_LEFTSHIFT",      "KEY_BACKSLASH", 
        "KEY_Z",      "KEY_X",      "KEY_C",      "KEY_V", 
        "KEY_B",      "KEY_N",      "KEY_M",      "KEY_COMMA", 
        "KEY_DOT",      "KEY_SLASH",      "KEY_RIGHTSHIFT",      "KEY_KPASTERISK", 
        "KEY_LEFTALT",      "KEY_SPACE",      "KEY_CAPSLOCK",      "KEY_F1", 
        "KEY_F2",      "KEY_F3",      "KEY_F4",      "KEY_F5", 
        "KEY_F6",      "KEY_F7",      "KEY_F8",      "KEY_F9", 
        "KEY_F10",      "KEY_NUMLOCK",      "KEY_SCROLLLOCK",      "KEY_KP7", 
        "KEY_KP8",      "KEY_KP9",      "KEY_KPMINUS",      "KEY_KP4", 
        "KEY_KP5",      "KEY_KP6",      "KEY_KPPLUS",      "KEY_KP1", 
        "KEY_KP2",      "KEY_KP3",      "KEY_KP0",      "KEY_KPDOT", 
        (char const   *)0,      "KEY_ZENKAKUHANKAKU",      "KEY_102ND",      "KEY_F11", 
        "KEY_F12",      "KEY_RO",      "KEY_KATAKANA",      "KEY_HIRAGANA", 
        "KEY_HENKAN",      "KEY_KATAKANAHIRAGANA",      "KEY_MUHENKAN",      "KEY_KPJPCOMMA", 
        "KEY_KPENTER",      "KEY_RIGHTCTRL",      "KEY_KPSLASH",      "KEY_SYSRQ", 
        "KEY_RIGHTALT",      "KEY_LINEFEED",      "KEY_HOME",      "KEY_UP", 
        "KEY_PAGEUP",      "KEY_LEFT",      "KEY_RIGHT",      "KEY_END", 
        "KEY_DOWN",      "KEY_PAGEDOWN",      "KEY_INSERT",      "KEY_DELETE", 
        "KEY_MACRO",      "KEY_MUTE",      "KEY_VOLUMEDOWN",      "KEY_VOLUMEUP", 
        "KEY_POWER",      "KEY_KPEQUAL",      "KEY_KPPLUSMINUS",      "KEY_PAUSE", 
        "KEY_SCALE",      "KEY_KPCOMMA",      "KEY_HANGEUL",      "KEY_HANJA", 
        "KEY_YEN",      "KEY_LEFTMETA",      "KEY_RIGHTMETA",      "KEY_COMPOSE", 
        "KEY_STOP",      "KEY_AGAIN",      "KEY_PROPS",      "KEY_UNDO", 
        "KEY_FRONT",      "KEY_COPY",      "KEY_OPEN",      "KEY_PASTE", 
        "KEY_FIND",      "KEY_CUT",      "KEY_HELP",      "KEY_MENU", 
        "KEY_CALC",      "KEY_SETUP",      "KEY_SLEEP",      "KEY_WAKEUP", 
        "KEY_FILE",      "KEY_SENDFILE",      "KEY_DELETEFILE",      "KEY_XFER", 
        "KEY_PROG1",      "KEY_PROG2",      "KEY_WWW",      "KEY_MSDOS", 
        "KEY_COFFEE",      "KEY_DIRECTION",      "KEY_CYCLEWINDOWS",      "KEY_MAIL", 
        "KEY_BOOKMARKS",      "KEY_COMPUTER",      "KEY_BACK",      "KEY_FORWARD", 
        "KEY_CLOSECD",      "KEY_EJECTCD",      "KEY_EJECTCLOSECD",      "KEY_NEXTSONG", 
        "KEY_PLAYPAUSE",      "KEY_PREVIOUSSONG",      "KEY_STOPCD",      "KEY_RECORD", 
        "KEY_REWIND",      "KEY_PHONE",      "KEY_ISO",      "KEY_CONFIG", 
        "KEY_HOMEPAGE",      "KEY_REFRESH",      "KEY_EXIT",      "KEY_MOVE", 
        "KEY_EDIT",      "KEY_SCROLLUP",      "KEY_SCROLLDOWN",      "KEY_KPLEFTPAREN", 
        "KEY_KPRIGHTPAREN",      "KEY_NEW",      "KEY_REDO",      "KEY_F13", 
        "KEY_F14",      "KEY_F15",      "KEY_F16",      "KEY_F17", 
        "KEY_F18",      "KEY_F19",      "KEY_F20",      "KEY_F21", 
        "KEY_F22",      "KEY_F23",      "KEY_F24",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_PLAYCD",      "KEY_PAUSECD",      "KEY_PROG3",      "KEY_PROG4", 
        "KEY_DASHBOARD",      "KEY_SUSPEND",      "KEY_CLOSE",      "KEY_PLAY", 
        "KEY_FASTFORWARD",      "KEY_BASSBOOST",      "KEY_PRINT",      "KEY_HP", 
        "KEY_CAMERA",      "KEY_SOUND",      "KEY_QUESTION",      "KEY_EMAIL", 
        "KEY_CHAT",      "KEY_SEARCH",      "KEY_CONNECT",      "KEY_FINANCE", 
        "KEY_SPORT",      "KEY_SHOP",      "KEY_ALTERASE",      "KEY_CANCEL", 
        "KEY_BRIGHTNESSDOWN",      "KEY_BRIGHTNESSUP",      "KEY_MEDIA",      "KEY_SWITCHVIDEOMODE", 
        "KEY_KBDILLUMTOGGLE",      "KEY_KBDILLUMDOWN",      "KEY_KBDILLUMUP",      "KEY_SEND", 
        "KEY_REPLY",      "KEY_FORWARDMAIL",      "KEY_SAVE",      "KEY_DOCUMENTS", 
        "KEY_BATTERY",      "KEY_BLUETOOTH",      "KEY_WLAN",      "KEY_UWB", 
        "KEY_UNKNOWN",      "KEY_VIDEO_NEXT",      "KEY_VIDEO_PREV",      "KEY_BRIGHTNESS_CYCLE", 
        "KEY_BRIGHTNESS_ZERO",      "KEY_DISPLAY_OFF",      "KEY_WWAN",      "KEY_RFKILL", 
        "KEY_MICMUTE",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "BTN_MISC",      "BTN_1",      "BTN_2",      "BTN_3", 
        "BTN_4",      "BTN_5",      "BTN_6",      "BTN_7", 
        "BTN_8",      "BTN_9",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "BTN_MOUSE",      "BTN_RIGHT",      "BTN_MIDDLE",      "BTN_SIDE", 
        "BTN_EXTRA",      "BTN_FORWARD",      "BTN_BACK",      "BTN_TASK", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "BTN_JOYSTICK",      "BTN_THUMB",      "BTN_THUMB2",      "BTN_TOP", 
        "BTN_TOP2",      "BTN_PINKIE",      "BTN_BASE",      "BTN_BASE2", 
        "BTN_BASE3",      "BTN_BASE4",      "BTN_BASE5",      "BTN_BASE6", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "BTN_DEAD", 
        "BTN_GAMEPAD",      "BTN_EAST",      "BTN_C",      "BTN_NORTH", 
        "BTN_WEST",      "BTN_Z",      "BTN_TL",      "BTN_TR", 
        "BTN_TL2",      "BTN_TR2",      "BTN_SELECT",      "BTN_START", 
        "BTN_MODE",      "BTN_THUMBL",      "BTN_THUMBR",      (char const   *)0, 
        "BTN_DIGI",      "BTN_TOOL_RUBBER",      "BTN_TOOL_BRUSH",      "BTN_TOOL_PENCIL", 
        "BTN_TOOL_AIRBRUSH",      "BTN_TOOL_FINGER",      "BTN_TOOL_MOUSE",      "BTN_TOOL_LENS", 
        "BTN_TOOL_QUINTTAP",      (char const   *)0,      "BTN_TOUCH",      "BTN_STYLUS", 
        "BTN_STYLUS2",      "BTN_TOOL_DOUBLETAP",      "BTN_TOOL_TRIPLETAP",      "BTN_TOOL_QUADTAP", 
        "BTN_WHEEL",      "BTN_GEAR_UP",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_OK",      "KEY_SELECT",      "KEY_GOTO",      "KEY_CLEAR", 
        "KEY_POWER2",      "KEY_OPTION",      "KEY_INFO",      "KEY_TIME", 
        "KEY_VENDOR",      "KEY_ARCHIVE",      "KEY_PROGRAM",      "KEY_CHANNEL", 
        "KEY_FAVORITES",      "KEY_EPG",      "KEY_PVR",      "KEY_MHP", 
        "KEY_LANGUAGE",      "KEY_TITLE",      "KEY_SUBTITLE",      "KEY_ANGLE", 
        "KEY_ZOOM",      "KEY_MODE",      "KEY_KEYBOARD",      "KEY_SCREEN", 
        "KEY_PC",      "KEY_TV",      "KEY_TV2",      "KEY_VCR", 
        "KEY_VCR2",      "KEY_SAT",      "KEY_SAT2",      "KEY_CD", 
        "KEY_TAPE",      "KEY_RADIO",      "KEY_TUNER",      "KEY_PLAYER", 
        "KEY_TEXT",      "KEY_DVD",      "KEY_AUX",      "KEY_MP3", 
        "KEY_AUDIO",      "KEY_VIDEO",      "KEY_DIRECTORY",      "KEY_LIST", 
        "KEY_MEMO",      "KEY_CALENDAR",      "KEY_RED",      "KEY_GREEN", 
        "KEY_YELLOW",      "KEY_BLUE",      "KEY_CHANNELUP",      "KEY_CHANNELDOWN", 
        "KEY_FIRST",      "KEY_LAST",      "KEY_AB",      "KEY_NEXT", 
        "KEY_RESTART",      "KEY_SLOW",      "KEY_SHUFFLE",      "KEY_BREAK", 
        "KEY_PREVIOUS",      "KEY_DIGITS",      "KEY_TEEN",      "KEY_TWEN", 
        "KEY_VIDEOPHONE",      "KEY_GAMES",      "KEY_ZOOMIN",      "KEY_ZOOMOUT", 
        "KEY_ZOOMRESET",      "KEY_WORDPROCESSOR",      "KEY_EDITOR",      "KEY_SPREADSHEET", 
        "KEY_GRAPHICSEDITOR",      "KEY_PRESENTATION",      "KEY_DATABASE",      "KEY_NEWS", 
        "KEY_VOICEMAIL",      "KEY_ADDRESSBOOK",      "KEY_MESSENGER",      "KEY_DISPLAYTOGGLE", 
        "KEY_SPELLCHECK",      "KEY_LOGOFF",      "KEY_DOLLAR",      "KEY_EURO", 
        "KEY_FRAMEBACK",      "KEY_FRAMEFORWARD",      "KEY_CONTEXT_MENU",      "KEY_MEDIA_REPEAT", 
        "KEY_10CHANNELSUP",      "KEY_10CHANNELSDOWN",      "KEY_IMAGES",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_DEL_EOL",      "KEY_DEL_EOS",      "KEY_INS_LINE",      "KEY_DEL_LINE", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_FN",      "KEY_FN_ESC",      "KEY_FN_F1",      "KEY_FN_F2", 
        "KEY_FN_F3",      "KEY_FN_F4",      "KEY_FN_F5",      "KEY_FN_F6", 
        "KEY_FN_F7",      "KEY_FN_F8",      "KEY_FN_F9",      "KEY_FN_F10", 
        "KEY_FN_F11",      "KEY_FN_F12",      "KEY_FN_1",      "KEY_FN_2", 
        "KEY_FN_D",      "KEY_FN_E",      "KEY_FN_F",      "KEY_FN_S", 
        "KEY_FN_B",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "KEY_BRL_DOT1",      "KEY_BRL_DOT2",      "KEY_BRL_DOT3", 
        "KEY_BRL_DOT4",      "KEY_BRL_DOT5",      "KEY_BRL_DOT6",      "KEY_BRL_DOT7", 
        "KEY_BRL_DOT8",      "KEY_BRL_DOT9",      "KEY_BRL_DOT10",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_NUMERIC_0",      "KEY_NUMERIC_1",      "KEY_NUMERIC_2",      "KEY_NUMERIC_3", 
        "KEY_NUMERIC_4",      "KEY_NUMERIC_5",      "KEY_NUMERIC_6",      "KEY_NUMERIC_7", 
        "KEY_NUMERIC_8",      "KEY_NUMERIC_9",      "KEY_NUMERIC_STAR",      "KEY_NUMERIC_POUND", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_CAMERA_FOCUS",      "KEY_WPS_BUTTON",      "KEY_TOUCHPAD_TOGGLE",      "KEY_TOUCHPAD_ON", 
        "KEY_TOUCHPAD_OFF",      "KEY_CAMERA_ZOOMIN",      "KEY_CAMERA_ZOOMOUT",      "KEY_CAMERA_UP", 
        "KEY_CAMERA_DOWN",      "KEY_CAMERA_LEFT",      "KEY_CAMERA_RIGHT",      "KEY_ATTENDANT_ON", 
        "KEY_ATTENDANT_OFF",      "KEY_ATTENDANT_TOGGLE",      "KEY_LIGHTS_TOGGLE",      (char const   *)0, 
        "BTN_DPAD_UP",      "BTN_DPAD_DOWN",      "BTN_DPAD_LEFT",      "BTN_DPAD_RIGHT", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "KEY_ALS_TOGGLE",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "BTN_TRIGGER_HAPPY",      "BTN_TRIGGER_HAPPY2",      "BTN_TRIGGER_HAPPY3",      "BTN_TRIGGER_HAPPY4", 
        "BTN_TRIGGER_HAPPY5",      "BTN_TRIGGER_HAPPY6",      "BTN_TRIGGER_HAPPY7",      "BTN_TRIGGER_HAPPY8", 
        "BTN_TRIGGER_HAPPY9",      "BTN_TRIGGER_HAPPY10",      "BTN_TRIGGER_HAPPY11",      "BTN_TRIGGER_HAPPY12", 
        "BTN_TRIGGER_HAPPY13",      "BTN_TRIGGER_HAPPY14",      "BTN_TRIGGER_HAPPY15",      "BTN_TRIGGER_HAPPY16", 
        "BTN_TRIGGER_HAPPY17",      "BTN_TRIGGER_HAPPY18",      "BTN_TRIGGER_HAPPY19",      "BTN_TRIGGER_HAPPY20", 
        "BTN_TRIGGER_HAPPY21",      "BTN_TRIGGER_HAPPY22",      "BTN_TRIGGER_HAPPY23",      "BTN_TRIGGER_HAPPY24", 
        "BTN_TRIGGER_HAPPY25",      "BTN_TRIGGER_HAPPY26",      "BTN_TRIGGER_HAPPY27",      "BTN_TRIGGER_HAPPY28", 
        "BTN_TRIGGER_HAPPY29",      "BTN_TRIGGER_HAPPY30",      "BTN_TRIGGER_HAPPY31",      "BTN_TRIGGER_HAPPY32", 
        "BTN_TRIGGER_HAPPY33",      "BTN_TRIGGER_HAPPY34",      "BTN_TRIGGER_HAPPY35",      "BTN_TRIGGER_HAPPY36", 
        "BTN_TRIGGER_HAPPY37",      "BTN_TRIGGER_HAPPY38",      "BTN_TRIGGER_HAPPY39",      "BTN_TRIGGER_HAPPY40"};
#line 52 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static evdev_t *evdevs  =    (evdev_t *)((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static client_t *clients  =    (client_t *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static int sockfd  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool grab  =    (_Bool)0;
#line 64 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static int key_min  =    88;
#line 65 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static char *device  =    (char *)"/var/run/lirc/lircd";
#line 67 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool capture_modifiers  =    (_Bool)0;
#line 68 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool meta  =    (_Bool)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool alt  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool shift  =    (_Bool)0;
#line 71 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static _Bool ctrl  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static long repeat_time  =    0L;
#line 74 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static struct timeval previous_input  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static struct timeval evdev_timeout  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static struct input_event previous_event  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static int repeat  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void *xalloc(size_t size ) 
{ 
  void *buf ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 80
  tmp = malloc(size);
#line 80
  buf = tmp;
  }
#line 81
  if (! buf) {
    {
#line 82
    tmp___0 = __errno_location();
#line 82
    tmp___1 = strerror(*tmp___0);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not allocate %zd bytes with malloc(): %s\n",
            size, tmp___1);
#line 83
    exit(71);
    }
  }
  {
#line 85
  memset(buf, 0, size);
  }
#line 86
  return (buf);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void parse_translation_table(char const   *path ) 
{ 
  FILE *table ;
  char *line ;
  size_t line_size ;
  char event_name[100] ;
  char lirc_name[100] ;
  unsigned int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  __ssize_t tmp___9 ;

  {
#line 91
  line = (char *)((void *)0);
#line 92
  line_size = (size_t )0;
#line 97
  if (! path) {
#line 98
    return;
  }
  {
#line 100
  table = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 101
  if (! table) {
    {
#line 102
    tmp = __errno_location();
#line 102
    tmp___0 = strerror(*tmp);
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open translation table %s: %s\n",
            path, tmp___0);
    }
#line 103
    return;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___9 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& line_size),
                      (FILE */* __restrict  */)table);
    }
#line 106
    if (! (tmp___9 >= 0L)) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp___1 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)" %99s = %99s ",
                     event_name, lirc_name);
    }
#line 107
    if (tmp___1 != 2) {
#line 108
      goto while_continue;
    }
    {
#line 110
    event_name[99] = (char )'\000';
#line 111
    lirc_name[99] = (char )'\000';
#line 112
    tmp___2 = strlen((char const   *)(event_name));
    }
#line 112
    if (tmp___2 < 1UL) {
#line 113
      goto while_continue;
    } else {
      {
#line 112
      tmp___3 = strlen((char const   *)(lirc_name));
      }
#line 112
      if (tmp___3 < 1UL) {
#line 113
        goto while_continue;
      }
    }
    {
#line 115
    tmp___5 = strtoul((char const   */* __restrict  */)(event_name), (char **/* __restrict  */)((void *)0),
                      0);
#line 115
    i = (unsigned int )tmp___5;
    }
#line 115
    if (! i) {
#line 116
      i = 0U;
      {
#line 116
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 116
        if (! (i < 767U)) {
#line 116
          goto while_break___0;
        }
#line 117
        if (! KEY_NAME[i]) {
#line 118
          goto __Cont;
        }
        {
#line 119
        tmp___4 = strcmp((char const   *)(event_name), KEY_NAME[i]);
        }
#line 119
        if (! tmp___4) {
#line 120
          goto while_break___0;
        }
        __Cont: /* CIL Label */ 
#line 116
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 124
    if (i >= 767U) {
#line 125
      goto while_continue;
    }
    {
#line 127
    tmp___6 = strdup((char const   *)(lirc_name));
#line 127
    KEY_NAME[i] = (char const   *)tmp___6;
    }
#line 129
    if (! KEY_NAME[i]) {
      {
#line 130
      tmp___7 = __errno_location();
#line 130
      tmp___8 = strerror(*tmp___7);
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strdup failure: %s\n",
              tmp___8);
#line 131
      exit(71);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  fclose(table);
#line 136
  free((void *)line);
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static int open_evdev(char *name ) 
{ 
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  char bits ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 142
  fd = open((char const   *)name, 0);
  }
#line 143
  if (fd < 0) {
    {
#line 144
    tmp = __errno_location();
#line 144
    tmp___0 = strerror(*tmp);
#line 144
    syslog(3, "Could not open %s: %s\n", name, tmp___0);
    }
#line 145
    return (-1);
  }
  {
#line 148
  bits = (char)0;
#line 150
  tmp___3 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 32U) | (sizeof(bits) << 16),
                  & bits);
  }
#line 150
  if (tmp___3 < 0) {
    {
#line 151
    close(fd);
#line 152
    tmp___1 = __errno_location();
#line 152
    tmp___2 = strerror(*tmp___1);
#line 152
    syslog(3, "Could not read supported event types from %s: %s\n", name, tmp___2);
    }
#line 153
    return (-1);
  }
#line 156
  if (! ((int )bits & 2)) {
    {
#line 157
    close(fd);
#line 158
    syslog(3, "%s does not support EV_KEY events\n", name);
    }
#line 159
    return (-1);
  }
#line 162
  if (grab) {
    {
#line 163
    tmp___6 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(69 << 8)) | 144U) | (sizeof(int ) << 16),
                    1);
    }
#line 163
    if (tmp___6 < 0) {
      {
#line 164
      close(fd);
#line 165
      tmp___4 = __errno_location();
#line 165
      tmp___5 = strerror(*tmp___4);
#line 165
      syslog(3, "Failed to grab %s: %s\n", name, tmp___5);
      }
#line 166
      return (-1);
    }
  }
#line 169
  return (fd);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void rescan_evdevs(fd_set *permset ) 
{ 
  evdev_t *evdev ;
  int fd ;

  {
#line 175
  evdev = evdevs;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! evdev) {
#line 175
      goto while_break;
    }
#line 176
    if (evdev->fd == -999) {
      {
#line 177
      syslog(6, "Reading device: %s", evdev->name);
#line 178
      fd = open_evdev(evdev->name);
      }
#line 179
      if (fd >= 0) {
        {
#line 180
        evdev->fd = fd;
#line 181
        permset->fds_bits[evdev->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << evdev->fd % (8 * (int )sizeof(__fd_mask ));
#line 182
        syslog(6, "Success!");
        }
      }
    }
#line 175
    evdev = evdev->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void add_evdev(char *name ) 
{ 
  int fd ;
  evdev_t *newdev ;
  void *tmp ;

  {
  {
#line 193
  fd = open_evdev(name);
  }
#line 194
  if (fd < 0) {
#line 195
    return;
  }
  {
#line 197
  tmp = xalloc(sizeof(*newdev));
#line 197
  newdev = (evdev_t *)tmp;
#line 198
  newdev->fd = fd;
#line 199
  newdev->name = strdup((char const   *)name);
#line 200
  newdev->next = evdevs;
#line 201
  evdevs = newdev;
  }
#line 202
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void add_named(char *pattern ) 
{ 
  int i ;
  int result ;
  int fd ;
  char name[32] ;
  glob_t g ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 210
  result = glob((char const   */* __restrict  */)"/dev/input/event*", 1 << 2, (int (*)(char const   * ,
                                                                                       int  ))((void *)0),
                (glob_t */* __restrict  */)(& g));
  }
#line 212
  if (result == 3) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No event devices found!\n");
    }
#line 214
    return;
  } else
#line 215
  if (result) {
    {
#line 216
    tmp = __errno_location();
#line 216
    tmp___0 = strerror(*tmp);
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read /dev/input/event*: %s\n",
            tmp___0);
    }
#line 217
    return;
  }
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ((size_t )i < g.gl_pathc)) {
#line 220
      goto while_break;
    }
    {
#line 221
    fd = open((char const   *)*(g.gl_pathv + i), 0);
    }
#line 222
    if (fd < 0) {
      {
#line 223
      tmp___1 = __errno_location();
#line 223
      tmp___2 = strerror(*tmp___1);
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open %s: %s\n",
              *(g.gl_pathv + i), tmp___2);
      }
#line 224
      goto __Cont;
    }
    {
#line 227
    result = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U) | (sizeof(name) << 16),
                   name);
#line 228
    close(fd);
    }
#line 229
    if (result < 0) {
      {
#line 230
      tmp___3 = __errno_location();
#line 230
      tmp___4 = strerror(*tmp___3);
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not read name of event device %s: %s\n",
              *(g.gl_pathv + i), tmp___4);
      }
#line 231
      goto __Cont;
    }
    {
#line 234
    name[sizeof(name) - 1UL] = (char)0;
#line 235
    tmp___5 = fnmatch((char const   *)pattern, (char const   *)(name), 1 << 4);
    }
#line 235
    if (! tmp___5) {
      {
#line 236
      add_evdev(*(g.gl_pathv + i));
      }
    }
    __Cont: /* CIL Label */ 
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  globfree(& g);
  }
#line 240
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void add_unixsocket(void) 
{ 
  struct sockaddr_un sa ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 243
  sa.sun_family = (sa_family_t )0;
#line 243
  sa.sun_path[0] = (char)0;
#line 243
  sa.sun_path[1] = (char)0;
#line 243
  sa.sun_path[2] = (char)0;
#line 243
  sa.sun_path[3] = (char)0;
#line 243
  sa.sun_path[4] = (char)0;
#line 243
  sa.sun_path[5] = (char)0;
#line 243
  sa.sun_path[6] = (char)0;
#line 243
  sa.sun_path[7] = (char)0;
#line 243
  sa.sun_path[8] = (char)0;
#line 243
  sa.sun_path[9] = (char)0;
#line 243
  sa.sun_path[10] = (char)0;
#line 243
  sa.sun_path[11] = (char)0;
#line 243
  sa.sun_path[12] = (char)0;
#line 243
  sa.sun_path[13] = (char)0;
#line 243
  sa.sun_path[14] = (char)0;
#line 243
  sa.sun_path[15] = (char)0;
#line 243
  sa.sun_path[16] = (char)0;
#line 243
  sa.sun_path[17] = (char)0;
#line 243
  sa.sun_path[18] = (char)0;
#line 243
  sa.sun_path[19] = (char)0;
#line 243
  sa.sun_path[20] = (char)0;
#line 243
  sa.sun_path[21] = (char)0;
#line 243
  sa.sun_path[22] = (char)0;
#line 243
  sa.sun_path[23] = (char)0;
#line 243
  sa.sun_path[24] = (char)0;
#line 243
  sa.sun_path[25] = (char)0;
#line 243
  sa.sun_path[26] = (char)0;
#line 243
  sa.sun_path[27] = (char)0;
#line 243
  sa.sun_path[28] = (char)0;
#line 243
  sa.sun_path[29] = (char)0;
#line 243
  sa.sun_path[30] = (char)0;
#line 243
  sa.sun_path[31] = (char)0;
#line 243
  sa.sun_path[32] = (char)0;
#line 243
  sa.sun_path[33] = (char)0;
#line 243
  sa.sun_path[34] = (char)0;
#line 243
  sa.sun_path[35] = (char)0;
#line 243
  sa.sun_path[36] = (char)0;
#line 243
  sa.sun_path[37] = (char)0;
#line 243
  sa.sun_path[38] = (char)0;
#line 243
  sa.sun_path[39] = (char)0;
#line 243
  sa.sun_path[40] = (char)0;
#line 243
  sa.sun_path[41] = (char)0;
#line 243
  sa.sun_path[42] = (char)0;
#line 243
  sa.sun_path[43] = (char)0;
#line 243
  sa.sun_path[44] = (char)0;
#line 243
  sa.sun_path[45] = (char)0;
#line 243
  sa.sun_path[46] = (char)0;
#line 243
  sa.sun_path[47] = (char)0;
#line 243
  sa.sun_path[48] = (char)0;
#line 243
  sa.sun_path[49] = (char)0;
#line 243
  sa.sun_path[50] = (char)0;
#line 243
  sa.sun_path[51] = (char)0;
#line 243
  sa.sun_path[52] = (char)0;
#line 243
  sa.sun_path[53] = (char)0;
#line 243
  sa.sun_path[54] = (char)0;
#line 243
  sa.sun_path[55] = (char)0;
#line 243
  sa.sun_path[56] = (char)0;
#line 243
  sa.sun_path[57] = (char)0;
#line 243
  sa.sun_path[58] = (char)0;
#line 243
  sa.sun_path[59] = (char)0;
#line 243
  sa.sun_path[60] = (char)0;
#line 243
  sa.sun_path[61] = (char)0;
#line 243
  sa.sun_path[62] = (char)0;
#line 243
  sa.sun_path[63] = (char)0;
#line 243
  sa.sun_path[64] = (char)0;
#line 243
  sa.sun_path[65] = (char)0;
#line 243
  sa.sun_path[66] = (char)0;
#line 243
  sa.sun_path[67] = (char)0;
#line 243
  sa.sun_path[68] = (char)0;
#line 243
  sa.sun_path[69] = (char)0;
#line 243
  sa.sun_path[70] = (char)0;
#line 243
  sa.sun_path[71] = (char)0;
#line 243
  sa.sun_path[72] = (char)0;
#line 243
  sa.sun_path[73] = (char)0;
#line 243
  sa.sun_path[74] = (char)0;
#line 243
  sa.sun_path[75] = (char)0;
#line 243
  sa.sun_path[76] = (char)0;
#line 243
  sa.sun_path[77] = (char)0;
#line 243
  sa.sun_path[78] = (char)0;
#line 243
  sa.sun_path[79] = (char)0;
#line 243
  sa.sun_path[80] = (char)0;
#line 243
  sa.sun_path[81] = (char)0;
#line 243
  sa.sun_path[82] = (char)0;
#line 243
  sa.sun_path[83] = (char)0;
#line 243
  sa.sun_path[84] = (char)0;
#line 243
  sa.sun_path[85] = (char)0;
#line 243
  sa.sun_path[86] = (char)0;
#line 243
  sa.sun_path[87] = (char)0;
#line 243
  sa.sun_path[88] = (char)0;
#line 243
  sa.sun_path[89] = (char)0;
#line 243
  sa.sun_path[90] = (char)0;
#line 243
  sa.sun_path[91] = (char)0;
#line 243
  sa.sun_path[92] = (char)0;
#line 243
  sa.sun_path[93] = (char)0;
#line 243
  sa.sun_path[94] = (char)0;
#line 243
  sa.sun_path[95] = (char)0;
#line 243
  sa.sun_path[96] = (char)0;
#line 243
  sa.sun_path[97] = (char)0;
#line 243
  sa.sun_path[98] = (char)0;
#line 243
  sa.sun_path[99] = (char)0;
#line 243
  sa.sun_path[100] = (char)0;
#line 243
  sa.sun_path[101] = (char)0;
#line 243
  sa.sun_path[102] = (char)0;
#line 243
  sa.sun_path[103] = (char)0;
#line 243
  sa.sun_path[104] = (char)0;
#line 243
  sa.sun_path[105] = (char)0;
#line 243
  sa.sun_path[106] = (char)0;
#line 243
  sa.sun_path[107] = (char)0;
#line 244
  sockfd = socket(1, 1, 0);
  }
#line 246
  if (sockfd < 0) {
    {
#line 247
    tmp = __errno_location();
#line 247
    tmp___0 = strerror(*tmp);
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to create an AF_UNIX socket: %s\n",
            tmp___0);
#line 248
    exit(71);
    }
  }
  {
#line 251
  sa.sun_family = (sa_family_t )1;
#line 252
  strncpy((char */* __restrict  */)(sa.sun_path), (char const   */* __restrict  */)device,
          sizeof(sa.sun_path) - 1UL);
#line 254
  unlink((char const   *)device);
#line 256
  tmp___3 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sa)),
                 (socklen_t )sizeof(sa));
  }
#line 256
  if (tmp___3 < 0) {
    {
#line 257
    tmp___1 = __errno_location();
#line 257
    tmp___2 = strerror(*tmp___1);
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to bind AF_UNIX socket to %s: %s\n",
            device, tmp___2);
#line 258
    exit(71);
    }
  }
  {
#line 261
  chmod((char const   *)device, (__mode_t )438);
#line 263
  tmp___6 = listen(sockfd, 3);
  }
#line 263
  if (tmp___6 < 0) {
    {
#line 264
    tmp___4 = __errno_location();
#line 264
    tmp___5 = strerror(*tmp___4);
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to listen on AF_UNIX socket: %s\n",
            tmp___5);
#line 265
    exit(71);
    }
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void processnewclient(void) 
{ 
  client_t *newclient ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int flags ;
  int tmp___4 ;

  {
  {
#line 270
  tmp = xalloc(sizeof(*newclient));
#line 270
  newclient = (client_t *)tmp;
#line 272
  newclient->fd = accept(sockfd, (struct sockaddr */* __restrict  */)((void *)0),
                         (socklen_t */* __restrict  */)((void *)0));
  }
#line 274
  if (newclient->fd < 0) {
    {
#line 275
    free((void *)newclient);
#line 276
    tmp___0 = __errno_location();
    }
#line 276
    if (*tmp___0 == 103) {
#line 277
      return;
    } else {
      {
#line 276
      tmp___1 = __errno_location();
      }
#line 276
      if (*tmp___1 == 4) {
#line 277
        return;
      }
    }
    {
#line 278
    tmp___2 = __errno_location();
#line 278
    tmp___3 = strerror(*tmp___2);
#line 278
    syslog(3, "Error during accept(): %s\n", tmp___3);
#line 279
    exit(71);
    }
  }
  {
#line 282
  tmp___4 = fcntl(newclient->fd, 3);
#line 282
  flags = tmp___4;
#line 283
  fcntl(newclient->fd, 4, flags | 2048);
#line 285
  newclient->next = clients;
#line 286
  clients = newclient;
  }
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static long time_elapsed(struct timeval *last , struct timeval *current ) 
{ 
  long seconds ;

  {
#line 290
  seconds = current->tv_sec - last->tv_sec;
#line 291
  return ((1000000L * seconds + current->tv_usec) - last->tv_usec);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void processevent(evdev_t *evdev , fd_set *permset ) 
{ 
  struct input_event event ;
  char message[1000] ;
  int len ;
  client_t *client ;
  client_t *prev ;
  client_t *next ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  struct timeval current ;
  long tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 300
  tmp___1 = read(evdev->fd, (void *)(& event), sizeof(event));
  }
#line 300
  if ((unsigned long )tmp___1 != sizeof(event)) {
    {
#line 301
    tmp = __errno_location();
#line 301
    tmp___0 = strerror(*tmp);
#line 301
    syslog(3, "Error processing event from %s: %s\n", evdev->name, tmp___0);
#line 302
    permset->fds_bits[evdev->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << evdev->fd % (8 * (int )sizeof(__fd_mask )));
#line 303
    close(evdev->fd);
#line 304
    evdev->fd = -999;
    }
#line 305
    return;
  }
#line 308
  if ((int )event.type != 1) {
#line 309
    return;
  }
#line 311
  if ((int )event.code > 767) {
#line 312
    return;
  } else
#line 311
  if ((int )event.code < key_min) {
#line 312
    return;
  }
#line 314
  if (capture_modifiers) {
#line 315
    if ((int )event.code == 29) {
#line 316
      ctrl = (_Bool )(! (! event.value));
#line 317
      return;
    } else
#line 315
    if ((int )event.code == 97) {
#line 316
      ctrl = (_Bool )(! (! event.value));
#line 317
      return;
    }
#line 319
    if ((int )event.code == 42) {
#line 320
      shift = (_Bool )(! (! event.value));
#line 321
      return;
    } else
#line 319
    if ((int )event.code == 54) {
#line 320
      shift = (_Bool )(! (! event.value));
#line 321
      return;
    }
#line 323
    if ((int )event.code == 56) {
#line 324
      alt = (_Bool )(! (! event.value));
#line 325
      return;
    } else
#line 323
    if ((int )event.code == 100) {
#line 324
      alt = (_Bool )(! (! event.value));
#line 325
      return;
    }
#line 327
    if ((int )event.code == 125) {
#line 328
      meta = (_Bool )(! (! event.value));
#line 329
      return;
    } else
#line 327
    if ((int )event.code == 126) {
#line 328
      meta = (_Bool )(! (! event.value));
#line 329
      return;
    }
  }
#line 333
  if (! event.value) {
#line 334
    return;
  }
  {
#line 337
  gettimeofday((struct timeval */* __restrict  */)(& current), (__timezone_ptr_t )((void *)0));
  }
#line 338
  if ((int )event.code == (int )previous_event.code) {
    {
#line 338
    tmp___2 = time_elapsed(& previous_input, & current);
    }
#line 338
    if (tmp___2 < repeat_time) {
#line 339
      repeat ++;
    } else {
#line 341
      repeat = 0;
    }
  } else {
#line 341
    repeat = 0;
  }
#line 343
  if (KEY_NAME[event.code]) {
#line 344
    if (meta) {
#line 344
      tmp___3 = "META_";
    } else {
#line 344
      tmp___3 = "";
    }
#line 344
    if (alt) {
#line 344
      tmp___4 = "ALT_";
    } else {
#line 344
      tmp___4 = "";
    }
#line 344
    if (shift) {
#line 344
      tmp___5 = "SHIFT_";
    } else {
#line 344
      tmp___5 = "";
    }
#line 344
    if (ctrl) {
#line 344
      tmp___6 = "CTRL_";
    } else {
#line 344
      tmp___6 = "";
    }
    {
#line 344
    len = snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"%x %x %s%s%s%s%s %s\n",
                   (int )event.code, repeat, tmp___6, tmp___5, tmp___4, tmp___3, KEY_NAME[event.code],
                   evdev->name);
    }
  } else {
    {
#line 346
    len = snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"%x %x KEY_CODE_%d %s\n",
                   (int )event.code, repeat, (int )event.code, evdev->name);
    }
  }
#line 348
  previous_input = current;
#line 349
  previous_event = event;
#line 351
  client = clients;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! client) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp___7 = write(client->fd, (void const   *)(message), (size_t )len);
    }
#line 352
    if (tmp___7 != (ssize_t )len) {
      {
#line 353
      close(client->fd);
#line 354
      client->fd = -1;
      }
    }
#line 351
    client = client->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  prev = (client_t *)((void *)0);
#line 358
  client = clients;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! client) {
#line 358
      goto while_break___0;
    }
#line 359
    next = client->next;
#line 360
    if (client->fd < 0) {
#line 361
      if (prev) {
#line 362
        prev->next = client->next;
      } else {
#line 364
        clients = client->next;
      }
      {
#line 365
      free((void *)client);
      }
    } else {
#line 367
      prev = client;
    }
#line 358
    client = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 370
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
static void main_loop(void) 
{ 
  fd_set permset ;
  fd_set fdset ;
  evdev_t *evdev ;
  int maxfd ;
  int retselect ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 376
  maxfd = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& permset.fds_bits[0]): "memory");
#line 379
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  evdev = evdevs;
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    if (! evdev) {
#line 381
      goto while_break___0;
    }
#line 382
    if (evdev->fd < 0) {
#line 383
      goto __Cont;
    }
#line 384
    permset.fds_bits[evdev->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << evdev->fd % (8 * (int )sizeof(__fd_mask ));
#line 385
    if (evdev->fd > maxfd) {
#line 386
      maxfd = evdev->fd;
    }
    __Cont: /* CIL Label */ 
#line 381
    evdev = evdev->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 389
  permset.fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
#line 390
  if (sockfd > maxfd) {
#line 391
    maxfd = sockfd;
  }
#line 393
  maxfd ++;
  {
#line 395
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 396
    fdset = permset;
#line 399
    evdev_timeout.tv_sec = (__time_t )30;
#line 401
    retselect = select(maxfd, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& evdev_timeout));
    }
#line 402
    if (retselect > 0) {
#line 403
      evdev = evdevs;
      {
#line 403
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 403
        if (! evdev) {
#line 403
          goto while_break___2;
        }
#line 404
        if ((fdset.fds_bits[evdev->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << evdev->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 405
          processevent(evdev, & permset);
          }
        }
#line 403
        evdev = evdev->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 407
      if ((fdset.fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] & (1L << sockfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 408
        processnewclient();
        }
      }
    } else {
#line 411
      if (retselect < 0) {
        {
#line 412
        tmp = __errno_location();
        }
#line 412
        if (*tmp == 4) {
#line 413
          goto while_continue___1;
        }
        {
#line 414
        tmp___0 = __errno_location();
#line 414
        tmp___1 = strerror(*tmp___0);
#line 414
        syslog(3, "Error during select(): %s\n", tmp___1);
        }
      }
      {
#line 416
      rescan_evdevs(& permset);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/inputlirc-23/inputlircd.c"
int main(int argc , char **argv ) 
{ 
  char *user ;
  char *translation_path ;
  int opt ;
  int i ;
  _Bool foreground ;
  _Bool named ;
  int tmp ;
  struct passwd *pwd ;
  struct passwd *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 423
  user = (char *)"nobody";
#line 424
  translation_path = (char *)((void *)0);
#line 426
  foreground = (_Bool)0;
#line 426
  named = (_Bool)0;
#line 428
  gettimeofday((struct timeval */* __restrict  */)(& previous_input), (__timezone_ptr_t )((void *)0));
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    opt = getopt(argc, (char * const  *)argv, "cd:gm:n:fu:r:t:");
    }
#line 430
    if (! (opt != -1)) {
#line 430
      goto while_break;
    }
    {
#line 432
    if (opt == 100) {
#line 432
      goto case_100;
    }
#line 435
    if (opt == 103) {
#line 435
      goto case_103;
    }
#line 438
    if (opt == 99) {
#line 438
      goto case_99;
    }
#line 441
    if (opt == 109) {
#line 441
      goto case_109;
    }
#line 444
    if (opt == 110) {
#line 444
      goto case_110;
    }
#line 448
    if (opt == 117) {
#line 448
      goto case_117;
    }
#line 451
    if (opt == 102) {
#line 451
      goto case_102;
    }
#line 454
    if (opt == 114) {
#line 454
      goto case_114;
    }
#line 457
    if (opt == 116) {
#line 457
      goto case_116;
    }
#line 460
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    device = strdup((char const   *)optarg);
    }
#line 434
    goto switch_break;
    case_103: /* CIL Label */ 
#line 436
    grab = (_Bool)1;
#line 437
    goto switch_break;
    case_99: /* CIL Label */ 
#line 439
    capture_modifiers = (_Bool)1;
#line 440
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 442
    key_min = atoi((char const   *)optarg);
    }
#line 443
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 445
    named = (_Bool)1;
#line 446
    add_named(optarg);
    }
#line 447
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 449
    user = strdup((char const   *)optarg);
    }
#line 450
    goto switch_break;
    case_102: /* CIL Label */ 
#line 452
    foreground = (_Bool)1;
#line 453
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 455
    tmp = atoi((char const   *)optarg);
#line 455
    repeat_time = (long )tmp * 1000L;
    }
#line 456
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 458
    translation_path = strdup((char const   *)optarg);
    }
#line 459
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 461
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option!\n");
    }
#line 462
    return (64);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  if (argc <= optind) {
#line 466
    if (! named) {
      {
#line 467
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough arguments.\n");
      }
#line 468
      return (64);
    }
  }
  {
#line 471
  openlog("inputlircd", 32, 3 << 3);
#line 473
  i = optind;
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! (i < argc)) {
#line 473
      goto while_break___0;
    }
    {
#line 474
    add_evdev(*(argv + i));
#line 473
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 476
  if (! evdevs) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open any event device!\n");
    }
#line 478
    return (71);
  }
  {
#line 481
  parse_translation_table((char const   *)translation_path);
#line 483
  add_unixsocket();
#line 485
  tmp___0 = getpwnam((char const   *)user);
#line 485
  pwd = tmp___0;
  }
#line 486
  if (! pwd) {
    {
#line 487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to resolve user %s!\n",
            user);
    }
#line 488
    return (71);
  }
  {
#line 491
  tmp___1 = setgid(pwd->pw_gid);
  }
#line 491
  if (tmp___1) {
    {
#line 492
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to setuid/setguid to %s!\n",
            user);
    }
#line 493
    return (71);
  } else {
    {
#line 491
    tmp___2 = setuid(pwd->pw_uid);
    }
#line 491
    if (tmp___2) {
      {
#line 492
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to setuid/setguid to %s!\n",
              user);
      }
#line 493
      return (71);
    }
  }
#line 496
  if (! foreground) {
    {
#line 497
    closelog();
#line 498
    daemon(0, 0);
#line 499
    openlog("inputlircd", 0, 3 << 3);
    }
  }
  {
#line 502
  syslog(6, "Started");
#line 504
  signal(13, (void (*)(int  ))1);
#line 506
  main_loop();
  }
#line 508
  return (0);
}
}
