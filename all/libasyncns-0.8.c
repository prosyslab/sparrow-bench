/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_63 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_63 HEADER;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.h"
struct asyncns;
#line 51 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.h"
typedef struct asyncns asyncns_t;
#line 54
struct asyncns_query;
#line 54 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.h"
typedef struct asyncns_query asyncns_query_t;
#line 65 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
enum __anonenum_query_type_t_96 {
    REQUEST_ADDRINFO = 0,
    RESPONSE_ADDRINFO = 1,
    REQUEST_NAMEINFO = 2,
    RESPONSE_NAMEINFO = 3,
    REQUEST_RES_QUERY = 4,
    REQUEST_RES_SEARCH = 5,
    RESPONSE_RES = 6,
    REQUEST_TERMINATE = 7,
    RESPONSE_DIED = 8
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef enum __anonenum_query_type_t_96 query_type_t;
#line 85 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct asyncns {
   int fds[4] ;
   pthread_t workers[16] ;
   unsigned int valid_workers ;
   unsigned int current_id ;
   unsigned int current_index ;
   asyncns_query_t *queries[256] ;
   asyncns_query_t *done_head ;
   asyncns_query_t *done_tail ;
   int n_queries ;
   int dead ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct asyncns_query {
   asyncns_t *asyncns ;
   int done ;
   unsigned int id ;
   query_type_t type ;
   asyncns_query_t *done_next ;
   asyncns_query_t *done_prev ;
   int ret ;
   int _errno ;
   int _h_errno ;
   struct addrinfo *addrinfo ;
   char *serv ;
   char *host ;
   void *userdata ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct rheader {
   query_type_t type ;
   unsigned int id ;
   size_t length ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct rheader rheader_t;
#line 124 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct addrinfo_request {
   struct rheader header ;
   int hints_is_null ;
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   size_t node_len ;
   size_t service_len ;
};
#line 124 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct addrinfo_request addrinfo_request_t;
#line 134 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct addrinfo_response {
   struct rheader header ;
   int ret ;
   int _errno ;
   int _h_errno ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct addrinfo_response addrinfo_response_t;
#line 142 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct addrinfo_serialization {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   size_t ai_addrlen ;
   size_t canonname_len ;
};
#line 142 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct addrinfo_serialization addrinfo_serialization_t;
#line 152 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct nameinfo_request {
   struct rheader header ;
   int flags ;
   socklen_t sockaddr_len ;
   int gethost ;
   int getserv ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct nameinfo_request nameinfo_request_t;
#line 159 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct nameinfo_response {
   struct rheader header ;
   size_t hostlen ;
   size_t servlen ;
   int ret ;
   int _errno ;
   int _h_errno ;
};
#line 159 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct nameinfo_response nameinfo_response_t;
#line 167 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct res_request {
   struct rheader header ;
   int class ;
   int type ;
   size_t dname_len ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct res_request res_request_t;
#line 174 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
struct res_response {
   struct rheader header ;
   int ret ;
   int _errno ;
   int _h_errno ;
};
#line 174 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef struct res_response res_response_t;
#line 181 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
union packet {
   rheader_t rheader ;
   addrinfo_request_t addrinfo_request ;
   addrinfo_response_t addrinfo_response ;
   nameinfo_request_t nameinfo_request ;
   nameinfo_response_t nameinfo_response ;
   res_request_t res_request ;
   res_response_t res_response ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
typedef union packet packet_t;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 277 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_query)(char const   * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  u_char * ,
                                                                                  int  ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_search)(char const   * ,
                                                                                   int  ,
                                                                                   int  ,
                                                                                   u_char * ,
                                                                                   int  ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.h"
asyncns_t *asyncns_new(unsigned int n_proc ) ;
#line 61
void asyncns_free(asyncns_t *asyncns ) ;
#line 66
int asyncns_fd(asyncns_t *asyncns ) ;
#line 73
int asyncns_wait(asyncns_t *asyncns , int block ) ;
#line 80
asyncns_query_t *asyncns_getaddrinfo(asyncns_t *asyncns , char const   *node , char const   *service ,
                                     struct addrinfo  const  *hints ) ;
#line 89
int asyncns_getaddrinfo_done(asyncns_t *asyncns , asyncns_query_t *q , struct addrinfo **ret_res ) ;
#line 97
asyncns_query_t *asyncns_getnameinfo(asyncns_t *asyncns , struct sockaddr  const  *sa ,
                                     socklen_t salen , int flags , int gethost , int getserv ) ;
#line 104
int asyncns_getnameinfo_done(asyncns_t *asyncns , asyncns_query_t *q , char *ret_host ,
                             size_t hostlen , char *ret_serv , size_t servlen ) ;
#line 110
asyncns_query_t *asyncns_res_query(asyncns_t *asyncns , char const   *dname , int class ,
                                   int type ) ;
#line 116
asyncns_query_t *asyncns_res_search(asyncns_t *asyncns , char const   *dname , int class ,
                                    int type ) ;
#line 125
int asyncns_res_done(asyncns_t *asyncns , asyncns_query_t *q , unsigned char **answer ) ;
#line 130
asyncns_query_t *asyncns_getnext(asyncns_t *asyncns ) ;
#line 134
int asyncns_getnqueries(asyncns_t *asyncns ) ;
#line 138
void asyncns_cancel(asyncns_t *asyncns , asyncns_query_t *q ) ;
#line 143
void asyncns_freeaddrinfo(struct addrinfo *ai ) ;
#line 146
void asyncns_freeanswer(unsigned char *answer ) ;
#line 149
int asyncns_isdone(asyncns_t *asyncns , asyncns_query_t *q ) ;
#line 152
void asyncns_setuserdata(asyncns_t *asyncns , asyncns_query_t *q , void *userdata ) ;
#line 157
void *asyncns_getuserdata(asyncns_t *asyncns , asyncns_query_t *q ) ;
#line 372 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int fd_nonblock(int fd ) 
{ 
  int i ;
  int tmp ;

  {
#line 374
  if (! (fd >= 0)) {
    {
#line 374
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  374U, "fd_nonblock");
    }
  }
  {
#line 376
  i = fcntl(fd, 3, 0);
  }
#line 376
  if (i < 0) {
#line 377
    return (-1);
  }
#line 379
  if (i & 2048) {
#line 380
    return (0);
  }
  {
#line 382
  tmp = fcntl(fd, 4, i | 2048);
  }
#line 382
  return (tmp);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int fd_cloexec(int fd ) 
{ 
  int v ;
  int tmp ;

  {
#line 387
  if (! (fd >= 0)) {
    {
#line 387
    __assert_fail("fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  387U, "fd_cloexec");
    }
  }
  {
#line 389
  v = fcntl(fd, 1, 0);
  }
#line 389
  if (v < 0) {
#line 390
    return (-1);
  }
#line 392
  if (v & 1) {
#line 393
    return (0);
  }
  {
#line 395
  tmp = fcntl(fd, 2, v | 1);
  }
#line 395
  return (tmp);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int send_died(int out_fd ) 
{ 
  rheader_t rh ;
  ssize_t tmp ;

  {
#line 400
  if (! (out_fd > 0)) {
    {
#line 400
    __assert_fail("out_fd > 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  400U, "send_died");
    }
  }
  {
#line 402
  memset((void *)(& rh), 0, sizeof(rh));
#line 403
  rh.type = (query_type_t )8;
#line 404
  rh.id = 0U;
#line 405
  rh.length = sizeof(rh);
#line 407
  tmp = send(out_fd, (void const   *)(& rh), rh.length, 16384);
  }
#line 407
  return ((int )tmp);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static void *serialize_addrinfo(void *p , struct addrinfo  const  *ai , size_t *length ,
                                size_t maxlength ) 
{ 
  addrinfo_serialization_t s ;
  size_t cnl ;
  size_t l ;
  size_t tmp ;

  {
#line 413
  if (! p) {
    {
#line 413
    __assert_fail("p", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  413U, "serialize_addrinfo");
    }
  }
#line 414
  if (! ai) {
    {
#line 414
    __assert_fail("ai", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  414U, "serialize_addrinfo");
    }
  }
#line 415
  if (! length) {
    {
#line 415
    __assert_fail("length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  415U, "serialize_addrinfo");
    }
  }
#line 416
  if (! (*length <= maxlength)) {
    {
#line 416
    __assert_fail("*length <= maxlength", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  416U, "serialize_addrinfo");
    }
  }
#line 418
  if (ai->ai_canonname) {
    {
#line 418
    tmp = strlen((char const   *)ai->ai_canonname);
#line 418
    cnl = tmp + 1UL;
    }
  } else {
#line 418
    cnl = (size_t )0;
  }
#line 419
  l = (sizeof(addrinfo_serialization_t ) + (unsigned long )ai->ai_addrlen) + cnl;
#line 421
  if (*length + l > maxlength) {
#line 422
    return ((void *)0);
  }
  {
#line 424
  s.ai_flags = (int )ai->ai_flags;
#line 425
  s.ai_family = (int )ai->ai_family;
#line 426
  s.ai_socktype = (int )ai->ai_socktype;
#line 427
  s.ai_protocol = (int )ai->ai_protocol;
#line 428
  s.ai_addrlen = (size_t )ai->ai_addrlen;
#line 429
  s.canonname_len = cnl;
#line 431
  memcpy((void */* __restrict  */)((uint8_t *)p), (void const   */* __restrict  */)(& s),
         sizeof(addrinfo_serialization_t ));
#line 432
  memcpy((void */* __restrict  */)((uint8_t *)p + sizeof(addrinfo_serialization_t )),
         (void const   */* __restrict  */)ai->ai_addr, (size_t )ai->ai_addrlen);
  }
#line 434
  if (ai->ai_canonname) {
    {
#line 435
    strcpy((char */* __restrict  */)(((char *)p + sizeof(addrinfo_serialization_t )) + ai->ai_addrlen),
           (char const   */* __restrict  */)ai->ai_canonname);
    }
  }
#line 437
  *length += l;
#line 438
  return ((void *)((uint8_t *)p + l));
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int send_addrinfo_reply(int out_fd , unsigned int id , int ret , struct addrinfo *ai ,
                               int _errno , int _h_errno ) 
{ 
  addrinfo_response_t data[10240UL / sizeof(addrinfo_response_t ) + 1UL] ;
  addrinfo_response_t *resp ;
  void *p ;
  struct addrinfo *k ;
  ssize_t tmp ;

  {
#line 443
  resp = data;
#line 444
  if (! (out_fd >= 0)) {
    {
#line 444
    __assert_fail("out_fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  444U, "send_addrinfo_reply");
    }
  }
  {
#line 446
  memset((void *)(data), 0, sizeof(data));
#line 447
  resp->header.type = (query_type_t )1;
#line 448
  resp->header.id = id;
#line 449
  resp->header.length = sizeof(addrinfo_response_t );
#line 450
  resp->ret = ret;
#line 451
  resp->_errno = _errno;
#line 452
  resp->_h_errno = _h_errno;
  }
#line 454
  if (ret == 0) {
#line 454
    if (ai) {
#line 455
      p = (void *)(data + 1);
#line 458
      k = ai;
      {
#line 458
      while (1) {
        while_continue: /* CIL Label */ ;
#line 458
        if (! k) {
#line 458
          goto while_break;
        }
        {
#line 460
        p = serialize_addrinfo(p, (struct addrinfo  const  *)k, & resp->header.length,
                               (size_t )(((char *)(data) + 10240) - (char *)p));
        }
#line 460
        if (! p) {
#line 461
          resp->ret = -10;
#line 462
          goto while_break;
        }
#line 458
        k = k->ai_next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 467
  if (ai) {
    {
#line 468
    freeaddrinfo(ai);
    }
  }
  {
#line 470
  tmp = send(out_fd, (void const   *)resp, resp->header.length, 16384);
  }
#line 470
  return ((int )tmp);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int send_nameinfo_reply(int out_fd , unsigned int id , int ret , char const   *host ,
                               char const   *serv , int _errno , int _h_errno ) 
{ 
  nameinfo_response_t data[10240UL / sizeof(nameinfo_response_t ) + 1UL] ;
  size_t hl ;
  size_t sl ;
  nameinfo_response_t *resp ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 476
  resp = data;
#line 478
  if (! (out_fd >= 0)) {
    {
#line 478
    __assert_fail("out_fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  478U, "send_nameinfo_reply");
    }
  }
#line 480
  if (serv) {
    {
#line 480
    tmp = strlen(serv);
#line 480
    sl = tmp + 1UL;
    }
  } else {
#line 480
    sl = (size_t )0;
  }
#line 481
  if (host) {
    {
#line 481
    tmp___0 = strlen(host);
#line 481
    hl = tmp___0 + 1UL;
    }
  } else {
#line 481
    hl = (size_t )0;
  }
  {
#line 483
  memset((void *)(data), 0, sizeof(data));
#line 484
  resp->header.type = (query_type_t )3;
#line 485
  resp->header.id = id;
#line 486
  resp->header.length = (sizeof(nameinfo_response_t ) + hl) + sl;
#line 487
  resp->ret = ret;
#line 488
  resp->_errno = _errno;
#line 489
  resp->_h_errno = _h_errno;
#line 490
  resp->hostlen = hl;
#line 491
  resp->servlen = sl;
  }
#line 493
  if (! (sizeof(data) >= resp->header.length)) {
    {
#line 493
    __assert_fail("sizeof(data) >= resp->header.length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  493U, "send_nameinfo_reply");
    }
  }
#line 495
  if (host) {
    {
#line 496
    memcpy((void */* __restrict  */)((uint8_t *)(data) + sizeof(nameinfo_response_t )),
           (void const   */* __restrict  */)host, hl);
    }
  }
#line 498
  if (serv) {
    {
#line 499
    memcpy((void */* __restrict  */)(((uint8_t *)(data) + sizeof(nameinfo_response_t )) + hl),
           (void const   */* __restrict  */)serv, sl);
    }
  }
  {
#line 501
  tmp___1 = send(out_fd, (void const   *)resp, resp->header.length, 16384);
  }
#line 501
  return ((int )tmp___1);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int send_res_reply(int out_fd , unsigned int id , unsigned char const   *answer ,
                          int ret , int _errno , int _h_errno ) 
{ 
  res_response_t data[10240UL / sizeof(res_response_t ) + 1UL] ;
  res_response_t *resp ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 506
  resp = data;
#line 508
  if (! (out_fd >= 0)) {
    {
#line 508
    __assert_fail("out_fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  508U, "send_res_reply");
    }
  }
  {
#line 510
  memset((void *)(data), 0, sizeof(data));
#line 511
  resp->header.type = (query_type_t )6;
#line 512
  resp->header.id = id;
  }
#line 513
  if (ret < 0) {
#line 513
    tmp = 0;
  } else {
#line 513
    tmp = ret;
  }
#line 513
  resp->header.length = sizeof(res_response_t ) + (unsigned long )tmp;
#line 514
  resp->ret = ret;
#line 515
  resp->_errno = _errno;
#line 516
  resp->_h_errno = _h_errno;
#line 518
  if (! (sizeof(data) >= resp->header.length)) {
    {
#line 518
    __assert_fail("sizeof(data) >= resp->header.length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  518U, "send_res_reply");
    }
  }
#line 520
  if (ret > 0) {
    {
#line 521
    memcpy((void */* __restrict  */)((uint8_t *)(data) + sizeof(res_response_t )),
           (void const   */* __restrict  */)answer, (size_t )ret);
    }
  }
  {
#line 523
  tmp___0 = send(out_fd, (void const   *)resp, resp->header.length, 16384);
  }
#line 523
  return ((int )tmp___0);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int handle_request(int out_fd , packet_t const   *packet , size_t length ) 
{ 
  rheader_t const   *req ;
  struct addrinfo ai ;
  struct addrinfo *result ;
  addrinfo_request_t const   *ai_req ;
  char const   *node ;
  char const   *service ;
  int ret ;
  struct addrinfo *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int ret___0 ;
  nameinfo_request_t const   *ni_req ;
  char hostbuf[1025] ;
  char servbuf[32] ;
  struct sockaddr_storage sa ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int ret___1 ;
  HEADER answer[10240UL / sizeof(HEADER ) + 1UL] ;
  res_request_t const   *res_req ;
  char const   *dname ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;

  {
#line 528
  if (! (out_fd >= 0)) {
    {
#line 528
    __assert_fail("out_fd >= 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  528U, "handle_request");
    }
  }
#line 530
  req = & packet->rheader;
#line 531
  if (! req) {
    {
#line 531
    __assert_fail("req", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  531U, "handle_request");
    }
  }
#line 532
  if (! (length >= sizeof(rheader_t ))) {
    {
#line 532
    __assert_fail("length >= sizeof(rheader_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  532U, "handle_request");
    }
  }
#line 533
  if (! (length == (size_t )req->length)) {
    {
#line 533
    __assert_fail("length == req->length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  533U, "handle_request");
    }
  }
  {
#line 537
  if ((unsigned int const   )req->type == 0U) {
#line 537
    goto case_0;
  }
#line 563
  if ((unsigned int const   )req->type == 2U) {
#line 563
    goto case_2;
  }
#line 586
  if ((unsigned int const   )req->type == 5U) {
#line 586
    goto case_5;
  }
#line 586
  if ((unsigned int const   )req->type == 4U) {
#line 586
    goto case_5;
  }
#line 605
  if ((unsigned int const   )req->type == 7U) {
#line 605
    goto case_7;
  }
#line 609
  goto switch_default;
  case_0: /* CIL Label */ 
#line 538
  result = (struct addrinfo *)((void *)0);
#line 539
  ai_req = & packet->addrinfo_request;
#line 543
  if (! (length >= sizeof(addrinfo_request_t ))) {
    {
#line 543
    __assert_fail("length >= sizeof(addrinfo_request_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  543U, "handle_request");
    }
  }
#line 544
  if (! (length == (sizeof(addrinfo_request_t ) + (unsigned long )ai_req->node_len) + (unsigned long )ai_req->service_len)) {
    {
#line 544
    __assert_fail("length == sizeof(addrinfo_request_t) + ai_req->node_len + ai_req->service_len",
                  "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  544U, "handle_request");
    }
  }
  {
#line 546
  memset((void *)(& ai), 0, sizeof(ai));
#line 547
  ai.ai_flags = (int )ai_req->ai_flags;
#line 548
  ai.ai_family = (int )ai_req->ai_family;
#line 549
  ai.ai_socktype = (int )ai_req->ai_socktype;
#line 550
  ai.ai_protocol = (int )ai_req->ai_protocol;
  }
#line 552
  if (ai_req->node_len) {
#line 552
    node = (char const   *)ai_req + sizeof(addrinfo_request_t );
  } else {
#line 552
    node = (char const   *)((void *)0);
  }
#line 553
  if (ai_req->service_len) {
#line 553
    service = ((char const   *)ai_req + sizeof(addrinfo_request_t )) + ai_req->node_len;
  } else {
#line 553
    service = (char const   *)((void *)0);
  }
#line 555
  if (ai_req->hints_is_null) {
#line 555
    tmp = (struct addrinfo *)((void *)0);
  } else {
#line 555
    tmp = & ai;
  }
  {
#line 555
  ret = getaddrinfo((char const   */* __restrict  */)node, (char const   */* __restrict  */)service,
                    (struct addrinfo  const  */* __restrict  */)tmp, (struct addrinfo **/* __restrict  */)(& result));
#line 560
  tmp___0 = __h_errno_location();
#line 560
  tmp___1 = __errno_location();
#line 560
  tmp___2 = send_addrinfo_reply(out_fd, (unsigned int )req->id, ret, result, *tmp___1,
                                *tmp___0);
  }
#line 560
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 565
  ni_req = & packet->nameinfo_request;
#line 569
  if (! (length >= sizeof(nameinfo_request_t ))) {
    {
#line 569
    __assert_fail("length >= sizeof(nameinfo_request_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  569U, "handle_request");
    }
  }
#line 570
  if (! (length == sizeof(nameinfo_request_t ) + (unsigned long )ni_req->sockaddr_len)) {
    {
#line 570
    __assert_fail("length == sizeof(nameinfo_request_t) + ni_req->sockaddr_len", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  570U, "handle_request");
    }
  }
  {
#line 572
  memcpy((void */* __restrict  */)(& sa), (void const   */* __restrict  */)((uint8_t const   *)ni_req + sizeof(nameinfo_request_t )),
         (size_t )ni_req->sockaddr_len);
  }
#line 574
  if (ni_req->getserv) {
#line 574
    tmp___3 = sizeof(servbuf);
  } else {
#line 574
    tmp___3 = 0UL;
  }
#line 574
  if (ni_req->getserv) {
#line 574
    tmp___4 = servbuf;
  } else {
#line 574
    tmp___4 = (char *)((void *)0);
  }
#line 574
  if (ni_req->gethost) {
#line 574
    tmp___5 = sizeof(hostbuf);
  } else {
#line 574
    tmp___5 = 0UL;
  }
#line 574
  if (ni_req->gethost) {
#line 574
    tmp___6 = hostbuf;
  } else {
#line 574
    tmp___6 = (char *)((void *)0);
  }
  {
#line 574
  ret___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sa)),
                        (socklen_t )ni_req->sockaddr_len, (char */* __restrict  */)tmp___6,
                        (socklen_t )tmp___5, (char */* __restrict  */)tmp___4, (socklen_t )tmp___3,
                        (int )ni_req->flags);
#line 579
  tmp___7 = __h_errno_location();
#line 579
  tmp___8 = __errno_location();
  }
#line 579
  if (ret___0 == 0) {
#line 579
    if (ni_req->getserv) {
#line 579
      tmp___9 = servbuf;
    } else {
#line 579
      tmp___9 = (char *)((void *)0);
    }
  } else {
#line 579
    tmp___9 = (char *)((void *)0);
  }
#line 579
  if (ret___0 == 0) {
#line 579
    if (ni_req->gethost) {
#line 579
      tmp___10 = hostbuf;
    } else {
#line 579
      tmp___10 = (char *)((void *)0);
    }
  } else {
#line 579
    tmp___10 = (char *)((void *)0);
  }
  {
#line 579
  tmp___11 = send_nameinfo_reply(out_fd, (unsigned int )req->id, ret___0, (char const   *)tmp___10,
                                 (char const   *)tmp___9, *tmp___8, *tmp___7);
  }
#line 579
  return (tmp___11);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 589
  res_req = & packet->res_request;
#line 592
  if (! (length >= sizeof(res_request_t ))) {
    {
#line 592
    __assert_fail("length >= sizeof(res_request_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  592U, "handle_request");
    }
  }
#line 593
  if (! (length == sizeof(res_request_t ) + (unsigned long )res_req->dname_len)) {
    {
#line 593
    __assert_fail("length == sizeof(res_request_t) + res_req->dname_len", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  593U, "handle_request");
    }
  }
#line 595
  dname = (char const   *)req + sizeof(res_request_t );
#line 597
  if ((unsigned int const   )req->type == 4U) {
    {
#line 598
    ret___1 = __res_query(dname, (int )res_req->class, (int )res_req->type, (unsigned char *)(answer),
                          10240);
    }
  } else {
    {
#line 600
    ret___1 = __res_search(dname, (int )res_req->class, (int )res_req->type, (unsigned char *)(answer),
                           10240);
    }
  }
  {
#line 602
  tmp___12 = __h_errno_location();
#line 602
  tmp___13 = __errno_location();
#line 602
  tmp___14 = send_res_reply(out_fd, (unsigned int )req->id, (unsigned char const   *)((unsigned char *)(answer)),
                            ret___1, *tmp___13, *tmp___12);
  }
#line 602
  return (tmp___14);
  case_7: /* CIL Label */ 
#line 607
  return (-1);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 613
  return (0);
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static void *thread_worker(void *p ) 
{ 
  asyncns_t *asyncns ;
  sigset_t fullset ;
  packet_t buf[10240UL / sizeof(packet_t ) + 1UL] ;
  ssize_t length ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 729
  asyncns = (asyncns_t *)p;
#line 733
  sigfillset(& fullset);
#line 734
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& fullset), (__sigset_t */* __restrict  */)((void *)0));
  }
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (! asyncns->dead)) {
#line 736
      goto while_break;
    }
    {
#line 740
    length = recv(asyncns->fds[0], (void *)(buf), sizeof(buf), 0);
    }
#line 740
    if (length <= 0L) {
#line 742
      if (length < 0L) {
        {
#line 742
        tmp = __errno_location();
        }
#line 742
        if (*tmp == 11) {
#line 744
          goto while_continue;
        } else {
          {
#line 742
          tmp___0 = __errno_location();
          }
#line 742
          if (*tmp___0 == 4) {
#line 744
            goto while_continue;
          }
        }
      }
#line 746
      goto while_break;
    }
#line 749
    if (asyncns->dead) {
#line 750
      goto while_break;
    }
    {
#line 752
    tmp___1 = handle_request(asyncns->fds[3], (packet_t const   *)(buf), (size_t )length);
    }
#line 752
    if (tmp___1 < 0) {
#line 753
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 756
  send_died(asyncns->fds[3]);
  }
#line 758
  return ((void *)0);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_t *asyncns_new(unsigned int n_proc ) 
{ 
  asyncns_t *asyncns ;
  int i ;
  int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int r ;
  int *tmp___3 ;
  unsigned int tmp___4 ;
  asyncns_query_t *tmp___5 ;

  {
#line 764
  asyncns = (asyncns_t *)((void *)0);
#line 766
  if (! (n_proc >= 1U)) {
    {
#line 766
    __assert_fail("n_proc >= 1", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  766U, "asyncns_new");
    }
  }
#line 768
  if (n_proc > 16U) {
#line 769
    n_proc = 16U;
  }
  {
#line 771
  tmp___0 = malloc(sizeof(asyncns_t ));
#line 771
  asyncns = (asyncns_t *)tmp___0;
  }
#line 771
  if (! asyncns) {
    {
#line 772
    tmp = __errno_location();
#line 772
    *tmp = 12;
    }
#line 773
    goto fail;
  }
#line 776
  asyncns->dead = 0;
#line 777
  asyncns->valid_workers = 0U;
#line 779
  i = 0;
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (i < 4)) {
#line 779
      goto while_break;
    }
#line 780
    asyncns->fds[i] = -1;
#line 779
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 782
  memset((void *)(asyncns->queries), 0, sizeof(asyncns->queries));
#line 784
  tmp___1 = socketpair(1, 2, 0, (int *)(asyncns->fds));
  }
#line 784
  if (tmp___1 < 0) {
#line 786
    goto fail;
  } else {
    {
#line 784
    tmp___2 = socketpair(1, 2, 0, (int *)(asyncns->fds + 2));
    }
#line 784
    if (tmp___2 < 0) {
#line 786
      goto fail;
    }
  }
#line 788
  i = 0;
  {
#line 788
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 788
    if (! (i < 4)) {
#line 788
      goto while_break___0;
    }
    {
#line 789
    fd_cloexec(asyncns->fds[i]);
#line 788
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 791
  asyncns->valid_workers = 0U;
  {
#line 791
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 791
    if (! (asyncns->valid_workers < n_proc)) {
#line 791
      goto while_break___1;
    }
    {
#line 809
    r = pthread_create((pthread_t */* __restrict  */)(& asyncns->workers[asyncns->valid_workers]),
                       (pthread_attr_t const   */* __restrict  */)((void *)0), & thread_worker,
                       (void */* __restrict  */)asyncns);
    }
#line 809
    if (r != 0) {
      {
#line 810
      tmp___3 = __errno_location();
#line 810
      *tmp___3 = r;
      }
#line 811
      goto fail;
    }
#line 791
    (asyncns->valid_workers) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 822
  tmp___4 = 0U;
#line 822
  asyncns->current_id = tmp___4;
#line 822
  asyncns->current_index = tmp___4;
#line 823
  tmp___5 = (asyncns_query_t *)((void *)0);
#line 823
  asyncns->done_tail = tmp___5;
#line 823
  asyncns->done_head = tmp___5;
#line 824
  asyncns->n_queries = 0;
#line 826
  fd_nonblock(asyncns->fds[2]);
  }
#line 828
  return (asyncns);
  fail: 
#line 831
  if (asyncns) {
    {
#line 832
    asyncns_free(asyncns);
    }
  }
#line 834
  return ((asyncns_t *)((void *)0));
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void asyncns_free(asyncns_t *asyncns ) 
{ 
  int i ;
  int saved_errno ;
  int *tmp ;
  unsigned int p ;
  rheader_t req ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 839
  tmp = __errno_location();
#line 839
  saved_errno = *tmp;
  }
#line 842
  if (! asyncns) {
    {
#line 842
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  842U, "asyncns_free");
    }
  }
#line 844
  asyncns->dead = 1;
#line 846
  if (asyncns->fds[1] >= 0) {
    {
#line 849
    memset((void *)(& req), 0, sizeof(req));
#line 850
    req.type = (query_type_t )7;
#line 851
    req.length = sizeof(req);
#line 852
    req.id = 0U;
#line 855
    p = 0U;
    }
    {
#line 855
    while (1) {
      while_continue: /* CIL Label */ ;
#line 855
      if (! (p < asyncns->valid_workers)) {
#line 855
        goto while_break;
      }
      {
#line 856
      send(asyncns->fds[1], (void const   *)(& req), req.length, 16384);
#line 855
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 860
  p = 0U;
  {
#line 860
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 860
    if (! (p < asyncns->valid_workers)) {
#line 860
      goto while_break___0;
    }
    {
#line 868
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 869
      tmp___0 = pthread_join(asyncns->workers[p], (void **)((void *)0));
      }
#line 869
      if (tmp___0 != 4) {
#line 870
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 860
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 876
  i = 0;
  {
#line 876
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 876
    if (! (i < 4)) {
#line 876
      goto while_break___2;
    }
#line 877
    if (asyncns->fds[i] >= 0) {
      {
#line 878
      close(asyncns->fds[i]);
      }
    }
#line 876
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 880
  p = 0U;
  {
#line 880
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 880
    if (! (p < 256U)) {
#line 880
      goto while_break___3;
    }
#line 881
    if (asyncns->queries[p]) {
      {
#line 882
      asyncns_cancel(asyncns, asyncns->queries[p]);
      }
    }
#line 880
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 884
  free((void *)asyncns);
#line 886
  tmp___1 = __errno_location();
#line 886
  *tmp___1 = saved_errno;
  }
#line 887
  return;
}
}
#line 889 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_fd(asyncns_t *asyncns ) 
{ 


  {
#line 890
  if (! asyncns) {
    {
#line 890
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  890U, "asyncns_fd");
    }
  }
#line 892
  return (asyncns->fds[2]);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static asyncns_query_t *lookup_query(asyncns_t *asyncns , unsigned int id ) 
{ 
  asyncns_query_t *q ;

  {
#line 897
  if (! asyncns) {
    {
#line 897
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  897U, "lookup_query");
    }
  }
#line 899
  q = asyncns->queries[id % 256U];
#line 899
  if (q) {
#line 900
    if (q->id == id) {
#line 901
      return (q);
    }
  }
#line 903
  return ((asyncns_query_t *)((void *)0));
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static void complete_query(asyncns_t *asyncns , asyncns_query_t *q ) 
{ 
  asyncns_query_t *tmp ;

  {
#line 907
  if (! asyncns) {
    {
#line 907
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  907U, "complete_query");
    }
  }
#line 908
  if (! q) {
    {
#line 908
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  908U, "complete_query");
    }
  }
#line 909
  if (! (! q->done)) {
    {
#line 909
    __assert_fail("!q->done", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  909U, "complete_query");
    }
  }
#line 911
  q->done = 1;
#line 913
  tmp = asyncns->done_tail;
#line 913
  q->done_prev = tmp;
#line 913
  if (tmp) {
#line 914
    (asyncns->done_tail)->done_next = q;
  } else {
#line 916
    asyncns->done_head = q;
  }
#line 918
  asyncns->done_tail = q;
#line 919
  q->done_next = (asyncns_query_t *)((void *)0);
#line 920
  return;
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static void const   *unserialize_addrinfo(void const   *p , struct addrinfo **ret_ai ,
                                          size_t *length ) 
{ 
  addrinfo_serialization_t s ;
  size_t l ;
  struct addrinfo *ai ;
  void *tmp ;
  struct sockaddr *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 926
  if (! p) {
    {
#line 926
    __assert_fail("p", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  926U, "unserialize_addrinfo");
    }
  }
#line 927
  if (! ret_ai) {
    {
#line 927
    __assert_fail("ret_ai", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  927U, "unserialize_addrinfo");
    }
  }
#line 928
  if (! length) {
    {
#line 928
    __assert_fail("length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  928U, "unserialize_addrinfo");
    }
  }
#line 930
  if (*length < sizeof(addrinfo_serialization_t )) {
#line 931
    return ((void const   *)((void *)0));
  }
  {
#line 933
  memcpy((void */* __restrict  */)(& s), (void const   */* __restrict  */)p, sizeof(s));
#line 935
  l = (sizeof(addrinfo_serialization_t ) + s.ai_addrlen) + s.canonname_len;
  }
#line 936
  if (*length < l) {
#line 937
    return ((void const   *)((void *)0));
  }
  {
#line 939
  tmp = malloc(sizeof(struct addrinfo ));
#line 939
  ai = (struct addrinfo *)tmp;
  }
#line 939
  if (! ai) {
#line 940
    goto fail;
  }
#line 942
  ai->ai_addr = (struct sockaddr *)((void *)0);
#line 943
  ai->ai_canonname = (char *)((void *)0);
#line 944
  ai->ai_next = (struct addrinfo *)((void *)0);
#line 946
  if (s.ai_addrlen) {
    {
#line 946
    tmp___1 = malloc(s.ai_addrlen);
#line 946
    tmp___0 = (struct sockaddr *)tmp___1;
#line 946
    ai->ai_addr = tmp___0;
    }
#line 946
    if (! tmp___0) {
#line 947
      goto fail;
    }
  }
#line 949
  if (s.canonname_len) {
    {
#line 949
    tmp___3 = malloc(s.canonname_len);
#line 949
    tmp___2 = (char *)tmp___3;
#line 949
    ai->ai_canonname = tmp___2;
    }
#line 949
    if (! tmp___2) {
#line 950
      goto fail;
    }
  }
#line 952
  ai->ai_flags = s.ai_flags;
#line 953
  ai->ai_family = s.ai_family;
#line 954
  ai->ai_socktype = s.ai_socktype;
#line 955
  ai->ai_protocol = s.ai_protocol;
#line 956
  ai->ai_addrlen = (socklen_t )s.ai_addrlen;
#line 958
  if (ai->ai_addr) {
    {
#line 959
    memcpy((void */* __restrict  */)ai->ai_addr, (void const   */* __restrict  */)((uint8_t const   *)p + sizeof(addrinfo_serialization_t )),
           s.ai_addrlen);
    }
  }
#line 961
  if (ai->ai_canonname) {
    {
#line 962
    memcpy((void */* __restrict  */)ai->ai_canonname, (void const   */* __restrict  */)(((uint8_t const   *)p + sizeof(addrinfo_serialization_t )) + s.ai_addrlen),
           s.canonname_len);
    }
  }
#line 964
  *length -= l;
#line 965
  *ret_ai = ai;
#line 967
  return ((void const   *)((uint8_t const   *)p + l));
  fail: 
#line 971
  if (ai) {
    {
#line 972
    asyncns_freeaddrinfo(ai);
    }
  }
#line 974
  return ((void const   *)((void *)0));
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static int handle_response(asyncns_t *asyncns , packet_t const   *packet , size_t length ) 
{ 
  rheader_t const   *resp ;
  asyncns_query_t *q ;
  addrinfo_response_t const   *ai_resp ;
  void const   *p ;
  size_t l ;
  struct addrinfo *prev ;
  struct addrinfo *ai ;
  nameinfo_response_t const   *ni_resp ;
  char *tmp ;
  char *tmp___0 ;
  res_response_t const   *res_resp ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 981
  if (! asyncns) {
    {
#line 981
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  981U, "handle_response");
    }
  }
#line 983
  resp = & packet->rheader;
#line 984
  if (! resp) {
    {
#line 984
    __assert_fail("resp", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  984U, "handle_response");
    }
  }
#line 985
  if (! (length >= sizeof(rheader_t ))) {
    {
#line 985
    __assert_fail("length >= sizeof(rheader_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  985U, "handle_response");
    }
  }
#line 986
  if (! (length == (size_t )resp->length)) {
    {
#line 986
    __assert_fail("length == resp->length", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  986U, "handle_response");
    }
  }
#line 988
  if ((unsigned int const   )resp->type == 8U) {
#line 989
    asyncns->dead = 1;
#line 990
    return (0);
  }
  {
#line 993
  q = lookup_query(asyncns, (unsigned int )resp->id);
  }
#line 993
  if (! q) {
#line 994
    return (0);
  }
  {
#line 997
  if ((unsigned int const   )resp->type == 1U) {
#line 997
    goto case_1;
  }
#line 1033
  if ((unsigned int const   )resp->type == 3U) {
#line 1033
    goto case_3;
  }
#line 1055
  if ((unsigned int const   )resp->type == 6U) {
#line 1055
    goto case_6;
  }
#line 1077
  goto switch_default;
  case_1: /* CIL Label */ 
#line 998
  ai_resp = & packet->addrinfo_response;
#line 1001
  prev = (struct addrinfo *)((void *)0);
#line 1003
  if (! (length >= sizeof(addrinfo_response_t ))) {
    {
#line 1003
    __assert_fail("length >= sizeof(addrinfo_response_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1003U, "handle_response");
    }
  }
#line 1004
  if (! ((unsigned int )q->type == 0U)) {
    {
#line 1004
    __assert_fail("q->type == REQUEST_ADDRINFO", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1004U, "handle_response");
    }
  }
#line 1006
  q->ret = (int )ai_resp->ret;
#line 1007
  q->_errno = (int )ai_resp->_errno;
#line 1008
  q->_h_errno = (int )ai_resp->_h_errno;
#line 1009
  l = length - sizeof(addrinfo_response_t );
#line 1010
  p = (void const   *)((uint8_t const   *)resp + sizeof(addrinfo_response_t ));
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1012
    if (l > 0UL) {
#line 1012
      if (! p) {
#line 1012
        goto while_break;
      }
    } else {
#line 1012
      goto while_break;
    }
    {
#line 1013
    ai = (struct addrinfo *)((void *)0);
#line 1014
    p = unserialize_addrinfo(p, & ai, & l);
    }
#line 1016
    if (! p) {
#line 1017
      q->ret = -10;
#line 1018
      goto while_break;
    } else
#line 1016
    if (! ai) {
#line 1017
      q->ret = -10;
#line 1018
      goto while_break;
    }
#line 1021
    if (prev) {
#line 1022
      prev->ai_next = ai;
    } else {
#line 1024
      q->addrinfo = ai;
    }
#line 1026
    prev = ai;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1029
  complete_query(asyncns, q);
  }
#line 1030
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1034
  ni_resp = & packet->nameinfo_response;
#line 1036
  if (! (length >= sizeof(nameinfo_response_t ))) {
    {
#line 1036
    __assert_fail("length >= sizeof(nameinfo_response_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1036U, "handle_response");
    }
  }
#line 1037
  if (! ((unsigned int )q->type == 2U)) {
    {
#line 1037
    __assert_fail("q->type == REQUEST_NAMEINFO", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1037U, "handle_response");
    }
  }
#line 1039
  q->ret = (int )ni_resp->ret;
#line 1040
  q->_errno = (int )ni_resp->_errno;
#line 1041
  q->_h_errno = (int )ni_resp->_h_errno;
#line 1043
  if (ni_resp->hostlen) {
    {
#line 1044
    tmp = strndup((char const   *)ni_resp + sizeof(nameinfo_response_t ), (size_t )(ni_resp->hostlen - 1UL));
#line 1044
    q->host = tmp;
    }
#line 1044
    if (! tmp) {
#line 1045
      q->ret = -10;
    }
  }
#line 1047
  if (ni_resp->servlen) {
    {
#line 1048
    tmp___0 = strndup(((char const   *)ni_resp + sizeof(nameinfo_response_t )) + ni_resp->hostlen,
                      (size_t )(ni_resp->servlen - 1UL));
#line 1048
    q->serv = tmp___0;
    }
#line 1048
    if (! tmp___0) {
#line 1049
      q->ret = -10;
    }
  }
  {
#line 1051
  complete_query(asyncns, q);
  }
#line 1052
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1056
  res_resp = & packet->res_response;
#line 1058
  if (! (length >= sizeof(res_response_t ))) {
    {
#line 1058
    __assert_fail("length >= sizeof(res_response_t)", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1058U, "handle_response");
    }
  }
#line 1059
  if (! ((unsigned int )q->type == 4U)) {
#line 1059
    if (! ((unsigned int )q->type == 5U)) {
      {
#line 1059
      __assert_fail("q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH",
                    "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                    1059U, "handle_response");
      }
    }
  }
#line 1061
  q->ret = (int )res_resp->ret;
#line 1062
  q->_errno = (int )res_resp->_errno;
#line 1063
  q->_h_errno = (int )res_resp->_h_errno;
#line 1065
  if (res_resp->ret >= 0) {
    {
#line 1066
    tmp___2 = malloc((size_t )res_resp->ret);
#line 1066
    tmp___1 = (char *)tmp___2;
#line 1066
    q->serv = tmp___1;
    }
#line 1066
    if (tmp___1) {
      {
#line 1070
      memcpy((void */* __restrict  */)q->serv, (void const   */* __restrict  */)((char const   *)resp + sizeof(res_response_t )),
             (size_t )res_resp->ret);
      }
    } else {
#line 1067
      q->ret = -1;
#line 1068
      q->_errno = 12;
    }
  }
  {
#line 1073
  complete_query(asyncns, q);
  }
#line 1074
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1081
  return (0);
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_wait(asyncns_t *asyncns , int block ) 
{ 
  int handled ;
  packet_t buf[10240UL / sizeof(packet_t ) + 1UL] ;
  ssize_t l ;
  int *tmp ;
  fd_set fds ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1085
  handled = 0;
#line 1086
  if (! asyncns) {
    {
#line 1086
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1086U, "asyncns_wait");
    }
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1092
    if (asyncns->dead) {
      {
#line 1093
      tmp = __errno_location();
#line 1093
      *tmp = 10;
      }
#line 1094
      return (-1);
    }
    {
#line 1097
    l = recv(asyncns->fds[2], (void *)(buf), sizeof(buf), 0);
    }
#line 1097
    if (l < 0L) {
      {
#line 1100
      tmp___0 = __errno_location();
      }
#line 1100
      if (*tmp___0 != 11) {
#line 1101
        return (-1);
      }
#line 1103
      if (! block) {
#line 1104
        return (0);
      } else
#line 1103
      if (handled) {
#line 1104
        return (0);
      }
      {
#line 1106
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1106
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 1106
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1107
      fds.fds_bits[asyncns->fds[2] / (8 * (int )sizeof(__fd_mask ))] |= 1L << asyncns->fds[2] % (8 * (int )sizeof(__fd_mask ));
#line 1109
      tmp___1 = select(asyncns->fds[2] + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 1109
      if (tmp___1 < 0) {
#line 1110
        return (-1);
      }
#line 1112
      goto __Cont;
    }
    {
#line 1115
    tmp___2 = handle_response(asyncns, (packet_t const   *)(buf), (size_t )l);
    }
#line 1115
    if (tmp___2 < 0) {
#line 1116
      return (-1);
    }
#line 1118
    handled = 1;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static asyncns_query_t *alloc_query(asyncns_t *asyncns ) 
{ 
  asyncns_query_t *q ;
  int *tmp ;
  int *tmp___0 ;
  asyncns_query_t *tmp___1 ;
  void *tmp___2 ;
  asyncns_query_t *tmp___3 ;
  char *tmp___4 ;

  {
#line 1124
  if (! asyncns) {
    {
#line 1124
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1124U, "alloc_query");
    }
  }
#line 1126
  if (asyncns->n_queries >= 256) {
    {
#line 1127
    tmp = __errno_location();
#line 1127
    *tmp = 12;
    }
#line 1128
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! asyncns->queries[asyncns->current_index]) {
#line 1131
      goto while_break;
    }
#line 1133
    (asyncns->current_index) ++;
#line 1134
    (asyncns->current_id) ++;
    {
#line 1136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1136
      if (! (asyncns->current_index >= 256U)) {
#line 1136
        goto while_break___0;
      }
#line 1137
      asyncns->current_index -= 256U;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1140
  tmp___2 = malloc(sizeof(asyncns_query_t ));
#line 1140
  tmp___1 = (asyncns_query_t *)tmp___2;
#line 1140
  asyncns->queries[asyncns->current_index] = tmp___1;
#line 1140
  q = tmp___1;
  }
#line 1140
  if (! q) {
    {
#line 1141
    tmp___0 = __errno_location();
#line 1141
    *tmp___0 = 12;
    }
#line 1142
    return ((asyncns_query_t *)((void *)0));
  }
#line 1145
  (asyncns->n_queries) ++;
#line 1147
  q->asyncns = asyncns;
#line 1148
  q->done = 0;
#line 1149
  q->id = asyncns->current_id;
#line 1150
  tmp___3 = (asyncns_query_t *)((void *)0);
#line 1150
  q->done_prev = tmp___3;
#line 1150
  q->done_next = tmp___3;
#line 1151
  q->ret = 0;
#line 1152
  q->_errno = 0;
#line 1153
  q->_h_errno = 0;
#line 1154
  q->addrinfo = (struct addrinfo *)((void *)0);
#line 1155
  q->userdata = (void *)0;
#line 1156
  tmp___4 = (char *)((void *)0);
#line 1156
  q->serv = tmp___4;
#line 1156
  q->host = tmp___4;
#line 1158
  return (q);
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_query_t *asyncns_getaddrinfo(asyncns_t *asyncns , char const   *node , char const   *service ,
                                     struct addrinfo  const  *hints ) 
{ 
  addrinfo_request_t data[10240UL / sizeof(addrinfo_request_t ) + 1UL] ;
  addrinfo_request_t *req ;
  asyncns_query_t *q ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  query_type_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 1163
  req = data;
#line 1165
  if (! asyncns) {
    {
#line 1165
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1165U, "asyncns_getaddrinfo");
    }
  }
#line 1166
  if (! node) {
#line 1166
    if (! service) {
      {
#line 1166
      __assert_fail("node || service", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                    1166U, "asyncns_getaddrinfo");
      }
    }
  }
#line 1168
  if (asyncns->dead) {
    {
#line 1169
    tmp = __errno_location();
#line 1169
    *tmp = 10;
    }
#line 1170
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1173
  q = alloc_query(asyncns);
  }
#line 1173
  if (! q) {
#line 1174
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1176
  memset((void *)req, 0, sizeof(addrinfo_request_t ));
  }
#line 1178
  if (node) {
    {
#line 1178
    tmp___0 = strlen(node);
#line 1178
    req->node_len = tmp___0 + 1UL;
    }
  } else {
#line 1178
    req->node_len = (size_t )0;
  }
#line 1179
  if (service) {
    {
#line 1179
    tmp___1 = strlen(service);
#line 1179
    req->service_len = tmp___1 + 1UL;
    }
  } else {
#line 1179
    req->service_len = (size_t )0;
  }
#line 1181
  req->header.id = q->id;
#line 1182
  tmp___2 = (query_type_t )0;
#line 1182
  q->type = tmp___2;
#line 1182
  req->header.type = tmp___2;
#line 1183
  req->header.length = (sizeof(addrinfo_request_t ) + req->node_len) + req->service_len;
#line 1185
  if (req->header.length > 10240UL) {
    {
#line 1186
    tmp___3 = __errno_location();
#line 1186
    *tmp___3 = 12;
    }
#line 1187
    goto fail;
  }
#line 1190
  tmp___4 = ! hints;
#line 1190
  req->hints_is_null = tmp___4;
#line 1190
  if (! tmp___4) {
#line 1191
    req->ai_flags = (int )hints->ai_flags;
#line 1192
    req->ai_family = (int )hints->ai_family;
#line 1193
    req->ai_socktype = (int )hints->ai_socktype;
#line 1194
    req->ai_protocol = (int )hints->ai_protocol;
  }
#line 1197
  if (node) {
    {
#line 1198
    strcpy((char */* __restrict  */)((char *)req + sizeof(addrinfo_request_t )), (char const   */* __restrict  */)node);
    }
  }
#line 1200
  if (service) {
    {
#line 1201
    strcpy((char */* __restrict  */)(((char *)req + sizeof(addrinfo_request_t )) + req->node_len),
           (char const   */* __restrict  */)service);
    }
  }
  {
#line 1203
  tmp___5 = send(asyncns->fds[1], (void const   *)req, req->header.length, 16384);
  }
#line 1203
  if (tmp___5 < 0L) {
#line 1204
    goto fail;
  }
#line 1206
  return (q);
  fail: 
#line 1209
  if (q) {
    {
#line 1210
    asyncns_cancel(asyncns, q);
    }
  }
#line 1212
  return ((asyncns_query_t *)((void *)0));
}
}
#line 1215 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_getaddrinfo_done(asyncns_t *asyncns , asyncns_query_t *q , struct addrinfo **ret_res ) 
{ 
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1217
  if (! asyncns) {
    {
#line 1217
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1217U, "asyncns_getaddrinfo_done");
    }
  }
#line 1218
  if (! q) {
    {
#line 1218
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1218U, "asyncns_getaddrinfo_done");
    }
  }
#line 1219
  if (! ((unsigned long )q->asyncns == (unsigned long )asyncns)) {
    {
#line 1219
    __assert_fail("q->asyncns == asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1219U, "asyncns_getaddrinfo_done");
    }
  }
#line 1220
  if (! ((unsigned int )q->type == 0U)) {
    {
#line 1220
    __assert_fail("q->type == REQUEST_ADDRINFO", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1220U, "asyncns_getaddrinfo_done");
    }
  }
#line 1222
  if (asyncns->dead) {
    {
#line 1223
    tmp = __errno_location();
#line 1223
    *tmp = 10;
    }
#line 1224
    return (-11);
  }
#line 1227
  if (! q->done) {
#line 1228
    return (-3);
  }
#line 1230
  *ret_res = q->addrinfo;
#line 1231
  q->addrinfo = (struct addrinfo *)((void *)0);
#line 1233
  ret = q->ret;
#line 1235
  if (ret == -11) {
    {
#line 1236
    tmp___0 = __errno_location();
#line 1236
    *tmp___0 = q->_errno;
    }
  }
#line 1238
  if (ret != 0) {
    {
#line 1239
    tmp___1 = __h_errno_location();
#line 1239
    *tmp___1 = q->_h_errno;
    }
  }
  {
#line 1241
  asyncns_cancel(asyncns, q);
  }
#line 1243
  return (ret);
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_query_t *asyncns_getnameinfo(asyncns_t *asyncns , struct sockaddr  const  *sa ,
                                     socklen_t salen , int flags , int gethost , int getserv ) 
{ 
  nameinfo_request_t data[10240UL / sizeof(nameinfo_request_t ) + 1UL] ;
  nameinfo_request_t *req ;
  asyncns_query_t *q ;
  int *tmp ;
  query_type_t tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1248
  req = data;
#line 1251
  if (! asyncns) {
    {
#line 1251
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1251U, "asyncns_getnameinfo");
    }
  }
#line 1252
  if (! sa) {
    {
#line 1252
    __assert_fail("sa", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1252U, "asyncns_getnameinfo");
    }
  }
#line 1253
  if (! (salen > 0U)) {
    {
#line 1253
    __assert_fail("salen > 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1253U, "asyncns_getnameinfo");
    }
  }
#line 1255
  if (asyncns->dead) {
    {
#line 1256
    tmp = __errno_location();
#line 1256
    *tmp = 10;
    }
#line 1257
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1260
  q = alloc_query(asyncns);
  }
#line 1260
  if (! q) {
#line 1261
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1263
  memset((void *)req, 0, sizeof(nameinfo_request_t ));
#line 1265
  req->header.id = q->id;
#line 1266
  tmp___0 = (query_type_t )2;
#line 1266
  q->type = tmp___0;
#line 1266
  req->header.type = tmp___0;
#line 1267
  req->header.length = sizeof(nameinfo_request_t ) + (unsigned long )salen;
  }
#line 1269
  if (req->header.length > 10240UL) {
    {
#line 1270
    tmp___1 = __errno_location();
#line 1270
    *tmp___1 = 12;
    }
#line 1271
    goto fail;
  }
  {
#line 1274
  req->flags = flags;
#line 1275
  req->sockaddr_len = salen;
#line 1276
  req->gethost = gethost;
#line 1277
  req->getserv = getserv;
#line 1279
  memcpy((void */* __restrict  */)((uint8_t *)req + sizeof(nameinfo_request_t )),
         (void const   */* __restrict  */)sa, (size_t )salen);
#line 1281
  tmp___2 = send(asyncns->fds[1], (void const   *)req, req->header.length, 16384);
  }
#line 1281
  if (tmp___2 < 0L) {
#line 1282
    goto fail;
  }
#line 1284
  return (q);
  fail: 
#line 1287
  if (q) {
    {
#line 1288
    asyncns_cancel(asyncns, q);
    }
  }
#line 1290
  return ((asyncns_query_t *)((void *)0));
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_getnameinfo_done(asyncns_t *asyncns , asyncns_query_t *q , char *ret_host ,
                             size_t hostlen , char *ret_serv , size_t servlen ) 
{ 
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1295
  if (! asyncns) {
    {
#line 1295
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1295U, "asyncns_getnameinfo_done");
    }
  }
#line 1296
  if (! q) {
    {
#line 1296
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1296U, "asyncns_getnameinfo_done");
    }
  }
#line 1297
  if (! ((unsigned long )q->asyncns == (unsigned long )asyncns)) {
    {
#line 1297
    __assert_fail("q->asyncns == asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1297U, "asyncns_getnameinfo_done");
    }
  }
#line 1298
  if (! ((unsigned int )q->type == 2U)) {
    {
#line 1298
    __assert_fail("q->type == REQUEST_NAMEINFO", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1298U, "asyncns_getnameinfo_done");
    }
  }
#line 1299
  if (! (! ret_host)) {
#line 1299
    if (! hostlen) {
      {
#line 1299
      __assert_fail("!ret_host || hostlen", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                    1299U, "asyncns_getnameinfo_done");
      }
    }
  }
#line 1300
  if (! (! ret_serv)) {
#line 1300
    if (! servlen) {
      {
#line 1300
      __assert_fail("!ret_serv || servlen", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                    1300U, "asyncns_getnameinfo_done");
      }
    }
  }
#line 1302
  if (asyncns->dead) {
    {
#line 1303
    tmp = __errno_location();
#line 1303
    *tmp = 10;
    }
#line 1304
    return (-11);
  }
#line 1307
  if (! q->done) {
#line 1308
    return (-3);
  }
#line 1310
  if (ret_host) {
#line 1310
    if (q->host) {
      {
#line 1311
      strncpy((char */* __restrict  */)ret_host, (char const   */* __restrict  */)q->host,
              hostlen);
#line 1312
      *(ret_host + (hostlen - 1UL)) = (char)0;
      }
    }
  }
#line 1315
  if (ret_serv) {
#line 1315
    if (q->serv) {
      {
#line 1316
      strncpy((char */* __restrict  */)ret_serv, (char const   */* __restrict  */)q->serv,
              servlen);
#line 1317
      *(ret_serv + (servlen - 1UL)) = (char)0;
      }
    }
  }
#line 1320
  ret = q->ret;
#line 1322
  if (ret == -11) {
    {
#line 1323
    tmp___0 = __errno_location();
#line 1323
    *tmp___0 = q->_errno;
    }
  }
#line 1325
  if (ret != 0) {
    {
#line 1326
    tmp___1 = __h_errno_location();
#line 1326
    *tmp___1 = q->_h_errno;
    }
  }
  {
#line 1328
  asyncns_cancel(asyncns, q);
  }
#line 1330
  return (ret);
}
}
#line 1333 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
static asyncns_query_t *asyncns_res(asyncns_t *asyncns , query_type_t qtype , char const   *dname ,
                                    int class , int type ) 
{ 
  res_request_t data[10240UL / sizeof(res_request_t ) + 1UL] ;
  res_request_t *req ;
  asyncns_query_t *q ;
  int *tmp ;
  size_t tmp___0 ;
  query_type_t tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 1335
  req = data;
#line 1338
  if (! asyncns) {
    {
#line 1338
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1338U, "asyncns_res");
    }
  }
#line 1339
  if (! dname) {
    {
#line 1339
    __assert_fail("dname", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1339U, "asyncns_res");
    }
  }
#line 1341
  if (asyncns->dead) {
    {
#line 1342
    tmp = __errno_location();
#line 1342
    *tmp = 10;
    }
#line 1343
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1346
  q = alloc_query(asyncns);
  }
#line 1346
  if (! q) {
#line 1347
    return ((asyncns_query_t *)((void *)0));
  }
  {
#line 1349
  memset((void *)req, 0, sizeof(res_request_t ));
#line 1351
  tmp___0 = strlen(dname);
#line 1351
  req->dname_len = tmp___0 + 1UL;
#line 1353
  req->header.id = q->id;
#line 1354
  tmp___1 = qtype;
#line 1354
  q->type = tmp___1;
#line 1354
  req->header.type = tmp___1;
#line 1355
  req->header.length = sizeof(res_request_t ) + req->dname_len;
  }
#line 1357
  if (req->header.length > 10240UL) {
    {
#line 1358
    tmp___2 = __errno_location();
#line 1358
    *tmp___2 = 12;
    }
#line 1359
    goto fail;
  }
  {
#line 1362
  req->class = class;
#line 1363
  req->type = type;
#line 1365
  strcpy((char */* __restrict  */)((char *)req + sizeof(res_request_t )), (char const   */* __restrict  */)dname);
#line 1367
  tmp___3 = send(asyncns->fds[1], (void const   *)req, req->header.length, 16384);
  }
#line 1367
  if (tmp___3 < 0L) {
#line 1368
    goto fail;
  }
#line 1370
  return (q);
  fail: 
#line 1373
  if (q) {
    {
#line 1374
    asyncns_cancel(asyncns, q);
    }
  }
#line 1376
  return ((asyncns_query_t *)((void *)0));
}
}
#line 1379 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_query_t *asyncns_res_query(asyncns_t *asyncns , char const   *dname , int class ,
                                   int type ) 
{ 
  asyncns_query_t *tmp ;

  {
  {
#line 1380
  tmp = asyncns_res(asyncns, (query_type_t )4, dname, class, type);
  }
#line 1380
  return (tmp);
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_query_t *asyncns_res_search(asyncns_t *asyncns , char const   *dname , int class ,
                                    int type ) 
{ 
  asyncns_query_t *tmp ;

  {
  {
#line 1384
  tmp = asyncns_res(asyncns, (query_type_t )5, dname, class, type);
  }
#line 1384
  return (tmp);
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_res_done(asyncns_t *asyncns , asyncns_query_t *q , unsigned char **answer ) 
{ 
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1389
  if (! asyncns) {
    {
#line 1389
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1389U, "asyncns_res_done");
    }
  }
#line 1390
  if (! q) {
    {
#line 1390
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1390U, "asyncns_res_done");
    }
  }
#line 1391
  if (! ((unsigned long )q->asyncns == (unsigned long )asyncns)) {
    {
#line 1391
    __assert_fail("q->asyncns == asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1391U, "asyncns_res_done");
    }
  }
#line 1392
  if (! ((unsigned int )q->type == 4U)) {
#line 1392
    if (! ((unsigned int )q->type == 5U)) {
      {
#line 1392
      __assert_fail("q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH",
                    "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                    1392U, "asyncns_res_done");
      }
    }
  }
#line 1393
  if (! answer) {
    {
#line 1393
    __assert_fail("answer", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1393U, "asyncns_res_done");
    }
  }
#line 1395
  if (asyncns->dead) {
    {
#line 1396
    tmp = __errno_location();
#line 1396
    *tmp = 10;
    }
#line 1397
    return (-10);
  }
#line 1400
  if (! q->done) {
    {
#line 1401
    tmp___0 = __errno_location();
#line 1401
    *tmp___0 = 11;
    }
#line 1402
    return (-11);
  }
#line 1405
  *answer = (unsigned char *)q->serv;
#line 1406
  q->serv = (char *)((void *)0);
#line 1408
  ret = q->ret;
#line 1410
  if (ret < 0) {
    {
#line 1411
    tmp___1 = __errno_location();
#line 1411
    *tmp___1 = q->_errno;
#line 1412
    tmp___2 = __h_errno_location();
#line 1412
    *tmp___2 = q->_h_errno;
    }
  }
  {
#line 1415
  asyncns_cancel(asyncns, q);
  }
#line 1417
  if (ret < 0) {
    {
#line 1417
    tmp___3 = __errno_location();
#line 1417
    tmp___4 = - *tmp___3;
    }
  } else {
#line 1417
    tmp___4 = ret;
  }
#line 1417
  return (tmp___4);
}
}
#line 1420 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
asyncns_query_t *asyncns_getnext(asyncns_t *asyncns ) 
{ 


  {
#line 1421
  if (! asyncns) {
    {
#line 1421
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1421U, "asyncns_getnext");
    }
  }
#line 1422
  return (asyncns->done_head);
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_getnqueries(asyncns_t *asyncns ) 
{ 


  {
#line 1426
  if (! asyncns) {
    {
#line 1426
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1426U, "asyncns_getnqueries");
    }
  }
#line 1427
  return (asyncns->n_queries);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void asyncns_cancel(asyncns_t *asyncns , asyncns_query_t *q ) 
{ 
  int i ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 1432
  tmp = __errno_location();
#line 1432
  saved_errno = *tmp;
  }
#line 1434
  if (! asyncns) {
    {
#line 1434
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1434U, "asyncns_cancel");
    }
  }
#line 1435
  if (! q) {
    {
#line 1435
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1435U, "asyncns_cancel");
    }
  }
#line 1436
  if (! ((unsigned long )q->asyncns == (unsigned long )asyncns)) {
    {
#line 1436
    __assert_fail("q->asyncns == asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1436U, "asyncns_cancel");
    }
  }
#line 1437
  if (! (asyncns->n_queries > 0)) {
    {
#line 1437
    __assert_fail("asyncns->n_queries > 0", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1437U, "asyncns_cancel");
    }
  }
#line 1439
  if (q->done) {
#line 1441
    if (q->done_prev) {
#line 1442
      (q->done_prev)->done_next = q->done_next;
    } else {
#line 1444
      asyncns->done_head = q->done_next;
    }
#line 1446
    if (q->done_next) {
#line 1447
      (q->done_next)->done_prev = q->done_prev;
    } else {
#line 1449
      asyncns->done_tail = q->done_prev;
    }
  }
#line 1452
  i = (int )(q->id % 256U);
#line 1453
  if (! ((unsigned long )asyncns->queries[i] == (unsigned long )q)) {
    {
#line 1453
    __assert_fail("asyncns->queries[i] == q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1453U, "asyncns_cancel");
    }
  }
  {
#line 1454
  asyncns->queries[i] = (asyncns_query_t *)((void *)0);
#line 1456
  asyncns_freeaddrinfo(q->addrinfo);
#line 1457
  free((void *)q->host);
#line 1458
  free((void *)q->serv);
#line 1460
  (asyncns->n_queries) --;
#line 1461
  free((void *)q);
#line 1463
  tmp___0 = __errno_location();
#line 1463
  *tmp___0 = saved_errno;
  }
#line 1464
  return;
}
}
#line 1466 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void asyncns_freeaddrinfo(struct addrinfo *ai ) 
{ 
  int saved_errno ;
  int *tmp ;
  struct addrinfo *next ;
  int *tmp___0 ;

  {
  {
#line 1467
  tmp = __errno_location();
#line 1467
  saved_errno = *tmp;
  }
  {
#line 1469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1469
    if (! ai) {
#line 1469
      goto while_break;
    }
    {
#line 1470
    next = ai->ai_next;
#line 1472
    free((void *)ai->ai_addr);
#line 1473
    free((void *)ai->ai_canonname);
#line 1474
    free((void *)ai);
#line 1476
    ai = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1479
  tmp___0 = __errno_location();
#line 1479
  *tmp___0 = saved_errno;
  }
#line 1480
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void asyncns_freeanswer(unsigned char *answer ) 
{ 
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 1483
  tmp = __errno_location();
#line 1483
  saved_errno = *tmp;
  }
#line 1485
  if (! answer) {
#line 1486
    return;
  }
  {
#line 1493
  free((void *)answer);
#line 1495
  tmp___0 = __errno_location();
#line 1495
  *tmp___0 = saved_errno;
  }
#line 1496
  return;
}
}
#line 1498 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
int asyncns_isdone(asyncns_t *asyncns , asyncns_query_t *q ) 
{ 


  {
#line 1499
  if (! asyncns) {
    {
#line 1499
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1499U, "asyncns_isdone");
    }
  }
#line 1500
  if (! q) {
    {
#line 1500
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1500U, "asyncns_isdone");
    }
  }
#line 1501
  if (! ((unsigned long )q->asyncns == (unsigned long )asyncns)) {
    {
#line 1501
    __assert_fail("q->asyncns == asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1501U, "asyncns_isdone");
    }
  }
#line 1503
  return (q->done);
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void asyncns_setuserdata(asyncns_t *asyncns , asyncns_query_t *q , void *userdata ) 
{ 
  asyncns_t *tmp ;

  {
#line 1507
  if (! q) {
    {
#line 1507
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1507U, "asyncns_setuserdata");
    }
  }
#line 1508
  if (! asyncns) {
    {
#line 1508
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1508U, "asyncns_setuserdata");
    }
  }
#line 1509
  tmp = asyncns;
#line 1509
  q->asyncns = tmp;
#line 1509
  if (! tmp) {
    {
#line 1509
    __assert_fail("q->asyncns = asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1509U, "asyncns_setuserdata");
    }
  }
#line 1511
  q->userdata = userdata;
#line 1512
  return;
}
}
#line 1514 "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c"
void *asyncns_getuserdata(asyncns_t *asyncns , asyncns_query_t *q ) 
{ 
  asyncns_t *tmp ;

  {
#line 1515
  if (! q) {
    {
#line 1515
    __assert_fail("q", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1515U, "asyncns_getuserdata");
    }
  }
#line 1516
  if (! asyncns) {
    {
#line 1516
    __assert_fail("asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1516U, "asyncns_getuserdata");
    }
  }
#line 1517
  tmp = asyncns;
#line 1517
  q->asyncns = tmp;
#line 1517
  if (! tmp) {
    {
#line 1517
    __assert_fail("q->asyncns = asyncns", "/home/june/repo/benchmarks/collector/temp/libasyncns-0.8/libasyncns/asyncns.c",
                  1517U, "asyncns_getuserdata");
    }
  }
#line 1519
  return (q->userdata);
}
}
