/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 37 "/usr/include/stdint.h"
typedef short int16_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/types.h"
typedef unsigned int bool_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
enum __anonenum_mtype_t_25 {
    MTYPE_NFS = 1,
    MTYPE_BIND = 2,
    MTYPE_SSH = 3
} ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef enum __anonenum_mtype_t_25 mtype_t;
#line 26
struct mount_info_s;
#line 30 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_info_s {
   mtype_t type ;
   char *point ;
   char *device ;
   char *opts ;
   dev_t device_dev ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef struct mount_info_s mount_info_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
struct __anonstruct_uint16v_t_26 {
   uint32_t len ;
   uint16_t *vec ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
typedef struct __anonstruct_uint16v_t_26 uint16v_t;
#line 62
enum __anonenum_ptype_t_27 {
    PTYPE_VERSION = 11,
    PTYPE_MESSAGE = 16,
    PTYPE_ERROR = 17,
    PTYPE_USER = 34,
    PTYPE_AUTH = 35,
    PTYPE_RC = 36,
    PTYPE_COMMAND = 48,
    PTYPE_MOUNT = 49,
    PTYPE_UMOUNT = 50,
    PTYPE_TARGET = 65,
    PTYPE_MOUNTS = 66,
    PTYPE_ARGS = 80,
    PTYPE_CWD = 81,
    PTYPE_ENVIRON = 82,
    PTYPE_IDS = 83,
    PTYPE_UMASK = 84,
    PTYPE_WINSIZE = 85,
    PTYPE_IN_REQ = 96,
    PTYPE_IN_DATA = 97,
    PTYPE_OUT_REQ = 98,
    PTYPE_OUT_DATA = 99,
    PTYPE_ERR_REQ = 100,
    PTYPE_ERR_DATA = 101
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
typedef enum __anonenum_ptype_t_27 ptype_t;
#line 17 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
struct __anonstruct_buffer_t_28 {
   size_t start ;
   size_t end ;
   bool_t eof ;
   size_t mem_size ;
   uint8_t *mem ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
typedef struct __anonstruct_buffer_t_28 buffer_t;
#line 14 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
struct __anonstruct_config_t_29 {
   char *target ;
   char *host ;
   char *port ;
   char **opts ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
typedef struct __anonstruct_config_t_29 config_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_42 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_43 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_44 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_46 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_47 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_48 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_41 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_42 _kill ;
   struct __anonstruct__timer_43 _timer ;
   struct __anonstruct__rt_44 _rt ;
   struct __anonstruct__sigchld_45 _sigchld ;
   struct __anonstruct__sigfault_46 _sigfault ;
   struct __anonstruct__sigpoll_47 _sigpoll ;
   struct __anonstruct__sigsys_48 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_40 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_41 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_40 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_60 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_60 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
struct __anonstruct_sel_57 {
   char nfs_path[4096] ;
   char *path ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
typedef void free_func_t(void * );
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_s;
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_s {
   struct mount_s *prev ;
   struct mount_s *next ;
   unsigned int usage ;
   time_t expiration ;
   struct mount_info_s info ;
   dev_t point_dev ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef struct mount_s mount_t;
#line 71 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct pid_mounts_s;
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_input_desc_t_35 {
   int fd ;
   bool_t wait ;
   buffer_t *buf ;
   ptype_t req_type ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_input_desc_t_35 input_desc_t;
#line 89 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_output_desc_t_36 {
   int fd ;
   size_t req ;
   ptype_t data_type ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_output_desc_t_36 output_desc_t;
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_param_38 {
   char *target ;
   mount_info_t **mounts ;
   char **args ;
   char *cwd ;
   char **environ ;
   uint16v_t *ids ;
   uint16_t umask ;
   struct winsize *term ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_handler_t_37 {
   int sd ;
   int client_version ;
   char host[1025] ;
   char const   *user ;
   struct __anonstruct_param_38 param ;
   char *root ;
   mount_t **mounts ;
   input_desc_t in ;
   output_desc_t out ;
   output_desc_t err ;
   char tmp_buf[4096] ;
   char *fakerootkey ;
   bool_t error ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_handler_t_37 handler_t;
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct pid_mounts_s {
   struct pid_mounts_s *next ;
   pid_t pid ;
   mount_t **mounts ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct pid_mounts_s pid_mounts_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
struct __anonstruct_all_mounts_87 {
   mount_t *head ;
   mount_t *tail ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
struct __anonstruct_debug_info_88 {
   pid_t pid ;
   char const   *name ;
};
#line 402 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_89 {
   int __in ;
   int __i ;
};
#line 402 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_90 {
   int __in ;
   int __i ;
};
#line 1434 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_91 {
   int __in ;
   int __i ;
};
#line 1437 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_92 {
   int __in ;
   int __i ;
};
#line 1441 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_93 {
   int __in ;
   int __i ;
};
#line 1440 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_94 {
   int __in ;
   int __i ;
};
#line 1436 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_95 {
   int __in ;
   int __i ;
};
#line 1433 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_96 {
   int __in ;
   int __i ;
};
#line 1615 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_97 {
   int __in ;
   int __i ;
};
#line 1614 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
union __anonunion_98 {
   int __in ;
   int __i ;
};
#line 1758 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
struct __anonstruct_info_99 {
   char const   *key ;
   int resource ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 24 "./fakeroot/message.h"
typedef uint32_t func_id_t;
#line 26 "./fakeroot/message.h"
typedef uint64_t fake_ino_t;
#line 27 "./fakeroot/message.h"
typedef uint64_t fake_dev_t;
#line 28 "./fakeroot/message.h"
typedef uint32_t fake_uid_t;
#line 29 "./fakeroot/message.h"
typedef uint32_t fake_gid_t;
#line 30 "./fakeroot/message.h"
typedef uint32_t fake_mode_t;
#line 31 "./fakeroot/message.h"
typedef uint32_t fake_nlink_t;
#line 33 "./fakeroot/message.h"
struct fakestat {
   fake_uid_t uid ;
   fake_gid_t gid ;
   fake_ino_t ino ;
   fake_dev_t dev ;
   fake_dev_t rdev ;
   fake_mode_t mode ;
   fake_nlink_t nlink ;
} __attribute__((__packed__)) ;
#line 43 "./fakeroot/message.h"
struct fake_msg {
   func_id_t id ;
   struct fakestat st ;
   uint32_t remote ;
} __attribute__((__packed__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
enum __anonenum_direction_t_67 {
    DAEMON_TO_CLIENT = 0,
    CLIENT_TO_DAEMON = 1
} ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
typedef enum __anonenum_direction_t_67 direction_t;
#line 33
struct node_s;
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
struct node_s {
   struct node_s *next ;
   int client ;
   int daemon ;
   fake_dev_t stored_dev ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
typedef struct node_s node_t;
#line 180 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
struct __anonstruct_sel_57___0 {
   char nfs_path[4096] ;
   char *path ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.h"
void error(char const   *msg  , ...) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
int set_nonblocking(int fd , bool_t nonblock ) ;
#line 36
char *get_progname(char *name ) ;
#line 39
size_t calc_vec_len(void **vec ) ;
#line 54
void oom_error(void) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
mount_info_t *mntinfo_parse(char const   *input ) ;
#line 69
int mntinfo_stat_device(mount_info_t *mi ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
uint16v_t *uint16v_alloc(uint32_t len ) ;
#line 27
void uint16v_free(uint16v_t *ints ) ;
#line 33
int read_buf(int fd , void *buf , size_t len ) ;
#line 36
int read_uint16(int fd , uint16_t *iptr ) ;
#line 39
int read_uint32(int fd , uint32_t *iptr ) ;
#line 44
int write_uint16v(int fd , uint16v_t *ints ) ;
#line 50
int write_strv(int fd , char **strv ) ;
#line 56
int write_mountv(int fd , mount_info_t **mounts ) ;
#line 59
int write_winsize(int fd , struct winsize  const  *ws ) ;
#line 94
int write_enum(int fd , int type ) ;
#line 95
int read_enum(int fd ) ;
#line 97
int write_buf_packet(int fd , ptype_t type , size_t size , void *buf ) ;
#line 98
int write_str_packet(int fd , ptype_t type , char const   *str ) ;
#line 99
int write_uint16_packet(int fd , ptype_t type , uint16_t val ) ;
#line 101
int send_version(int fd ) ;
#line 102
int get_version(int fd ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
buffer_t *buf_alloc(void) ;
#line 29
bool_t buf_is_empty(buffer_t *buf ) ;
#line 30
ssize_t buf_read_in(buffer_t *buf , int fd , size_t len ) ;
#line 31
ssize_t buf_write_out(buffer_t *buf , int *fd ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
config_t *config_alloc(void) ;
#line 22
void config_free(config_t *cfg ) ;
#line 23
bool_t config_read(config_t *cfg , char const   *filename , char const   *target___0 ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
extern char **environ ;
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *progname  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *configpath  =    (char *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *target  =    (char *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *remote_user  =    (char *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *cwd  =    (char *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char **args  =    (char **)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int action  =    48;
#line 55 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int sd  =    -1;
#line 58 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static buffer_t *buf_out  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static buffer_t *buf_err  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *tmp_buf  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t rawmode  =    (bool_t )0;
#line 66 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static struct termios oldtio  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static size_t inreq  =    (size_t )0;
#line 72 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t outwait  =    (bool_t )0;
#line 73 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t errwait  =    (bool_t )0;
#line 76 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int daemon_version  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
void error(char const   *msg  , ...) 
{ 
  char *desc ;
  va_list arg ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 101
  desc = (char *)((void *)0);
#line 104
  tmp___0 = __errno_location();
  }
#line 104
  if (*tmp___0 > 0) {
    {
#line 105
    tmp = __errno_location();
#line 105
    desc = strerror(*tmp);
    }
  }
  {
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 113
  __builtin_va_start(arg, msg);
#line 114
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           arg);
#line 115
  __builtin_va_end(arg);
  }
#line 117
  if (desc) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
            desc);
    }
  }
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 121
  fflush(stderr);
  }
#line 122
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int write_buffer(buffer_t *buf , int fd , bool_t *wait ) 
{ 
  char const   *tmp ;
  ssize_t tmp___0 ;
  bool_t tmp___1 ;

  {
  {
#line 134
  tmp___0 = buf_write_out(buf, & fd);
  }
#line 134
  if (tmp___0 < 0L) {
#line 135
    if (fd == 1) {
#line 135
      tmp = "Can\'t write buffer to stdout";
    } else {
#line 135
      tmp = "Can\'t write buffer to stderr";
    }
    {
#line 135
    error(tmp);
    }
#line 138
    return (-1);
  }
  {
#line 141
  tmp___1 = buf_is_empty(buf);
  }
#line 141
  if (tmp___1) {
#line 142
    *wait = (bool_t )0;
  }
#line 144
  return (0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int send_data(void) 
{ 
  bool_t ok ;
  ssize_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 153
  ok = (bool_t )0;
#line 154
  len = (ssize_t )4096;
#line 159
  tmp___0 = isatty(0);
  }
#line 159
  if (tmp___0) {
    {
#line 160
    tmp = ioctl(0, 21531UL, & len);
    }
#line 160
    if (tmp < 0) {
      {
#line 161
      error("Can\'t check tty for available data");
      }
#line 162
      return (-1);
    }
#line 165
    if (len < 0L) {
      {
#line 166
      error("ioctl(tty) gave invalid read length");
      }
#line 167
      return (-1);
    }
#line 170
    if (len == 0L) {
#line 171
      return (0);
    }
#line 173
    if (len > 4096L) {
#line 174
      len = (ssize_t )4096;
    }
  }
  {
#line 177
  len = read(0, (void *)tmp_buf, (size_t )len);
  }
#line 178
  if (len < 0L) {
    {
#line 179
    error("Can\'t read from stdin");
    }
#line 180
    return (-1);
  }
#line 183
  if (len == 0L) {
#line 185
    ok = (bool_t )1;
#line 186
    inreq = (size_t )0;
  }
  {
#line 189
  tmp___1 = write_buf_packet(sd, (ptype_t )97, (size_t )len, (void *)tmp_buf);
  }
#line 189
  if (tmp___1 < 0) {
    {
#line 190
    error("Can\'t write IN DATA packet to socket");
    }
#line 191
    return (-1);
  }
#line 195
  inreq -= (size_t )len;
#line 197
  return ((int )ok);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_stream(buffer_t *buf ) 
{ 
  uint32_t len ;
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 208
  tmp = read_uint32(sd, & len);
  }
#line 208
  if (tmp < 0) {
    {
#line 209
    error("Unable to read data packet length");
    }
#line 210
    return (-1);
  }
#line 213
  if (len == 0U) {
    {
#line 214
    tmp___0 = __errno_location();
#line 214
    *tmp___0 = 0;
#line 215
    error("Received empty data packet (EOF)");
    }
#line 216
    return (-1);
  }
  {
#line 219
  tmp___1 = buf_read_in(buf, sd, (size_t )len);
  }
#line 219
  if (tmp___1 < 0L) {
    {
#line 220
    error("Can\'t append data packet to buffer");
    }
#line 221
    return (-1);
  }
#line 224
  return (0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_message(ptype_t type ) 
{ 
  uint32_t len ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 235
  tmp = read_uint32(sd, & len);
  }
#line 235
  if (tmp < 0) {
    {
#line 236
    error("Unable to read message packet length");
    }
#line 237
    return (-1);
  }
  {
#line 240
  tmp___0 = read_buf(sd, (void *)tmp_buf, (size_t )len);
  }
#line 240
  if (tmp___0 < 0) {
    {
#line 241
    error("Can\'t read message packet");
    }
#line 242
    return (-1);
  }
#line 245
  if (len == 4096U) {
#line 246
    len = (uint32_t )4095;
  }
#line 248
  *(tmp_buf + len) = (char )'\000';
#line 256
  if ((unsigned int )type == 17U) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s server: %s\n",
            progname, tmp_buf);
    }
  } else {
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            progname, tmp_buf);
    }
  }
#line 262
  return (0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_packet(uint16_t *rc ) 
{ 
  ptype_t type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 272
  tmp = read_enum(sd);
#line 272
  type = (ptype_t )tmp;
  }
  {
#line 274
  if ((unsigned int )type == 4294967295U) {
#line 274
    goto case_4294967295;
  }
#line 278
  if ((unsigned int )type == 96U) {
#line 278
    goto case_96;
  }
#line 282
  if ((unsigned int )type == 99U) {
#line 282
    goto case_99;
  }
#line 285
  if ((unsigned int )type == 101U) {
#line 285
    goto case_101;
  }
#line 288
  if ((unsigned int )type == 36U) {
#line 288
    goto case_36;
  }
#line 296
  if ((unsigned int )type == 16U) {
#line 296
    goto case_16;
  }
#line 299
  if ((unsigned int )type == 17U) {
#line 299
    goto case_17;
  }
#line 302
  goto switch_default;
  case_4294967295: /* CIL Label */ 
  {
#line 275
  error("Can\'t read packet type from socket");
  }
#line 276
  return (-1);
  case_96: /* CIL Label */ 
#line 279
  inreq = (size_t )4096;
#line 280
  return (0);
  case_99: /* CIL Label */ 
  {
#line 283
  tmp___0 = receive_stream(buf_out);
  }
#line 283
  return (tmp___0);
  case_101: /* CIL Label */ 
  {
#line 286
  tmp___1 = receive_stream(buf_err);
  }
#line 286
  return (tmp___1);
  case_36: /* CIL Label */ 
  {
#line 290
  tmp___2 = read_uint16(sd, rc);
  }
#line 290
  if (tmp___2 < 0) {
    {
#line 291
    error("Can\'t read RC packet from socket");
    }
#line 292
    return (-1);
  }
#line 294
  return (1);
  case_16: /* CIL Label */ 
  {
#line 297
  tmp___3 = receive_message((ptype_t )16);
  }
#line 297
  return (tmp___3);
  case_17: /* CIL Label */ 
  {
#line 300
  tmp___4 = receive_message((ptype_t )17);
  }
#line 300
  return (tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 303
  tmp___5 = __errno_location();
#line 303
  *tmp___5 = 0;
#line 304
  error("Received packet has unexpected type (0x%02x)", (unsigned int )type);
  }
#line 305
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int send_request(ptype_t ptype , bool_t *wait ) 
{ 
  int tmp ;

  {
  {
#line 317
  tmp = write_enum(sd, (int )ptype);
  }
#line 317
  if (tmp < 0) {
    {
#line 318
    error("Can\'t write packet to socket");
    }
#line 319
    return (-1);
  }
#line 322
  *wait = (bool_t )1;
#line 324
  return (0);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int manage(bool_t is_tty ) 
{ 
  fd_set readfds ;
  fd_set writefds ;
  bool_t inopen ;
  int ok ;
  ssize_t tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  int tmp___2 ;
  uint16_t rc ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool_t tmp___10 ;

  {
#line 338
  if (is_tty) {
#line 339
    inopen = (bool_t )1;
  } else {
    {
#line 338
    tmp = read(0, (void *)0, (size_t )0);
    }
#line 338
    if (tmp != -1L) {
#line 339
      inopen = (bool_t )1;
    } else {
#line 341
      inopen = (bool_t )0;
    }
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 345
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 345
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 346
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefds.__fds_bits[0]): "memory");
#line 346
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 348
    readfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 350
    if (inopen) {
#line 350
      if (inreq) {
#line 351
        readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
      }
    }
    {
#line 353
    tmp___0 = buf_is_empty(buf_out);
    }
#line 353
    if (tmp___0) {
#line 353
      if (! outwait) {
#line 354
        writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 1 % (8 * (int )sizeof(__fd_mask ));
      }
    } else {
#line 354
      writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 1 % (8 * (int )sizeof(__fd_mask ));
    }
#line 356
    if (! is_tty) {
      {
#line 356
      tmp___1 = buf_is_empty(buf_err);
      }
#line 356
      if (tmp___1) {
#line 356
        if (! errwait) {
#line 357
          writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 2 % (8 * (int )sizeof(__fd_mask ));
        }
      } else {
#line 357
        writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 2 % (8 * (int )sizeof(__fd_mask ));
      }
    }
    {
#line 359
    tmp___2 = select(sd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 359
    if (tmp___2 <= 0) {
      {
#line 360
      error("Can\'t select");
      }
#line 361
      return (-1);
    }
#line 365
    if ((readfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 368
      ok = receive_packet(& rc);
      }
#line 369
      if (ok < 0) {
#line 370
        return (-1);
      }
#line 372
      if (ok > 0) {
#line 373
        return ((int )rc);
      }
    }
#line 377
    if (inopen) {
#line 377
      if (inreq) {
#line 377
        if ((readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 378
          ok = send_data();
          }
#line 379
          if (ok < 0) {
#line 380
            return (-1);
          }
#line 381
          if (ok > 0) {
#line 382
            inopen = (bool_t )0;
          }
        }
      }
    }
#line 386
    if ((writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] & (1L << 1 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 387
      tmp___6 = buf_is_empty(buf_out);
      }
#line 387
      if (tmp___6) {
#line 388
        if (outwait) {
#line 388
          tmp___4 = 1;
        } else {
          {
#line 388
          tmp___3 = send_request((ptype_t )98, & outwait);
          }
#line 388
          if (tmp___3 >= 0) {
#line 388
            tmp___4 = 1;
          } else {
#line 388
            tmp___4 = 0;
          }
        }
#line 388
        ok = tmp___4;
      } else {
        {
#line 390
        tmp___5 = write_buffer(buf_out, 1, & outwait);
#line 390
        ok = tmp___5 >= 0;
        }
      }
#line 392
      if (! ok) {
#line 393
        return (-1);
      }
    }
#line 397
    if ((writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] & (1L << 2 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 398
      tmp___10 = buf_is_empty(buf_err);
      }
#line 398
      if (tmp___10) {
#line 399
        if (errwait) {
#line 399
          tmp___8 = 1;
        } else {
          {
#line 399
          tmp___7 = send_request((ptype_t )100, & errwait);
          }
#line 399
          if (tmp___7 >= 0) {
#line 399
            tmp___8 = 1;
          } else {
#line 399
            tmp___8 = 0;
          }
        }
#line 399
        ok = tmp___8;
      } else {
        {
#line 401
        tmp___9 = write_buffer(buf_err, 2, & errwait);
#line 401
        ok = tmp___9 >= 0;
        }
      }
#line 403
      if (! ok) {
#line 404
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return (-1);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int set_raw_mode(void) 
{ 
  struct termios tio ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 419
  tmp = tcgetattr(0, & tio);
  }
#line 419
  if (tmp < 0) {
    {
#line 420
    error("Can\'t get termios");
    }
#line 421
    return (-1);
  }
  {
#line 424
  oldtio = tio;
#line 426
  tio.c_iflag |= 4U;
#line 427
  tio.c_iflag &= 4294963743U;
#line 428
  tio.c_lflag &= 4294963140U;
#line 429
  tio.c_lflag &= 4294934462U;
#line 430
  tio.c_cc[6] = (cc_t )1;
#line 431
  tio.c_cc[5] = (cc_t )0;
#line 435
  tmp___0 = tcsetattr(0, 1, (struct termios  const  *)(& tio));
  }
#line 435
  if (tmp___0 < 0) {
    {
#line 436
    error("Can\'t change termios");
    }
#line 437
    return (-1);
  }
#line 440
  rawmode = (bool_t )1;
#line 442
  return (0);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void set_old_mode(void) 
{ 
  int tmp ;

  {
#line 450
  if (! rawmode) {
#line 452
    return;
  }
  {
#line 457
  tmp = tcsetattr(0, 1, (struct termios  const  *)(& oldtio));
  }
#line 457
  if (tmp < 0) {
    {
#line 458
    error("Can\'t restore original termios");
    }
  }
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void usage(void) 
{ 


  {
  {
#line 463
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-t|--target <target>] [-c|--config <path>] [-d|--directory <dir>] [-r|--remote <uid>,<gid>,<username>] [<command>] [<args>]\n       %s [-t|--target <target>] [-c|--config <path>] --mount\n       %s [-t|--target <target>] [-c|--config <path>] --umount\n       %s -v|--version\n       %s -h|--help\n",
          progname, progname, progname, progname, progname);
  }
#line 478
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t should_skip_parameter(char *arg , struct option *longopts ) 
{ 
  bool_t is_long ;
  struct option *opt ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 485
  tmp = strlen((char const   *)arg);
#line 485
  is_long = (bool_t )(tmp > 2UL);
  }
#line 488
  if (is_long) {
    {
#line 488
    tmp___0 = strchr((char const   *)arg, '=');
    }
#line 488
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 489
      return ((bool_t )0);
    }
  }
#line 491
  opt = longopts;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! opt->name) {
#line 491
      goto while_break;
    }
#line 492
    if (is_long) {
      {
#line 493
      tmp___1 = strcmp((char const   *)(arg + 2), opt->name);
      }
#line 493
      if (tmp___1 != 0) {
#line 494
        goto __Cont;
      }
    } else
#line 496
    if ((int )*(arg + 1) != opt->val) {
#line 497
      goto __Cont;
    }
#line 500
    return ((bool_t )(opt->has_arg == 1));
    __Cont: /* CIL Label */ 
#line 491
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return ((bool_t )0);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char **modify_args(int old_argc , char **old_argv , int *new_argc , struct option *longopts ) 
{ 
  char **new_argv ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *arg ;
  char **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  bool_t tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;

  {
  {
#line 509
  i = 0;
#line 511
  tmp = calloc((size_t )(old_argc + 2), sizeof(char *));
#line 511
  new_argv = (char **)tmp;
  }
#line 512
  if (! new_argv) {
    {
#line 513
    oom_error();
#line 514
    exit(1);
    }
  }
#line 518
  tmp___0 = i;
#line 518
  i ++;
#line 518
  tmp___1 = old_argv;
#line 518
  old_argv ++;
#line 518
  *(new_argv + tmp___0) = *tmp___1;
#line 520
  if (old_argc > 1) {
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;
#line 522
      if (! (i < old_argc)) {
#line 522
        goto while_break;
      }
#line 523
      tmp___2 = old_argv;
#line 523
      old_argv ++;
#line 523
      arg = *tmp___2;
#line 525
      if ((int )*(arg + 0) != 45) {
#line 526
        tmp___3 = i;
#line 526
        i ++;
#line 526
        *(new_argv + tmp___3) = (char *)"--";
#line 527
        tmp___4 = i;
#line 527
        i ++;
#line 527
        *(new_argv + tmp___4) = arg;
#line 528
        goto while_break;
      }
      {
#line 531
      tmp___5 = i;
#line 531
      i ++;
#line 531
      *(new_argv + tmp___5) = arg;
#line 533
      tmp___8 = should_skip_parameter(arg, longopts);
      }
#line 533
      if (tmp___8) {
#line 533
        if (i < old_argc) {
#line 534
          tmp___6 = i;
#line 534
          i ++;
#line 534
          tmp___7 = old_argv;
#line 534
          old_argv ++;
#line 534
          *(new_argv + tmp___6) = *tmp___7;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 538
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 538
      if (! *old_argv) {
#line 538
        goto while_break___0;
      }
#line 539
      tmp___9 = i;
#line 539
      i ++;
#line 539
      tmp___10 = old_argv;
#line 539
      old_argv ++;
#line 539
      *(new_argv + tmp___9) = *tmp___10;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 542
  *new_argc = i;
#line 543
  return (new_argv);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void read_args(int orig_argc , char **orig_argv ) 
{ 
  char **argv ;
  int argc ;
  int skip_args ;
  struct option longopts[10] ;
  int c ;

  {
  {
#line 554
  skip_args = 0;
#line 556
  longopts[0].name = "help";
#line 556
  longopts[0].has_arg = 0;
#line 556
  longopts[0].flag = (int *)0;
#line 556
  longopts[0].val = 'h';
#line 556
  longopts[1].name = "version";
#line 556
  longopts[1].has_arg = 0;
#line 556
  longopts[1].flag = (int *)0;
#line 556
  longopts[1].val = 'v';
#line 556
  longopts[2].name = "sbox-call";
#line 556
  longopts[2].has_arg = 0;
#line 556
  longopts[2].flag = & skip_args;
#line 556
  longopts[2].val = 1;
#line 556
  longopts[3].name = "target";
#line 556
  longopts[3].has_arg = 1;
#line 556
  longopts[3].flag = (int *)0;
#line 556
  longopts[3].val = 't';
#line 556
  longopts[4].name = "config";
#line 556
  longopts[4].has_arg = 1;
#line 556
  longopts[4].flag = (int *)0;
#line 556
  longopts[4].val = 'c';
#line 556
  longopts[5].name = "directory";
#line 556
  longopts[5].has_arg = 1;
#line 556
  longopts[5].flag = (int *)0;
#line 556
  longopts[5].val = 'd';
#line 556
  longopts[6].name = "remote";
#line 556
  longopts[6].has_arg = 1;
#line 556
  longopts[6].flag = (int *)0;
#line 556
  longopts[6].val = 'r';
#line 556
  longopts[7].name = "mount";
#line 556
  longopts[7].has_arg = 0;
#line 556
  longopts[7].flag = & action;
#line 556
  longopts[7].val = 49;
#line 556
  longopts[8].name = "umount";
#line 556
  longopts[8].has_arg = 0;
#line 556
  longopts[8].flag = & action;
#line 556
  longopts[8].val = 50;
#line 556
  longopts[9].name = (char const   *)0;
#line 556
  longopts[9].has_arg = 0;
#line 556
  longopts[9].flag = (int *)0;
#line 556
  longopts[9].val = 0;
#line 569
  argv = modify_args(orig_argc, orig_argv, & argc, longopts);
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 574
    c = getopt_long(argc, (char * const  *)argv, "hvt:c:d:r:", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 575
    if (c < 0) {
#line 576
      goto while_break;
    }
    {
#line 580
    if (c == 116) {
#line 580
      goto case_116;
    }
#line 584
    if (c == 99) {
#line 584
      goto case_99;
    }
#line 588
    if (c == 100) {
#line 588
      goto case_100;
    }
#line 592
    if (c == 114) {
#line 592
      goto case_114;
    }
#line 596
    if (c == 0) {
#line 596
      goto case_0;
    }
#line 600
    if (c == 118) {
#line 600
      goto case_118;
    }
#line 605
    if (c == 104) {
#line 605
      goto case_104;
    }
#line 609
    goto switch_default;
    case_116: /* CIL Label */ 
#line 581
    target = optarg;
#line 582
    goto switch_break;
    case_99: /* CIL Label */ 
#line 585
    configpath = optarg;
#line 586
    goto switch_break;
    case_100: /* CIL Label */ 
#line 589
    cwd = optarg;
#line 590
    goto switch_break;
    case_114: /* CIL Label */ 
#line 593
    remote_user = optarg;
#line 594
    goto switch_break;
    case_0: /* CIL Label */ 
#line 598
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scratchbox Remote Shell client %d%s\n",
            7, ".6");
#line 603
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 606
    usage();
#line 607
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 610
    usage();
#line 611
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  if (*(argv + optind)) {
#line 615
    if (*(argv + (optind + skip_args))) {
#line 616
      args = argv + (optind + skip_args);
    }
  }
#line 617
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void cleanup(void) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 626
  tmp = buf_is_empty(buf_out);
  }
#line 626
  if (! tmp) {
    {
#line 627
    set_nonblocking(1, (bool_t )0);
#line 628
    write_buffer(buf_out, 1, & outwait);
    }
  }
  {
#line 631
  tmp___0 = buf_is_empty(buf_err);
  }
#line 631
  if (! tmp___0) {
    {
#line 632
    set_nonblocking(2, (bool_t )0);
#line 633
    write_buffer(buf_err, 2, & errwait);
    }
  }
  {
#line 636
  set_old_mode();
  }
#line 639
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int determine_user_info(uid_t *uidp , gid_t *gidp , char *username ) 
{ 
  uid_t uid ;
  gid_t gid ;
  int tmp ;
  char *str ;
  struct passwd *userstruct ;
  struct passwd *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 646
  if ((unsigned long )remote_user != (unsigned long )((void *)0)) {
    {
#line 651
    tmp = sscanf((char const   */* __restrict  */)remote_user, (char const   */* __restrict  */)"%d,%d,%s",
                 & uid, & gid, username);
    }
#line 651
    if (tmp != 3) {
      {
#line 652
      error("Invalid format for -r argument: %s", remote_user);
      }
#line 653
      return (1);
    }
  } else {
    {
#line 659
    uid = geteuid();
#line 660
    gid = getegid();
#line 662
    tmp___0 = getpwuid(uid);
#line 662
    userstruct = tmp___0;
    }
#line 663
    if (! userstruct) {
      {
#line 664
      error("Can\'t get user information about uid %d", uid);
      }
#line 665
      return (1);
    }
    {
#line 668
    strcpy((char */* __restrict  */)username, (char const   */* __restrict  */)userstruct->pw_name);
#line 673
    str = getenv("_SBOX_NONFAKE_USER");
    }
#line 674
    if (str) {
      {
#line 675
      strcpy((char */* __restrict  */)username, (char const   */* __restrict  */)str);
      }
    }
    {
#line 678
    str = getenv("_SBOX_NONFAKE_UID");
    }
#line 679
    if (str) {
      {
#line 679
      tmp___1 = atoi((char const   *)str);
#line 679
      uid = (uid_t )tmp___1;
      }
#line 679
      if (uid <= 0U) {
        {
#line 680
        error("Invalid _SBOX_NONFAKE_UID: %d", uid);
        }
#line 681
        return (1);
      }
    }
    {
#line 684
    str = getenv("_SBOX_NONFAKE_GID");
    }
#line 685
    if (str) {
      {
#line 685
      tmp___2 = atoi((char const   *)str);
#line 685
      gid = (gid_t )tmp___2;
      }
#line 685
      if (gid <= 0U) {
        {
#line 686
        error("Invalid _SBOX_NONFAKE_GID: %d", gid);
        }
#line 687
        return (1);
      }
    }
  }
#line 691
  *uidp = uid;
#line 692
  *gidp = gid;
#line 694
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
int main(int argc , char **argv ) 
{ 
  config_t *cfg ;
  mount_info_t **mounts ;
  int16_t rc ;
  uid_t uid ;
  gid_t gid ;
  char user[255] ;
  void *tmp ;
  struct sigaction act ;
  char *home ;
  char *path ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  bool_t tmp___3 ;
  size_t len ;
  size_t i ;
  void *tmp___4 ;
  mount_info_t *mi ;
  mount_info_t *tmp___5 ;
  int tmp___6 ;
  struct addrinfo *ai ;
  struct addrinfo *i___0 ;
  struct addrinfo hints ;
  char *port___0 ;
  int ret ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint16_t val ;
  ptype_t type ;
  int tmp___13 ;
  uint16_t auth ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  bool_t is_tty ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  gid_t gids[65536] ;
  int num ;
  int i___1 ;
  uint16v_t *ids ;
  int tmp___26 ;
  int tmp___27 ;
  uint16_t mask ;
  __mode_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct winsize ws ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  uint16_t val___0 ;
  ptype_t type___0 ;
  int tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;

  {
  {
#line 705
  uid = (uid_t )0;
#line 706
  gid = (gid_t )0;
#line 709
  progname = get_progname(*(argv + 0));
#line 717
  cfg = config_alloc();
  }
#line 717
  if (cfg) {
    {
#line 717
    buf_out = buf_alloc();
    }
#line 717
    if (buf_out) {
      {
#line 717
      buf_err = buf_alloc();
      }
#line 717
      if (buf_err) {
        {
#line 717
        tmp = malloc((size_t )4096);
#line 717
        tmp_buf = (char *)tmp;
        }
#line 717
        if (! tmp_buf) {
          {
#line 721
          oom_error();
          }
#line 722
          return (1);
        }
      } else {
        {
#line 721
        oom_error();
        }
#line 722
        return (1);
      }
    } else {
      {
#line 721
      oom_error();
      }
#line 722
      return (1);
    }
  } else {
    {
#line 721
    oom_error();
    }
#line 722
    return (1);
  }
  {
#line 731
  act.__sigaction_handler.sa_handler = (void (*)(int  ))(& exit);
#line 732
  sigemptyset(& act.sa_mask);
#line 733
  act.sa_flags = (-0x7FFFFFFF-1);
#line 735
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 736
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 737
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 739
  atexit(& cleanup);
#line 746
  read_args(argc, argv);
#line 752
  path = (char *)((void *)0);
  }
#line 754
  if (! configpath) {
    {
#line 755
    home = getenv("HOME");
#line 756
    tmp___0 = strlen((char const   *)home);
#line 756
    tmp___1 = strlen("/.sbrsh");
#line 756
    tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 756
    path = (char *)tmp___2;
    }
#line 757
    if (! path) {
      {
#line 758
      oom_error();
      }
#line 759
      return (1);
    }
    {
#line 761
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)home);
#line 762
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/.sbrsh");
#line 764
    configpath = path;
    }
  }
  {
#line 767
  tmp___3 = config_read(cfg, (char const   *)configpath, (char const   *)target);
  }
#line 767
  if (! tmp___3) {
#line 768
    if (target) {
      {
#line 769
      error("Target %s not found in %s", target, configpath);
      }
    } else {
      {
#line 771
      error("No targets found in %s", configpath);
      }
    }
#line 772
    return (1);
  }
#line 775
  if (path) {
    {
#line 776
    free((void *)path);
#line 777
    configpath = (char *)((void *)0);
    }
  }
  {
#line 787
  len = calc_vec_len((void **)cfg->opts);
#line 789
  tmp___4 = calloc(len + 1UL, sizeof(mount_info_t *));
#line 789
  mounts = (mount_info_t **)tmp___4;
  }
#line 790
  if (! mounts) {
    {
#line 791
    oom_error();
    }
#line 792
    return (1);
  }
#line 795
  i = (size_t )0;
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! (i < len)) {
#line 795
      goto while_break;
    }
    {
#line 796
    tmp___5 = mntinfo_parse((char const   *)*(cfg->opts + i));
#line 796
    mi = tmp___5;
    }
#line 797
    if (! mi) {
#line 798
      return (1);
    }
#line 803
    if (action == 48) {
#line 803
      if (1U == (unsigned int )mi->type) {
#line 803
        goto _L;
      } else
#line 803
      if (3U == (unsigned int )mi->type) {
        _L: /* CIL Label */ 
        {
#line 805
        tmp___6 = mntinfo_stat_device(mi);
        }
#line 805
        if (tmp___6 < 0) {
#line 806
          return (1);
        }
      }
    }
#line 811
    *(mounts + i) = mi;
#line 795
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  hints.ai_flags = 0;
#line 819
  hints.ai_family = 0;
#line 819
  hints.ai_socktype = 0;
#line 819
  hints.ai_protocol = 0;
#line 819
  hints.ai_addrlen = 0U;
#line 819
  hints.ai_addr = (struct sockaddr *)0;
#line 819
  hints.ai_canonname = (char *)0;
#line 819
  hints.ai_next = (struct addrinfo *)0;
#line 820
  port___0 = (char *)"1202";
#line 823
  hints.ai_flags = 32;
#line 824
  hints.ai_socktype = 1;
#line 826
  if (cfg->port) {
#line 827
    port___0 = cfg->port;
  }
  {
#line 829
  ret = getaddrinfo((char const   */* __restrict  */)cfg->host, (char const   */* __restrict  */)port___0,
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 830
  if (ret < 0) {
    {
#line 831
    tmp___7 = gai_strerror(ret);
#line 831
    error("Can\'t resolve host: %s", tmp___7);
    }
#line 832
    return (1);
  }
#line 835
  i___0 = ai;
  {
#line 835
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 835
    if (! i___0) {
#line 835
      goto while_break___0;
    }
    {
#line 836
    sd = socket(i___0->ai_family, i___0->ai_socktype, i___0->ai_protocol);
    }
#line 838
    if (sd < 0) {
#line 839
      goto __Cont;
    }
    {
#line 841
    tmp___8 = connect(sd, (struct sockaddr  const  *)i___0->ai_addr, i___0->ai_addrlen);
    }
#line 841
    if (tmp___8 == 0) {
#line 842
      goto while_break___0;
    }
    {
#line 844
    close(sd);
#line 845
    sd = -1;
    }
    __Cont: /* CIL Label */ 
#line 835
    i___0 = i___0->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 848
  if (sd < 0) {
    {
#line 849
    error("Can\'t connect");
    }
#line 850
    return (1);
  }
  {
#line 853
  freeaddrinfo(ai);
#line 860
  tmp___9 = send_version(sd);
  }
#line 860
  if (tmp___9 < 0) {
    {
#line 861
    error("Can\'t write protocol version packet to socket");
    }
#line 862
    return (1);
  }
  {
#line 865
  daemon_version = get_version(sd);
  }
#line 866
  if (daemon_version < 0) {
    {
#line 867
    error("Can\'t read protocol version packet from socket");
    }
#line 868
    return (1);
  }
#line 871
  if (daemon_version < 6) {
    {
#line 872
    tmp___10 = __errno_location();
#line 872
    *tmp___10 = 0;
#line 873
    error("Server version %d is too old (version %d required)", daemon_version, 6);
    }
#line 875
    return (1);
  }
  {
#line 881
  tmp___11 = determine_user_info(& uid, & gid, user);
  }
#line 881
  if (tmp___11) {
#line 882
    return (1);
  }
  {
#line 891
  tmp___12 = write_str_packet(sd, (ptype_t )34, (char const   *)(user));
  }
#line 891
  if (tmp___12 < 0) {
    {
#line 892
    error("Can\'t send USER packet");
    }
#line 893
    return (1);
  }
  {
#line 900
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 902
    tmp___13 = read_enum(sd);
#line 902
    type = (ptype_t )tmp___13;
    }
    {
#line 906
    if ((unsigned int )type == 4294967295U) {
#line 906
      goto case_4294967295;
    }
#line 910
    if ((unsigned int )type == 35U) {
#line 910
      goto case_35;
    }
#line 925
    if ((unsigned int )type == 36U) {
#line 925
      goto case_36;
    }
#line 934
    if ((unsigned int )type == 16U) {
#line 934
      goto case_16;
    }
#line 938
    if ((unsigned int )type == 17U) {
#line 938
      goto case_17;
    }
#line 942
    goto switch_default;
    case_4294967295: /* CIL Label */ 
    {
#line 907
    error("Can\'t read packet type from socket");
    }
#line 908
    return (1);
    case_35: /* CIL Label */ 
    {
#line 912
    tmp___14 = read_uint16(sd, & auth);
    }
#line 912
    if (tmp___14 < 0) {
      {
#line 913
      error("Can\'t read AUTH packet from socket");
      }
#line 914
      return (1);
    }
#line 916
    if (auth) {
#line 918
      goto switch_break;
    } else {
      {
#line 920
      tmp___15 = __errno_location();
#line 920
      *tmp___15 = 0;
#line 921
      error("Authentication failed");
      }
#line 922
      return (1);
    }
    case_36: /* CIL Label */ 
    {
#line 927
    tmp___16 = read_uint16(sd, & val);
    }
#line 927
    if (tmp___16 < 0) {
      {
#line 928
      error("Can\'t read RC packet from socket");
      }
#line 929
      return (1);
    }
#line 931
    rc = (int16_t )val;
#line 932
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 935
    receive_message((ptype_t )16);
    }
#line 936
    goto while_continue___1;
    case_17: /* CIL Label */ 
    {
#line 939
    receive_message((ptype_t )17);
    }
#line 940
    goto while_continue___1;
    switch_default: /* CIL Label */ 
    {
#line 943
    tmp___17 = __errno_location();
#line 943
    *tmp___17 = 0;
#line 944
    error("Received packet has unexpected type (0x%02x)", (unsigned int )type);
    }
#line 945
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 948
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 955
  tmp___18 = write_str_packet(sd, (ptype_t )65, (char const   *)cfg->target);
  }
#line 955
  if (tmp___18 < 0) {
    {
#line 956
    error("Can\'t send TARGET packet");
    }
#line 957
    return (1);
  }
  {
#line 960
  config_free(cfg);
#line 966
  tmp___19 = write_enum(sd, 66);
  }
#line 966
  if (tmp___19 < 0) {
    {
#line 967
    error("Can\'t send MOUNTS packet");
    }
#line 968
    return (1);
  } else {
    {
#line 966
    tmp___20 = write_mountv(sd, mounts);
    }
#line 966
    if (tmp___20 < 0) {
      {
#line 967
      error("Can\'t send MOUNTS packet");
      }
#line 968
      return (1);
    }
  }
#line 975
  if (action == 48) {
#line 981
    if (args) {
      {
#line 983
      tmp___21 = write_enum(sd, 80);
      }
#line 983
      if (tmp___21 < 0) {
        {
#line 984
        error("Can\'t send ARGS packet");
        }
#line 985
        return (1);
      } else {
        {
#line 983
        tmp___22 = write_strv(sd, args);
        }
#line 983
        if (tmp___22 < 0) {
          {
#line 984
          error("Can\'t send ARGS packet");
          }
#line 985
          return (1);
        }
      }
    }
#line 992
    if (cwd) {
      {
#line 994
      tmp___23 = write_str_packet(sd, (ptype_t )81, (char const   *)cwd);
      }
#line 994
      if (tmp___23 < 0) {
        {
#line 995
        error("Can\'t send CWD packet");
        }
#line 996
        return (1);
      }
    }
    {
#line 1005
    tmp___24 = write_enum(sd, 82);
    }
#line 1005
    if (tmp___24 < 0) {
      {
#line 1006
      error("Can\'t send ENVIRON packet");
      }
#line 1007
      return (1);
    } else {
      {
#line 1005
      tmp___25 = write_strv(sd, environ);
      }
#line 1005
      if (tmp___25 < 0) {
        {
#line 1006
        error("Can\'t send ENVIRON packet");
        }
#line 1007
        return (1);
      }
    }
#line 1021
    if (! remote_user) {
      {
#line 1022
      num = getgroups(65536, gids);
      }
#line 1023
      if (num < 0) {
        {
#line 1024
        error("Can\'t get supplementary group IDs");
        }
#line 1025
        return (1);
      }
    } else {
#line 1028
      num = 0;
    }
    {
#line 1031
    ids = uint16v_alloc((uint32_t )(2 + num));
    }
#line 1032
    if (! ids) {
      {
#line 1033
      oom_error();
      }
#line 1034
      return (1);
    }
#line 1037
    *(ids->vec + 0) = (uint16_t )uid;
#line 1038
    *(ids->vec + 1) = (uint16_t )gid;
#line 1040
    i___1 = 0;
    {
#line 1040
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1040
      if (! (i___1 < num)) {
#line 1040
        goto while_break___2;
      }
#line 1041
      *(ids->vec + (i___1 + 2)) = (uint16_t )gids[i___1];
#line 1040
      i___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1044
    tmp___26 = write_enum(sd, 83);
    }
#line 1044
    if (tmp___26 < 0) {
      {
#line 1045
      error("Can\'t send IDS packet");
      }
#line 1046
      return (1);
    } else {
      {
#line 1044
      tmp___27 = write_uint16v(sd, ids);
      }
#line 1044
      if (tmp___27 < 0) {
        {
#line 1045
        error("Can\'t send IDS packet");
        }
#line 1046
        return (1);
      }
    }
    {
#line 1049
    uint16v_free(ids);
#line 1056
    tmp___28 = umask((__mode_t )0);
#line 1056
    mask = (uint16_t )tmp___28;
#line 1057
    umask((__mode_t )mask);
#line 1060
    tmp___29 = write_uint16_packet(sd, (ptype_t )84, mask);
    }
#line 1060
    if (tmp___29 < 0) {
      {
#line 1061
      error("Can\'t send UMASK packet");
      }
#line 1062
      return (1);
    }
    {
#line 1070
    tmp___30 = isatty(0);
    }
#line 1070
    if (tmp___30) {
      {
#line 1070
      tmp___31 = isatty(1);
      }
#line 1070
      if (tmp___31) {
        {
#line 1070
        tmp___32 = isatty(2);
        }
#line 1070
        if (tmp___32) {
#line 1070
          tmp___33 = 1;
        } else {
#line 1070
          tmp___33 = 0;
        }
      } else {
#line 1070
        tmp___33 = 0;
      }
    } else {
#line 1070
      tmp___33 = 0;
    }
#line 1070
    is_tty = (bool_t )tmp___33;
#line 1073
    if (is_tty) {
      {
#line 1075
      ioctl(0, 21523UL, & ws);
#line 1078
      tmp___34 = write_enum(sd, 85);
      }
#line 1078
      if (tmp___34 < 0) {
        {
#line 1079
        error("Can\'t send WINSIZE packet");
        }
#line 1080
        return (1);
      } else {
        {
#line 1078
        tmp___35 = write_winsize(sd, (struct winsize  const  *)(& ws));
        }
#line 1078
        if (tmp___35 < 0) {
          {
#line 1079
          error("Can\'t send WINSIZE packet");
          }
#line 1080
          return (1);
        }
      }
    }
    {
#line 1088
    tmp___36 = set_nonblocking(1, (bool_t )1);
    }
#line 1088
    if (tmp___36 < 0) {
      {
#line 1089
      error("Can\'t make stdout non-blocking");
      }
#line 1090
      return (1);
    }
#line 1093
    if (is_tty) {
      {
#line 1094
      tmp___37 = set_nonblocking(2, (bool_t )1);
      }
#line 1094
      if (tmp___37 < 0) {
        {
#line 1095
        error("Can\'t make stderr non-blocking");
        }
#line 1096
        return (1);
      }
      {
#line 1099
      tmp___38 = set_raw_mode();
      }
#line 1099
      if (tmp___38 < 0) {
#line 1100
        return (1);
      }
    }
    {
#line 1107
    tmp___39 = write_enum(sd, 48);
    }
#line 1107
    if (tmp___39 < 0) {
      {
#line 1108
      error("Can\'t send COMMAND packet");
      }
#line 1109
      return (1);
    }
    {
#line 1115
    tmp___40 = manage(is_tty);
#line 1115
    rc = (int16_t )tmp___40;
    }
#line 1116
    if ((int )rc < 0) {
#line 1117
      return (1);
    }
  } else {
#line 1124
    if (action == 49) {
      {
#line 1126
      tmp___41 = write_enum(sd, 49);
      }
#line 1126
      if (tmp___41 < 0) {
        {
#line 1127
        error("Can\'t send MOUNT packet");
        }
#line 1128
        return (1);
      }
    } else {
      {
#line 1132
      tmp___42 = write_enum(sd, 50);
      }
#line 1132
      if (tmp___42 < 0) {
        {
#line 1133
        error("Can\'t send UMOUNT packet");
        }
#line 1134
        return (1);
      }
    }
    {
#line 1141
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1143
      tmp___43 = read_enum(sd);
#line 1143
      type___0 = (ptype_t )tmp___43;
      }
      {
#line 1145
      if ((unsigned int )type___0 == 4294967295U) {
#line 1145
        goto case_4294967295___0;
      }
#line 1149
      if ((unsigned int )type___0 == 36U) {
#line 1149
        goto case_36___0;
      }
#line 1158
      if ((unsigned int )type___0 == 16U) {
#line 1158
        goto case_16___0;
      }
#line 1162
      if ((unsigned int )type___0 == 17U) {
#line 1162
        goto case_17___0;
      }
#line 1166
      goto switch_default___0;
      case_4294967295___0: /* CIL Label */ 
      {
#line 1146
      error("Can\'t read packet type from socket");
      }
#line 1147
      return (1);
      case_36___0: /* CIL Label */ 
      {
#line 1151
      tmp___44 = read_uint16(sd, & val___0);
      }
#line 1151
      if (tmp___44 < 0) {
        {
#line 1152
        error("Can\'t read RC packet from socket");
        }
#line 1153
        return (1);
      }
#line 1155
      rc = (int16_t )val___0;
#line 1156
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
      {
#line 1159
      receive_message((ptype_t )16);
      }
#line 1160
      goto while_continue___3;
      case_17___0: /* CIL Label */ 
      {
#line 1163
      receive_message((ptype_t )17);
      }
#line 1164
      goto while_continue___3;
      switch_default___0: /* CIL Label */ 
      {
#line 1167
      tmp___45 = __errno_location();
#line 1167
      *tmp___45 = 0;
#line 1168
      error("Received packet has unexpected type (0x%02x)", (unsigned int )type___0);
      }
#line 1169
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
#line 1172
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1180
  if ((int )rc == 32767) {
#line 1182
    return (1);
  } else {
#line 1185
    return ((int )rc);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
mount_info_t *mntinfo_alloc(void) ;
#line 66
void mntinfo_free(mount_info_t *mi ) ;
#line 67
int mntinfo_copy(mount_info_t *dest , mount_info_t *src ) ;
#line 70
void mntinfo_sort_vec(mount_info_t **vec ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
uint32_t resolve(char const   *hostname ) ;
#line 40
ssize_t read_line(FILE *file , char *buf , size_t size ) ;
#line 47
int split_string(char *line  , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
mount_info_t *mntinfo_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 20
  tmp = calloc((size_t )1, sizeof(mount_info_t ));
  }
#line 20
  return ((mount_info_t *)tmp);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
void mntinfo_free(mount_info_t *mi ) 
{ 


  {
#line 25
  if (mi->opts) {
    {
#line 26
    free((void *)mi->opts);
    }
  }
#line 28
  if (mi->device) {
    {
#line 29
    free((void *)mi->device);
    }
  }
#line 31
  if (mi->point) {
    {
#line 32
    free((void *)mi->point);
    }
  }
  {
#line 34
  free((void *)mi);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
int mntinfo_copy(mount_info_t *dest , mount_info_t *src ) 
{ 


  {
  {
#line 39
  memset((void *)dest, 0, sizeof(mount_info_t ));
#line 41
  dest->type = src->type;
#line 43
  dest->point = strdup((char const   *)src->point);
  }
#line 44
  if (! dest->point) {
#line 45
    goto _err;
  }
  {
#line 47
  dest->device = strdup((char const   *)src->device);
  }
#line 48
  if (! dest->device) {
#line 49
    goto _err;
  }
#line 51
  if (src->opts) {
    {
#line 52
    dest->opts = strdup((char const   *)src->opts);
    }
#line 53
    if (! dest->opts) {
#line 54
      goto _err;
    }
  }
#line 57
  dest->device_dev = src->device_dev;
#line 59
  return (0);
  _err: 
#line 62
  if (dest->device) {
    {
#line 63
    free((void *)dest->device);
    }
  }
#line 65
  if (dest->point) {
    {
#line 66
    free((void *)dest->point);
    }
  }
  {
#line 68
  oom_error();
  }
#line 69
  return (-1);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
mount_info_t *mntinfo_parse(char const   *input ) 
{ 
  mount_info_t *mi ;
  char *buf ;
  char *type ;
  char *device ;
  char *point ;
  char *opts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 79
  buf = (char *)((void *)0);
#line 81
  mi = mntinfo_alloc();
  }
#line 82
  if (! mi) {
    {
#line 83
    oom_error();
    }
#line 84
    return ((mount_info_t *)((void *)0));
  }
  {
#line 87
  buf = strdup(input);
  }
#line 88
  if (! buf) {
    {
#line 89
    oom_error();
    }
#line 90
    goto _err_buf;
  }
  {
#line 93
  split_string(buf, & type, & device, & point, & opts, (void *)0);
  }
#line 95
  if (! type) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  } else
#line 95
  if (! device) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  } else
#line 95
  if (! point) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  }
  {
#line 100
  tmp___1 = strcmp((char const   *)type, "nfs");
  }
#line 100
  if (tmp___1 == 0) {
#line 101
    mi->type = (mtype_t )1;
  } else {
    {
#line 102
    tmp___0 = strcmp((char const   *)type, "bind");
    }
#line 102
    if (tmp___0 == 0) {
#line 103
      mi->type = (mtype_t )2;
    } else {
      {
#line 104
      tmp = strcmp((char const   *)type, "ssh");
      }
#line 104
      if (tmp == 0) {
#line 105
        mi->type = (mtype_t )3;
      } else {
        {
#line 107
        error("Unknown mount type: %s", type);
        }
#line 108
        goto _err;
      }
    }
  }
  {
#line 111
  mi->device = strdup((char const   *)device);
  }
#line 112
  if (! mi->device) {
    {
#line 113
    oom_error();
    }
#line 114
    goto _err;
  }
  {
#line 117
  mi->point = strdup((char const   *)point);
  }
#line 118
  if (! mi->point) {
    {
#line 119
    oom_error();
    }
#line 120
    goto _err;
  }
#line 123
  if (opts) {
    {
#line 124
    mi->opts = strdup((char const   *)opts);
    }
#line 125
    if (! mi->opts) {
      {
#line 126
      oom_error();
      }
#line 127
      goto _err;
    }
  }
  {
#line 131
  free((void *)buf);
  }
#line 133
  return (mi);
  _err: 
  {
#line 136
  free((void *)buf);
  }
  _err_buf: 
  {
#line 139
  mntinfo_free(mi);
  }
#line 140
  return ((mount_info_t *)((void *)0));
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static int resolve_nfs(char const   *fs , uint32_t *addr_p , char **path_p ) 
{ 
  char host[64] ;
  char *path ;
  uint32_t addr ;
  unsigned long tmp ;

  {
  {
#line 153
  path = strchr(fs, ':');
  }
#line 154
  if (! path) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  } else
#line 154
  if ((int )*(path + 1) == 0) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  }
  {
#line 159
  memset((void *)(host), '\000', sizeof(host));
  }
#line 160
  if ((unsigned long )(path - (char *)fs) < sizeof(host) - 1UL) {
#line 160
    tmp = (unsigned long )(path - (char *)fs);
  } else {
#line 160
    tmp = sizeof(host) - 1UL;
  }
  {
#line 160
  strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)fs, tmp);
#line 162
  addr = resolve((char const   *)(host));
  }
#line 163
  if (! addr) {
#line 164
    return (-1);
  }
#line 166
  *addr_p = addr;
#line 167
  *path_p = path + 1;
#line 169
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *get_local_path(uint32_t r_addr , char *r_path ) 
{ 
  FILE *file ;
  char buf[1024] ;
  struct __anonstruct_sel_57 sel ;
  char *device ;
  char *point ;
  char *type ;
  char *nfs_path ;
  uint32_t nfs_addr ;
  ssize_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 182
  sel.path = (char *)((void *)0);
#line 184
  file = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 185
  if (! file) {
    {
#line 186
    error("Can\'t open /proc/mounts");
    }
#line 187
    return ((char *)((void *)0));
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    tmp = read_line(file, buf, sizeof(buf));
    }
#line 194
    if (tmp < 0L) {
#line 195
      goto while_break;
    }
    {
#line 197
    split_string(buf, & device, & point, & type, (void *)0);
    }
#line 198
    if (! device) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! point) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! type) {
#line 199
      goto while_continue;
    } else {
      {
#line 198
      tmp___0 = strchr((char const   *)device, ':');
      }
#line 198
      if (tmp___0) {
        {
#line 198
        tmp___1 = strcmp((char const   *)type, "nfs");
        }
#line 198
        if (tmp___1 != 0) {
#line 199
          goto while_continue;
        }
      } else {
#line 199
        goto while_continue;
      }
    }
    {
#line 201
    tmp___2 = resolve_nfs((char const   *)device, & nfs_addr, & nfs_path);
    }
#line 201
    if (tmp___2 < 0) {
#line 202
      goto _err;
    }
#line 204
    if (r_addr != nfs_addr) {
#line 205
      goto while_continue;
    }
    {
#line 207
    tmp___3 = strlen((char const   *)nfs_path);
#line 207
    tmp___4 = strncmp((char const   *)r_path, (char const   *)nfs_path, tmp___3);
    }
#line 207
    if (tmp___4 != 0) {
#line 208
      goto while_continue;
    }
#line 212
    if (sel.path) {
      {
#line 213
      tmp___5 = strlen((char const   *)(sel.nfs_path));
#line 213
      tmp___6 = strlen((char const   *)nfs_path);
      }
#line 213
      if (tmp___5 < tmp___6) {
#line 214
        goto while_continue;
      }
      {
#line 216
      free((void *)sel.path);
      }
    }
    {
#line 219
    sel.path = strdup((char const   *)point);
    }
#line 220
    if (! sel.path) {
      {
#line 221
      oom_error();
      }
#line 222
      goto _err;
    }
    {
#line 225
    memset((void *)(sel.nfs_path), '\000', sizeof(sel.nfs_path));
#line 226
    strncpy((char */* __restrict  */)(sel.nfs_path), (char const   */* __restrict  */)nfs_path,
            sizeof(sel.nfs_path) - 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  fclose(file);
  }
#line 231
  if (sel.path) {
#line 232
    return (sel.path);
  } else {
#line 234
    return (r_path);
  }
  _err: 
#line 237
  if (sel.path) {
    {
#line 238
    free((void *)sel.path);
    }
  }
  {
#line 240
  fclose(file);
  }
#line 242
  return ((char *)((void *)0));
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *scratchbox_path_alias(char const   * const  path ) 
{ 
  char const   *scratchbox ;
  size_t scratchbox_len ;
  size_t tmp ;
  char *alias ;
  char *renamed ;
  size_t alias_len ;
  size_t renamed_len ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 247
  scratchbox = "/scratchbox/";
#line 248
  tmp = strlen(scratchbox);
#line 248
  scratchbox_len = tmp;
#line 253
  alias = getenv("_SBOX_DIR");
  }
#line 254
  if (! alias) {
#line 255
    return ((char *)((void *)0));
  }
  {
#line 257
  alias_len = strlen((char const   *)alias);
  }
#line 258
  if (alias_len <= 1UL) {
#line 259
    return ((char *)((void *)0));
  } else {
    {
#line 258
    tmp___0 = strncmp((char const   *)path, (char const   *)alias, alias_len);
    }
#line 258
    if (tmp___0 != 0) {
#line 259
      return ((char *)((void *)0));
    }
  }
  {
#line 261
  tmp___1 = strlen((char const   *)path);
#line 261
  renamed_len = ((tmp___1 - alias_len) + scratchbox_len) + 1UL;
#line 262
  tmp___2 = malloc(renamed_len);
#line 262
  renamed = (char *)tmp___2;
  }
#line 263
  if (! renamed) {
    {
#line 264
    oom_error();
    }
#line 265
    return ((char *)((void *)0));
  }
  {
#line 268
  strcpy((char */* __restrict  */)renamed, (char const   */* __restrict  */)scratchbox);
#line 269
  strcat((char */* __restrict  */)renamed, (char const   */* __restrict  */)(path + alias_len));
  }
#line 271
  return (renamed);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
int mntinfo_stat_device(mount_info_t *mi ) 
{ 
  char *nfs_path ;
  char *path ;
  char *renamed_path ;
  uint32_t nfs_addr ;
  struct stat buf ;
  int rc ;
  int tmp ;

  {
#line 279
  nfs_path = (char *)((void *)0);
#line 284
  if ((unsigned int )mi->type == 1U) {
    {
#line 285
    tmp = resolve_nfs((char const   *)mi->device, & nfs_addr, & nfs_path);
    }
#line 285
    if (tmp < 0) {
#line 286
      return (-1);
    }
    {
#line 288
    path = get_local_path(nfs_addr, nfs_path);
    }
#line 289
    if (! path) {
#line 290
      return (-1);
    }
    {
#line 292
    renamed_path = scratchbox_path_alias((char const   */* const  */)path);
    }
#line 293
    if (renamed_path) {
#line 294
      if ((unsigned long )path != (unsigned long )nfs_path) {
        {
#line 295
        free((void *)path);
        }
      }
#line 297
      path = renamed_path;
    }
  } else {
    {
#line 300
    path = strchr((char const   *)mi->device, ':');
    }
#line 301
    if (! path) {
#line 302
      return (-1);
    }
#line 303
    path ++;
  }
  {
#line 306
  rc = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
  }
#line 307
  if (rc >= 0) {
#line 308
    mi->device_dev = buf.st_dev;
  } else {
    {
#line 310
    error("Can\'t stat %s", path);
    }
  }
#line 312
  if (nfs_path) {
#line 312
    if ((unsigned long )path != (unsigned long )nfs_path) {
      {
#line 313
      free((void *)path);
      }
    }
  }
#line 315
  return (rc);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
void mntinfo_sort_vec(mount_info_t **vec ) 
{ 
  mount_info_t **p ;
  mount_info_t *tmp ;
  bool_t touched ;
  int tmp___0 ;

  {
#line 326
  if (! *(vec + 0)) {
#line 327
    return;
  } else
#line 326
  if (! *(vec + 1)) {
#line 327
    return;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    touched = (bool_t )0;
#line 332
    p = vec;
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 332
      if (! *(p + 1)) {
#line 332
        goto while_break___0;
      }
      {
#line 333
      tmp___0 = strcmp((char const   *)(*(p + 0))->point, (char const   *)(*(p + 1))->point);
      }
#line 333
      if (tmp___0 > 0) {
#line 334
        tmp = *(p + 0);
#line 335
        *(p + 0) = *(p + 1);
#line 336
        *(p + 1) = tmp;
#line 338
        touched = (bool_t )1;
      }
#line 332
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 329
    if (! touched) {
#line 329
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
int set_closeonexec(int fd ) ;
#line 35
int setsockopt_bool(int s , int level , int sockopt , bool_t value ) ;
#line 38
void free_vec(void **vec , free_func_t *func ) ;
#line 41
ssize_t read_line_blank(FILE *file , char *buf , size_t size , bool_t *blankp ) ;
#line 42
ssize_t read_line_nocomments(FILE *file , char *buf , size_t size ) ;
#line 43
char *skip_spaces(char const   *buf ) ;
#line 44
char *find_space(char const   *buf ) ;
#line 45
char *find_line(char *buf ) ;
#line 46
char *trim_string(char *buf ) ;
#line 48
size_t string_cat(char *buf , size_t bufsize , char const   *piece  , ...) ;
#line 51
char const   *oom ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char const   *oom  =    "Out of memory";
#line 24 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
void oom_error(void) 
{ 
  int *tmp ;

  {
  {
#line 26
  tmp = __errno_location();
#line 26
  *tmp = 0;
#line 27
  error(oom);
  }
#line 28
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int set_nonblocking(int fd , bool_t nonblock ) 
{ 
  int val ;
  int tmp ;

  {
  {
#line 39
  val = fcntl(fd, 3, 0);
  }
#line 40
  if (val < 0) {
#line 41
    return (-1);
  }
#line 43
  if (nonblock) {
#line 44
    if (val & 2048) {
#line 45
      return (0);
    }
#line 47
    val |= 2048;
  } else {
#line 49
    if (! (val & 2048)) {
#line 50
      return (0);
    }
#line 52
    val &= -2049;
  }
  {
#line 55
  tmp = fcntl(fd, 4, val);
  }
#line 55
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int set_closeonexec(int fd ) 
{ 
  int val ;
  int tmp ;

  {
  {
#line 65
  val = fcntl(fd, 1, 0);
  }
#line 66
  if (val < 0) {
#line 67
    return (-1);
  }
#line 69
  if (val & 1) {
#line 70
    return (0);
  }
  {
#line 72
  tmp = fcntl(fd, 2, val | 1);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int setsockopt_bool(int s , int level , int sockopt , bool_t value ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = setsockopt(s, level, sockopt, (void const   *)(& value), (socklen_t )sizeof(value));
  }
#line 77
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *get_progname(char *name ) 
{ 
  char *p ;
  size_t tmp ;

  {
  {
#line 87
  p = strrchr((char const   *)name, '/');
  }
#line 88
  if (p) {
    {
#line 88
    tmp = strlen((char const   *)p);
    }
#line 88
    if (tmp >= 2UL) {
#line 89
      return (p + 1);
    } else {
#line 91
      return (name);
    }
  } else {
#line 91
    return (name);
  }
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
uint32_t resolve(char const   *hostname ) 
{ 
  struct hostent *host ;
  uint32_t addr ;
  uint32_t tmp ;

  {
  {
#line 99
  host = gethostbyname(hostname);
  }
#line 100
  if (! host) {
#line 101
    goto _err;
  }
#line 103
  addr = *((uint32_t *)*(host->h_addr_list + 0));
#line 104
  if (! addr) {
#line 105
    goto _err;
  }
  {
#line 107
  tmp = ntohl(addr);
  }
#line 107
  return (tmp);
  _err: 
  {
#line 110
  error("Can\'t resolve host: %s", hostname);
  }
#line 111
  return ((uint32_t )0);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
void free_vec(void **vec , free_func_t *func ) 
{ 
  void **p ;

  {
#line 125
  if (! vec) {
#line 126
    return;
  }
#line 128
  if (! func) {
#line 129
    func = (free_func_t *)(& free);
  }
#line 131
  p = vec;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! *p) {
#line 131
      goto while_break;
    }
    {
#line 132
    (*func)(*p);
#line 131
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  free((void *)vec);
  }
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
size_t calc_vec_len(void **vec ) 
{ 
  size_t len ;
  void **tmp ;

  {
#line 139
  len = (size_t )0;
#line 141
  if (vec) {
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 142
      tmp = vec;
#line 142
      vec ++;
#line 142
      if (! *tmp) {
#line 142
        goto while_break;
      }
#line 143
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 145
  return (len);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
static ssize_t do_read_line(FILE *file , char *buf , size_t size , char comment_char ,
                            bool_t *blankp ) 
{ 
  bool_t blank ;
  bool_t comm ;
  size_t i ;
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 151
  blank = (bool_t )1;
#line 152
  comm = (bool_t )0;
#line 153
  i = (size_t )0;
#line 156
  tmp = feof(file);
  }
#line 156
  if (tmp) {
#line 157
    return ((ssize_t )-1);
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    c = fgetc(file);
    }
#line 161
    if (c == -1) {
#line 162
      goto while_break;
    } else
#line 161
    if (c == 10) {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp___0 = __ctype_b_loc();
    }
#line 164
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 165
      blank = (bool_t )0;
    }
#line 167
    if (c == (int )comment_char) {
#line 168
      comm = (bool_t )1;
    }
#line 170
    if (! comm) {
#line 170
      if (i < size - 1UL) {
#line 171
        tmp___1 = buf;
#line 171
        buf ++;
#line 171
        *tmp___1 = (char )c;
#line 172
        i ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *buf = (char )'\000';
#line 177
  if (blankp) {
#line 178
    *blankp = blank;
  }
#line 180
  return ((ssize_t )i);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line(FILE *file , char *buf , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 185
  tmp = do_read_line(file, buf, size, (char )'#', (bool_t *)((void *)0));
  }
#line 185
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line_blank(FILE *file , char *buf , size_t size , bool_t *blankp ) 
{ 
  ssize_t tmp ;

  {
  {
#line 190
  tmp = do_read_line(file, buf, size, (char )'#', blankp);
  }
#line 190
  return (tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line_nocomments(FILE *file , char *buf , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 198
  tmp = do_read_line(file, buf, size, (char )'\000', (bool_t *)((void *)0));
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *skip_spaces(char const   *buf ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (*buf) {
      {
#line 203
      tmp = __ctype_b_loc();
      }
#line 203
      if (! ((int const   )*(*tmp + (int )*buf) & 8192)) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 204
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return ((char *)buf);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *find_space(char const   *buf ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (*buf) {
      {
#line 211
      tmp = __ctype_b_loc();
      }
#line 211
      if ((int const   )*(*tmp + (int )*buf) & 8192) {
#line 211
        goto while_break;
      }
    } else {
#line 211
      goto while_break;
    }
#line 212
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((char *)buf);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *find_line(char *buf ) 
{ 
  char *tmp ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (*buf) {
#line 219
      tmp = buf;
#line 219
      buf ++;
#line 219
      if (! ((int )*tmp != 10)) {
#line 219
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (buf);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *trim_string(char *buf ) 
{ 
  char *next ;
  char *end ;
  char *tmp ;

  {
  {
#line 229
  buf = skip_spaces((char const   *)buf);
#line 231
  next = buf;
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    tmp = find_space((char const   *)next);
#line 232
    end = tmp;
    }
#line 234
    if ((int )*end == 0) {
#line 235
      goto while_break;
    }
    {
#line 237
    next = skip_spaces((char const   *)end);
    }
#line 238
    if ((int )*next == 0) {
#line 239
      *end = (char )'\000';
#line 240
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (buf);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int split_string(char *line  , ...) 
{ 
  va_list arg ;
  char **strp ;
  char *str ;
  int n ;
  char **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 251
  n = 0;
#line 253
  __builtin_va_start(arg, line);
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 256
    tmp = __builtin_va_arg(arg, char **);
#line 256
    strp = tmp;
    }
#line 257
    if (! strp) {
#line 258
      goto while_break;
    }
    {
#line 260
    tmp___0 = strlen((char const   *)line);
    }
#line 260
    if (tmp___0 == 0UL) {
#line 261
      *strp = (char *)((void *)0);
#line 262
      goto while_continue;
    }
    {
#line 265
    str = line;
#line 267
    line = find_space((char const   *)line);
    }
#line 268
    if (*line) {
      {
#line 269
      tmp___1 = line;
#line 269
      line ++;
#line 269
      *tmp___1 = (char )'\000';
#line 270
      line = skip_spaces((char const   *)line);
      }
    }
    {
#line 273
    tmp___2 = strlen((char const   *)str);
    }
#line 273
    if (tmp___2 > 0UL) {
#line 274
      *strp = str;
#line 275
      n ++;
    } else {
#line 277
      *strp = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  __builtin_va_end(arg);
  }
#line 283
  return (n);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
size_t string_cat(char *buf , size_t bufsize , char const   *piece  , ...) 
{ 
  char *str ;
  ssize_t avail ;
  va_list arg ;
  size_t len ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 292
  __builtin_va_start(arg, piece);
#line 294
  str = buf;
#line 295
  *str = (char )'\000';
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! piece) {
#line 297
      goto while_break;
    }
    {
#line 300
    tmp = strlen((char const   *)str);
#line 300
    avail = (ssize_t )((bufsize - 1UL) - tmp);
    }
#line 301
    if (avail <= 0L) {
#line 302
      goto while_break;
    }
    {
#line 305
    len = strlen(piece);
    }
#line 306
    if (len > (size_t )avail) {
      {
#line 307
      strncat((char */* __restrict  */)str, (char const   */* __restrict  */)piece,
              (size_t )avail);
      }
#line 308
      goto while_break;
    }
    {
#line 311
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)piece);
#line 313
    tmp___0 = __builtin_va_arg(arg, char *);
#line 313
    piece = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  __builtin_va_end(arg);
#line 318
  tmp___1 = strlen((char const   *)buf);
  }
#line 318
  return (tmp___1);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
char **get_targets(char const   *filename ) ;
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static char *is_target(char *tgt , char *buf ) 
{ 
  int a ;
  int b ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    tmp = tgt;
#line 28
    tgt ++;
#line 28
    a = (int )*tmp;
#line 29
    tmp___0 = buf;
#line 29
    buf ++;
#line 29
    b = (int )*tmp___0;
#line 31
    if (! a) {
#line 31
      goto _L;
    } else
#line 31
    if (! b) {
#line 31
      goto _L;
    } else {
      {
#line 31
      tmp___4 = __ctype_b_loc();
      }
#line 31
      if ((int const   )*(*tmp___4 + b) & 8192) {
        _L: /* CIL Label */ 
#line 32
        if (! a) {
          {
#line 32
          tmp___3 = __ctype_b_loc();
          }
#line 32
          if ((int const   )*(*tmp___3 + b) & 8192) {
#line 32
            tmp___2 = buf;
          } else {
#line 32
            tmp___2 = (char *)((void *)0);
          }
        } else {
#line 32
          tmp___2 = (char *)((void *)0);
        }
#line 32
        return (tmp___2);
      }
    }
#line 34
    if (a != b) {
#line 35
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static bool_t read_params(char *buf , config_t *cfg ) 
{ 
  char *host ;
  char *port___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 46
  host = skip_spaces((char const   *)buf);
  }
#line 47
  if (! host) {
    {
#line 48
    tmp = __errno_location();
#line 48
    *tmp = 0;
#line 49
    error("Invalid parameter string");
    }
#line 50
    return ((bool_t )0);
  }
  {
#line 53
  port___0 = strchr((char const   *)host, ':');
  }
#line 54
  if (port___0) {
#line 55
    tmp___0 = port___0;
#line 55
    port___0 ++;
#line 55
    *tmp___0 = (char )'\000';
#line 56
    buf = port___0;
  } else {
#line 58
    port___0 = (char *)((void *)0);
#line 59
    buf = host;
  }
  {
#line 62
  buf = find_space((char const   *)buf);
  }
#line 63
  if (! buf) {
    {
#line 64
    tmp___1 = __errno_location();
#line 64
    *tmp___1 = 0;
#line 65
    error("Invalid parameter string");
    }
#line 66
    return ((bool_t )0);
  }
  {
#line 68
  tmp___2 = buf;
#line 68
  buf ++;
#line 68
  *tmp___2 = (char )'\000';
#line 70
  cfg->host = strdup((char const   *)host);
  }
#line 71
  if (! cfg->host) {
    {
#line 72
    oom_error();
    }
#line 73
    return ((bool_t )0);
  }
#line 76
  if (port___0) {
    {
#line 77
    cfg->port = strdup((char const   *)port___0);
    }
#line 78
    if (! cfg->port) {
      {
#line 79
      oom_error();
      }
#line 80
      return ((bool_t )0);
    }
  }
#line 84
  return ((bool_t )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static bool_t read_opts(FILE *file , char *buf , size_t size , config_t *cfg ) 
{ 
  long pos ;
  size_t cnt ;
  char **p ;
  bool_t blank ;
  ssize_t len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  char **tmp___4 ;

  {
  {
#line 90
  cnt = (size_t )0;
#line 93
  pos = ftell(file);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    len = read_line_blank(file, buf, size, & blank);
    }
#line 100
    if (len < 0L) {
#line 101
      goto while_break;
    }
#line 102
    if (blank) {
#line 103
      goto while_break;
    }
#line 104
    if (len > 0L) {
      {
#line 104
      tmp = __ctype_b_loc();
      }
#line 104
      if (! ((int const   )*(*tmp + (int )*(buf + 0)) & 8192)) {
#line 105
        goto while_break;
      }
    }
    {
#line 107
    buf = skip_spaces((char const   *)buf);
#line 108
    tmp___0 = strlen((char const   *)buf);
    }
#line 108
    if (tmp___0 == 0UL) {
#line 109
      goto while_continue;
    }
#line 111
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  fseek(file, pos, 0);
#line 116
  tmp___1 = calloc(cnt + 1UL, sizeof(char *));
#line 116
  cfg->opts = (char **)tmp___1;
  }
#line 117
  if (! cfg->opts) {
    {
#line 118
    oom_error();
    }
#line 119
    return ((bool_t )0);
  }
#line 122
  p = cfg->opts;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! (cnt > 0UL)) {
#line 122
      goto while_break___0;
    }
    {
#line 123
    tmp___2 = read_line(file, buf, size);
    }
#line 123
    if (tmp___2 < 0L) {
#line 124
      goto while_break___0;
    }
    {
#line 126
    buf = skip_spaces((char const   *)buf);
#line 127
    tmp___3 = strlen((char const   *)buf);
    }
#line 127
    if (tmp___3 == 0UL) {
#line 128
      goto __Cont;
    }
    {
#line 130
    tmp___4 = p;
#line 130
    p ++;
#line 130
    *tmp___4 = strdup((char const   *)buf);
#line 131
    cnt --;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  return ((bool_t )1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
bool_t config_read(config_t *cfg , char const   *filename , char const   *target___0 ) 
{ 
  FILE *file ;
  char buf[1024] ;
  char *bufp ;
  ssize_t len ;
  bool_t ok ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 142
  ok = (bool_t )0;
#line 144
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 145
  if (! file) {
    {
#line 146
    error("Can\'t open %s", filename);
    }
#line 147
    return ((bool_t )0);
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    len = read_line(file, buf, sizeof(buf));
    }
#line 152
    if (len < 0L) {
      {
#line 153
      tmp = __errno_location();
#line 153
      *tmp = 0;
#line 154
      error("Target %s is not listed in %s", target___0, filename);
      }
#line 155
      goto while_break;
    }
#line 158
    if (len == 0L) {
#line 159
      goto while_continue;
    } else {
      {
#line 158
      tmp___0 = __ctype_b_loc();
      }
#line 158
      if ((int const   )*(*tmp___0 + (int )buf[0]) & 8192) {
#line 159
        goto while_continue;
      }
    }
#line 161
    if (target___0) {
      {
#line 164
      bufp = is_target((char *)target___0, buf);
      }
#line 165
      if (! bufp) {
#line 166
        goto while_continue;
      }
      {
#line 168
      cfg->target = strdup(target___0);
      }
    } else {
      {
#line 173
      bufp = find_space((char const   *)(buf));
#line 174
      cfg->target = strndup((char const   *)(buf), (size_t )(bufp - buf));
      }
    }
    {
#line 177
    tmp___1 = read_params(bufp, cfg);
    }
#line 177
    if (tmp___1) {
      {
#line 177
      tmp___2 = read_opts(file, buf, sizeof(buf), cfg);
      }
#line 177
      if (tmp___2) {
#line 177
        tmp___3 = 1;
      } else {
#line 177
        tmp___3 = 0;
      }
    } else {
#line 177
      tmp___3 = 0;
    }
#line 177
    ok = (bool_t )tmp___3;
#line 178
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  fclose(file);
  }
#line 183
  return (ok);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
config_t *config_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 188
  tmp = calloc((size_t )1, sizeof(config_t ));
  }
#line 188
  return ((config_t *)tmp);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
void config_free(config_t *cfg ) 
{ 


  {
#line 193
  if (cfg->target) {
    {
#line 194
    free((void *)cfg->target);
    }
  }
#line 196
  if (cfg->host) {
    {
#line 197
    free((void *)cfg->host);
    }
  }
#line 199
  if (cfg->port) {
    {
#line 200
    free((void *)cfg->port);
    }
  }
#line 202
  if (cfg->opts) {
    {
#line 203
    free_vec((void **)cfg->opts, (free_func_t *)((void *)0));
    }
  }
  {
#line 205
  free((void *)cfg);
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
char **get_targets(char const   *filename ) 
{ 
  FILE *file ;
  char buf[1024] ;
  ssize_t len ;
  size_t cnt ;
  char **targets ;
  char **p ;
  unsigned short const   **tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 216
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 217
  if (! file) {
#line 218
    return ((char **)((void *)0));
  }
#line 220
  cnt = (size_t )0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    len = read_line(file, buf, sizeof(buf));
    }
#line 222
    if (len < 0L) {
#line 223
      goto while_break;
    }
#line 225
    if (len > 0L) {
      {
#line 225
      tmp = __ctype_b_loc();
      }
#line 225
      if (! ((int const   )*(*tmp + (int )buf[0]) & 8192)) {
#line 226
        cnt ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  rewind(file);
#line 231
  tmp___0 = calloc(cnt + 1UL, sizeof(char *));
#line 231
  targets = (char **)tmp___0;
  }
#line 232
  if (! targets) {
    {
#line 233
    oom_error();
    }
#line 234
    return ((char **)((void *)0));
  }
#line 237
  p = targets;
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    len = read_line(file, buf, sizeof(buf));
    }
#line 239
    if (len < 0L) {
#line 240
      goto while_break___0;
    }
#line 242
    if (len > 0L) {
      {
#line 242
      tmp___3 = __ctype_b_loc();
      }
#line 242
      if (! ((int const   )*(*tmp___3 + (int )buf[0]) & 8192)) {
        {
#line 243
        tmp___1 = find_space((char const   *)(buf));
#line 243
        *tmp___1 = (char )'\000';
#line 244
        tmp___2 = p;
#line 244
        p ++;
#line 244
        *tmp___2 = strdup((char const   *)(buf));
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  return (targets);
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
ssize_t write_ni(int fd , void *buf , size_t len ) ;
#line 30
ssize_t read_ni(int fd , void *buf , size_t len ) ;
#line 32
int write_buf(int fd , void *buf , size_t len ) ;
#line 35
int write_uint16(int fd , uint16_t i ) ;
#line 38
int write_uint32(int fd , uint32_t i ) ;
#line 41
int write_uint64(int fd , uint64_t i ) ;
#line 42
int read_uint64(int fd , uint64_t *iptr ) ;
#line 45
uint16v_t *read_uint16v(int fd ) ;
#line 47
int write_str(int fd , char const   *str ) ;
#line 48
char *read_str(int fd ) ;
#line 51
char **read_strv(int fd ) ;
#line 53
int write_mount(int fd , mount_info_t const   *mi ) ;
#line 54
mount_info_t *read_mount(int fd ) ;
#line 57
mount_info_t **read_mountv(int fd ) ;
#line 60
struct winsize *read_winsize(int fd ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
uint16v_t *uint16v_alloc(uint32_t len ) 
{ 
  char *mem ;
  void *tmp ;
  uint16v_t *ints ;

  {
  {
#line 108
  tmp = malloc(sizeof(uint16v_t ) + (unsigned long )len * sizeof(uint16_t ));
#line 108
  mem = (char *)tmp;
#line 109
  ints = (uint16v_t *)mem;
  }
#line 110
  if (ints) {
#line 111
    ints->len = len;
#line 112
    ints->vec = (uint16_t *)(mem + sizeof(uint16v_t ));
  }
#line 114
  return (ints);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
void uint16v_free(uint16v_t *ints ) 
{ 


  {
  {
#line 119
  free((void *)ints);
  }
#line 120
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
ssize_t read_ni(int fd , void *buf , size_t len ) 
{ 
  ssize_t retval ;
  int *tmp ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    retval = read(fd, buf, len);
    }
#line 128
    if (retval < 0L) {
      {
#line 128
      tmp = __errno_location();
      }
#line 128
      if (! (*tmp == 4)) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return (retval);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
ssize_t write_ni(int fd , void *buf , size_t len ) 
{ 
  ssize_t retval ;
  int *tmp ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    retval = write(fd, (void const   *)buf, len);
    }
#line 140
    if (retval < 0L) {
      {
#line 140
      tmp = __errno_location();
      }
#line 140
      if (! (*tmp == 4)) {
#line 140
        goto while_break;
      }
    } else {
#line 140
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (retval);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16(int fd , uint16_t i ) 
{ 
  uint16_t data ;
  uint16_t tmp ;
  int tmp___0 ;

  {
  {
#line 148
  tmp = htons(i);
#line 148
  data = tmp;
#line 149
  tmp___0 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 149
  return (tmp___0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint32(int fd , uint32_t i ) 
{ 
  uint32_t data ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 154
  tmp = htonl(i);
#line 154
  data = tmp;
#line 155
  tmp___0 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 155
  return (tmp___0);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint64(int fd , uint64_t i ) 
{ 
  uint64_t data ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 160
  tmp = htonl((uint32_t )i);
#line 160
  tmp___0 = htonl((uint32_t )(i >> 32LL));
#line 160
  data = ((uint64_t )tmp << 32LL) | (unsigned long )tmp___0;
#line 161
  tmp___1 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 161
  return (tmp___1);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16v(int fd , uint16v_t *ints ) 
{ 
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 166
  tmp = write_uint32(fd, ints->len);
  }
#line 166
  if (tmp < 0) {
#line 167
    return (-1);
  }
#line 169
  if (ints) {
#line 171
    i = 0;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! ((uint32_t )i < ints->len)) {
#line 171
        goto while_break;
      }
      {
#line 172
      tmp___0 = write_uint16(fd, *(ints->vec + i));
      }
#line 172
      if (tmp___0 < 0) {
#line 173
        return (-1);
      }
#line 171
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 176
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_str(int fd , char const   *str ) 
{ 
  uint32_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 189
  if (! str) {
#line 190
    str = "";
  }
  {
#line 192
  tmp = strlen(str);
#line 192
  len = (uint32_t )tmp;
#line 194
  tmp___0 = write_uint32(fd, len);
  }
#line 194
  if (tmp___0 < 0) {
#line 195
    return (-1);
  } else {
    {
#line 194
    tmp___1 = write_buf(fd, (void *)str, (size_t )len);
    }
#line 194
    if (tmp___1 < 0) {
#line 195
      return (-1);
    }
  }
#line 196
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_strv(int fd , char **strv ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char **s ;
  int tmp___1 ;

  {
  {
#line 207
  tmp = calc_vec_len((void **)strv);
#line 207
  tmp___0 = write_uint32(fd, (uint32_t )tmp);
  }
#line 207
  if (tmp___0 < 0) {
#line 208
    return (-1);
  }
#line 210
  if (strv) {
#line 212
    s = strv;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! *s) {
#line 212
        goto while_break;
      }
      {
#line 213
      tmp___1 = write_str(fd, (char const   *)*s);
      }
#line 213
      if (tmp___1 < 0) {
#line 214
        return (-1);
      }
#line 212
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 217
  return (0);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_mount(int fd , mount_info_t const   *mi ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 222
  tmp = write_enum(fd, (int )mi->type);
  }
#line 222
  if (tmp < 0) {
#line 225
    return (-1);
  } else {
    {
#line 222
    tmp___0 = write_str(fd, (char const   *)mi->point);
    }
#line 222
    if (tmp___0 < 0) {
#line 225
      return (-1);
    } else {
      {
#line 222
      tmp___1 = write_str(fd, (char const   *)mi->device);
      }
#line 222
      if (tmp___1 < 0) {
#line 225
        return (-1);
      } else {
        {
#line 222
        tmp___2 = write_str(fd, (char const   *)mi->opts);
        }
#line 222
        if (tmp___2 < 0) {
#line 225
          return (-1);
        } else {
          {
#line 222
          tmp___3 = write_uint64(fd, (uint64_t )mi->device_dev);
          }
#line 222
          if (tmp___3) {
#line 225
            return (-1);
          }
        }
      }
    }
  }
#line 226
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_mountv(int fd , mount_info_t **mounts ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  mount_info_t **p ;
  int tmp___1 ;

  {
  {
#line 231
  tmp = calc_vec_len((void **)mounts);
#line 231
  tmp___0 = write_uint32(fd, (uint32_t )tmp);
  }
#line 231
  if (tmp___0 < 0) {
#line 232
    return (-1);
  }
#line 234
  if (mounts) {
#line 236
    p = mounts;
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! *p) {
#line 236
        goto while_break;
      }
      {
#line 237
      tmp___1 = write_mount(fd, (mount_info_t const   *)*p);
      }
#line 237
      if (tmp___1 < 0) {
#line 238
        return (-1);
      }
#line 236
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 241
  return (0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_buf(int fd , void *buf , size_t len ) 
{ 
  ssize_t i ;
  ssize_t cnt ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 248
  i = (ssize_t )0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ((size_t )i < len)) {
#line 248
      goto while_break;
    }
    {
#line 249
    cnt = write(fd, (void const   *)(buf + i), len - (size_t )i);
    }
#line 250
    if (cnt < 0L) {
      {
#line 251
      tmp = __errno_location();
      }
#line 251
      if (*tmp == 11) {
#line 252
        cnt = (ssize_t )0;
#line 253
        goto __Cont;
      } else {
        {
#line 251
        tmp___0 = __errno_location();
        }
#line 251
        if (*tmp___0 == 4) {
#line 252
          cnt = (ssize_t )0;
#line 253
          goto __Cont;
        }
      }
#line 256
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 248
    i += cnt;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_buf(int fd , void *buf , size_t len ) 
{ 
  ssize_t i ;
  ssize_t cnt ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 274
  i = (ssize_t )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((size_t )i < len)) {
#line 274
      goto while_break;
    }
    {
#line 275
    cnt = read(fd, buf + i, len - (size_t )i);
    }
#line 276
    if (cnt < 0L) {
      {
#line 277
      tmp = __errno_location();
      }
#line 277
      if (*tmp == 11) {
#line 278
        cnt = (ssize_t )0;
#line 279
        goto __Cont;
      } else {
        {
#line 277
        tmp___0 = __errno_location();
        }
#line 277
        if (*tmp___0 == 4) {
#line 278
          cnt = (ssize_t )0;
#line 279
          goto __Cont;
        }
      }
#line 282
      return (-1);
    }
#line 285
    if (cnt == 0L) {
      {
#line 286
      tmp___1 = __errno_location();
#line 286
      *tmp___1 = 5;
      }
#line 287
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 274
    i += cnt;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return (0);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint16(int fd , uint16_t *iptr ) 
{ 
  uint16_t data ;
  int tmp ;

  {
  {
#line 297
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 297
  if (tmp < 0) {
#line 298
    return (-1);
  }
  {
#line 299
  *iptr = ntohs(data);
  }
#line 300
  return (0);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint32(int fd , uint32_t *iptr ) 
{ 
  uint32_t data ;
  int tmp ;

  {
  {
#line 306
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 306
  if (tmp < 0) {
#line 307
    return (-1);
  }
  {
#line 308
  *iptr = ntohl(data);
  }
#line 309
  return (0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint64(int fd , uint64_t *iptr ) 
{ 
  uint64_t data ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 315
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 315
  if (tmp < 0) {
#line 316
    return (-1);
  }
  {
#line 317
  tmp___0 = ntohl((uint32_t )data);
#line 317
  tmp___1 = ntohl((uint32_t )(data >> 32LL));
#line 317
  *iptr = ((uint64_t )tmp___0 << 32LL) | (unsigned long )tmp___1;
  }
#line 318
  return (0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
uint16v_t *read_uint16v(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  uint16v_t *ints ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 326
  tmp = read_uint32(fd, & len);
  }
#line 326
  if (tmp < 0) {
#line 327
    return ((uint16v_t *)((void *)0));
  }
  {
#line 329
  ints = uint16v_alloc(len);
  }
#line 330
  if (! ints) {
#line 331
    return ((uint16v_t *)((void *)0));
  }
#line 333
  i = (uint32_t )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < len)) {
#line 333
      goto while_break;
    }
    {
#line 334
    tmp___0 = read_uint16(fd, ints->vec + i);
    }
#line 334
    if (tmp___0 < 0) {
      {
#line 335
      uint16v_free(ints);
      }
#line 336
      return ((uint16v_t *)((void *)0));
    }
#line 333
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return (ints);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
char *read_str(int fd ) 
{ 
  uint32_t len ;
  char *str ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 352
  tmp = read_uint32(fd, & len);
  }
#line 352
  if (tmp < 0) {
#line 353
    return ((char *)((void *)0));
  }
  {
#line 355
  tmp___0 = calloc((size_t )(len + 1U), (size_t )1);
#line 355
  str = (char *)tmp___0;
  }
#line 356
  if (! str) {
#line 357
    return ((char *)((void *)0));
  }
  {
#line 359
  tmp___1 = read_buf(fd, (void *)str, (size_t )len);
  }
#line 359
  if (tmp___1 < 0) {
    {
#line 360
    free((void *)str);
    }
#line 361
    return ((char *)((void *)0));
  }
#line 363
  return (str);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
char **read_strv(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  char **strv ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 377
  tmp = read_uint32(fd, & len);
  }
#line 377
  if (tmp < 0) {
#line 378
    return ((char **)((void *)0));
  }
  {
#line 380
  tmp___0 = calloc((size_t )(len + 1U), sizeof(char *));
#line 380
  strv = (char **)tmp___0;
  }
#line 381
  if (! strv) {
#line 382
    return ((char **)((void *)0));
  }
#line 384
  i = (uint32_t )0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (i < len)) {
#line 384
      goto while_break;
    }
    {
#line 385
    *(strv + i) = read_str(fd);
    }
#line 386
    if (! *(strv + i)) {
      {
#line 387
      free_vec((void **)strv, (free_func_t *)((void *)0));
      }
#line 388
      return ((char **)((void *)0));
    }
#line 384
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return (strv);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
mount_info_t *read_mount(int fd ) 
{ 
  mount_info_t *mi ;
  mtype_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 399
  mi = mntinfo_alloc();
  }
#line 400
  if (! mi) {
#line 401
    return ((mount_info_t *)((void *)0));
  }
  {
#line 403
  tmp___0 = read_enum(fd);
#line 403
  tmp = (mtype_t )tmp___0;
#line 403
  mi->type = tmp;
  }
#line 403
  if ((unsigned int )tmp >= 0U) {
    {
#line 403
    tmp___1 = read_str(fd);
#line 403
    mi->point = tmp___1;
    }
#line 403
    if (tmp___1) {
      {
#line 403
      tmp___2 = read_str(fd);
#line 403
      mi->device = tmp___2;
      }
#line 403
      if (tmp___2) {
        {
#line 403
        tmp___3 = read_str(fd);
#line 403
        mi->opts = tmp___3;
        }
#line 403
        if (tmp___3) {
          {
#line 403
          tmp___4 = read_uint64(fd, & mi->device_dev);
          }
#line 403
          if (tmp___4 >= 0) {
#line 408
            return (mi);
          }
        }
      }
    }
  }
  {
#line 410
  mntinfo_free(mi);
  }
#line 411
  return ((mount_info_t *)((void *)0));
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
mount_info_t **read_mountv(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  mount_info_t **mounts ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 419
  tmp = read_uint32(fd, & len);
  }
#line 419
  if (tmp < 0) {
#line 420
    return ((mount_info_t **)((void *)0));
  }
  {
#line 422
  tmp___0 = calloc((size_t )(len + 1U), sizeof(mount_info_t *));
#line 422
  mounts = (mount_info_t **)tmp___0;
  }
#line 423
  if (! mounts) {
#line 424
    return ((mount_info_t **)((void *)0));
  }
#line 426
  i = (uint32_t )0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (i < len)) {
#line 426
      goto while_break;
    }
    {
#line 427
    *(mounts + i) = read_mount(fd);
    }
#line 428
    if (! *(mounts + i)) {
      {
#line 429
      free_vec((void **)mounts, (free_func_t *)(& mntinfo_free));
      }
#line 430
      return ((mount_info_t **)((void *)0));
    }
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return (mounts);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_winsize(int fd , struct winsize  const  *ws ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 439
  tmp = write_uint16(fd, (uint16_t )ws->ws_row);
  }
#line 439
  if (tmp < 0) {
#line 441
    return (-1);
  } else {
    {
#line 439
    tmp___0 = write_uint16(fd, (uint16_t )ws->ws_col);
    }
#line 439
    if (tmp___0 < 0) {
#line 441
      return (-1);
    } else {
      {
#line 439
      tmp___1 = write_uint16(fd, (uint16_t )ws->ws_xpixel);
      }
#line 439
      if (tmp___1 < 0) {
#line 441
        return (-1);
      } else {
        {
#line 439
        tmp___2 = write_uint16(fd, (uint16_t )ws->ws_ypixel);
        }
#line 439
        if (tmp___2 < 0) {
#line 441
          return (-1);
        }
      }
    }
  }
#line 442
  return (0);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
struct winsize *read_winsize(int fd ) 
{ 
  uint16_t row ;
  uint16_t col ;
  uint16_t xpixel ;
  uint16_t ypixel ;
  struct winsize *ws ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 450
  tmp = read_uint16(fd, & row);
  }
#line 450
  if (tmp < 0) {
#line 452
    return ((struct winsize *)((void *)0));
  } else {
    {
#line 450
    tmp___0 = read_uint16(fd, & col);
    }
#line 450
    if (tmp___0 < 0) {
#line 452
      return ((struct winsize *)((void *)0));
    } else {
      {
#line 450
      tmp___1 = read_uint16(fd, & xpixel);
      }
#line 450
      if (tmp___1 < 0) {
#line 452
        return ((struct winsize *)((void *)0));
      } else {
        {
#line 450
        tmp___2 = read_uint16(fd, & ypixel);
        }
#line 450
        if (tmp___2 < 0) {
#line 452
          return ((struct winsize *)((void *)0));
        }
      }
    }
  }
  {
#line 454
  tmp___3 = malloc(sizeof(struct winsize ));
#line 454
  ws = (struct winsize *)tmp___3;
  }
#line 455
  if (! ws) {
#line 456
    return ((struct winsize *)((void *)0));
  }
#line 458
  ws->ws_row = row;
#line 459
  ws->ws_col = col;
#line 460
  ws->ws_xpixel = xpixel;
#line 461
  ws->ws_ypixel = ypixel;
#line 462
  return (ws);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_enum(int fd , int type ) 
{ 
  int tmp ;

  {
  {
#line 467
  tmp = write_uint16(fd, (uint16_t )type);
  }
#line 467
  return (tmp);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_enum(int fd ) 
{ 
  uint16_t type ;
  int tmp ;

  {
  {
#line 473
  tmp = read_uint16(fd, & type);
  }
#line 473
  if (tmp < 0) {
#line 474
    return (-1);
  }
#line 475
  return ((int )type);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_buf_packet(int fd , ptype_t type , size_t size , void *buf ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 480
  tmp = write_enum(fd, (int )type);
  }
#line 480
  if (tmp < 0) {
#line 481
    return (-1);
  } else {
    {
#line 480
    tmp___0 = write_uint32(fd, (uint32_t )size);
    }
#line 480
    if (tmp___0 < 0) {
#line 481
      return (-1);
    } else {
      {
#line 480
      tmp___1 = write_buf(fd, buf, size);
      }
#line 480
      if (tmp___1 < 0) {
#line 481
        return (-1);
      }
    }
  }
#line 482
  return (0);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_str_packet(int fd , ptype_t type , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 487
  tmp = write_enum(fd, (int )type);
  }
#line 487
  if (tmp < 0) {
#line 488
    return (-1);
  } else {
    {
#line 487
    tmp___0 = write_str(fd, (char const   *)((char *)str));
    }
#line 487
    if (tmp___0 < 0) {
#line 488
      return (-1);
    }
  }
#line 489
  return (0);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16_packet(int fd , ptype_t type , uint16_t val ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 494
  tmp = write_enum(fd, (int )type);
  }
#line 494
  if (tmp < 0) {
#line 495
    return (-1);
  } else {
    {
#line 494
    tmp___0 = write_uint16(fd, val);
    }
#line 494
    if (tmp___0 < 0) {
#line 495
      return (-1);
    }
  }
#line 496
  return (0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int send_version(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 506
  tmp = write_enum(fd, 11);
  }
#line 506
  if (tmp < 0) {
#line 507
    return (-1);
  } else {
    {
#line 506
    tmp___0 = write_uint16(fd, (uint16_t )7);
    }
#line 506
    if (tmp___0 < 0) {
#line 507
      return (-1);
    }
  }
#line 508
  return (0);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int get_version(int fd ) 
{ 
  uint16_t ver ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 519
  tmp___0 = read_enum(fd);
  }
#line 519
  if (tmp___0 != 11) {
    {
#line 520
    tmp = __errno_location();
#line 520
    *tmp = 0;
    }
#line 521
    return (-1);
  }
  {
#line 523
  tmp___1 = read_uint16(fd, & ver);
  }
#line 523
  if (tmp___1 < 0) {
#line 524
    return (-1);
  }
#line 525
  return ((int )ver);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
void buf_free(buffer_t *buf ) ;
#line 27
void buf_set_eof(buffer_t *buf ) ;
#line 28
size_t buf_size(buffer_t *buf ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
buffer_t *buf_alloc(void) 
{ 
  buffer_t *buf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 25
  tmp = calloc((size_t )1, sizeof(buffer_t ));
#line 25
  buf = (buffer_t *)tmp;
  }
#line 26
  if (buf) {
    {
#line 27
    buf->mem_size = (size_t )4096;
#line 28
    tmp___0 = malloc((size_t )4096);
#line 28
    buf->mem = (uint8_t *)tmp___0;
    }
#line 29
    if (! buf->mem) {
      {
#line 30
      free((void *)buf);
#line 31
      buf = (buffer_t *)0;
      }
    }
  }
#line 34
  return (buf);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
void buf_free(buffer_t *buf ) 
{ 


  {
#line 43
  if (buf->mem) {
    {
#line 44
    free((void *)buf->mem);
    }
  }
  {
#line 46
  free((void *)buf);
  }
#line 47
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
void buf_set_eof(buffer_t *buf ) 
{ 


  {
#line 56
  buf->eof = (bool_t )1;
#line 57
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
size_t buf_size(buffer_t *buf ) 
{ 


  {
#line 66
  return (buf->end - buf->start);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
bool_t buf_is_empty(buffer_t *buf ) 
{ 
  int tmp ;

  {
#line 76
  if (buf->end == 0UL) {
#line 76
    if (buf->eof == 0U) {
#line 76
      tmp = 1;
    } else {
#line 76
      tmp = 0;
    }
  } else {
#line 76
    tmp = 0;
  }
#line 76
  return ((bool_t )tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
ssize_t buf_read_in(buffer_t *buf , int fd , size_t len ) 
{ 
  size_t size ;
  uint8_t *mem ;
  void *tmp ;
  int tmp___0 ;

  {
#line 95
  size = buf->end + len;
#line 96
  if (size > buf->mem_size) {
    {
#line 101
    tmp = malloc(size);
#line 101
    mem = (uint8_t *)tmp;
    }
#line 102
    if (! mem) {
#line 103
      return ((ssize_t )-1);
    }
    {
#line 106
    memcpy((void */* __restrict  */)mem, (void const   */* __restrict  */)buf->mem,
           buf->mem_size);
#line 107
    free((void *)buf->mem);
#line 109
    buf->mem_size = size;
#line 110
    buf->mem = mem;
    }
  }
  {
#line 113
  tmp___0 = read_buf(fd, (void *)(buf->mem + buf->end), len);
  }
#line 113
  if (tmp___0 < 0) {
#line 114
    return ((ssize_t )-1);
  }
#line 117
  buf->end += len;
#line 119
  return ((ssize_t )len);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
ssize_t buf_write_out(buffer_t *buf , int *fd ) 
{ 
  size_t size ;
  ssize_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 132
  len = (ssize_t )0;
#line 134
  size = buf_size(buf);
  }
#line 135
  if (size) {
    {
#line 138
    len = write_ni(*fd, (void *)(buf->mem + buf->start), size);
    }
#line 139
    if (len < 0L) {
      {
#line 140
      tmp = __errno_location();
      }
#line 140
      if (*tmp == 11) {
#line 141
        len = (ssize_t )0;
      } else {
        {
#line 143
        close(*fd);
#line 144
        *fd = -1;
        }
#line 146
        return ((ssize_t )-1);
      }
    }
    {
#line 150
    buf->start += (size_t )len;
#line 152
    size = buf_size(buf);
    }
#line 153
    if (size == 0UL) {
#line 154
      buf->start = (size_t )0;
#line 155
      buf->end = (size_t )0;
    }
  }
#line 159
  if (size == 0UL) {
#line 159
    if (buf->eof) {
      {
#line 160
      close(*fd);
#line 161
      *fd = -1;
#line 162
      tmp___0 = __errno_location();
#line 162
      *tmp___0 = 0;
#line 165
      buf->eof = (bool_t )0;
      }
    }
  }
#line 168
  return (len);
}
}
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 677 "/usr/include/netdb.h"
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 157 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
FILE *debug_file ;
#line 159
void set_debug_name(char const   *name ) ;
#line 160
void print_debug(char const   *msg  , ...) ;
#line 161
void send_error(handler_t *data , char const   *msg  , ...) ;
#line 163
int daemonize(int listenfd ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.h"
int fakeroot_relay(handler_t *data ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 983
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getdtablesize)(void) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 41 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) login_tty)(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 34
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
FILE *debug_file  =    (FILE *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *debug_filename  =    (char *)((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int debug_verbose_flag  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int daemon_pid  =    -1;
#line 63 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *port  =    (char *)"1202";
#line 64 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static bool_t local_only  =    (bool_t )0;
#line 65 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static bool_t sandbox  =    (bool_t )1;
#line 66 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static bool_t allow_root  =    (bool_t )0;
#line 67 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int mount_expiration  =    900;
#line 68 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *mount_cmd  =    (char *)"/bin/mount";
#line 69 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *umount_cmd  =    (char *)"/bin/umount";
#line 70 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *bind_opt  =    (char *)"--bind";
#line 71 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *fusermount_cmd  =    (char *)"/usr/bin/fusermount";
#line 72 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *sshfs_cmd  =    (char *)"/usr/bin/sshfs";
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static struct __anonstruct_all_mounts_87 all_mounts  =    {(mount_t *)((void *)0), (mount_t *)((void *)0)};
#line 84 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static pid_mounts_t *pid_mounts  =    (pid_mounts_t *)((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static struct __anonstruct_debug_info_88 debug_info  =    {-1, (char const   *)((void *)0)};
#line 94 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void set_debug_name(char const   *name ) 
{ 


  {
  {
#line 96
  debug_info.pid = getpid();
#line 97
  debug_info.name = name;
  }
#line 98
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_debug_prefix(void) 
{ 
  struct timeval tv ;
  struct tm *t ;
  char const   *domain ;
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 107
  domain = "";
#line 109
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 110
  t = gmtime((time_t const   *)(& tv.tv_sec));
#line 112
  tmp = getpid();
  }
#line 112
  if (debug_info.pid == tmp) {
#line 113
    domain = debug_info.name;
  }
  {
#line 115
  tmp___0 = getpid();
#line 115
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"%02d-%02d-%04d %02d:%02d:%02d.%03ld %5d %7s ",
          t->tm_mday, t->tm_mon + 1, 1900 + t->tm_year, t->tm_hour, t->tm_min, t->tm_sec,
          tv.tv_usec / 1000L, tmp___0, domain);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void open_debug_log(void) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 122
  if (debug_file) {
#line 123
    if (debug_file) {
      {
#line 123
      print_debug("Debugging is already enabled");
      }
    }
#line 124
    return;
  }
#line 127
  if (! debug_filename) {
    {
#line 128
    tmp = strlen("/tmp/sbrshd-%s.log");
#line 128
    tmp___0 = malloc(tmp + 5UL);
#line 128
    debug_filename = (char *)tmp___0;
    }
#line 129
    if (! debug_filename) {
      {
#line 130
      oom_error();
      }
#line 131
      return;
    }
    {
#line 134
    sprintf((char */* __restrict  */)debug_filename, (char const   */* __restrict  */)"/tmp/sbrshd-%s.log",
            port);
    }
  }
  {
#line 137
  debug_file = fopen((char const   */* __restrict  */)debug_filename, (char const   */* __restrict  */)"a");
  }
#line 138
  if (! debug_file) {
    {
#line 139
    error("Can\'t append to %s", debug_filename);
    }
#line 140
    return;
  }
#line 143
  if (debug_file) {
    {
#line 143
    print_debug("Debugging enabled");
    }
  }
#line 144
  if (debug_file) {
    {
#line 144
    print_debug("sbrshd version %d%s", 7, ".6");
    }
  }
#line 145
  if (debug_file) {
    {
#line 145
    print_debug("Port: %s", port);
    }
  }
#line 146
  if (debug_file) {
#line 146
    if (local_only) {
#line 146
      tmp___1 = "yes";
    } else {
#line 146
      tmp___1 = "no";
    }
    {
#line 146
    print_debug("Local only: %s", tmp___1);
    }
  }
#line 147
  if (debug_file) {
#line 147
    if (sandbox) {
#line 147
      tmp___2 = "yes";
    } else {
#line 147
      tmp___2 = "no";
    }
    {
#line 147
    print_debug("Sandbox: %s", tmp___2);
    }
  }
#line 148
  if (debug_file) {
#line 148
    if (allow_root) {
#line 148
      tmp___3 = "yes";
    } else {
#line 148
      tmp___3 = "no";
    }
    {
#line 148
    print_debug("Allow root: %s", tmp___3);
    }
  }
#line 150
  if (mount_expiration > 0) {
#line 151
    if (debug_file) {
      {
#line 151
      print_debug("Mount expiration: %d seconds", mount_expiration);
      }
    }
  } else
#line 152
  if (mount_expiration == 0) {
#line 153
    if (debug_file) {
      {
#line 153
      print_debug("Mount expiration: immediate");
      }
    }
  } else
#line 155
  if (debug_file) {
    {
#line 155
    print_debug("Mount expiration: never");
    }
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void close_debug_log(void) 
{ 


  {
#line 161
  if (debug_file) {
#line 162
    if (debug_file) {
      {
#line 162
      print_debug("Debugging disabled");
      }
    }
    {
#line 164
    fclose(debug_file);
#line 165
    debug_file = (FILE *)((void *)0);
    }
  }
#line 167
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void print_debug(char const   *msg  , ...) 
{ 
  va_list arg ;

  {
  {
#line 176
  print_debug_prefix();
#line 178
  __builtin_va_start(arg, msg);
#line 179
  vfprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)msg,
           arg);
#line 180
  __builtin_va_end(arg);
#line 182
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"\n");
#line 183
  fflush(debug_file);
  }
#line 184
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_debug_vector(char const   *msg , char **vec ) 
{ 
  char **tmp ;

  {
  {
#line 191
  print_debug_prefix();
#line 192
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"%s",
          msg);
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! *vec) {
#line 194
      goto while_break;
    }
    {
#line 195
    tmp = vec;
#line 195
    vec ++;
#line 195
    fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)" %s",
            *tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"\n");
#line 198
  fflush(debug_file);
  }
#line 199
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_error(handler_t *data , char const   *progname___0 , char const   *msg ,
                        va_list arg , int priority ) 
{ 
  char str[1024] ;
  unsigned int tmp ;
  char *err ;
  size_t len ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;

  {
#line 208
  str[0] = (char )'\000';
#line 208
  tmp = 1U;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (tmp >= 1024U) {
#line 208
      goto while_break;
    }
#line 208
    str[tmp] = (char)0;
#line 208
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  vsnprintf((char */* __restrict  */)(str), sizeof(str) - 1UL, (char const   */* __restrict  */)msg,
            arg);
#line 212
  len = strlen((char const   *)(str));
#line 214
  tmp___0 = __errno_location();
#line 214
  err = strerror(*tmp___0);
#line 215
  tmp___1 = __errno_location();
  }
#line 215
  if (*tmp___1) {
#line 215
    if (err) {
      {
#line 215
      tmp___2 = strlen((char const   *)err);
      }
#line 215
      if ((len + tmp___2) + 3UL < sizeof(str)) {
        {
#line 216
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)" (");
#line 217
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)err);
#line 218
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)")");
#line 220
        len = strlen((char const   *)(str));
        }
      }
    }
  }
#line 223
  if (progname___0) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            progname___0, str);
    }
  } else {
    {
#line 226
    syslog(priority, "%s", str);
    }
#line 227
    if (debug_file) {
#line 227
      if (priority == 4) {
#line 227
        tmp___3 = "Warning: %s";
      } else {
#line 227
        tmp___3 = "Error: %s";
      }
      {
#line 227
      print_debug(tmp___3, str);
      }
    }
  }
#line 230
  if (data) {
    {
#line 231
    write_str_packet(data->sd, (ptype_t )17, (char const   *)(str));
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void send_error(handler_t *data , char const   *msg  , ...) 
{ 
  va_list arg ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 238
  if (! msg) {
    {
#line 239
    tmp = __errno_location();
#line 239
    tmp___0 = strerror(*tmp);
#line 239
    msg = (char const   *)tmp___0;
#line 240
    tmp___1 = __errno_location();
#line 240
    *tmp___1 = 0;
    }
  }
  {
#line 243
  __builtin_va_start(arg, msg);
#line 244
  print_error(data, (char const   *)((void *)0), msg, arg, 3);
#line 245
  __builtin_va_end(arg);
  }
#line 246
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void error_err(char const   *progname___0 , char const   *msg  , ...) 
{ 
  va_list arg ;

  {
  {
#line 255
  __builtin_va_start(arg, msg);
#line 256
  print_error((handler_t *)((void *)0), progname___0, msg, arg, 3);
#line 257
  __builtin_va_end(arg);
  }
#line 258
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void warn(char const   *msg  , ...) 
{ 
  va_list arg ;
  int *tmp ;

  {
  {
#line 279
  tmp = __errno_location();
#line 279
  *tmp = 0;
#line 281
  __builtin_va_start(arg, msg);
#line 282
  print_error((handler_t *)((void *)0), (char const   *)((void *)0), msg, arg, 4);
#line 283
  __builtin_va_end(arg);
  }
#line 284
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void flush(handler_t *data , char *buf , size_t *lenp ) 
{ 
  int *tmp ;

  {
#line 291
  if (*lenp > 0UL) {
    {
#line 292
    *(buf + *lenp) = (char )'\000';
#line 293
    *lenp = (size_t )0;
#line 295
    tmp = __errno_location();
#line 295
    *tmp = 0;
#line 296
    send_error(data, (char const   *)buf);
    }
  }
#line 298
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int execute(handler_t *data , char **argv , int uid , int gid ) 
{ 
  pid_t pid ;
  int status ;
  int err[2] ;
  size_t pos ;
  char line[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t len ;
  char c ;
  int *tmp___4 ;
  size_t tmp___5 ;
  __pid_t tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  union __anonunion_90 __constr_expr_1 ;

  {
  {
#line 308
  pos = (size_t )0;
#line 311
  tmp = pipe((int *)(err));
  }
#line 311
  if (tmp < 0) {
    {
#line 312
    send_error(data, "Can\'t create pipe");
    }
#line 313
    return (-1);
  }
  {
#line 316
  pid = fork();
  }
#line 317
  if (pid < 0) {
    {
#line 318
    send_error(data, "Can\'t fork");
    }
#line 319
    return (-1);
  }
#line 322
  if (pid == 0) {
    {
#line 325
    set_debug_name("EXECUTE");
    }
#line 327
    if (gid >= 0) {
#line 328
      if (debug_file) {
        {
#line 328
        print_debug("Changing to group ID %d", gid);
        }
      }
      {
#line 330
      tmp___0 = setgid((__gid_t )gid);
      }
#line 330
      if (tmp___0 < 0) {
        {
#line 331
        send_error(data, "Can\'t change group ID to %d", gid);
#line 332
        exit(1);
        }
      }
    }
#line 336
    if (uid >= 0) {
#line 337
      if (debug_file) {
        {
#line 337
        print_debug("Changing to user ID %d", uid);
        }
      }
      {
#line 339
      tmp___1 = setuid((__uid_t )uid);
      }
#line 339
      if (tmp___1 < 0) {
        {
#line 340
        send_error(data, "Can\'t change user ID to %d", uid);
#line 341
        exit(1);
        }
      }
    }
    {
#line 345
    tmp___2 = dup2(err[1], 1);
    }
#line 345
    if (tmp___2 != 1) {
      {
#line 346
      send_error(data, "Can\'t duplicate pipe as stdout");
#line 347
      exit(1);
      }
    }
    {
#line 349
    tmp___3 = dup2(err[1], 2);
    }
#line 349
    if (tmp___3 != 2) {
      {
#line 350
      send_error(data, "Can\'t duplicate pipe as stderr");
#line 351
      exit(1);
      }
    }
    {
#line 353
    close(err[0]);
#line 355
    execv((char const   *)*(argv + 0), (char * const  *)argv);
#line 357
    send_error(data, "Can\'t execute command: %s", *(argv + 0));
#line 358
    exit(1);
    }
  }
  {
#line 363
  close(err[1]);
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    c = (char )'\000';
#line 369
    len = read(err[0], (void *)(& c), (size_t )1);
    }
#line 371
    if ((int )c == 0) {
#line 371
      if (pos == 0UL) {
#line 372
        goto while_break;
      }
    }
#line 374
    if (len < 0L) {
      {
#line 374
      tmp___4 = __errno_location();
      }
#line 374
      if (*tmp___4 == 4) {
#line 375
        goto while_continue;
      }
    }
#line 377
    if (len <= 0L) {
      {
#line 378
      flush(data, line, & pos);
      }
#line 379
      goto while_break;
    }
#line 382
    if ((int )c == 10) {
      {
#line 383
      flush(data, line, & pos);
      }
#line 384
      goto while_continue;
    } else
#line 382
    if ((int )c == 0) {
      {
#line 383
      flush(data, line, & pos);
      }
#line 384
      goto while_continue;
    }
#line 387
    if (pos == sizeof(line)) {
      {
#line 388
      flush(data, line, & pos);
      }
    }
#line 390
    tmp___5 = pos;
#line 390
    pos ++;
#line 390
    line[tmp___5] = c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  close(err[0]);
#line 395
  tmp___6 = waitpid(pid, & status, 0);
  }
#line 395
  if (tmp___6 != pid) {
#line 396
    return (-1);
  }
#line 398
  if (status < 0) {
#line 399
    return (-1);
  }
  {
#line 401
  tmp___7 = __errno_location();
#line 401
  *tmp___7 = 0;
#line 402
  __constr_expr_1.__in = status;
  }
#line 402
  if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
#line 402
    tmp___8 = -1;
  } else {
#line 402
    tmp___8 = 0;
  }
#line 402
  return (tmp___8);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void check_for_busybox(char const   *progname___0 ) 
{ 
  char mount_buf[4096] ;
  char *real_mount ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 409
  real_mount = realpath((char const   */* __restrict  */)mount_cmd, (char */* __restrict  */)(mount_buf));
  }
#line 410
  if (! real_mount) {
    {
#line 411
    error_err(progname___0, "Can\'t get real path of %s", mount_cmd);
#line 412
    exit(1);
    }
  }
  {
#line 415
  tmp = __xpg_basename(real_mount);
#line 415
  tmp___0 = strstr((char const   *)tmp, "busybox");
  }
#line 415
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 416
    if (debug_file) {
      {
#line 416
      print_debug("%s is Busybox", mount_cmd);
      }
    }
#line 417
    bind_opt = (char *)"-obind";
  }
#line 419
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char **read_config(char const   *filename ) 
{ 
  int count ;
  int i ;
  int slot ;
  char **lines ;
  FILE *file ;
  void *tmp ;
  int *tmp___0 ;
  int c ;
  int tmp___1 ;
  void *tmp___2 ;
  int pos ;
  int len ;
  char *line ;
  char *ptr ;
  long tmp___3 ;
  int c___0 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 430
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 431
  if (! file) {
    {
#line 432
    tmp___0 = __errno_location();
    }
#line 432
    if (*tmp___0 == 2) {
      {
#line 433
      tmp = calloc((size_t )1, sizeof(char *));
      }
#line 433
      return ((char **)tmp);
    }
    {
#line 435
    error_err(filename, "cannot open for reading");
    }
#line 436
    return ((char **)((void *)0));
  }
#line 439
  count = 1;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 441
    tmp___1 = fgetc(file);
#line 441
    c = tmp___1;
    }
#line 442
    if (c == -1) {
#line 443
      goto while_break;
    }
#line 444
    if (c == 10) {
#line 445
      count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  rewind(file);
#line 450
  tmp___2 = calloc((size_t )(count + 1), sizeof(char *));
#line 450
  lines = (char **)tmp___2;
  }
#line 451
  if (! lines) {
    {
#line 452
    oom_error();
    }
#line 453
    goto _out;
  }
#line 456
  i = 0;
#line 456
  slot = 0;
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! (i < count)) {
#line 456
      goto while_break___0;
    }
    {
#line 460
    tmp___3 = ftell(file);
#line 460
    pos = (int )tmp___3;
    }
#line 461
    if (pos < 0) {
      {
#line 462
      error_err(filename, "tell");
      }
#line 463
      goto _err;
    }
#line 466
    len = 0;
    {
#line 467
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 468
      tmp___4 = fgetc(file);
#line 468
      c___0 = tmp___4;
      }
#line 469
      if (c___0 == -1) {
#line 470
        goto while_break___1;
      }
#line 471
      len ++;
#line 472
      if (c___0 == 10) {
#line 473
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 476
    tmp___5 = fseek(file, (long )pos, 0);
    }
#line 476
    if (tmp___5 < 0) {
      {
#line 477
      error_err(filename, "seek");
      }
#line 478
      goto _err;
    }
    {
#line 481
    tmp___6 = calloc((size_t )(len + 1), sizeof(char ));
#line 481
    line = (char *)tmp___6;
    }
#line 482
    if (! line) {
      {
#line 483
      oom_error();
      }
#line 484
      goto _err;
    }
    {
#line 487
    tmp___7 = fread((void */* __restrict  */)line, sizeof(char ), (size_t )len, (FILE */* __restrict  */)file);
    }
#line 487
    if (tmp___7 != (size_t )len) {
      {
#line 488
      error_err(filename, "read");
      }
#line 489
      goto _err;
    }
#line 492
    if (len == 0) {
#line 493
      goto __Cont;
    }
#line 495
    if ((int )*(line + (len - 1)) == 10) {
#line 496
      *(line + (len - 1)) = (char )'\000';
    }
    {
#line 498
    ptr = strchr((char const   *)line, '#');
    }
#line 499
    if (ptr) {
#line 500
      *ptr = (char )'\000';
    }
    {
#line 502
    tmp___9 = strlen((char const   *)line);
    }
#line 502
    if (tmp___9 > 0UL) {
#line 503
      tmp___8 = slot;
#line 503
      slot ++;
#line 503
      *(lines + tmp___8) = line;
    }
    __Cont: /* CIL Label */ 
#line 456
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  _out: 
  {
#line 507
  fclose(file);
  }
#line 508
  return (lines);
  _err: 
  {
#line 511
  free_vec((void **)lines, (free_func_t *)((void *)0));
  }
#line 512
  goto _out;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int write_config(char const   *filename , char **lines ) 
{ 
  FILE *file ;
  int i ;
  int retval ;
  char *line ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 521
  retval = -1;
#line 523
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 524
  if (! file) {
    {
#line 525
    error_err(filename, "cannot open for writing");
    }
#line 526
    return (-1);
  }
#line 529
  i = 0;
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! *(lines + i)) {
#line 529
      goto while_break;
    }
    {
#line 533
    line = *(lines + i);
#line 534
    tmp = strlen((char const   *)line);
#line 534
    len = (int )tmp;
#line 536
    tmp___0 = fwrite((void const   */* __restrict  */)line, sizeof(char ), (size_t )len,
                     (FILE */* __restrict  */)file);
    }
#line 536
    if (tmp___0 != (size_t )len) {
      {
#line 537
      error_err(filename, "write");
      }
#line 538
      goto _out;
    }
#line 541
    if (len == 0) {
#line 541
      goto _L;
    } else
#line 541
    if ((int )*(line + (len - 1)) != 10) {
      _L: /* CIL Label */ 
      {
#line 542
      tmp___1 = fputc('\n', file);
      }
#line 542
      if (tmp___1 == -1) {
        {
#line 543
        error_err(filename, "write");
        }
#line 544
        goto _out;
      }
    }
#line 529
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  retval = 0;
  _out: 
  {
#line 551
  fclose(file);
  }
#line 552
  return (retval);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int add_to_config(char *host ) 
{ 
  char **lines ;
  int i ;
  int retval ;
  bool_t found ;
  char *line ;
  char *ptr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int oldlineslen ;
  char **vec ;
  char *line___0 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 561
  retval = 0;
#line 562
  found = (bool_t )0;
#line 564
  lines = read_config("/etc/sbrshd.conf");
  }
#line 565
  if ((unsigned long )lines == (unsigned long )((void *)0)) {
#line 566
    return (-1);
  }
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! *(lines + i)) {
#line 568
      goto while_break;
    }
    {
#line 569
    line = *(lines + i);
#line 570
    tmp = find_space((char const   *)line);
#line 570
    ptr = tmp;
#line 572
    tmp___0 = strlen((char const   *)host);
    }
#line 572
    if (tmp___0 == (size_t )(ptr - line)) {
      {
#line 572
      tmp___1 = strncmp((char const   *)line, (char const   *)host, (size_t )(ptr - line));
      }
#line 572
      if (tmp___1 == 0) {
#line 574
        found = (bool_t )1;
#line 575
        goto while_break;
      }
    }
#line 568
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  if (! found) {
    {
#line 583
    tmp___2 = calc_vec_len((void **)lines);
#line 583
    oldlineslen = (int )tmp___2;
#line 585
    tmp___3 = calloc(sizeof(char *), (size_t )(oldlineslen + 2));
#line 585
    vec = (char **)tmp___3;
    }
#line 586
    if (! vec) {
      {
#line 587
      oom_error();
#line 588
      retval = -1;
      }
#line 589
      goto _out;
    }
    {
#line 592
    memcpy((void */* __restrict  */)vec, (void const   */* __restrict  */)lines, sizeof(char *) * (unsigned long )oldlineslen);
#line 594
    free((void *)lines);
#line 595
    lines = vec;
#line 597
    line___0 = strdup((char const   *)host);
    }
#line 598
    if (! line___0) {
      {
#line 599
      oom_error();
#line 600
      retval = -1;
      }
#line 601
      goto _out;
    }
    {
#line 604
    *(lines + oldlineslen) = line___0;
#line 606
    retval = write_config("/etc/sbrshd.conf", lines);
    }
  }
  _out: 
  {
#line 610
  free_vec((void **)lines, (free_func_t *)((void *)0));
  }
#line 611
  return (retval);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static bool_t find_host(handler_t *data , char const   *filename ) 
{ 
  bool_t found ;
  char **lines ;
  int i ;
  char *line ;
  char *ptr ;
  char *p ;
  char *star ;
  int len ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  int pos ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 622
  found = (bool_t )0;
#line 626
  lines = read_config("/etc/sbrshd.conf");
  }
#line 627
  if ((unsigned long )lines == (unsigned long )((void *)0)) {
#line 628
    return ((bool_t )0);
  }
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! *(lines + i)) {
#line 630
      goto while_break;
    }
    {
#line 634
    line = *(lines + i);
#line 635
    ptr = find_space((char const   *)line);
#line 637
    p = ptr;
    }
    {
#line 637
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 637
      if (! *p) {
#line 637
        goto while_break___0;
      }
      {
#line 638
      tmp___0 = __ctype_b_loc();
      }
#line 638
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
        {
#line 639
        tmp = __errno_location();
#line 639
        *tmp = 0;
#line 640
        error("Malformed line in %s: \"%s\" (old config file format?)", "/etc/sbrshd.conf",
              line);
        }
#line 642
        return ((bool_t )0);
      }
#line 637
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 645
    *ptr = (char )'\000';
#line 646
    len = (int )(ptr - line);
#line 648
    star = strchr((char const   *)line, '*');
    }
#line 649
    if (star) {
#line 650
      pos = (int )(star - line);
#line 652
      if (pos != len - 1) {
        {
#line 653
        tmp___1 = __errno_location();
#line 653
        *tmp___1 = 0;
#line 654
        error("Malformed line in %s: %s", "/etc/sbrshd.conf", line);
        }
#line 655
        goto __Cont;
      }
#line 658
      len --;
    }
#line 661
    if (! star) {
      {
#line 661
      tmp___2 = strlen((char const   *)(data->host));
      }
#line 661
      if (tmp___2 != (size_t )len) {
#line 662
        goto __Cont;
      }
    }
    {
#line 664
    tmp___3 = strncmp((char const   *)line, (char const   *)(data->host), (size_t )len);
    }
#line 664
    if (tmp___3 == 0) {
#line 665
      if (debug_file) {
        {
#line 665
        print_debug("Found matching line: %s", line);
        }
      }
#line 666
      found = (bool_t )1;
#line 667
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 671
  free_vec((void **)lines, (free_func_t *)((void *)0));
  }
#line 673
  return (found);
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int mkdirs(char const   *path ) 
{ 
  char *parent ;
  char *p ;
  int rc ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 682
  rc = -1;
#line 684
  tmp = mkdir(path, (__mode_t )488);
  }
#line 684
  if (tmp == 0) {
#line 685
    return (0);
  } else {
    {
#line 684
    tmp___0 = __errno_location();
    }
#line 684
    if (*tmp___0 == 17) {
#line 685
      return (0);
    }
  }
  {
#line 687
  tmp___1 = __errno_location();
  }
#line 687
  if (*tmp___1 != 2) {
#line 688
    return (-1);
  }
  {
#line 690
  parent = strdup(path);
  }
#line 691
  if (! parent) {
#line 692
    return (-1);
  }
  {
#line 694
  p = strrchr((char const   *)parent, '/');
  }
#line 695
  if (p) {
#line 695
    if ((unsigned long )parent != (unsigned long )p) {
#line 696
      *p = (char )'\000';
#line 697
      rc = 0;
    }
  }
#line 700
  if (rc == 0) {
    {
#line 701
    rc = mkdirs((char const   *)parent);
    }
  }
  {
#line 703
  free((void *)parent);
  }
#line 705
  if (rc == 0) {
    {
#line 705
    tmp___2 = mkdir(path, (__mode_t )488);
    }
#line 705
    if (tmp___2 < 0) {
      {
#line 705
      tmp___3 = __errno_location();
      }
#line 705
      if (*tmp___3 != 17) {
#line 706
        rc = -1;
      }
    }
  }
#line 708
  return (rc);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void mnt_free(mount_t *m ) 
{ 


  {
#line 716
  if (m->info.opts) {
    {
#line 717
    free((void *)m->info.opts);
    }
  }
#line 719
  if (m->info.device) {
    {
#line 720
    free((void *)m->info.device);
    }
  }
#line 722
  if (m->info.point) {
    {
#line 723
    free((void *)m->info.point);
    }
  }
  {
#line 725
  free((void *)m);
  }
#line 726
  return;
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static mount_t *mnt_list_find(char const   *point ) 
{ 
  mount_t *mnt ;
  int tmp ;

  {
#line 736
  mnt = all_mounts.head;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! mnt) {
#line 736
      goto while_break;
    }
    {
#line 737
    tmp = strcmp((char const   *)mnt->info.point, point);
    }
#line 737
    if (tmp == 0) {
#line 738
      goto while_break;
    }
#line 736
    mnt = mnt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  return (mnt);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void mnt_list_add(mount_t *mnt ) 
{ 
  mount_t *prev ;
  mount_t *next ;
  int tmp ;

  {
#line 751
  prev = (mount_t *)((void *)0);
#line 752
  next = all_mounts.head;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 753
    if (! next) {
#line 753
      goto while_break;
    }
    {
#line 754
    tmp = strcmp((char const   *)next->info.point, (char const   *)mnt->info.point);
    }
#line 754
    if (tmp > 0) {
#line 755
      goto while_break;
    }
#line 757
    prev = next;
#line 758
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  mnt->prev = prev;
#line 762
  mnt->next = next;
#line 764
  if (prev) {
#line 765
    prev->next = mnt;
  } else {
#line 767
    all_mounts.head = mnt;
  }
#line 769
  if (next) {
#line 770
    next->prev = mnt;
  } else {
#line 772
    all_mounts.tail = mnt;
  }
#line 773
  return;
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void mnt_list_del(mount_t *mnt ) 
{ 


  {
#line 780
  if (mnt->prev) {
#line 781
    (mnt->prev)->next = mnt->next;
  } else {
#line 783
    all_mounts.head = mnt->next;
  }
#line 785
  if (mnt->next) {
#line 786
    (mnt->next)->prev = mnt->prev;
  } else {
#line 788
    all_mounts.tail = mnt->prev;
  }
  {
#line 790
  mnt_free(mnt);
  }
#line 791
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int do_mount(handler_t *data , mount_info_t const   *mi ) 
{ 
  char *argv[8] ;
  int uid ;
  int gid ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 799
  uid = -1;
#line 800
  gid = -1;
#line 802
  memset((void *)(argv), 0, sizeof(argv));
#line 804
  argv[0] = mount_cmd;
#line 805
  argv[1] = (char *)mi->device;
#line 806
  argv[2] = (char *)mi->point;
  }
  {
#line 809
  if ((unsigned int const   )mi->type == 1U) {
#line 809
    goto case_1;
  }
#line 822
  if ((unsigned int const   )mi->type == 2U) {
#line 822
    goto case_2;
  }
#line 831
  if ((unsigned int const   )mi->type == 3U) {
#line 831
    goto case_3;
  }
#line 853
  goto switch_default;
  case_1: /* CIL Label */ 
#line 810
  argv[3] = (char *)"-t";
#line 811
  argv[4] = (char *)"nfs";
#line 812
  if (mi->opts) {
#line 812
    argv[5] = (char *)"-o";
  } else {
#line 812
    argv[5] = (char *)((void *)0);
  }
#line 813
  argv[6] = (char *)mi->opts;
#line 815
  if (mi->opts) {
#line 816
    if (debug_file) {
      {
#line 816
      print_debug("Executing: %s %s %s -t nfs -o %s", argv[0], argv[1], argv[2], argv[6]);
      }
    }
  } else
#line 818
  if (debug_file) {
    {
#line 818
    print_debug("Executing: %s %s %s -t nfs", argv[0], argv[1], argv[2]);
    }
  }
#line 820
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 823
  split_string(bind_opt, & argv[3], & argv[4], & argv[5], & argv[6], (void *)0);
  }
#line 825
  if (debug_file) {
#line 825
    if (argv[6]) {
#line 825
      tmp = (char const   *)argv[6];
    } else {
#line 825
      tmp = "";
    }
#line 825
    if (argv[5]) {
#line 825
      tmp___0 = (char const   *)argv[5];
    } else {
#line 825
      tmp___0 = "";
    }
#line 825
    if (argv[4]) {
#line 825
      tmp___1 = (char const   *)argv[4];
    } else {
#line 825
      tmp___1 = "";
    }
#line 825
    if (argv[3]) {
#line 825
      tmp___2 = (char const   *)argv[3];
    } else {
#line 825
      tmp___2 = "";
    }
    {
#line 825
    print_debug("Executing: %s %s %s %s %s %s %s", argv[0], argv[1], argv[2], tmp___2,
                tmp___1, tmp___0, tmp);
    }
  }
#line 829
  goto switch_break;
  case_3: /* CIL Label */ 
#line 832
  argv[0] = sshfs_cmd;
#line 834
  if (mi->opts) {
#line 834
    argv[3] = (char *)"-o";
  } else {
#line 834
    argv[3] = (char *)((void *)0);
  }
#line 835
  argv[4] = (char *)mi->opts;
#line 837
  if (mi->opts) {
#line 838
    if (debug_file) {
      {
#line 838
      print_debug("Executing: %s %s %s -o %s", argv[0], argv[1], argv[2], argv[4]);
      }
    }
  } else
#line 840
  if (debug_file) {
    {
#line 840
    print_debug("Executing: %s %s %s", argv[0], argv[1], argv[2]);
    }
  }
#line 843
  if (! data->param.ids) {
    {
#line 844
    tmp___3 = __errno_location();
#line 844
    *tmp___3 = 0;
#line 845
    send_error(data, "Valid IDS parameter required");
    }
#line 846
    return (-1);
  } else
#line 843
  if ((data->param.ids)->len < 2U) {
    {
#line 844
    tmp___3 = __errno_location();
#line 844
    *tmp___3 = 0;
#line 845
    send_error(data, "Valid IDS parameter required");
    }
#line 846
    return (-1);
  }
#line 849
  uid = (int )*((data->param.ids)->vec + 0);
#line 850
  gid = (int )*((data->param.ids)->vec + 1);
#line 851
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 854
  tmp___4 = __errno_location();
#line 854
  *tmp___4 = 22;
  }
#line 855
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 858
  tmp___5 = execute(data, argv, uid, gid);
  }
#line 858
  return (tmp___5);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int do_unmount(handler_t *data , mount_info_t const   *mi ) 
{ 
  char *argv[4] ;
  int tmp ;

  {
#line 863
  argv[0] = umount_cmd;
#line 863
  argv[1] = (char *)mi->point;
#line 863
  argv[2] = (char *)((void *)0);
#line 863
  argv[3] = (char *)((void *)0);
#line 866
  if ((unsigned int const   )mi->type == 3U) {
#line 867
    argv[0] = fusermount_cmd;
#line 868
    argv[1] = (char *)"-u";
#line 869
    argv[2] = (char *)mi->point;
  }
#line 871
  if (debug_file) {
    {
#line 871
    print_debug("Executing: %s %s %s", argv[0], argv[1], argv[2]);
    }
  }
  {
#line 872
  tmp = execute(data, argv, -1, -1);
  }
#line 872
  return (tmp);
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static mount_t *mnt_create(handler_t *data , mount_info_t *mi ) 
{ 
  mount_t *mnt ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 879
  mnt = mnt_list_find((char const   *)mi->point);
  }
#line 880
  if (mnt) {
#line 881
    return (mnt);
  }
  {
#line 883
  tmp = calloc((size_t )1, sizeof(mount_t ));
#line 883
  mnt = (mount_t *)tmp;
  }
#line 884
  if (! mnt) {
    {
#line 885
    tmp___0 = __errno_location();
#line 885
    *tmp___0 = 0;
#line 886
    send_error(data, oom);
    }
#line 887
    return ((mount_t *)((void *)0));
  }
  {
#line 890
  mntinfo_copy(& mnt->info, mi);
#line 892
  mnt_list_add(mnt);
  }
#line 894
  return (mnt);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int is_mounted(handler_t *data , char const   *point ) 
{ 
  int mounted ;
  FILE *file ;
  char buf[1024] ;
  char buf1[4096] ;
  char buf2[4096] ;
  char *point1 ;
  char *device ;
  char *point2tmp ;
  char *point2 ;
  ssize_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 905
  mounted = (int )((bool_t )0);
#line 909
  point1 = realpath((char const   */* __restrict  */)point, (char */* __restrict  */)(buf1));
  }
#line 910
  if (! point1) {
#line 911
    return ((int )((bool_t )0));
  }
  {
#line 913
  file = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 914
  if (! file) {
    {
#line 915
    send_error(data, "Can\'t open /proc/mounts");
    }
#line 916
    return (-1);
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 922
    tmp = read_line_nocomments(file, buf, sizeof(buf));
    }
#line 922
    if (tmp < 0L) {
#line 923
      goto while_break;
    }
    {
#line 925
    split_string(buf, & device, & point2tmp, (void *)0);
    }
#line 926
    if (! device) {
#line 927
      goto while_continue;
    } else
#line 926
    if (! point2tmp) {
#line 927
      goto while_continue;
    }
    {
#line 929
    point2 = realpath((char const   */* __restrict  */)point2tmp, (char */* __restrict  */)(buf2));
    }
#line 930
    if (! point2) {
      {
#line 931
      error("Can\'t get real path of %s", point2tmp);
      }
#line 932
      goto while_continue;
    }
    {
#line 935
    tmp___0 = strcmp((char const   *)point1, (char const   *)point2);
    }
#line 935
    if (tmp___0 == 0) {
#line 936
      mounted = (int )((bool_t )1);
#line 937
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 941
  fclose(file);
  }
#line 943
  if (debug_file) {
#line 943
    if (mounted) {
#line 943
      tmp___1 = "%s is mounted";
    } else {
#line 943
      tmp___1 = "%s is not mounted";
    }
    {
#line 943
    print_debug(tmp___1, point);
    }
  }
#line 945
  return (mounted);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static mount_t *add_mount(handler_t *data , mount_info_t *mi ) 
{ 
  int mounted ;
  mount_t *mnt ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 956
  mounted = is_mounted(data, (char const   *)mi->point);
  }
#line 957
  if (mounted < 0) {
#line 958
    return ((mount_t *)((void *)0));
  }
  {
#line 960
  mnt = mnt_create(data, mi);
  }
#line 961
  if (! mnt) {
#line 962
    return ((mount_t *)((void *)0));
  }
#line 964
  if (! mounted) {
#line 965
    if (debug_file) {
      {
#line 965
      print_debug("Creating directory %s", mnt->info.point);
      }
    }
    {
#line 967
    tmp = mkdirs((char const   *)mnt->info.point);
    }
#line 967
    if (tmp < 0) {
      {
#line 968
      send_error(data, "Can\'t create directory: %s", mnt->info.point);
      }
#line 969
      return ((mount_t *)((void *)0));
    }
    {
#line 972
    tmp___0 = do_mount(data, (mount_info_t const   *)(& mnt->info));
    }
#line 972
    if (tmp___0 < 0) {
#line 973
      return ((mount_t *)((void *)0));
    }
  }
#line 976
  (mnt->usage) ++;
#line 978
  return (mnt);
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int remove_mount(handler_t *data , mount_info_t const   *mi ) 
{ 
  int mounted ;
  mount_t *mnt ;
  int tmp ;

  {
  {
#line 990
  mounted = is_mounted(data, (char const   *)mi->point);
  }
#line 991
  if (mounted < 0) {
#line 992
    return (-1);
  }
  {
#line 994
  mnt = mnt_list_find((char const   *)mi->point);
  }
#line 995
  if (mnt) {
#line 996
    if (mnt->usage == 0U) {
      {
#line 997
      mnt_list_del(mnt);
      }
    } else {
      {
#line 999
      send_error(data, "Warning: %s usage is %d", mnt->info.point, mnt->usage);
      }
    }
  }
#line 1002
  if (mounted) {
    {
#line 1002
    tmp = do_unmount(data, mi);
    }
#line 1002
    if (tmp < 0) {
#line 1003
      return (-1);
    }
  }
#line 1005
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void release_mount(mount_t *mnt ) 
{ 
  time_t tmp ;

  {
#line 1013
  (mnt->usage) --;
#line 1015
  if (debug_file) {
    {
#line 1015
    print_debug("Releasing mount %s (%d users remain)", mnt->info.point, mnt->usage);
    }
  }
#line 1017
  if (mnt->usage <= 0U) {
#line 1017
    if (mount_expiration >= 0) {
#line 1019
      if ((unsigned int )mnt->info.type == 2U) {
#line 1020
        mnt->expiration = (time_t )0;
      } else {
        {
#line 1022
        tmp = time((time_t *)((void *)0));
#line 1022
        mnt->expiration = tmp + (time_t )mount_expiration;
        }
      }
    }
  }
#line 1024
  return;
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void expire_mounts(void) 
{ 
  mount_t *prev ;
  mount_t *curr ;
  time_t now ;

  {
#line 1034
  if (debug_file) {
    {
#line 1034
    print_debug("Checking for expired mounts");
    }
  }
  {
#line 1036
  now = time((time_t *)((void *)0));
#line 1038
  prev = (mount_t *)((void *)0);
#line 1039
  curr = all_mounts.tail;
  }
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (! curr) {
#line 1040
      goto while_break;
    }
#line 1041
    prev = curr->prev;
#line 1043
    if (curr->usage <= 0U) {
#line 1043
      if (curr->expiration <= now) {
#line 1044
        if (debug_file) {
          {
#line 1044
          print_debug("Unmounting %s", curr->info.point);
          }
        }
#line 1046
        if (curr->next) {
#line 1047
          (curr->next)->prev = curr->prev;
        } else {
#line 1049
          all_mounts.tail = curr->prev;
        }
#line 1051
        if (curr->prev) {
#line 1052
          (curr->prev)->next = curr->next;
        } else {
#line 1054
          all_mounts.head = curr->next;
        }
        {
#line 1057
        do_unmount((handler_t *)((void *)0), (mount_info_t const   *)(& curr->info));
#line 1058
        mnt_free(curr);
        }
      }
    }
#line 1061
    curr = prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  return;
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int get_remote(handler_t *data , char const   *point , char *cpy ) 
{ 
  FILE *file ;
  char buf[1024] ;
  char buf1[4096] ;
  char buf2[4096] ;
  char *point1 ;
  char *device ;
  char *point2tmp ;
  char *point2 ;
  ssize_t tmp ;
  int tmp___0 ;
  mount_t *mnt ;
  mount_t *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 1077
  point1 = realpath((char const   */* __restrict  */)point, (char */* __restrict  */)(buf1));
  }
#line 1078
  if (! point1) {
#line 1079
    return (-1);
  }
  {
#line 1081
  file = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 1082
  if (! file) {
    {
#line 1083
    send_error(data, "Can\'t open /proc/mounts");
    }
#line 1084
    return (-1);
  }
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1090
    tmp = read_line_nocomments(file, buf, sizeof(buf));
    }
#line 1090
    if (tmp < 0L) {
#line 1091
      goto while_break;
    }
    {
#line 1093
    split_string(buf, & device, & point2tmp, (void *)0);
    }
#line 1094
    if (! device) {
#line 1095
      goto while_continue;
    } else
#line 1094
    if (! point2tmp) {
#line 1095
      goto while_continue;
    }
    {
#line 1097
    point2 = realpath((char const   */* __restrict  */)point2tmp, (char */* __restrict  */)(buf2));
    }
#line 1098
    if (! point2) {
      {
#line 1099
      error("Can\'t get real path of %s", point2tmp);
      }
#line 1100
      goto while_continue;
    }
    {
#line 1103
    tmp___0 = strcmp((char const   *)point1, (char const   *)point2);
    }
#line 1103
    if (tmp___0 != 0) {
#line 1104
      goto while_continue;
    }
    {
#line 1106
    tmp___1 = mnt_list_find(point);
#line 1106
    mnt = tmp___1;
    }
#line 1111
    if (mnt) {
#line 1111
      if ((unsigned int )mnt->info.type == 3U) {
        {
#line 1111
        tmp___4 = strlen("sshfs#");
#line 1111
        tmp___5 = strncmp((char const   *)device, "sshfs#", tmp___4);
        }
#line 1111
        if (tmp___5 == 0) {
          {
#line 1113
          tmp___2 = strlen("sshfs#");
#line 1113
          strcat((char */* __restrict  */)cpy, (char const   */* __restrict  */)(device + tmp___2));
          }
#line 1114
          if (debug_file) {
            {
#line 1114
            print_debug("Remote sshfs mount point is \'%s\'", cpy);
            }
          }
          {
#line 1115
          fclose(file);
#line 1116
          tmp___3 = strlen((char const   *)cpy);
          }
#line 1116
          return ((int )tmp___3);
        }
      }
    }
#line 1122
    if (mnt) {
#line 1122
      if ((unsigned int )mnt->info.type == 1U) {
        {
#line 1123
        strcat((char */* __restrict  */)cpy, (char const   */* __restrict  */)device);
        }
#line 1124
        if (debug_file) {
          {
#line 1124
          print_debug("Remote nfs mount point is \'%s\'", cpy);
          }
        }
        {
#line 1125
        fclose(file);
#line 1126
        tmp___6 = strlen((char const   *)cpy);
        }
#line 1126
        return ((int )tmp___6);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1130
  fclose(file);
  }
#line 1131
  return (-1);
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int expire_changed(handler_t *data , mount_info_t const   *mi ) 
{ 
  mount_t *mnt ;
  char remote_path[4096] ;
  unsigned int tmp ;
  int len ;
  mount_t *curr ;
  int exprcnt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1143
  remote_path[0] = (char)0;
#line 1143
  tmp = 1U;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    if (tmp >= 4096U) {
#line 1143
      goto while_break;
    }
#line 1143
    remote_path[tmp] = (char)0;
#line 1143
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1146
  mnt = mnt_list_find((char const   *)mi->point);
  }
#line 1147
  if ((unsigned long )mnt == (unsigned long )((void *)0)) {
#line 1148
    return (0);
  }
#line 1155
  if ((unsigned int const   )mi->type == 2U) {
#line 1156
    return (0);
  }
  {
#line 1158
  len = get_remote(data, (char const   *)mi->point, remote_path);
  }
#line 1159
  if (len <= 0) {
#line 1160
    return (len);
  }
#line 1163
  if ((unsigned int const   )mi->type == 1U) {
#line 1163
    goto _L;
  } else
#line 1163
  if ((unsigned int const   )mi->type == 3U) {
    _L: /* CIL Label */ 
    {
#line 1163
    tmp___2 = strcmp((char const   *)(remote_path), (char const   *)mi->device);
    }
#line 1163
    if (tmp___2 != 0) {
      {
#line 1166
      exprcnt = 0;
#line 1168
      warn("Remote mount point for \'%s\' has changed", mi->point);
#line 1174
      curr = all_mounts.tail;
      }
      {
#line 1174
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1174
        if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 1174
          goto while_break___0;
        }
        {
#line 1175
        tmp___0 = strlen((char const   *)mi->point);
#line 1175
        tmp___1 = strncmp((char const   *)mi->point, (char const   *)curr->info.point,
                          tmp___0 - 1UL);
        }
#line 1175
        if (tmp___1 != 0) {
#line 1176
          goto __Cont;
        }
#line 1178
        if (curr->usage <= 0U) {
#line 1179
          if (debug_file) {
            {
#line 1179
            print_debug("Setting %s as expired", curr->info.point);
            }
          }
#line 1180
          curr->expiration = (time_t )0;
#line 1181
          exprcnt ++;
        } else {
          {
#line 1183
          send_error(data, "Warning: %s remote mount point has changed, has usage %d",
                     mnt->info.point, mnt->usage);
          }
#line 1185
          return (-1);
        }
        __Cont: /* CIL Label */ 
#line 1174
        curr = curr->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1189
      if (exprcnt > 0) {
        {
#line 1190
        expire_mounts();
        }
      }
    }
  }
#line 1193
  return (0);
}
}
#line 1199 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void unmount_all(void) 
{ 
  mount_t *prev ;
  mount_t *mnt ;

  {
#line 1203
  mnt = all_mounts.tail;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if (! mnt) {
#line 1204
      goto while_break;
    }
#line 1205
    prev = mnt->prev;
#line 1207
    if (debug_file) {
      {
#line 1207
      print_debug("Unmounting %s", mnt->info.point);
      }
    }
    {
#line 1210
    do_unmount((handler_t *)((void *)0), (mount_info_t const   *)(& mnt->info));
#line 1211
    mnt_free(mnt);
#line 1213
    mnt = prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1216
  all_mounts.head = (mount_t *)((void *)0);
#line 1217
  all_mounts.tail = (mount_t *)((void *)0);
#line 1218
  return;
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int unmount_infos(handler_t *data ) 
{ 
  mount_info_t **mip ;
  int cnt ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
#line 1227
  rc = 0;
#line 1229
  if (debug_file) {
    {
#line 1229
    print_debug("Unmounting filesystems");
    }
  }
#line 1232
  cnt = 0;
#line 1232
  mip = data->param.mounts;
  {
#line 1232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1232
    if (! *mip) {
#line 1232
      goto while_break;
    }
#line 1232
    cnt ++;
#line 1232
    mip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  mip --;
  {
#line 1236
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1236
    tmp___0 = cnt;
#line 1236
    cnt --;
#line 1236
    if (! (tmp___0 > 0)) {
#line 1236
      goto while_break___0;
    }
    {
#line 1237
    tmp = remove_mount(data, (mount_info_t const   *)*mip);
    }
#line 1237
    if (tmp < 0) {
#line 1238
      rc = -1;
    }
#line 1236
    mip --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1240
  return (rc);
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static ssize_t get_data_length(handler_t *data , int fd , size_t max ) 
{ 
  ssize_t len ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1250
  len = (ssize_t )max;
#line 1252
  tmp___0 = isatty(fd);
  }
#line 1252
  if (tmp___0) {
    {
#line 1253
    tmp = ioctl(fd, 21531UL, & len);
    }
#line 1253
    if (tmp < 0) {
      {
#line 1254
      send_error(data, "Can\'t check pty for available data");
      }
#line 1255
      return ((ssize_t )-1);
    }
#line 1258
    if (len < 0L) {
      {
#line 1259
      send_error(data, "ioctl() gave invalid read length");
      }
#line 1260
      return ((ssize_t )-1);
    }
#line 1263
    if ((size_t )len > max) {
#line 1264
      len = (ssize_t )max;
    }
  }
#line 1267
  return (len);
}
}
#line 1276 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void send_data___0(handler_t *data , output_desc_t *out ) 
{ 
  ssize_t len ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1280
  len = get_data_length(data, out->fd, out->req);
  }
#line 1281
  if (len < 0L) {
#line 1282
    goto _error;
  }
#line 1285
  if (len == 0L) {
#line 1286
    return;
  }
  {
#line 1288
  len = read_ni(out->fd, (void *)(data->tmp_buf), (size_t )len);
  }
#line 1289
  if (len < 0L) {
    {
#line 1290
    send_error(data, "Can\'t read output of the process");
    }
#line 1291
    goto _error;
  }
#line 1294
  if (len) {
#line 1295
    if (debug_verbose_flag) {
#line 1295
      if (debug_file) {
#line 1295
        if ((unsigned int )out->data_type == 99U) {
#line 1295
          tmp = "OUT";
        } else {
#line 1295
          tmp = "ERR";
        }
        {
#line 1295
        print_debug("Sending %s DATA packet (%d bytes)", tmp, len);
        }
      }
    }
    {
#line 1298
    tmp___0 = write_buf_packet(data->sd, out->data_type, (size_t )len, (void *)(data->tmp_buf));
    }
#line 1298
    if (tmp___0 < 0) {
      {
#line 1299
      error("Can\'t write packet to socket");
      }
#line 1300
      goto _error;
    }
#line 1303
    out->req -= (size_t )len;
  } else {
#line 1305
    if (debug_file) {
#line 1305
      if ((unsigned int )out->data_type == 99U) {
#line 1305
        tmp___1 = "Stdout hit EOF";
      } else {
#line 1305
        tmp___1 = "Stderr hit EOF";
      }
      {
#line 1305
      print_debug(tmp___1);
      }
    }
#line 1307
    out->fd = -1;
#line 1308
    out->req = (size_t )0;
  }
#line 1311
  return;
  _error: 
#line 1314
  data->error = (bool_t )1;
#line 1315
  return;
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void send_request___0(handler_t *data , input_desc_t *in ) 
{ 
  int tmp ;

  {
#line 1323
  if (in->wait) {
#line 1324
    return;
  }
#line 1326
  if (debug_verbose_flag) {
#line 1326
    if (debug_file) {
      {
#line 1326
      print_debug("Sending IN REQ packet");
      }
    }
  }
  {
#line 1328
  tmp = write_enum(data->sd, (int )in->req_type);
  }
#line 1328
  if (tmp < 0) {
    {
#line 1329
    error("Can\'t write packet to socket");
    }
#line 1330
    goto _error;
  }
#line 1333
  in->wait = (bool_t )1;
#line 1334
  return;
  _error: 
#line 1337
  data->error = (bool_t )1;
#line 1338
  return;
}
}
#line 1343 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void write_buffer___0(handler_t *data , input_desc_t *in ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  bool_t tmp___2 ;

  {
#line 1345
  if (debug_verbose_flag) {
#line 1345
    if (debug_file) {
      {
#line 1345
      print_debug("Writing buffer to stdin");
      }
    }
  }
  {
#line 1347
  tmp___1 = buf_write_out(in->buf, & in->fd);
  }
#line 1347
  if (tmp___1 < 0L) {
#line 1348
    if (debug_file) {
      {
#line 1348
      tmp = __errno_location();
#line 1348
      tmp___0 = strerror(*tmp);
#line 1348
      print_debug("Stdin is closed (%s)", tmp___0);
      }
    }
  }
  {
#line 1350
  tmp___2 = buf_is_empty(in->buf);
  }
#line 1350
  if (tmp___2) {
#line 1351
    in->wait = (bool_t )0;
  }
#line 1352
  return;
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void receive_stream___0(handler_t *data ) 
{ 
  uint32_t len ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1362
  tmp = read_uint32(data->sd, & len);
  }
#line 1362
  if (tmp < 0) {
    {
#line 1363
    send_error(data, "Can\'t read data packet length");
    }
#line 1364
    goto _error;
  }
#line 1367
  if (len > 0U) {
#line 1368
    if (debug_verbose_flag) {
#line 1368
      if (debug_file) {
        {
#line 1368
        print_debug("Receiving IN DATA packet (%d bytes)", len);
        }
      }
    }
    {
#line 1369
    tmp___0 = buf_read_in(data->in.buf, data->sd, (size_t )len);
    }
#line 1369
    if (tmp___0 < 0L) {
      {
#line 1370
      send_error(data, "Can\'t read IN DATA packet to buffer");
      }
#line 1371
      goto _error;
    }
  } else {
#line 1374
    if (debug_file) {
      {
#line 1374
      print_debug("Receiving IN DATA packet: EOF");
      }
    }
    {
#line 1375
    buf_set_eof(data->in.buf);
    }
  }
#line 1378
  return;
  _error: 
#line 1381
  data->error = (bool_t )1;
#line 1382
  return;
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int receive_packet___0(handler_t *data ) 
{ 
  ptype_t type ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1390
  tmp = read_enum(data->sd);
#line 1390
  type = (ptype_t )tmp;
  }
  {
#line 1392
  if ((unsigned int )type == 4294967295U) {
#line 1392
    goto case_4294967295;
  }
#line 1401
  if ((unsigned int )type == 97U) {
#line 1401
    goto case_97;
  }
#line 1405
  if ((unsigned int )type == 98U) {
#line 1405
    goto case_98;
  }
#line 1410
  if ((unsigned int )type == 100U) {
#line 1410
    goto case_100;
  }
#line 1415
  goto switch_default;
  case_4294967295: /* CIL Label */ 
  {
#line 1393
  tmp___0 = __errno_location();
  }
#line 1393
  if (*tmp___0 == 0) {
#line 1394
    if (debug_file) {
      {
#line 1394
      print_debug("EOF from client");
      }
    }
#line 1395
    return (1);
  }
  {
#line 1398
  error("Can\'t read packet header from socket");
  }
#line 1399
  goto _error;
  case_97: /* CIL Label */ 
  {
#line 1402
  receive_stream___0(data);
  }
#line 1403
  return (0);
  case_98: /* CIL Label */ 
#line 1406
  if (debug_verbose_flag) {
#line 1406
    if (debug_file) {
      {
#line 1406
      print_debug("Receiving OUT REQ packet");
      }
    }
  }
#line 1407
  data->out.req = (size_t )4096;
#line 1408
  return (0);
  case_100: /* CIL Label */ 
#line 1411
  if (debug_verbose_flag) {
#line 1411
    if (debug_file) {
      {
#line 1411
      print_debug("Receiving ERR REQ packet");
      }
    }
  }
#line 1412
  data->err.req = (size_t )4096;
#line 1413
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 1416
  tmp___1 = __errno_location();
#line 1416
  *tmp___1 = 0;
#line 1417
  send_error(data, "Received packet has unexpected type (0x%02x)", (unsigned int )type);
  }
  switch_break: /* CIL Label */ ;
  }
  _error: 
#line 1422
  data->error = (bool_t )1;
#line 1423
  return (0);
}
}
#line 1429 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_status(int pid , int status ) 
{ 
  int sig ;
  union __anonunion_91 __constr_expr_2 ;
  union __anonunion_92 __constr_expr_3 ;
  char *tmp ;
  union __anonunion_93 __constr_expr_4 ;
  char *tmp___0 ;
  union __anonunion_94 __constr_expr_5 ;
  union __anonunion_95 __constr_expr_6 ;
  union __anonunion_96 __constr_expr_7 ;

  {
#line 1433
  __constr_expr_7.__in = status;
#line 1433
  if ((__constr_expr_7.__i & 127) == 0) {
#line 1434
    if (debug_file) {
      {
#line 1434
      __constr_expr_2.__in = status;
#line 1434
      print_debug("Process %d returned: %d", pid, (__constr_expr_2.__i & 65280) >> 8);
      }
    }
  } else {
#line 1436
    __constr_expr_6.__in = status;
#line 1436
    if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
#line 1437
      __constr_expr_3.__in = status;
#line 1437
      sig = __constr_expr_3.__i & 127;
#line 1438
      if (debug_file) {
        {
#line 1438
        tmp = strsignal(sig);
#line 1438
        print_debug("Process %d terminated by signal: %s (%d)", pid, tmp, sig);
        }
      }
    } else {
#line 1440
      __constr_expr_5.__in = status;
#line 1440
      if ((__constr_expr_5.__i & 255) == 127) {
#line 1441
        __constr_expr_4.__in = status;
#line 1441
        sig = (__constr_expr_4.__i & 65280) >> 8;
#line 1442
        if (debug_file) {
          {
#line 1442
          tmp___0 = strsignal(sig);
#line 1442
          print_debug("Process %d stopped by signal: %s (%d)", pid, tmp___0, sig);
          }
        }
      } else {
        {
#line 1445
        error("Invalid status %d for pid %d", status, pid);
        }
      }
    }
  }
#line 1447
  return;
}
}
#line 1483 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int handler_manage(handler_t *data , pid_t pid ) 
{ 
  fd_set readfds ;
  fd_set writefds ;
  int maxfd1 ;
  int status ;
  bool_t alive ;
  int *tmp ;
  int count ;
  int val ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  bool_t tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  ssize_t tmp___20 ;
  int tmp___21 ;
  bool_t tmp___22 ;
  int *tmp___23 ;
  __pid_t tmp___24 ;
  union __anonunion_97 __constr_expr_8 ;
  union __anonunion_98 __constr_expr_9 ;

  {
#line 1487
  alive = (bool_t )1;
#line 1489
  if (debug_file) {
    {
#line 1489
    print_debug("Managing process %d", pid);
    }
  }
#line 1491
  if (data->sd > data->in.fd) {
#line 1491
    maxfd1 = data->sd;
  } else {
#line 1491
    maxfd1 = data->in.fd;
  }
#line 1492
  if (maxfd1 > data->out.fd) {
#line 1492
    maxfd1 = maxfd1;
  } else {
#line 1492
    maxfd1 = data->out.fd;
  }
#line 1493
  if (maxfd1 > data->err.fd) {
#line 1493
    maxfd1 = maxfd1;
  } else {
#line 1493
    maxfd1 = data->err.fd;
  }
  {
#line 1494
  maxfd1 ++;
#line 1496
  data->in.buf = buf_alloc();
  }
#line 1497
  if (! data->in.buf) {
    {
#line 1498
    tmp = __errno_location();
#line 1498
    *tmp = 0;
#line 1499
    send_error(data, oom);
    }
#line 1500
    goto _kill;
  }
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (debug_verbose_flag) {
#line 1506
      if (debug_file) {
#line 1506
        if (alive) {
#line 1506
          tmp___0 = "yes";
        } else {
#line 1506
          tmp___0 = "no";
        }
        {
#line 1506
        print_debug("Process alive  = %s", tmp___0);
        }
#line 1506
        if (data->in.fd >= 0) {
#line 1506
          tmp___1 = "yes";
        } else {
#line 1506
          tmp___1 = "no";
        }
        {
#line 1506
        print_debug("Stdin open     = %s", tmp___1);
        }
#line 1506
        if (data->in.wait) {
#line 1506
          tmp___2 = "yes";
        } else {
#line 1506
          tmp___2 = "no";
        }
        {
#line 1506
        print_debug("Stdin waiting  = %s", tmp___2);
        }
#line 1506
        if ((data->in.buf)->eof) {
#line 1506
          tmp___3 = " (EOF set)";
        } else {
#line 1506
          tmp___3 = "";
        }
        {
#line 1506
        tmp___4 = buf_size(data->in.buf);
#line 1506
        print_debug("Stdin buffered = %d bytes%s", tmp___4, tmp___3);
        }
#line 1506
        if (data->out.fd >= 0) {
#line 1506
          tmp___5 = "yes";
        } else {
#line 1506
          tmp___5 = "no";
        }
        {
#line 1506
        print_debug("Stdout open    = %s", tmp___5);
#line 1506
        print_debug("Stdout request = %d bytes", data->out.req);
        }
#line 1506
        if (data->err.fd >= 0) {
#line 1506
          tmp___6 = "yes";
        } else {
#line 1506
          tmp___6 = "no";
        }
        {
#line 1506
        print_debug("Stderr open    = %s", tmp___6);
#line 1506
        print_debug("Stderr request = %d bytes", data->err.req);
        }
#line 1506
        if (data->error) {
#line 1506
          tmp___7 = "yes";
        } else {
#line 1506
          tmp___7 = "no";
        }
        {
#line 1506
        print_debug("Error          = %s", tmp___7);
        }
      }
    }
#line 1508
    if (data->error) {
#line 1509
      if (debug_file) {
        {
#line 1509
        print_debug("Ending loop due to error");
        }
      }
#line 1510
      goto _kill;
    }
#line 1514
    if (! data->param.term) {
#line 1514
      if (data->in.fd < 0) {
#line 1514
        if (data->out.fd < 0) {
#line 1514
          if (data->err.fd < 0) {
#line 1515
            if (debug_file) {
              {
#line 1515
              print_debug("Ending loop due to closed stdin, stdout and stderr descriptors");
              }
            }
#line 1516
            goto while_break;
          }
        }
      }
    }
    {
#line 1519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1519
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 1519
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1520
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefds.__fds_bits[0]): "memory");
#line 1520
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1522
    readfds.__fds_bits[data->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->sd % (8 * (int )sizeof(__fd_mask ));
#line 1524
    if (data->out.fd >= 0) {
#line 1524
      if (data->out.req > 0UL) {
#line 1525
        readfds.__fds_bits[data->out.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->out.fd % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 1527
    if (! data->param.term) {
#line 1527
      if (data->err.fd >= 0) {
#line 1527
        if (data->err.req > 0UL) {
#line 1528
          readfds.__fds_bits[data->err.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->err.fd % (8 * (int )sizeof(__fd_mask ));
        }
      }
    }
#line 1530
    if (data->in.fd >= 0) {
#line 1533
      if (! data->param.term) {
#line 1534
        readfds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->in.fd % (8 * (int )sizeof(__fd_mask ));
      }
      {
#line 1536
      tmp___8 = buf_is_empty(data->in.buf);
      }
#line 1536
      if (tmp___8) {
#line 1536
        if (! data->in.wait) {
#line 1537
          writefds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->in.fd % (8 * (int )sizeof(__fd_mask ));
        }
      } else {
#line 1537
        writefds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->in.fd % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 1540
    if (debug_verbose_flag) {
#line 1540
      if (debug_file) {
#line 1540
        if (data->in.fd >= 0) {
#line 1540
          if ((writefds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1540
            tmp___9 = "IN";
          } else {
#line 1540
            tmp___9 = "";
          }
        } else {
#line 1540
          tmp___9 = "";
        }
#line 1540
        if (data->err.fd >= 0) {
#line 1540
          if ((readfds.__fds_bits[data->err.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->err.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1540
            tmp___10 = "ERR";
          } else {
#line 1540
            tmp___10 = "";
          }
        } else {
#line 1540
          tmp___10 = "";
        }
#line 1540
        if (data->out.fd >= 0) {
#line 1540
          if ((readfds.__fds_bits[data->out.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->out.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1540
            tmp___11 = "OUT";
          } else {
#line 1540
            tmp___11 = "";
          }
        } else {
#line 1540
          tmp___11 = "";
        }
#line 1540
        if (data->in.fd >= 0) {
#line 1540
          if ((readfds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1540
            tmp___12 = "IN";
          } else {
#line 1540
            tmp___12 = "";
          }
        } else {
#line 1540
          tmp___12 = "";
        }
#line 1540
        if (data->sd >= 0) {
#line 1540
          if ((readfds.__fds_bits[data->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1540
            tmp___13 = "NET";
          } else {
#line 1540
            tmp___13 = "";
          }
        } else {
#line 1540
          tmp___13 = "";
        }
        {
#line 1540
        print_debug("Selecting [%3s %2s %3s %3s][%2s]", tmp___13, tmp___12, tmp___11,
                    tmp___10, tmp___9);
        }
      }
    }
    {
#line 1542
    count = select(maxfd1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 1543
    if (count < 0) {
      {
#line 1544
      tmp___14 = __errno_location();
      }
#line 1544
      if (*tmp___14 == 4) {
#line 1545
        if (debug_file) {
          {
#line 1545
          print_debug("Select interrupted");
          }
        }
      } else {
        {
#line 1547
        error("Select failed");
        }
#line 1548
        if (debug_file) {
          {
#line 1548
          print_debug("Ending loop due to failed select");
          }
        }
#line 1549
        goto _kill;
      }
    } else
#line 1552
    if (count > 0) {
#line 1553
      if (debug_verbose_flag) {
#line 1553
        if (debug_file) {
#line 1553
          if (data->in.fd >= 0) {
#line 1553
            if ((writefds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1553
              tmp___15 = "IN";
            } else {
#line 1553
              tmp___15 = "";
            }
          } else {
#line 1553
            tmp___15 = "";
          }
#line 1553
          if (data->err.fd >= 0) {
#line 1553
            if ((readfds.__fds_bits[data->err.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->err.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1553
              tmp___16 = "ERR";
            } else {
#line 1553
              tmp___16 = "";
            }
          } else {
#line 1553
            tmp___16 = "";
          }
#line 1553
          if (data->out.fd >= 0) {
#line 1553
            if ((readfds.__fds_bits[data->out.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->out.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1553
              tmp___17 = "OUT";
            } else {
#line 1553
              tmp___17 = "";
            }
          } else {
#line 1553
            tmp___17 = "";
          }
#line 1553
          if (data->in.fd >= 0) {
#line 1553
            if ((readfds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1553
              tmp___18 = "IN";
            } else {
#line 1553
              tmp___18 = "";
            }
          } else {
#line 1553
            tmp___18 = "";
          }
#line 1553
          if (data->sd >= 0) {
#line 1553
            if ((readfds.__fds_bits[data->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1553
              tmp___19 = "NET";
            } else {
#line 1553
              tmp___19 = "";
            }
          } else {
#line 1553
            tmp___19 = "";
          }
          {
#line 1553
          print_debug("Selected  [%3s %2s %3s %3s][%2s]", tmp___19, tmp___18, tmp___17,
                      tmp___16, tmp___15);
          }
        }
      }
#line 1556
      if (data->param.term) {
#line 1556
        if (! alive) {
#line 1556
          if (data->out.fd >= 0) {
#line 1556
            if ((readfds.__fds_bits[data->out.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->out.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
              {
#line 1556
              tmp___20 = get_data_length(data, data->out.fd, (size_t )1);
              }
#line 1556
              if (tmp___20 <= 0L) {
#line 1558
                if (debug_file) {
                  {
#line 1558
                  print_debug("Ending loop due to dead process and empty stdout buffer");
                  }
                }
#line 1559
                goto while_break;
              }
            }
          }
        }
      }
#line 1563
      if (data->sd >= 0) {
#line 1563
        if ((readfds.__fds_bits[data->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 1563
          tmp___21 = receive_packet___0(data);
          }
#line 1563
          if (tmp___21 == 1) {
            {
#line 1564
            close(data->sd);
#line 1565
            data->sd = -1;
            }
#line 1567
            if (debug_file) {
              {
#line 1567
              print_debug("Ending loop due to closed socket");
              }
            }
#line 1568
            goto _kill;
          }
        }
      }
#line 1571
      if (data->out.fd >= 0) {
#line 1571
        if ((readfds.__fds_bits[data->out.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->out.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 1572
          send_data___0(data, & data->out);
          }
        }
      }
#line 1574
      if (data->err.fd >= 0) {
#line 1574
        if ((readfds.__fds_bits[data->err.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->err.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 1575
          send_data___0(data, & data->err);
          }
        }
      }
#line 1577
      if (data->in.fd >= 0) {
#line 1577
        if ((writefds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 1578
          tmp___22 = buf_is_empty(data->in.buf);
          }
#line 1578
          if (tmp___22) {
            {
#line 1579
            send_request___0(data, & data->in);
            }
          } else {
            {
#line 1581
            write_buffer___0(data, & data->in);
            }
          }
        }
      }
#line 1585
      if (! data->param.term) {
#line 1585
        if (data->in.fd >= 0) {
#line 1585
          if ((readfds.__fds_bits[data->in.fd / (8 * (int )sizeof(__fd_mask ))] & (1L << data->in.fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1586
            data->in.fd = -1;
          }
        }
      }
    }
    {
#line 1591
    val = waitpid(-1, & status, 1);
    }
#line 1592
    if (val < 0) {
      {
#line 1592
      tmp___23 = __errno_location();
      }
#line 1592
      if (*tmp___23 != 10) {
        {
#line 1593
        send_error(data, "Can\'t wait for children");
        }
#line 1594
        return (-1);
      }
    }
#line 1597
    if (val > 0) {
#line 1598
      if (val == pid) {
#line 1599
        alive = (bool_t )0;
      }
      {
#line 1601
      print_status(val, status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1605
  if (alive) {
    {
#line 1606
    tmp___24 = waitpid(pid, & status, 0);
    }
#line 1606
    if (tmp___24 < 0) {
      {
#line 1607
      send_error(data, "Can\'t wait for child %d", pid);
      }
#line 1608
      return (-1);
    }
    {
#line 1611
    print_status(pid, status);
    }
  }
#line 1614
  __constr_expr_9.__in = status;
#line 1614
  if ((__constr_expr_9.__i & 127) == 0) {
#line 1615
    __constr_expr_8.__in = status;
#line 1615
    return ((__constr_expr_8.__i & 65280) >> 8);
  }
#line 1617
  return (-1);
  _kill: 
#line 1620
  if (debug_file) {
    {
#line 1620
    print_debug("Sending SIGTERM to command process %d", pid);
    }
  }
  {
#line 1621
  kill(pid, 15);
  }
#line 1623
  return (-1);
}
}
#line 1629 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int authenticate(handler_t *data ) 
{ 
  bool_t ok ;

  {
#line 1633
  if (debug_file) {
    {
#line 1633
    print_debug("Searching for host %s in %s", data->host, "/etc/sbrshd.conf");
    }
  }
  {
#line 1635
  ok = find_host(data, "/etc/sbrshd.conf");
  }
#line 1636
  if (! ok) {
    {
#line 1637
    warn("Unauthorized connection from %s", data->host);
    }
  }
#line 1639
  return ((int )ok);
}
}
#line 1646 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static pid_t fork_pty(handler_t *data , int *ptyfd ) 
{ 
  int master ;
  int slave ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1651
  tmp = openpty(& master, & slave, (char *)((void *)0), (struct termios  const  *)((void *)0),
                (struct winsize  const  *)data->param.term);
  }
#line 1651
  if (tmp < 0) {
    {
#line 1652
    send_error(data, "Can\'t open a pseudo-tty");
    }
#line 1653
    return (-1);
  }
  {
#line 1656
  pid = fork();
  }
#line 1657
  if (pid < 0) {
    {
#line 1658
    send_error(data, "Can\'t fork");
    }
#line 1659
    return (-1);
  }
#line 1662
  if (pid == 0) {
    {
#line 1665
    set_debug_name("COMMAND");
#line 1667
    close(master);
#line 1668
    tmp___0 = login_tty(slave);
    }
#line 1668
    if (tmp___0) {
      {
#line 1669
      send_error(data, "Can\'t login to a pseudo-tty");
#line 1670
      exit(1);
      }
    }
  } else {
    {
#line 1675
    close(slave);
#line 1676
    *ptyfd = master;
    }
  }
#line 1679
  return (pid);
}
}
#line 1691 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static pid_t fork_sockets(handler_t *data , int *infd , int *outfd , int *errfd ) 
{ 
  int insd[2] ;
  int outsd[2] ;
  int errsd[2] ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1696
  tmp = socketpair(1, 1, 0, (int *)(insd));
  }
#line 1696
  if (tmp < 0) {
    {
#line 1699
    send_error(data, "Can\'t create socket pairs");
    }
#line 1700
    return (-1);
  } else {
    {
#line 1696
    tmp___0 = socketpair(1, 1, 0, (int *)(outsd));
    }
#line 1696
    if (tmp___0 < 0) {
      {
#line 1699
      send_error(data, "Can\'t create socket pairs");
      }
#line 1700
      return (-1);
    } else {
      {
#line 1696
      tmp___1 = socketpair(1, 1, 0, (int *)(errsd));
      }
#line 1696
      if (tmp___1 < 0) {
        {
#line 1699
        send_error(data, "Can\'t create socket pairs");
        }
#line 1700
        return (-1);
      }
    }
  }
  {
#line 1703
  pid = fork();
  }
#line 1704
  if (pid < 0) {
    {
#line 1705
    send_error(data, "Can\'t fork");
    }
#line 1706
    return (-1);
  }
#line 1709
  if (pid == 0) {
    {
#line 1712
    set_debug_name("COMMAND");
#line 1714
    close(insd[0]);
#line 1715
    close(outsd[0]);
#line 1716
    close(errsd[0]);
#line 1718
    tmp___2 = dup2(insd[1], 0);
    }
#line 1718
    if (tmp___2 != 0) {
      {
#line 1719
      send_error(data, "Can\'t duplicate socket as stdin");
#line 1720
      exit(1);
      }
    }
    {
#line 1723
    tmp___3 = dup2(outsd[1], 1);
    }
#line 1723
    if (tmp___3 != 1) {
      {
#line 1724
      send_error(data, "Can\'t duplicate socket as stdout");
#line 1725
      exit(1);
      }
    }
    {
#line 1728
    tmp___4 = dup2(errsd[1], 2);
    }
#line 1728
    if (tmp___4 != 2) {
      {
#line 1729
      send_error(data, "Can\'t duplicate socket as stderr");
#line 1730
      exit(1);
      }
    }
  } else {
    {
#line 1735
    tmp___5 = set_nonblocking(insd[0], (bool_t )1);
    }
#line 1735
    if (tmp___5) {
      {
#line 1736
      send_error(data, "Can\'t make socket non-blocking");
      }
#line 1737
      return (-1);
    }
#line 1740
    *infd = insd[0];
#line 1741
    *outfd = outsd[0];
#line 1742
    *errfd = errsd[0];
  }
  {
#line 1745
  close(insd[1]);
#line 1746
  close(outsd[1]);
#line 1747
  close(errsd[1]);
  }
#line 1749
  return (pid);
}
}
#line 1758
static int set_rlimits(handler_t *data ) ;
#line 1758 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static struct __anonstruct_info_99 info[11]  = 
#line 1758
  {      {"SBOX_RLIMIT_CPU", 0}, 
        {"SBOX_RLIMIT_FSIZE", 1}, 
        {"SBOX_RLIMIT_DATA", 2}, 
        {"SBOX_RLIMIT_STACK", 3}, 
        {"SBOX_RLIMIT_CORE", 4}, 
        {"SBOX_RLIMIT_RSS", 5}, 
        {"SBOX_RLIMIT_NPROC", 6}, 
        {"SBOX_RLIMIT_NOFILE", 7}, 
        {"SBOX_RLIMIT_MEMLOCK", 8}, 
        {"SBOX_RLIMIT_AS", 9}, 
        {(char const   *)((void *)0), 0}};
#line 1756 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int set_rlimits(handler_t *data ) 
{ 
  int prefixlen ;
  size_t tmp ;
  char *resname ;
  int i ;
  char *str ;
  struct rlimit lim ;
  size_t tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1772
  tmp = strlen("SBOX_RLIMIT_");
#line 1772
  prefixlen = (int )tmp;
#line 1778
  i = 0;
  }
  {
#line 1778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1778
    if (! info[i].key) {
#line 1778
      goto while_break;
    }
    {
#line 1779
    resname = (char *)info[i].key + prefixlen;
#line 1781
    str = getenv(info[i].key);
    }
#line 1782
    if (! str) {
#line 1783
      goto __Cont;
    }
    {
#line 1785
    str = skip_spaces((char const   *)str);
#line 1786
    tmp___0 = strlen((char const   *)str);
    }
#line 1786
    if (tmp___0 == 0UL) {
#line 1787
      goto __Cont;
    }
#line 1789
    if (debug_file) {
      {
#line 1789
      print_debug("Setting %s resource to %s", resname, str);
      }
    }
    {
#line 1791
    tmp___1 = getrlimit((__rlimit_resource_t )info[i].resource, & lim);
    }
#line 1791
    if (tmp___1 < 0) {
      {
#line 1792
      send_error(data, "Can\'t get %s resource limit", resname);
      }
#line 1793
      return (-1);
    }
    {
#line 1796
    lim.rlim_cur = (__rlim_t )-1;
#line 1798
    tmp___4 = strlen("unlimited");
#line 1798
    tmp___5 = strncmp((char const   *)str, "unlimited", tmp___4);
    }
#line 1798
    if (tmp___5 != 0) {
      {
#line 1799
      tmp___2 = atol((char const   *)str);
#line 1799
      lim.rlim_cur = (rlim_t )tmp___2;
      }
#line 1801
      if (lim.rlim_cur == 0UL) {
        {
#line 1801
        tmp___3 = strcmp((char const   *)str, "0");
        }
#line 1801
        if (tmp___3 != 0) {
          {
#line 1802
          send_error(data, "Invalid %s resource limit value: %s", resname, str);
          }
#line 1803
          return (-1);
        }
      }
    }
    {
#line 1807
    tmp___6 = setrlimit((__rlimit_resource_t )info[i].resource, (struct rlimit  const  *)(& lim));
    }
#line 1807
    if (tmp___6 < 0) {
      {
#line 1808
      send_error(data, "Can\'t set %s resource limit to %d while maximum is %d", resname,
                 lim.rlim_cur, lim.rlim_max);
      }
#line 1810
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 1778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1814
  return (0);
}
}
#line 1822 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *add_root_prefix(handler_t *data , char *orig ) 
{ 
  char *dir ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 1826
  if ((int )*(orig + 0) == 47) {
#line 1827
    return (orig);
  }
  {
#line 1829
  tmp = strlen((char const   *)orig);
#line 1829
  tmp___0 = malloc((1UL + tmp) + 1UL);
#line 1829
  dir = (char *)tmp___0;
  }
#line 1830
  if (! dir) {
    {
#line 1831
    tmp___1 = __errno_location();
#line 1831
    *tmp___1 = 0;
#line 1832
    send_error(data, oom);
#line 1833
    exit(1);
    }
  }
  {
#line 1836
  strcpy((char */* __restrict  */)dir, (char const   */* __restrict  */)"/");
#line 1837
  strcat((char */* __restrict  */)dir, (char const   */* __restrict  */)orig);
  }
#line 1839
  return (dir);
}
}
#line 1845 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void execute_command(handler_t *data ) 
{ 
  char **argv ;
  char *dir ;
  char *tmp ;
  int tmp___0 ;
  uid_t uid ;
  gid_t gid ;
  int gcount ;
  int i ;
  gid_t groups[65536] ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char **env ;
  void *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *dir___0 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1853
  if (data->root) {
    {
#line 1854
    tmp = add_root_prefix(data, data->root);
#line 1854
    dir = tmp;
    }
#line 1856
    if (debug_file) {
      {
#line 1856
      print_debug("Changing root directory to %s", dir);
      }
    }
    {
#line 1857
    tmp___0 = chroot((char const   *)dir);
    }
#line 1857
    if (tmp___0 < 0) {
      {
#line 1858
      send_error(data, "Can\'t change root directory to: %s", dir);
#line 1859
      exit(1);
      }
    }
  }
  {
#line 1863
  chdir("/");
  }
#line 1874
  if (! data->param.ids) {
    {
#line 1875
    tmp___1 = __errno_location();
#line 1875
    *tmp___1 = 0;
#line 1876
    send_error(data, "Valid IDS parameter required");
#line 1877
    exit(1);
    }
  } else
#line 1874
  if ((data->param.ids)->len < 2U) {
    {
#line 1875
    tmp___1 = __errno_location();
#line 1875
    *tmp___1 = 0;
#line 1876
    send_error(data, "Valid IDS parameter required");
#line 1877
    exit(1);
    }
  }
#line 1880
  uid = (uid_t )*((data->param.ids)->vec + 0);
#line 1881
  gid = (gid_t )*((data->param.ids)->vec + 1);
#line 1883
  if (! allow_root) {
#line 1884
    i = 0;
    {
#line 1884
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1884
      if (! ((uint32_t )i < (data->param.ids)->len)) {
#line 1884
        goto while_break;
      }
#line 1885
      if ((int )*((data->param.ids)->vec + i) == 0) {
        {
#line 1886
        send_error(data, "root access denied");
#line 1887
        exit(1);
        }
      }
#line 1884
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1890
  gcount = (int )((data->param.ids)->len - 2U);
#line 1896
  if (gcount > 0) {
#line 1897
    if (gcount > 65536) {
#line 1898
      gcount = 65536;
    }
#line 1900
    i = 0;
    {
#line 1900
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1900
      if (! (i < gcount)) {
#line 1900
        goto while_break___0;
      }
#line 1901
      groups[i] = (gid_t )*((data->param.ids)->vec + (i + 2));
#line 1900
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1904
  if (debug_file) {
    {
#line 1904
    print_debug("Changing gid to %d", gid);
    }
  }
  {
#line 1905
  tmp___2 = setgid(gid);
  }
#line 1905
  if (tmp___2 < 0) {
    {
#line 1906
    send_error(data, "Can\'t change group ID to %d", gid);
#line 1907
    exit(1);
    }
  }
#line 1910
  if (gcount > 0) {
#line 1911
    if (debug_file) {
      {
#line 1911
      print_debug("Setting %d supplementary gids", gcount);
      }
    }
    {
#line 1912
    tmp___3 = setgroups((size_t )gcount, (__gid_t const   *)(groups));
    }
#line 1912
    if (tmp___3 < 0) {
      {
#line 1913
      send_error(data, "Can\'t set supplementary group IDs");
#line 1915
      exit(1);
      }
    }
  } else
#line 1919
  if (debug_file) {
    {
#line 1919
    print_debug("Using groups of user");
    }
  }
#line 1922
  if (debug_file) {
    {
#line 1922
    print_debug("Changing uid to %d", uid);
    }
  }
  {
#line 1923
  tmp___4 = setuid(uid);
  }
#line 1923
  if (tmp___4 < 0) {
    {
#line 1924
    send_error(data, "Can\'t change user ID to %d", uid);
#line 1925
    exit(1);
    }
  }
#line 1933
  env = data->param.environ;
#line 1934
  if (! env) {
    {
#line 1935
    tmp___5 = calloc((size_t )1, sizeof(char *));
#line 1935
    env = (char **)tmp___5;
    }
#line 1936
    if (! env) {
      {
#line 1937
      tmp___6 = __errno_location();
#line 1937
      *tmp___6 = 0;
#line 1938
      send_error(data, oom);
#line 1939
      exit(1);
      }
    }
  }
#line 1942
  environ = env;
#line 1945
  if (data->fakerootkey) {
    {
#line 1945
    tmp___7 = putenv(data->fakerootkey);
    }
#line 1945
    if (tmp___7 < 0) {
      {
#line 1946
      send_error(data, "Can\'t put %s to environment", data->fakerootkey);
#line 1947
      exit(1);
      }
    }
  }
  {
#line 1954
  tmp___8 = set_rlimits(data);
  }
#line 1954
  if (tmp___8 < 0) {
    {
#line 1955
    exit(1);
    }
  }
  {
#line 1961
  umask((__mode_t )data->param.umask);
#line 1967
  argv = data->param.args;
  }
#line 1968
  if (! argv) {
    {
#line 1969
    tmp___9 = calloc((size_t )2, sizeof(char *));
#line 1969
    argv = (char **)tmp___9;
    }
#line 1970
    if (! argv) {
      {
#line 1971
      tmp___10 = __errno_location();
#line 1971
      *tmp___10 = 0;
#line 1972
      send_error(data, oom);
#line 1973
      exit(1);
      }
    }
    {
#line 1976
    *(argv + 0) = getenv("SHELL");
    }
#line 1977
    if (! *(argv + 0)) {
#line 1978
      *(argv + 0) = (char *)"/bin/sh";
    }
  }
#line 1985
  if (data->param.cwd) {
    {
#line 1986
    tmp___11 = add_root_prefix(data, data->param.cwd);
#line 1986
    dir___0 = tmp___11;
    }
#line 1988
    if (debug_file) {
      {
#line 1988
      print_debug("Changing current directory to %s", dir___0);
      }
    }
    {
#line 1989
    tmp___12 = chdir((char const   *)dir___0);
    }
#line 1989
    if (tmp___12 < 0) {
      {
#line 1990
      send_error(data, "Can\'t change current directory to %s inside sandbox", dir___0);
#line 1991
      exit(1);
      }
    }
  }
#line 1997
  if (debug_file) {
    {
#line 1997
    print_debug_vector("Executing command:", argv);
    }
  }
  {
#line 1999
  set_closeonexec(data->sd);
#line 2000
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 2002
  send_error(data, "Can\'t execute command: %s", *(argv + 0));
#line 2003
  exit(1);
  }
}
}
#line 2010 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static int handler_startup(handler_t *data , mount_t ***mounts_ptr ) 
{ 
  size_t i ;
  size_t mount_count ;
  ptype_t action___0 ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint16_t auth ;
  int ok ;
  int tmp___3 ;
  int tmp___4 ;
  ptype_t type ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char root[4096] ;
  int *tmp___10 ;
  char tmp___11[4096] ;
  char *str ;
  mount_info_t *mi ;
  int tmp___12 ;
  mount_t **mounts ;
  void *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;

  {
#line 2012
  mount_count = (size_t )0;
#line 2013
  action___0 = (ptype_t )0;
#line 2015
  if (debug_file) {
    {
#line 2015
    print_debug("Client IP address is %s", data->host);
    }
  }
#line 2021
  if (debug_file) {
    {
#line 2021
    print_debug("Sending VERSION packet");
    }
  }
  {
#line 2022
  tmp = send_version(data->sd);
  }
#line 2022
  if (tmp < 0) {
    {
#line 2023
    error("Can\'t send protocol version packet");
    }
#line 2024
    return (-1);
  }
#line 2027
  if (debug_file) {
    {
#line 2027
    print_debug("Reading client\'s VERSION packet");
    }
  }
  {
#line 2028
  data->client_version = get_version(data->sd);
  }
#line 2029
  if (data->client_version < 0) {
    {
#line 2030
    error("Can\'t read protocol version packet");
    }
#line 2031
    return (-1);
  }
#line 2034
  if (data->client_version < 7) {
    {
#line 2035
    tmp___0 = __errno_location();
#line 2035
    *tmp___0 = 0;
#line 2036
    send_error(data, "Client version %d is too old (version %d required)", data->client_version,
               7);
    }
#line 2038
    return (-1);
  }
#line 2045
  if (debug_file) {
    {
#line 2045
    print_debug("Reading USER packet");
    }
  }
  {
#line 2046
  tmp___1 = read_enum(data->sd);
  }
#line 2046
  if (tmp___1 != 34) {
    {
#line 2047
    error("Received packet has unexpected type");
    }
#line 2048
    return (-1);
  }
  {
#line 2051
  tmp___2 = read_str(data->sd);
#line 2051
  data->user = (char const   *)tmp___2;
  }
#line 2052
  if (! data->user) {
    {
#line 2053
    error("Can\'t read USER packet");
    }
#line 2054
    return (-1);
  }
  {
#line 2063
  tmp___3 = authenticate(data);
#line 2063
  ok = tmp___3;
  }
#line 2064
  if (ok < 0) {
#line 2065
    return (-1);
  }
#line 2067
  auth = (uint16_t )ok;
#line 2069
  if (debug_file) {
    {
#line 2069
    print_debug("Sending AUTH packet");
    }
  }
  {
#line 2070
  tmp___4 = write_uint16_packet(data->sd, (ptype_t )35, auth);
  }
#line 2070
  if (tmp___4 < 0) {
    {
#line 2071
    error("Can\'t write AUTH packet to socket");
    }
#line 2072
    return (-1);
  }
#line 2075
  if (! auth) {
#line 2076
    return (-1);
  }
  {
#line 2082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2082
    if (! (! action___0)) {
#line 2082
      goto while_break;
    }
    {
#line 2083
    tmp___5 = read_enum(data->sd);
#line 2083
    type = (ptype_t )tmp___5;
    }
    {
#line 2085
    if ((unsigned int )type == 4294967295U) {
#line 2085
      goto case_4294967295;
    }
#line 2089
    if ((unsigned int )type == 65U) {
#line 2089
      goto case_65;
    }
#line 2098
    if ((unsigned int )type == 66U) {
#line 2098
      goto case_66;
    }
#line 2107
    if ((unsigned int )type == 80U) {
#line 2107
      goto case_80;
    }
#line 2116
    if ((unsigned int )type == 81U) {
#line 2116
      goto case_81;
    }
#line 2125
    if ((unsigned int )type == 82U) {
#line 2125
      goto case_82;
    }
#line 2134
    if ((unsigned int )type == 83U) {
#line 2134
      goto case_83;
    }
#line 2143
    if ((unsigned int )type == 84U) {
#line 2143
      goto case_84;
    }
#line 2151
    if ((unsigned int )type == 85U) {
#line 2151
      goto case_85;
    }
#line 2160
    if ((unsigned int )type == 48U) {
#line 2160
      goto case_48;
    }
#line 2165
    if ((unsigned int )type == 49U) {
#line 2165
      goto case_49;
    }
#line 2170
    if ((unsigned int )type == 50U) {
#line 2170
      goto case_50;
    }
#line 2175
    goto switch_default;
    case_4294967295: /* CIL Label */ 
    {
#line 2086
    error("Can\'t read packet type from socket");
    }
#line 2087
    return (-1);
    case_65: /* CIL Label */ 
#line 2090
    if (debug_file) {
      {
#line 2090
      print_debug("Receiving TARGET packet");
      }
    }
    {
#line 2091
    data->param.target = read_str(data->sd);
    }
#line 2092
    if (! data->param.target) {
      {
#line 2093
      error("Can\'t read TARGET packet");
      }
#line 2094
      return (-1);
    }
#line 2096
    goto switch_break;
    case_66: /* CIL Label */ 
#line 2099
    if (debug_file) {
      {
#line 2099
      print_debug("Receiving MOUNTS packet");
      }
    }
    {
#line 2100
    data->param.mounts = read_mountv(data->sd);
    }
#line 2101
    if (! data->param.mounts) {
      {
#line 2102
      error("Can\'t read MOUNTS packet");
      }
#line 2103
      return (-1);
    }
#line 2105
    goto switch_break;
    case_80: /* CIL Label */ 
#line 2108
    if (debug_file) {
      {
#line 2108
      print_debug("Receiving ARGS packet");
      }
    }
    {
#line 2109
    data->param.args = read_strv(data->sd);
    }
#line 2110
    if (! data->param.args) {
      {
#line 2111
      error("Can\'t read ARGS packet");
      }
#line 2112
      return (-1);
    }
#line 2114
    goto switch_break;
    case_81: /* CIL Label */ 
#line 2117
    if (debug_file) {
      {
#line 2117
      print_debug("Receiving CWD packet");
      }
    }
    {
#line 2118
    data->param.cwd = read_str(data->sd);
    }
#line 2119
    if (! data->param.cwd) {
      {
#line 2120
      error("Can\'t read CWD packet");
      }
#line 2121
      return (-1);
    }
#line 2123
    goto switch_break;
    case_82: /* CIL Label */ 
#line 2126
    if (debug_file) {
      {
#line 2126
      print_debug("Receiving ENVIRON packet");
      }
    }
    {
#line 2127
    data->param.environ = read_strv(data->sd);
    }
#line 2128
    if (! data->param.environ) {
      {
#line 2129
      error("Can\'t read ENVIRON packet");
      }
#line 2130
      return (-1);
    }
#line 2132
    goto switch_break;
    case_83: /* CIL Label */ 
#line 2135
    if (debug_file) {
      {
#line 2135
      print_debug("Receiving IDS packet");
      }
    }
    {
#line 2136
    data->param.ids = read_uint16v(data->sd);
    }
#line 2137
    if (! data->param.ids) {
      {
#line 2138
      error("Can\'t read IDS packet");
      }
#line 2139
      return (-1);
    }
#line 2141
    goto switch_break;
    case_84: /* CIL Label */ 
#line 2144
    if (debug_file) {
      {
#line 2144
      print_debug("Receiving UMASK packet");
      }
    }
    {
#line 2145
    tmp___6 = read_uint16(data->sd, & data->param.umask);
    }
#line 2145
    if (tmp___6 < 0) {
      {
#line 2146
      error("Can\'t read UMASK packet");
      }
#line 2147
      return (-1);
    }
#line 2149
    goto switch_break;
    case_85: /* CIL Label */ 
#line 2152
    if (debug_file) {
      {
#line 2152
      print_debug("Receiving WINSIZE packet");
      }
    }
    {
#line 2153
    data->param.term = read_winsize(data->sd);
    }
#line 2154
    if (! data->param.term) {
      {
#line 2155
      error("Can\'t read WINSIZE packet");
      }
#line 2156
      return (-1);
    }
#line 2158
    goto switch_break;
    case_48: /* CIL Label */ 
#line 2161
    if (debug_file) {
      {
#line 2161
      print_debug("Received COMMAND packet");
      }
    }
#line 2162
    action___0 = type;
#line 2163
    goto switch_break;
    case_49: /* CIL Label */ 
#line 2166
    if (debug_file) {
      {
#line 2166
      print_debug("Received MOUNT packet");
      }
    }
#line 2167
    action___0 = type;
#line 2168
    goto switch_break;
    case_50: /* CIL Label */ 
#line 2171
    if (debug_file) {
      {
#line 2171
      print_debug("Received UMOUNT packet");
      }
    }
#line 2172
    action___0 = type;
#line 2173
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2176
    tmp___7 = __errno_location();
#line 2176
    *tmp___7 = 0;
#line 2177
    send_error(data, "Received packet has unexpected type (0x%02x)", (unsigned int )type);
    }
#line 2178
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2182
  if (! data->param.target) {
    {
#line 2183
    tmp___8 = __errno_location();
#line 2183
    *tmp___8 = 0;
#line 2184
    send_error(data, "TARGET parameter required");
    }
#line 2185
    return (-1);
  }
#line 2187
  if ((unsigned int )action___0 != 48U) {
#line 2187
    if (! data->param.mounts) {
      {
#line 2188
      tmp___9 = __errno_location();
#line 2188
      *tmp___9 = 0;
#line 2189
      send_error(data, "MOUNTS parameter required");
      }
#line 2190
      return (-1);
    }
  }
#line 2197
  if (sandbox) {
    {
#line 2200
    snprintf((char */* __restrict  */)(root), sizeof(root) - 1UL, (char const   */* __restrict  */)"/var/sbrshd/%s@%s/%s",
             data->user, data->host, data->param.target);
    }
#line 2203
    if (debug_file) {
      {
#line 2203
      print_debug("Sandbox root is %s", root);
      }
    }
    {
#line 2205
    data->root = strdup((char const   *)(root));
    }
#line 2206
    if (! data->root) {
      {
#line 2207
      tmp___10 = __errno_location();
#line 2207
      *tmp___10 = 0;
#line 2208
      send_error(data, oom);
      }
#line 2209
      return (-1);
    }
  }
#line 2217
  if (data->param.mounts) {
    {
#line 2218
    mount_count = calc_vec_len((void **)data->param.mounts);
    }
  }
#line 2224
  if (mount_count > 0UL) {
#line 2224
    if (data->root) {
#line 2225
      i = (size_t )0;
      {
#line 2225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2225
        if (! (i < mount_count)) {
#line 2225
          goto while_break___0;
        }
        {
#line 2229
        mi = *(data->param.mounts + i);
#line 2231
        snprintf((char */* __restrict  */)(tmp___11), sizeof(tmp___11) - 1UL, (char const   */* __restrict  */)"%s%s",
                 data->root, mi->point);
#line 2233
        str = strdup((char const   *)(tmp___11));
        }
#line 2234
        if (! str) {
          {
#line 2235
          send_error(data, (char const   *)((void *)0));
          }
#line 2236
          return (-1);
        }
        {
#line 2239
        free((void *)mi->point);
#line 2240
        mi->point = str;
#line 2225
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 2243
  if ((unsigned int )action___0 == 50U) {
#line 2248
    if (debug_file) {
      {
#line 2248
      print_debug("--umount requested");
      }
    }
    {
#line 2250
    tmp___12 = unmount_infos(data);
    }
#line 2250
    if (tmp___12 < 0) {
#line 2251
      return (-1);
    }
  } else
#line 2253
  if (mount_count > 0UL) {
    {
#line 2260
    mntinfo_sort_vec(data->param.mounts);
#line 2262
    tmp___13 = calloc(mount_count + 1UL, sizeof(mount_t *));
#line 2262
    mounts = (mount_t **)tmp___13;
    }
#line 2263
    if (! mounts) {
      {
#line 2264
      tmp___14 = __errno_location();
#line 2264
      *tmp___14 = 0;
#line 2265
      send_error(data, oom);
      }
#line 2266
      return (-1);
    }
#line 2269
    i = (size_t )0;
    {
#line 2269
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2269
      if (! (i < mount_count)) {
#line 2269
        goto while_break___1;
      }
      {
#line 2270
      tmp___16 = expire_changed(data, (mount_info_t const   *)*(data->param.mounts + i));
      }
#line 2270
      if (tmp___16 < 0) {
        {
#line 2271
        tmp___15 = __errno_location();
#line 2271
        *tmp___15 = 0;
#line 2272
        send_error(data, "Can\'t expire remote mount point: %s", (*(data->param.mounts + i))->point);
        }
#line 2274
        return (-1);
      }
#line 2269
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2277
    i = (size_t )0;
    {
#line 2277
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2277
      if (! (i < mount_count)) {
#line 2277
        goto while_break___2;
      }
      {
#line 2278
      *(mounts + i) = add_mount(data, *(data->param.mounts + i));
      }
#line 2279
      if (! *(mounts + i)) {
        {
#line 2280
        tmp___17 = __errno_location();
#line 2280
        *tmp___17 = 0;
#line 2281
        send_error(data, "Can\'t mount to point: %s", (*(data->param.mounts + i))->point);
#line 2283
        free_vec((void **)mounts, (free_func_t *)(& release_mount));
        }
#line 2284
        return (-1);
      }
#line 2277
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2288
    *mounts_ptr = mounts;
  }
#line 2291
  return ((int )action___0);
}
}
#line 2294 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void send_rc(handler_t *data , uint16_t rc ) 
{ 
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 2296
  if (data->sd < 0) {
#line 2297
    if (debug_file) {
      {
#line 2297
      print_debug("Not sending RC packet");
      }
    }
#line 2298
    return;
  }
#line 2301
  if (debug_file) {
    {
#line 2301
    print_debug("Sending RC packet: %d", (int )rc);
    }
  }
  {
#line 2304
  tmp___2 = write_uint16_packet(data->sd, (ptype_t )36, rc);
  }
#line 2304
  if (tmp___2 >= 0) {
    {
#line 2308
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2309
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2309
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.__fds_bits[0]): "memory");
#line 2309
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2310
      fds.__fds_bits[data->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << data->sd % (8 * (int )sizeof(__fd_mask ));
#line 2312
      tmp___0 = select(data->sd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 2312
      if (tmp___0 < 0) {
        {
#line 2313
        tmp = __errno_location();
        }
#line 2313
        if (*tmp == 4) {
#line 2314
          goto while_continue;
        } else {
#line 2316
          goto while_break;
        }
      }
      {
#line 2319
      tmp___1 = read(data->sd, (void *)(data->tmp_buf), (size_t )4096);
      }
#line 2319
      if (tmp___1 <= 0L) {
#line 2320
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2323
    error("Can\'t write RC packet to socket");
    }
  }
  {
#line 2326
  close(data->sd);
#line 2327
  data->sd = -1;
  }
#line 2328
  return;
}
}
#line 2330 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void handler_handle(handler_t *data ) 
{ 
  int rc ;
  pid_t relay_pid ;
  pid_t pid ;
  int fd ;

  {
  {
#line 2332
  rc = -1;
#line 2335
  relay_pid = fakeroot_relay(data);
  }
#line 2336
  if (relay_pid < 0) {
#line 2337
    goto _rc;
  }
#line 2339
  if (data->param.term) {
#line 2342
    if (debug_file) {
      {
#line 2342
      print_debug("Creating command process in a pty");
      }
    }
    {
#line 2343
    pid = fork_pty(data, & fd);
#line 2345
    data->in.fd = fd;
#line 2346
    data->out.fd = fd;
#line 2347
    data->err.fd = -1;
    }
  } else {
#line 2349
    if (debug_file) {
      {
#line 2349
      print_debug("Creating command process without a pty");
      }
    }
    {
#line 2350
    pid = fork_sockets(data, & data->in.fd, & data->out.fd, & data->err.fd);
    }
  }
#line 2354
  if (pid == 0) {
    {
#line 2355
    execute_command(data);
    }
  }
#line 2357
  if (pid > 0) {
    {
#line 2358
    rc = handler_manage(data, pid);
    }
  }
#line 2360
  if (relay_pid > 0) {
#line 2361
    if (debug_file) {
      {
#line 2361
      print_debug("Sending SIGTERM to relay process %d", relay_pid);
      }
    }
    {
#line 2362
    kill(relay_pid, 15);
    }
  }
  _rc: 
#line 2366
  if (rc < 0) {
#line 2367
    rc = 32767;
  }
  {
#line 2369
  send_rc(data, (uint16_t )rc);
  }
#line 2370
  return;
}
}
#line 2372 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void release_mounts(mount_t **vec ) 
{ 
  mount_t **tmp ;

  {
  {
#line 2374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2374
    if (! *vec) {
#line 2374
      goto while_break;
    }
    {
#line 2375
    tmp = vec;
#line 2375
    vec ++;
#line 2375
    release_mount(*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2376
  return;
}
}
#line 2378 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static handler_t *alloc_handler(void) 
{ 
  handler_t *h ;
  void *tmp ;

  {
  {
#line 2380
  tmp = calloc((size_t )1, sizeof(handler_t ));
#line 2380
  h = (handler_t *)tmp;
  }
#line 2381
  if (h) {
#line 2382
    h->sd = -1;
#line 2384
    h->in.req_type = (ptype_t )96;
#line 2385
    h->out.data_type = (ptype_t )99;
#line 2386
    h->err.data_type = (ptype_t )101;
#line 2388
    h->error = (bool_t )0;
  }
#line 2391
  return (h);
}
}
#line 2397 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void free_handler(handler_t *data ) 
{ 


  {
#line 2399
  if (data->sd >= 0) {
    {
#line 2400
    close(data->sd);
    }
  }
#line 2402
  if (data->user) {
    {
#line 2403
    free((void *)((char *)data->user));
    }
  }
#line 2405
  if (data->param.target) {
    {
#line 2406
    free((void *)data->param.target);
    }
  }
#line 2408
  if (data->param.mounts) {
    {
#line 2409
    free_vec((void **)data->param.mounts, (free_func_t *)(& mntinfo_free));
    }
  }
#line 2411
  if (data->param.args) {
    {
#line 2412
    free_vec((void **)data->param.args, (free_func_t *)((void *)0));
    }
  }
#line 2414
  if (data->param.cwd) {
    {
#line 2415
    free((void *)data->param.cwd);
    }
  }
#line 2417
  if (data->param.environ) {
    {
#line 2418
    free_vec((void **)data->param.environ, (free_func_t *)((void *)0));
    }
  }
#line 2420
  if (data->param.ids) {
    {
#line 2421
    uint16v_free(data->param.ids);
    }
  }
#line 2423
  if (data->root) {
    {
#line 2424
    free((void *)data->root);
    }
  }
#line 2426
  if (data->in.buf) {
    {
#line 2427
    buf_free(data->in.buf);
    }
  }
#line 2429
  if (data->fakerootkey) {
    {
#line 2430
    free((void *)data->fakerootkey);
    }
  }
  {
#line 2432
  free((void *)data);
  }
#line 2433
  return;
}
}
#line 2435 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void pid_mounts_add(pid_t pid , mount_t **vec ) 
{ 
  pid_mounts_t *pm ;
  pid_mounts_t *node ;
  void *tmp ;

  {
  {
#line 2441
  tmp = calloc((size_t )1, sizeof(pid_mounts_t ));
#line 2441
  pm = (pid_mounts_t *)tmp;
  }
#line 2442
  if (! pm) {
    {
#line 2443
    oom_error();
    }
#line 2444
    return;
  }
#line 2447
  pm->pid = pid;
#line 2448
  pm->mounts = vec;
#line 2452
  if ((unsigned long )pid_mounts == (unsigned long )((void *)0)) {
#line 2453
    pid_mounts = pm;
  } else {
#line 2455
    node = pid_mounts;
    {
#line 2455
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2455
      if (! node->next) {
#line 2455
        goto while_break;
      }
#line 2455
      node = node->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2457
    node->next = pm;
  }
#line 2459
  return;
}
}
#line 2461 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void pid_mounts_del(pid_t pid ) 
{ 
  pid_mounts_t *pm ;
  pid_mounts_t *node ;

  {
#line 2463
  pm = (pid_mounts_t *)((void *)0);
#line 2465
  if (! pid_mounts) {
#line 2466
    return;
  }
#line 2470
  if (pid_mounts->pid == pid) {
#line 2471
    pm = pid_mounts;
#line 2472
    pid_mounts = pm->next;
  } else {
#line 2474
    node = pid_mounts;
    {
#line 2474
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2474
      if (! node->next) {
#line 2474
        goto while_break;
      }
#line 2475
      if ((node->next)->pid == pid) {
#line 2476
        pm = node->next;
#line 2477
        node->next = pm->next;
#line 2478
        goto while_break;
      }
#line 2474
      node = node->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2482
  if (! pm) {
#line 2483
    return;
  }
#line 2485
  if (debug_file) {
    {
#line 2485
    print_debug("Found mounts for pid %d", pid);
    }
  }
#line 2489
  if (pm->mounts) {
    {
#line 2490
    release_mounts(pm->mounts);
#line 2491
    free((void *)pm->mounts);
    }
  }
  {
#line 2494
  free((void *)pm);
  }
#line 2495
  return;
}
}
#line 2497 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void accept_conn(int srvsd ) 
{ 
  struct sockaddr_storage addr ;
  socklen_t len ;
  int clisd ;
  handler_t *data ;
  mount_t **mounts ;
  int action___0 ;
  pid_t pid ;
  int tmp ;

  {
  {
#line 2500
  len = (socklen_t )sizeof(addr);
#line 2503
  mounts = (mount_t **)((void *)0);
#line 2507
  clisd = accept(srvsd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                 (socklen_t */* __restrict  */)(& len));
  }
#line 2508
  if (clisd < 0) {
    {
#line 2509
    error("Can\'t accept connection");
    }
#line 2510
    return;
  }
#line 2513
  if (debug_file) {
    {
#line 2513
    print_debug("New connection");
    }
  }
  {
#line 2515
  data = alloc_handler();
  }
#line 2516
  if (! data) {
    {
#line 2517
    oom_error();
#line 2518
    close(clisd);
    }
#line 2519
    return;
  }
  {
#line 2522
  data->sd = clisd;
#line 2525
  tmp = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                    len, (char */* __restrict  */)(data->host), (socklen_t )sizeof(data->host),
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 1);
  }
#line 2525
  if (tmp < 0) {
    {
#line 2527
    error("Can\'t get client\'s IP address");
    }
#line 2528
    goto _error;
  }
  {
#line 2531
  action___0 = handler_startup(data, & mounts);
  }
#line 2532
  if (action___0 < 0) {
#line 2533
    goto _error;
  }
#line 2535
  if (action___0 == 48) {
    {
#line 2537
    pid = fork();
    }
#line 2538
    if (pid < 0) {
      {
#line 2539
      error("Can\'t fork");
      }
#line 2540
      goto _error;
    }
#line 2544
    if (pid == 0) {
      {
#line 2545
      set_debug_name("HANDLER");
#line 2547
      close(srvsd);
#line 2549
      handler_handle(data);
      }
#line 2551
      if (debug_file) {
        {
#line 2551
        print_debug("Handler process exiting");
        }
      }
      {
#line 2552
      exit(0);
      }
    }
#line 2558
    if (mounts) {
      {
#line 2559
      pid_mounts_add(pid, mounts);
      }
    }
    {
#line 2561
    free_handler(data);
    }
  } else {
    {
#line 2563
    send_rc(data, (uint16_t )0);
#line 2565
    free_handler(data);
#line 2566
    free_vec((void **)mounts, (free_func_t *)(& release_mount));
    }
  }
#line 2569
  return;
  _error: 
  {
#line 2572
  send_rc(data, (uint16_t )32767);
#line 2574
  free_handler(data);
  }
#line 2575
  if (mounts) {
    {
#line 2576
    free((void *)mounts);
    }
  }
#line 2577
  return;
}
}
#line 2582 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void clean_exit(int rc ) 
{ 


  {
  {
#line 2584
  unmount_all();
  }
#line 2586
  if (debug_file) {
    {
#line 2586
    print_debug("sbrshd exiting");
    }
  }
  {
#line 2587
  exit(rc);
  }
}
}
#line 2590 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void sig_dummy(int sig ) 
{ 


  {
#line 2597
  return;
}
}
#line 2602 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void sig_exit(int sig ) 
{ 
  char *tmp ;
  __pid_t tmp___0 ;

  {
#line 2604
  if (debug_file) {
    {
#line 2604
    tmp = strsignal(sig);
#line 2604
    print_debug((char const   *)tmp);
    }
  }
  {
#line 2606
  tmp___0 = getpid();
  }
#line 2606
  if (tmp___0 == daemon_pid) {
    {
#line 2607
    clean_exit(0);
    }
  }
  {
#line 2609
  exit(0);
  }
}
}
#line 2612 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void sig_debug(int sig ) 
{ 
  int stored_errno ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 2614
  tmp = __errno_location();
#line 2614
  stored_errno = *tmp;
  }
#line 2616
  if (debug_file) {
    {
#line 2616
    tmp___0 = strsignal(sig);
#line 2616
    print_debug((char const   *)tmp___0);
    }
  }
  {
#line 2618
  tmp___1 = getpid();
  }
#line 2618
  if (tmp___1 != daemon_pid) {
#line 2619
    goto _ret;
  }
#line 2621
  if (sig == 10) {
    {
#line 2622
    open_debug_log();
    }
  } else
#line 2623
  if (sig == 12) {
    {
#line 2624
    close_debug_log();
    }
  }
  _ret: 
  {
#line 2627
  tmp___2 = __errno_location();
#line 2627
  *tmp___2 = stored_errno;
  }
#line 2628
  return;
}
}
#line 2630 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static char *get_absolute_path(char const   *progname___0 , char *relpath ) 
{ 
  char *tmp1 ;
  char *tmp2 ;
  char *dir ;
  char *file ;
  char *abspath ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 2634
  tmp1 = relpath;
#line 2635
  tmp2 = strdup((char const   *)relpath);
  }
#line 2636
  if (! tmp2) {
    {
#line 2637
    tmp = __errno_location();
#line 2637
    *tmp = 0;
#line 2638
    error_err(progname___0, oom);
#line 2639
    exit(1);
    }
  }
  {
#line 2642
  dir = dirname(tmp1);
#line 2643
  file = __xpg_basename(tmp2);
#line 2645
  tmp___0 = malloc((size_t )4097);
#line 2645
  abspath = (char *)tmp___0;
  }
#line 2646
  if (! abspath) {
    {
#line 2647
    tmp___1 = __errno_location();
#line 2647
    *tmp___1 = 0;
#line 2648
    error_err(progname___0, oom);
#line 2649
    exit(1);
    }
  }
  {
#line 2652
  abspath = realpath((char const   */* __restrict  */)dir, (char */* __restrict  */)abspath);
  }
#line 2653
  if (! abspath) {
    {
#line 2654
    error_err(progname___0, "Can\'t get real path of %s", dir);
#line 2655
    exit(1);
    }
  }
  {
#line 2658
  tmp___2 = strlen((char const   *)abspath);
#line 2658
  tmp___3 = strlen((char const   *)file);
  }
#line 2658
  if ((tmp___2 + 1UL) + tmp___3 > 4096UL) {
    {
#line 2659
    error_err(progname___0, "Path is too long: %s/%s", abspath, file);
#line 2660
    exit(1);
    }
  }
  {
#line 2663
  strcat((char */* __restrict  */)abspath, (char const   */* __restrict  */)"/");
#line 2664
  strcat((char */* __restrict  */)abspath, (char const   */* __restrict  */)file);
#line 2666
  free((void *)tmp2);
  }
#line 2668
  return (abspath);
}
}
#line 2671 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void usage___0(char *progname___0 ) 
{ 


  {
  {
#line 2673
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-p|--port <port>] [-l|--local-only] [-n|--no-sandbox] [-r|--allow-root] [-d|--debug <path>] [-e|--mount-expiration <minutes>|none] [-m|--mount-bin <path>] [-u|--umount-bin <path>] [-S|--sshfs-bin <path>] [-F|--fusermount-bin <path>] [-t|--mount-tab <path>] [-b|--bind-opt <options>]\n       %s add <address>\n       %s -v|--version\n       %s -h|--help\n",
          progname___0, progname___0, progname___0, progname___0);
#line 2690
  exit(0);
  }
}
}
#line 2696 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void read_args___0(char *progname___0 , int argc , char **argv ) 
{ 
  char const   *optstring ;
  struct option longopts[15] ;
  char *debugname ;
  char *exp_str ;
  bool_t default_bind_opt ;
  int c ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2698
  optstring = "hvp:lnird:Ve:m:u:b:";
#line 2699
  longopts[0].name = "help";
#line 2699
  longopts[0].has_arg = 0;
#line 2699
  longopts[0].flag = (int *)0;
#line 2699
  longopts[0].val = 'h';
#line 2699
  longopts[1].name = "version";
#line 2699
  longopts[1].has_arg = 0;
#line 2699
  longopts[1].flag = (int *)0;
#line 2699
  longopts[1].val = 'v';
#line 2699
  longopts[2].name = "port";
#line 2699
  longopts[2].has_arg = 1;
#line 2699
  longopts[2].flag = (int *)0;
#line 2699
  longopts[2].val = 'p';
#line 2699
  longopts[3].name = "local-only";
#line 2699
  longopts[3].has_arg = 0;
#line 2699
  longopts[3].flag = (int *)0;
#line 2699
  longopts[3].val = 'l';
#line 2699
  longopts[4].name = "no-sandbox";
#line 2699
  longopts[4].has_arg = 0;
#line 2699
  longopts[4].flag = (int *)0;
#line 2699
  longopts[4].val = 'n';
#line 2699
  longopts[5].name = "allow-root";
#line 2699
  longopts[5].has_arg = 0;
#line 2699
  longopts[5].flag = (int *)0;
#line 2699
  longopts[5].val = 'r';
#line 2699
  longopts[6].name = "debug";
#line 2699
  longopts[6].has_arg = 1;
#line 2699
  longopts[6].flag = (int *)0;
#line 2699
  longopts[6].val = 'd';
#line 2699
  longopts[7].name = "debug-verbose";
#line 2699
  longopts[7].has_arg = 0;
#line 2699
  longopts[7].flag = (int *)0;
#line 2699
  longopts[7].val = 'V';
#line 2699
  longopts[8].name = "mount-expiration";
#line 2699
  longopts[8].has_arg = 1;
#line 2699
  longopts[8].flag = (int *)0;
#line 2699
  longopts[8].val = 'e';
#line 2699
  longopts[9].name = "mount-bin";
#line 2699
  longopts[9].has_arg = 1;
#line 2699
  longopts[9].flag = (int *)0;
#line 2699
  longopts[9].val = 'm';
#line 2699
  longopts[10].name = "umount-bin";
#line 2699
  longopts[10].has_arg = 1;
#line 2699
  longopts[10].flag = (int *)0;
#line 2699
  longopts[10].val = 'u';
#line 2699
  longopts[11].name = "sshfs-bin";
#line 2699
  longopts[11].has_arg = 1;
#line 2699
  longopts[11].flag = (int *)0;
#line 2699
  longopts[11].val = 'S';
#line 2699
  longopts[12].name = "fusermount-bin";
#line 2699
  longopts[12].has_arg = 1;
#line 2699
  longopts[12].flag = (int *)0;
#line 2699
  longopts[12].val = 'F';
#line 2699
  longopts[13].name = "bind-opt";
#line 2699
  longopts[13].has_arg = 1;
#line 2699
  longopts[13].flag = (int *)0;
#line 2699
  longopts[13].val = 'b';
#line 2699
  longopts[14].name = (char const   *)0;
#line 2699
  longopts[14].has_arg = 0;
#line 2699
  longopts[14].flag = (int *)0;
#line 2699
  longopts[14].val = 0;
#line 2717
  debugname = (char *)((void *)0);
#line 2718
  exp_str = (char *)((void *)0);
#line 2719
  default_bind_opt = (bool_t )1;
  {
#line 2721
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2722
    tmp = getopt_long(argc, (char * const  *)argv, optstring, (struct option  const  *)(longopts),
                      (int *)((void *)0));
#line 2722
    c = tmp;
    }
#line 2723
    if (c < 0) {
#line 2724
      goto while_break;
    }
    {
#line 2727
    if (c == 112) {
#line 2727
      goto case_112;
    }
#line 2731
    if (c == 108) {
#line 2731
      goto case_108;
    }
#line 2735
    if (c == 110) {
#line 2735
      goto case_110;
    }
#line 2739
    if (c == 114) {
#line 2739
      goto case_114;
    }
#line 2743
    if (c == 100) {
#line 2743
      goto case_100;
    }
#line 2747
    if (c == 86) {
#line 2747
      goto case_86;
    }
#line 2751
    if (c == 101) {
#line 2751
      goto case_101;
    }
#line 2755
    if (c == 109) {
#line 2755
      goto case_109;
    }
#line 2759
    if (c == 117) {
#line 2759
      goto case_117;
    }
#line 2763
    if (c == 83) {
#line 2763
      goto case_83;
    }
#line 2767
    if (c == 70) {
#line 2767
      goto case_70;
    }
#line 2771
    if (c == 98) {
#line 2771
      goto case_98;
    }
#line 2776
    if (c == 118) {
#line 2776
      goto case_118;
    }
#line 2783
    goto switch_default;
    case_112: /* CIL Label */ 
#line 2728
    port = optarg;
#line 2729
    goto switch_break;
    case_108: /* CIL Label */ 
#line 2732
    local_only = (bool_t )1;
#line 2733
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2736
    sandbox = (bool_t )0;
#line 2737
    goto switch_break;
    case_114: /* CIL Label */ 
#line 2740
    allow_root = (bool_t )1;
#line 2741
    goto switch_break;
    case_100: /* CIL Label */ 
#line 2744
    debugname = optarg;
#line 2745
    goto switch_break;
    case_86: /* CIL Label */ 
#line 2748
    debug_verbose_flag = (int )((bool_t )1);
#line 2749
    goto switch_break;
    case_101: /* CIL Label */ 
#line 2752
    exp_str = optarg;
#line 2753
    goto switch_break;
    case_109: /* CIL Label */ 
#line 2756
    mount_cmd = optarg;
#line 2757
    goto switch_break;
    case_117: /* CIL Label */ 
#line 2760
    umount_cmd = optarg;
#line 2761
    goto switch_break;
    case_83: /* CIL Label */ 
#line 2764
    sshfs_cmd = optarg;
#line 2765
    goto switch_break;
    case_70: /* CIL Label */ 
#line 2768
    fusermount_cmd = optarg;
#line 2769
    goto switch_break;
    case_98: /* CIL Label */ 
#line 2772
    bind_opt = optarg;
#line 2773
    default_bind_opt = (bool_t )0;
#line 2774
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 2777
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scratchbox Remote Shell daemon %d%s\n",
            7, ".6");
#line 2779
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 2784
    usage___0(progname___0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2788
  if (exp_str) {
    {
#line 2789
    tmp___2 = strcmp((char const   *)exp_str, "none");
    }
#line 2789
    if (tmp___2 == 0) {
#line 2790
      mount_expiration = -1;
    } else {
      {
#line 2792
      tmp___1 = strcmp((char const   *)exp_str, "0");
      }
#line 2792
      if (tmp___1 == 0) {
#line 2793
        mount_expiration = 0;
      } else {
        {
#line 2796
        tmp___0 = atoi((char const   *)exp_str);
#line 2796
        i = tmp___0;
        }
#line 2797
        if (i <= 0) {
          {
#line 2798
          error_err((char const   *)progname___0, "Invalid expiration time: %s minutes",
                    exp_str);
#line 2799
          exit(1);
          }
        }
#line 2801
        mount_expiration = i * 60;
      }
    }
  }
#line 2806
  if (debugname) {
    {
#line 2807
    debug_filename = get_absolute_path((char const   *)progname___0, debugname);
    }
  }
#line 2809
  if (default_bind_opt) {
    {
#line 2810
    check_for_busybox((char const   *)progname___0);
    }
  }
#line 2811
  return;
}
}
#line 2818 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
int daemonize(int listenfd ) 
{ 
  int debugfd ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2822
  chdir("/");
#line 2823
  umask((__mode_t )0);
  }
#line 2826
  if (debug_file) {
    {
#line 2826
    tmp = fileno(debug_file);
#line 2826
    debugfd = tmp;
    }
  } else {
#line 2826
    debugfd = -1;
  }
  {
#line 2828
  fd = getdtablesize();
  }
  {
#line 2828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2828
    tmp___0 = fd;
#line 2828
    fd --;
#line 2828
    if (! (tmp___0 > 0)) {
#line 2828
      goto while_break;
    }
#line 2829
    if (fd != listenfd) {
#line 2829
      if (fd != debugfd) {
        {
#line 2830
        close(fd);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2832
  fd = open("/dev/null", 2);
  }
#line 2833
  if (fd < 0) {
    {
#line 2834
    error("Can\'t open /dev/null");
    }
#line 2835
    return (-1);
  }
#line 2840
  if (debugfd >= 0) {
#line 2841
    fd = debugfd;
  }
  {
#line 2843
  tmp___1 = dup2(fd, 1);
  }
#line 2843
  if (tmp___1 != 1) {
    {
#line 2844
    error("Can\'t duplicate descriptor %d as stdout", fd);
    }
#line 2845
    return (-1);
  }
  {
#line 2848
  tmp___2 = dup2(fd, 2);
  }
#line 2848
  if (tmp___2 != 2) {
    {
#line 2849
    error("Can\'t duplicate descriptor %d as stderr", fd);
    }
#line 2850
    return (-1);
  }
#line 2853
  return (0);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static unsigned int volatile   parent_alive  =    (bool_t volatile   )((bool_t )1);
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int volatile   listen_sd  =    (int volatile   )-1;
#line 43 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static uint32_t relay_id  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void append_node(handler_t *data , node_t **head , int client_sd , int daemon_sd ) 
{ 
  node_t *node ;
  node_t *n ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 49
  tmp = calloc((size_t )1, sizeof(node_t ));
#line 49
  node = (node_t *)tmp;
  }
#line 50
  if (! node) {
    {
#line 51
    tmp___0 = __errno_location();
#line 51
    *tmp___0 = 0;
#line 52
    send_error(data, oom);
#line 53
    exit(1);
    }
  }
#line 56
  node->client = client_sd;
#line 57
  node->daemon = daemon_sd;
#line 59
  if (*head) {
#line 60
    n = *head;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! n->next) {
#line 60
        goto while_break;
      }
#line 60
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 61
    n->next = node;
  } else {
#line 63
    *head = node;
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void remove_node(node_t **head , node_t *node ) 
{ 
  node_t *n ;

  {
#line 71
  if ((unsigned long )*head == (unsigned long )node) {
#line 72
    *head = node->next;
  } else {
#line 74
    n = *head;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! ((unsigned long )n->next != (unsigned long )node)) {
#line 74
        goto while_break;
      }
#line 74
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 75
    n->next = node->next;
  }
#line 78
  if (debug_file) {
    {
#line 78
    print_debug("Removing node: client=%d, daemon=%d", node->client, node->daemon);
    }
  }
  {
#line 80
  close(node->client);
#line 81
  close(node->daemon);
#line 83
  free((void *)node);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void get_device_numbers(handler_t *data ) 
{ 
  mount_t **ptr ;
  mount_t *m ;
  struct stat buf ;
  int tmp ;

  {
#line 90
  if (! data->mounts) {
#line 91
    if (debug_file) {
      {
#line 91
      print_debug("No mounts");
      }
    }
#line 92
    return;
  }
#line 95
  ptr = data->mounts;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! *ptr) {
#line 95
      goto while_break;
    }
#line 96
    m = *ptr;
#line 98
    if ((unsigned int )m->info.type != 2U) {
#line 98
      if ((long long )m->point_dev == 0LL) {
        {
#line 101
        tmp = stat((char const   */* __restrict  */)m->info.point, (struct stat */* __restrict  */)(& buf));
        }
#line 101
        if (tmp < 0) {
          {
#line 102
          send_error(data, "Can\'t stat %s", m->info.point);
#line 103
          exit(1);
          }
        }
#line 106
        m->point_dev = buf.st_dev;
#line 108
        if (debug_file) {
          {
#line 108
          print_debug("Device number of %s is %lld", m->info.device, m->info.device_dev);
          }
        }
#line 109
        if (debug_file) {
          {
#line 109
          print_debug("Device number of %s is %lld", m->info.point, m->point_dev);
          }
        }
      }
    }
#line 95
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static bool_t translate_dev(handler_t *data , node_t *node , struct fakestat *st ) 
{ 
  mount_t **ptr ;
  fake_dev_t old ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  mount_t const   *m ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 117
  tmp = ntohl((uint32_t )st->dev);
#line 117
  tmp___0 = ntohl((uint32_t )(st->dev >> 32LL));
#line 117
  old = ((uint64_t )tmp << 32LL) | (unsigned long )tmp___0;
#line 119
  node->stored_dev = st->dev;
  }
#line 121
  if (! data->mounts) {
#line 122
    if (debug_file) {
      {
#line 122
      print_debug("No mounts");
      }
    }
#line 123
    return ((bool_t )0);
  }
#line 126
  ptr = data->mounts;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! *ptr) {
#line 126
      goto while_break;
    }
#line 127
    m = (mount_t const   *)*ptr;
#line 129
    if (old == (fake_dev_t )m->point_dev) {
#line 130
      if (debug_file) {
        {
#line 130
        print_debug("Translating device number: %lld -> %lld", old, m->info.device_dev);
        }
      }
      {
#line 132
      tmp___1 = htonl((uint32_t )m->info.device_dev);
#line 132
      tmp___2 = htonl((uint32_t )(m->info.device_dev >> 32LL));
#line 132
      st->dev = ((uint64_t )tmp___1 << 32LL) | (unsigned long )tmp___2;
      }
#line 133
      return ((bool_t )1);
    }
#line 126
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (debug_file) {
    {
#line 137
    print_debug("No match for device number %lld", old);
    }
  }
#line 138
  return ((bool_t )0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void restore_dev(node_t *node , struct fakestat *st ) 
{ 


  {
#line 143
  if (debug_file) {
    {
#line 143
    print_debug("Restoring device number");
    }
  }
#line 145
  st->dev = node->stored_dev;
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int copy_msg(handler_t *data , node_t *node , direction_t direction ) 
{ 
  int source ;
  int destination ;
  struct fake_msg buf ;
  ssize_t len ;
  int *tmp ;
  uint32_t tmp___0 ;
  bool_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
#line 154
  if ((unsigned int )direction == 1U) {
#line 155
    source = node->client;
#line 156
    destination = node->daemon;
#line 158
    if (debug_file) {
      {
#line 158
      print_debug("Processing message from client=%d", source);
      }
    }
  } else {
#line 160
    source = node->daemon;
#line 161
    destination = node->client;
#line 163
    if (debug_file) {
      {
#line 163
      print_debug("Processing message from daemon=%d", source);
      }
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    len = read(source, (void *)(& buf), sizeof(buf));
    }
#line 168
    if (len >= 0L) {
#line 169
      goto while_break;
    }
    {
#line 171
    tmp = __errno_location();
    }
#line 171
    if (*tmp != 4) {
      {
#line 172
      send_error(data, "Can\'t read from socket");
#line 173
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (len == 0L) {
#line 178
    if (debug_file) {
      {
#line 178
      print_debug("No message");
      }
    }
#line 179
    return (-1);
  }
#line 182
  if ((unsigned int )direction == 1U) {
    {
#line 183
    tmp___1 = translate_dev(data, node, & buf.st);
    }
#line 183
    if (tmp___1) {
      {
#line 184
      buf.remote = htonl((uint32_t )0);
      }
    } else {
      {
#line 185
      tmp___0 = ntohl(buf.remote);
      }
#line 185
      if (tmp___0 == 0U) {
#line 186
        if (debug_file) {
          {
#line 186
          print_debug("Setting remote ID");
          }
        }
        {
#line 187
        buf.remote = htonl(relay_id);
        }
      }
    }
  } else {
    {
#line 190
    restore_dev(node, & buf.st);
    }
  }
#line 193
  if ((unsigned int )direction == 1U) {
#line 194
    if (debug_file) {
      {
#line 194
      print_debug("Forwarding message to daemon=%d", destination);
      }
    }
  } else
#line 196
  if (debug_file) {
    {
#line 196
    print_debug("Forwarding message to client=%d", destination);
    }
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 200
    tmp___2 = write(destination, (void const   *)(& buf), sizeof(buf));
    }
#line 200
    if (tmp___2 >= 0L) {
#line 201
      goto while_break___0;
    }
    {
#line 203
    tmp___3 = __errno_location();
    }
#line 203
    if (*tmp___3 != 4) {
      {
#line 204
      send_error(data, "Can\'t write to socket");
#line 205
      exit(1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int get_daemon(handler_t *data , struct sockaddr_in *addr ) 
{ 
  int sd___0 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 216
  sd___0 = socket(2, 1, 0);
  }
#line 217
  if (sd___0 < 0) {
    {
#line 218
    send_error(data, "Can\'t create socket");
#line 219
    exit(1);
    }
  }
  {
#line 222
  tmp___0 = connect(sd___0, (struct sockaddr  const  *)((struct sockaddr *)addr),
                    (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 222
  if (tmp___0 < 0) {
    {
#line 223
    tmp = __errno_location();
    }
#line 223
    if (*tmp == 4) {
#line 224
      if (debug_file) {
        {
#line 224
        print_debug("Connect interrupted");
        }
      }
      {
#line 225
      exit(0);
      }
    }
    {
#line 228
    send_error(data, "Connect failed");
#line 229
    exit(1);
    }
  }
#line 232
  if (debug_file) {
    {
#line 232
    print_debug("Connected to daemon=%d", sd___0);
    }
  }
#line 234
  return (sd___0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int get_client(handler_t *data ) 
{ 
  struct sockaddr_in addr ;
  socklen_t len ;
  int sd___0 ;
  int *tmp ;

  {
  {
#line 240
  len = (socklen_t )sizeof(addr);
#line 243
  sd___0 = accept((int )listen_sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                  (socklen_t */* __restrict  */)(& len));
  }
#line 244
  if (sd___0 < 0) {
    {
#line 245
    tmp = __errno_location();
    }
#line 245
    if (*tmp == 4) {
#line 246
      if (debug_file) {
        {
#line 246
        print_debug("Accept interrupted");
        }
      }
      {
#line 247
      exit(0);
      }
    }
    {
#line 250
    send_error(data, "Accept failed");
#line 251
    exit(1);
    }
  }
#line 254
  if (debug_file) {
    {
#line 254
    print_debug("Connection from client=%d", sd___0);
    }
  }
#line 256
  return (sd___0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void do_relay(handler_t *data , int port___0 ) 
{ 
  struct hostent *host ;
  struct sockaddr_in addr ;
  node_t *sd_head ;
  fd_set fds ;
  int maxfd ;
  int count ;
  node_t *n ;
  node_t *next ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int cli ;
  int dae ;

  {
  {
#line 262
  addr.sin_family = (sa_family_t )0;
#line 262
  addr.sin_port = (unsigned short)0;
#line 262
  addr.sin_addr.s_addr = 0U;
#line 262
  addr.sin_zero[0] = (unsigned char)0;
#line 262
  addr.sin_zero[1] = (unsigned char)0;
#line 262
  addr.sin_zero[2] = (unsigned char)0;
#line 262
  addr.sin_zero[3] = (unsigned char)0;
#line 262
  addr.sin_zero[4] = (unsigned char)0;
#line 262
  addr.sin_zero[5] = (unsigned char)0;
#line 262
  addr.sin_zero[6] = (unsigned char)0;
#line 262
  addr.sin_zero[7] = (unsigned char)0;
#line 263
  sd_head = (node_t *)((void *)0);
#line 266
  host = gethostbyname((char const   *)(data->host));
  }
#line 267
  if (! host) {
    {
#line 268
    send_error(data, "Can\'t resolve host: %s", data->host);
#line 269
    exit(1);
    }
  }
  {
#line 272
  addr.sin_family = (sa_family_t )2;
#line 273
  addr.sin_addr.s_addr = *((unsigned int *)*(host->h_addr_list + 0));
#line 274
  addr.sin_port = htons((uint16_t )port___0);
  }
#line 276
  if (debug_file) {
    {
#line 276
    print_debug("Fakeroot daemon assumed to be at %s:%d", data->host, port___0);
    }
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! parent_alive) {
#line 278
      goto while_break;
    }
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 282
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 282
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 284
    fds.__fds_bits[listen_sd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] |= 1L << listen_sd % (int volatile   )(8 * (int )sizeof(__fd_mask ));
#line 285
    maxfd = (int )listen_sd;
#line 287
    n = sd_head;
#line 287
    count = 0;
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 287
      if (! n) {
#line 287
        goto while_break___1;
      }
#line 288
      fds.__fds_bits[n->daemon / (8 * (int )sizeof(__fd_mask ))] |= 1L << n->daemon % (8 * (int )sizeof(__fd_mask ));
#line 289
      fds.__fds_bits[n->client / (8 * (int )sizeof(__fd_mask ))] |= 1L << n->client % (8 * (int )sizeof(__fd_mask ));
#line 290
      if (maxfd > n->daemon) {
#line 290
        maxfd = maxfd;
      } else {
#line 290
        maxfd = n->daemon;
      }
#line 291
      if (maxfd > n->client) {
#line 291
        maxfd = maxfd;
      } else {
#line 291
        maxfd = n->client;
      }
#line 287
      n = n->next;
#line 287
      count ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 294
    if (debug_file) {
      {
#line 294
      print_debug("Selecting (%d nodes)", count);
      }
    }
    {
#line 296
    tmp___0 = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 296
    if (tmp___0 < 0) {
#line 297
      if (! parent_alive) {
#line 298
        if (debug_file) {
          {
#line 298
          print_debug("SIGEXIT caught during select call");
          }
        }
#line 299
        goto while_break;
      }
      {
#line 302
      tmp = __errno_location();
      }
#line 302
      if (*tmp == 4) {
#line 303
        if (debug_file) {
          {
#line 303
          print_debug("Select interrupted");
          }
        }
#line 304
        goto while_continue;
      }
      {
#line 307
      send_error(data, "Select failed");
#line 308
      exit(1);
      }
    }
#line 311
    n = sd_head;
    {
#line 311
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 311
      if (! n) {
#line 311
        goto while_break___2;
      }
#line 312
      next = n->next;
#line 314
      if ((fds.__fds_bits[n->daemon / (8 * (int )sizeof(__fd_mask ))] & (1L << n->daemon % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 314
        tmp___1 = copy_msg(data, n, (direction_t )0);
        }
#line 314
        if (tmp___1 < 0) {
          {
#line 315
          remove_node(& sd_head, n);
          }
#line 316
          goto __Cont;
        }
      }
#line 319
      if ((fds.__fds_bits[n->client / (8 * (int )sizeof(__fd_mask ))] & (1L << n->client % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 319
        tmp___2 = copy_msg(data, n, (direction_t )1);
        }
#line 319
        if (tmp___2 < 0) {
          {
#line 320
          remove_node(& sd_head, n);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 311
      n = next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 324
    if ((fds.__fds_bits[listen_sd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] & (1L << listen_sd % (int volatile   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 327
      cli = get_client(data);
#line 328
      dae = get_daemon(data, & addr);
#line 330
      append_node(data, & sd_head, cli, dae);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if (debug_file) {
    {
#line 334
    print_debug("Exiting");
    }
  }
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void sig_exit___0(int sig ) 
{ 
  int stored_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 339
  tmp = __errno_location();
#line 339
  stored_errno = *tmp;
#line 341
  parent_alive = (unsigned int volatile   )((bool_t )0);
  }
#line 343
  if (listen_sd >= (int volatile   )0) {
    {
#line 344
    close((int )listen_sd);
    }
  }
  {
#line 346
  tmp___0 = __errno_location();
#line 346
  *tmp___0 = stored_errno;
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static pid_t fork_relay(handler_t *data , uint16_t *portp ) 
{ 
  int faked_port ;
  int sd___0 ;
  struct sockaddr_in addr ;
  socklen_t len ;
  uint32_t id ;
  pid_t pid ;
  struct sigaction act_exit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 358
  faked_port = (int )*portp;
#line 360
  sd___0 = socket(2, 1, 0);
  }
#line 361
  if (sd___0 < 0) {
    {
#line 362
    send_error(data, "Can\'t create socket");
    }
#line 363
    return (-1);
  }
  {
#line 366
  tmp = setsockopt_bool(sd___0, 1, 2, (bool_t )1);
  }
#line 366
  if (tmp) {
    {
#line 367
    send_error(data, "Can\'t set socket option: SO_REUSEADDR");
    }
#line 368
    goto _error;
  }
  {
#line 371
  tmp___0 = listen(sd___0, 128);
  }
#line 371
  if (tmp___0 < 0) {
    {
#line 372
    send_error(data, "Can\'t listen to socket");
    }
#line 373
    goto _error;
  }
  {
#line 376
  len = (socklen_t )sizeof(addr);
#line 377
  tmp___1 = getsockname(sd___0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 377
  if (tmp___1 < 0) {
    {
#line 378
    send_error(data, "Can\'t get name of relay listening socket");
    }
#line 379
    goto _error;
  }
  {
#line 382
  *portp = ntohs(addr.sin_port);
#line 384
  len = (socklen_t )sizeof(addr);
#line 385
  tmp___2 = getsockname(data->sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 385
  if (tmp___2 < 0) {
    {
#line 386
    send_error(data, "Can\'t get name of client connection socket");
    }
#line 387
    goto _error;
  }
  {
#line 390
  id = ntohl(addr.sin_addr.s_addr);
#line 392
  pid = fork();
  }
#line 393
  if (pid < 0) {
    {
#line 394
    send_error(data, "Can\'t fork");
    }
#line 395
    goto _error;
  }
#line 398
  if (pid > 0) {
    {
#line 400
    close(sd___0);
    }
#line 401
    return (pid);
  }
  {
#line 406
  set_debug_name("RELAY");
  }
#line 407
  if (debug_file) {
    {
#line 407
    print_debug("Relaying fakeroot messages at port %d", (int )*portp);
    }
  }
#line 408
  if (debug_file) {
    {
#line 408
    print_debug("Remote ID of this relay is 0x%lx", id);
    }
  }
  {
#line 410
  daemonize(sd___0);
#line 412
  act_exit.__sigaction_handler.sa_handler = & sig_exit___0;
#line 413
  sigemptyset(& act_exit.sa_mask);
#line 414
  act_exit.sa_flags = 0;
#line 416
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& act_exit), (struct sigaction */* __restrict  */)((void *)0));
#line 417
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act_exit), (struct sigaction */* __restrict  */)((void *)0));
#line 419
  get_device_numbers(data);
#line 421
  listen_sd = (int volatile   )sd___0;
#line 422
  relay_id = id;
#line 424
  do_relay(data, faked_port);
#line 425
  exit(0);
  }
  _error: 
  {
#line 428
  close(sd___0);
  }
#line 429
  return (-1);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
int fakeroot_relay(handler_t *data ) 
{ 
  char **old_environ ;
  char *str ;
  uint16_t port___0 ;
  pid_t pid ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 439
  old_environ = environ;
#line 440
  environ = data->param.environ;
#line 441
  str = getenv("FAKEROOTKEY");
#line 442
  environ = old_environ;
  }
#line 444
  if (! str) {
#line 445
    return (0);
  } else
#line 444
  if (! *str) {
#line 445
    return (0);
  }
#line 447
  if (debug_file) {
    {
#line 447
    print_debug("Creating relay process");
    }
  }
  {
#line 449
  tmp = atoi((char const   *)str);
#line 449
  port___0 = (uint16_t )tmp;
  }
#line 450
  if ((int )port___0 == 0) {
    {
#line 451
    send_error(data, "Invalid FAKEROOTKEY: %s", str);
    }
#line 452
    return (-1);
  }
  {
#line 455
  pid = fork_relay(data, & port___0);
  }
#line 456
  if (pid < 0) {
#line 457
    return (-1);
  }
  {
#line 459
  tmp___0 = strlen("FAKEROOTKEY");
#line 459
  tmp___1 = malloc(((tmp___0 + 1UL) + 5UL) + 1UL);
#line 459
  data->fakerootkey = (char *)tmp___1;
  }
#line 460
  if (! data->fakerootkey) {
    {
#line 461
    tmp___2 = __errno_location();
#line 461
    *tmp___2 = 0;
#line 462
    send_error(data, oom);
    }
#line 463
    goto _kill;
  }
  {
#line 466
  sprintf((char */* __restrict  */)data->fakerootkey, (char const   */* __restrict  */)"FAKEROOTKEY=%d",
          (int )port___0);
  }
#line 468
  return (pid);
  _kill: 
  {
#line 471
  kill(pid, 15);
  }
#line 472
  return (-1);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static int resolve_nfs___0(char const   *fs , uint32_t *addr_p , char **path_p ) 
{ 
  char host[64] ;
  char *path ;
  uint32_t addr ;
  unsigned long tmp ;

  {
  {
#line 153
  path = strchr(fs, ':');
  }
#line 154
  if (! path) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  } else
#line 154
  if ((int )*(path + 1) == 0) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  }
  {
#line 159
  memset((void *)(host), '\000', sizeof(host));
  }
#line 160
  if ((unsigned long )(path - (char *)fs) < sizeof(host) - 1UL) {
#line 160
    tmp = (unsigned long )(path - (char *)fs);
  } else {
#line 160
    tmp = sizeof(host) - 1UL;
  }
  {
#line 160
  strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)fs, tmp);
#line 162
  addr = resolve((char const   *)(host));
  }
#line 163
  if (! addr) {
#line 164
    return (-1);
  }
#line 166
  *addr_p = addr;
#line 167
  *path_p = path + 1;
#line 169
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *get_local_path___0(uint32_t r_addr , char *r_path ) 
{ 
  FILE *file ;
  char buf[1024] ;
  struct __anonstruct_sel_57___0 sel ;
  char *device ;
  char *point ;
  char *type ;
  char *nfs_path ;
  uint32_t nfs_addr ;
  ssize_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 182
  sel.path = (char *)((void *)0);
#line 184
  file = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 185
  if (! file) {
    {
#line 186
    error("Can\'t open /proc/mounts");
    }
#line 187
    return ((char *)((void *)0));
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    tmp = read_line(file, buf, sizeof(buf));
    }
#line 194
    if (tmp < 0L) {
#line 195
      goto while_break;
    }
    {
#line 197
    split_string(buf, & device, & point, & type, (void *)0);
    }
#line 198
    if (! device) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! point) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! type) {
#line 199
      goto while_continue;
    } else {
      {
#line 198
      tmp___0 = strchr((char const   *)device, ':');
      }
#line 198
      if (tmp___0) {
        {
#line 198
        tmp___1 = strcmp((char const   *)type, "nfs");
        }
#line 198
        if (tmp___1 != 0) {
#line 199
          goto while_continue;
        }
      } else {
#line 199
        goto while_continue;
      }
    }
    {
#line 201
    tmp___2 = resolve_nfs___0((char const   *)device, & nfs_addr, & nfs_path);
    }
#line 201
    if (tmp___2 < 0) {
#line 202
      goto _err;
    }
#line 204
    if (r_addr != nfs_addr) {
#line 205
      goto while_continue;
    }
    {
#line 207
    tmp___3 = strlen((char const   *)nfs_path);
#line 207
    tmp___4 = strncmp((char const   *)r_path, (char const   *)nfs_path, tmp___3);
    }
#line 207
    if (tmp___4 != 0) {
#line 208
      goto while_continue;
    }
#line 212
    if (sel.path) {
      {
#line 213
      tmp___5 = strlen((char const   *)(sel.nfs_path));
#line 213
      tmp___6 = strlen((char const   *)nfs_path);
      }
#line 213
      if (tmp___5 < tmp___6) {
#line 214
        goto while_continue;
      }
      {
#line 216
      free((void *)sel.path);
      }
    }
    {
#line 219
    sel.path = strdup((char const   *)point);
    }
#line 220
    if (! sel.path) {
      {
#line 221
      oom_error();
      }
#line 222
      goto _err;
    }
    {
#line 225
    memset((void *)(sel.nfs_path), '\000', sizeof(sel.nfs_path));
#line 226
    strncpy((char */* __restrict  */)(sel.nfs_path), (char const   */* __restrict  */)nfs_path,
            sizeof(sel.nfs_path) - 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  fclose(file);
  }
#line 231
  if (sel.path) {
#line 232
    return (sel.path);
  } else {
#line 234
    return (r_path);
  }
  _err: 
#line 237
  if (sel.path) {
    {
#line 238
    free((void *)sel.path);
    }
  }
  {
#line 240
  fclose(file);
  }
#line 242
  return ((char *)((void *)0));
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *scratchbox_path_alias___0(char const   * const  path ) 
{ 
  char const   *scratchbox ;
  size_t scratchbox_len ;
  size_t tmp ;
  char *alias ;
  char *renamed ;
  size_t alias_len ;
  size_t renamed_len ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 247
  scratchbox = "/scratchbox/";
#line 248
  tmp = strlen(scratchbox);
#line 248
  scratchbox_len = tmp;
#line 253
  alias = getenv("_SBOX_DIR");
  }
#line 254
  if (! alias) {
#line 255
    return ((char *)((void *)0));
  }
  {
#line 257
  alias_len = strlen((char const   *)alias);
  }
#line 258
  if (alias_len <= 1UL) {
#line 259
    return ((char *)((void *)0));
  } else {
    {
#line 258
    tmp___0 = strncmp((char const   *)path, (char const   *)alias, alias_len);
    }
#line 258
    if (tmp___0 != 0) {
#line 259
      return ((char *)((void *)0));
    }
  }
  {
#line 261
  tmp___1 = strlen((char const   *)path);
#line 261
  renamed_len = ((tmp___1 - alias_len) + scratchbox_len) + 1UL;
#line 262
  tmp___2 = malloc(renamed_len);
#line 262
  renamed = (char *)tmp___2;
  }
#line 263
  if (! renamed) {
    {
#line 264
    oom_error();
    }
#line 265
    return ((char *)((void *)0));
  }
  {
#line 268
  strcpy((char */* __restrict  */)renamed, (char const   */* __restrict  */)scratchbox);
#line 269
  strcat((char */* __restrict  */)renamed, (char const   */* __restrict  */)(path + alias_len));
  }
#line 271
  return (renamed);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
static ssize_t do_read_line___0(FILE *file , char *buf , size_t size , char comment_char ,
                                bool_t *blankp ) 
{ 
  bool_t blank ;
  bool_t comm ;
  size_t i ;
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 151
  blank = (bool_t )1;
#line 152
  comm = (bool_t )0;
#line 153
  i = (size_t )0;
#line 156
  tmp = feof(file);
  }
#line 156
  if (tmp) {
#line 157
    return ((ssize_t )-1);
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    c = fgetc(file);
    }
#line 161
    if (c == -1) {
#line 162
      goto while_break;
    } else
#line 161
    if (c == 10) {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp___0 = __ctype_b_loc();
    }
#line 164
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 165
      blank = (bool_t )0;
    }
#line 167
    if (c == (int )comment_char) {
#line 168
      comm = (bool_t )1;
    }
#line 170
    if (! comm) {
#line 170
      if (i < size - 1UL) {
#line 171
        tmp___1 = buf;
#line 171
        buf ++;
#line 171
        *tmp___1 = (char )c;
#line 172
        i ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *buf = (char )'\000';
#line 177
  if (blankp) {
#line 178
    *blankp = blank;
  }
#line 180
  return ((ssize_t )i);
}
}
