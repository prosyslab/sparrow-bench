/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.h"
enum redir_state {
    REDIR_NONE = 0,
    REDIR_CONNECT = 1,
    REDIR_INIT = 2,
    REDIR_AUTH = 3,
    REDIR_INIT_SOL = 10,
    REDIR_RUN_SOL = 11,
    REDIR_INIT_IDER = 20,
    REDIR_RUN_IDER = 21,
    REDIR_CLOSING = 30,
    REDIR_CLOSED = 31,
    REDIR_ERROR = 40
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.h"
struct redir {
   unsigned char host[64] ;
   unsigned char port[16] ;
   unsigned char user[64] ;
   unsigned char pass[64] ;
   unsigned char type[4] ;
   int verbose ;
   int trace ;
   enum redir_state state ;
   unsigned char err[128] ;
   int sock ;
   unsigned char buf[64] ;
   unsigned int blen ;
   void *cb_data ;
   void (*cb_state)(void *cb_data , enum redir_state old , enum redir_state new ) ;
   int (*cb_recv)(void *cb_data , unsigned char *buf , int len ) ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.h"
struct controls_from_host_message {
   unsigned char type ;
   unsigned char reserved[3] ;
   uint32_t host_sequence_number ;
   unsigned char control ;
   unsigned char status ;
} __attribute__((__packed__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   HEARTBEAT_INTERVAL  =    (unsigned short const   )5000;
#line 50 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.h"
char const   *redir_state_name(enum redir_state state ) ;
#line 51
char const   *redir_state_desc(enum redir_state state ) ;
#line 53
int redir_connect(struct redir *r ) ;
#line 54
int redir_start(struct redir *r ) ;
#line 58
int redir_sol_stop(struct redir *r ) ;
#line 59
int redir_sol_send(struct redir *r , unsigned char *buf , int blen ) ;
#line 61
int redir_data(struct redir *r ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static int recv_tty(void *cb_data , unsigned char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 42
  tmp = write(1, (void const   *)buf, (size_t )len);
  }
#line 42
  return ((int )tmp);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void state_tty(void *cb_data , enum redir_state old , enum redir_state new ) 
{ 
  struct redir *r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 47
  r = (struct redir *)cb_data;
#line 49
  if (r->verbose) {
    {
#line 50
    tmp = redir_state_desc(new);
#line 50
    tmp___0 = redir_state_name(new);
#line 50
    tmp___1 = redir_state_name(old);
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"amtterm: %s -> %s (%s)\n",
            tmp___1, tmp___0, tmp);
    }
  }
  {
#line 54
  if ((unsigned int )new == 11U) {
#line 54
    goto case_11;
  }
#line 60
  if ((unsigned int )new == 40U) {
#line 60
    goto case_40;
  }
#line 63
  goto switch_default;
  case_11: /* CIL Label */ 
#line 55
  if (r->verbose) {
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"serial-over-lan redirection ok\nconnected now, use ^] to escape\n");
    }
  }
#line 59
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"amtterm: ERROR: %s\n",
          r->err);
  }
#line 62
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static int redir_loop(struct redir *r ) 
{ 
  unsigned char buf[513] ;
  struct timeval tv ;
  int rc ;
  int i ;
  fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if ((unsigned int )r->state == 31U) {
#line 78
      goto while_break;
    } else
#line 76
    if ((unsigned int )r->state == 40U) {
#line 78
      goto while_break;
    }
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 80
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    if ((unsigned int )r->state == 11U) {
#line 82
      set.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 83
    set.__fds_bits[r->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->sock % (8 * (int )sizeof(__fd_mask ));
#line 84
    tv.tv_sec = (__time_t )(((int const   )HEARTBEAT_INTERVAL * 4) / 1000);
#line 85
    tv.tv_usec = (__suseconds_t )0;
#line 86
    tmp = select(r->sock + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 87
    if (tmp == -1) {
#line 87
      goto case_neg_1;
    }
#line 90
    if (tmp == 0) {
#line 90
      goto case_0;
    }
#line 86
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 88
    perror("select");
    }
#line 89
    return (-1);
    case_0: /* CIL Label */ 
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"select: timeout\n");
    }
#line 92
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 95
    if ((set.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 97
      tmp___0 = read(0, (void *)(buf), (size_t )512);
#line 97
      rc = (int )tmp___0;
      }
      {
#line 99
      if (rc == -1) {
#line 99
        goto case_neg_1___0;
      }
#line 102
      if (rc == 0) {
#line 102
        goto case_0___0;
      }
#line 105
      goto switch_default;
      case_neg_1___0: /* CIL Label */ 
      {
#line 100
      perror("read(stdin)");
      }
#line 101
      return (-1);
      case_0___0: /* CIL Label */ 
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF from stdin\n");
      }
#line 104
      return (-1);
      switch_default: /* CIL Label */ 
#line 106
      if ((int )buf[0] == 29) {
#line 107
        if (r->verbose) {
          {
#line 108
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\namtterm: saw ^], exiting\n");
          }
        }
        {
#line 109
        redir_sol_stop(r);
        }
      }
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 111
        if (! (i < rc)) {
#line 111
          goto while_break___1;
        }
#line 113
        if ((int )buf[i] == 10) {
#line 114
          buf[i] = (unsigned char)13;
        }
#line 111
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___1 = redir_sol_send(r, buf, rc);
      }
#line 116
      if (-1 == tmp___1) {
#line 117
        return (-1);
      }
#line 118
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 122
    if ((set.__fds_bits[r->sock / (8 * (int )sizeof(__fd_mask ))] & (1L << r->sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 123
      tmp___2 = redir_data(r);
      }
#line 123
      if (-1 == tmp___2) {
#line 124
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
struct termios saved_attributes  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
int saved_fl  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void tty_save(void) 
{ 


  {
  {
#line 137
  fcntl(0, 3, & saved_fl);
#line 138
  tcgetattr(0, & saved_attributes);
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void tty_noecho(void) 
{ 
  struct termios tattr ;

  {
  {
#line 145
  memcpy((void */* __restrict  */)(& tattr), (void const   */* __restrict  */)(& saved_attributes),
         sizeof(struct termios ));
#line 146
  tattr.c_lflag &= 4294967287U;
#line 147
  tcsetattr(0, 2, (struct termios  const  *)(& tattr));
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void tty_raw(void) 
{ 
  struct termios tattr ;

  {
  {
#line 154
  fcntl(0, 4, 2048);
#line 155
  memcpy((void */* __restrict  */)(& tattr), (void const   */* __restrict  */)(& saved_attributes),
         sizeof(struct termios ));
#line 156
  tattr.c_lflag &= 4294967284U;
#line 157
  tattr.c_cc[6] = (cc_t )1;
#line 158
  tattr.c_cc[5] = (cc_t )0;
#line 159
  tcsetattr(0, 2, (struct termios  const  *)(& tattr));
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void tty_restore(void) 
{ 


  {
  {
#line 164
  fcntl(0, 4, saved_fl);
#line 165
  tcsetattr(0, 0, (struct termios  const  *)(& saved_attributes));
  }
#line 166
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
static void usage(FILE *fp ) 
{ 


  {
  {
#line 172
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nThis is amtterm, release 1.3, I\'ll establish\nserial-over-lan (sol) connections to your Intel AMT boxes.\n\nusage: amtterm [options] host [port]\noptions:\n   -h            print this text\n   -v            verbose (default)\n   -q            quiet\n   -u user       username (default: admin)\n   -p pass       password (default: $AMT_PASSWORD)\n\nBy default port 16994 is used.\nIf no password is given amtterm will ask for one.\n\n-- \n(c) 2007 Gerd Hoffmann <kraxel@redhat.com>\n\n");
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/amtterm.c"
int main(int argc , char **argv ) 
{ 
  struct redir r ;
  char *h ;
  int c ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 199
  memset((void *)(& r), 0, sizeof(r));
#line 200
  r.verbose = 1;
#line 201
  memcpy((void */* __restrict  */)(r.type), (void const   */* __restrict  */)"SOL ",
         (size_t )4);
#line 202
  strcpy((char */* __restrict  */)(r.user), (char const   */* __restrict  */)"admin");
#line 204
  r.cb_data = (void *)(& r);
#line 205
  r.cb_recv = & recv_tty;
#line 206
  r.cb_state = & state_tty;
#line 208
  h = getenv("AMT_PASSWORD");
  }
#line 208
  if ((unsigned long )((void *)0) != (unsigned long )h) {
    {
#line 209
    snprintf((char */* __restrict  */)(r.pass), sizeof(r.pass), (char const   */* __restrict  */)"%s",
             h);
    }
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    c = getopt(argc, (char * const  *)argv, "hvqu:p:");
    }
#line 212
    if (-1 == c) {
#line 213
      goto while_break;
    }
    {
#line 215
    if (c == 118) {
#line 215
      goto case_118;
    }
#line 218
    if (c == 113) {
#line 218
      goto case_113;
    }
#line 221
    if (c == 117) {
#line 221
      goto case_117;
    }
#line 224
    if (c == 112) {
#line 224
      goto case_112;
    }
#line 229
    if (c == 104) {
#line 229
      goto case_104;
    }
#line 232
    goto switch_default;
    case_118: /* CIL Label */ 
#line 216
    r.verbose = 1;
#line 217
    goto switch_break;
    case_113: /* CIL Label */ 
#line 219
    r.verbose = 0;
#line 220
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 222
    snprintf((char */* __restrict  */)(r.user), sizeof(r.user), (char const   */* __restrict  */)"%s",
             optarg);
    }
#line 223
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 225
    snprintf((char */* __restrict  */)(r.pass), sizeof(r.pass), (char const   */* __restrict  */)"%s",
             optarg);
#line 226
    tmp = strlen((char const   *)optarg);
#line 226
    memset((void *)optarg, '*', tmp);
    }
#line 227
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 230
    usage(stdout);
#line 231
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 233
    usage(stderr);
#line 234
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (optind < argc) {
    {
#line 239
    snprintf((char */* __restrict  */)(r.host), sizeof(r.host), (char const   */* __restrict  */)"%s",
             *(argv + optind));
    }
  }
#line 240
  if (optind + 1 < argc) {
    {
#line 241
    snprintf((char */* __restrict  */)(r.port), sizeof(r.port), (char const   */* __restrict  */)"%s",
             *(argv + (optind + 1)));
    }
  }
  {
#line 242
  tmp___0 = strlen((char const   *)(r.host));
  }
#line 242
  if (0UL == tmp___0) {
    {
#line 243
    usage(stderr);
#line 244
    exit(1);
    }
  }
  {
#line 247
  tty_save();
#line 248
  tmp___1 = strlen((char const   *)(r.pass));
  }
#line 248
  if (0UL == tmp___1) {
    {
#line 249
    tty_noecho();
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AMT password for host %s: ",
            r.host);
#line 251
    fgets((char */* __restrict  */)(r.pass), (int )sizeof(r.pass), (FILE */* __restrict  */)stdin);
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 253
    h = strchr((char const   *)(r.pass), '\r');
    }
#line 253
    if ((unsigned long )((void *)0) != (unsigned long )h) {
#line 254
      *h = (char)0;
    }
    {
#line 255
    h = strchr((char const   *)(r.pass), '\n');
    }
#line 255
    if ((unsigned long )((void *)0) != (unsigned long )h) {
#line 256
      *h = (char)0;
    }
  }
  {
#line 259
  tmp___2 = redir_connect(& r);
  }
#line 259
  if (-1 == tmp___2) {
    {
#line 260
    tty_restore();
#line 261
    exit(1);
    }
  }
  {
#line 264
  tty_raw();
#line 265
  redir_start(& r);
#line 266
  redir_loop(& r);
#line 267
  tty_restore();
#line 269
  exit(0);
  }
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/tcp.h"
int tcp_verbose ;
#line 7
int tcp_connect(struct addrinfo *ai , char *addr , char *port , char *host , char *serv ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   MAX_TRANSMIT_BUFFER  =    (unsigned short const   )1000;
#line 83 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   TRANSMIT_BUFFER_TIMEOUT  =    (unsigned short const   )100;
#line 84 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   TRANSMIT_OVERFLOW_TIMEOUT  =    (unsigned short const   )0;
#line 85 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   HOST_SESSION_RX_TIMEOUT  =    (unsigned short const   )10000;
#line 86 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   HOST_FIFO_RX_FLUSH_TIMEOUT  =    (unsigned short const   )0;
#line 87 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/RedirectionConstants.h"
static unsigned short const   HEARTBEAT_INTERVAL___0  =    (unsigned short const   )5000;
#line 55 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.h"
int redir_stop(struct redir *r ) ;
#line 56
int redir_auth(struct redir *r ) ;
#line 57
int redir_sol_start(struct redir *r ) ;
#line 60
int redir_sol_recv(struct redir *r ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static char const   *state_name[41]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
  {      "NONE",      "CONNECT",      "INIT",      "AUTH", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "INIT_SOL",      "RUN_SOL", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "INIT_IDER",      "RUN_IDER",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "CLOSING",      "CLOSED", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "ERROR"};
#line 46 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static char const   *state_desc[41]  = 
#line 46
  {      "disconnected",      "connection to host",      "redirection initialization",      "session authentication", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "serial-over-lan initialization",      "serial-over-lan active", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "IDE redirect initialization",      "IDE redirect active",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "redirection shutdown",      "connection closed", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "failure"};
#line 62 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static void hexdump(char const   *prefix , unsigned char const   *data , size_t size ) 
{ 
  char ascii[17] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___2 ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((size_t )i < size)) {
#line 67
      goto while_break;
    }
#line 68
    if (0 == i % 16) {
#line 69
      if (prefix) {
#line 69
        tmp = ": ";
      } else {
#line 69
        tmp = "";
      }
#line 69
      if (prefix) {
#line 69
        tmp___0 = prefix;
      } else {
#line 69
        tmp___0 = "";
      }
      {
#line 69
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s%04x:",
              tmp___0, tmp, i);
#line 73
      memset((void *)(ascii), 0, sizeof(ascii));
      }
    }
#line 75
    if (0 == i % 4) {
      {
#line 76
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %02x",
            (int const   )*(data + i));
#line 78
    tmp___2 = __ctype_b_loc();
    }
#line 78
    if ((int const   )*(*tmp___2 + (int )*(data + i)) & 16384) {
#line 78
      ascii[i % 16] = (char )*(data + i);
    } else {
#line 78
      ascii[i % 16] = (char )'.';
    }
#line 79
    if (15 == i % 16) {
      {
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s\n",
              ascii);
      }
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (0 != i % 16) {
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! (0 != i % 16)) {
#line 83
        goto while_break___0;
      }
#line 84
      if (0 == i % 4) {
        {
#line 85
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
        }
      }
      {
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ");
#line 87
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s\n",
            ascii);
    }
  }
#line 91
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static ssize_t redir_write(struct redir *r , char const   *buf , size_t count ) 
{ 
  int rc ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 97
  if (r->trace) {
    {
#line 98
    hexdump("out", (unsigned char const   *)buf, count);
    }
  }
  {
#line 99
  tmp = write(r->sock, (void const   *)buf, count);
#line 99
  rc = (int )tmp;
  }
#line 100
  if (-1 == rc) {
    {
#line 101
    tmp___0 = __errno_location();
#line 101
    tmp___1 = strerror(*tmp___0);
#line 101
    snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"write(socket): %s",
             tmp___1);
    }
  }
#line 102
  return ((ssize_t )rc);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static void redir_state(struct redir *r , enum redir_state new ) 
{ 
  enum redir_state old ;

  {
#line 107
  old = r->state;
#line 109
  r->state = new;
#line 110
  if (r->cb_state) {
    {
#line 111
    (*(r->cb_state))(r->cb_data, old, new);
    }
  }
#line 112
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
char const   *redir_state_name(enum redir_state state ) 
{ 
  char const   *name ;

  {
#line 118
  name = (char const   *)((void *)0);
#line 120
  if ((unsigned long )state < sizeof(state_name) / sizeof(state_name[0])) {
#line 121
    name = state_name[state];
  }
#line 122
  if ((unsigned long )((void *)0) == (unsigned long )name) {
#line 123
    name = "unknown";
  }
#line 124
  return (name);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
char const   *redir_state_desc(enum redir_state state ) 
{ 
  char const   *desc ;

  {
#line 129
  desc = (char const   *)((void *)0);
#line 131
  if ((unsigned long )state < sizeof(state_desc) / sizeof(state_desc[0])) {
#line 132
    desc = state_desc[state];
  }
#line 133
  if ((unsigned long )((void *)0) == (unsigned long )desc) {
#line 134
    desc = "unknown";
  }
#line 135
  return (desc);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static unsigned char *defport  =    (unsigned char *)"16994";
#line 138 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_connect(struct redir *r ) 
{ 
  struct addrinfo ai ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 143
  memset((void *)(& ai), 0, sizeof(ai));
#line 144
  ai.ai_socktype = 1;
#line 145
  ai.ai_family = 0;
#line 146
  tcp_verbose = r->verbose;
#line 147
  redir_state(r, (enum redir_state )1);
#line 148
  tmp___1 = strlen((char const   *)(r->port));
  }
#line 148
  if (tmp___1) {
#line 148
    tmp___0 = r->port;
  } else {
#line 148
    tmp___0 = defport;
  }
  {
#line 148
  r->sock = tcp_connect(& ai, (char *)((void *)0), (char *)((void *)0), (char *)(r->host),
                        (char *)tmp___0);
  }
#line 150
  if (-1 == r->sock) {
    {
#line 151
    redir_state(r, (enum redir_state )40);
#line 153
    snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"connect failed");
    }
#line 154
    return (-1);
  }
#line 156
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_start(struct redir *r ) 
{ 
  unsigned char request[8] ;
  ssize_t tmp ;

  {
  {
#line 161
  request[0] = (unsigned char)16;
#line 161
  request[1] = (unsigned char)0;
#line 161
  request[2] = (unsigned char)0;
#line 161
  request[3] = (unsigned char)0;
#line 161
  request[4] = (unsigned char)0;
#line 161
  request[5] = (unsigned char)0;
#line 161
  request[6] = (unsigned char)0;
#line 161
  request[7] = (unsigned char)0;
#line 165
  memcpy((void */* __restrict  */)(request + 4), (void const   */* __restrict  */)(r->type),
         (size_t )4);
#line 166
  redir_state(r, (enum redir_state )2);
#line 167
  tmp = redir_write(r, (char const   *)(request), sizeof(request));
  }
#line 167
  return ((int )tmp);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_stop(struct redir *r ) 
{ 
  unsigned char request[4] ;

  {
  {
#line 172
  request[0] = (unsigned char)18;
#line 172
  request[1] = (unsigned char)0;
#line 172
  request[2] = (unsigned char)0;
#line 172
  request[3] = (unsigned char)0;
#line 176
  redir_state(r, (enum redir_state )31);
#line 177
  redir_write(r, (char const   *)(request), sizeof(request));
#line 178
  close(r->sock);
  }
#line 179
  return (0);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_auth(struct redir *r ) 
{ 
  int ulen ;
  size_t tmp ;
  int plen ;
  size_t tmp___0 ;
  int len ;
  int rc ;
  unsigned char *request ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 184
  tmp = strlen((char const   *)(r->user));
#line 184
  ulen = (int )tmp;
#line 185
  tmp___0 = strlen((char const   *)(r->pass));
#line 185
  plen = (int )tmp___0;
#line 186
  len = (11 + ulen) + plen;
#line 188
  tmp___1 = malloc((size_t )len);
#line 188
  request = (unsigned char *)tmp___1;
#line 190
  memset((void *)request, 0, (size_t )len);
#line 191
  *(request + 0) = (unsigned char)19;
#line 192
  *(request + 4) = (unsigned char)1;
#line 193
  *(request + 5) = (unsigned char )((ulen + plen) + 2);
#line 194
  *(request + 9) = (unsigned char )ulen;
#line 195
  memcpy((void */* __restrict  */)(request + 10), (void const   */* __restrict  */)(r->user),
         (size_t )ulen);
#line 196
  *(request + (10 + ulen)) = (unsigned char )plen;
#line 197
  memcpy((void */* __restrict  */)((request + 11) + ulen), (void const   */* __restrict  */)(r->pass),
         (size_t )plen);
#line 198
  redir_state(r, (enum redir_state )3);
#line 199
  tmp___2 = redir_write(r, (char const   *)request, (size_t )len);
#line 199
  rc = (int )tmp___2;
#line 200
  free((void *)request);
  }
#line 201
  return (rc);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_sol_start(struct redir *r ) 
{ 
  unsigned char request[24] ;
  ssize_t tmp ;

  {
  {
#line 206
  request[0] = (unsigned char)32;
#line 206
  request[1] = (unsigned char)0;
#line 206
  request[2] = (unsigned char)0;
#line 206
  request[3] = (unsigned char)0;
#line 206
  request[4] = (unsigned char)0;
#line 206
  request[5] = (unsigned char)0;
#line 206
  request[6] = (unsigned char)0;
#line 206
  request[7] = (unsigned char)0;
#line 206
  request[8] = (unsigned char )((int const   )MAX_TRANSMIT_BUFFER & 255);
#line 206
  request[9] = (unsigned char )((int const   )MAX_TRANSMIT_BUFFER >> 8);
#line 206
  request[10] = (unsigned char )((int const   )TRANSMIT_BUFFER_TIMEOUT & 255);
#line 206
  request[11] = (unsigned char )((int const   )TRANSMIT_BUFFER_TIMEOUT >> 8);
#line 206
  request[12] = (unsigned char )((int const   )TRANSMIT_OVERFLOW_TIMEOUT & 255);
#line 206
  request[13] = (unsigned char )((int const   )TRANSMIT_OVERFLOW_TIMEOUT >> 8);
#line 206
  request[14] = (unsigned char )((int const   )HOST_SESSION_RX_TIMEOUT & 255);
#line 206
  request[15] = (unsigned char )((int const   )HOST_SESSION_RX_TIMEOUT >> 8);
#line 206
  request[16] = (unsigned char )((int const   )HOST_FIFO_RX_FLUSH_TIMEOUT & 255);
#line 206
  request[17] = (unsigned char )((int const   )HOST_FIFO_RX_FLUSH_TIMEOUT >> 8);
#line 206
  request[18] = (unsigned char )((int const   )HEARTBEAT_INTERVAL___0 & 255);
#line 206
  request[19] = (unsigned char )((int const   )HEARTBEAT_INTERVAL___0 >> 8);
#line 206
  request[20] = (unsigned char)0;
#line 206
  request[21] = (unsigned char)0;
#line 206
  request[22] = (unsigned char)0;
#line 206
  request[23] = (unsigned char)0;
#line 223
  redir_state(r, (enum redir_state )10);
#line 224
  tmp = redir_write(r, (char const   *)(request), sizeof(request));
  }
#line 224
  return ((int )tmp);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_sol_stop(struct redir *r ) 
{ 
  unsigned char request[8] ;
  ssize_t tmp ;

  {
  {
#line 229
  request[0] = (unsigned char)34;
#line 229
  request[1] = (unsigned char)0;
#line 229
  request[2] = (unsigned char)0;
#line 229
  request[3] = (unsigned char)0;
#line 229
  request[4] = (unsigned char)0;
#line 229
  request[5] = (unsigned char)0;
#line 229
  request[6] = (unsigned char)0;
#line 229
  request[7] = (unsigned char)0;
#line 234
  redir_state(r, (enum redir_state )30);
#line 235
  tmp = redir_write(r, (char const   *)(request), sizeof(request));
  }
#line 235
  return ((int )tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_sol_send(struct redir *r , unsigned char *buf , int blen ) 
{ 
  int len ;
  int rc ;
  unsigned char *request ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 240
  len = 10 + blen;
#line 242
  tmp = malloc((size_t )len);
#line 242
  request = (unsigned char *)tmp;
#line 244
  memset((void *)request, 0, (size_t )len);
#line 245
  *(request + 0) = (unsigned char)40;
#line 246
  *(request + 8) = (unsigned char )(blen & 255);
#line 247
  *(request + 9) = (unsigned char )(blen >> 8);
#line 248
  memcpy((void */* __restrict  */)(request + 10), (void const   */* __restrict  */)buf,
         (size_t )blen);
#line 249
  tmp___0 = redir_write(r, (char const   *)request, (size_t )len);
#line 249
  rc = (int )tmp___0;
#line 250
  free((void *)request);
  }
#line 251
  return (rc);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_sol_recv(struct redir *r ) 
{ 
  unsigned char msg[64] ;
  int count ;
  int len ;
  int bshift ;
  int flags ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 260
  len = (int )r->buf[8] + ((int )r->buf[9] << 8);
#line 261
  count = (int )(r->blen - 10U);
#line 262
  if (count > len) {
#line 263
    count = len;
  }
#line 264
  bshift = count + 10;
#line 265
  if (r->cb_recv) {
    {
#line 266
    (*(r->cb_recv))(r->cb_data, r->buf + 10, count);
    }
  }
#line 267
  len -= count;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! len) {
#line 269
      goto while_break;
    }
#line 270
    if (r->trace) {
      {
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in+: need %d more data bytes\n",
              len);
      }
    }
#line 272
    count = (int )sizeof(msg);
#line 273
    if (count > len) {
#line 274
      count = len;
    }
    {
#line 277
    flags = fcntl(r->sock, 3);
#line 278
    fcntl(r->sock, 4, flags & -2049);
#line 279
    tmp = read(r->sock, (void *)(msg), (size_t )count);
#line 279
    count = (int )tmp;
#line 280
    fcntl(r->sock, 4, flags);
    }
    {
#line 283
    if (count == -1) {
#line 283
      goto case_neg_1;
    }
#line 286
    if (count == 0) {
#line 286
      goto case_0;
    }
#line 289
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 284
    tmp___0 = __errno_location();
#line 284
    tmp___1 = strerror(*tmp___0);
#line 284
    snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"read(socket): %s",
             tmp___1);
    }
#line 285
    return (-1);
    case_0: /* CIL Label */ 
    {
#line 287
    snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"EOF from socket");
    }
#line 288
    return (-1);
    switch_default: /* CIL Label */ 
#line 290
    if (r->trace) {
      {
#line 291
      hexdump("in+", (unsigned char const   *)(msg), (size_t )count);
      }
    }
#line 292
    if (r->cb_recv) {
      {
#line 293
      (*(r->cb_recv))(r->cb_data, msg, count);
      }
    }
#line 294
    len -= count;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (bshift);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static int in_loopback_mode  =    0;
#line 302 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
static int powered_off  =    0;
#line 304 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/redir.c"
int redir_data(struct redir *r ) 
{ 
  int rc ;
  int bshift ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  struct controls_from_host_message *msg ;

  {
#line 308
  if (r->trace) {
    {
#line 309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in --\n");
    }
#line 310
    if (r->blen) {
      {
#line 311
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in : already have %d\n",
              r->blen);
      }
    }
  }
  {
#line 313
  tmp = read(r->sock, (void *)(r->buf + r->blen), sizeof(r->buf) - (unsigned long )r->blen);
#line 313
  rc = (int )tmp;
  }
  {
#line 315
  if (rc == -1) {
#line 315
    goto case_neg_1;
  }
#line 318
  if (rc == 0) {
#line 318
    goto case_0;
  }
#line 321
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 316
  tmp___0 = __errno_location();
#line 316
  tmp___1 = strerror(*tmp___0);
#line 316
  snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"read(socket): %s",
           tmp___1);
  }
#line 317
  goto err;
  case_0: /* CIL Label */ 
  {
#line 319
  snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"EOF from socket");
  }
#line 320
  goto err;
  switch_default: /* CIL Label */ 
#line 322
  if (r->trace) {
    {
#line 323
    hexdump("in ", (unsigned char const   *)(r->buf + r->blen), (size_t )rc);
    }
  }
#line 324
  r->blen += (unsigned int )rc;
  switch_break: /* CIL Label */ ;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (r->blen < 4U) {
#line 329
      goto again;
    }
#line 330
    bshift = 0;
    {
#line 333
    if ((int )r->buf[0] == 17) {
#line 333
      goto case_17;
    }
#line 344
    if ((int )r->buf[0] == 20) {
#line 344
      goto case_20;
    }
#line 355
    if ((int )r->buf[0] == 33) {
#line 355
      goto case_33;
    }
#line 368
    if ((int )r->buf[0] == 68) {
#line 368
      goto case_68;
    }
#line 368
    if ((int )r->buf[0] == 75) {
#line 368
      goto case_68;
    }
#line 368
    if ((int )r->buf[0] == 36) {
#line 368
      goto case_68;
    }
#line 368
    if ((int )r->buf[0] == 43) {
#line 368
      goto case_68;
    }
#line 375
    if ((int )r->buf[0] == 42) {
#line 375
      goto case_42;
    }
#line 382
    if ((int )r->buf[0] == 35) {
#line 382
      goto case_35;
    }
#line 388
    if ((int )r->buf[0] == 41) {
#line 388
      goto case_41;
    }
#line 437
    goto switch_default___0;
    case_17: /* CIL Label */ 
#line 334
    bshift = 13;
#line 335
    if (r->blen < (unsigned int )bshift) {
#line 336
      goto again;
    }
#line 337
    if ((int )r->buf[1] != 0) {
      {
#line 338
      snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"redirection session start failed");
      }
#line 339
      goto err;
    }
    {
#line 341
    tmp___2 = redir_auth(r);
    }
#line 341
    if (-1 == tmp___2) {
#line 342
      goto err;
    }
#line 343
    goto switch_break___0;
    case_20: /* CIL Label */ 
#line 345
    bshift = (int )r->blen;
#line 346
    if (r->blen < (unsigned int )bshift) {
#line 347
      goto again;
    }
#line 348
    if ((int )r->buf[1] != 0) {
      {
#line 349
      snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"session authentication failed");
      }
#line 350
      goto err;
    }
    {
#line 352
    tmp___3 = redir_sol_start(r);
    }
#line 352
    if (-1 == tmp___3) {
#line 353
      goto err;
    }
#line 354
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 356
    bshift = (int )r->blen;
#line 357
    if (r->blen < (unsigned int )bshift) {
#line 358
      goto again;
    }
#line 359
    if ((int )r->buf[1] != 0) {
      {
#line 360
      snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"serial-over-lan redirection failed");
      }
#line 361
      goto err;
    }
    {
#line 363
    redir_state(r, (enum redir_state )11);
    }
#line 364
    goto switch_break___0;
    case_68: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 369
    bshift = 8;
#line 370
    if (r->blen < (unsigned int )bshift) {
#line 371
      goto again;
    }
    {
#line 372
    tmp___4 = redir_write(r, (char const   *)(r->buf), (size_t )8);
    }
#line 372
    if (8L != tmp___4) {
#line 373
      goto err;
    }
#line 374
    goto switch_break___0;
    case_42: /* CIL Label */ 
#line 376
    if (r->blen < 10U) {
#line 377
      goto again;
    }
    {
#line 378
    bshift = redir_sol_recv(r);
    }
#line 379
    if (bshift < 0) {
#line 380
      goto err;
    }
#line 381
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 383
    bshift = (int )r->blen;
#line 384
    if (r->blen < (unsigned int )bshift) {
#line 385
      goto again;
    }
    {
#line 386
    redir_stop(r);
    }
#line 387
    goto switch_break___0;
    case_41: /* CIL Label */ 
#line 389
    bshift = (int )r->blen;
#line 390
    if (r->blen < (unsigned int )bshift) {
#line 391
      goto again;
    }
#line 399
    msg = (struct controls_from_host_message *)(r->buf);
#line 401
    if ((int )msg->status & 2) {
#line 402
      if (r->verbose) {
        {
#line 403
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning, SOL device is running in loopback mode.  Text input may not be accepted\n");
        }
      }
#line 404
      in_loopback_mode = 1;
    } else
#line 405
    if (in_loopback_mode) {
#line 406
      if (r->verbose) {
        {
#line 407
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SOL device is no longer running in loopback mode\n");
        }
      }
#line 408
      in_loopback_mode = 0;
    }
#line 411
    if (0 == ((int )msg->status & 4)) {
#line 412
      if (r->verbose) {
        {
#line 413
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The system is powered off.\n");
        }
      }
#line 414
      powered_off = 1;
    } else
#line 415
    if (powered_off) {
#line 416
      if (r->verbose) {
        {
#line 417
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The system is powered on.\n");
        }
      }
#line 418
      powered_off = 0;
    }
#line 421
    if (r->verbose) {
#line 422
      if ((int )msg->status & 25) {
        {
#line 423
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Other unhandled status condition\n");
        }
      }
#line 425
      if ((int )msg->control & 1) {
        {
#line 426
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RTS is asserted on the COM Port\n");
        }
      }
#line 428
      if ((int )msg->control & 2) {
        {
#line 429
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DTR is asserted on the COM Port\n");
        }
      }
#line 431
      if ((int )msg->control & 4) {
        {
#line 432
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BREAK is asserted on the COM Port\n");
        }
      }
    }
#line 435
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 438
    snprintf((char */* __restrict  */)(r->err), sizeof(r->err), (char const   */* __restrict  */)"%s: unknown r->buf 0x%02x",
             "redir_data", (int )r->buf[0]);
    }
#line 440
    goto err;
    switch_break___0: /* CIL Label */ ;
    }
#line 443
    if ((unsigned int )bshift == r->blen) {
#line 444
      r->blen = 0U;
#line 445
      goto while_break;
    }
#line 449
    if (r->trace) {
      {
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in : shift by %d\n",
              bshift);
      }
    }
    {
#line 451
    memmove((void *)(r->buf), (void const   *)(r->buf + bshift), (size_t )(r->blen - (unsigned int )bshift));
#line 452
    r->blen -= (unsigned int )bshift;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return (0);
  again: 
#line 458
  if (r->trace) {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in : need more data\n");
    }
  }
#line 460
  return (0);
  err: 
#line 463
  if (r->trace) {
    {
#line 464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in : ERROR (%s)\n",
            r->err);
    }
  }
  {
#line 465
  redir_state(r, (enum redir_state )40);
#line 466
  close(r->sock);
  }
#line 467
  return (-1);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/tcp.h"
int tcp_verbose  ;
#line 11
int tcp_listen(struct addrinfo *ai , char *addr , char *port ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/tcp.c"
static char *strfamily(int family ) 
{ 


  {
  {
#line 37
  if (family == 10) {
#line 37
    goto case_10;
  }
#line 38
  if (family == 2) {
#line 38
    goto case_2;
  }
#line 39
  if (family == 1) {
#line 39
    goto case_1;
  }
#line 36
  goto switch_break;
  case_10: /* CIL Label */ 
#line 37
  return ((char *)"ipv6");
  case_2: /* CIL Label */ 
#line 38
  return ((char *)"ipv4");
  case_1: /* CIL Label */ 
#line 39
  return ((char *)"unix");
  switch_break: /* CIL Label */ ;
  }
#line 41
  return ((char *)"????");
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/tcp.c"
int tcp_connect(struct addrinfo *ai , char *addr , char *port , char *host , char *serv ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *e ;
  struct addrinfo *lres ;
  struct addrinfo ask ;
  char uaddr[47] ;
  char uport[33] ;
  char uhost[47] ;
  char userv[33] ;
  int sock ;
  int rc ;
  int opt ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 54
  opt = 1;
#line 57
  ai->ai_flags = 2;
#line 58
  rc = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)serv,
                   (struct addrinfo  const  */* __restrict  */)ai, (struct addrinfo **/* __restrict  */)(& res));
  }
#line 58
  if (0 != rc) {
#line 59
    if (tcp_verbose) {
      {
#line 60
      tmp = gai_strerror(rc);
#line 60
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo (peer): %s\n",
              tmp);
      }
    }
#line 61
    return (-1);
  }
#line 63
  e = res;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)e->ai_addr,
                          e->ai_addrlen, (char */* __restrict  */)(uhost), (socklen_t )46,
                          (char */* __restrict  */)(userv), (socklen_t )32, 3);
    }
#line 64
    if (0 != tmp___0) {
#line 67
      if (tcp_verbose) {
        {
#line 68
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getnameinfo (peer): oops\n");
        }
      }
#line 69
      goto __Cont;
    }
    {
#line 71
    sock = socket(e->ai_family, e->ai_socktype, e->ai_protocol);
    }
#line 71
    if (-1 == sock) {
#line 73
      if (tcp_verbose) {
        {
#line 74
        tmp___1 = __errno_location();
#line 74
        tmp___2 = strerror(*tmp___1);
#line 74
        tmp___3 = strfamily(e->ai_family);
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"socket (%s): %s\n",
                tmp___3, tmp___2);
        }
      }
#line 76
      goto __Cont;
    }
    {
#line 78
    setsockopt(sock, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
    }
#line 79
    if ((unsigned long )((void *)0) != (unsigned long )addr) {
#line 79
      goto _L;
    } else
#line 79
    if ((unsigned long )((void *)0) != (unsigned long )port) {
      _L: /* CIL Label */ 
      {
#line 81
      memset((void *)(& ask), 0, sizeof(ask));
#line 82
      ask.ai_flags = 1;
#line 83
      ask.ai_family = e->ai_family;
#line 84
      ask.ai_socktype = e->ai_socktype;
#line 85
      rc = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)port,
                       (struct addrinfo  const  */* __restrict  */)(& ask), (struct addrinfo **/* __restrict  */)(& lres));
      }
#line 85
      if (0 != rc) {
#line 86
        if (tcp_verbose) {
          {
#line 87
          tmp___4 = gai_strerror(rc);
#line 87
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo (local): %s\n",
                  tmp___4);
          }
        }
#line 89
        goto __Cont;
      }
      {
#line 91
      tmp___5 = getnameinfo((struct sockaddr  const  */* __restrict  */)lres->ai_addr,
                            lres->ai_addrlen, (char */* __restrict  */)(uaddr), (socklen_t )46,
                            (char */* __restrict  */)(uport), (socklen_t )32, 3);
      }
#line 91
      if (0 != tmp___5) {
#line 95
        if (tcp_verbose) {
          {
#line 96
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getnameinfo (local): oops\n");
          }
        }
#line 97
        goto __Cont;
      }
      {
#line 99
      tmp___9 = bind(sock, (struct sockaddr  const  *)lres->ai_addr, lres->ai_addrlen);
      }
#line 99
      if (-1 == tmp___9) {
#line 100
        if (tcp_verbose) {
          {
#line 101
          tmp___6 = __errno_location();
#line 101
          tmp___7 = strerror(*tmp___6);
#line 101
          tmp___8 = strfamily(lres->ai_family);
#line 101
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s [%s] %s bind: %s\n",
                  tmp___8, uaddr, uport, tmp___7);
          }
        }
#line 104
        goto __Cont;
      }
    }
    {
#line 108
    tmp___13 = connect(sock, (struct sockaddr  const  *)e->ai_addr, e->ai_addrlen);
    }
#line 108
    if (-1 == tmp___13) {
#line 109
      if (tcp_verbose) {
        {
#line 110
        tmp___10 = __errno_location();
#line 110
        tmp___11 = strerror(*tmp___10);
#line 110
        tmp___12 = strfamily(e->ai_family);
#line 110
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s [%s] %s connect: %s\n",
                tmp___12, e->ai_canonname, uhost, userv, tmp___11);
        }
      }
      {
#line 113
      close(sock);
      }
#line 114
      goto __Cont;
    }
#line 116
    if (tcp_verbose) {
      {
#line 117
      tmp___14 = strfamily(e->ai_family);
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s [%s] %s open\n",
              tmp___14, e->ai_canonname, uhost, userv);
      }
    }
    {
#line 119
    fcntl(sock, 4, 2048);
    }
#line 120
    return (sock);
    __Cont: /* CIL Label */ 
#line 63
    e = e->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (-1);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/amtterm-1.3/tcp.c"
int tcp_listen(struct addrinfo *ai , char *addr , char *port ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *e ;
  char uaddr[47] ;
  char uport[33] ;
  int slisten ;
  int rc ;
  int opt ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 130
  opt = 1;
#line 133
  ai->ai_flags = 1;
#line 134
  rc = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)port,
                   (struct addrinfo  const  */* __restrict  */)ai, (struct addrinfo **/* __restrict  */)(& res));
  }
#line 134
  if (0 != rc) {
#line 135
    if (tcp_verbose) {
      {
#line 136
      tmp = gai_strerror(rc);
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
              tmp);
      }
    }
    {
#line 137
    exit(1);
    }
  }
#line 141
  e = res;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 141
      goto while_break;
    }
    {
#line 142
    getnameinfo((struct sockaddr  const  */* __restrict  */)e->ai_addr, e->ai_addrlen,
                (char */* __restrict  */)(uaddr), (socklen_t )46, (char */* __restrict  */)(uport),
                (socklen_t )32, 3);
#line 145
    slisten = socket(e->ai_family, e->ai_socktype, e->ai_protocol);
    }
#line 145
    if (-1 == slisten) {
#line 147
      if (tcp_verbose) {
        {
#line 148
        tmp___0 = __errno_location();
#line 148
        tmp___1 = strerror(*tmp___0);
#line 148
        tmp___2 = strfamily(e->ai_family);
#line 148
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"socket (%s): %s\n",
                tmp___2, tmp___1);
        }
      }
#line 150
      goto __Cont;
    }
    {
#line 152
    opt = 1;
#line 153
    setsockopt(slisten, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
#line 154
    tmp___6 = bind(slisten, (struct sockaddr  const  *)e->ai_addr, e->ai_addrlen);
    }
#line 154
    if (-1 == tmp___6) {
#line 155
      if (tcp_verbose) {
        {
#line 156
        tmp___3 = __errno_location();
#line 156
        tmp___4 = strerror(*tmp___3);
#line 156
        tmp___5 = strfamily(e->ai_family);
#line 156
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s [%s] %s bind: %s\n",
                tmp___5, uaddr, uport, tmp___4);
        }
      }
#line 159
      goto __Cont;
    }
    {
#line 161
    listen(slisten, 1);
    }
#line 162
    goto while_break;
    __Cont: /* CIL Label */ 
#line 141
    e = e->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((unsigned long )((void *)0) == (unsigned long )e) {
#line 165
    return (-1);
  }
#line 168
  if (tcp_verbose) {
    {
#line 169
    tmp___7 = strfamily(e->ai_family);
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"listen on %s [%s] %s ...\n",
            tmp___7, uaddr, uport);
    }
  }
  {
#line 171
  fcntl(slisten, 4, 2048);
  }
#line 172
  return (slisten);
}
}
