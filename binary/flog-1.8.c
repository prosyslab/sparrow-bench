/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct __anonstruct_buf_52 {
   char *data ;
   int used ;
   int size ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct FileInfo {
   char *name ;
   int fd ;
   struct stat stat ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct Conf {
   char timestamp ;
   char pidfile ;
   char *time_format ;
   char *pidfile_name ;
   int max_len ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 1019
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off64_t __length )  __asm__("ftruncate64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct __anonstruct_buf_52 buf  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct FileInfo out  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
struct Conf conf  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
int volatile   gotHUP  ;
#line 46
void growbuf(int size ) ;
#line 47
int openfile(struct FileInfo *file ) ;
#line 48
int filechanged(struct FileInfo *file ) ;
#line 49
void unlinkpidfile(struct Conf *conf___0 ) ;
#line 50
void catchHUP(int sig ) ;
#line 51
void handleHUP(void) ;
#line 52
void writetime(int fd ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
int main(int argc , char **argv ) 
{ 
  char *eol ;
  char *pos ;
  int done ;
  int opt ;
  int totalwn ;
  FILE *pid_fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  int size ;
  ssize_t tmp___4 ;
  void *tmp___5 ;
  int wn ;
  ssize_t tmp___6 ;
  char str[256] ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char str___0[256] ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 57
  done = 0;
#line 58
  opt = 0;
#line 59
  totalwn = 0;
#line 64
  conf.time_format = (char *)((void *)0);
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    opt ++;
#line 65
    if (! (opt < argc)) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___2 = strcmp((char const   *)*(argv + opt), "-t");
    }
#line 66
    if (tmp___2) {
      {
#line 69
      tmp___1 = strcmp((char const   *)*(argv + opt), "-T");
      }
#line 69
      if (tmp___1) {
        {
#line 75
        tmp___0 = strcmp((char const   *)*(argv + opt), "-p");
        }
#line 75
        if (tmp___0) {
          {
#line 81
          tmp = strcmp((char const   *)*(argv + opt), "-l");
          }
#line 81
          if (tmp) {
#line 87
            goto while_break;
          } else {
#line 82
            opt ++;
#line 83
            if (opt < argc) {
              {
#line 84
              conf.max_len = atoi((char const   *)*(argv + opt));
              }
            }
          }
        } else {
#line 76
          opt ++;
#line 77
          if (opt < argc) {
#line 78
            conf.pidfile = (char)1;
#line 79
            conf.pidfile_name = *(argv + opt);
          }
        }
      } else {
#line 70
        opt ++;
#line 71
        if (opt < argc) {
#line 72
          conf.timestamp = (char)1;
#line 73
          conf.time_format = *(argv + opt);
        }
      }
    } else {
#line 67
      conf.timestamp = (char)1;
#line 68
      conf.time_format = (char *)"%Y%m%d;%T: ";
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if (opt >= argc) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: pipeline| %s [options] {logfile|-}  # SIGHUP will reopen logfile\n\t-t           prepend each line with \"YYYYMMDD;HH:MM:SS: \"\n\t-T <format>  prepend each line with specified strftime(3) format\n\t-l <number>  log file length limit (force truncation)\n\t-p <pidfile> pid file\n",
            *(argv + 0));
#line 99
    exit(1);
    }
  }
#line 102
  if (conf.pidfile) {
    {
#line 103
    pid_fd = fopen((char const   */* __restrict  */)conf.pidfile_name, (char const   */* __restrict  */)"w");
#line 104
    pid_fd = fopen((char const   */* __restrict  */)conf.pidfile_name, (char const   */* __restrict  */)"w");
    }
#line 104
    if ((unsigned long )pid_fd == (unsigned long )((void *)0)) {
      {
#line 105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open pidile: %s",
              conf.pidfile_name);
#line 106
      exit(1);
      }
    } else
#line 107
    if (pid_fd) {
      {
#line 108
      tmp___3 = getpid();
#line 108
      fprintf((FILE */* __restrict  */)pid_fd, (char const   */* __restrict  */)"%lu\n",
              (unsigned long )tmp___3);
#line 109
      fclose(pid_fd);
      }
    }
  }
  {
#line 113
  out.name = *(argv + opt);
#line 114
  openfile(& out);
#line 116
  signal(1, & catchHUP);
#line 118
  growbuf(4096);
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (! done)) {
#line 120
      goto while_break___0;
    }
#line 123
    if (buf.used == buf.size) {
      {
#line 123
      growbuf(buf.size * 2);
      }
    }
    {
#line 125
    tmp___4 = read(0, (void *)(buf.data + buf.used), (size_t )(buf.size - buf.used));
#line 125
    size = (int )tmp___4;
    }
#line 126
    if (size > 0) {
#line 127
      buf.used += size;
    } else
#line 129
    if (size == 0) {
#line 130
      done = 1;
    }
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      if (gotHUP) {
        {
#line 137
        handleHUP();
#line 138
        signal(1, & catchHUP);
#line 139
        gotHUP = (int volatile   )0;
        }
      }
      {
#line 142
      pos = buf.data;
#line 143
      tmp___5 = memchr((void const   *)buf.data, '\n', (size_t )buf.used);
#line 143
      eol = (char *)tmp___5;
      }
#line 144
      if ((unsigned long )eol == (unsigned long )((char *)0)) {
#line 144
        goto while_break___1;
      }
#line 145
      eol ++;
#line 147
      if (conf.timestamp) {
        {
#line 148
        writetime(out.fd);
        }
      }
      {
#line 150
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 150
        if (! ((unsigned long )pos < (unsigned long )eol)) {
#line 150
          goto while_break___2;
        }
        {
#line 151
        tmp___6 = write(out.fd, (void const   *)pos, (size_t )(eol - pos));
#line 151
        wn = (int )tmp___6;
        }
#line 152
        if (wn > 0) {
#line 153
          pos += wn;
#line 154
          totalwn += wn;
        } else {
          {
#line 156
          tmp___15 = __errno_location();
          }
#line 156
          if (*tmp___15 == 28) {
            {
#line 158
            tmp___10 = ftruncate(out.fd, (__off64_t )0);
            }
#line 158
            if (tmp___10) {
              {
#line 159
              tmp___7 = __errno_location();
#line 159
              tmp___8 = strerror(*tmp___7);
#line 159
              tmp___9 = __errno_location();
#line 159
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"truncating %s: %d %s\n",
                      out.name, *tmp___9, tmp___8);
#line 160
              unlinkpidfile(& conf);
#line 161
              exit(1);
              }
            }
            {
#line 163
            tmp___11 = snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"Device full: truncating %s\n\n",
                                out.name);
#line 163
            write(out.fd, (void const   *)(str), (size_t )tmp___11);
            }
          } else {
            {
#line 166
            tmp___12 = __errno_location();
#line 166
            tmp___13 = strerror(*tmp___12);
#line 166
            tmp___14 = __errno_location();
#line 166
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write %s: %d %s\n",
                    out.name, *tmp___14, tmp___13);
#line 167
            unlinkpidfile(& conf);
#line 168
            exit(1);
            }
          }
        }
#line 170
        if (conf.max_len) {
#line 170
          if (totalwn > conf.max_len) {
            {
#line 172
            tmp___19 = ftruncate(out.fd, (__off64_t )0);
            }
#line 172
            if (tmp___19) {
              {
#line 173
              tmp___16 = __errno_location();
#line 173
              tmp___17 = strerror(*tmp___16);
#line 173
              tmp___18 = __errno_location();
#line 173
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"truncating %s: %d %s\n",
                      out.name, *tmp___18, tmp___17);
#line 174
              unlinkpidfile(& conf);
#line 175
              exit(1);
              }
            }
            {
#line 177
            tmp___20 = snprintf((char */* __restrict  */)(str___0), sizeof(str___0),
                                (char const   */* __restrict  */)"File size limit: truncating %s\n\n",
                                out.name);
#line 177
            write(out.fd, (void const   *)(str___0), (size_t )tmp___20);
#line 178
            totalwn = 0;
            }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 182
      buf.used = (int )((buf.data + buf.used) - eol);
#line 183
      memmove((void *)buf.data, (void const   *)eol, (size_t )buf.used);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 190
  unlinkpidfile(& conf);
#line 191
  exit(0);
  }
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
void growbuf(int size ) 
{ 
  void *tmp ;

  {
#line 198
  if (size > buf.size) {
    {
#line 199
    tmp = realloc((void *)buf.data, (size_t )size);
#line 199
    buf.data = (char *)tmp;
#line 200
    buf.size = size;
    }
  }
#line 202
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
int openfile(struct FileInfo *file ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 210
  tmp = strcmp((char const   *)file->name, "-");
  }
#line 210
  if (tmp != 0) {
    {
#line 212
    fd = open((char const   *)file->name, 1089, 438);
    }
  } else {
#line 217
    fd = 2;
  }
#line 219
  if (fd < 0) {
    {
#line 220
    tmp___0 = __errno_location();
#line 220
    tmp___1 = strerror(*tmp___0);
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"open write %s: %s\n",
            file->name, tmp___1);
#line 221
    exit(1);
    }
  }
  {
#line 223
  file->fd = fd;
#line 224
  stat((char const   */* __restrict  */)file->name, (struct stat */* __restrict  */)(& file->stat));
  }
#line 225
  return (fd);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
int reopenfile(struct FileInfo *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 231
  tmp___0 = strcmp((char const   *)file->name, "-");
  }
#line 231
  if (tmp___0 != 0) {
    {
#line 232
    close(file->fd);
#line 233
    tmp = openfile(file);
    }
#line 233
    return (tmp);
  } else {
#line 235
    return (file->fd);
  }
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
int filechanged(struct FileInfo *file ) 
{ 
  struct stat stat2 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 247
  tmp = strcmp((char const   *)file->name, "-");
  }
#line 247
  if (tmp == 0) {
#line 247
    return (0);
  }
  {
#line 249
  tmp___0 = stat((char const   */* __restrict  */)file->name, (struct stat */* __restrict  */)(& stat2));
  }
#line 249
  if (tmp___0 < 0) {
#line 250
    return (1);
  }
#line 253
  if (stat2.st_ino != file->stat.st_ino) {
#line 255
    return (1);
  } else
#line 253
  if (stat2.st_dev != file->stat.st_dev) {
#line 255
    return (1);
  }
#line 258
  return (0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
void catchHUP(int sig ) 
{ 


  {
#line 265
  gotHUP = (int volatile   )1;
#line 266
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
void handleHUP(void) 
{ 
  char str[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 273
  tmp___1 = filechanged(& out);
  }
#line 273
  if (tmp___1) {
    {
#line 275
    tmp = snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"Caught SIGHUP: Reopening %s (closed)\n\n",
                   out.name);
#line 275
    write(out.fd, (void const   *)(str), (size_t )tmp);
#line 276
    reopenfile(& out);
#line 277
    tmp___0 = snprintf((char */* __restrict  */)(str), sizeof(str), (char const   */* __restrict  */)"Caught SIGHUP: Reopening %s (opened)\n\n",
                       out.name);
#line 277
    write(out.fd, (void const   *)(str), (size_t )tmp___0);
    }
  }
#line 279
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
void writetime(int fd ) 
{ 
  time_t now ;
  struct tm *t ;
  char buf___0[32] ;
  int len ;
  size_t tmp ;

  {
  {
#line 291
  time(& now);
#line 292
  t = localtime((time_t const   *)(& now));
#line 294
  tmp = strftime((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)conf.time_format,
                 (struct tm  const  */* __restrict  */)t);
#line 294
  len = (int )tmp;
#line 295
  write(fd, (void const   *)(& buf___0), (size_t )len);
  }
#line 296
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/flog-1.8/flog.c"
void unlinkpidfile(struct Conf *conf___0 ) 
{ 


  {
#line 303
  if (conf___0->pidfile) {
    {
#line 304
    unlink((char const   *)conf___0->pidfile_name);
    }
  }
#line 306
  return;
}
}
