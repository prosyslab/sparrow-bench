/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli.h"
struct ZopfliOptions {
   int verbose ;
   int verbose_more ;
   int numiterations ;
   int blocksplitting ;
   int blocksplittinglast ;
   int blocksplittingmax ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli.h"
typedef struct ZopfliOptions ZopfliOptions;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli.h"
enum __anonenum_ZopfliFormat_8 {
    ZOPFLI_FORMAT_GZIP = 0,
    ZOPFLI_FORMAT_ZLIB = 1,
    ZOPFLI_FORMAT_DEFLATE = 2
} ;
#line 68 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli.h"
typedef enum __anonenum_ZopfliFormat_8 ZopfliFormat;
#line 39 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.h"
struct ZopfliLongestMatchCache {
   unsigned short *length ;
   unsigned short *dist ;
   unsigned char *sublen ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.h"
typedef struct ZopfliLongestMatchCache ZopfliLongestMatchCache;
#line 29 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.h"
struct ZopfliHash {
   int *head ;
   unsigned short *prev ;
   int *hashval ;
   int val ;
   int *head2 ;
   unsigned short *prev2 ;
   int *hashval2 ;
   int val2 ;
   unsigned short *same ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.h"
typedef struct ZopfliHash ZopfliHash;
#line 41 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.h"
struct ZopfliLZ77Store {
   unsigned short *litlens ;
   unsigned short *dists ;
   size_t size ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.h"
typedef struct ZopfliLZ77Store ZopfliLZ77Store;
#line 59 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.h"
struct ZopfliBlockState {
   ZopfliOptions const   *options ;
   ZopfliLongestMatchCache *lmc ;
   size_t blockstart ;
   size_t blockend ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.h"
typedef struct ZopfliBlockState ZopfliBlockState;
#line 30 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
struct Node;
#line 30 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
typedef struct Node Node;
#line 35 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
struct Node {
   size_t weight ;
   Node *tail ;
   int count ;
   char inuse ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
struct NodePool {
   Node *nodes ;
   Node *next ;
   int size ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
typedef struct NodePool NodePool;
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
struct SymbolStats {
   size_t litlens[288] ;
   size_t dists[32] ;
   double ll_symbols[288] ;
   double d_symbols[32] ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
typedef struct SymbolStats SymbolStats;
#line 75 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
struct RanState {
   unsigned int m_w ;
   unsigned int m_z ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
typedef struct RanState RanState;
#line 114 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
typedef double CostModelFun(unsigned int litlen , unsigned int dist , void *context );
#line 37 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
typedef double FindMinimumFun(size_t i , void *context );
#line 112 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
struct SplitCostContext {
   unsigned short const   *litlens ;
   unsigned short const   *dists ;
   size_t llsize ;
   size_t start ;
   size_t end ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
typedef struct SplitCostContext SplitCostContext;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zlib_container.h"
void ZopfliZlibCompress(ZopfliOptions const   *options , unsigned char const   *in ,
                        size_t insize , unsigned char **out , size_t *outsize ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.h"
void ZopfliDeflate(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in ,
                   size_t insize , unsigned char *bp , unsigned char **out , size_t *outsize ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zlib_container.c"
static unsigned int adler32(unsigned char const   *data , size_t size ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zlib_container.c"
static unsigned int const   sums_overflow  =    (unsigned int const   )5550;
#line 29 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zlib_container.c"
static unsigned int adler32(unsigned char const   *data , size_t size ) 
{ 
  unsigned int s1 ;
  unsigned int s2 ;
  size_t amount ;
  size_t tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 32
  s1 = 1U;
#line 33
  s2 = (unsigned int )(1 >> 16);
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (size > 0UL)) {
#line 35
      goto while_break;
    }
#line 36
    if (size > (size_t )sums_overflow) {
#line 36
      tmp = (size_t )sums_overflow;
    } else {
#line 36
      tmp = size;
    }
#line 36
    amount = tmp;
#line 37
    size -= amount;
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      if (! (amount > 0UL)) {
#line 38
        goto while_break___0;
      }
#line 39
      tmp___0 = data;
#line 39
      data ++;
#line 39
      s1 += (unsigned int )*tmp___0;
#line 40
      s2 += s1;
#line 41
      amount --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 43
    s1 %= 65521U;
#line 44
    s2 %= 65521U;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((s2 << 16) | s1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zlib_container.c"
void ZopfliZlibCompress(ZopfliOptions const   *options , unsigned char const   *in ,
                        size_t insize , unsigned char **out , size_t *outsize ) 
{ 
  unsigned char bitpointer ;
  unsigned int checksum ;
  unsigned int tmp ;
  unsigned int cmf ;
  unsigned int flevel ;
  unsigned int fdict ;
  unsigned int cmfflg ;
  unsigned int fcheck ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 53
  bitpointer = (unsigned char)0;
#line 54
  tmp = adler32(in, (size_t )((unsigned int )insize));
#line 54
  checksum = tmp;
#line 55
  cmf = 120U;
#line 56
  flevel = 0U;
#line 57
  fdict = 0U;
#line 58
  cmfflg = (256U * cmf + fdict * 32U) + flevel * 64U;
#line 59
  fcheck = 31U - cmfflg % 31U;
#line 60
  cmfflg += fcheck;
  }
#line 62
  if (! (*outsize & (*outsize - 1UL))) {
#line 62
    if (*outsize == 0UL) {
      {
#line 62
      tmp___0 = malloc(sizeof(*(*out)));
#line 62
      *out = (unsigned char *)tmp___0;
      }
    } else {
      {
#line 62
      tmp___1 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 62
      *out = (unsigned char *)tmp___1;
      }
    }
  }
#line 62
  *(*out + *outsize) = (unsigned char )(cmfflg / 256U);
#line 62
  (*outsize) ++;
#line 63
  if (! (*outsize & (*outsize - 1UL))) {
#line 63
    if (*outsize == 0UL) {
      {
#line 63
      tmp___2 = malloc(sizeof(*(*out)));
#line 63
      *out = (unsigned char *)tmp___2;
      }
    } else {
      {
#line 63
      tmp___3 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 63
      *out = (unsigned char *)tmp___3;
      }
    }
  }
  {
#line 63
  *(*out + *outsize) = (unsigned char )(cmfflg % 256U);
#line 63
  (*outsize) ++;
#line 65
  ZopfliDeflate(options, 2, 1, in, insize, & bitpointer, out, outsize);
  }
#line 68
  if (! (*outsize & (*outsize - 1UL))) {
#line 68
    if (*outsize == 0UL) {
      {
#line 68
      tmp___4 = malloc(sizeof(*(*out)));
#line 68
      *out = (unsigned char *)tmp___4;
      }
    } else {
      {
#line 68
      tmp___5 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 68
      *out = (unsigned char *)tmp___5;
      }
    }
  }
#line 68
  *(*out + *outsize) = (unsigned char )((checksum >> 24) % 256U);
#line 68
  (*outsize) ++;
#line 69
  if (! (*outsize & (*outsize - 1UL))) {
#line 69
    if (*outsize == 0UL) {
      {
#line 69
      tmp___6 = malloc(sizeof(*(*out)));
#line 69
      *out = (unsigned char *)tmp___6;
      }
    } else {
      {
#line 69
      tmp___7 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 69
      *out = (unsigned char *)tmp___7;
      }
    }
  }
#line 69
  *(*out + *outsize) = (unsigned char )((checksum >> 16) % 256U);
#line 69
  (*outsize) ++;
#line 70
  if (! (*outsize & (*outsize - 1UL))) {
#line 70
    if (*outsize == 0UL) {
      {
#line 70
      tmp___8 = malloc(sizeof(*(*out)));
#line 70
      *out = (unsigned char *)tmp___8;
      }
    } else {
      {
#line 70
      tmp___9 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 70
      *out = (unsigned char *)tmp___9;
      }
    }
  }
#line 70
  *(*out + *outsize) = (unsigned char )((checksum >> 8) % 256U);
#line 70
  (*outsize) ++;
#line 71
  if (! (*outsize & (*outsize - 1UL))) {
#line 71
    if (*outsize == 0UL) {
      {
#line 71
      tmp___10 = malloc(sizeof(*(*out)));
#line 71
      *out = (unsigned char *)tmp___10;
      }
    } else {
      {
#line 71
      tmp___11 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 71
      *out = (unsigned char *)tmp___11;
      }
    }
  }
#line 71
  *(*out + *outsize) = (unsigned char )(checksum % 256U);
#line 71
  (*outsize) ++;
#line 73
  if (options->verbose) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Original Size: %d, Zlib: %d, Compression: %f%% Removed\n",
            (int )insize, (int )*outsize, (100.0 * (double )(insize - *outsize)) / (double )insize);
    }
  }
#line 79
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.h"
void ZopfliGzipCompress(ZopfliOptions const   *options , unsigned char const   *in ,
                        size_t insize , unsigned char **out , size_t *outsize ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
static unsigned long crc_table[256]  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
static int crc_table_computed  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
static void MakeCRCTable(void) 
{ 
  unsigned long c ;
  int n ;
  int k ;

  {
#line 37
  n = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (n < 256)) {
#line 37
      goto while_break;
    }
#line 38
    c = (unsigned long )n;
#line 39
    k = 0;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 39
      if (! (k < 8)) {
#line 39
        goto while_break___0;
      }
#line 40
      if (c & 1UL) {
#line 41
        c = 3988292384UL ^ (c >> 1);
      } else {
#line 43
        c >>= 1;
      }
#line 39
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 46
    crc_table[n] = c;
#line 37
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  crc_table_computed = 1;
#line 49
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
static unsigned long UpdateCRC(unsigned long crc , unsigned char const   *buf , size_t len ) 
{ 
  unsigned long c ;
  unsigned int n ;

  {
#line 58
  c = crc ^ 4294967295UL;
#line 61
  if (! crc_table_computed) {
    {
#line 62
    MakeCRCTable();
    }
  }
#line 63
  n = 0U;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((size_t )n < len)) {
#line 63
      goto while_break;
    }
#line 64
    c = crc_table[(c ^ (unsigned long )*(buf + n)) & 255UL] ^ (c >> 8);
#line 63
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (c ^ 4294967295UL);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
static unsigned long CRC(unsigned char const   *buf , int len ) 
{ 
  unsigned long tmp ;

  {
  {
#line 71
  tmp = UpdateCRC(0UL, buf, (size_t )len);
  }
#line 71
  return (tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/gzip_container.c"
void ZopfliGzipCompress(ZopfliOptions const   *options , unsigned char const   *in ,
                        size_t insize , unsigned char **out , size_t *outsize ) 
{ 
  unsigned long crcvalue ;
  unsigned long tmp ;
  unsigned char bp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;

  {
  {
#line 80
  tmp = CRC(in, (int )insize);
#line 80
  crcvalue = tmp;
#line 81
  bp = (unsigned char)0;
  }
#line 83
  if (! (*outsize & (*outsize - 1UL))) {
#line 83
    if (*outsize == 0UL) {
      {
#line 83
      tmp___0 = malloc(sizeof(*(*out)));
#line 83
      *out = (unsigned char *)tmp___0;
      }
    } else {
      {
#line 83
      tmp___1 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 83
      *out = (unsigned char *)tmp___1;
      }
    }
  }
#line 83
  *(*out + *outsize) = (unsigned char)31;
#line 83
  (*outsize) ++;
#line 84
  if (! (*outsize & (*outsize - 1UL))) {
#line 84
    if (*outsize == 0UL) {
      {
#line 84
      tmp___2 = malloc(sizeof(*(*out)));
#line 84
      *out = (unsigned char *)tmp___2;
      }
    } else {
      {
#line 84
      tmp___3 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 84
      *out = (unsigned char *)tmp___3;
      }
    }
  }
#line 84
  *(*out + *outsize) = (unsigned char)139;
#line 84
  (*outsize) ++;
#line 85
  if (! (*outsize & (*outsize - 1UL))) {
#line 85
    if (*outsize == 0UL) {
      {
#line 85
      tmp___4 = malloc(sizeof(*(*out)));
#line 85
      *out = (unsigned char *)tmp___4;
      }
    } else {
      {
#line 85
      tmp___5 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 85
      *out = (unsigned char *)tmp___5;
      }
    }
  }
#line 85
  *(*out + *outsize) = (unsigned char)8;
#line 85
  (*outsize) ++;
#line 86
  if (! (*outsize & (*outsize - 1UL))) {
#line 86
    if (*outsize == 0UL) {
      {
#line 86
      tmp___6 = malloc(sizeof(*(*out)));
#line 86
      *out = (unsigned char *)tmp___6;
      }
    } else {
      {
#line 86
      tmp___7 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 86
      *out = (unsigned char *)tmp___7;
      }
    }
  }
#line 86
  *(*out + *outsize) = (unsigned char)0;
#line 86
  (*outsize) ++;
#line 88
  if (! (*outsize & (*outsize - 1UL))) {
#line 88
    if (*outsize == 0UL) {
      {
#line 88
      tmp___8 = malloc(sizeof(*(*out)));
#line 88
      *out = (unsigned char *)tmp___8;
      }
    } else {
      {
#line 88
      tmp___9 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 88
      *out = (unsigned char *)tmp___9;
      }
    }
  }
#line 88
  *(*out + *outsize) = (unsigned char)0;
#line 88
  (*outsize) ++;
#line 89
  if (! (*outsize & (*outsize - 1UL))) {
#line 89
    if (*outsize == 0UL) {
      {
#line 89
      tmp___10 = malloc(sizeof(*(*out)));
#line 89
      *out = (unsigned char *)tmp___10;
      }
    } else {
      {
#line 89
      tmp___11 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 89
      *out = (unsigned char *)tmp___11;
      }
    }
  }
#line 89
  *(*out + *outsize) = (unsigned char)0;
#line 89
  (*outsize) ++;
#line 90
  if (! (*outsize & (*outsize - 1UL))) {
#line 90
    if (*outsize == 0UL) {
      {
#line 90
      tmp___12 = malloc(sizeof(*(*out)));
#line 90
      *out = (unsigned char *)tmp___12;
      }
    } else {
      {
#line 90
      tmp___13 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 90
      *out = (unsigned char *)tmp___13;
      }
    }
  }
#line 90
  *(*out + *outsize) = (unsigned char)0;
#line 90
  (*outsize) ++;
#line 91
  if (! (*outsize & (*outsize - 1UL))) {
#line 91
    if (*outsize == 0UL) {
      {
#line 91
      tmp___14 = malloc(sizeof(*(*out)));
#line 91
      *out = (unsigned char *)tmp___14;
      }
    } else {
      {
#line 91
      tmp___15 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 91
      *out = (unsigned char *)tmp___15;
      }
    }
  }
#line 91
  *(*out + *outsize) = (unsigned char)0;
#line 91
  (*outsize) ++;
#line 93
  if (! (*outsize & (*outsize - 1UL))) {
#line 93
    if (*outsize == 0UL) {
      {
#line 93
      tmp___16 = malloc(sizeof(*(*out)));
#line 93
      *out = (unsigned char *)tmp___16;
      }
    } else {
      {
#line 93
      tmp___17 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 93
      *out = (unsigned char *)tmp___17;
      }
    }
  }
#line 93
  *(*out + *outsize) = (unsigned char)2;
#line 93
  (*outsize) ++;
#line 94
  if (! (*outsize & (*outsize - 1UL))) {
#line 94
    if (*outsize == 0UL) {
      {
#line 94
      tmp___18 = malloc(sizeof(*(*out)));
#line 94
      *out = (unsigned char *)tmp___18;
      }
    } else {
      {
#line 94
      tmp___19 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 94
      *out = (unsigned char *)tmp___19;
      }
    }
  }
  {
#line 94
  *(*out + *outsize) = (unsigned char)3;
#line 94
  (*outsize) ++;
#line 96
  ZopfliDeflate(options, 2, 1, in, insize, & bp, out, outsize);
  }
#line 100
  if (! (*outsize & (*outsize - 1UL))) {
#line 100
    if (*outsize == 0UL) {
      {
#line 100
      tmp___20 = malloc(sizeof(*(*out)));
#line 100
      *out = (unsigned char *)tmp___20;
      }
    } else {
      {
#line 100
      tmp___21 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 100
      *out = (unsigned char *)tmp___21;
      }
    }
  }
#line 100
  *(*out + *outsize) = (unsigned char )(crcvalue % 256UL);
#line 100
  (*outsize) ++;
#line 101
  if (! (*outsize & (*outsize - 1UL))) {
#line 101
    if (*outsize == 0UL) {
      {
#line 101
      tmp___22 = malloc(sizeof(*(*out)));
#line 101
      *out = (unsigned char *)tmp___22;
      }
    } else {
      {
#line 101
      tmp___23 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 101
      *out = (unsigned char *)tmp___23;
      }
    }
  }
#line 101
  *(*out + *outsize) = (unsigned char )((crcvalue >> 8) % 256UL);
#line 101
  (*outsize) ++;
#line 102
  if (! (*outsize & (*outsize - 1UL))) {
#line 102
    if (*outsize == 0UL) {
      {
#line 102
      tmp___24 = malloc(sizeof(*(*out)));
#line 102
      *out = (unsigned char *)tmp___24;
      }
    } else {
      {
#line 102
      tmp___25 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 102
      *out = (unsigned char *)tmp___25;
      }
    }
  }
#line 102
  *(*out + *outsize) = (unsigned char )((crcvalue >> 16) % 256UL);
#line 102
  (*outsize) ++;
#line 103
  if (! (*outsize & (*outsize - 1UL))) {
#line 103
    if (*outsize == 0UL) {
      {
#line 103
      tmp___26 = malloc(sizeof(*(*out)));
#line 103
      *out = (unsigned char *)tmp___26;
      }
    } else {
      {
#line 103
      tmp___27 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 103
      *out = (unsigned char *)tmp___27;
      }
    }
  }
#line 103
  *(*out + *outsize) = (unsigned char )((crcvalue >> 24) % 256UL);
#line 103
  (*outsize) ++;
#line 106
  if (! (*outsize & (*outsize - 1UL))) {
#line 106
    if (*outsize == 0UL) {
      {
#line 106
      tmp___28 = malloc(sizeof(*(*out)));
#line 106
      *out = (unsigned char *)tmp___28;
      }
    } else {
      {
#line 106
      tmp___29 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 106
      *out = (unsigned char *)tmp___29;
      }
    }
  }
#line 106
  *(*out + *outsize) = (unsigned char )(insize % 256UL);
#line 106
  (*outsize) ++;
#line 107
  if (! (*outsize & (*outsize - 1UL))) {
#line 107
    if (*outsize == 0UL) {
      {
#line 107
      tmp___30 = malloc(sizeof(*(*out)));
#line 107
      *out = (unsigned char *)tmp___30;
      }
    } else {
      {
#line 107
      tmp___31 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 107
      *out = (unsigned char *)tmp___31;
      }
    }
  }
#line 107
  *(*out + *outsize) = (unsigned char )((insize >> 8) % 256UL);
#line 107
  (*outsize) ++;
#line 108
  if (! (*outsize & (*outsize - 1UL))) {
#line 108
    if (*outsize == 0UL) {
      {
#line 108
      tmp___32 = malloc(sizeof(*(*out)));
#line 108
      *out = (unsigned char *)tmp___32;
      }
    } else {
      {
#line 108
      tmp___33 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 108
      *out = (unsigned char *)tmp___33;
      }
    }
  }
#line 108
  *(*out + *outsize) = (unsigned char )((insize >> 16) % 256UL);
#line 108
  (*outsize) ++;
#line 109
  if (! (*outsize & (*outsize - 1UL))) {
#line 109
    if (*outsize == 0UL) {
      {
#line 109
      tmp___34 = malloc(sizeof(*(*out)));
#line 109
      *out = (unsigned char *)tmp___34;
      }
    } else {
      {
#line 109
      tmp___35 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 109
      *out = (unsigned char *)tmp___35;
      }
    }
  }
#line 109
  *(*out + *outsize) = (unsigned char )((insize >> 24) % 256UL);
#line 109
  (*outsize) ++;
#line 111
  if (options->verbose) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Original Size: %d, Gzip: %d, Compression: %f%% Removed\n",
            (int )insize, (int )*outsize, (100.0 * (double )(insize - *outsize)) / (double )insize);
    }
  }
#line 117
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli.h"
void ZopfliInitOptions(ZopfliOptions *options ) ;
#line 84
void ZopfliCompress(ZopfliOptions const   *options , ZopfliFormat output_type , unsigned char const   *in ,
                    size_t insize , unsigned char **out , size_t *outsize ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
static void LoadFile(char const   *filename , unsigned char **out , size_t *outsize ) 
{ 
  FILE *file ;
  long tmp ;
  void *tmp___0 ;
  size_t testsize ;
  size_t tmp___1 ;

  {
  {
#line 43
  *out = (unsigned char *)0;
#line 44
  *outsize = (size_t )0;
#line 45
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 46
  if (! file) {
#line 46
    return;
  }
  {
#line 48
  fseek(file, 0L, 2);
#line 49
  tmp = ftell(file);
#line 49
  *outsize = (size_t )tmp;
#line 50
  rewind(file);
#line 52
  tmp___0 = malloc(*outsize);
#line 52
  *out = (unsigned char *)tmp___0;
  }
#line 54
  if (*outsize) {
#line 54
    if (*out) {
      {
#line 55
      tmp___1 = fread((void */* __restrict  */)*out, (size_t )1, *outsize, (FILE */* __restrict  */)file);
#line 55
      testsize = tmp___1;
      }
#line 56
      if (testsize != *outsize) {
        {
#line 58
        free((void *)*out);
#line 59
        *out = (unsigned char *)0;
#line 60
        *outsize = (size_t )0;
        }
      }
    }
  }
#line 64
  if (! (! *outsize)) {
#line 64
    if (! out) {
      {
#line 64
      __assert_fail("!(*outsize) || out", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c",
                    64U, "LoadFile");
      }
    }
  }
  {
#line 65
  fclose(file);
  }
#line 66
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
static void SaveFile(char const   *filename , unsigned char const   *in , size_t insize ) 
{ 
  FILE *file ;
  FILE *tmp ;

  {
  {
#line 73
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
#line 73
  file = tmp;
  }
#line 74
  if (! file) {
    {
#line 74
    __assert_fail("file", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c",
                  74U, "SaveFile");
    }
  }
  {
#line 75
  fwrite((void const   */* __restrict  */)((char *)in), (size_t )1, insize, (FILE */* __restrict  */)file);
#line 76
  fclose(file);
  }
#line 77
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
static void CompressFile(ZopfliOptions const   *options , ZopfliFormat output_type ,
                         char const   *infilename , char const   *outfilename ) 
{ 
  unsigned char *in ;
  size_t insize ;
  unsigned char *out ;
  size_t outsize ;
  size_t i ;

  {
  {
#line 88
  out = (unsigned char *)0;
#line 89
  outsize = (size_t )0;
#line 90
  LoadFile(infilename, & in, & insize);
  }
#line 91
  if (insize == 0UL) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid filename: %s\n",
            infilename);
    }
#line 93
    return;
  }
  {
#line 96
  ZopfliCompress(options, output_type, (unsigned char const   *)in, insize, & out,
                 & outsize);
  }
#line 98
  if (outfilename) {
    {
#line 99
    SaveFile(outfilename, (unsigned char const   *)out, outsize);
    }
  } else {
#line 102
    i = (size_t )0;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! (i < outsize)) {
#line 102
        goto while_break;
      }
      {
#line 104
      printf((char const   */* __restrict  */)"%c", (int )*(out + i));
#line 102
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 108
  free((void *)out);
#line 109
  free((void *)in);
  }
#line 110
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
static char *AddStrings(char const   *str1 , char const   *str2 ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *result ;
  void *tmp___1 ;

  {
  {
#line 116
  tmp = strlen(str1);
#line 116
  tmp___0 = strlen(str2);
#line 116
  len = tmp + tmp___0;
#line 117
  tmp___1 = malloc(len + 1UL);
#line 117
  result = (char *)tmp___1;
  }
#line 118
  if (! result) {
    {
#line 118
    exit(-1);
    }
  }
  {
#line 119
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)str1);
#line 120
  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)str2);
  }
#line 121
  return (result);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
static char StringsEqual(char const   *str1 , char const   *str2 ) 
{ 
  int tmp ;

  {
  {
#line 125
  tmp = strcmp(str1, str2);
  }
#line 125
  return ((char )(tmp == 0));
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c"
int main(int argc , char **argv ) 
{ 
  ZopfliOptions options ;
  ZopfliFormat output_type ;
  char const   *filename ;
  int output_to_stdout ;
  int i ;
  char const   *arg ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char *outfilename ;

  {
  {
#line 130
  output_type = (ZopfliFormat )0;
#line 131
  filename = (char const   *)0;
#line 132
  output_to_stdout = 0;
#line 135
  ZopfliInitOptions(& options);
#line 137
  i = 1;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < argc)) {
#line 137
      goto while_break;
    }
    {
#line 138
    arg = (char const   *)*(argv + i);
#line 139
    tmp___5 = StringsEqual(arg, "-v");
    }
#line 139
    if (tmp___5) {
#line 139
      options.verbose = 1;
    } else {
      {
#line 140
      tmp___4 = StringsEqual(arg, "-c");
      }
#line 140
      if (tmp___4) {
#line 140
        output_to_stdout = 1;
      } else {
        {
#line 141
        tmp___3 = StringsEqual(arg, "--deflate");
        }
#line 141
        if (tmp___3) {
#line 142
          output_type = (ZopfliFormat )2;
        } else {
          {
#line 144
          tmp___2 = StringsEqual(arg, "--zlib");
          }
#line 144
          if (tmp___2) {
#line 144
            output_type = (ZopfliFormat )1;
          } else {
            {
#line 145
            tmp___1 = StringsEqual(arg, "--gzip");
            }
#line 145
            if (tmp___1) {
#line 145
              output_type = (ZopfliFormat )0;
            } else {
              {
#line 146
              tmp___0 = StringsEqual(arg, "--splitlast");
              }
#line 146
              if (tmp___0) {
#line 146
                options.blocksplittinglast = 1;
              } else
#line 147
              if ((int const   )*(arg + 0) == 45) {
#line 147
                if ((int const   )*(arg + 1) == 45) {
#line 147
                  if ((int const   )*(arg + 2) == 105) {
#line 147
                    if ((int const   )*(arg + 3) >= 48) {
#line 147
                      if ((int const   )*(arg + 3) <= 57) {
                        {
#line 149
                        options.numiterations = atoi(arg + 3);
                        }
                      } else {
#line 147
                        goto _L___2;
                      }
                    } else {
#line 147
                      goto _L___2;
                    }
                  } else {
#line 147
                    goto _L___2;
                  }
                } else {
#line 147
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 151
                tmp = StringsEqual(arg, "-h");
                }
#line 151
                if (tmp) {
                  {
#line 152
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: zopfli [OPTION]... FILE\n  -h    gives this help\n  -c    write the result on standard output, instead of disk filename + \'.gz\'\n  -v    verbose mode\n  --i#  perform # iterations (default 15). More gives more compression but is slower. Examples: --i10, --i50, --i1000\n");
#line 161
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  --gzip        output to gzip format (default)\n  --zlib        output to zlib format instead of gzip\n  --deflate     output to deflate format instead of gzip\n  --splitlast   do block splitting last instead of first\n");
                  }
#line 166
                  return (0);
                }
              }
            }
          }
        }
      }
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if (options.numiterations < 1) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: must have 1 or more iterations");
    }
#line 172
    return (0);
  }
#line 175
  i = 1;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (i < argc)) {
#line 175
      goto while_break___0;
    }
#line 176
    if ((int )*(*(argv + i) + 0) != 45) {
#line 178
      filename = (char const   *)*(argv + i);
#line 179
      if (output_to_stdout) {
#line 180
        outfilename = (char *)0;
      } else
#line 181
      if ((unsigned int )output_type == 0U) {
        {
#line 182
        outfilename = AddStrings(filename, ".gz");
        }
      } else
#line 183
      if ((unsigned int )output_type == 1U) {
        {
#line 184
        outfilename = AddStrings(filename, ".zlib");
        }
      } else {
#line 186
        if (! ((unsigned int )output_type == 2U)) {
          {
#line 186
          __assert_fail("output_type == ZOPFLI_FORMAT_DEFLATE", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_bin.c",
                        186U, "main");
          }
        }
        {
#line 187
        outfilename = AddStrings(filename, ".deflate");
        }
      }
#line 189
      if (options.verbose) {
#line 189
        if (outfilename) {
          {
#line 190
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Saving to: %s\n",
                  outfilename);
          }
        }
      }
      {
#line 192
      CompressFile((ZopfliOptions const   *)(& options), output_type, filename, (char const   *)outfilename);
#line 193
      free((void *)outfilename);
      }
    }
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 197
  if (! filename) {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please provide filename\nFor help, type: %s -h\n",
            *(argv + 0));
    }
  }
#line 202
  return (0);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.h"
int ZopfliGetLengthSymbol(int l ) ;
#line 132
int ZopfliGetDistSymbol(int dist ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.h"
void ZopfliSublenToCache(unsigned short const   *sublen , size_t pos , size_t length ,
                         ZopfliLongestMatchCache *lmc ) ;
#line 57
void ZopfliCacheToSublen(ZopfliLongestMatchCache const   *lmc , size_t pos , size_t length ,
                         unsigned short *sublen ) ;
#line 61
unsigned int ZopfliMaxCachedSublen(ZopfliLongestMatchCache const   *lmc , size_t pos ,
                                   size_t length ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.h"
void ZopfliInitHash(size_t window_size , ZopfliHash *h ) ;
#line 53
void ZopfliCleanHash(ZopfliHash *h ) ;
#line 59
void ZopfliUpdateHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) ;
#line 67
void ZopfliWarmupHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.h"
void ZopfliInitLZ77Store(ZopfliLZ77Store *store ) ;
#line 49
void ZopfliCleanLZ77Store(ZopfliLZ77Store *store ) ;
#line 50
void ZopfliCopyLZ77Store(ZopfliLZ77Store const   *source , ZopfliLZ77Store *dest ) ;
#line 51
void ZopfliStoreLitLenDist(unsigned short length , unsigned short dist , ZopfliLZ77Store *store ) ;
#line 88
void ZopfliFindLongestMatch(ZopfliBlockState *s , ZopfliHash const   *h , unsigned char const   *array ,
                            size_t pos , size_t size , size_t limit , unsigned short *sublen ,
                            unsigned short *distance , unsigned short *length ) ;
#line 96
void ZopfliVerifyLenDist(unsigned char const   *data , size_t datasize , size_t pos ,
                         unsigned short dist , unsigned short length ) ;
#line 110
void ZopfliLZ77Counts(unsigned short const   *litlens , unsigned short const   *dists ,
                      size_t start , size_t end , size_t *ll_count , size_t *d_count ) ;
#line 122
void ZopfliLZ77Greedy(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                      size_t inend , ZopfliLZ77Store *store ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliInitLZ77Store(ZopfliLZ77Store *store ) 
{ 


  {
#line 28
  store->size = (size_t )0;
#line 29
  store->litlens = (unsigned short *)0;
#line 30
  store->dists = (unsigned short *)0;
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliCleanLZ77Store(ZopfliLZ77Store *store ) 
{ 


  {
  {
#line 34
  free((void *)store->litlens);
#line 35
  free((void *)store->dists);
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliCopyLZ77Store(ZopfliLZ77Store const   *source , ZopfliLZ77Store *dest ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 41
  ZopfliCleanLZ77Store(dest);
#line 42
  tmp = malloc(sizeof(*(dest->litlens)) * (unsigned long )source->size);
#line 42
  dest->litlens = (unsigned short *)tmp;
#line 44
  tmp___0 = malloc(sizeof(*(dest->dists)) * (unsigned long )source->size);
#line 44
  dest->dists = (unsigned short *)tmp___0;
  }
#line 46
  if (! dest->litlens) {
    {
#line 46
    exit(-1);
    }
  } else
#line 46
  if (! dest->dists) {
    {
#line 46
    exit(-1);
    }
  }
#line 48
  dest->size = (size_t )source->size;
#line 49
  i = (size_t )0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < (size_t )source->size)) {
#line 49
      goto while_break;
    }
#line 50
    *(dest->litlens + i) = *(source->litlens + i);
#line 51
    *(dest->dists + i) = *(source->dists + i);
#line 49
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliStoreLitLenDist(unsigned short length , unsigned short dist , ZopfliLZ77Store *store ) 
{ 
  size_t size2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 61
  size2 = store->size;
#line 62
  if (! (store->size & (store->size - 1UL))) {
#line 62
    if (store->size == 0UL) {
      {
#line 62
      tmp = malloc(sizeof(*(store->litlens)));
#line 62
      store->litlens = (unsigned short *)tmp;
      }
    } else {
      {
#line 62
      tmp___0 = realloc((void *)store->litlens, (store->size * 2UL) * sizeof(*(store->litlens)));
#line 62
      store->litlens = (unsigned short *)tmp___0;
      }
    }
  }
#line 62
  *(store->litlens + store->size) = length;
#line 62
  (store->size) ++;
#line 63
  if (! (size2 & (size2 - 1UL))) {
#line 63
    if (size2 == 0UL) {
      {
#line 63
      tmp___1 = malloc(sizeof(*(store->dists)));
#line 63
      store->dists = (unsigned short *)tmp___1;
      }
    } else {
      {
#line 63
      tmp___2 = realloc((void *)store->dists, (size2 * 2UL) * sizeof(*(store->dists)));
#line 63
      store->dists = (unsigned short *)tmp___2;
      }
    }
  }
#line 63
  *(store->dists + size2) = dist;
#line 63
  size2 ++;
#line 64
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
static int GetLengthScore(int length , int distance ) 
{ 
  int tmp ;

  {
#line 92
  if (distance > 1024) {
#line 92
    tmp = length - 1;
  } else {
#line 92
    tmp = length;
  }
#line 92
  return (tmp);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliVerifyLenDist(unsigned char const   *data , size_t datasize , size_t pos ,
                         unsigned short dist , unsigned short length ) 
{ 
  size_t i ;

  {
#line 101
  if (! (pos + (size_t )length <= datasize)) {
    {
#line 101
    __assert_fail("pos + length <= datasize", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  101U, "ZopfliVerifyLenDist");
    }
  }
#line 102
  i = (size_t )0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < (size_t )length)) {
#line 102
      goto while_break;
    }
#line 103
    if ((int const   )*(data + ((pos - (size_t )dist) + i)) != (int const   )*(data + (pos + i))) {
#line 104
      if (! ((int const   )*(data + ((pos - (size_t )dist) + i)) == (int const   )*(data + (pos + i)))) {
        {
#line 104
        __assert_fail("data[pos - dist + i] == data[pos + i]", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                      104U, "ZopfliVerifyLenDist");
        }
      }
#line 105
      goto while_break;
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
static unsigned char const   *GetMatch(unsigned char const   *scan , unsigned char const   *match ,
                                       unsigned char const   *end , unsigned char const   *safe_end ) 
{ 


  {
#line 124
  if (sizeof(size_t ) == 8UL) {
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if ((unsigned long )scan < (unsigned long )safe_end) {
#line 126
        if (! (*((size_t *)scan) == *((size_t *)match))) {
#line 126
          goto while_break;
        }
      } else {
#line 126
        goto while_break;
      }
#line 127
      scan += 8;
#line 128
      match += 8;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 130
  if (sizeof(unsigned int ) == 4UL) {
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if ((unsigned long )scan < (unsigned long )safe_end) {
#line 132
        if (! (*((unsigned int *)scan) == *((unsigned int *)match))) {
#line 132
          goto while_break___0;
        }
      } else {
#line 132
        goto while_break___0;
      }
#line 134
      scan += 4;
#line 135
      match += 4;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 139
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 139
      if ((unsigned long )scan < (unsigned long )safe_end) {
#line 139
        if ((int const   )*scan == (int const   )*match) {
#line 139
          scan ++;
#line 139
          match ++;
#line 139
          if ((int const   )*scan == (int const   )*match) {
#line 139
            scan ++;
#line 139
            match ++;
#line 139
            if ((int const   )*scan == (int const   )*match) {
#line 139
              scan ++;
#line 139
              match ++;
#line 139
              if ((int const   )*scan == (int const   )*match) {
#line 139
                scan ++;
#line 139
                match ++;
#line 139
                if ((int const   )*scan == (int const   )*match) {
#line 139
                  scan ++;
#line 139
                  match ++;
#line 139
                  if ((int const   )*scan == (int const   )*match) {
#line 139
                    scan ++;
#line 139
                    match ++;
#line 139
                    if ((int const   )*scan == (int const   )*match) {
#line 139
                      scan ++;
#line 139
                      match ++;
#line 139
                      if (! ((int const   )*scan == (int const   )*match)) {
#line 139
                        goto while_break___1;
                      }
                    } else {
#line 139
                      goto while_break___1;
                    }
                  } else {
#line 139
                    goto while_break___1;
                  }
                } else {
#line 139
                  goto while_break___1;
                }
              } else {
#line 139
                goto while_break___1;
              }
            } else {
#line 139
              goto while_break___1;
            }
          } else {
#line 139
            goto while_break___1;
          }
        } else {
#line 139
          goto while_break___1;
        }
      } else {
#line 139
        goto while_break___1;
      }
#line 143
      scan ++;
#line 143
      match ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 148
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 148
    if ((unsigned long )scan != (unsigned long )end) {
#line 148
      if (! ((int const   )*scan == (int const   )*match)) {
#line 148
        goto while_break___2;
      }
    } else {
#line 148
      goto while_break___2;
    }
#line 149
    scan ++;
#line 149
    match ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 152
  return (scan);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
static int TryGetFromLongestMatchCache(ZopfliBlockState *s , size_t pos , size_t *limit ,
                                       unsigned short *sublen , unsigned short *distance ,
                                       unsigned short *length ) 
{ 
  size_t lmcpos ;
  unsigned char cache_available ;
  int tmp ;
  unsigned char limit_ok_for_cache ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 167
  lmcpos = pos - s->blockstart;
#line 171
  if (s->lmc) {
#line 171
    if ((int )*((s->lmc)->length + lmcpos) == 0) {
#line 171
      tmp = 1;
    } else
#line 171
    if ((int )*((s->lmc)->dist + lmcpos) != 0) {
#line 171
      tmp = 1;
    } else {
#line 171
      tmp = 0;
    }
  } else {
#line 171
    tmp = 0;
  }
#line 171
  cache_available = (unsigned char )tmp;
#line 173
  if (cache_available) {
#line 173
    if (*limit == 258UL) {
#line 173
      tmp___1 = 1;
    } else
#line 173
    if ((size_t )*((s->lmc)->length + lmcpos) <= *limit) {
#line 173
      tmp___1 = 1;
    } else
#line 173
    if (sublen) {
      {
#line 173
      tmp___0 = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)s->lmc, lmcpos,
                                      (size_t )*((s->lmc)->length + lmcpos));
      }
#line 173
      if ((size_t )tmp___0 >= *limit) {
#line 173
        tmp___1 = 1;
      } else {
#line 173
        tmp___1 = 0;
      }
    } else {
#line 173
      tmp___1 = 0;
    }
  } else {
#line 173
    tmp___1 = 0;
  }
#line 173
  limit_ok_for_cache = (unsigned char )tmp___1;
#line 178
  if (s->lmc) {
#line 178
    if (limit_ok_for_cache) {
#line 178
      if (cache_available) {
#line 179
        if (! sublen) {
#line 179
          goto _L;
        } else {
          {
#line 179
          tmp___2 = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)s->lmc,
                                          lmcpos, (size_t )*((s->lmc)->length + lmcpos));
          }
#line 179
          if ((unsigned int )*((s->lmc)->length + lmcpos) <= tmp___2) {
            _L: /* CIL Label */ 
#line 181
            *length = *((s->lmc)->length + lmcpos);
#line 182
            if ((size_t )*length > *limit) {
#line 182
              *length = (unsigned short )*limit;
            }
#line 183
            if (sublen) {
              {
#line 184
              ZopfliCacheToSublen((ZopfliLongestMatchCache const   *)s->lmc, lmcpos,
                                  (size_t )*length, sublen);
#line 185
              *distance = *(sublen + *length);
              }
#line 186
              if (*limit == 258UL) {
#line 186
                if ((int )*length >= 3) {
#line 187
                  if (! ((int )*(sublen + *length) == (int )*((s->lmc)->dist + lmcpos))) {
                    {
#line 187
                    __assert_fail("sublen[*length] == s->lmc->dist[lmcpos]", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                                  187U, "TryGetFromLongestMatchCache");
                    }
                  }
                }
              }
            } else {
#line 190
              *distance = *((s->lmc)->dist + lmcpos);
            }
#line 192
            return (1);
          }
        }
#line 196
        *limit = (size_t )*((s->lmc)->length + lmcpos);
      }
    }
  }
#line 199
  return (0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
static void StoreInLongestMatchCache(ZopfliBlockState *s , size_t pos , size_t limit ,
                                     unsigned short const   *sublen , unsigned short distance ,
                                     unsigned short length ) 
{ 
  size_t lmcpos ;
  unsigned char cache_available ;
  int tmp ;

  {
#line 212
  lmcpos = pos - s->blockstart;
#line 216
  if (s->lmc) {
#line 216
    if ((int )*((s->lmc)->length + lmcpos) == 0) {
#line 216
      tmp = 1;
    } else
#line 216
    if ((int )*((s->lmc)->dist + lmcpos) != 0) {
#line 216
      tmp = 1;
    } else {
#line 216
      tmp = 0;
    }
  } else {
#line 216
    tmp = 0;
  }
#line 216
  cache_available = (unsigned char )tmp;
#line 219
  if (s->lmc) {
#line 219
    if (limit == 258UL) {
#line 219
      if (sublen) {
#line 219
        if (! cache_available) {
#line 220
          if ((int )*((s->lmc)->length + lmcpos) == 1) {
#line 220
            if (! ((int )*((s->lmc)->dist + lmcpos) == 0)) {
              {
#line 220
              __assert_fail("s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0",
                            "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                            220U, "StoreInLongestMatchCache");
              }
            }
          } else {
            {
#line 220
            __assert_fail("s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0",
                          "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                          220U, "StoreInLongestMatchCache");
            }
          }
#line 221
          if ((int )length < 3) {
#line 221
            *((s->lmc)->dist + lmcpos) = (unsigned short)0;
          } else {
#line 221
            *((s->lmc)->dist + lmcpos) = distance;
          }
#line 222
          if ((int )length < 3) {
#line 222
            *((s->lmc)->length + lmcpos) = (unsigned short)0;
          } else {
#line 222
            *((s->lmc)->length + lmcpos) = length;
          }
#line 223
          if ((int )*((s->lmc)->length + lmcpos) == 1) {
#line 223
            if ((int )*((s->lmc)->dist + lmcpos) == 0) {
              {
#line 223
              __assert_fail("!(s->lmc->length[lmcpos] == 1 && s->lmc->dist[lmcpos] == 0)",
                            "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                            223U, "StoreInLongestMatchCache");
              }
            }
          }
          {
#line 224
          ZopfliSublenToCache(sublen, lmcpos, (size_t )length, s->lmc);
          }
        }
      }
    }
  }
#line 226
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliFindLongestMatch(ZopfliBlockState *s , ZopfliHash const   *h , unsigned char const   *array ,
                            size_t pos , size_t size , size_t limit , unsigned short *sublen ,
                            unsigned short *distance , unsigned short *length ) 
{ 
  unsigned short hpos ;
  unsigned short p ;
  unsigned short pp ;
  unsigned short bestdist ;
  unsigned short bestlength ;
  unsigned char const   *scan ;
  unsigned char const   *match ;
  unsigned char const   *arrayend ;
  unsigned char const   *arrayend_safe ;
  int chain_counter ;
  unsigned int dist ;
  int *hhead ;
  unsigned short *hprev ;
  int *hhashval ;
  int hval ;
  int tmp ;
  unsigned short currentlength ;
  unsigned short same0 ;
  unsigned short same1 ;
  unsigned short same ;
  int tmp___0 ;
  unsigned short j ;
  int tmp___1 ;

  {
  {
#line 233
  hpos = (unsigned short )(pos & 32767UL);
#line 234
  bestdist = (unsigned short)0;
#line 235
  bestlength = (unsigned short)1;
#line 241
  chain_counter = 8192;
#line 244
  dist = 0U;
#line 246
  hhead = (int *)h->head;
#line 247
  hprev = (unsigned short *)h->prev;
#line 248
  hhashval = (int *)h->hashval;
#line 249
  hval = (int )h->val;
#line 252
  tmp = TryGetFromLongestMatchCache(s, pos, & limit, sublen, distance, length);
  }
#line 252
  if (tmp) {
#line 253
    if (! (pos + (size_t )*length <= size)) {
      {
#line 253
      __assert_fail("pos + *length <= size", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                    253U, "ZopfliFindLongestMatch");
      }
    }
#line 254
    return;
  }
#line 258
  if (! (limit <= 258UL)) {
    {
#line 258
    __assert_fail("limit <= 258", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  258U, "ZopfliFindLongestMatch");
    }
  }
#line 259
  if (! (limit >= 3UL)) {
    {
#line 259
    __assert_fail("limit >= 3", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  259U, "ZopfliFindLongestMatch");
    }
  }
#line 260
  if (! (pos < size)) {
    {
#line 260
    __assert_fail("pos < size", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  260U, "ZopfliFindLongestMatch");
    }
  }
#line 262
  if (size - pos < 3UL) {
#line 265
    *length = (unsigned short)0;
#line 266
    *distance = (unsigned short)0;
#line 267
    return;
  }
#line 270
  if (pos + limit > size) {
#line 271
    limit = size - pos;
  }
#line 273
  arrayend = (array + pos) + limit;
#line 274
  arrayend_safe = arrayend - 8;
#line 276
  if (! (hval < 65536)) {
    {
#line 276
    __assert_fail("hval < 65536", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  276U, "ZopfliFindLongestMatch");
    }
  }
#line 278
  pp = (unsigned short )*(hhead + hval);
#line 279
  p = *(hprev + pp);
#line 281
  if (! ((int )pp == (int )hpos)) {
    {
#line 281
    __assert_fail("pp == hpos", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  281U, "ZopfliFindLongestMatch");
    }
  }
#line 283
  if ((int )p < (int )pp) {
#line 283
    dist = (unsigned int )((int )pp - (int )p);
  } else {
#line 283
    dist = (unsigned int )((32768 - (int )p) + (int )pp);
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (dist < 32768U)) {
#line 286
      goto while_break;
    }
#line 287
    currentlength = (unsigned short)0;
#line 289
    if (! ((int )p < 32768)) {
      {
#line 289
      __assert_fail("p < 32768", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                    289U, "ZopfliFindLongestMatch");
      }
    }
#line 290
    if (! ((int )p == (int )*(hprev + pp))) {
      {
#line 290
      __assert_fail("p == hprev[pp]", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                    290U, "ZopfliFindLongestMatch");
      }
    }
#line 291
    if (! (*(hhashval + p) == hval)) {
      {
#line 291
      __assert_fail("hhashval[p] == hval", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                    291U, "ZopfliFindLongestMatch");
      }
    }
#line 293
    if (dist > 0U) {
#line 294
      if (! (pos < size)) {
        {
#line 294
        __assert_fail("pos < size", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                      294U, "ZopfliFindLongestMatch");
        }
      }
#line 295
      if (! ((size_t )dist <= pos)) {
        {
#line 295
        __assert_fail("dist <= pos", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                      295U, "ZopfliFindLongestMatch");
        }
      }
#line 296
      scan = array + pos;
#line 297
      match = array + (pos - (size_t )dist);
#line 300
      if (pos + (size_t )bestlength >= size) {
#line 300
        goto _L;
      } else
#line 300
      if ((int const   )*(scan + (int )bestlength) == (int const   )*(match + (int )bestlength)) {
        _L: /* CIL Label */ 
#line 304
        same0 = *(h->same + (pos & 32767UL));
#line 305
        if ((int )same0 > 2) {
#line 305
          if ((int const   )*scan == (int const   )*match) {
#line 306
            same1 = *(h->same + ((pos - (size_t )dist) & 32767UL));
#line 307
            if ((int )same0 < (int )same1) {
#line 307
              tmp___0 = (int )same0;
            } else {
#line 307
              tmp___0 = (int )same1;
            }
#line 307
            same = (unsigned short )tmp___0;
#line 308
            if ((size_t )same > limit) {
#line 308
              same = (unsigned short )limit;
            }
#line 309
            scan += (int )same;
#line 310
            match += (int )same;
          }
        }
        {
#line 313
        scan = GetMatch(scan, match, arrayend, arrayend_safe);
#line 314
        currentlength = (unsigned short )(scan - (array + pos));
        }
      }
#line 317
      if ((int )currentlength > (int )bestlength) {
#line 318
        if (sublen) {
#line 320
          j = (unsigned short )((int )bestlength + 1);
          {
#line 320
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 320
            if (! ((int )j <= (int )currentlength)) {
#line 320
              goto while_break___0;
            }
#line 321
            *(sublen + j) = (unsigned short )dist;
#line 320
            j = (unsigned short )((int )j + 1);
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 324
        bestdist = (unsigned short )dist;
#line 325
        bestlength = currentlength;
#line 326
        if ((size_t )currentlength >= limit) {
#line 326
          goto while_break;
        }
      }
    }
#line 333
    if ((unsigned long )hhead != (unsigned long )h->head2) {
#line 333
      if ((int )bestlength >= (int )*(h->same + hpos)) {
#line 333
        if (h->val2 == (int const   )*(h->hashval2 + p)) {
#line 336
          hhead = (int *)h->head2;
#line 337
          hprev = (unsigned short *)h->prev2;
#line 338
          hhashval = (int *)h->hashval2;
#line 339
          hval = (int )h->val2;
        }
      }
    }
#line 343
    pp = p;
#line 344
    p = *(hprev + p);
#line 345
    if ((int )p == (int )pp) {
#line 345
      goto while_break;
    }
#line 347
    if ((int )p < (int )pp) {
#line 347
      tmp___1 = (int )pp - (int )p;
    } else {
#line 347
      tmp___1 = (32768 - (int )p) + (int )pp;
    }
#line 347
    dist += (unsigned int )tmp___1;
#line 350
    chain_counter --;
#line 351
    if (chain_counter <= 0) {
#line 351
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  StoreInLongestMatchCache(s, pos, limit, (unsigned short const   *)sublen, bestdist,
                           bestlength);
  }
#line 359
  if (! ((size_t )bestlength <= limit)) {
    {
#line 359
    __assert_fail("bestlength <= limit", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  359U, "ZopfliFindLongestMatch");
    }
  }
#line 361
  *distance = bestdist;
#line 362
  *length = bestlength;
#line 363
  if (! (pos + (size_t )*length <= size)) {
    {
#line 363
    __assert_fail("pos + *length <= size", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                  363U, "ZopfliFindLongestMatch");
    }
  }
#line 364
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliLZ77Greedy(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                      size_t inend , ZopfliLZ77Store *store ) 
{ 
  size_t i ;
  size_t j ;
  unsigned short leng ;
  unsigned short dist ;
  int lengthscore ;
  size_t windowstart ;
  size_t tmp ;
  unsigned short dummysublen[259] ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  unsigned int prev_length ;
  unsigned int prev_match ;
  int prevlengthscore ;
  int match_available ;

  {
#line 369
  i = (size_t )0;
#line 373
  if (instart > 32768UL) {
#line 373
    tmp = instart - 32768UL;
  } else {
#line 373
    tmp = (size_t )0;
  }
#line 373
  windowstart = tmp;
#line 378
  h = & hash;
#line 382
  prev_length = 0U;
#line 383
  prev_match = 0U;
#line 385
  match_available = 0;
#line 388
  if (instart == inend) {
#line 388
    return;
  }
  {
#line 390
  ZopfliInitHash((size_t )32768, h);
#line 391
  ZopfliWarmupHash(in, windowstart, inend, h);
#line 392
  i = windowstart;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i < instart)) {
#line 392
      goto while_break;
    }
    {
#line 393
    ZopfliUpdateHash(in, i, inend, h);
#line 392
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  i = instart;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (i < inend)) {
#line 396
      goto while_break___0;
    }
    {
#line 397
    ZopfliUpdateHash(in, i, inend, h);
#line 399
    ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in, i, inend, (size_t )258,
                           dummysublen, & dist, & leng);
#line 401
    lengthscore = GetLengthScore((int )leng, (int )dist);
#line 405
    prevlengthscore = GetLengthScore((int )prev_length, (int )prev_match);
    }
#line 406
    if (match_available) {
#line 407
      match_available = 0;
#line 408
      if (lengthscore > prevlengthscore + 1) {
        {
#line 409
        ZopfliStoreLitLenDist((unsigned short )*(in + (i - 1UL)), (unsigned short)0,
                              store);
        }
#line 410
        if (lengthscore >= 3) {
#line 410
          if ((int )leng < 258) {
#line 411
            match_available = 1;
#line 412
            prev_length = (unsigned int )leng;
#line 413
            prev_match = (unsigned int )dist;
#line 414
            goto __Cont;
          }
        }
      } else {
        {
#line 418
        leng = (unsigned short )prev_length;
#line 419
        dist = (unsigned short )prev_match;
#line 420
        lengthscore = prevlengthscore;
#line 422
        ZopfliVerifyLenDist(in, inend, i - 1UL, dist, leng);
#line 423
        ZopfliStoreLitLenDist(leng, dist, store);
#line 424
        j = (size_t )2;
        }
        {
#line 424
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 424
          if (! (j < (size_t )leng)) {
#line 424
            goto while_break___1;
          }
#line 425
          if (! (i < inend)) {
            {
#line 425
            __assert_fail("i < inend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                          425U, "ZopfliLZ77Greedy");
            }
          }
          {
#line 426
          i ++;
#line 427
          ZopfliUpdateHash(in, i, inend, h);
#line 424
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 429
        goto __Cont;
      }
    } else
#line 432
    if (lengthscore >= 3) {
#line 432
      if ((int )leng < 258) {
#line 433
        match_available = 1;
#line 434
        prev_length = (unsigned int )leng;
#line 435
        prev_match = (unsigned int )dist;
#line 436
        goto __Cont;
      }
    }
#line 442
    if (lengthscore >= 3) {
      {
#line 443
      ZopfliVerifyLenDist(in, inend, i, dist, leng);
#line 444
      ZopfliStoreLitLenDist(leng, dist, store);
      }
    } else {
      {
#line 446
      leng = (unsigned short)1;
#line 447
      ZopfliStoreLitLenDist((unsigned short )*(in + i), (unsigned short)0, store);
      }
    }
#line 449
    j = (size_t )1;
    {
#line 449
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 449
      if (! (j < (size_t )leng)) {
#line 449
        goto while_break___2;
      }
#line 450
      if (! (i < inend)) {
        {
#line 450
        __assert_fail("i < inend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c",
                      450U, "ZopfliLZ77Greedy");
        }
      }
      {
#line 451
      i ++;
#line 452
      ZopfliUpdateHash(in, i, inend, h);
#line 449
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 396
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 456
  ZopfliCleanHash(h);
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/lz77.c"
void ZopfliLZ77Counts(unsigned short const   *litlens , unsigned short const   *dists ,
                      size_t start , size_t end , size_t *ll_count , size_t *d_count ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 465
  i = (size_t )0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < 288UL)) {
#line 465
      goto while_break;
    }
#line 466
    *(ll_count + i) = (size_t )0;
#line 465
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  i = (size_t )0;
  {
#line 468
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 468
    if (! (i < 32UL)) {
#line 468
      goto while_break___0;
    }
#line 469
    *(d_count + i) = (size_t )0;
#line 468
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 472
  i = start;
  {
#line 472
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 472
    if (! (i < end)) {
#line 472
      goto while_break___1;
    }
#line 473
    if ((int const   )*(dists + i) == 0) {
#line 474
      (*(ll_count + *(litlens + i))) ++;
    } else {
      {
#line 476
      tmp = ZopfliGetLengthSymbol((int )*(litlens + i));
#line 476
      (*(ll_count + tmp)) ++;
#line 477
      tmp___0 = ZopfliGetDistSymbol((int )*(dists + i));
#line 477
      (*(d_count + tmp___0)) ++;
      }
    }
#line 472
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 481
  *(ll_count + 256) = (size_t )1;
#line 482
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.h"
void ZopfliDeflatePart(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in ,
                       size_t instart , size_t inend , unsigned char *bp , unsigned char **out ,
                       size_t *outsize ) ;
#line 74
double ZopfliCalculateBlockSize(unsigned short const   *litlens , unsigned short const   *dists ,
                                size_t lstart , size_t lend , int btype ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.h"
void ZopfliBlockSplitLZ77(ZopfliOptions const   *options , unsigned short const   *litlens ,
                          unsigned short const   *dists , size_t llsize , size_t maxblocks ,
                          size_t **splitpoints , size_t *npoints ) ;
#line 64
void ZopfliBlockSplit(ZopfliOptions const   *options , unsigned char const   *in ,
                      size_t instart , size_t inend , size_t maxblocks , size_t **splitpoints ,
                      size_t *npoints ) ;
#line 72
void ZopfliBlockSplitSimple(unsigned char const   *in , size_t instart , size_t inend ,
                            size_t blocksize , size_t **splitpoints , size_t *npoints ) ;
#line 126 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.h"
int ZopfliGetLengthExtraBits(int l ) ;
#line 129
int ZopfliGetLengthExtraBitsValue(int l ) ;
#line 135
int ZopfliGetDistExtraBits(int dist ) ;
#line 138
int ZopfliGetDistExtraBitsValue(int dist ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.h"
void ZopfliInitCache(size_t blocksize , ZopfliLongestMatchCache *lmc ) ;
#line 49
void ZopfliCleanCache(ZopfliLongestMatchCache *lmc ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.h"
void ZopfliLZ77Optimal(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                       size_t inend , ZopfliLZ77Store *store ) ;
#line 55
void ZopfliLZ77OptimalFixed(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                            size_t inend , ZopfliLZ77Store *store ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.h"
void ZopfliCalculateBitLengths(size_t const   *count , size_t n , int maxbits , unsigned int *bitlengths ) ;
#line 39
void ZopfliLengthsToSymbols(unsigned int const   *lengths , size_t n , unsigned int maxbits ,
                            unsigned int *symbols ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddBit(int bit , unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 33
  if (((int )*bp & 7) == 0) {
#line 33
    if (! (*outsize & (*outsize - 1UL))) {
#line 33
      if (*outsize == 0UL) {
        {
#line 33
        tmp = malloc(sizeof(*(*out)));
#line 33
        *out = (unsigned char *)tmp;
        }
      } else {
        {
#line 33
        tmp___0 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 33
        *out = (unsigned char *)tmp___0;
        }
      }
    }
#line 33
    *(*out + *outsize) = (unsigned char)0;
#line 33
    (*outsize) ++;
  }
#line 34
  *(*out + (*outsize - 1UL)) = (unsigned char )((int )*(*out + (*outsize - 1UL)) | (bit << ((int )*bp & 7)));
#line 35
  *bp = (unsigned char )((int )*bp + 1);
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddBits(unsigned int symbol , unsigned int length , unsigned char *bp ,
                    unsigned char **out , size_t *outsize ) 
{ 
  unsigned int i ;
  unsigned int bit ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 42
  i = 0U;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < length)) {
#line 42
      goto while_break;
    }
#line 43
    bit = (symbol >> i) & 1U;
#line 44
    if (((int )*bp & 7) == 0) {
#line 44
      if (! (*outsize & (*outsize - 1UL))) {
#line 44
        if (*outsize == 0UL) {
          {
#line 44
          tmp = malloc(sizeof(*(*out)));
#line 44
          *out = (unsigned char *)tmp;
          }
        } else {
          {
#line 44
          tmp___0 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 44
          *out = (unsigned char *)tmp___0;
          }
        }
      }
#line 44
      *(*out + *outsize) = (unsigned char)0;
#line 44
      (*outsize) ++;
    }
#line 45
    *(*out + (*outsize - 1UL)) = (unsigned char )((unsigned int )*(*out + (*outsize - 1UL)) | (bit << ((int )*bp & 7)));
#line 46
    *bp = (unsigned char )((int )*bp + 1);
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddHuffmanBits(unsigned int symbol , unsigned int length , unsigned char *bp ,
                           unsigned char **out , size_t *outsize ) 
{ 
  unsigned int i ;
  unsigned int bit ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 59
  i = 0U;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < length)) {
#line 59
      goto while_break;
    }
#line 60
    bit = (symbol >> ((length - i) - 1U)) & 1U;
#line 61
    if (((int )*bp & 7) == 0) {
#line 61
      if (! (*outsize & (*outsize - 1UL))) {
#line 61
        if (*outsize == 0UL) {
          {
#line 61
          tmp = malloc(sizeof(*(*out)));
#line 61
          *out = (unsigned char *)tmp;
          }
        } else {
          {
#line 61
          tmp___0 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 61
          *out = (unsigned char *)tmp___0;
          }
        }
      }
#line 61
      *(*out + *outsize) = (unsigned char)0;
#line 61
      (*outsize) ++;
    }
#line 62
    *(*out + (*outsize - 1UL)) = (unsigned char )((unsigned int )*(*out + (*outsize - 1UL)) | (bit << ((int )*bp & 7)));
#line 63
    *bp = (unsigned char )((int )*bp + 1);
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void PatchDistanceCodesForBuggyDecoders(unsigned int *d_lengths ) 
{ 
  int num_dist_codes ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 80
  num_dist_codes = 0;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < 30)) {
#line 82
      goto while_break;
    }
#line 83
    if (*(d_lengths + i)) {
#line 83
      num_dist_codes ++;
    }
#line 84
    if (num_dist_codes >= 2) {
#line 84
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (num_dist_codes == 0) {
#line 88
    tmp = 1U;
#line 88
    *(d_lengths + 1) = tmp;
#line 88
    *(d_lengths + 0) = tmp;
  } else
#line 89
  if (num_dist_codes == 1) {
#line 90
    if (*(d_lengths + 0)) {
#line 90
      tmp___0 = 1;
    } else {
#line 90
      tmp___0 = 0;
    }
#line 90
    *(d_lengths + tmp___0) = 1U;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddDynamicTree(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                           unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  unsigned int *lld_lengths ;
  unsigned int lld_total ;
  unsigned int *rle ;
  unsigned int *rle_bits ;
  size_t rle_size ;
  size_t rle_bits_size ;
  unsigned int hlit ;
  unsigned int hdist ;
  unsigned int hclen ;
  size_t i ;
  size_t j ;
  size_t clcounts[19] ;
  unsigned int clcl[19] ;
  unsigned int clsymbols[19] ;
  unsigned int order[19] ;
  void *tmp ;
  size_t count ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  unsigned int repeat ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  unsigned int symbol ;

  {
#line 98
  lld_lengths = (unsigned int *)0;
#line 101
  rle = (unsigned int *)0;
#line 103
  rle_bits = (unsigned int *)0;
#line 104
  rle_size = (size_t )0;
#line 105
  rle_bits_size = (size_t )0;
#line 106
  hlit = 29U;
#line 107
  hdist = 29U;
#line 114
  order[0] = 16U;
#line 114
  order[1] = 17U;
#line 114
  order[2] = 18U;
#line 114
  order[3] = 0U;
#line 114
  order[4] = 8U;
#line 114
  order[5] = 7U;
#line 114
  order[6] = 9U;
#line 114
  order[7] = 6U;
#line 114
  order[8] = 10U;
#line 114
  order[9] = 5U;
#line 114
  order[10] = 11U;
#line 114
  order[11] = 4U;
#line 114
  order[12] = 12U;
#line 114
  order[13] = 3U;
#line 114
  order[14] = 13U;
#line 114
  order[15] = 2U;
#line 114
  order[16] = 14U;
#line 114
  order[17] = 1U;
#line 114
  order[18] = 15U;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (hlit > 0U) {
#line 119
      if (! (*(ll_lengths + ((257U + hlit) - 1U)) == 0U)) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
#line 119
    hlit --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (hdist > 0U) {
#line 120
      if (! (*(d_lengths + ((1U + hdist) - 1U)) == 0U)) {
#line 120
        goto while_break___0;
      }
    } else {
#line 120
      goto while_break___0;
    }
#line 120
    hdist --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  lld_total = ((hlit + 257U) + hdist) + 1U;
#line 123
  tmp = malloc(sizeof(*lld_lengths) * (unsigned long )lld_total);
#line 123
  lld_lengths = (unsigned int *)tmp;
  }
#line 124
  if (! lld_lengths) {
    {
#line 124
    exit(-1);
    }
  }
#line 126
  i = (size_t )0;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! (i < (size_t )lld_total)) {
#line 126
      goto while_break___1;
    }
#line 127
    if (i < (size_t )(257U + hlit)) {
#line 127
      *(lld_lengths + i) = (unsigned int )*(ll_lengths + i);
    } else {
#line 127
      *(lld_lengths + i) = (unsigned int )*(d_lengths + ((i - 257UL) - (size_t )hlit));
    }
#line 129
    if (! (*(lld_lengths + i) < 16U)) {
      {
#line 129
      __assert_fail("lld_lengths[i] < 16", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    129U, "AddDynamicTree");
      }
    }
#line 126
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 132
  i = (size_t )0;
  {
#line 132
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 132
    if (! (i < (size_t )lld_total)) {
#line 132
      goto while_break___2;
    }
#line 133
    count = (size_t )0;
#line 134
    j = i;
    {
#line 134
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 134
      if (j < (size_t )lld_total) {
#line 134
        if (! (*(lld_lengths + i) == *(lld_lengths + j))) {
#line 134
          goto while_break___3;
        }
      } else {
#line 134
        goto while_break___3;
      }
#line 135
      count ++;
#line 134
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 137
    if (count >= 4UL) {
#line 137
      goto _L;
    } else
#line 137
    if (count >= 3UL) {
#line 137
      if (*(lld_lengths + i) == 0U) {
        _L: /* CIL Label */ 
#line 138
        if (*(lld_lengths + i) == 0U) {
#line 139
          if (count > 10UL) {
#line 140
            if (count > 138UL) {
#line 140
              count = (size_t )138;
            }
#line 141
            if (! (rle_size & (rle_size - 1UL))) {
#line 141
              if (rle_size == 0UL) {
                {
#line 141
                tmp___0 = malloc(sizeof(*rle));
#line 141
                rle = (unsigned int *)tmp___0;
                }
              } else {
                {
#line 141
                tmp___1 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 141
                rle = (unsigned int *)tmp___1;
                }
              }
            }
#line 141
            *(rle + rle_size) = 18U;
#line 141
            rle_size ++;
#line 142
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 142
              if (rle_bits_size == 0UL) {
                {
#line 142
                tmp___2 = malloc(sizeof(*rle_bits));
#line 142
                rle_bits = (unsigned int *)tmp___2;
                }
              } else {
                {
#line 142
                tmp___3 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 142
                rle_bits = (unsigned int *)tmp___3;
                }
              }
            }
#line 142
            *(rle_bits + rle_bits_size) = (unsigned int )(count - 11UL);
#line 142
            rle_bits_size ++;
          } else {
#line 144
            if (! (rle_size & (rle_size - 1UL))) {
#line 144
              if (rle_size == 0UL) {
                {
#line 144
                tmp___4 = malloc(sizeof(*rle));
#line 144
                rle = (unsigned int *)tmp___4;
                }
              } else {
                {
#line 144
                tmp___5 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 144
                rle = (unsigned int *)tmp___5;
                }
              }
            }
#line 144
            *(rle + rle_size) = 17U;
#line 144
            rle_size ++;
#line 145
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 145
              if (rle_bits_size == 0UL) {
                {
#line 145
                tmp___6 = malloc(sizeof(*rle_bits));
#line 145
                rle_bits = (unsigned int *)tmp___6;
                }
              } else {
                {
#line 145
                tmp___7 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 145
                rle_bits = (unsigned int *)tmp___7;
                }
              }
            }
#line 145
            *(rle_bits + rle_bits_size) = (unsigned int )(count - 3UL);
#line 145
            rle_bits_size ++;
          }
        } else {
#line 148
          repeat = (unsigned int )(count - 1UL);
#line 149
          if (! (rle_size & (rle_size - 1UL))) {
#line 149
            if (rle_size == 0UL) {
              {
#line 149
              tmp___8 = malloc(sizeof(*rle));
#line 149
              rle = (unsigned int *)tmp___8;
              }
            } else {
              {
#line 149
              tmp___9 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 149
              rle = (unsigned int *)tmp___9;
              }
            }
          }
#line 149
          *(rle + rle_size) = *(lld_lengths + i);
#line 149
          rle_size ++;
#line 150
          if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 150
            if (rle_bits_size == 0UL) {
              {
#line 150
              tmp___10 = malloc(sizeof(*rle_bits));
#line 150
              rle_bits = (unsigned int *)tmp___10;
              }
            } else {
              {
#line 150
              tmp___11 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 150
              rle_bits = (unsigned int *)tmp___11;
              }
            }
          }
#line 150
          *(rle_bits + rle_bits_size) = 0U;
#line 150
          rle_bits_size ++;
          {
#line 151
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 151
            if (! (repeat >= 6U)) {
#line 151
              goto while_break___4;
            }
#line 152
            if (! (rle_size & (rle_size - 1UL))) {
#line 152
              if (rle_size == 0UL) {
                {
#line 152
                tmp___12 = malloc(sizeof(*rle));
#line 152
                rle = (unsigned int *)tmp___12;
                }
              } else {
                {
#line 152
                tmp___13 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 152
                rle = (unsigned int *)tmp___13;
                }
              }
            }
#line 152
            *(rle + rle_size) = 16U;
#line 152
            rle_size ++;
#line 153
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 153
              if (rle_bits_size == 0UL) {
                {
#line 153
                tmp___14 = malloc(sizeof(*rle_bits));
#line 153
                rle_bits = (unsigned int *)tmp___14;
                }
              } else {
                {
#line 153
                tmp___15 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 153
                rle_bits = (unsigned int *)tmp___15;
                }
              }
            }
#line 153
            *(rle_bits + rle_bits_size) = 3U;
#line 153
            rle_bits_size ++;
#line 154
            repeat -= 6U;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 156
          if (repeat >= 3U) {
#line 157
            if (! (rle_size & (rle_size - 1UL))) {
#line 157
              if (rle_size == 0UL) {
                {
#line 157
                tmp___16 = malloc(sizeof(*rle));
#line 157
                rle = (unsigned int *)tmp___16;
                }
              } else {
                {
#line 157
                tmp___17 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 157
                rle = (unsigned int *)tmp___17;
                }
              }
            }
#line 157
            *(rle + rle_size) = 16U;
#line 157
            rle_size ++;
#line 158
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 158
              if (rle_bits_size == 0UL) {
                {
#line 158
                tmp___18 = malloc(sizeof(*rle_bits));
#line 158
                rle_bits = (unsigned int *)tmp___18;
                }
              } else {
                {
#line 158
                tmp___19 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 158
                rle_bits = (unsigned int *)tmp___19;
                }
              }
            }
#line 158
            *(rle_bits + rle_bits_size) = 0U;
#line 158
            rle_bits_size ++;
#line 159
            repeat -= 3U;
          }
          {
#line 161
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 161
            if (! (repeat != 0U)) {
#line 161
              goto while_break___5;
            }
#line 162
            if (! (rle_size & (rle_size - 1UL))) {
#line 162
              if (rle_size == 0UL) {
                {
#line 162
                tmp___20 = malloc(sizeof(*rle));
#line 162
                rle = (unsigned int *)tmp___20;
                }
              } else {
                {
#line 162
                tmp___21 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 162
                rle = (unsigned int *)tmp___21;
                }
              }
            }
#line 162
            *(rle + rle_size) = *(lld_lengths + i);
#line 162
            rle_size ++;
#line 163
            if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 163
              if (rle_bits_size == 0UL) {
                {
#line 163
                tmp___22 = malloc(sizeof(*rle_bits));
#line 163
                rle_bits = (unsigned int *)tmp___22;
                }
              } else {
                {
#line 163
                tmp___23 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 163
                rle_bits = (unsigned int *)tmp___23;
                }
              }
            }
#line 163
            *(rle_bits + rle_bits_size) = 0U;
#line 163
            rle_bits_size ++;
#line 164
            repeat --;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 168
        i += count - 1UL;
      } else {
#line 137
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 170
      if (! (rle_size & (rle_size - 1UL))) {
#line 170
        if (rle_size == 0UL) {
          {
#line 170
          tmp___24 = malloc(sizeof(*rle));
#line 170
          rle = (unsigned int *)tmp___24;
          }
        } else {
          {
#line 170
          tmp___25 = realloc((void *)rle, (rle_size * 2UL) * sizeof(*rle));
#line 170
          rle = (unsigned int *)tmp___25;
          }
        }
      }
#line 170
      *(rle + rle_size) = *(lld_lengths + i);
#line 170
      rle_size ++;
#line 171
      if (! (rle_bits_size & (rle_bits_size - 1UL))) {
#line 171
        if (rle_bits_size == 0UL) {
          {
#line 171
          tmp___26 = malloc(sizeof(*rle_bits));
#line 171
          rle_bits = (unsigned int *)tmp___26;
          }
        } else {
          {
#line 171
          tmp___27 = realloc((void *)rle_bits, (rle_bits_size * 2UL) * sizeof(*rle_bits));
#line 171
          rle_bits = (unsigned int *)tmp___27;
          }
        }
      }
#line 171
      *(rle_bits + rle_bits_size) = 0U;
#line 171
      rle_bits_size ++;
    }
#line 173
    if (! (*(rle + (rle_size - 1UL)) <= 18U)) {
      {
#line 173
      __assert_fail("rle[rle_size - 1] <= 18", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    173U, "AddDynamicTree");
      }
    }
#line 132
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 176
  i = (size_t )0;
  {
#line 176
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 176
    if (! (i < 19UL)) {
#line 176
      goto while_break___6;
    }
#line 177
    clcounts[i] = (size_t )0;
#line 176
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 179
  i = (size_t )0;
  {
#line 179
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 179
    if (! (i < rle_size)) {
#line 179
      goto while_break___7;
    }
#line 180
    (clcounts[*(rle + i)]) ++;
#line 179
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 183
  ZopfliCalculateBitLengths((size_t const   *)(clcounts), (size_t )19, 7, clcl);
#line 184
  ZopfliLengthsToSymbols((unsigned int const   *)(clcl), (size_t )19, 7U, clsymbols);
#line 186
  hclen = 15U;
  }
  {
#line 188
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 188
    if (hclen > 0U) {
#line 188
      if (! (clcounts[order[(hclen + 4U) - 1U]] == 0UL)) {
#line 188
        goto while_break___8;
      }
    } else {
#line 188
      goto while_break___8;
    }
#line 188
    hclen --;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 190
  AddBits(hlit, 5U, bp, out, outsize);
#line 191
  AddBits(hdist, 5U, bp, out, outsize);
#line 192
  AddBits(hclen, 4U, bp, out, outsize);
#line 194
  i = (size_t )0;
  }
  {
#line 194
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 194
    if (! (i < (size_t )(hclen + 4U))) {
#line 194
      goto while_break___9;
    }
    {
#line 195
    AddBits(clcl[order[i]], 3U, bp, out, outsize);
#line 194
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 198
  i = (size_t )0;
  {
#line 198
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 198
    if (! (i < rle_size)) {
#line 198
      goto while_break___10;
    }
    {
#line 199
    symbol = clsymbols[*(rle + i)];
#line 200
    AddHuffmanBits(symbol, clcl[*(rle + i)], bp, out, outsize);
    }
#line 202
    if (*(rle + i) == 16U) {
      {
#line 202
      AddBits(*(rle_bits + i), 2U, bp, out, outsize);
      }
    } else
#line 203
    if (*(rle + i) == 17U) {
      {
#line 203
      AddBits(*(rle_bits + i), 3U, bp, out, outsize);
      }
    } else
#line 204
    if (*(rle + i) == 18U) {
      {
#line 204
      AddBits(*(rle_bits + i), 7U, bp, out, outsize);
      }
    }
#line 198
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 207
  free((void *)lld_lengths);
#line 208
  free((void *)rle);
#line 209
  free((void *)rle_bits);
  }
#line 210
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static size_t CalculateTreeSize(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                                size_t *ll_counts , size_t *d_counts ) 
{ 
  unsigned char *dummy ;
  size_t dummysize ;
  unsigned char bp ;

  {
  {
#line 218
  dummy = (unsigned char *)0;
#line 219
  dummysize = (size_t )0;
#line 220
  bp = (unsigned char)0;
#line 225
  AddDynamicTree(ll_lengths, d_lengths, & bp, & dummy, & dummysize);
#line 226
  free((void *)dummy);
  }
#line 228
  return (dummysize * 8UL + (size_t )((int )bp & 7));
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddLZ77Data(unsigned short const   *litlens , unsigned short const   *dists ,
                        size_t lstart , size_t lend , size_t expected_data_size ,
                        unsigned int const   *ll_symbols , unsigned int const   *ll_lengths ,
                        unsigned int const   *d_symbols , unsigned int const   *d_lengths ,
                        unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  size_t testlength ;
  size_t i ;
  unsigned int dist ;
  unsigned int litlen ;
  unsigned int lls ;
  int tmp ;
  unsigned int ds ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 244
  testlength = (size_t )0;
#line 247
  i = lstart;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < lend)) {
#line 247
      goto while_break;
    }
#line 248
    dist = (unsigned int )*(dists + i);
#line 249
    litlen = (unsigned int )*(litlens + i);
#line 250
    if (dist == 0U) {
#line 251
      if (! (litlen < 256U)) {
        {
#line 251
        __assert_fail("litlen < 256", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                      251U, "AddLZ77Data");
        }
      }
#line 252
      if (! (*(ll_lengths + litlen) > 0U)) {
        {
#line 252
        __assert_fail("ll_lengths[litlen] > 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                      252U, "AddLZ77Data");
        }
      }
      {
#line 253
      AddHuffmanBits((unsigned int )*(ll_symbols + litlen), (unsigned int )*(ll_lengths + litlen),
                     bp, out, outsize);
#line 254
      testlength ++;
      }
    } else {
      {
#line 256
      tmp = ZopfliGetLengthSymbol((int )litlen);
#line 256
      lls = (unsigned int )tmp;
#line 257
      tmp___0 = ZopfliGetDistSymbol((int )dist);
#line 257
      ds = (unsigned int )tmp___0;
      }
#line 258
      if (litlen >= 3U) {
#line 258
        if (! (litlen <= 288U)) {
          {
#line 258
          __assert_fail("litlen >= 3 && litlen <= 288", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                        258U, "AddLZ77Data");
          }
        }
      } else {
        {
#line 258
        __assert_fail("litlen >= 3 && litlen <= 288", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                      258U, "AddLZ77Data");
        }
      }
#line 259
      if (! (*(ll_lengths + lls) > 0U)) {
        {
#line 259
        __assert_fail("ll_lengths[lls] > 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                      259U, "AddLZ77Data");
        }
      }
#line 260
      if (! (*(d_lengths + ds) > 0U)) {
        {
#line 260
        __assert_fail("d_lengths[ds] > 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                      260U, "AddLZ77Data");
        }
      }
      {
#line 261
      AddHuffmanBits((unsigned int )*(ll_symbols + lls), (unsigned int )*(ll_lengths + lls),
                     bp, out, outsize);
#line 262
      tmp___1 = ZopfliGetLengthExtraBits((int )litlen);
#line 262
      tmp___2 = ZopfliGetLengthExtraBitsValue((int )litlen);
#line 262
      AddBits((unsigned int )tmp___2, (unsigned int )tmp___1, bp, out, outsize);
#line 265
      AddHuffmanBits((unsigned int )*(d_symbols + ds), (unsigned int )*(d_lengths + ds),
                     bp, out, outsize);
#line 266
      tmp___3 = ZopfliGetDistExtraBits((int )dist);
#line 266
      tmp___4 = ZopfliGetDistExtraBitsValue((int )dist);
#line 266
      AddBits((unsigned int )tmp___4, (unsigned int )tmp___3, bp, out, outsize);
#line 269
      testlength += (size_t )litlen;
      }
    }
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (! (expected_data_size == 0UL)) {
#line 272
    if (! (testlength == expected_data_size)) {
      {
#line 272
      __assert_fail("expected_data_size == 0 || testlength == expected_data_size",
                    "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    272U, "AddLZ77Data");
      }
    }
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void GetFixedTree(unsigned int *ll_lengths , unsigned int *d_lengths ) 
{ 
  size_t i ;

  {
#line 277
  i = (size_t )0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < 144UL)) {
#line 277
      goto while_break;
    }
#line 277
    *(ll_lengths + i) = 8U;
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  i = (size_t )144;
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 278
    if (! (i < 256UL)) {
#line 278
      goto while_break___0;
    }
#line 278
    *(ll_lengths + i) = 9U;
#line 278
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 279
  i = (size_t )256;
  {
#line 279
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 279
    if (! (i < 280UL)) {
#line 279
      goto while_break___1;
    }
#line 279
    *(ll_lengths + i) = 7U;
#line 279
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 280
  i = (size_t )280;
  {
#line 280
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 280
    if (! (i < 288UL)) {
#line 280
      goto while_break___2;
    }
#line 280
    *(ll_lengths + i) = 8U;
#line 280
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 281
  i = (size_t )0;
  {
#line 281
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 281
    if (! (i < 32UL)) {
#line 281
      goto while_break___3;
    }
#line 281
    *(d_lengths + i) = 5U;
#line 281
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 282
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static size_t CalculateBlockSymbolSize(unsigned int const   *ll_lengths , unsigned int const   *d_lengths ,
                                       unsigned short const   *litlens , unsigned short const   *dists ,
                                       size_t lstart , size_t lend ) 
{ 
  size_t result ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 292
  result = (size_t )0;
#line 294
  i = lstart;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < lend)) {
#line 294
      goto while_break;
    }
#line 295
    if ((int const   )*(dists + i) == 0) {
#line 296
      result += (size_t )*(ll_lengths + *(litlens + i));
    } else {
      {
#line 298
      tmp = ZopfliGetLengthSymbol((int )*(litlens + i));
#line 298
      result += (size_t )*(ll_lengths + tmp);
#line 299
      tmp___0 = ZopfliGetDistSymbol((int )*(dists + i));
#line 299
      result += (size_t )*(d_lengths + tmp___0);
#line 300
      tmp___1 = ZopfliGetLengthExtraBits((int )*(litlens + i));
#line 300
      result += (size_t )tmp___1;
#line 301
      tmp___2 = ZopfliGetDistExtraBits((int )*(dists + i));
#line 301
      result += (size_t )tmp___2;
      }
    }
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  result += (size_t )*(ll_lengths + 256);
#line 305
  return (result);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
double ZopfliCalculateBlockSize(unsigned short const   *litlens , unsigned short const   *dists ,
                                size_t lstart , size_t lend , int btype ) 
{ 
  size_t ll_counts[288] ;
  size_t d_counts[32] ;
  unsigned int ll_lengths[288] ;
  unsigned int d_lengths[32] ;
  double result ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 317
  result = (double )3;
#line 319
  if (! (btype == 1)) {
#line 319
    if (! (btype == 2)) {
      {
#line 319
      __assert_fail("btype == 1 || btype == 2", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    319U, "ZopfliCalculateBlockSize");
      }
    }
  }
#line 321
  if (btype == 1) {
    {
#line 322
    GetFixedTree(ll_lengths, d_lengths);
    }
  } else {
    {
#line 324
    ZopfliLZ77Counts(litlens, dists, lstart, lend, ll_counts, d_counts);
#line 325
    ZopfliCalculateBitLengths((size_t const   *)(ll_counts), (size_t )288, 15, ll_lengths);
#line 326
    ZopfliCalculateBitLengths((size_t const   *)(d_counts), (size_t )32, 15, d_lengths);
#line 327
    PatchDistanceCodesForBuggyDecoders(d_lengths);
#line 328
    tmp = CalculateTreeSize((unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_lengths),
                            ll_counts, d_counts);
#line 328
    result += (double )tmp;
    }
  }
  {
#line 331
  tmp___0 = CalculateBlockSymbolSize((unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_lengths),
                                     litlens, dists, lstart, lend);
#line 331
  result += (double )tmp___0;
  }
#line 334
  return (result);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void AddLZ77Block(ZopfliOptions const   *options , int btype , int final ,
                         unsigned short const   *litlens , unsigned short const   *dists ,
                         size_t lstart , size_t lend , size_t expected_data_size ,
                         unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  size_t ll_counts[288] ;
  size_t d_counts[32] ;
  unsigned int ll_lengths[288] ;
  unsigned int d_lengths[32] ;
  unsigned int ll_symbols[288] ;
  unsigned int d_symbols[32] ;
  size_t detect_block_size ;
  size_t compressed_size ;
  size_t uncompressed_size ;
  size_t i ;
  unsigned int detect_tree_size ;
  int tmp ;

  {
  {
#line 366
  detect_block_size = *outsize;
#line 368
  uncompressed_size = (size_t )0;
#line 371
  AddBit(final, bp, out, outsize);
#line 372
  AddBit(btype & 1, bp, out, outsize);
#line 373
  AddBit((btype & 2) >> 1, bp, out, outsize);
  }
#line 375
  if (btype == 1) {
    {
#line 377
    GetFixedTree(ll_lengths, d_lengths);
    }
  } else {
#line 381
    if (! (btype == 2)) {
      {
#line 381
      __assert_fail("btype == 2", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    381U, "AddLZ77Block");
      }
    }
    {
#line 382
    ZopfliLZ77Counts(litlens, dists, lstart, lend, ll_counts, d_counts);
#line 383
    ZopfliCalculateBitLengths((size_t const   *)(ll_counts), (size_t )288, 15, ll_lengths);
#line 384
    ZopfliCalculateBitLengths((size_t const   *)(d_counts), (size_t )32, 15, d_lengths);
#line 385
    PatchDistanceCodesForBuggyDecoders(d_lengths);
#line 386
    detect_tree_size = (unsigned int )*outsize;
#line 387
    AddDynamicTree((unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_lengths),
                   bp, out, outsize);
    }
#line 388
    if (options->verbose) {
      {
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"treesize: %d\n",
              (int )(*outsize - (size_t )detect_tree_size));
      }
    }
#line 394
    i = (size_t )0;
    {
#line 394
    while (1) {
      while_continue: /* CIL Label */ ;
#line 394
      if (! (i < 288UL)) {
#line 394
        goto while_break;
      }
#line 394
      if (! (ll_counts[i] == 0UL)) {
#line 394
        if (! (ll_lengths[i] > 0U)) {
          {
#line 394
          __assert_fail("ll_counts[i] == 0 || ll_lengths[i] > 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                        394U, "AddLZ77Block");
          }
        }
      }
#line 394
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 395
    i = (size_t )0;
    {
#line 395
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 395
      if (! (i < 32UL)) {
#line 395
        goto while_break___0;
      }
#line 395
      if (! (d_counts[i] == 0UL)) {
#line 395
        if (! (d_lengths[i] > 0U)) {
          {
#line 395
          __assert_fail("d_counts[i] == 0 || d_lengths[i] > 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                        395U, "AddLZ77Block");
          }
        }
      }
#line 395
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 398
  ZopfliLengthsToSymbols((unsigned int const   *)(ll_lengths), (size_t )288, 15U,
                         ll_symbols);
#line 399
  ZopfliLengthsToSymbols((unsigned int const   *)(d_lengths), (size_t )32, 15U, d_symbols);
#line 401
  detect_block_size = *outsize;
#line 402
  AddLZ77Data(litlens, dists, lstart, lend, expected_data_size, (unsigned int const   *)(ll_symbols),
              (unsigned int const   *)(ll_lengths), (unsigned int const   *)(d_symbols),
              (unsigned int const   *)(d_lengths), bp, out, outsize);
#line 406
  AddHuffmanBits(ll_symbols[256], ll_lengths[256], bp, out, outsize);
#line 408
  i = lstart;
  }
  {
#line 408
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 408
    if (! (i < lend)) {
#line 408
      goto while_break___1;
    }
#line 409
    if ((int const   )*(dists + i) == 0) {
#line 409
      tmp = 1;
    } else {
#line 409
      tmp = (int )*(litlens + i);
    }
#line 409
    uncompressed_size += (size_t )tmp;
#line 408
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 411
  compressed_size = *outsize - detect_block_size;
#line 412
  if (options->verbose) {
    {
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"compressed block size: %d (%dk) (unc: %d)\n",
            (int )compressed_size, (int )(compressed_size / 1024UL), (int )uncompressed_size);
    }
  }
#line 417
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateDynamicBlock(ZopfliOptions const   *options , int final , unsigned char const   *in ,
                                size_t instart , size_t inend , unsigned char *bp ,
                                unsigned char **out , size_t *outsize ) 
{ 
  ZopfliBlockState s ;
  size_t blocksize ;
  ZopfliLZ77Store store ;
  int btype ;
  void *tmp ;
  double dyncost ;
  double fixedcost ;
  ZopfliLZ77Store fixedstore ;

  {
  {
#line 425
  blocksize = inend - instart;
#line 427
  btype = 2;
#line 429
  ZopfliInitLZ77Store(& store);
#line 431
  s.options = options;
#line 432
  s.blockstart = instart;
#line 433
  s.blockend = inend;
#line 435
  tmp = malloc(sizeof(ZopfliLongestMatchCache ));
#line 435
  s.lmc = (ZopfliLongestMatchCache *)tmp;
#line 436
  ZopfliInitCache(blocksize, s.lmc);
#line 439
  ZopfliLZ77Optimal(& s, in, instart, inend, & store);
  }
#line 443
  if (store.size < 1000UL) {
    {
#line 446
    ZopfliInitLZ77Store(& fixedstore);
#line 447
    ZopfliLZ77OptimalFixed(& s, in, instart, inend, & fixedstore);
#line 448
    dyncost = ZopfliCalculateBlockSize((unsigned short const   *)store.litlens, (unsigned short const   *)store.dists,
                                       (size_t )0, store.size, 2);
#line 450
    fixedcost = ZopfliCalculateBlockSize((unsigned short const   *)fixedstore.litlens,
                                         (unsigned short const   *)fixedstore.dists,
                                         (size_t )0, fixedstore.size, 1);
    }
#line 452
    if (fixedcost < dyncost) {
      {
#line 453
      btype = 1;
#line 454
      ZopfliCleanLZ77Store(& store);
#line 455
      store = fixedstore;
      }
    } else {
      {
#line 457
      ZopfliCleanLZ77Store(& fixedstore);
      }
    }
  }
  {
#line 461
  AddLZ77Block(s.options, btype, final, (unsigned short const   *)store.litlens, (unsigned short const   *)store.dists,
               (size_t )0, store.size, blocksize, bp, out, outsize);
#line 466
  ZopfliCleanCache(s.lmc);
#line 467
  free((void *)s.lmc);
#line 469
  ZopfliCleanLZ77Store(& store);
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateFixedBlock(ZopfliOptions const   *options , int final , unsigned char const   *in ,
                              size_t instart , size_t inend , unsigned char *bp ,
                              unsigned char **out , size_t *outsize ) 
{ 
  ZopfliBlockState s ;
  size_t blocksize ;
  ZopfliLZ77Store store ;
  void *tmp ;

  {
  {
#line 478
  blocksize = inend - instart;
#line 481
  ZopfliInitLZ77Store(& store);
#line 483
  s.options = options;
#line 484
  s.blockstart = instart;
#line 485
  s.blockend = inend;
#line 487
  tmp = malloc(sizeof(ZopfliLongestMatchCache ));
#line 487
  s.lmc = (ZopfliLongestMatchCache *)tmp;
#line 488
  ZopfliInitCache(blocksize, s.lmc);
#line 491
  ZopfliLZ77OptimalFixed(& s, in, instart, inend, & store);
#line 493
  AddLZ77Block(s.options, 1, final, (unsigned short const   *)store.litlens, (unsigned short const   *)store.dists,
               (size_t )0, store.size, blocksize, bp, out, outsize);
#line 497
  ZopfliCleanCache(s.lmc);
#line 498
  free((void *)s.lmc);
#line 500
  ZopfliCleanLZ77Store(& store);
  }
#line 501
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateNonCompressedBlock(ZopfliOptions const   *options , int final ,
                                      unsigned char const   *in , size_t instart ,
                                      size_t inend , unsigned char *bp , unsigned char **out ,
                                      size_t *outsize ) 
{ 
  size_t i ;
  size_t blocksize ;
  unsigned short nlen ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 509
  blocksize = inend - instart;
#line 510
  nlen = (unsigned short )(~ blocksize);
#line 513
  if (! (blocksize < 65536UL)) {
    {
#line 513
    __assert_fail("blocksize < 65536", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                  513U, "DeflateNonCompressedBlock");
    }
  }
  {
#line 515
  AddBit(final, bp, out, outsize);
#line 517
  AddBit(0, bp, out, outsize);
#line 518
  AddBit(0, bp, out, outsize);
#line 521
  *bp = (unsigned char)0;
  }
#line 523
  if (! (*outsize & (*outsize - 1UL))) {
#line 523
    if (*outsize == 0UL) {
      {
#line 523
      tmp = malloc(sizeof(*(*out)));
#line 523
      *out = (unsigned char *)tmp;
      }
    } else {
      {
#line 523
      tmp___0 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 523
      *out = (unsigned char *)tmp___0;
      }
    }
  }
#line 523
  *(*out + *outsize) = (unsigned char )(blocksize % 256UL);
#line 523
  (*outsize) ++;
#line 524
  if (! (*outsize & (*outsize - 1UL))) {
#line 524
    if (*outsize == 0UL) {
      {
#line 524
      tmp___1 = malloc(sizeof(*(*out)));
#line 524
      *out = (unsigned char *)tmp___1;
      }
    } else {
      {
#line 524
      tmp___2 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 524
      *out = (unsigned char *)tmp___2;
      }
    }
  }
#line 524
  *(*out + *outsize) = (unsigned char )((blocksize / 256UL) % 256UL);
#line 524
  (*outsize) ++;
#line 525
  if (! (*outsize & (*outsize - 1UL))) {
#line 525
    if (*outsize == 0UL) {
      {
#line 525
      tmp___3 = malloc(sizeof(*(*out)));
#line 525
      *out = (unsigned char *)tmp___3;
      }
    } else {
      {
#line 525
      tmp___4 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 525
      *out = (unsigned char *)tmp___4;
      }
    }
  }
#line 525
  *(*out + *outsize) = (unsigned char )((int )nlen % 256);
#line 525
  (*outsize) ++;
#line 526
  if (! (*outsize & (*outsize - 1UL))) {
#line 526
    if (*outsize == 0UL) {
      {
#line 526
      tmp___5 = malloc(sizeof(*(*out)));
#line 526
      *out = (unsigned char *)tmp___5;
      }
    } else {
      {
#line 526
      tmp___6 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 526
      *out = (unsigned char *)tmp___6;
      }
    }
  }
#line 526
  *(*out + *outsize) = (unsigned char )(((int )nlen / 256) % 256);
#line 526
  (*outsize) ++;
#line 528
  i = instart;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < inend)) {
#line 528
      goto while_break;
    }
#line 529
    if (! (*outsize & (*outsize - 1UL))) {
#line 529
      if (*outsize == 0UL) {
        {
#line 529
        tmp___7 = malloc(sizeof(*(*out)));
#line 529
        *out = (unsigned char *)tmp___7;
        }
      } else {
        {
#line 529
        tmp___8 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 529
        *out = (unsigned char *)tmp___8;
        }
      }
    }
#line 529
    *(*out + *outsize) = (unsigned char )*(in + i);
#line 529
    (*outsize) ++;
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  return;
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateBlock(ZopfliOptions const   *options , int btype , int final ,
                         unsigned char const   *in , size_t instart , size_t inend ,
                         unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 


  {
#line 538
  if (btype == 0) {
    {
#line 539
    DeflateNonCompressedBlock(options, final, in, instart, inend, bp, out, outsize);
    }
  } else
#line 541
  if (btype == 1) {
    {
#line 542
    DeflateFixedBlock(options, final, in, instart, inend, bp, out, outsize);
    }
  } else {
#line 544
    if (! (btype == 2)) {
      {
#line 544
      __assert_fail("btype == 2", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    544U, "DeflateBlock");
      }
    }
    {
#line 545
    DeflateDynamicBlock(options, final, in, instart, inend, bp, out, outsize);
    }
  }
#line 547
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateSplittingFirst(ZopfliOptions const   *options , int btype , int final ,
                                  unsigned char const   *in , size_t instart , size_t inend ,
                                  unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  size_t i ;
  size_t *splitpoints ;
  size_t npoints ;
  size_t start ;
  size_t tmp ;
  size_t end ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 561
  splitpoints = (size_t *)0;
#line 562
  npoints = (size_t )0;
#line 563
  if (btype == 0) {
    {
#line 564
    ZopfliBlockSplitSimple(in, instart, inend, (size_t )65535, & splitpoints, & npoints);
    }
  } else
#line 565
  if (! (btype == 1)) {
    {
#line 569
    ZopfliBlockSplit(options, in, instart, inend, (size_t )options->blocksplittingmax,
                     & splitpoints, & npoints);
    }
  }
#line 573
  i = (size_t )0;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! (i <= npoints)) {
#line 573
      goto while_break;
    }
#line 574
    if (i == 0UL) {
#line 574
      tmp = instart;
    } else {
#line 574
      tmp = *(splitpoints + (i - 1UL));
    }
#line 574
    start = tmp;
#line 575
    if (i == npoints) {
#line 575
      tmp___0 = inend;
    } else {
#line 575
      tmp___0 = *(splitpoints + i);
    }
#line 575
    end = tmp___0;
#line 576
    if (i == npoints) {
#line 576
      if (final) {
#line 576
        tmp___1 = 1;
      } else {
#line 576
        tmp___1 = 0;
      }
    } else {
#line 576
      tmp___1 = 0;
    }
    {
#line 576
    DeflateBlock(options, btype, tmp___1, in, start, end, bp, out, outsize);
#line 573
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  free((void *)splitpoints);
  }
#line 581
  return;
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
static void DeflateSplittingLast(ZopfliOptions const   *options , int btype , int final ,
                                 unsigned char const   *in , size_t instart , size_t inend ,
                                 unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  size_t i ;
  ZopfliBlockState s ;
  ZopfliLZ77Store store ;
  size_t *splitpoints ;
  size_t npoints ;
  void *tmp ;
  size_t start ;
  size_t tmp___0 ;
  size_t end ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 597
  splitpoints = (size_t *)0;
#line 598
  npoints = (size_t )0;
#line 600
  if (btype == 0) {
    {
#line 603
    DeflateSplittingFirst(options, btype, final, in, instart, inend, bp, out, outsize);
    }
  }
#line 607
  if (! (btype == 1)) {
#line 607
    if (! (btype == 2)) {
      {
#line 607
      __assert_fail("btype == 1 || btype == 2", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    607U, "DeflateSplittingLast");
      }
    }
  }
  {
#line 609
  ZopfliInitLZ77Store(& store);
#line 611
  s.options = options;
#line 612
  s.blockstart = instart;
#line 613
  s.blockend = inend;
#line 615
  tmp = malloc(sizeof(ZopfliLongestMatchCache ));
#line 615
  s.lmc = (ZopfliLongestMatchCache *)tmp;
#line 616
  ZopfliInitCache(inend - instart, s.lmc);
  }
#line 619
  if (btype == 2) {
    {
#line 620
    ZopfliLZ77Optimal(& s, in, instart, inend, & store);
    }
  } else {
#line 622
    if (! (btype == 1)) {
      {
#line 622
      __assert_fail("btype == 1", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c",
                    622U, "DeflateSplittingLast");
      }
    }
    {
#line 623
    ZopfliLZ77OptimalFixed(& s, in, instart, inend, & store);
    }
  }
#line 626
  if (! (btype == 1)) {
    {
#line 630
    ZopfliBlockSplitLZ77(options, (unsigned short const   *)store.litlens, (unsigned short const   *)store.dists,
                         store.size, (size_t )options->blocksplittingmax, & splitpoints,
                         & npoints);
    }
  }
#line 634
  i = (size_t )0;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (! (i <= npoints)) {
#line 634
      goto while_break;
    }
#line 635
    if (i == 0UL) {
#line 635
      tmp___0 = (size_t )0;
    } else {
#line 635
      tmp___0 = *(splitpoints + (i - 1UL));
    }
#line 635
    start = tmp___0;
#line 636
    if (i == npoints) {
#line 636
      tmp___1 = store.size;
    } else {
#line 636
      tmp___1 = *(splitpoints + i);
    }
#line 636
    end = tmp___1;
#line 637
    if (i == npoints) {
#line 637
      if (final) {
#line 637
        tmp___2 = 1;
      } else {
#line 637
        tmp___2 = 0;
      }
    } else {
#line 637
      tmp___2 = 0;
    }
    {
#line 637
    AddLZ77Block(options, btype, tmp___2, (unsigned short const   *)store.litlens,
                 (unsigned short const   *)store.dists, start, end, (size_t )0, bp,
                 out, outsize);
#line 634
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 643
  ZopfliCleanCache(s.lmc);
#line 644
  free((void *)s.lmc);
#line 647
  ZopfliCleanLZ77Store(& store);
  }
#line 648
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
void ZopfliDeflatePart(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in ,
                       size_t instart , size_t inend , unsigned char *bp , unsigned char **out ,
                       size_t *outsize ) 
{ 


  {
#line 663
  if (options->blocksplitting) {
#line 664
    if (options->blocksplittinglast) {
      {
#line 665
      DeflateSplittingLast(options, btype, final, in, instart, inend, bp, out, outsize);
      }
    } else {
      {
#line 668
      DeflateSplittingFirst(options, btype, final, in, instart, inend, bp, out, outsize);
      }
    }
  } else {
    {
#line 672
    DeflateBlock(options, btype, final, in, instart, inend, bp, out, outsize);
    }
  }
#line 674
  return;
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/deflate.c"
void ZopfliDeflate(ZopfliOptions const   *options , int btype , int final , unsigned char const   *in ,
                   size_t insize , unsigned char *bp , unsigned char **out , size_t *outsize ) 
{ 
  size_t i ;
  int masterfinal ;
  int final2 ;
  int tmp ;
  size_t size ;
  size_t tmp___0 ;

  {
#line 682
  i = (size_t )0;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (i < insize)) {
#line 683
      goto while_break;
    }
#line 684
    masterfinal = i + 20000000UL >= insize;
#line 685
    if (final) {
#line 685
      if (masterfinal) {
#line 685
        tmp = 1;
      } else {
#line 685
        tmp = 0;
      }
    } else {
#line 685
      tmp = 0;
    }
#line 685
    final2 = tmp;
#line 686
    if (masterfinal) {
#line 686
      tmp___0 = insize - i;
    } else {
#line 686
      tmp___0 = (size_t )20000000;
    }
    {
#line 686
    size = tmp___0;
#line 687
    ZopfliDeflatePart(options, btype, final2, in, i, i + size, bp, out, outsize);
#line 689
    i += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  if (options->verbose) {
    {
#line 693
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Original Size: %d, Deflate: %d, Compression: %f%% Removed\n",
            (int )insize, (int )*outsize, (100.0 * (double )(insize - *outsize)) / (double )insize);
    }
  }
#line 698
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c"
void ZopfliInitCache(size_t blocksize , ZopfliLongestMatchCache *lmc ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 30
  tmp = malloc(sizeof(unsigned short ) * blocksize);
#line 30
  lmc->length = (unsigned short *)tmp;
#line 31
  tmp___0 = malloc(sizeof(unsigned short ) * blocksize);
#line 31
  lmc->dist = (unsigned short *)tmp___0;
#line 33
  tmp___1 = malloc(24UL * blocksize);
#line 33
  lmc->sublen = (unsigned char *)tmp___1;
#line 37
  i = (size_t )0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < blocksize)) {
#line 37
      goto while_break;
    }
#line 37
    *(lmc->length + i) = (unsigned short)1;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  i = (size_t )0;
  {
#line 38
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 38
    if (! (i < blocksize)) {
#line 38
      goto while_break___0;
    }
#line 38
    *(lmc->dist + i) = (unsigned short)0;
#line 38
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 39
  i = (size_t )0;
  {
#line 39
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 39
    if (! (i < (8UL * blocksize) * 3UL)) {
#line 39
      goto while_break___1;
    }
#line 39
    *(lmc->sublen + i) = (unsigned char)0;
#line 39
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c"
void ZopfliCleanCache(ZopfliLongestMatchCache *lmc ) 
{ 


  {
  {
#line 43
  free((void *)lmc->length);
#line 44
  free((void *)lmc->dist);
#line 45
  free((void *)lmc->sublen);
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c"
void ZopfliSublenToCache(unsigned short const   *sublen , size_t pos , size_t length ,
                         ZopfliLongestMatchCache *lmc ) 
{ 
  size_t i ;
  size_t j ;
  unsigned int bestlength ;
  unsigned char *cache ;
  unsigned int tmp ;

  {
#line 52
  j = (size_t )0;
#line 53
  bestlength = 0U;
#line 60
  cache = lmc->sublen + (8UL * pos) * 3UL;
#line 61
  if (length < 3UL) {
#line 61
    return;
  }
#line 62
  i = (size_t )3;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i <= length)) {
#line 62
      goto while_break;
    }
#line 63
    if (i == length) {
#line 63
      goto _L;
    } else
#line 63
    if ((int const   )*(sublen + i) != (int const   )*(sublen + (i + 1UL))) {
      _L: /* CIL Label */ 
#line 64
      *(cache + j * 3UL) = (unsigned char )(i - 3UL);
#line 65
      *(cache + (j * 3UL + 1UL)) = (unsigned char )((int const   )*(sublen + i) % 256);
#line 66
      *(cache + (j * 3UL + 2UL)) = (unsigned char )(((int const   )*(sublen + i) >> 8) % 256);
#line 67
      bestlength = (unsigned int )i;
#line 68
      j ++;
#line 69
      if (j >= 8UL) {
#line 69
        goto while_break;
      }
    }
#line 62
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (j < 8UL) {
#line 73
    if (! ((size_t )bestlength == length)) {
      {
#line 73
      __assert_fail("bestlength == length", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c",
                    73U, "ZopfliSublenToCache");
      }
    }
#line 74
    *(cache + 21) = (unsigned char )(bestlength - 3U);
  } else
#line 76
  if (! ((size_t )bestlength <= length)) {
    {
#line 76
    __assert_fail("bestlength <= length", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c",
                  76U, "ZopfliSublenToCache");
    }
  }
  {
#line 78
  tmp = ZopfliMaxCachedSublen((ZopfliLongestMatchCache const   *)lmc, pos, length);
  }
#line 78
  if (! (bestlength == tmp)) {
    {
#line 78
    __assert_fail("bestlength == ZopfliMaxCachedSublen(lmc, pos, length)", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c",
                  78U, "ZopfliSublenToCache");
    }
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c"
void ZopfliCacheToSublen(ZopfliLongestMatchCache const   *lmc , size_t pos , size_t length ,
                         unsigned short *sublen ) 
{ 
  size_t i ;
  size_t j ;
  unsigned int maxlength ;
  unsigned int tmp ;
  unsigned int prevlength ;
  unsigned char *cache ;
  unsigned int length___0 ;
  unsigned int dist ;

  {
  {
#line 85
  tmp = ZopfliMaxCachedSublen(lmc, pos, length);
#line 85
  maxlength = tmp;
#line 86
  prevlength = 0U;
  }
#line 91
  if (length < 3UL) {
#line 91
    return;
  }
#line 92
  cache = lmc->sublen + (8UL * pos) * 3UL;
#line 93
  j = (size_t )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (j < 8UL)) {
#line 93
      goto while_break;
    }
#line 94
    length___0 = (unsigned int )((int )*(cache + j * 3UL) + 3);
#line 95
    dist = (unsigned int )((int )*(cache + (j * 3UL + 1UL)) + 256 * (int )*(cache + (j * 3UL + 2UL)));
#line 96
    i = (size_t )prevlength;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (i <= (size_t )length___0)) {
#line 96
        goto while_break___0;
      }
#line 97
      *(sublen + i) = (unsigned short )dist;
#line 96
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    if (length___0 == maxlength) {
#line 99
      goto while_break;
    }
#line 100
    prevlength = length___0 + 1U;
#line 93
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/cache.c"
unsigned int ZopfliMaxCachedSublen(ZopfliLongestMatchCache const   *lmc , size_t pos ,
                                   size_t length ) 
{ 
  unsigned char *cache ;

  {
#line 113
  cache = lmc->sublen + (8UL * pos) * 3UL;
#line 115
  if ((int )*(cache + 1) == 0) {
#line 115
    if ((int )*(cache + 2) == 0) {
#line 115
      return (0U);
    }
  }
#line 116
  return ((unsigned int )((int )*(cache + 21) + 3));
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.h"
int ZopfliLengthLimitedCodeLengths(size_t const   *frequencies , int n , int maxbits ,
                                   unsigned int *bitlengths ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static void InitNode(size_t weight , int count , Node *tail , Node *node ) 
{ 


  {
#line 55
  node->weight = weight;
#line 56
  node->count = count;
#line 57
  node->tail = tail;
#line 58
  node->inuse = (char)1;
#line 59
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static Node *GetFreeNode(Node *(*lists)[2] , int maxbits , NodePool *pool ) 
{ 
  int i ;
  Node *node ;
  Node *tmp ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if ((unsigned long )pool->next >= (unsigned long )(pool->nodes + pool->size)) {
#line 72
      i = 0;
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 72
        if (! (i < pool->size)) {
#line 72
          goto while_break___0;
        }
#line 73
        (pool->nodes + i)->inuse = (char)0;
#line 72
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 75
      if (lists) {
#line 76
        i = 0;
        {
#line 76
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 76
          if (! (i < maxbits * 2)) {
#line 76
            goto while_break___1;
          }
#line 78
          node = (*(lists + i / 2))[i % 2];
          {
#line 78
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 78
            if (! node) {
#line 78
              goto while_break___2;
            }
#line 79
            node->inuse = (char)1;
#line 78
            node = node->tail;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 76
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 83
      pool->next = pool->nodes + 0;
    }
#line 85
    if (! (pool->next)->inuse) {
#line 85
      goto while_break;
    }
#line 86
    (pool->next) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  tmp = pool->next;
#line 88
  (pool->next) ++;
#line 88
  return (tmp);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static void BoundaryPM(Node *(*lists)[2] , int maxbits , Node *leaves , int numsymbols ,
                       NodePool *pool , int index , char final ) 
{ 
  Node *newchain ;
  Node *oldchain ;
  int lastcount ;
  size_t sum ;

  {
#line 109
  lastcount = ((*(lists + index))[1])->count;
#line 111
  if (index == 0) {
#line 111
    if (lastcount >= numsymbols) {
#line 111
      return;
    }
  }
  {
#line 113
  newchain = GetFreeNode(lists, maxbits, pool);
#line 114
  oldchain = (*(lists + index))[1];
#line 118
  (*(lists + index))[0] = oldchain;
#line 119
  (*(lists + index))[1] = newchain;
  }
#line 121
  if (index == 0) {
    {
#line 123
    InitNode((leaves + lastcount)->weight, lastcount + 1, (Node *)0, newchain);
    }
  } else {
#line 125
    sum = ((*(lists + (index - 1)))[0])->weight + ((*(lists + (index - 1)))[1])->weight;
#line 126
    if (lastcount < numsymbols) {
#line 126
      if (sum > (leaves + lastcount)->weight) {
        {
#line 128
        InitNode((leaves + lastcount)->weight, lastcount + 1, oldchain->tail, newchain);
        }
      } else {
#line 126
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 131
      InitNode(sum, lastcount, (*(lists + (index - 1)))[1], newchain);
      }
#line 132
      if (! final) {
        {
#line 134
        BoundaryPM(lists, maxbits, leaves, numsymbols, pool, index - 1, (char)0);
#line 135
        BoundaryPM(lists, maxbits, leaves, numsymbols, pool, index - 1, (char)0);
        }
      }
    }
  }
#line 139
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static void InitLists(NodePool *pool , Node const   *leaves , int maxbits , Node *(*lists)[2] ) 
{ 
  int i ;
  Node *node0 ;
  Node *tmp ;
  Node *node1 ;
  Node *tmp___0 ;

  {
  {
#line 148
  tmp = GetFreeNode((Node *(*)[2])0, maxbits, pool);
#line 148
  node0 = tmp;
#line 149
  tmp___0 = GetFreeNode((Node *(*)[2])0, maxbits, pool);
#line 149
  node1 = tmp___0;
#line 150
  InitNode((size_t )(leaves + 0)->weight, 1, (Node *)0, node0);
#line 151
  InitNode((size_t )(leaves + 1)->weight, 2, (Node *)0, node1);
#line 152
  i = 0;
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < maxbits)) {
#line 152
      goto while_break;
    }
#line 153
    (*(lists + i))[0] = node0;
#line 154
    (*(lists + i))[1] = node1;
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static void ExtractBitLengths(Node *chain , Node *leaves , unsigned int *bitlengths ) 
{ 
  Node *node ;
  int i ;

  {
#line 165
  node = chain;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! node) {
#line 165
      goto while_break;
    }
#line 167
    i = 0;
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (i < node->count)) {
#line 167
        goto while_break___0;
      }
#line 168
      (*(bitlengths + (leaves + i)->count)) ++;
#line 167
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 165
    node = node->tail;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
static int LeafComparator(void const   *a , void const   *b ) 
{ 


  {
#line 177
  return ((int )(((Node const   *)a)->weight - ((Node const   *)b)->weight));
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/katajainen.c"
int ZopfliLengthLimitedCodeLengths(size_t const   *frequencies , int n , int maxbits ,
                                   unsigned int *bitlengths ) 
{ 
  NodePool pool ;
  int i ;
  int numsymbols ;
  int numBoundaryPMRuns ;
  Node *(*lists)[2] ;
  Node *leaves ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char final ;

  {
  {
#line 184
  numsymbols = 0;
#line 192
  tmp = malloc((unsigned long )n * sizeof(*leaves));
#line 192
  leaves = (Node *)tmp;
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < n)) {
#line 195
      goto while_break;
    }
#line 196
    *(bitlengths + i) = 0U;
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (i < n)) {
#line 200
      goto while_break___0;
    }
#line 201
    if (*(frequencies + i)) {
#line 202
      (leaves + numsymbols)->weight = (size_t )*(frequencies + i);
#line 203
      (leaves + numsymbols)->count = i;
#line 204
      numsymbols ++;
    }
#line 200
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  if (1 << maxbits < numsymbols) {
    {
#line 210
    free((void *)leaves);
    }
#line 211
    return (1);
  }
#line 213
  if (numsymbols == 0) {
    {
#line 214
    free((void *)leaves);
    }
#line 215
    return (0);
  }
#line 217
  if (numsymbols == 1) {
    {
#line 218
    *(bitlengths + (leaves + 0)->count) = 1U;
#line 219
    free((void *)leaves);
    }
#line 220
    return (0);
  }
  {
#line 224
  qsort((void *)leaves, (size_t )numsymbols, sizeof(Node ), & LeafComparator);
#line 227
  pool.size = (2 * maxbits) * (maxbits + 1);
#line 228
  tmp___0 = malloc((unsigned long )pool.size * sizeof(*(pool.nodes)));
#line 228
  pool.nodes = (Node *)tmp___0;
#line 229
  pool.next = pool.nodes;
#line 230
  i = 0;
  }
  {
#line 230
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 230
    if (! (i < pool.size)) {
#line 230
      goto while_break___1;
    }
#line 231
    (pool.nodes + i)->inuse = (char)0;
#line 230
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 234
  tmp___1 = malloc((unsigned long )maxbits * sizeof(*lists));
#line 234
  lists = (Node *(*)[2])tmp___1;
#line 235
  InitLists(& pool, (Node const   *)leaves, maxbits, lists);
#line 239
  numBoundaryPMRuns = 2 * numsymbols - 4;
#line 240
  i = 0;
  }
  {
#line 240
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 240
    if (! (i < numBoundaryPMRuns)) {
#line 240
      goto while_break___2;
    }
    {
#line 241
    final = (char )(i == numBoundaryPMRuns - 1);
#line 242
    BoundaryPM(lists, maxbits, leaves, numsymbols, & pool, maxbits - 1, final);
#line 240
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 245
  ExtractBitLengths((*(lists + (maxbits - 1)))[1], leaves, bitlengths);
#line 247
  free((void *)lists);
#line 248
  free((void *)leaves);
#line 249
  free((void *)pool.nodes);
  }
#line 250
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.h"
void ZopfliCalculateEntropy(size_t const   *count , size_t n , double *bitlengths ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void InitStats(SymbolStats *stats ) 
{ 


  {
  {
#line 43
  memset((void *)(stats->litlens), 0, 288UL * sizeof(stats->litlens[0]));
#line 44
  memset((void *)(stats->dists), 0, 32UL * sizeof(stats->dists[0]));
#line 46
  memset((void *)(stats->ll_symbols), 0, 288UL * sizeof(stats->ll_symbols[0]));
#line 47
  memset((void *)(stats->d_symbols), 0, 32UL * sizeof(stats->d_symbols[0]));
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void CopyStats(SymbolStats *source , SymbolStats *dest ) 
{ 


  {
  {
#line 51
  memcpy((void */* __restrict  */)(dest->litlens), (void const   */* __restrict  */)(source->litlens),
         288UL * sizeof(dest->litlens[0]));
#line 52
  memcpy((void */* __restrict  */)(dest->dists), (void const   */* __restrict  */)(source->dists),
         32UL * sizeof(dest->dists[0]));
#line 54
  memcpy((void */* __restrict  */)(dest->ll_symbols), (void const   */* __restrict  */)(source->ll_symbols),
         288UL * sizeof(dest->ll_symbols[0]));
#line 56
  memcpy((void */* __restrict  */)(dest->d_symbols), (void const   */* __restrict  */)(source->d_symbols),
         32UL * sizeof(dest->d_symbols[0]));
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void AddWeighedStatFreqs(SymbolStats const   *stats1 , double w1 , SymbolStats const   *stats2 ,
                                double w2 , SymbolStats *result ) 
{ 
  size_t i ;

  {
#line 64
  i = (size_t )0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 288UL)) {
#line 64
      goto while_break;
    }
#line 65
    result->litlens[i] = (size_t )((double )stats1->litlens[i] * w1 + (double )stats2->litlens[i] * w2);
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  i = (size_t )0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i < 32UL)) {
#line 68
      goto while_break___0;
    }
#line 69
    result->dists[i] = (size_t )((double )stats1->dists[i] * w1 + (double )stats2->dists[i] * w2);
#line 68
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  result->litlens[256] = (size_t )1;
#line 73
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void InitRanState(RanState *state ) 
{ 


  {
#line 80
  state->m_w = 1U;
#line 81
  state->m_z = 2U;
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static unsigned int Ran(RanState *state ) 
{ 


  {
#line 86
  state->m_z = 36969U * (state->m_z & 65535U) + (state->m_z >> 16);
#line 87
  state->m_w = 18000U * (state->m_w & 65535U) + (state->m_w >> 16);
#line 88
  return ((state->m_z << 16) + state->m_w);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void RandomizeFreqs(RanState *state , size_t *freqs , int n ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < n)) {
#line 93
      goto while_break;
    }
    {
#line 94
    tmp___0 = Ran(state);
    }
#line 94
    if ((tmp___0 >> 4) % 3U == 0U) {
      {
#line 94
      tmp = Ran(state);
#line 94
      *(freqs + i) = *(freqs + tmp % (unsigned int )n);
      }
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void RandomizeStatFreqs(RanState *state , SymbolStats *stats ) 
{ 


  {
  {
#line 99
  RandomizeFreqs(state, stats->litlens, 288);
#line 100
  RandomizeFreqs(state, stats->dists, 32);
#line 101
  stats->litlens[256] = (size_t )1;
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void ClearStatFreqs(SymbolStats *stats ) 
{ 
  size_t i ;

  {
#line 106
  i = (size_t )0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < 288UL)) {
#line 106
      goto while_break;
    }
#line 106
    stats->litlens[i] = (size_t )0;
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = (size_t )0;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < 32UL)) {
#line 107
      goto while_break___0;
    }
#line 107
    stats->dists[i] = (size_t )0;
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static double GetCostFixed(unsigned int litlen , unsigned int dist , void *unused ) 
{ 
  int dbits ;
  int tmp ;
  int lbits ;
  int tmp___0 ;
  int lsym ;
  int tmp___1 ;
  double cost ;

  {
#line 122
  if (dist == 0U) {
#line 123
    if (litlen <= 143U) {
#line 123
      return ((double )8);
    } else {
#line 124
      return ((double )9);
    }
  } else {
    {
#line 126
    tmp = ZopfliGetDistExtraBits((int )dist);
#line 126
    dbits = tmp;
#line 127
    tmp___0 = ZopfliGetLengthExtraBits((int )litlen);
#line 127
    lbits = tmp___0;
#line 128
    tmp___1 = ZopfliGetLengthSymbol((int )litlen);
#line 128
    lsym = tmp___1;
#line 129
    cost = (double )0;
    }
#line 130
    if (lsym <= 279) {
#line 130
      cost += (double )7;
    } else {
#line 131
      cost += (double )8;
    }
#line 132
    cost += (double )5;
#line 133
    return ((cost + (double )dbits) + (double )lbits);
  }
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static double GetCostStat(unsigned int litlen , unsigned int dist , void *context ) 
{ 
  SymbolStats *stats ;
  int lsym ;
  int tmp ;
  int lbits ;
  int tmp___0 ;
  int dsym ;
  int tmp___1 ;
  int dbits ;
  int tmp___2 ;

  {
#line 142
  stats = (SymbolStats *)context;
#line 143
  if (dist == 0U) {
#line 144
    return (stats->ll_symbols[litlen]);
  } else {
    {
#line 146
    tmp = ZopfliGetLengthSymbol((int )litlen);
#line 146
    lsym = tmp;
#line 147
    tmp___0 = ZopfliGetLengthExtraBits((int )litlen);
#line 147
    lbits = tmp___0;
#line 148
    tmp___1 = ZopfliGetDistSymbol((int )dist);
#line 148
    dsym = tmp___1;
#line 149
    tmp___2 = ZopfliGetDistExtraBits((int )dist);
#line 149
    dbits = tmp___2;
    }
#line 150
    return (((stats->ll_symbols[lsym] + (double )lbits) + stats->d_symbols[dsym]) + (double )dbits);
  }
}
}
#line 169
static double GetCostModelMinCost(CostModelFun *costmodel , void *costcontext ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static int const   dsymbols[30]  = 
#line 169
  {      (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )7,      (int const   )9,      (int const   )13, 
        (int const   )17,      (int const   )25,      (int const   )33,      (int const   )49, 
        (int const   )65,      (int const   )97,      (int const   )129,      (int const   )193, 
        (int const   )257,      (int const   )385,      (int const   )513,      (int const   )769, 
        (int const   )1025,      (int const   )1537,      (int const   )2049,      (int const   )3073, 
        (int const   )4097,      (int const   )6145,      (int const   )8193,      (int const   )12289, 
        (int const   )16385,      (int const   )24577};
#line 158 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static double GetCostModelMinCost(CostModelFun *costmodel , void *costcontext ) 
{ 
  double mincost ;
  int bestlength ;
  int bestdist ;
  int i ;
  double c ;
  double tmp ;
  double c___0 ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 160
  bestlength = 0;
#line 161
  bestdist = 0;
#line 174
  mincost = 1e30;
#line 175
  i = 3;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < 259)) {
#line 175
      goto while_break;
    }
    {
#line 176
    tmp = (*costmodel)((unsigned int )i, 1U, costcontext);
#line 176
    c = tmp;
    }
#line 177
    if (c < mincost) {
#line 178
      bestlength = i;
#line 179
      mincost = c;
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  mincost = 1e30;
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! (i < 30)) {
#line 184
      goto while_break___0;
    }
    {
#line 185
    tmp___0 = (*costmodel)(3U, (unsigned int )dsymbols[i], costcontext);
#line 185
    c___0 = tmp___0;
    }
#line 186
    if (c___0 < mincost) {
#line 187
      bestdist = (int )dsymbols[i];
#line 188
      mincost = c___0;
    }
#line 184
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 192
  tmp___1 = (*costmodel)((unsigned int )bestlength, (unsigned int )bestdist, costcontext);
  }
#line 192
  return (tmp___1);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static double GetBestLengths(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                             size_t inend , CostModelFun *costmodel , void *costcontext ,
                             unsigned short *length_array ) 
{ 
  size_t blocksize ;
  float *costs ;
  size_t i ;
  size_t k ;
  unsigned short leng ;
  unsigned short dist ;
  unsigned short sublen[259] ;
  size_t windowstart ;
  size_t tmp ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  double result ;
  double mincost ;
  double tmp___0 ;
  void *tmp___1 ;
  size_t j ;
  double symbolcost ;
  double tmp___2 ;
  double newCost ;
  double tmp___3 ;
  double newCost___0 ;
  double tmp___4 ;

  {
#line 214
  blocksize = inend - instart;
#line 216
  i = (size_t )0;
#line 220
  if (instart > 32768UL) {
#line 220
    tmp = instart - 32768UL;
  } else {
#line 220
    tmp = (size_t )0;
  }
  {
#line 220
  windowstart = tmp;
#line 223
  h = & hash;
#line 225
  tmp___0 = GetCostModelMinCost(costmodel, costcontext);
#line 225
  mincost = tmp___0;
  }
#line 227
  if (instart == inend) {
#line 227
    return ((double )0);
  }
  {
#line 229
  tmp___1 = malloc(sizeof(float ) * (blocksize + 1UL));
#line 229
  costs = (float *)tmp___1;
  }
#line 230
  if (! costs) {
    {
#line 230
    exit(-1);
    }
  }
  {
#line 232
  ZopfliInitHash((size_t )32768, h);
#line 233
  ZopfliWarmupHash(in, windowstart, inend, h);
#line 234
  i = windowstart;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < instart)) {
#line 234
      goto while_break;
    }
    {
#line 235
    ZopfliUpdateHash(in, i, inend, h);
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  i = (size_t )1;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! (i < blocksize + 1UL)) {
#line 238
      goto while_break___0;
    }
#line 238
    *(costs + i) = (float )1e30;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 239
  *(costs + 0) = (float )0;
#line 240
  *(length_array + 0) = (unsigned short)0;
#line 242
  i = instart;
  {
#line 242
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 242
    if (! (i < inend)) {
#line 242
      goto while_break___1;
    }
    {
#line 243
    j = i - instart;
#line 244
    ZopfliUpdateHash(in, i, inend, h);
    }
#line 249
    if ((int )*(h->same + (i & 32767UL)) > 516) {
#line 249
      if (i > (instart + 258UL) + 1UL) {
#line 249
        if ((i + 516UL) + 1UL < inend) {
#line 249
          if ((int )*(h->same + ((i - 258UL) & 32767UL)) > 258) {
            {
#line 254
            tmp___2 = (*costmodel)(258U, 1U, costcontext);
#line 254
            symbolcost = tmp___2;
#line 258
            k = (size_t )0;
            }
            {
#line 258
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 258
              if (! (k < 258UL)) {
#line 258
                goto while_break___2;
              }
              {
#line 259
              *(costs + (j + 258UL)) = (float )((double )*(costs + j) + symbolcost);
#line 260
              *(length_array + (j + 258UL)) = (unsigned short)258;
#line 261
              i ++;
#line 262
              j ++;
#line 263
              ZopfliUpdateHash(in, i, inend, h);
#line 258
              k ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
      }
    }
    {
#line 268
    ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in, i, inend, (size_t )258,
                           sublen, & dist, & leng);
    }
#line 272
    if (i + 1UL <= inend) {
      {
#line 273
      tmp___3 = (*costmodel)((unsigned int )*(in + i), 0U, costcontext);
#line 273
      newCost = (double )*(costs + j) + tmp___3;
      }
#line 274
      if (! (newCost >= (double )0)) {
        {
#line 274
        __assert_fail("newCost >= 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                      274U, "GetBestLengths");
        }
      }
#line 275
      if (newCost < (double )*(costs + (j + 1UL))) {
#line 276
        *(costs + (j + 1UL)) = (float )newCost;
#line 277
        *(length_array + (j + 1UL)) = (unsigned short)1;
      }
    }
#line 281
    k = (size_t )3;
    {
#line 281
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 281
      if (k <= (size_t )leng) {
#line 281
        if (! (i + k <= inend)) {
#line 281
          goto while_break___3;
        }
      } else {
#line 281
        goto while_break___3;
      }
#line 286
      if ((double )(*(costs + (j + k)) - *(costs + j)) <= mincost) {
#line 286
        goto __Cont;
      }
      {
#line 288
      tmp___4 = (*costmodel)((unsigned int )k, (unsigned int )sublen[k], costcontext);
#line 288
      newCost___0 = (double )*(costs + j) + tmp___4;
      }
#line 289
      if (! (newCost___0 >= (double )0)) {
        {
#line 289
        __assert_fail("newCost >= 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                      289U, "GetBestLengths");
        }
      }
#line 290
      if (newCost___0 < (double )*(costs + (j + k))) {
#line 291
        if (! (k <= 258UL)) {
          {
#line 291
          __assert_fail("k <= 258", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                        291U, "GetBestLengths");
          }
        }
#line 292
        *(costs + (j + k)) = (float )newCost___0;
#line 293
        *(length_array + (j + k)) = (unsigned short )k;
      }
      __Cont: /* CIL Label */ 
#line 281
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 242
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 298
  if (! (*(costs + blocksize) >= (float )0)) {
    {
#line 298
    __assert_fail("costs[blocksize] >= 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                  298U, "GetBestLengths");
    }
  }
  {
#line 299
  result = (double )*(costs + blocksize);
#line 301
  ZopfliCleanHash(h);
#line 302
  free((void *)costs);
  }
#line 304
  return (result);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void TraceBackwards(size_t size , unsigned short const   *length_array , unsigned short **path ,
                           size_t *pathsize ) 
{ 
  size_t index ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short temp ;

  {
#line 315
  index = size;
#line 316
  if (size == 0UL) {
#line 316
    return;
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (*pathsize & (*pathsize - 1UL))) {
#line 318
      if (*pathsize == 0UL) {
        {
#line 318
        tmp = malloc(sizeof(*(*path)));
#line 318
        *path = (unsigned short *)tmp;
        }
      } else {
        {
#line 318
        tmp___0 = realloc((void *)*path, (*pathsize * 2UL) * sizeof(*(*path)));
#line 318
        *path = (unsigned short *)tmp___0;
        }
      }
    }
#line 318
    *(*path + *pathsize) = (unsigned short )*(length_array + index);
#line 318
    (*pathsize) ++;
#line 319
    if (! ((size_t )*(length_array + index) <= index)) {
      {
#line 319
      __assert_fail("length_array[index] <= index", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                    319U, "TraceBackwards");
      }
    }
#line 320
    if (! ((int const   )*(length_array + index) <= 258)) {
      {
#line 320
      __assert_fail("length_array[index] <= 258", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                    320U, "TraceBackwards");
      }
    }
#line 321
    if (! ((int const   )*(length_array + index) != 0)) {
      {
#line 321
      __assert_fail("length_array[index] != 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                    321U, "TraceBackwards");
      }
    }
#line 322
    index -= (size_t )*(length_array + index);
#line 323
    if (index == 0UL) {
#line 323
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  index = (size_t )0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (index < *pathsize / 2UL)) {
#line 327
      goto while_break___0;
    }
#line 328
    temp = *(*path + index);
#line 329
    *(*path + index) = *(*path + ((*pathsize - index) - 1UL));
#line 330
    *(*path + ((*pathsize - index) - 1UL)) = temp;
#line 327
    index ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 332
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void FollowPath(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                       size_t inend , unsigned short *path , size_t pathsize , ZopfliLZ77Store *store ) 
{ 
  size_t i ;
  size_t j ;
  size_t pos ;
  size_t windowstart ;
  size_t tmp ;
  size_t total_length_test ;
  ZopfliHash hash ;
  ZopfliHash *h ;
  unsigned short length ;
  unsigned short dummy_length ;
  unsigned short dist ;

  {
#line 338
  pos = (size_t )0;
#line 339
  if (instart > 32768UL) {
#line 339
    tmp = instart - 32768UL;
  } else {
#line 339
    tmp = (size_t )0;
  }
#line 339
  windowstart = tmp;
#line 342
  total_length_test = (size_t )0;
#line 345
  h = & hash;
#line 347
  if (instart == inend) {
#line 347
    return;
  }
  {
#line 349
  ZopfliInitHash((size_t )32768, h);
#line 350
  ZopfliWarmupHash(in, windowstart, inend, h);
#line 351
  i = windowstart;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < instart)) {
#line 351
      goto while_break;
    }
    {
#line 352
    ZopfliUpdateHash(in, i, inend, h);
#line 351
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  pos = instart;
#line 356
  i = (size_t )0;
  {
#line 356
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 356
    if (! (i < pathsize)) {
#line 356
      goto while_break___0;
    }
#line 357
    length = *(path + i);
#line 360
    if (! (pos < inend)) {
      {
#line 360
      __assert_fail("pos < inend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                    360U, "FollowPath");
      }
    }
    {
#line 362
    ZopfliUpdateHash(in, pos, inend, h);
    }
#line 365
    if ((int )length >= 3) {
      {
#line 368
      ZopfliFindLongestMatch(s, (ZopfliHash const   *)h, in, pos, inend, (size_t )length,
                             (unsigned short *)0, & dist, & dummy_length);
      }
#line 370
      if ((int )dummy_length != (int )length) {
#line 370
        if ((int )length > 2) {
#line 370
          if ((int )dummy_length > 2) {
            {
#line 370
            __assert_fail("!(dummy_length != length && length > 2 && dummy_length > 2)",
                          "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                          370U, "FollowPath");
            }
          }
        }
      }
      {
#line 371
      ZopfliVerifyLenDist(in, inend, pos, dist, length);
#line 372
      ZopfliStoreLitLenDist(length, dist, store);
#line 373
      total_length_test += (size_t )length;
      }
    } else {
      {
#line 375
      length = (unsigned short)1;
#line 376
      ZopfliStoreLitLenDist((unsigned short )*(in + pos), (unsigned short)0, store);
#line 377
      total_length_test ++;
      }
    }
#line 381
    if (! (pos + (size_t )length <= inend)) {
      {
#line 381
      __assert_fail("pos + length <= inend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                    381U, "FollowPath");
      }
    }
#line 382
    j = (size_t )1;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      if (! (j < (size_t )length)) {
#line 382
        goto while_break___1;
      }
      {
#line 383
      ZopfliUpdateHash(in, pos + j, inend, h);
#line 382
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 386
    pos += (size_t )length;
#line 356
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 389
  ZopfliCleanHash(h);
  }
#line 390
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void CalculateStatistics(SymbolStats *stats ) 
{ 


  {
  {
#line 394
  ZopfliCalculateEntropy((size_t const   *)(stats->litlens), (size_t )288, stats->ll_symbols);
#line 395
  ZopfliCalculateEntropy((size_t const   *)(stats->dists), (size_t )32, stats->d_symbols);
  }
#line 396
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static void GetStatistics(ZopfliLZ77Store const   *store , SymbolStats *stats ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 401
  i = (size_t )0;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (i < (size_t )store->size)) {
#line 401
      goto while_break;
    }
#line 402
    if ((int )*(store->dists + i) == 0) {
#line 403
      (stats->litlens[*(store->litlens + i)]) ++;
    } else {
      {
#line 405
      tmp = ZopfliGetLengthSymbol((int )*(store->litlens + i));
#line 405
      (stats->litlens[tmp]) ++;
#line 406
      tmp___0 = ZopfliGetDistSymbol((int )*(store->dists + i));
#line 406
      (stats->dists[tmp___0]) ++;
      }
    }
#line 401
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  stats->litlens[256] = (size_t )1;
#line 411
  CalculateStatistics(stats);
  }
#line 412
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
static double LZ77OptimalRun(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                             size_t inend , unsigned short **path , size_t *pathsize ,
                             unsigned short *length_array , CostModelFun *costmodel ,
                             void *costcontext , ZopfliLZ77Store *store ) 
{ 
  double cost ;
  double tmp ;

  {
  {
#line 436
  tmp = GetBestLengths(s, in, instart, inend, costmodel, costcontext, length_array);
#line 436
  cost = tmp;
#line 438
  free((void *)*path);
#line 439
  *path = (unsigned short *)0;
#line 440
  *pathsize = (size_t )0;
#line 441
  TraceBackwards(inend - instart, (unsigned short const   *)length_array, path, pathsize);
#line 442
  FollowPath(s, in, instart, inend, *path, *pathsize, store);
  }
#line 443
  if (! (cost < 1e30)) {
    {
#line 443
    __assert_fail("cost < 1e30", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c",
                  443U, "LZ77OptimalRun");
    }
  }
#line 444
  return (cost);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
void ZopfliLZ77Optimal(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                       size_t inend , ZopfliLZ77Store *store ) 
{ 
  size_t blocksize ;
  unsigned short *length_array ;
  void *tmp ;
  unsigned short *path ;
  size_t pathsize ;
  ZopfliLZ77Store currentstore ;
  SymbolStats stats ;
  SymbolStats beststats ;
  SymbolStats laststats ;
  int i ;
  double cost ;
  double bestcost ;
  double lastcost ;
  RanState ran_state ;
  int lastrandomstep ;

  {
  {
#line 451
  blocksize = inend - instart;
#line 452
  tmp = malloc(sizeof(unsigned short ) * (blocksize + 1UL));
#line 452
  length_array = (unsigned short *)tmp;
#line 454
  path = (unsigned short *)0;
#line 455
  pathsize = (size_t )0;
#line 460
  bestcost = 1e30;
#line 461
  lastcost = (double )0;
#line 464
  lastrandomstep = -1;
  }
#line 466
  if (! length_array) {
    {
#line 466
    exit(-1);
    }
  }
  {
#line 468
  InitRanState(& ran_state);
#line 469
  InitStats(& stats);
#line 470
  ZopfliInitLZ77Store(& currentstore);
#line 476
  ZopfliLZ77Greedy(s, in, instart, inend, & currentstore);
#line 477
  GetStatistics((ZopfliLZ77Store const   *)(& currentstore), & stats);
#line 481
  i = 0;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < (int )(s->options)->numiterations)) {
#line 481
      goto while_break;
    }
    {
#line 482
    ZopfliCleanLZ77Store(& currentstore);
#line 483
    ZopfliInitLZ77Store(& currentstore);
#line 484
    LZ77OptimalRun(s, in, instart, inend, & path, & pathsize, length_array, & GetCostStat,
                   (void *)(& stats), & currentstore);
#line 487
    cost = ZopfliCalculateBlockSize((unsigned short const   *)currentstore.litlens,
                                    (unsigned short const   *)currentstore.dists,
                                    (size_t )0, currentstore.size, 2);
    }
#line 489
    if ((s->options)->verbose_more) {
      {
#line 490
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Iteration %d: %d bit\n",
              i, (int )cost);
      }
    } else
#line 489
    if ((s->options)->verbose) {
#line 489
      if (cost < bestcost) {
        {
#line 490
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Iteration %d: %d bit\n",
                i, (int )cost);
        }
      }
    }
#line 492
    if (cost < bestcost) {
      {
#line 494
      ZopfliCopyLZ77Store((ZopfliLZ77Store const   *)(& currentstore), store);
#line 495
      CopyStats(& stats, & beststats);
#line 496
      bestcost = cost;
      }
    }
    {
#line 498
    CopyStats(& stats, & laststats);
#line 499
    ClearStatFreqs(& stats);
#line 500
    GetStatistics((ZopfliLZ77Store const   *)(& currentstore), & stats);
    }
#line 501
    if (lastrandomstep != -1) {
      {
#line 505
      AddWeighedStatFreqs((SymbolStats const   *)(& stats), 1.0, (SymbolStats const   *)(& laststats),
                          0.5, & stats);
#line 506
      CalculateStatistics(& stats);
      }
    }
#line 508
    if (i > 5) {
#line 508
      if (cost == lastcost) {
        {
#line 509
        CopyStats(& beststats, & stats);
#line 510
        RandomizeStatFreqs(& ran_state, & stats);
#line 511
        CalculateStatistics(& stats);
#line 512
        lastrandomstep = i;
        }
      }
    }
#line 514
    lastcost = cost;
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  free((void *)length_array);
#line 518
  free((void *)path);
#line 519
  ZopfliCleanLZ77Store(& currentstore);
  }
#line 520
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/squeeze.c"
void ZopfliLZ77OptimalFixed(ZopfliBlockState *s , unsigned char const   *in , size_t instart ,
                            size_t inend , ZopfliLZ77Store *store ) 
{ 
  size_t blocksize ;
  unsigned short *length_array ;
  void *tmp ;
  unsigned short *path ;
  size_t pathsize ;

  {
  {
#line 528
  blocksize = inend - instart;
#line 529
  tmp = malloc(sizeof(unsigned short ) * (blocksize + 1UL));
#line 529
  length_array = (unsigned short *)tmp;
#line 531
  path = (unsigned short *)0;
#line 532
  pathsize = (size_t )0;
  }
#line 534
  if (! length_array) {
    {
#line 534
    exit(-1);
    }
  }
  {
#line 536
  s->blockstart = instart;
#line 537
  s->blockend = inend;
#line 541
  LZ77OptimalRun(s, in, instart, inend, & path, & pathsize, length_array, & GetCostFixed,
                 (void *)0, store);
#line 544
  free((void *)length_array);
#line 545
  free((void *)path);
  }
#line 546
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static size_t FindMinimum(FindMinimumFun *f , void *context , size_t start , size_t end ) 
{ 
  double best ;
  size_t result ;
  size_t i ;
  double v ;
  double tmp ;
  size_t i___0 ;
  size_t p[9] ;
  double vp[9] ;
  size_t besti ;
  double best___0 ;
  double lastbest ;
  size_t pos ;

  {
#line 45
  if (end - start < 1024UL) {
#line 46
    best = 1e30;
#line 47
    result = start;
#line 49
    i = start;
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      if (! (i < end)) {
#line 49
        goto while_break;
      }
      {
#line 50
      tmp = (*f)(i, context);
#line 50
      v = tmp;
      }
#line 51
      if (v < best) {
#line 52
        best = v;
#line 53
        result = i;
      }
#line 49
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 56
    return (result);
  } else {
#line 65
    lastbest = 1e30;
#line 66
    pos = start;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (end - start <= 9UL) {
#line 69
        goto while_break___0;
      }
#line 71
      i___0 = (size_t )0;
      {
#line 71
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 71
        if (! (i___0 < 9UL)) {
#line 71
          goto while_break___1;
        }
        {
#line 72
        p[i___0] = start + (i___0 + 1UL) * ((end - start) / 10UL);
#line 73
        vp[i___0] = (*f)(p[i___0], context);
#line 71
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 75
      besti = (size_t )0;
#line 76
      best___0 = vp[0];
#line 77
      i___0 = (size_t )1;
      {
#line 77
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 77
        if (! (i___0 < 9UL)) {
#line 77
          goto while_break___2;
        }
#line 78
        if (vp[i___0] < best___0) {
#line 79
          best___0 = vp[i___0];
#line 80
          besti = i___0;
        }
#line 77
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 83
      if (best___0 > lastbest) {
#line 83
        goto while_break___0;
      }
#line 85
      if (besti == 0UL) {
#line 85
        start = start;
      } else {
#line 85
        start = p[besti - 1UL];
      }
#line 86
      if (besti == 8UL) {
#line 86
        end = end;
      } else {
#line 86
        end = p[besti + 1UL];
      }
#line 88
      pos = p[besti];
#line 89
      lastbest = best___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return (pos);
  }
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static double EstimateCost(unsigned short const   *litlens , unsigned short const   *dists ,
                           size_t lstart , size_t lend ) 
{ 
  double tmp ;

  {
  {
#line 109
  tmp = ZopfliCalculateBlockSize(litlens, dists, lstart, lend, 2);
  }
#line 109
  return (tmp);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static double SplitCost(size_t i , void *context ) 
{ 
  SplitCostContext *c ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 127
  c = (SplitCostContext *)context;
#line 128
  tmp = EstimateCost(c->litlens, c->dists, c->start, i);
#line 128
  tmp___0 = EstimateCost(c->litlens, c->dists, i, c->end);
  }
#line 128
  return (tmp + tmp___0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static void AddSorted(size_t value , size_t **out , size_t *outsize ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  size_t j ;

  {
#line 134
  if (! (*outsize & (*outsize - 1UL))) {
#line 134
    if (*outsize == 0UL) {
      {
#line 134
      tmp = malloc(sizeof(*(*out)));
#line 134
      *out = (size_t *)tmp;
      }
    } else {
      {
#line 134
      tmp___0 = realloc((void *)*out, (*outsize * 2UL) * sizeof(*(*out)));
#line 134
      *out = (size_t *)tmp___0;
      }
    }
  }
#line 134
  *(*out + *outsize) = value;
#line 134
  (*outsize) ++;
#line 135
  if (*outsize > 0UL) {
#line 136
    i = (size_t )0;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! (i < *outsize - 1UL)) {
#line 136
        goto while_break;
      }
#line 137
      if (*(*out + i) > value) {
#line 139
        j = *outsize - 1UL;
        {
#line 139
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 139
          if (! (j > i)) {
#line 139
            goto while_break___0;
          }
#line 140
          *(*out + j) = *(*out + (j - 1UL));
#line 139
          j --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 142
        *(*out + i) = value;
#line 143
        goto while_break;
      }
#line 136
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 147
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static void PrintBlockSplitPoints(unsigned short const   *litlens , unsigned short const   *dists ,
                                  size_t llsize , size_t const   *lz77splitpoints ,
                                  size_t nlz77points ) 
{ 
  size_t *splitpoints ;
  size_t npoints ;
  size_t i ;
  size_t pos ;
  size_t length ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 156
  splitpoints = (size_t *)0;
#line 157
  npoints = (size_t )0;
#line 161
  pos = (size_t )0;
#line 162
  if (nlz77points > 0UL) {
#line 163
    i = (size_t )0;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 163
      if (! (i < llsize)) {
#line 163
        goto while_break;
      }
#line 164
      if ((int const   )*(dists + i) == 0) {
#line 164
        tmp = 1;
      } else {
#line 164
        tmp = (int )*(litlens + i);
      }
#line 164
      length = (size_t )tmp;
#line 165
      if (*(lz77splitpoints + npoints) == (size_t const   )i) {
#line 166
        if (! (npoints & (npoints - 1UL))) {
#line 166
          if (npoints == 0UL) {
            {
#line 166
            tmp___0 = malloc(sizeof(*splitpoints));
#line 166
            splitpoints = (size_t *)tmp___0;
            }
          } else {
            {
#line 166
            tmp___1 = realloc((void *)splitpoints, (npoints * 2UL) * sizeof(*splitpoints));
#line 166
            splitpoints = (size_t *)tmp___1;
            }
          }
        }
#line 166
        *(splitpoints + npoints) = pos;
#line 166
        npoints ++;
#line 167
        if (npoints == nlz77points) {
#line 167
          goto while_break;
        }
      }
#line 169
      pos += length;
#line 163
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 172
  if (! (npoints == nlz77points)) {
    {
#line 172
    __assert_fail("npoints == nlz77points", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c",
                  172U, "PrintBlockSplitPoints");
    }
  }
  {
#line 174
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block split points: ");
#line 175
  i = (size_t )0;
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (i < npoints)) {
#line 175
      goto while_break___0;
    }
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ",
            (int )*(splitpoints + i));
#line 175
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(hex:");
#line 179
  i = (size_t )0;
  }
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (! (i < npoints)) {
#line 179
      goto while_break___1;
    }
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %x",
            (int )*(splitpoints + i));
#line 179
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 182
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 184
  free((void *)splitpoints);
  }
#line 185
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
static int FindLargestSplittableBlock(size_t llsize , unsigned char const   *done ,
                                      size_t const   *splitpoints , size_t npoints ,
                                      size_t *lstart , size_t *lend ) 
{ 
  size_t longest ;
  int found ;
  size_t i ;
  size_t start ;
  size_t tmp ;
  size_t end ;
  size_t tmp___0 ;

  {
#line 204
  longest = (size_t )0;
#line 205
  found = 0;
#line 207
  i = (size_t )0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i <= npoints)) {
#line 207
      goto while_break;
    }
#line 208
    if (i == 0UL) {
#line 208
      tmp = (size_t const   )0;
    } else {
#line 208
      tmp = *(splitpoints + (i - 1UL));
    }
#line 208
    start = (size_t )tmp;
#line 209
    if (i == npoints) {
#line 209
      tmp___0 = llsize - 1UL;
    } else {
#line 209
      tmp___0 = (size_t )*(splitpoints + i);
    }
#line 209
    end = tmp___0;
#line 210
    if (! *(done + start)) {
#line 210
      if (end - start > longest) {
#line 211
        *lstart = start;
#line 212
        *lend = end;
#line 213
        found = 1;
#line 214
        longest = end - start;
      }
    }
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (found);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
void ZopfliBlockSplitLZ77(ZopfliOptions const   *options , unsigned short const   *litlens ,
                          unsigned short const   *dists , size_t llsize , size_t maxblocks ,
                          size_t **splitpoints , size_t *npoints ) 
{ 
  size_t lstart ;
  size_t lend ;
  size_t i ;
  size_t llpos ;
  size_t numblocks ;
  unsigned char *done ;
  double splitcost ;
  double origcost ;
  void *tmp ;
  SplitCostContext c ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;

  {
#line 227
  llpos = (size_t )0;
#line 228
  numblocks = (size_t )1;
#line 232
  if (llsize < 10UL) {
#line 232
    return;
  }
  {
#line 234
  tmp = malloc(llsize);
#line 234
  done = (unsigned char *)tmp;
  }
#line 235
  if (! done) {
    {
#line 235
    exit(-1);
    }
  }
#line 236
  i = (size_t )0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < llsize)) {
#line 236
      goto while_break;
    }
#line 236
    *(done + i) = (unsigned char)0;
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  lstart = (size_t )0;
#line 239
  lend = llsize;
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 243
    if (maxblocks > 0UL) {
#line 243
      if (numblocks >= maxblocks) {
#line 244
        goto while_break___0;
      }
    }
#line 247
    c.litlens = litlens;
#line 248
    c.dists = dists;
#line 249
    c.llsize = llsize;
#line 250
    c.start = lstart;
#line 251
    c.end = lend;
#line 252
    if (! (lstart < lend)) {
      {
#line 252
      __assert_fail("lstart < lend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c",
                    252U, "ZopfliBlockSplitLZ77");
      }
    }
    {
#line 253
    llpos = FindMinimum(& SplitCost, (void *)(& c), lstart + 1UL, lend);
    }
#line 255
    if (! (llpos > lstart)) {
      {
#line 255
      __assert_fail("llpos > lstart", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c",
                    255U, "ZopfliBlockSplitLZ77");
      }
    }
#line 256
    if (! (llpos < lend)) {
      {
#line 256
      __assert_fail("llpos < lend", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c",
                    256U, "ZopfliBlockSplitLZ77");
      }
    }
    {
#line 258
    tmp___0 = EstimateCost(litlens, dists, lstart, llpos);
#line 258
    tmp___1 = EstimateCost(litlens, dists, llpos, lend);
#line 258
    splitcost = tmp___0 + tmp___1;
#line 260
    origcost = EstimateCost(litlens, dists, lstart, lend);
    }
#line 262
    if (splitcost > origcost) {
#line 263
      *(done + lstart) = (unsigned char)1;
    } else
#line 262
    if (llpos == lstart + 1UL) {
#line 263
      *(done + lstart) = (unsigned char)1;
    } else
#line 262
    if (llpos == lend) {
#line 263
      *(done + lstart) = (unsigned char)1;
    } else {
      {
#line 265
      AddSorted(llpos, splitpoints, npoints);
#line 266
      numblocks ++;
      }
    }
    {
#line 269
    tmp___2 = FindLargestSplittableBlock(llsize, (unsigned char const   *)done, (size_t const   *)*splitpoints,
                                         *npoints, & lstart, & lend);
    }
#line 269
    if (! tmp___2) {
#line 271
      goto while_break___0;
    }
#line 274
    if (lend - lstart < 10UL) {
#line 275
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 279
  if (options->verbose) {
    {
#line 280
    PrintBlockSplitPoints(litlens, dists, llsize, (size_t const   *)*splitpoints,
                          *npoints);
    }
  }
  {
#line 283
  free((void *)done);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
void ZopfliBlockSplit(ZopfliOptions const   *options , unsigned char const   *in ,
                      size_t instart , size_t inend , size_t maxblocks , size_t **splitpoints ,
                      size_t *npoints ) 
{ 
  size_t pos ;
  size_t i ;
  ZopfliBlockState s ;
  size_t *lz77splitpoints ;
  size_t nlz77points ;
  ZopfliLZ77Store store ;
  size_t length ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 289
  pos = (size_t )0;
#line 292
  lz77splitpoints = (size_t *)0;
#line 293
  nlz77points = (size_t )0;
#line 296
  ZopfliInitLZ77Store(& store);
#line 298
  s.options = options;
#line 299
  s.blockstart = instart;
#line 300
  s.blockend = inend;
#line 302
  s.lmc = (ZopfliLongestMatchCache *)0;
#line 305
  *npoints = (size_t )0;
#line 306
  *splitpoints = (size_t *)0;
#line 310
  ZopfliLZ77Greedy(& s, in, instart, inend, & store);
#line 312
  ZopfliBlockSplitLZ77(options, (unsigned short const   *)store.litlens, (unsigned short const   *)store.dists,
                       store.size, maxblocks, & lz77splitpoints, & nlz77points);
#line 317
  pos = instart;
  }
#line 318
  if (nlz77points > 0UL) {
#line 319
    i = (size_t )0;
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      if (! (i < store.size)) {
#line 319
        goto while_break;
      }
#line 320
      if ((int )*(store.dists + i) == 0) {
#line 320
        tmp = 1;
      } else {
#line 320
        tmp = (int )*(store.litlens + i);
      }
#line 320
      length = (size_t )tmp;
#line 321
      if (*(lz77splitpoints + *npoints) == i) {
#line 322
        if (! (*npoints & (*npoints - 1UL))) {
#line 322
          if (*npoints == 0UL) {
            {
#line 322
            tmp___0 = malloc(sizeof(*(*splitpoints)));
#line 322
            *splitpoints = (size_t *)tmp___0;
            }
          } else {
            {
#line 322
            tmp___1 = realloc((void *)*splitpoints, (*npoints * 2UL) * sizeof(*(*splitpoints)));
#line 322
            *splitpoints = (size_t *)tmp___1;
            }
          }
        }
#line 322
        *(*splitpoints + *npoints) = pos;
#line 322
        (*npoints) ++;
#line 323
        if (*npoints == nlz77points) {
#line 323
          goto while_break;
        }
      }
#line 325
      pos += length;
#line 319
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 328
  if (! (*npoints == nlz77points)) {
    {
#line 328
    __assert_fail("*npoints == nlz77points", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c",
                  328U, "ZopfliBlockSplit");
    }
  }
  {
#line 330
  free((void *)lz77splitpoints);
#line 331
  ZopfliCleanLZ77Store(& store);
  }
#line 332
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/blocksplitter.c"
void ZopfliBlockSplitSimple(unsigned char const   *in , size_t instart , size_t inend ,
                            size_t blocksize , size_t **splitpoints , size_t *npoints ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 338
  i = instart;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i < inend)) {
#line 339
      goto while_break;
    }
#line 340
    if (! (*npoints & (*npoints - 1UL))) {
#line 340
      if (*npoints == 0UL) {
        {
#line 340
        tmp = malloc(sizeof(*(*splitpoints)));
#line 340
        *splitpoints = (size_t *)tmp;
        }
      } else {
        {
#line 340
        tmp___0 = realloc((void *)*splitpoints, (*npoints * 2UL) * sizeof(*(*splitpoints)));
#line 340
        *splitpoints = (size_t *)tmp___0;
        }
      }
    }
#line 340
    *(*splitpoints + *npoints) = i;
#line 340
    (*npoints) ++;
#line 341
    i += blocksize;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return;
}
}
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetDistExtraBits(int dist ) 
{ 
  int tmp ;

  {
#line 30
  if (dist < 5) {
#line 30
    return (0);
  }
  {
#line 31
  tmp = __builtin_clz((unsigned int )(dist - 1));
  }
#line 31
  return ((31 ^ tmp) - 1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetDistExtraBitsValue(int dist ) 
{ 
  int l ;
  int tmp ;

  {
#line 52
  if (dist < 5) {
#line 53
    return (0);
  } else {
    {
#line 55
    tmp = __builtin_clz((unsigned int )(dist - 1));
#line 55
    l = 31 ^ tmp;
    }
#line 56
    return ((dist - (1 + (1 << l))) & ((1 << (l - 1)) - 1));
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetDistSymbol(int dist ) 
{ 
  int l ;
  int tmp ;
  int r ;

  {
#line 78
  if (dist < 5) {
#line 79
    return (dist - 1);
  } else {
    {
#line 81
    tmp = __builtin_clz((unsigned int )(dist - 1));
#line 81
    l = 31 ^ tmp;
#line 82
    r = ((dist - 1) >> (l - 1)) & 1;
    }
#line 83
    return (l * 2 + r);
  }
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
static int const   table[259]  = 
#line 126
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0};
#line 125 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetLengthExtraBits(int l ) 
{ 


  {
#line 144
  return ((int )table[l]);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
static int const   table___0[259]  = 
#line 148
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )7,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )16, 
        (int const   )17,      (int const   )18,      (int const   )19,      (int const   )20, 
        (int const   )21,      (int const   )22,      (int const   )23,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )0};
#line 147 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetLengthExtraBitsValue(int l ) 
{ 


  {
#line 162
  return ((int )table___0[l]);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
static int const   table___1[259]  = 
#line 169
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )257, 
        (int const   )258,      (int const   )259,      (int const   )260,      (int const   )261, 
        (int const   )262,      (int const   )263,      (int const   )264,      (int const   )265, 
        (int const   )265,      (int const   )266,      (int const   )266,      (int const   )267, 
        (int const   )267,      (int const   )268,      (int const   )268,      (int const   )269, 
        (int const   )269,      (int const   )269,      (int const   )269,      (int const   )270, 
        (int const   )270,      (int const   )270,      (int const   )270,      (int const   )271, 
        (int const   )271,      (int const   )271,      (int const   )271,      (int const   )272, 
        (int const   )272,      (int const   )272,      (int const   )272,      (int const   )273, 
        (int const   )273,      (int const   )273,      (int const   )273,      (int const   )273, 
        (int const   )273,      (int const   )273,      (int const   )273,      (int const   )274, 
        (int const   )274,      (int const   )274,      (int const   )274,      (int const   )274, 
        (int const   )274,      (int const   )274,      (int const   )274,      (int const   )275, 
        (int const   )275,      (int const   )275,      (int const   )275,      (int const   )275, 
        (int const   )275,      (int const   )275,      (int const   )275,      (int const   )276, 
        (int const   )276,      (int const   )276,      (int const   )276,      (int const   )276, 
        (int const   )276,      (int const   )276,      (int const   )276,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )277, 
        (int const   )277,      (int const   )277,      (int const   )277,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )278, 
        (int const   )278,      (int const   )278,      (int const   )278,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )279, 
        (int const   )279,      (int const   )279,      (int const   )279,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )280, 
        (int const   )280,      (int const   )280,      (int const   )280,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )281, 
        (int const   )281,      (int const   )281,      (int const   )281,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )282, 
        (int const   )282,      (int const   )282,      (int const   )282,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )283, 
        (int const   )283,      (int const   )283,      (int const   )283,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )284,      (int const   )284, 
        (int const   )284,      (int const   )284,      (int const   )285};
#line 168 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
int ZopfliGetLengthSymbol(int l ) 
{ 


  {
#line 203
  return ((int )table___1[l]);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/util.c"
void ZopfliInitOptions(ZopfliOptions *options ) 
{ 


  {
#line 207
  options->verbose = 0;
#line 208
  options->verbose_more = 0;
#line 209
  options->numiterations = 15;
#line 210
  options->blocksplitting = 1;
#line 211
  options->blocksplittinglast = 0;
#line 212
  options->blocksplittingmax = 15;
#line 213
  return;
}
}
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c"
void ZopfliLengthsToSymbols(unsigned int const   *lengths , size_t n , unsigned int maxbits ,
                            unsigned int *symbols ) 
{ 
  size_t *bl_count ;
  void *tmp ;
  size_t *next_code ;
  void *tmp___0 ;
  unsigned int bits ;
  unsigned int i ;
  unsigned int code ;
  unsigned int len ;

  {
  {
#line 32
  tmp = malloc(sizeof(size_t ) * (unsigned long )(maxbits + 1U));
#line 32
  bl_count = (size_t *)tmp;
#line 33
  tmp___0 = malloc(sizeof(size_t ) * (unsigned long )(maxbits + 1U));
#line 33
  next_code = (size_t *)tmp___0;
#line 37
  i = 0U;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! ((size_t )i < n)) {
#line 37
      goto while_break;
    }
#line 38
    *(symbols + i) = 0U;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  bits = 0U;
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 43
    if (! (bits <= maxbits)) {
#line 43
      goto while_break___0;
    }
#line 44
    *(bl_count + bits) = (size_t )0;
#line 43
    bits ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 46
  i = 0U;
  {
#line 46
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 46
    if (! ((size_t )i < n)) {
#line 46
      goto while_break___1;
    }
#line 47
    if (! (*(lengths + i) <= (unsigned int const   )maxbits)) {
      {
#line 47
      __assert_fail("lengths[i] <= maxbits", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c",
                    47U, "ZopfliLengthsToSymbols");
      }
    }
#line 48
    (*(bl_count + *(lengths + i))) ++;
#line 46
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 51
  code = 0U;
#line 52
  *(bl_count + 0) = (size_t )0;
#line 53
  bits = 1U;
  {
#line 53
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 53
    if (! (bits <= maxbits)) {
#line 53
      goto while_break___2;
    }
#line 54
    code = (unsigned int )(((size_t )code + *(bl_count + (bits - 1U))) << 1);
#line 55
    *(next_code + bits) = (size_t )code;
#line 53
    bits ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 59
  i = 0U;
  {
#line 59
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 59
    if (! ((size_t )i < n)) {
#line 59
      goto while_break___3;
    }
#line 60
    len = (unsigned int )*(lengths + i);
#line 61
    if (len != 0U) {
#line 62
      *(symbols + i) = (unsigned int )*(next_code + len);
#line 63
      (*(next_code + len)) ++;
    }
#line 59
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 67
  free((void *)bl_count);
#line 68
  free((void *)next_code);
  }
#line 69
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c"
static double const   kInvLog2  =    (double const   )1.4426950408889;
#line 71 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c"
void ZopfliCalculateEntropy(size_t const   *count , size_t n , double *bitlengths ) 
{ 
  unsigned int sum ;
  unsigned int i ;
  double log2sum ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 73
  sum = 0U;
#line 76
  i = 0U;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((size_t )i < n)) {
#line 76
      goto while_break;
    }
#line 77
    sum = (unsigned int )((size_t const   )sum + *(count + i));
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (sum == 0U) {
    {
#line 79
    tmp = log((double )n);
#line 79
    tmp___1 = tmp;
    }
  } else {
    {
#line 79
    tmp___0 = log((double )sum);
#line 79
    tmp___1 = tmp___0;
    }
  }
#line 79
  log2sum = tmp___1 * (double )kInvLog2;
#line 80
  i = 0U;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! ((size_t )i < n)) {
#line 80
      goto while_break___0;
    }
#line 84
    if (*(count + i) == 0UL) {
#line 84
      *(bitlengths + i) = log2sum;
    } else {
      {
#line 85
      tmp___2 = log((double )*(count + i));
#line 85
      *(bitlengths + i) = log2sum - tmp___2 * (double )kInvLog2;
      }
    }
#line 91
    if (*(bitlengths + i) < (double )0) {
#line 91
      if (*(bitlengths + i) > - 1e-5) {
#line 91
        *(bitlengths + i) = (double )0;
      }
    }
#line 92
    if (! (*(bitlengths + i) >= (double )0)) {
      {
#line 92
      __assert_fail("bitlengths[i] >= 0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c",
                    92U, "ZopfliCalculateEntropy");
      }
    }
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c"
void ZopfliCalculateBitLengths(size_t const   *count , size_t n , int maxbits , unsigned int *bitlengths ) 
{ 
  int error ;
  int tmp ;

  {
  {
#line 98
  tmp = ZopfliLengthLimitedCodeLengths(count, (int )n, maxbits, bitlengths);
#line 98
  error = tmp;
  }
#line 100
  if (! (! error)) {
    {
#line 100
    __assert_fail("!error", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/tree.c",
                  100U, "ZopfliCalculateBitLengths");
    }
  }
#line 101
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.c"
void ZopfliInitHash(size_t window_size , ZopfliHash *h ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 32
  h->val = 0;
#line 33
  tmp = malloc(sizeof(*(h->head)) * 65536UL);
#line 33
  h->head = (int *)tmp;
#line 34
  tmp___0 = malloc(sizeof(*(h->prev)) * window_size);
#line 34
  h->prev = (unsigned short *)tmp___0;
#line 35
  tmp___1 = malloc(sizeof(*(h->hashval)) * window_size);
#line 35
  h->hashval = (int *)tmp___1;
#line 36
  i = (size_t )0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < 65536UL)) {
#line 36
      goto while_break;
    }
#line 37
    *(h->head + i) = -1;
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  i = (size_t )0;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! (i < window_size)) {
#line 39
      goto while_break___0;
    }
#line 40
    *(h->prev + i) = (unsigned short )i;
#line 41
    *(h->hashval + i) = -1;
#line 39
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 45
  tmp___2 = malloc(sizeof(*(h->same)) * window_size);
#line 45
  h->same = (unsigned short *)tmp___2;
#line 46
  i = (size_t )0;
  }
  {
#line 46
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 46
    if (! (i < window_size)) {
#line 46
      goto while_break___1;
    }
#line 47
    *(h->same + i) = (unsigned short)0;
#line 46
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 52
  h->val2 = 0;
#line 53
  tmp___3 = malloc(sizeof(*(h->head2)) * 65536UL);
#line 53
  h->head2 = (int *)tmp___3;
#line 54
  tmp___4 = malloc(sizeof(*(h->prev2)) * window_size);
#line 54
  h->prev2 = (unsigned short *)tmp___4;
#line 55
  tmp___5 = malloc(sizeof(*(h->hashval2)) * window_size);
#line 55
  h->hashval2 = (int *)tmp___5;
#line 56
  i = (size_t )0;
  }
  {
#line 56
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 56
    if (! (i < 65536UL)) {
#line 56
      goto while_break___2;
    }
#line 57
    *(h->head2 + i) = -1;
#line 56
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 59
  i = (size_t )0;
  {
#line 59
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 59
    if (! (i < window_size)) {
#line 59
      goto while_break___3;
    }
#line 60
    *(h->prev2 + i) = (unsigned short )i;
#line 61
    *(h->hashval2 + i) = -1;
#line 59
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.c"
void ZopfliCleanHash(ZopfliHash *h ) 
{ 


  {
  {
#line 67
  free((void *)h->head);
#line 68
  free((void *)h->prev);
#line 69
  free((void *)h->hashval);
#line 72
  free((void *)h->head2);
#line 73
  free((void *)h->prev2);
#line 74
  free((void *)h->hashval2);
#line 78
  free((void *)h->same);
  }
#line 80
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.c"
static void UpdateHashValue(ZopfliHash *h , unsigned char c ) 
{ 


  {
#line 88
  h->val = ((h->val << 5) ^ (int )c) & 32767;
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.c"
void ZopfliUpdateHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) 
{ 
  unsigned short hpos ;
  size_t amount ;
  int tmp ;

  {
#line 93
  hpos = (unsigned short )(pos & 32767UL);
#line 95
  amount = (size_t )0;
#line 98
  if (pos + 3UL <= end) {
#line 98
    tmp = (int const   )*(array + ((pos + 3UL) - 1UL));
  } else {
#line 98
    tmp = (int const   )0;
  }
  {
#line 98
  UpdateHashValue(h, (unsigned char )tmp);
#line 100
  *(h->hashval + hpos) = h->val;
  }
#line 101
  if (*(h->head + h->val) != -1) {
#line 101
    if (*(h->hashval + *(h->head + h->val)) == h->val) {
#line 102
      *(h->prev + hpos) = (unsigned short )*(h->head + h->val);
    } else {
#line 104
      *(h->prev + hpos) = hpos;
    }
  } else {
#line 104
    *(h->prev + hpos) = hpos;
  }
#line 105
  *(h->head + h->val) = (int )hpos;
#line 109
  if ((int )*(h->same + ((pos - 1UL) & 32767UL)) > 1) {
#line 110
    amount = (size_t )((int )*(h->same + ((pos - 1UL) & 32767UL)) - 1);
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((pos + amount) + 1UL < end) {
#line 112
      if ((int const   )*(array + pos) == (int const   )*(array + ((pos + amount) + 1UL))) {
#line 112
        if (! (amount < 65535UL)) {
#line 112
          goto while_break;
        }
      } else {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 114
    amount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  *(h->same + hpos) = (unsigned short )amount;
#line 120
  h->val2 = (((int )*(h->same + hpos) - 3) & 255) ^ h->val;
#line 121
  *(h->hashval2 + hpos) = h->val2;
#line 122
  if (*(h->head2 + h->val2) != -1) {
#line 122
    if (*(h->hashval2 + *(h->head2 + h->val2)) == h->val2) {
#line 123
      *(h->prev2 + hpos) = (unsigned short )*(h->head2 + h->val2);
    } else {
#line 125
      *(h->prev2 + hpos) = hpos;
    }
  } else {
#line 125
    *(h->prev2 + hpos) = hpos;
  }
#line 126
  *(h->head2 + h->val2) = (int )hpos;
#line 128
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/hash.c"
void ZopfliWarmupHash(unsigned char const   *array , size_t pos , size_t end , ZopfliHash *h ) 
{ 


  {
  {
#line 133
  UpdateHashValue(h, (unsigned char )*(array + pos));
#line 134
  UpdateHashValue(h, (unsigned char )*(array + (pos + 1UL)));
  }
#line 135
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_lib.c"
void ZopfliCompress(ZopfliOptions const   *options , ZopfliFormat output_type , unsigned char const   *in ,
                    size_t insize , unsigned char **out , size_t *outsize ) 
{ 
  unsigned char bp ;

  {
#line 32
  if ((unsigned int )output_type == 0U) {
    {
#line 33
    ZopfliGzipCompress(options, in, insize, out, outsize);
    }
  } else
#line 34
  if ((unsigned int )output_type == 1U) {
    {
#line 35
    ZopfliZlibCompress(options, in, insize, out, outsize);
    }
  } else
#line 36
  if ((unsigned int )output_type == 2U) {
    {
#line 37
    bp = (unsigned char)0;
#line 38
    ZopfliDeflate(options, 2, 1, in, insize, & bp, out, outsize);
    }
  } else {
    {
#line 41
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/zopfli-1.0.0/src/zopfli/zopfli_lib.c",
                  41U, "ZopfliCompress");
    }
  }
#line 43
  return;
}
}
