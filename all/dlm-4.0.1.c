/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/dlm_controld.h"
struct dlmc_header {
   unsigned int magic ;
   unsigned int version ;
   unsigned int command ;
   unsigned int option ;
   unsigned int len ;
   int data ;
   int unused1 ;
   int unsued2 ;
   char name[64] ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/dlm_controld.h"
struct dlmc_state {
   uint32_t type ;
   uint32_t flags ;
   int32_t nodeid ;
   uint32_t data32 ;
   uint32_t data64 ;
   uint32_t str_len ;
   uint32_t bin_len ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/libdlmcontrol.h"
struct dlmc_node {
   int nodeid ;
   uint32_t flags ;
   uint32_t added_seq ;
   uint32_t removed_seq ;
   int fail_reason ;
   uint64_t fail_walltime ;
   uint64_t fail_monotime ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/libdlmcontrol.h"
struct dlmc_change {
   int member_count ;
   int joined_count ;
   int remove_count ;
   int failed_count ;
   int wait_condition ;
   int wait_messages ;
   uint32_t seq ;
   uint32_t combined_seq ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/libdlmcontrol.h"
struct dlmc_lockspace {
   struct dlmc_change cg_prev ;
   struct dlmc_change cg_next ;
   uint32_t flags ;
   uint32_t global_id ;
   char name[65] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 61 "/usr/include/linux/dlm.h"
struct dlm_lksb {
   int sb_status ;
   __u32 sb_lkid ;
   char sb_flags ;
   char *sb_lvbptr ;
};
#line 136 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.h"
typedef void *dlm_lshandle_t;
#line 32 "/usr/include/linux/dlm_device.h"
struct dlm_lock_params {
   __u8 mode ;
   __u8 namelen ;
   __u16 unused ;
   __u32 flags ;
   __u32 lkid ;
   __u32 parent ;
   __u64 xid ;
   __u64 timeout ;
   void *castparam ;
   void *castaddr ;
   void *bastparam ;
   void *bastaddr ;
   struct dlm_lksb *lksb ;
   char lvb[32] ;
   char name[0] ;
};
#line 50 "/usr/include/linux/dlm_device.h"
struct dlm_lspace_params {
   __u32 flags ;
   __u32 minor ;
   char name[0] ;
};
#line 56 "/usr/include/linux/dlm_device.h"
struct dlm_purge_params {
   __u32 nodeid ;
   __u32 pid ;
};
#line 61 "/usr/include/linux/dlm_device.h"
union __anonunion_i_58 {
   struct dlm_lock_params lock ;
   struct dlm_lspace_params lspace ;
   struct dlm_purge_params purge ;
};
#line 61 "/usr/include/linux/dlm_device.h"
struct dlm_write_request {
   __u32 version[3] ;
   __u8 cmd ;
   __u8 is64bit ;
   __u8 unused[2] ;
   union __anonunion_i_58 i ;
};
#line 74 "/usr/include/linux/dlm_device.h"
struct dlm_device_version {
   __u32 version[3] ;
};
#line 81 "/usr/include/linux/dlm_device.h"
struct dlm_lock_result {
   __u32 version[3] ;
   __u32 length ;
   void *user_astaddr ;
   void *user_astparam ;
   struct dlm_lksb *user_lksb ;
   struct dlm_lksb lksb ;
   __u8 bast_mode ;
   __u8 unused[3] ;
   __u32 lvb_offset ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct dlm_lock_params_v5 {
   __u8 mode ;
   __u8 namelen ;
   __u16 flags ;
   __u32 lkid ;
   __u32 parent ;
   void *castparam ;
   void *castaddr ;
   void *bastparam ;
   void *bastaddr ;
   struct dlm_lksb *lksb ;
   char lvb[32] ;
   char name[0] ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
union __anonunion_i_59 {
   struct dlm_lock_params_v5 lock ;
   struct dlm_lspace_params lspace ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct dlm_write_request_v5 {
   __u32 version[3] ;
   __u8 cmd ;
   __u8 is64bit ;
   __u8 unused[2] ;
   union __anonunion_i_59 i ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct dlm_lock_result_v5 {
   __u32 length ;
   void *user_astaddr ;
   void *user_astparam ;
   struct dlm_lksb *user_lksb ;
   struct dlm_lksb lksb ;
   __u8 bast_mode ;
   __u8 unused[3] ;
   __u32 lvb_offset ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct dlm_ls_info {
   int fd ;
   int tid ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_3 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_3 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_4 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_4 pthread_mutexattr_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_6 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_5 {
   struct __anonstruct___data_6 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_5 pthread_cond_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_7 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_7 pthread_condattr_t;
#line 551 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct dlm_ls_info___0 {
   int fd ;
   pthread_t tid ;
};
#line 127 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
struct lock_wait {
   pthread_cond_t cond ;
   pthread_mutex_t mutex ;
   struct dlm_lksb lksb ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/libdlmcontrol.h"
int dlmc_dump_debug(char *buf ) ;
#line 84
int dlmc_dump_config(char *buf ) ;
#line 85
int dlmc_dump_log_plock(char *buf ) ;
#line 86
int dlmc_dump_plocks(char *name , char *buf ) ;
#line 87
int dlmc_lockspace_info(char *name , struct dlmc_lockspace *lockspace ) ;
#line 88
int dlmc_node_info(char *name , int nodeid , struct dlmc_node *node ) ;
#line 89
int dlmc_lockspaces(int max , int *count , struct dlmc_lockspace *lss ) ;
#line 90
int dlmc_lockspace_nodes(char *name , int type , int max , int *count , struct dlmc_node *nodes ) ;
#line 92
int dlmc_print_status(uint32_t flags ) ;
#line 97
int dlmc_fs_connect(void) ;
#line 98
void dlmc_fs_disconnect(int fd ) ;
#line 99
int dlmc_fs_register(int fd , char *name ) ;
#line 100
int dlmc_fs_unregister(int fd , char *name ) ;
#line 101
int dlmc_fs_notified(int fd , char *name , int nodeid ) ;
#line 102
int dlmc_fs_result(int fd , char *name , int *type , int *nodeid , int *result ) ;
#line 104
int dlmc_deadlock_check(char *name ) ;
#line 105
int dlmc_fence_ack(char *name ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static int do_read(int fd , void *buf , size_t count ) 
{ 
  int rv ;
  int off ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 25
  off = 0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((size_t )off < count)) {
#line 27
      goto while_break;
    }
    {
#line 28
    tmp = read(fd, (void *)((char *)buf + off), count - (size_t )off);
#line 28
    rv = (int )tmp;
    }
#line 29
    if (rv == 0) {
#line 30
      return (-1);
    }
#line 31
    if (rv == -1) {
      {
#line 31
      tmp___0 = __errno_location();
      }
#line 31
      if (*tmp___0 == 4) {
#line 32
        goto while_continue;
      }
    }
#line 33
    if (rv == -1) {
#line 34
      return (-1);
    }
#line 35
    off += rv;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (0);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static int do_write(int fd , void *buf , size_t count ) 
{ 
  int rv ;
  int off ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 42
  off = 0;
  retry: 
  {
#line 45
  tmp = write(fd, (void const   *)((char *)buf + off), count);
#line 45
  rv = (int )tmp;
  }
#line 46
  if (rv == -1) {
    {
#line 46
    tmp___0 = __errno_location();
    }
#line 46
    if (*tmp___0 == 4) {
#line 47
      goto retry;
    }
  }
#line 48
  if (rv < 0) {
#line 49
    return (rv);
  }
#line 52
  if ((size_t )rv != count) {
#line 53
    count -= (size_t )rv;
#line 54
    off += rv;
#line 55
    goto retry;
  }
#line 57
  return (0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static int do_connect(char const   *sock_path ) 
{ 
  struct sockaddr_un sun ;
  socklen_t addrlen ;
  int rv ;
  int fd ;
  size_t tmp ;

  {
  {
#line 66
  fd = socket(1, 1, 0);
  }
#line 67
  if (fd < 0) {
#line 68
    goto out;
  }
  {
#line 70
  memset((void *)(& sun), 0, sizeof(sun));
#line 71
  sun.sun_family = (sa_family_t )1;
#line 72
  strcpy((char */* __restrict  */)(& sun.sun_path[1]), (char const   */* __restrict  */)sock_path);
#line 73
  tmp = strlen((char const   *)(sun.sun_path + 1));
#line 73
  addrlen = (socklen_t )((sizeof(sa_family_t ) + tmp) + 1UL);
#line 75
  rv = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sun)),
               addrlen);
  }
#line 76
  if (rv < 0) {
    {
#line 77
    close(fd);
#line 78
    fd = rv;
    }
  }
  out: 
#line 81
  return (fd);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static void init_header(struct dlmc_header *h , int cmd , char *name , int extra_len ) 
{ 


  {
  {
#line 87
  memset((void *)h, 0, sizeof(struct dlmc_header ));
#line 89
  h->magic = 3510423868U;
#line 90
  h->version = 65537U;
#line 91
  h->len = (unsigned int )(sizeof(struct dlmc_header ) + (unsigned long )extra_len);
#line 92
  h->command = (unsigned int )cmd;
  }
#line 94
  if (name) {
    {
#line 95
    strncpy((char */* __restrict  */)(h->name), (char const   */* __restrict  */)name,
            (size_t )64);
    }
  }
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static char copy_buf[1048576]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static int do_dump(int cmd , char *name , char *buf ) 
{ 
  struct dlmc_header h ;
  int fd ;
  int rv ;
  int len ;

  {
  {
#line 105
  memset((void *)(copy_buf), 0, (size_t )1048576);
#line 107
  init_header(& h, cmd, name, 0);
#line 109
  fd = do_connect("dlmc_query_sock");
  }
#line 110
  if (fd < 0) {
#line 111
    rv = fd;
#line 112
    goto out;
  }
  {
#line 115
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 116
  if (rv < 0) {
#line 117
    goto out_close;
  }
  {
#line 119
  memset((void *)(& h), 0, sizeof(h));
#line 121
  rv = do_read(fd, (void *)(& h), sizeof(h));
  }
#line 122
  if (rv < 0) {
#line 123
    goto out_close;
  }
#line 125
  len = (int )((unsigned long )h.len - sizeof(h));
#line 127
  if (len <= 0) {
#line 128
    goto out_close;
  } else
#line 127
  if (len > 1048576) {
#line 128
    goto out_close;
  }
  {
#line 130
  rv = do_read(fd, (void *)(copy_buf), (size_t )len);
  }
#line 131
  if (rv < 0) {
#line 132
    goto out_close;
  }
  {
#line 134
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(copy_buf),
         (size_t )len);
  }
  out_close: 
  {
#line 136
  close(fd);
  }
  out: 
#line 138
  return (rv);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_dump_debug(char *buf ) 
{ 
  int tmp ;

  {
  {
#line 143
  tmp = do_dump(1, (char *)((void *)0), buf);
  }
#line 143
  return (tmp);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_dump_config(char *buf ) 
{ 
  int tmp ;

  {
  {
#line 148
  tmp = do_dump(14, (char *)((void *)0), buf);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_dump_log_plock(char *buf ) 
{ 
  int tmp ;

  {
  {
#line 153
  tmp = do_dump(11, (char *)((void *)0), buf);
  }
#line 153
  return (tmp);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_dump_plocks(char *name , char *buf ) 
{ 
  int tmp ;

  {
  {
#line 158
  tmp = do_dump(2, name, buf);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static int nodeid_compare(void const   *va , void const   *vb ) 
{ 
  int const   *a ;
  int const   *b ;

  {
#line 163
  a = (int const   *)va;
#line 164
  b = (int const   *)vb;
#line 166
  return ((int )(*a - *b));
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static void print_str(char *str , int len ) 
{ 
  char *p ;
  int i ;

  {
#line 174
  p = str + 0;
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < len - 1)) {
#line 175
      goto while_break;
    }
#line 176
    if ((int )*(str + i) == 32) {
      {
#line 177
      *(str + i) = (char )'\000';
#line 178
      printf((char const   */* __restrict  */)"    %s\n", p);
#line 179
      p = str + (i + 1);
      }
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (p) {
    {
#line 184
    printf((char const   */* __restrict  */)"    %s\n", p);
    }
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static unsigned int kv(char *str , char const   *k ) 
{ 
  char valstr___0[64] ;
  char *p ;
  int i ;
  char *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 193
  p = strstr((char const   *)str, k);
  }
#line 194
  if (! p) {
#line 195
    return (0U);
  }
  {
#line 197
  tmp = strstr((char const   *)p, "=");
#line 197
  p = tmp + 1;
  }
#line 198
  if (! p) {
#line 199
    return (0U);
  }
  {
#line 201
  memset((void *)(valstr___0), 0, (size_t )64);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 64)) {
#line 203
      goto while_break;
    }
#line 204
    if ((int )*p == 32) {
#line 205
      goto while_break;
    }
#line 206
    if ((int )*p == 0) {
#line 207
      goto while_break;
    }
#line 208
    if ((int )*p == 10) {
#line 209
      goto while_break;
    }
#line 210
    valstr___0[i] = *p;
#line 211
    p ++;
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  tmp___0 = strtoul((char const   */* __restrict  */)(valstr___0), (char **/* __restrict  */)((void *)0),
                    0);
  }
#line 214
  return ((unsigned int )tmp___0);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static char valstr[64]  ;
#line 217 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static char *ks(char *str , char const   *k ) 
{ 
  char *p ;
  int i ;
  char *tmp ;

  {
  {
#line 223
  p = strstr((char const   *)str, k);
  }
#line 224
  if (! p) {
#line 225
    return ((char *)0);
  }
  {
#line 227
  tmp = strstr((char const   *)p, "=");
#line 227
  p = tmp + 1;
  }
#line 228
  if (! p) {
#line 229
    return ((char *)0);
  }
  {
#line 231
  memset((void *)(valstr), 0, (size_t )64);
#line 233
  i = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < 64)) {
#line 233
      goto while_break;
    }
#line 234
    if ((int )*p == 32) {
#line 235
      goto while_break;
    }
#line 236
    if ((int )*p == 0) {
#line 237
      goto while_break;
    }
#line 238
    if ((int )*p == 10) {
#line 239
      goto while_break;
    }
#line 240
    valstr[i] = *p;
#line 241
    p ++;
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (valstr);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static void print_daemon(struct dlmc_state *st , char *str , char *bin , uint32_t flags ) 
{ 
  unsigned int cluster_ringid ;
  unsigned int daemon_ringid ;
  unsigned int fipu ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 252
  if (flags & 1U) {
    {
#line 253
    printf((char const   */* __restrict  */)"our_nodeid %d\n", st->nodeid);
#line 254
    print_str(str, (int )st->str_len);
    }
#line 255
    return;
  }
  {
#line 258
  cluster_ringid = kv(str, "cluster_ringid");
#line 259
  daemon_ringid = kv(str, "daemon_ringid");
#line 261
  tmp = kv(str, "quorate");
#line 261
  printf((char const   */* __restrict  */)"cluster nodeid %d quorate %u ring seq %u %u\n",
         st->nodeid, tmp, cluster_ringid, daemon_ringid);
#line 266
  fipu = kv(str, "fence_in_progress_unknown");
  }
#line 268
  if (fipu) {
#line 268
    tmp___0 = "fence_init";
  } else {
#line 268
    tmp___0 = "";
  }
  {
#line 268
  tmp___1 = kv(str, "fence_pid");
#line 268
  tmp___2 = kv(str, "monotime");
#line 268
  printf((char const   */* __restrict  */)"daemon now %u fence_pid %u %s\n", tmp___2,
         tmp___1, tmp___0);
  }
#line 272
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
static void format_daemon_node(struct dlmc_state *st , char *str , char *bin , uint32_t flags ,
                               char *node_line , char *fence_line ) 
{ 
  unsigned int delay_fencing ;
  unsigned int result_wait ;
  unsigned int killed ;
  char letter ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  time_t tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  time_t tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  char *tmp___21 ;

  {
#line 280
  if (st->type == 3U) {
#line 281
    letter = (char )'U';
  } else {
    {
#line 282
    tmp = kv(str, "member");
    }
#line 282
    if (tmp) {
#line 283
      letter = (char )'M';
    } else {
#line 285
      letter = (char )'X';
    }
  }
  {
#line 288
  tmp___0 = kv(str, "fence_walltime");
#line 288
  tmp___1 = kv(str, "actor_done");
#line 288
  tmp___2 = kv(str, "fence_monotime");
#line 288
  tmp___3 = kv(str, "fail_monotime");
#line 288
  tmp___4 = kv(str, "rem_time");
#line 288
  tmp___5 = kv(str, "add_time");
#line 288
  snprintf((char */* __restrict  */)node_line, (size_t )4095, (char const   */* __restrict  */)"node %d %c add %u rem %u fail %u fence %u at %u %u\n",
           st->nodeid, (int )letter, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1,
           tmp___0);
#line 299
  tmp___6 = kv(str, "need_fencing");
  }
#line 299
  if (! tmp___6) {
#line 300
    return;
  }
  {
#line 302
  delay_fencing = kv(str, "delay_fencing");
#line 303
  result_wait = kv(str, "fence_result_wait");
#line 304
  killed = kv(str, "killed");
  }
#line 306
  if (delay_fencing) {
#line 307
    if (killed) {
#line 307
      tmp___7 = " killed";
    } else {
#line 307
      tmp___7 = "";
    }
#line 307
    if (result_wait) {
#line 307
      tmp___8 = " result_wait";
    } else {
#line 307
      tmp___8 = "";
    }
    {
#line 307
    tmp___9 = time((time_t *)((void *)0));
#line 307
    tmp___10 = kv(str, "fence_walltime");
#line 307
    tmp___11 = kv(str, "fail_walltime");
#line 307
    tmp___12 = kv(str, "actor_last");
#line 307
    tmp___13 = ks(str, "left_reason");
#line 307
    snprintf((char */* __restrict  */)fence_line, (size_t )4095, (char const   */* __restrict  */)"fence %d %s delay actor %u fail %u fence %u now %u%s%s\n",
             st->nodeid, tmp___13, tmp___12, tmp___11, tmp___10, (unsigned int )tmp___9,
             tmp___8, tmp___7);
    }
  } else {
#line 318
    if (killed) {
#line 318
      tmp___14 = " killed";
    } else {
#line 318
      tmp___14 = "";
    }
#line 318
    if (result_wait) {
#line 318
      tmp___15 = " result_wait";
    } else {
#line 318
      tmp___15 = "";
    }
    {
#line 318
    tmp___16 = time((time_t *)((void *)0));
#line 318
    tmp___17 = kv(str, "fence_walltime");
#line 318
    tmp___18 = kv(str, "fail_walltime");
#line 318
    tmp___19 = kv(str, "actor_last");
#line 318
    tmp___20 = kv(str, "fence_pid");
#line 318
    tmp___21 = ks(str, "left_reason");
#line 318
    snprintf((char */* __restrict  */)fence_line, (size_t )4095, (char const   */* __restrict  */)"fence %d %s pid %d actor %u fail %u fence %u now %u%s%s\n",
             st->nodeid, tmp___21, tmp___20, tmp___19, tmp___18, tmp___17, (unsigned int )tmp___16,
             tmp___15, tmp___14);
    }
  }
#line 329
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_print_status(uint32_t flags ) 
{ 
  struct dlmc_header h ;
  struct dlmc_state state ;
  struct dlmc_state *st ;
  char maxstr[4096] ;
  char maxbin[4096] ;
  char *str ;
  char *bin ;
  int all_count ;
  int node_count ;
  int fence_count ;
  int all_ids[64] ;
  int node_ids[64] ;
  int fence_ids[64] ;
  char *node_lines[64] ;
  char *fence_lines[64] ;
  char *node_line ;
  char *fence_line ;
  int fd ;
  int rv ;
  int off ;
  int i ;
  int j ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 348
  init_header(& h, 13, (char *)((void *)0), 0);
#line 350
  fd = do_connect("dlmc_query_sock");
  }
#line 351
  if (fd < 0) {
    {
#line 352
    printf((char const   */* __restrict  */)"cannot connect to dlm_controld\n");
#line 353
    rv = fd;
    }
#line 354
    goto out;
  }
  {
#line 357
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 358
  if (rv < 0) {
    {
#line 359
    printf((char const   */* __restrict  */)"cannot send to dlm_controld\n");
    }
#line 360
    goto out_close;
  }
  {
#line 363
  st = & state;
#line 364
  str = maxstr;
#line 365
  bin = maxbin;
#line 366
  off = 0;
#line 368
  all_count = 0;
#line 369
  node_count = 0;
#line 370
  fence_count = 0;
#line 371
  memset((void *)(& all_ids), 0, sizeof(all_ids));
#line 372
  memset((void *)(& node_ids), 0, sizeof(node_ids));
#line 373
  memset((void *)(& fence_ids), 0, sizeof(fence_ids));
#line 374
  memset((void *)(node_lines), 0, sizeof(node_lines));
#line 375
  memset((void *)(fence_lines), 0, sizeof(fence_lines));
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 378
    memset((void *)(& state), 0, sizeof(state));
#line 379
    memset((void *)(maxstr), 0, sizeof(maxstr));
#line 380
    memset((void *)(maxbin), 0, sizeof(maxbin));
#line 382
    tmp = recv(fd, (void *)st, sizeof(struct dlmc_state ), 256);
#line 382
    rv = (int )tmp;
    }
#line 383
    if (! rv) {
#line 384
      goto while_break;
    }
#line 385
    if ((unsigned long )rv != sizeof(struct dlmc_state )) {
#line 386
      goto while_break;
    }
#line 388
    if (st->str_len) {
      {
#line 389
      tmp___0 = recv(fd, (void *)str, (size_t )st->str_len, 256);
#line 389
      rv = (int )tmp___0;
      }
#line 390
      if ((uint32_t )rv != st->str_len) {
#line 391
        goto while_break;
      }
    }
#line 394
    if (st->bin_len) {
      {
#line 395
      tmp___1 = recv(fd, (void *)bin, (size_t )st->bin_len, 256);
#line 395
      rv = (int )tmp___1;
      }
#line 396
      if ((uint32_t )rv != st->bin_len) {
#line 397
        goto while_break;
      }
    }
    {
#line 401
    if (st->type == 1U) {
#line 401
      goto case_1;
    }
#line 406
    if (st->type == 3U) {
#line 406
      goto case_3;
    }
#line 406
    if (st->type == 2U) {
#line 406
      goto case_3;
    }
#line 442
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 402
    print_daemon(st, str, bin, flags);
    }
#line 403
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 408
    if (flags & 1U) {
      {
#line 409
      printf((char const   */* __restrict  */)"nodeid %d\n", st->nodeid);
#line 410
      print_str(str, (int )st->str_len);
      }
    } else {
      {
#line 412
      tmp___2 = malloc((size_t )4096);
#line 412
      node_line = (char *)tmp___2;
      }
#line 413
      if (! node_line) {
#line 414
        goto switch_break;
      }
      {
#line 415
      tmp___3 = malloc((size_t )4096);
#line 415
      fence_line = (char *)tmp___3;
      }
#line 416
      if (! fence_line) {
        {
#line 417
        free((void *)node_line);
        }
#line 418
        goto switch_break;
      }
      {
#line 420
      memset((void *)node_line, 0, (size_t )4096);
#line 421
      memset((void *)fence_line, 0, (size_t )4096);
#line 423
      format_daemon_node(st, str, bin, flags, node_line, fence_line);
#line 426
      tmp___4 = all_count;
#line 426
      all_count ++;
#line 426
      all_ids[tmp___4] = st->nodeid;
#line 428
      node_ids[node_count] = st->nodeid;
#line 429
      tmp___5 = node_count;
#line 429
      node_count ++;
#line 429
      node_lines[tmp___5] = node_line;
#line 430
      node_count ++;
      }
#line 432
      if (! *(fence_line + 0)) {
        {
#line 433
        free((void *)fence_line);
        }
      } else {
#line 435
        fence_ids[fence_count] = st->nodeid;
#line 436
        fence_lines[fence_count] = fence_line;
#line 437
        fence_count ++;
      }
    }
#line 440
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 443
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 446
    if (rv < 0) {
#line 447
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if (all_count) {
    {
#line 451
    qsort((void *)(all_ids), (size_t )all_count, sizeof(int ), & nodeid_compare);
    }
  }
#line 453
  if (all_count) {
#line 453
    if (fence_count) {
#line 454
      i = 0;
      {
#line 454
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 454
        if (! (i < all_count)) {
#line 454
          goto while_break___0;
        }
#line 455
        j = 0;
        {
#line 455
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 455
          if (! (j < fence_count)) {
#line 455
            goto while_break___1;
          }
#line 456
          if (all_ids[i] != fence_ids[j]) {
#line 457
            goto __Cont;
          }
          {
#line 458
          printf((char const   */* __restrict  */)"%s", fence_lines[j]);
#line 459
          free((void *)fence_lines[j]);
          }
#line 460
          goto while_break___1;
          __Cont: /* CIL Label */ 
#line 455
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 454
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 465
  if (all_count) {
#line 465
    if (node_count) {
#line 466
      i = 0;
      {
#line 466
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 466
        if (! (i < all_count)) {
#line 466
          goto while_break___2;
        }
#line 467
        j = 0;
        {
#line 467
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 467
          if (! (j < node_count)) {
#line 467
            goto while_break___3;
          }
#line 468
          if (all_ids[i] != node_ids[j]) {
#line 469
            goto __Cont___0;
          }
          {
#line 470
          printf((char const   */* __restrict  */)"%s", node_lines[j]);
#line 471
          free((void *)node_lines[j]);
          }
#line 472
          goto while_break___3;
          __Cont___0: /* CIL Label */ 
#line 467
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 466
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  out_close: 
  {
#line 478
  close(fd);
  }
  out: 
#line 480
  return (rv);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_node_info(char *name , int nodeid , struct dlmc_node *node ) 
{ 
  struct dlmc_header h ;
  struct dlmc_header *rh ;
  char reply[sizeof(struct dlmc_header ) + sizeof(struct dlmc_node )] ;
  int fd ;
  int rv ;

  {
  {
#line 489
  init_header(& h, 4, name, 0);
#line 490
  h.data = nodeid;
#line 492
  memset((void *)(reply), 0, sizeof(reply));
#line 494
  fd = do_connect("dlmc_query_sock");
  }
#line 495
  if (fd < 0) {
#line 496
    rv = fd;
#line 497
    goto out;
  }
  {
#line 500
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 501
  if (rv < 0) {
#line 502
    goto out_close;
  }
  {
#line 504
  rv = do_read(fd, (void *)(reply), sizeof(reply));
  }
#line 505
  if (rv < 0) {
#line 506
    goto out_close;
  }
#line 508
  rh = (struct dlmc_header *)(reply);
#line 509
  rv = rh->data;
#line 510
  if (rv < 0) {
#line 511
    goto out_close;
  }
  {
#line 513
  memcpy((void */* __restrict  */)node, (void const   */* __restrict  */)(reply + sizeof(struct dlmc_header )),
         sizeof(struct dlmc_node ));
  }
  out_close: 
  {
#line 516
  close(fd);
  }
  out: 
#line 518
  return (rv);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_lockspace_info(char *name , struct dlmc_lockspace *lockspace ) 
{ 
  struct dlmc_header h ;
  struct dlmc_header *rh ;
  char reply[sizeof(struct dlmc_header ) + sizeof(struct dlmc_lockspace )] ;
  int fd ;
  int rv ;

  {
  {
#line 527
  init_header(& h, 3, name, 0);
#line 529
  memset((void *)(reply), 0, sizeof(reply));
#line 531
  fd = do_connect("dlmc_query_sock");
  }
#line 532
  if (fd < 0) {
#line 533
    rv = fd;
#line 534
    goto out;
  }
  {
#line 537
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 538
  if (rv < 0) {
#line 539
    goto out_close;
  }
  {
#line 541
  rv = do_read(fd, (void *)(reply), sizeof(reply));
  }
#line 542
  if (rv < 0) {
#line 543
    goto out_close;
  }
#line 545
  rh = (struct dlmc_header *)(reply);
#line 546
  rv = rh->data;
#line 547
  if (rv < 0) {
#line 548
    goto out_close;
  }
  {
#line 550
  memcpy((void */* __restrict  */)lockspace, (void const   */* __restrict  */)(reply + sizeof(struct dlmc_header )),
         sizeof(struct dlmc_lockspace ));
  }
  out_close: 
  {
#line 553
  close(fd);
  }
  out: 
#line 555
  return (rv);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_lockspaces(int max , int *count , struct dlmc_lockspace *lss ) 
{ 
  struct dlmc_header h ;
  struct dlmc_header *rh ;
  char *reply ;
  int reply_len ;
  int fd ;
  int rv ;
  int result ;
  int ls_count ;
  void *tmp ;

  {
  {
#line 565
  init_header(& h, 5, (char *)((void *)0), 0);
#line 566
  h.data = max;
#line 568
  reply_len = (int )(sizeof(struct dlmc_header ) + (unsigned long )max * sizeof(struct dlmc_lockspace ));
#line 570
  tmp = malloc((size_t )reply_len);
#line 570
  reply = (char *)tmp;
  }
#line 571
  if (! reply) {
#line 572
    rv = -1;
#line 573
    goto out;
  }
  {
#line 575
  memset((void *)reply, 0, (size_t )reply_len);
#line 577
  fd = do_connect("dlmc_query_sock");
  }
#line 578
  if (fd < 0) {
#line 579
    rv = fd;
#line 580
    goto out;
  }
  {
#line 583
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 584
  if (rv < 0) {
#line 585
    goto out_close;
  }
  {
#line 588
  do_read(fd, (void *)reply, (size_t )reply_len);
#line 590
  rh = (struct dlmc_header *)reply;
#line 591
  result = rh->data;
  }
#line 592
  if (result < 0) {
#line 592
    if (result != -7) {
#line 593
      rv = result;
#line 594
      goto out_close;
    }
  }
#line 597
  if (result == -7) {
#line 598
    *count = -7;
#line 599
    ls_count = max;
  } else {
#line 601
    *count = result;
#line 602
    ls_count = result;
  }
  {
#line 604
  rv = 0;
#line 606
  memcpy((void */* __restrict  */)lss, (void const   */* __restrict  */)(reply + sizeof(struct dlmc_header )),
         (unsigned long )ls_count * sizeof(struct dlmc_lockspace ));
  }
  out_close: 
  {
#line 609
  close(fd);
  }
  out: 
#line 611
  return (rv);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_lockspace_nodes(char *name , int type , int max , int *count , struct dlmc_node *nodes ) 
{ 
  struct dlmc_header h ;
  struct dlmc_header *rh ;
  char *reply ;
  int reply_len ;
  int fd ;
  int rv ;
  int result ;
  int node_count ;
  void *tmp ;

  {
  {
#line 622
  init_header(& h, 6, name, 0);
#line 623
  h.option = (unsigned int )type;
#line 624
  h.data = max;
#line 626
  reply_len = (int )(sizeof(struct dlmc_header ) + (unsigned long )max * sizeof(struct dlmc_node ));
#line 628
  tmp = malloc((size_t )reply_len);
#line 628
  reply = (char *)tmp;
  }
#line 629
  if (! reply) {
#line 630
    rv = -1;
#line 631
    goto out;
  }
  {
#line 633
  memset((void *)reply, 0, (size_t )reply_len);
#line 635
  fd = do_connect("dlmc_query_sock");
  }
#line 636
  if (fd < 0) {
#line 637
    rv = fd;
#line 638
    goto out;
  }
  {
#line 641
  rv = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 642
  if (rv < 0) {
#line 643
    goto out_close;
  }
  {
#line 646
  do_read(fd, (void *)reply, (size_t )reply_len);
#line 648
  rh = (struct dlmc_header *)reply;
#line 649
  result = rh->data;
  }
#line 650
  if (result < 0) {
#line 650
    if (result != -7) {
#line 651
      rv = result;
#line 652
      goto out_close;
    }
  }
#line 655
  if (result == -7) {
#line 656
    *count = -7;
#line 657
    node_count = max;
  } else {
#line 659
    *count = result;
#line 660
    node_count = result;
  }
  {
#line 662
  rv = 0;
#line 664
  memcpy((void */* __restrict  */)nodes, (void const   */* __restrict  */)(reply + sizeof(struct dlmc_header )),
         (unsigned long )node_count * sizeof(struct dlmc_node ));
  }
  out_close: 
  {
#line 667
  close(fd);
  }
  out: 
#line 669
  return (rv);
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fs_connect(void) 
{ 
  int tmp ;

  {
  {
#line 674
  tmp = do_connect("dlmc_sock");
  }
#line 674
  return (tmp);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
void dlmc_fs_disconnect(int fd ) 
{ 


  {
  {
#line 679
  close(fd);
  }
#line 680
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fs_register(int fd , char *name ) 
{ 
  struct dlmc_header h ;
  int tmp ;

  {
  {
#line 686
  init_header(& h, 7, name, 0);
#line 688
  tmp = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 688
  return (tmp);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fs_unregister(int fd , char *name ) 
{ 
  struct dlmc_header h ;
  int tmp ;

  {
  {
#line 695
  init_header(& h, 8, name, 0);
#line 697
  tmp = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 697
  return (tmp);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fs_notified(int fd , char *name , int nodeid ) 
{ 
  struct dlmc_header h ;
  int tmp ;

  {
  {
#line 704
  init_header(& h, 9, name, 0);
#line 705
  h.data = nodeid;
#line 707
  tmp = do_write(fd, (void *)(& h), sizeof(h));
  }
#line 707
  return (tmp);
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fs_result(int fd , char *name , int *type , int *nodeid , int *result ) 
{ 
  struct dlmc_header h ;
  int rv ;

  {
  {
#line 715
  rv = do_read(fd, (void *)(& h), sizeof(h));
  }
#line 716
  if (rv < 0) {
#line 717
    goto out;
  }
  {
#line 719
  strncpy((char */* __restrict  */)name, (char const   */* __restrict  */)(h.name),
          (size_t )64);
#line 720
  *nodeid = (int )h.option;
#line 721
  *result = h.data;
  }
  {
#line 724
  if (h.command == 7U) {
#line 724
    goto case_7;
  }
#line 727
  if (h.command == 9U) {
#line 727
    goto case_9;
  }
#line 730
  goto switch_default;
  case_7: /* CIL Label */ 
#line 725
  *type = 1;
#line 726
  goto switch_break;
  case_9: /* CIL Label */ 
#line 728
  *type = 2;
#line 729
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 731
  *type = 0;
  switch_break: /* CIL Label */ ;
  }
  out: 
#line 734
  return (rv);
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_deadlock_check(char *name ) 
{ 
  struct dlmc_header h ;
  int fd ;
  int rv ;

  {
  {
#line 742
  init_header(& h, 10, name, 0);
#line 744
  fd = do_connect("dlmc_sock");
  }
#line 745
  if (fd < 0) {
#line 746
    rv = fd;
#line 747
    goto out;
  }
  {
#line 750
  rv = do_write(fd, (void *)(& h), sizeof(h));
#line 751
  close(fd);
  }
  out: 
#line 753
  return (rv);
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/dlm_controld/lib.c"
int dlmc_fence_ack(char *name ) 
{ 
  struct dlmc_header h ;
  int fd ;
  int rv ;

  {
  {
#line 761
  init_header(& h, 12, name, 0);
#line 763
  fd = do_connect("dlmc_sock");
  }
#line 764
  if (fd < 0) {
#line 765
    rv = fd;
#line 766
    goto out;
  }
  {
#line 769
  rv = do_write(fd, (void *)(& h), sizeof(h));
#line 770
  close(fd);
  }
  out: 
#line 772
  return (rv);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.h"
int dlm_kernel_version(uint32_t *major , uint32_t *minor , uint32_t *patch ) ;
#line 58
void dlm_library_version(uint32_t *major , uint32_t *minor , uint32_t *patch ) ;
#line 77
int dlm_lock(uint32_t mode , struct dlm_lksb *lksb , uint32_t flags , void const   *name ,
             unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
             void *astarg , void (*bastaddr)(void *astarg ) , void *range ) ;
#line 88
int dlm_unlock(uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb , void *astarg ) ;
#line 93
int dlm_lock_wait(uint32_t mode , struct dlm_lksb *lksb , uint32_t flags , void const   *name ,
                  unsigned int namelen , uint32_t parent , void *bastarg , void (*bastaddr)(void *bastarg ) ,
                  void *range ) ;
#line 103
int dlm_unlock_wait(uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ) ;
#line 115
int dlm_get_fd(void) ;
#line 116
int dlm_dispatch(int fd ) ;
#line 138
dlm_lshandle_t dlm_create_lockspace(char const   *name , mode_t mode ) ;
#line 139
int dlm_release_lockspace(char const   *name , dlm_lshandle_t ls , int force ) ;
#line 141
dlm_lshandle_t dlm_open_lockspace(char const   *name ) ;
#line 142
int dlm_close_lockspace(dlm_lshandle_t ls ) ;
#line 143
int dlm_ls_get_fd(dlm_lshandle_t lockspace ) ;
#line 144
dlm_lshandle_t dlm_new_lockspace(char const   *name , mode_t mode , uint32_t flags ) ;
#line 160
int dlm_ls_lock(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                void const   *name , unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
                void *astarg , void (*bastaddr)(void *astarg ) , void *range ) ;
#line 172
int dlm_ls_lockx(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                 void const   *name , unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
                 void *astarg , void (*bastaddr)(void *astarg ) , uint64_t *xid ,
                 uint64_t *timeout ) ;
#line 185
int dlm_ls_unlock(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ,
                  void *astarg ) ;
#line 191
int dlm_ls_lock_wait(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                     void const   *name , unsigned int namelen , uint32_t parent ,
                     void *bastarg , void (*bastaddr)(void *bastarg ) , void *range ) ;
#line 202
int dlm_ls_unlock_wait(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ) ;
#line 207
int dlm_ls_deadlock_cancel(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags ) ;
#line 211
int dlm_ls_purge(dlm_lshandle_t ls , int nodeid , int pid ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static struct dlm_ls_info *default_ls  =    (struct dlm_ls_info *)((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int control_fd  =    -1;
#line 109 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static struct dlm_device_version kernel_version  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int kernel_version_detected  =    0;
#line 113
static int release_lockspace(uint32_t minor , uint32_t flags ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void ls_dev_name(char const   *lsname , char *devname , int devlen ) 
{ 


  {
  {
#line 118
  snprintf((char */* __restrict  */)devname, (size_t )devlen, (char const   */* __restrict  */)"/dev/misc/dlm_%s",
           lsname);
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void dummy_ast_routine(void *arg ) 
{ 


  {
#line 123
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_pthread_cleanup(struct dlm_ls_info *lsinfo ) 
{ 


  {
  {
#line 273
  close(lsinfo->fd);
#line 274
  free((void *)lsinfo);
  }
#line 275
  return (0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void set_version_v5(struct dlm_write_request_v5 *req ) 
{ 


  {
#line 282
  req->version[0] = kernel_version.version[0];
#line 283
  req->version[1] = kernel_version.version[1];
#line 284
  req->version[2] = kernel_version.version[2];
#line 285
  if (sizeof(long ) == sizeof(long long )) {
#line 286
    req->is64bit = (__u8 )1;
  } else {
#line 288
    req->is64bit = (__u8 )0;
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void set_version_v6(struct dlm_write_request *req ) 
{ 


  {
#line 293
  req->version[0] = kernel_version.version[0];
#line 294
  req->version[1] = kernel_version.version[1];
#line 295
  req->version[2] = kernel_version.version[2];
#line 296
  if (sizeof(long ) == sizeof(long long )) {
#line 297
    req->is64bit = (__u8 )1;
  } else {
#line 299
    req->is64bit = (__u8 )0;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int open_default_lockspace(void) 
{ 
  dlm_lshandle_t ls ;

  {
#line 304
  if (! default_ls) {
    {
#line 312
    ls = dlm_open_lockspace("default");
    }
#line 313
    if (! ls) {
      {
#line 314
      ls = dlm_create_lockspace("default", (mode_t )384);
      }
    }
#line 315
    if (! ls) {
#line 316
      return (-1);
    }
#line 318
    default_ls = (struct dlm_ls_info *)ls;
  }
#line 320
  return (0);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void detect_kernel_version(void) 
{ 
  struct dlm_device_version v ;
  int rv ;
  ssize_t tmp ;

  {
  {
#line 328
  tmp = read(control_fd, (void *)(& v), sizeof(struct dlm_device_version ));
#line 328
  rv = (int )tmp;
  }
#line 329
  if (rv < 0) {
#line 330
    kernel_version.version[0] = (__u32 )5;
#line 331
    kernel_version.version[1] = (__u32 )0;
#line 332
    kernel_version.version[2] = (__u32 )0;
  } else {
#line 334
    kernel_version.version[0] = v.version[0];
#line 335
    kernel_version.version[1] = v.version[1];
#line 336
    kernel_version.version[2] = v.version[2];
  }
#line 339
  kernel_version_detected = 1;
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int find_control_minor(int *minor ) 
{ 
  FILE *f ;
  char name[256] ;
  int found ;
  int m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 346
  found = 0;
#line 346
  m = 0;
#line 348
  f = fopen((char const   */* __restrict  */)"/proc/misc", (char const   */* __restrict  */)"r");
  }
#line 349
  if (! f) {
#line 350
    return (-1);
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 352
    tmp___1 = feof(f);
    }
#line 352
    if (tmp___1) {
#line 352
      goto while_break;
    }
    {
#line 353
    tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %s",
                 & m, name);
    }
#line 353
    if (tmp != 2) {
#line 354
      goto while_continue;
    }
    {
#line 355
    tmp___0 = strcmp((char const   *)(name), "dlm-control");
    }
#line 355
    if (tmp___0) {
#line 356
      goto while_continue;
    }
#line 357
    found = 1;
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  fclose(f);
  }
#line 362
  if (found) {
#line 363
    *minor = m;
#line 364
    return (0);
  }
#line 366
  return (-1);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int open_control_device(void) 
{ 
  struct stat st ;
  int i ;
  int rv ;
  int minor ;
  int found ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 372
  found = 0;
#line 374
  if (control_fd > -1) {
#line 375
    goto out;
  }
  {
#line 377
  rv = find_control_minor(& minor);
  }
#line 378
  if (rv < 0) {
#line 379
    return (-1);
  }
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < 10)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp = stat((char const   */* __restrict  */)"/dev/misc/dlm-control", (struct stat */* __restrict  */)(& st));
    }
#line 384
    if (tmp == 0) {
      {
#line 384
      tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 384
      if (tmp___0 == (unsigned int )minor) {
#line 386
        found = 1;
#line 387
        goto while_break;
      }
    }
    {
#line 389
    sleep(1U);
    }
#line 390
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (! found) {
#line 394
    return (-1);
  }
  {
#line 396
  control_fd = open("/dev/misc/dlm-control", 2);
  }
#line 397
  if (control_fd == -1) {
#line 398
    return (-1);
  }
  out: 
  {
#line 401
  fcntl(control_fd, 2, 1);
  }
#line 403
  if (! kernel_version_detected) {
    {
#line 404
    detect_kernel_version();
    }
  }
#line 405
  return (0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int find_udev_device(char const   *lockspace , int minor , char *udev_path ) 
{ 
  char bname[4096] ;
  char tmp_path[4096] ;
  DIR *d ;
  struct dirent *de ;
  struct stat st ;
  size_t basename_len ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 421
  ls_dev_name(lockspace, udev_path, 4096);
#line 422
  snprintf((char */* __restrict  */)(bname), (size_t )4096, (char const   */* __restrict  */)"dlm_%s",
           lockspace);
#line 423
  basename_len = strlen((char const   *)(bname));
#line 425
  i = 0;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i < 10)) {
#line 425
      goto while_break;
    }
    {
#line 429
    tmp = stat((char const   */* __restrict  */)udev_path, (struct stat */* __restrict  */)(& st));
    }
#line 429
    if (tmp == 0) {
      {
#line 429
      tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 429
      if (tmp___0 == (unsigned int )minor) {
#line 430
        return (0);
      }
    }
#line 432
    if (basename_len < 19UL) {
      {
#line 433
      sleep(1U);
      }
#line 434
      goto __Cont;
    }
    {
#line 439
    d = opendir("/dev/misc/");
    }
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 440
      de = readdir(d);
      }
#line 440
      if (! de) {
#line 440
        goto while_break___0;
      }
#line 441
      if ((int )de->d_name[0] == 46) {
#line 442
        goto while_continue___0;
      }
      {
#line 443
      tmp___1 = strlen((char const   *)(de->d_name));
      }
#line 443
      if (tmp___1 < 19UL) {
#line 444
        goto while_continue___0;
      }
      {
#line 445
      tmp___2 = strncmp((char const   *)(de->d_name), (char const   *)(bname), (size_t )19);
      }
#line 445
      if (tmp___2) {
#line 446
        goto while_continue___0;
      }
      {
#line 447
      snprintf((char */* __restrict  */)(tmp_path), (size_t )4096, (char const   */* __restrict  */)"/dev/misc/%s",
               de->d_name);
#line 449
      tmp___3 = stat((char const   */* __restrict  */)(tmp_path), (struct stat */* __restrict  */)(& st));
      }
#line 449
      if (tmp___3) {
#line 450
        goto while_continue___0;
      }
      {
#line 451
      tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 451
      if (tmp___4 != (unsigned int )minor) {
#line 452
        goto while_continue___0;
      }
      {
#line 455
      strncpy((char */* __restrict  */)udev_path, (char const   */* __restrict  */)(tmp_path),
              (size_t )4096);
#line 456
      closedir(d);
      }
#line 457
      return (0);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 459
    closedir(d);
#line 460
    sleep(1U);
    }
    __Cont: /* CIL Label */ 
#line 425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (-1);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch_v5(int fd ) 
{ 
  char resultbuf[sizeof(struct dlm_lock_result_v5 ) + 32UL] ;
  struct dlm_lock_result_v5 *result ;
  char *fullresult ;
  int status ;
  void (*astaddr)(void *astarg ) ;
  ssize_t tmp ;
  int newstat ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 474
  result = (struct dlm_lock_result_v5 *)(resultbuf);
#line 475
  fullresult = (char *)((void *)0);
#line 479
  tmp = read(fd, (void *)result, sizeof(resultbuf));
#line 479
  status = (int )tmp;
  }
#line 480
  if (status <= 0) {
#line 481
    return (-1);
  }
#line 485
  if (result->length != (__u32 )status) {
    {
#line 488
    tmp___0 = malloc((size_t )result->length);
#line 488
    fullresult = (char *)tmp___0;
    }
#line 489
    if (! fullresult) {
#line 490
      return (-1);
    }
    {
#line 492
    tmp___1 = read(fd, (void *)((struct dlm_lock_result_v5 *)fullresult), (size_t )result->length);
#line 492
    newstat = (int )tmp___1;
    }
#line 499
    if ((__u32 )newstat == result->length) {
#line 500
      result = (struct dlm_lock_result_v5 *)fullresult;
    }
  } else {
#line 502
    fullresult = resultbuf;
  }
  {
#line 507
  memcpy((void */* __restrict  */)result->user_lksb, (void const   */* __restrict  */)(& result->lksb),
         sizeof(struct dlm_lksb ) - sizeof(char *));
#line 512
  (result->user_lksb)->sb_status = - (result->user_lksb)->sb_status;
  }
#line 515
  if (result->lvb_offset) {
    {
#line 516
    memcpy((void */* __restrict  */)(result->user_lksb)->sb_lvbptr, (void const   */* __restrict  */)(fullresult + result->lvb_offset),
           (size_t )32);
    }
  }
#line 520
  if (result->user_astaddr) {
    {
#line 521
    astaddr = (void (*)(void *astarg ))result->user_astaddr;
#line 522
    (*astaddr)(result->user_astparam);
    }
  }
#line 525
  if ((unsigned long )fullresult != (unsigned long )(resultbuf)) {
    {
#line 526
    free((void *)fullresult);
    }
  }
#line 528
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch_v6(int fd ) 
{ 
  char resultbuf[sizeof(struct dlm_lock_result ) + 32UL] ;
  struct dlm_lock_result *result ;
  int status ;
  void (*astaddr)(void *astarg ) ;
  ssize_t tmp ;

  {
  {
#line 534
  result = (struct dlm_lock_result *)(resultbuf);
#line 538
  tmp = read(fd, (void *)result, sizeof(resultbuf));
#line 538
  status = (int )tmp;
  }
#line 539
  if (status <= 0) {
#line 540
    return (-1);
  }
  {
#line 543
  memcpy((void */* __restrict  */)result->user_lksb, (void const   */* __restrict  */)(& result->lksb),
         sizeof(struct dlm_lksb ) - sizeof(char *));
  }
#line 547
  if (result->lvb_offset) {
    {
#line 548
    memcpy((void */* __restrict  */)(result->user_lksb)->sb_lvbptr, (void const   */* __restrict  */)((char *)result + result->lvb_offset),
           (size_t )32);
    }
  }
#line 551
  (result->user_lksb)->sb_status = - (result->user_lksb)->sb_status;
#line 553
  if (result->user_astaddr) {
    {
#line 554
    astaddr = (void (*)(void *astarg ))result->user_astaddr;
#line 555
    (*astaddr)(result->user_astparam);
    }
  }
#line 558
  return (0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 563
  if (kernel_version.version[0] == 5U) {
    {
#line 564
    tmp = do_dlm_dispatch_v5(fd);
    }
#line 564
    return (tmp);
  } else {
    {
#line 566
    tmp___0 = do_dlm_dispatch_v6(fd);
    }
#line 566
    return (tmp___0);
  }
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int sync_write_v5(struct dlm_ls_info *lsinfo , struct dlm_write_request_v5 *req ,
                         int len ) 
{ 
  int status ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 661
  req->i.lock.castaddr = (void *)(& dummy_ast_routine);
#line 662
  req->i.lock.castparam = (void *)0;
#line 664
  tmp = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 664
  status = (int )tmp;
  }
#line 665
  if (status < 0) {
#line 666
    return (-1);
  }
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! ((req->i.lock.lksb)->sb_status == 65539)) {
#line 668
      goto while_break;
    }
    {
#line 669
    do_dlm_dispatch_v5(lsinfo->fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  tmp___0 = __errno_location();
#line 672
  *tmp___0 = (req->i.lock.lksb)->sb_status;
#line 673
  tmp___1 = __errno_location();
  }
#line 673
  if (*tmp___1) {
    {
#line 673
    tmp___2 = __errno_location();
    }
#line 673
    if (*tmp___2 != 65538) {
#line 674
      return (-1);
    }
  }
#line 675
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int sync_write_v6(struct dlm_ls_info *lsinfo , struct dlm_write_request *req ,
                         int len ) 
{ 
  int status ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 683
  req->i.lock.castaddr = (void *)(& dummy_ast_routine);
#line 684
  req->i.lock.castparam = (void *)0;
#line 686
  tmp = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 686
  status = (int )tmp;
  }
#line 687
  if (status < 0) {
#line 688
    return (-1);
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! ((req->i.lock.lksb)->sb_status == 65539)) {
#line 690
      goto while_break;
    }
    {
#line 691
    do_dlm_dispatch_v6(lsinfo->fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  tmp___0 = __errno_location();
#line 694
  *tmp___0 = (req->i.lock.lksb)->sb_status;
#line 695
  tmp___1 = __errno_location();
  }
#line 695
  if (*tmp___1) {
    {
#line 695
    tmp___2 = __errno_location();
    }
#line 695
    if (*tmp___2 != 65538) {
#line 696
      return (-1);
    }
  }
#line 697
  return (0);
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock_v5(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb ,
                      uint32_t flags , void const   *name , unsigned int namelen ,
                      uint32_t parent , void (*astaddr)(void *astarg ) , void *astarg ,
                      void (*bastaddr)(void *astarg ) ) 
{ 
  char parambuf[sizeof(struct dlm_write_request_v5 ) + 64UL] ;
  struct dlm_write_request_v5 *req ;
  struct dlm_ls_info *lsinfo ;
  int status ;
  int len ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 720
  req = (struct dlm_write_request_v5 *)(parambuf);
#line 721
  lsinfo = (struct dlm_ls_info *)ls;
#line 725
  memset((void *)req, 0, sizeof(*req));
#line 726
  set_version_v5(req);
#line 728
  req->cmd = (__u8 )1;
#line 729
  req->i.lock.mode = (__u8 )mode;
#line 730
  req->i.lock.flags = (__u16 )(flags & 2147483647U);
#line 731
  req->i.lock.lkid = lksb->sb_lkid;
#line 732
  req->i.lock.parent = parent;
#line 733
  req->i.lock.lksb = lksb;
#line 734
  req->i.lock.castaddr = (void *)astaddr;
#line 735
  req->i.lock.bastaddr = (void *)bastaddr;
#line 736
  req->i.lock.castparam = astarg;
#line 737
  req->i.lock.bastparam = astarg;
  }
#line 739
  if (flags & 4U) {
#line 740
    req->i.lock.namelen = (__u8 )0;
  } else {
#line 742
    if (namelen > 64U) {
      {
#line 743
      tmp = __errno_location();
#line 743
      *tmp = 22;
      }
#line 744
      return (-1);
    }
    {
#line 746
    req->i.lock.namelen = (__u8 )namelen;
#line 747
    memcpy((void */* __restrict  */)(req->i.lock.name), (void const   */* __restrict  */)name,
           (size_t )namelen);
    }
  }
#line 750
  if (flags & 8U) {
    {
#line 751
    memcpy((void */* __restrict  */)(req->i.lock.lvb), (void const   */* __restrict  */)lksb->sb_lvbptr,
           (size_t )32);
    }
  }
#line 754
  len = (int )(sizeof(struct dlm_write_request_v5 ) + (unsigned long )namelen);
#line 755
  lksb->sb_status = 65539;
#line 757
  if (flags & 2147483648U) {
    {
#line 758
    status = sync_write_v5(lsinfo, req, len);
    }
  } else {
    {
#line 760
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 760
    status = (int )tmp___0;
    }
  }
#line 762
  if (status < 0) {
#line 763
    return (-1);
  }
#line 769
  if (status > 0) {
#line 770
    lksb->sb_lkid = (__u32 )status;
  }
#line 771
  return (0);
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock_v6(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb ,
                      uint32_t flags , void const   *name , unsigned int namelen ,
                      uint32_t parent , void (*astaddr)(void *astarg ) , void *astarg ,
                      void (*bastaddr)(void *astarg ) , uint64_t *xid , uint64_t *timeout ) 
{ 
  char parambuf[sizeof(struct dlm_write_request ) + 64UL] ;
  struct dlm_write_request *req ;
  struct dlm_ls_info *lsinfo ;
  int status ;
  int len ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 788
  req = (struct dlm_write_request *)(parambuf);
#line 789
  lsinfo = (struct dlm_ls_info *)ls;
#line 793
  memset((void *)req, 0, sizeof(*req));
#line 794
  set_version_v6(req);
#line 796
  req->cmd = (__u8 )1;
#line 797
  req->i.lock.mode = (__u8 )mode;
#line 798
  req->i.lock.flags = flags & 2147483647U;
#line 799
  req->i.lock.lkid = lksb->sb_lkid;
#line 800
  req->i.lock.parent = parent;
#line 801
  req->i.lock.lksb = lksb;
#line 802
  req->i.lock.castaddr = (void *)astaddr;
#line 803
  req->i.lock.bastaddr = (void *)bastaddr;
#line 804
  req->i.lock.castparam = astarg;
#line 805
  req->i.lock.bastparam = astarg;
  }
#line 807
  if (xid) {
#line 808
    req->i.lock.xid = (__u64 )*xid;
  }
#line 809
  if (timeout) {
#line 810
    req->i.lock.timeout = (__u64 )*timeout;
  }
#line 812
  if (flags & 4U) {
#line 813
    req->i.lock.namelen = (__u8 )0;
  } else {
#line 815
    if (namelen > 64U) {
      {
#line 816
      tmp = __errno_location();
#line 816
      *tmp = 22;
      }
#line 817
      return (-1);
    }
    {
#line 819
    req->i.lock.namelen = (__u8 )namelen;
#line 820
    memcpy((void */* __restrict  */)(req->i.lock.name), (void const   */* __restrict  */)name,
           (size_t )namelen);
    }
  }
#line 823
  if (flags & 8U) {
    {
#line 824
    memcpy((void */* __restrict  */)(req->i.lock.lvb), (void const   */* __restrict  */)lksb->sb_lvbptr,
           (size_t )32);
    }
  }
#line 827
  len = (int )(sizeof(struct dlm_write_request ) + (unsigned long )namelen);
#line 828
  lksb->sb_status = 65539;
#line 830
  if (flags & 2147483648U) {
    {
#line 831
    status = sync_write_v6(lsinfo, req, len);
    }
  } else {
    {
#line 833
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 833
    status = (int )tmp___0;
    }
  }
#line 835
  if (status < 0) {
#line 836
    return (-1);
  }
#line 842
  if (status > 0) {
#line 843
    lksb->sb_lkid = (__u32 )status;
  }
#line 844
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                   void const   *name , unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
                   void *astarg , void (*bastaddr)(void *astarg ) , void *range ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 860
  if (range) {
    {
#line 861
    tmp = __errno_location();
#line 861
    *tmp = 38;
    }
#line 862
    return (-1);
  }
#line 865
  if (flags & 8U) {
#line 865
    if (! lksb->sb_lvbptr) {
      {
#line 866
      tmp___0 = __errno_location();
#line 866
      *tmp___0 = 22;
      }
#line 867
      return (-1);
    }
  }
#line 870
  if (kernel_version.version[0] == 5U) {
    {
#line 871
    tmp___1 = ls_lock_v5(ls, mode, lksb, flags, name, namelen, parent, astaddr, astarg,
                         bastaddr);
    }
#line 871
    return (tmp___1);
  } else {
    {
#line 874
    tmp___2 = ls_lock_v6(ls, mode, lksb, flags, name, namelen, parent, astaddr, astarg,
                         bastaddr, (uint64_t *)((void *)0), (uint64_t *)((void *)0));
    }
#line 874
    return (tmp___2);
  }
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_lockx(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                 void const   *name , unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
                 void *astarg , void (*bastaddr)(void *astarg ) , uint64_t *xid ,
                 uint64_t *timeout ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 894
  if (kernel_version.version[0] < 6U) {
    {
#line 895
    tmp = __errno_location();
#line 895
    *tmp = 38;
    }
#line 896
    return (-1);
  }
  {
#line 899
  tmp___0 = ls_lock_v6(ls, mode, lksb, flags, name, namelen, parent, astaddr, astarg,
                       bastaddr, xid, timeout);
  }
#line 899
  return (tmp___0);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_lock(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                void const   *name , unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
                void *astarg , void (*bastaddr)(void *astarg ) , void *range ) 
{ 
  int tmp ;

  {
  {
#line 918
  tmp = ls_lock(ls, mode, lksb, flags, name, namelen, parent, astaddr, astarg, bastaddr,
                range);
  }
#line 918
  return (tmp);
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_lock_wait(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb , uint32_t flags ,
                     void const   *name , unsigned int namelen , uint32_t parent ,
                     void *bastarg , void (*bastaddr)(void *bastarg ) , void *range ) 
{ 
  int tmp ;

  {
  {
#line 936
  tmp = ls_lock(ls, mode, lksb, flags | 2147483648U, name, namelen, parent, (void (*)(void *astarg ))((void *)0),
                bastarg, bastaddr, range);
  }
#line 936
  return (tmp);
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_lock(uint32_t mode , struct dlm_lksb *lksb , uint32_t flags , void const   *name ,
             unsigned int namelen , uint32_t parent , void (*astaddr)(void *astarg ) ,
             void *astarg , void (*bastaddr)(void *astarg ) , void *range ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 954
  tmp = open_default_lockspace();
  }
#line 954
  if (tmp) {
#line 955
    return (-1);
  }
  {
#line 957
  tmp___0 = ls_lock((dlm_lshandle_t )default_ls, mode, lksb, flags, name, namelen,
                    parent, astaddr, astarg, bastaddr, range);
  }
#line 957
  return (tmp___0);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_lock_wait(uint32_t mode , struct dlm_lksb *lksb , uint32_t flags , void const   *name ,
                  unsigned int namelen , uint32_t parent , void *bastarg , void (*bastaddr)(void *bastarg ) ,
                  void *range ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 974
  tmp = open_default_lockspace();
  }
#line 974
  if (tmp) {
#line 975
    return (-1);
  }
  {
#line 977
  tmp___0 = ls_lock((dlm_lshandle_t )default_ls, mode, lksb, flags | 2147483648U,
                    name, namelen, parent, (void (*)(void *astarg ))((void *)0), bastarg,
                    bastaddr, range);
  }
#line 977
  return (tmp___0);
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_unlock_v5(struct dlm_ls_info *lsinfo , uint32_t lkid , uint32_t flags ,
                        struct dlm_lksb *lksb , void *astarg ) 
{ 
  struct dlm_write_request_v5 req ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 992
  set_version_v5(& req);
#line 993
  req.cmd = (__u8 )2;
#line 994
  req.i.lock.lkid = lkid;
#line 995
  req.i.lock.flags = (__u16 )(flags & 2147483647U);
#line 996
  req.i.lock.lksb = lksb;
#line 997
  req.i.lock.castparam = astarg;
#line 999
  req.i.lock.castaddr = (void *)0;
#line 1000
  lksb->sb_status = 65539;
  }
#line 1002
  if (flags & 2147483648U) {
    {
#line 1003
    tmp = sync_write_v5(lsinfo, & req, (int )sizeof(req));
    }
#line 1003
    return (tmp);
  } else {
    {
#line 1005
    tmp___0 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
    }
#line 1005
    return ((int )tmp___0);
  }
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_unlock_v6(struct dlm_ls_info *lsinfo , uint32_t lkid , uint32_t flags ,
                        struct dlm_lksb *lksb , void *astarg ) 
{ 
  struct dlm_write_request req ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1013
  set_version_v6(& req);
#line 1014
  req.cmd = (__u8 )2;
#line 1015
  req.i.lock.lkid = lkid;
#line 1016
  req.i.lock.flags = flags & 2147483647U;
#line 1017
  req.i.lock.lksb = lksb;
#line 1018
  req.i.lock.namelen = (__u8 )0;
#line 1019
  req.i.lock.castparam = astarg;
#line 1021
  req.i.lock.castaddr = (void *)0;
#line 1022
  lksb->sb_status = 65539;
  }
#line 1024
  if (flags & 2147483648U) {
    {
#line 1025
    tmp = sync_write_v6(lsinfo, & req, (int )sizeof(req));
    }
#line 1025
    return (tmp);
  } else {
    {
#line 1027
    tmp___0 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
    }
#line 1027
    return ((int )tmp___0);
  }
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_unlock(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ,
                  void *astarg ) 
{ 
  struct dlm_ls_info *lsinfo ;
  int status ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1033
  lsinfo = (struct dlm_ls_info *)ls;
#line 1036
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
    {
#line 1037
    tmp = __errno_location();
#line 1037
    *tmp = 107;
    }
#line 1038
    return (-1);
  }
#line 1041
  if (! lkid) {
    {
#line 1042
    tmp___0 = __errno_location();
#line 1042
    *tmp___0 = 22;
    }
#line 1043
    return (-1);
  }
#line 1046
  if (kernel_version.version[0] == 5U) {
    {
#line 1047
    status = ls_unlock_v5(lsinfo, lkid, flags, lksb, astarg);
    }
  } else {
    {
#line 1049
    status = ls_unlock_v6(lsinfo, lkid, flags, lksb, astarg);
    }
  }
#line 1051
  if (status < 0) {
#line 1052
    return (-1);
  }
#line 1053
  return (0);
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_unlock_wait(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ) 
{ 
  int tmp ;

  {
  {
#line 1059
  tmp = dlm_ls_unlock(ls, lkid, flags | 2147483648U, lksb, (void *)0);
  }
#line 1059
  return (tmp);
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_unlock_wait(uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb ) 
{ 
  int tmp ;

  {
  {
#line 1064
  tmp = dlm_ls_unlock_wait((dlm_lshandle_t )default_ls, lkid, flags | 2147483648U,
                           lksb);
  }
#line 1064
  return (tmp);
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_unlock(uint32_t lkid , uint32_t flags , struct dlm_lksb *lksb , void *astarg ) 
{ 
  int tmp ;

  {
  {
#line 1070
  tmp = dlm_ls_unlock((dlm_lshandle_t )default_ls, lkid, flags, lksb, astarg);
  }
#line 1070
  return (tmp);
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_deadlock_cancel(dlm_lshandle_t ls , uint32_t lkid , uint32_t flags ) 
{ 
  struct dlm_ls_info *lsinfo ;
  struct dlm_write_request req ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1075
  lsinfo = (struct dlm_ls_info *)ls;
#line 1078
  if (kernel_version.version[0] < 6U) {
    {
#line 1079
    tmp = __errno_location();
#line 1079
    *tmp = 38;
    }
#line 1080
    return (-1);
  }
#line 1083
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
    {
#line 1084
    tmp___0 = __errno_location();
#line 1084
    *tmp___0 = 107;
    }
#line 1085
    return (-1);
  }
#line 1088
  if (! lkid) {
    {
#line 1089
    tmp___1 = __errno_location();
#line 1089
    *tmp___1 = 22;
    }
#line 1090
    return (-1);
  }
  {
#line 1093
  set_version_v6(& req);
#line 1094
  req.cmd = (__u8 )7;
#line 1095
  req.i.lock.lkid = lkid;
#line 1096
  req.i.lock.flags = flags;
#line 1098
  tmp___2 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
  }
#line 1098
  return ((int )tmp___2);
}
}
#line 1107 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_purge(dlm_lshandle_t ls , int nodeid , int pid ) 
{ 
  struct dlm_write_request req ;
  struct dlm_ls_info *lsinfo ;
  int status ;
  int *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 1110
  lsinfo = (struct dlm_ls_info *)ls;
#line 1113
  if (kernel_version.version[0] < 6U) {
    {
#line 1114
    tmp = __errno_location();
#line 1114
    *tmp = 38;
    }
#line 1115
    return (-1);
  }
#line 1118
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
    {
#line 1119
    tmp___0 = __errno_location();
#line 1119
    *tmp___0 = 107;
    }
#line 1120
    return (-1);
  }
  {
#line 1123
  set_version_v6(& req);
#line 1124
  req.cmd = (__u8 )6;
#line 1125
  req.i.purge.nodeid = (__u32 )nodeid;
#line 1126
  req.i.purge.pid = (__u32 )pid;
#line 1128
  tmp___1 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
#line 1128
  status = (int )tmp___1;
  }
#line 1130
  if (status < 0) {
#line 1131
    return (-1);
  }
#line 1132
  return (0);
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_get_fd(void) 
{ 
  int tmp ;

  {
#line 1142
  if (default_ls) {
#line 1144
    return (default_ls->fd);
  } else {
    {
#line 1148
    tmp = open_default_lockspace();
    }
#line 1148
    if (tmp) {
#line 1149
      return (-1);
    } else {
#line 1151
      return (default_ls->fd);
    }
  }
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_dispatch(int fd ) 
{ 
  int status ;
  int fdflags ;
  int *tmp ;

  {
  {
#line 1160
  fdflags = fcntl(fd, 3, 0);
#line 1161
  fcntl(fd, 4, fdflags | 2048);
  }
  {
#line 1162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1164
    status = do_dlm_dispatch(fd);
    }
#line 1162
    if (! (status == 0)) {
#line 1162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1168
  if (status < 0) {
    {
#line 1168
    tmp = __errno_location();
    }
#line 1168
    if (*tmp == 11) {
#line 1169
      status = 0;
    }
  }
  {
#line 1171
  fcntl(fd, 4, fdflags);
  }
#line 1172
  return (status);
}
}
#line 1176 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_get_fd(dlm_lshandle_t lockspace ) 
{ 
  struct dlm_ls_info *lsinfo ;

  {
#line 1178
  lsinfo = (struct dlm_ls_info *)lockspace;
#line 1180
  return (lsinfo->fd);
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int create_lockspace_v5(char const   *name , uint32_t flags ) 
{ 
  char reqbuf[sizeof(struct dlm_write_request_v5 ) + 64UL] ;
  struct dlm_write_request_v5 *req ;
  int namelen ;
  size_t tmp ;
  int minor ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1241
  req = (struct dlm_write_request_v5 *)(reqbuf);
#line 1242
  tmp = strlen(name);
#line 1242
  namelen = (int )tmp;
#line 1245
  memset((void *)(reqbuf), 0, sizeof(reqbuf));
#line 1246
  set_version_v5(req);
#line 1248
  req->cmd = (__u8 )4;
#line 1249
  req->i.lspace.flags = flags;
  }
#line 1251
  if (namelen > 64) {
    {
#line 1252
    tmp___0 = __errno_location();
#line 1252
    *tmp___0 = 22;
    }
#line 1253
    return (-1);
  }
  {
#line 1255
  memcpy((void */* __restrict  */)(req->i.lspace.name), (void const   */* __restrict  */)name,
         (size_t )namelen);
#line 1257
  tmp___1 = write(control_fd, (void const   *)req, sizeof(*req) + (unsigned long )namelen);
#line 1257
  minor = (int )tmp___1;
  }
#line 1259
  return (minor);
}
}
#line 1262 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int create_lockspace_v6(char const   *name , uint32_t flags ) 
{ 
  char reqbuf[sizeof(struct dlm_write_request ) + 64UL] ;
  struct dlm_write_request *req ;
  int namelen ;
  size_t tmp ;
  int minor ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1265
  req = (struct dlm_write_request *)(reqbuf);
#line 1266
  tmp = strlen(name);
#line 1266
  namelen = (int )tmp;
#line 1269
  memset((void *)(reqbuf), 0, sizeof(reqbuf));
#line 1270
  set_version_v6(req);
#line 1272
  req->cmd = (__u8 )4;
#line 1273
  req->i.lspace.flags = flags;
  }
#line 1275
  if (namelen > 64) {
    {
#line 1276
    tmp___0 = __errno_location();
#line 1276
    *tmp___0 = 22;
    }
#line 1277
    return (-1);
  }
  {
#line 1279
  memcpy((void */* __restrict  */)(req->i.lspace.name), (void const   */* __restrict  */)name,
         (size_t )namelen);
#line 1281
  tmp___1 = write(control_fd, (void const   *)req, sizeof(*req) + (unsigned long )namelen);
#line 1281
  minor = (int )tmp___1;
  }
#line 1283
  return (minor);
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static dlm_lshandle_t create_lockspace(char const   *name , mode_t mode , uint32_t flags ) 
{ 
  char dev_path[4096] ;
  char udev_path[4096] ;
  struct dlm_ls_info *newls ;
  int error ;
  int saved_errno ;
  int minor ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1295
  tmp = open_control_device();
  }
#line 1295
  if (tmp) {
#line 1296
    return ((void *)0);
  }
  {
#line 1298
  tmp___0 = malloc(sizeof(struct dlm_ls_info ));
#line 1298
  newls = (struct dlm_ls_info *)tmp___0;
  }
#line 1299
  if (! newls) {
#line 1300
    return ((void *)0);
  }
  {
#line 1302
  ls_dev_name(name, dev_path, (int )sizeof(dev_path));
  }
#line 1304
  if (kernel_version.version[0] == 5U) {
    {
#line 1305
    minor = create_lockspace_v5(name, flags);
    }
  } else {
    {
#line 1307
    minor = create_lockspace_v6(name, flags);
    }
  }
#line 1309
  if (minor < 0) {
#line 1310
    goto fail;
  }
  {
#line 1315
  error = find_udev_device(name, minor, udev_path);
  }
#line 1316
  if (error) {
#line 1317
    goto fail;
  }
  {
#line 1322
  tmp___1 = strcmp((char const   *)(dev_path), (char const   *)(udev_path));
  }
#line 1322
  if (tmp___1) {
    {
#line 1323
    error = symlink((char const   *)(udev_path), (char const   *)(dev_path));
    }
#line 1324
    if (error) {
#line 1325
      goto fail;
    }
  }
  {
#line 1330
  newls->fd = open((char const   *)(dev_path), 2);
  }
#line 1331
  if (newls->fd == -1) {
#line 1332
    goto fail;
  }
#line 1333
  if (mode) {
    {
#line 1334
    fchmod(newls->fd, mode);
    }
  }
  {
#line 1335
  newls->tid = 0;
#line 1336
  fcntl(newls->fd, 2, 1);
  }
#line 1337
  return ((dlm_lshandle_t )newls);
  fail: 
  {
#line 1340
  tmp___2 = __errno_location();
#line 1340
  saved_errno = *tmp___2;
#line 1341
  free((void *)newls);
#line 1342
  tmp___3 = __errno_location();
#line 1342
  *tmp___3 = saved_errno;
  }
#line 1343
  return ((void *)0);
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
dlm_lshandle_t dlm_new_lockspace(char const   *name , mode_t mode , uint32_t flags ) 
{ 
  dlm_lshandle_t tmp ;

  {
  {
#line 1348
  tmp = create_lockspace(name, mode, flags);
  }
#line 1348
  return (tmp);
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
dlm_lshandle_t dlm_create_lockspace(char const   *name , mode_t mode ) 
{ 
  dlm_lshandle_t tmp ;

  {
  {
#line 1353
  tmp = create_lockspace(name, mode, (uint32_t )0);
  }
#line 1353
  return (tmp);
}
}
#line 1356 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace_v5(uint32_t minor , uint32_t flags ) 
{ 
  struct dlm_write_request_v5 req ;
  ssize_t tmp ;

  {
  {
#line 1360
  set_version_v5(& req);
#line 1361
  req.cmd = (__u8 )5;
#line 1362
  req.i.lspace.minor = minor;
#line 1363
  req.i.lspace.flags = flags;
#line 1365
  tmp = write(control_fd, (void const   *)(& req), sizeof(req));
  }
#line 1365
  return ((int )tmp);
}
}
#line 1368 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace_v6(uint32_t minor , uint32_t flags ) 
{ 
  struct dlm_write_request req ;
  ssize_t tmp ;

  {
  {
#line 1372
  set_version_v6(& req);
#line 1373
  req.cmd = (__u8 )5;
#line 1374
  req.i.lspace.minor = minor;
#line 1375
  req.i.lspace.flags = flags;
#line 1377
  tmp = write(control_fd, (void const   *)(& req), sizeof(req));
  }
#line 1377
  return ((int )tmp);
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace(uint32_t minor , uint32_t flags ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1382
  if (kernel_version.version[0] == 5U) {
    {
#line 1383
    tmp = release_lockspace_v5(minor, flags);
    }
#line 1383
    return (tmp);
  } else {
    {
#line 1385
    tmp___0 = release_lockspace_v6(minor, flags);
    }
#line 1385
    return (tmp___0);
  }
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_release_lockspace(char const   *name , dlm_lshandle_t ls , int force ) 
{ 
  char dev_path[4096] ;
  struct stat st ;
  struct dlm_ls_info *lsinfo ;
  uint32_t flags ;
  int fd ;
  int is_symlink ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 1392
  lsinfo = (struct dlm_ls_info *)ls;
#line 1393
  flags = (uint32_t )0;
#line 1394
  is_symlink = 0;
#line 1396
  ls_dev_name(name, dev_path, (int )sizeof(dev_path));
#line 1397
  tmp = lstat((char const   */* __restrict  */)(dev_path), (struct stat */* __restrict  */)(& st));
  }
#line 1397
  if (! tmp) {
#line 1397
    if ((st.st_mode & 61440U) == 40960U) {
#line 1398
      is_symlink = 1;
    }
  }
  {
#line 1401
  tmp___0 = fstat(lsinfo->fd, & st);
  }
#line 1401
  if (tmp___0) {
#line 1402
    return (-1);
  }
  {
#line 1405
  ls_pthread_cleanup(lsinfo);
#line 1407
  tmp___1 = open_control_device();
  }
#line 1407
  if (tmp___1) {
#line 1408
    return (-1);
  }
#line 1410
  if (force) {
#line 1411
    flags = (uint32_t )2;
  }
  {
#line 1413
  tmp___2 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 1413
  release_lockspace(tmp___2, flags);
  }
#line 1415
  if (! is_symlink) {
#line 1416
    return (0);
  }
  {
#line 1428
  fd = open((char const   *)(dev_path), 2);
  }
#line 1429
  if (fd < 0) {
    {
#line 1430
    unlink((char const   *)(dev_path));
    }
  } else {
    {
#line 1432
    close(fd);
    }
  }
#line 1434
  return (0);
}
}
#line 1441 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
dlm_lshandle_t dlm_open_lockspace(char const   *name ) 
{ 
  char dev_name[4096] ;
  struct dlm_ls_info *newls ;
  int saved_errno ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1448
  tmp = open_control_device();
  }
#line 1448
  if (tmp) {
#line 1449
    return ((void *)0);
  }
  {
#line 1451
  tmp___0 = malloc(sizeof(struct dlm_ls_info ));
#line 1451
  newls = (struct dlm_ls_info *)tmp___0;
  }
#line 1452
  if (! newls) {
#line 1453
    return ((void *)0);
  }
  {
#line 1455
  newls->tid = 0;
#line 1456
  ls_dev_name(name, dev_name, (int )sizeof(dev_name));
#line 1458
  newls->fd = open((char const   *)(dev_name), 2);
#line 1459
  tmp___1 = __errno_location();
#line 1459
  saved_errno = *tmp___1;
  }
#line 1461
  if (newls->fd == -1) {
    {
#line 1462
    free((void *)newls);
#line 1463
    tmp___2 = __errno_location();
#line 1463
    *tmp___2 = saved_errno;
    }
#line 1464
    return ((void *)0);
  }
  {
#line 1466
  fcntl(newls->fd, 2, 1);
  }
#line 1467
  return ((dlm_lshandle_t )newls);
}
}
#line 1470 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_close_lockspace(dlm_lshandle_t ls ) 
{ 
  struct dlm_ls_info *lsinfo ;

  {
  {
#line 1472
  lsinfo = (struct dlm_ls_info *)ls;
#line 1474
  ls_pthread_cleanup(lsinfo);
  }
#line 1475
  return (0);
}
}
#line 1478 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_kernel_version(uint32_t *major , uint32_t *minor , uint32_t *patch ) 
{ 
  int tmp ;

  {
  {
#line 1480
  tmp = open_control_device();
  }
#line 1480
  if (tmp) {
#line 1481
    return (-1);
  }
#line 1482
  *major = kernel_version.version[0];
#line 1483
  *minor = kernel_version.version[1];
#line 1484
  *patch = kernel_version.version[2];
#line 1485
  return (0);
}
}
#line 1488 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
void dlm_library_version(uint32_t *major , uint32_t *minor , uint32_t *patch ) 
{ 


  {
#line 1490
  *major = (uint32_t )6;
#line 1491
  *minor = (uint32_t )0;
#line 1492
  *patch = (uint32_t )1;
#line 1493
  return;
}
}
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 286
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 618 "/usr/include/pthread.h"
__inline extern void __attribute__((__gnu_inline__))  __pthread_cleanup_routine(struct __pthread_cleanup_frame *__frame ) 
{ 


  {
#line 621
  if (__frame->__do_it) {
    {
#line 622
    (*(__frame->__cancel_routine))(__frame->__cancel_arg);
    }
  }
#line 623
  return;
}
}
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.h"
int lock_resource(char const   *resource , int mode , int flags , int *lockid ) ;
#line 74
int unlock_resource(int lockid ) ;
#line 231
int dlm_pthread_init(void) ;
#line 232
int dlm_ls_pthread_init(dlm_lshandle_t ls ) ;
#line 233
int dlm_pthread_cleanup(void) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static struct dlm_ls_info___0 *default_ls___0  =    (struct dlm_ls_info___0 *)((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int control_fd___0  =    -1;
#line 109 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static struct dlm_device_version kernel_version___0  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int kernel_version_detected___0  =    0;
#line 113
static int release_lockspace___0(uint32_t minor , uint32_t flags ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void ls_dev_name___0(char const   *lsname , char *devname , int devlen ) 
{ 


  {
  {
#line 118
  snprintf((char */* __restrict  */)devname, (size_t )devlen, (char const   */* __restrict  */)"/dev/misc/dlm_%s",
           lsname);
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void dummy_ast_routine___0(void *arg ) 
{ 


  {
#line 123
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void sync_ast_routine(void *arg ) 
{ 
  struct lock_wait *lwait ;

  {
  {
#line 136
  lwait = (struct lock_wait *)arg;
#line 138
  pthread_mutex_lock(& lwait->mutex);
#line 139
  pthread_cond_signal(& lwait->cond);
#line 140
  pthread_mutex_unlock(& lwait->mutex);
  }
#line 141
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int lock_resource(char const   *resource , int mode , int flags , int *lockid ) 
{ 
  int status ;
  struct lock_wait lwait ;
  int tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 152
  if ((unsigned long )default_ls___0 == (unsigned long )((void *)0)) {
    {
#line 154
    tmp = dlm_pthread_init();
    }
#line 154
    if (tmp) {
#line 156
      return (-1);
    }
  }
#line 160
  if (! lockid) {
    {
#line 162
    tmp___0 = __errno_location();
#line 162
    *tmp___0 = 22;
    }
#line 163
    return (-1);
  }
#line 167
  if (flags & 4) {
#line 168
    lwait.lksb.sb_lkid = (__u32 )*lockid;
  }
  {
#line 170
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 171
  pthread_mutex_init(& lwait.mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 172
  pthread_mutex_lock(& lwait.mutex);
#line 174
  tmp___1 = strlen(resource);
#line 174
  status = dlm_lock((uint32_t )mode, & lwait.lksb, (uint32_t )flags, (void const   *)resource,
                    (unsigned int )tmp___1, (uint32_t )0, & sync_ast_routine, (void *)(& lwait),
                    (void (*)(void *astarg ))((void *)0), (void *)0);
  }
#line 184
  if (status) {
#line 185
    return (status);
  }
  {
#line 188
  pthread_cond_wait((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_mutex_t */* __restrict  */)(& lwait.mutex));
#line 189
  pthread_mutex_unlock(& lwait.mutex);
#line 191
  *lockid = (int )lwait.lksb.sb_lkid;
#line 193
  tmp___2 = __errno_location();
#line 193
  *tmp___2 = lwait.lksb.sb_status;
  }
#line 194
  if (lwait.lksb.sb_status) {
#line 195
    return (-1);
  } else {
#line 197
    return (0);
  }
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int unlock_resource(int lockid ) 
{ 
  int status ;
  struct lock_wait lwait ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 206
  if ((unsigned long )default_ls___0 == (unsigned long )((void *)0)) {
    {
#line 208
    tmp = __errno_location();
#line 208
    *tmp = -107;
    }
#line 209
    return (-1);
  }
  {
#line 212
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 213
  pthread_mutex_init(& lwait.mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 214
  pthread_mutex_lock(& lwait.mutex);
#line 216
  status = dlm_unlock((uint32_t )lockid, (uint32_t )0, & lwait.lksb, (void *)(& lwait));
  }
#line 218
  if (status) {
#line 219
    return (status);
  }
  {
#line 222
  pthread_cond_wait((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_mutex_t */* __restrict  */)(& lwait.mutex));
#line 223
  pthread_mutex_unlock(& lwait.mutex);
#line 225
  tmp___0 = __errno_location();
#line 225
  *tmp___0 = lwait.lksb.sb_status;
  }
#line 226
  if (lwait.lksb.sb_status != 65538) {
#line 227
    return (-1);
  } else {
#line 229
    return (0);
  }
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_pthread_cleanup___0(struct dlm_ls_info___0 *lsinfo ) 
{ 
  int status ;
  int fd ;

  {
#line 235
  status = 0;
#line 239
  fd = lsinfo->fd;
#line 240
  if (lsinfo->tid) {
    {
#line 242
    status = pthread_cancel(lsinfo->tid);
    }
#line 243
    if (! status) {
      {
#line 244
      pthread_join(lsinfo->tid, (void **)((void *)0));
      }
    }
  }
#line 246
  if (! status) {
    {
#line 248
    free((void *)lsinfo);
#line 249
    close(fd);
    }
  }
#line 252
  return (status);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_pthread_cleanup(void) 
{ 
  struct dlm_ls_info___0 *lsinfo ;
  int tmp ;

  {
#line 258
  lsinfo = default_ls___0;
#line 261
  if (! lsinfo) {
#line 262
    return (0);
  }
  {
#line 264
  default_ls___0 = (struct dlm_ls_info___0 *)((void *)0);
#line 266
  tmp = ls_pthread_cleanup___0(lsinfo);
  }
#line 266
  return (tmp);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void set_version_v5___0(struct dlm_write_request_v5 *req ) 
{ 


  {
#line 282
  req->version[0] = kernel_version___0.version[0];
#line 283
  req->version[1] = kernel_version___0.version[1];
#line 284
  req->version[2] = kernel_version___0.version[2];
#line 285
  if (sizeof(long ) == sizeof(long long )) {
#line 286
    req->is64bit = (__u8 )1;
  } else {
#line 288
    req->is64bit = (__u8 )0;
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void set_version_v6___0(struct dlm_write_request *req ) 
{ 


  {
#line 293
  req->version[0] = kernel_version___0.version[0];
#line 294
  req->version[1] = kernel_version___0.version[1];
#line 295
  req->version[2] = kernel_version___0.version[2];
#line 296
  if (sizeof(long ) == sizeof(long long )) {
#line 297
    req->is64bit = (__u8 )1;
  } else {
#line 299
    req->is64bit = (__u8 )0;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int open_default_lockspace___0(void) 
{ 
  dlm_lshandle_t ls ;

  {
#line 304
  if (! default_ls___0) {
    {
#line 312
    ls = dlm_open_lockspace("default");
    }
#line 313
    if (! ls) {
      {
#line 314
      ls = dlm_create_lockspace("default", (mode_t )384);
      }
    }
#line 315
    if (! ls) {
#line 316
      return (-1);
    }
#line 318
    default_ls___0 = (struct dlm_ls_info___0 *)ls;
  }
#line 320
  return (0);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void detect_kernel_version___0(void) 
{ 
  struct dlm_device_version v ;
  int rv ;
  ssize_t tmp ;

  {
  {
#line 328
  tmp = read(control_fd___0, (void *)(& v), sizeof(struct dlm_device_version ));
#line 328
  rv = (int )tmp;
  }
#line 329
  if (rv < 0) {
#line 330
    kernel_version___0.version[0] = (__u32 )5;
#line 331
    kernel_version___0.version[1] = (__u32 )0;
#line 332
    kernel_version___0.version[2] = (__u32 )0;
  } else {
#line 334
    kernel_version___0.version[0] = v.version[0];
#line 335
    kernel_version___0.version[1] = v.version[1];
#line 336
    kernel_version___0.version[2] = v.version[2];
  }
#line 339
  kernel_version_detected___0 = 1;
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int find_control_minor___0(int *minor ) 
{ 
  FILE *f ;
  char name[256] ;
  int found ;
  int m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 346
  found = 0;
#line 346
  m = 0;
#line 348
  f = fopen((char const   */* __restrict  */)"/proc/misc", (char const   */* __restrict  */)"r");
  }
#line 349
  if (! f) {
#line 350
    return (-1);
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 352
    tmp___1 = feof(f);
    }
#line 352
    if (tmp___1) {
#line 352
      goto while_break;
    }
    {
#line 353
    tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %s",
                 & m, name);
    }
#line 353
    if (tmp != 2) {
#line 354
      goto while_continue;
    }
    {
#line 355
    tmp___0 = strcmp((char const   *)(name), "dlm-control");
    }
#line 355
    if (tmp___0) {
#line 356
      goto while_continue;
    }
#line 357
    found = 1;
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  fclose(f);
  }
#line 362
  if (found) {
#line 363
    *minor = m;
#line 364
    return (0);
  }
#line 366
  return (-1);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int open_control_device___0(void) 
{ 
  struct stat st ;
  int i ;
  int rv ;
  int minor ;
  int found ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 372
  found = 0;
#line 374
  if (control_fd___0 > -1) {
#line 375
    goto out;
  }
  {
#line 377
  rv = find_control_minor___0(& minor);
  }
#line 378
  if (rv < 0) {
#line 379
    return (-1);
  }
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < 10)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp = stat((char const   */* __restrict  */)"/dev/misc/dlm-control", (struct stat */* __restrict  */)(& st));
    }
#line 384
    if (tmp == 0) {
      {
#line 384
      tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 384
      if (tmp___0 == (unsigned int )minor) {
#line 386
        found = 1;
#line 387
        goto while_break;
      }
    }
    {
#line 389
    sleep(1U);
    }
#line 390
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (! found) {
#line 394
    return (-1);
  }
  {
#line 396
  control_fd___0 = open("/dev/misc/dlm-control", 2);
  }
#line 397
  if (control_fd___0 == -1) {
#line 398
    return (-1);
  }
  out: 
  {
#line 401
  fcntl(control_fd___0, 2, 1);
  }
#line 403
  if (! kernel_version_detected___0) {
    {
#line 404
    detect_kernel_version___0();
    }
  }
#line 405
  return (0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int find_udev_device___0(char const   *lockspace , int minor , char *udev_path ) 
{ 
  char bname[4096] ;
  char tmp_path[4096] ;
  DIR *d ;
  struct dirent *de ;
  struct stat st ;
  size_t basename_len ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 421
  ls_dev_name___0(lockspace, udev_path, 4096);
#line 422
  snprintf((char */* __restrict  */)(bname), (size_t )4096, (char const   */* __restrict  */)"dlm_%s",
           lockspace);
#line 423
  basename_len = strlen((char const   *)(bname));
#line 425
  i = 0;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (i < 10)) {
#line 425
      goto while_break;
    }
    {
#line 429
    tmp = stat((char const   */* __restrict  */)udev_path, (struct stat */* __restrict  */)(& st));
    }
#line 429
    if (tmp == 0) {
      {
#line 429
      tmp___0 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 429
      if (tmp___0 == (unsigned int )minor) {
#line 430
        return (0);
      }
    }
#line 432
    if (basename_len < 19UL) {
      {
#line 433
      sleep(1U);
      }
#line 434
      goto __Cont;
    }
    {
#line 439
    d = opendir("/dev/misc/");
    }
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 440
      de = readdir(d);
      }
#line 440
      if (! de) {
#line 440
        goto while_break___0;
      }
#line 441
      if ((int )de->d_name[0] == 46) {
#line 442
        goto while_continue___0;
      }
      {
#line 443
      tmp___1 = strlen((char const   *)(de->d_name));
      }
#line 443
      if (tmp___1 < 19UL) {
#line 444
        goto while_continue___0;
      }
      {
#line 445
      tmp___2 = strncmp((char const   *)(de->d_name), (char const   *)(bname), (size_t )19);
      }
#line 445
      if (tmp___2) {
#line 446
        goto while_continue___0;
      }
      {
#line 447
      snprintf((char */* __restrict  */)(tmp_path), (size_t )4096, (char const   */* __restrict  */)"/dev/misc/%s",
               de->d_name);
#line 449
      tmp___3 = stat((char const   */* __restrict  */)(tmp_path), (struct stat */* __restrict  */)(& st));
      }
#line 449
      if (tmp___3) {
#line 450
        goto while_continue___0;
      }
      {
#line 451
      tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 451
      if (tmp___4 != (unsigned int )minor) {
#line 452
        goto while_continue___0;
      }
      {
#line 455
      strncpy((char */* __restrict  */)udev_path, (char const   */* __restrict  */)(tmp_path),
              (size_t )4096);
#line 456
      closedir(d);
      }
#line 457
      return (0);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 459
    closedir(d);
#line 460
    sleep(1U);
    }
    __Cont: /* CIL Label */ 
#line 425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (-1);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch_v5___0(int fd ) 
{ 
  char resultbuf[sizeof(struct dlm_lock_result_v5 ) + 32UL] ;
  struct dlm_lock_result_v5 *result ;
  char *fullresult ;
  int status ;
  void (*astaddr)(void *astarg ) ;
  ssize_t tmp ;
  int newstat ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 474
  result = (struct dlm_lock_result_v5 *)(resultbuf);
#line 475
  fullresult = (char *)((void *)0);
#line 479
  tmp = read(fd, (void *)result, sizeof(resultbuf));
#line 479
  status = (int )tmp;
  }
#line 480
  if (status <= 0) {
#line 481
    return (-1);
  }
#line 485
  if (result->length != (__u32 )status) {
    {
#line 488
    tmp___0 = malloc((size_t )result->length);
#line 488
    fullresult = (char *)tmp___0;
    }
#line 489
    if (! fullresult) {
#line 490
      return (-1);
    }
    {
#line 492
    tmp___1 = read(fd, (void *)((struct dlm_lock_result_v5 *)fullresult), (size_t )result->length);
#line 492
    newstat = (int )tmp___1;
    }
#line 499
    if ((__u32 )newstat == result->length) {
#line 500
      result = (struct dlm_lock_result_v5 *)fullresult;
    }
  } else {
#line 502
    fullresult = resultbuf;
  }
  {
#line 507
  memcpy((void */* __restrict  */)result->user_lksb, (void const   */* __restrict  */)(& result->lksb),
         sizeof(struct dlm_lksb ) - sizeof(char *));
#line 512
  (result->user_lksb)->sb_status = - (result->user_lksb)->sb_status;
  }
#line 515
  if (result->lvb_offset) {
    {
#line 516
    memcpy((void */* __restrict  */)(result->user_lksb)->sb_lvbptr, (void const   */* __restrict  */)(fullresult + result->lvb_offset),
           (size_t )32);
    }
  }
#line 520
  if (result->user_astaddr) {
    {
#line 521
    astaddr = (void (*)(void *astarg ))result->user_astaddr;
#line 522
    (*astaddr)(result->user_astparam);
    }
  }
#line 525
  if ((unsigned long )fullresult != (unsigned long )(resultbuf)) {
    {
#line 526
    free((void *)fullresult);
    }
  }
#line 528
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch_v6___0(int fd ) 
{ 
  char resultbuf[sizeof(struct dlm_lock_result ) + 32UL] ;
  struct dlm_lock_result *result ;
  int status ;
  void (*astaddr)(void *astarg ) ;
  ssize_t tmp ;

  {
  {
#line 534
  result = (struct dlm_lock_result *)(resultbuf);
#line 538
  tmp = read(fd, (void *)result, sizeof(resultbuf));
#line 538
  status = (int )tmp;
  }
#line 539
  if (status <= 0) {
#line 540
    return (-1);
  }
  {
#line 543
  memcpy((void */* __restrict  */)result->user_lksb, (void const   */* __restrict  */)(& result->lksb),
         sizeof(struct dlm_lksb ) - sizeof(char *));
  }
#line 547
  if (result->lvb_offset) {
    {
#line 548
    memcpy((void */* __restrict  */)(result->user_lksb)->sb_lvbptr, (void const   */* __restrict  */)((char *)result + result->lvb_offset),
           (size_t )32);
    }
  }
#line 551
  (result->user_lksb)->sb_status = - (result->user_lksb)->sb_status;
#line 553
  if (result->user_astaddr) {
    {
#line 554
    astaddr = (void (*)(void *astarg ))result->user_astaddr;
#line 555
    (*astaddr)(result->user_astparam);
    }
  }
#line 558
  return (0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int do_dlm_dispatch___0(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 563
  if (kernel_version___0.version[0] == 5U) {
    {
#line 564
    tmp = do_dlm_dispatch_v5___0(fd);
    }
#line 564
    return (tmp);
  } else {
    {
#line 566
    tmp___0 = do_dlm_dispatch_v6___0(fd);
    }
#line 566
    return (tmp___0);
  }
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int sync_write_v5___0(struct dlm_ls_info___0 *lsinfo , struct dlm_write_request_v5 *req ,
                             int len ) 
{ 
  struct lock_wait lwait ;
  int status ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  pthread_t tmp___1 ;

  {
  {
#line 586
  tmp___1 = pthread_self();
  }
#line 586
  if (tmp___1 == lsinfo->tid) {
    {
#line 588
    req->i.lock.castaddr = (void *)(& dummy_ast_routine___0);
#line 589
    req->i.lock.castparam = (void *)0;
#line 591
    tmp = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 591
    status = (int )tmp;
    }
#line 592
    if (status < 0) {
#line 593
      return (-1);
    }
    {
#line 595
    while (1) {
      while_continue: /* CIL Label */ ;
#line 595
      if (! ((req->i.lock.lksb)->sb_status == 65539)) {
#line 595
        goto while_break;
      }
      {
#line 596
      do_dlm_dispatch_v5___0(lsinfo->fd);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 599
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 600
    pthread_mutex_init(& lwait.mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 601
    pthread_mutex_lock(& lwait.mutex);
#line 603
    req->i.lock.castaddr = (void *)(& sync_ast_routine);
#line 604
    req->i.lock.castparam = (void *)(& lwait);
#line 606
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 606
    status = (int )tmp___0;
    }
#line 607
    if (status < 0) {
#line 608
      return (-1);
    }
    {
#line 610
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_mutex_t */* __restrict  */)(& lwait.mutex));
#line 611
    pthread_mutex_unlock(& lwait.mutex);
    }
  }
#line 614
  return (status);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int sync_write_v6___0(struct dlm_ls_info___0 *lsinfo , struct dlm_write_request *req ,
                             int len ) 
{ 
  struct lock_wait lwait ;
  int status ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  pthread_t tmp___1 ;

  {
  {
#line 623
  tmp___1 = pthread_self();
  }
#line 623
  if (tmp___1 == lsinfo->tid) {
    {
#line 625
    req->i.lock.castaddr = (void *)(& dummy_ast_routine___0);
#line 626
    req->i.lock.castparam = (void *)0;
#line 628
    tmp = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 628
    status = (int )tmp;
    }
#line 629
    if (status < 0) {
#line 630
      return (-1);
    }
    {
#line 632
    while (1) {
      while_continue: /* CIL Label */ ;
#line 632
      if (! ((req->i.lock.lksb)->sb_status == 65539)) {
#line 632
        goto while_break;
      }
      {
#line 633
      do_dlm_dispatch_v6___0(lsinfo->fd);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 636
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 637
    pthread_mutex_init(& lwait.mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 638
    pthread_mutex_lock(& lwait.mutex);
#line 640
    req->i.lock.castaddr = (void *)(& sync_ast_routine);
#line 641
    req->i.lock.castparam = (void *)(& lwait);
#line 643
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 643
    status = (int )tmp___0;
    }
#line 644
    if (status < 0) {
#line 645
      return (-1);
    }
    {
#line 647
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& lwait.cond), (pthread_mutex_t */* __restrict  */)(& lwait.mutex));
#line 648
    pthread_mutex_unlock(& lwait.mutex);
    }
  }
#line 651
  return (status);
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock_v5___0(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb ,
                          uint32_t flags , void const   *name , unsigned int namelen ,
                          uint32_t parent , void (*astaddr)(void *astarg ) , void *astarg ,
                          void (*bastaddr)(void *astarg ) ) 
{ 
  char parambuf[sizeof(struct dlm_write_request_v5 ) + 64UL] ;
  struct dlm_write_request_v5 *req ;
  struct dlm_ls_info___0 *lsinfo ;
  int status ;
  int len ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 720
  req = (struct dlm_write_request_v5 *)(parambuf);
#line 721
  lsinfo = (struct dlm_ls_info___0 *)ls;
#line 725
  memset((void *)req, 0, sizeof(*req));
#line 726
  set_version_v5___0(req);
#line 728
  req->cmd = (__u8 )1;
#line 729
  req->i.lock.mode = (__u8 )mode;
#line 730
  req->i.lock.flags = (__u16 )(flags & 2147483647U);
#line 731
  req->i.lock.lkid = lksb->sb_lkid;
#line 732
  req->i.lock.parent = parent;
#line 733
  req->i.lock.lksb = lksb;
#line 734
  req->i.lock.castaddr = (void *)astaddr;
#line 735
  req->i.lock.bastaddr = (void *)bastaddr;
#line 736
  req->i.lock.castparam = astarg;
#line 737
  req->i.lock.bastparam = astarg;
  }
#line 739
  if (flags & 4U) {
#line 740
    req->i.lock.namelen = (__u8 )0;
  } else {
#line 742
    if (namelen > 64U) {
      {
#line 743
      tmp = __errno_location();
#line 743
      *tmp = 22;
      }
#line 744
      return (-1);
    }
    {
#line 746
    req->i.lock.namelen = (__u8 )namelen;
#line 747
    memcpy((void */* __restrict  */)(req->i.lock.name), (void const   */* __restrict  */)name,
           (size_t )namelen);
    }
  }
#line 750
  if (flags & 8U) {
    {
#line 751
    memcpy((void */* __restrict  */)(req->i.lock.lvb), (void const   */* __restrict  */)lksb->sb_lvbptr,
           (size_t )32);
    }
  }
#line 754
  len = (int )(sizeof(struct dlm_write_request_v5 ) + (unsigned long )namelen);
#line 755
  lksb->sb_status = 65539;
#line 757
  if (flags & 2147483648U) {
    {
#line 758
    status = sync_write_v5___0(lsinfo, req, len);
    }
  } else {
    {
#line 760
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 760
    status = (int )tmp___0;
    }
  }
#line 762
  if (status < 0) {
#line 763
    return (-1);
  }
#line 769
  if (status > 0) {
#line 770
    lksb->sb_lkid = (__u32 )status;
  }
#line 771
  return (0);
}
}
#line 774 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock_v6___0(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb ,
                          uint32_t flags , void const   *name , unsigned int namelen ,
                          uint32_t parent , void (*astaddr)(void *astarg ) , void *astarg ,
                          void (*bastaddr)(void *astarg ) , uint64_t *xid , uint64_t *timeout ) 
{ 
  char parambuf[sizeof(struct dlm_write_request ) + 64UL] ;
  struct dlm_write_request *req ;
  struct dlm_ls_info___0 *lsinfo ;
  int status ;
  int len ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 788
  req = (struct dlm_write_request *)(parambuf);
#line 789
  lsinfo = (struct dlm_ls_info___0 *)ls;
#line 793
  memset((void *)req, 0, sizeof(*req));
#line 794
  set_version_v6___0(req);
#line 796
  req->cmd = (__u8 )1;
#line 797
  req->i.lock.mode = (__u8 )mode;
#line 798
  req->i.lock.flags = flags & 2147483647U;
#line 799
  req->i.lock.lkid = lksb->sb_lkid;
#line 800
  req->i.lock.parent = parent;
#line 801
  req->i.lock.lksb = lksb;
#line 802
  req->i.lock.castaddr = (void *)astaddr;
#line 803
  req->i.lock.bastaddr = (void *)bastaddr;
#line 804
  req->i.lock.castparam = astarg;
#line 805
  req->i.lock.bastparam = astarg;
  }
#line 807
  if (xid) {
#line 808
    req->i.lock.xid = (__u64 )*xid;
  }
#line 809
  if (timeout) {
#line 810
    req->i.lock.timeout = (__u64 )*timeout;
  }
#line 812
  if (flags & 4U) {
#line 813
    req->i.lock.namelen = (__u8 )0;
  } else {
#line 815
    if (namelen > 64U) {
      {
#line 816
      tmp = __errno_location();
#line 816
      *tmp = 22;
      }
#line 817
      return (-1);
    }
    {
#line 819
    req->i.lock.namelen = (__u8 )namelen;
#line 820
    memcpy((void */* __restrict  */)(req->i.lock.name), (void const   */* __restrict  */)name,
           (size_t )namelen);
    }
  }
#line 823
  if (flags & 8U) {
    {
#line 824
    memcpy((void */* __restrict  */)(req->i.lock.lvb), (void const   */* __restrict  */)lksb->sb_lvbptr,
           (size_t )32);
    }
  }
#line 827
  len = (int )(sizeof(struct dlm_write_request ) + (unsigned long )namelen);
#line 828
  lksb->sb_status = 65539;
#line 830
  if (flags & 2147483648U) {
    {
#line 831
    status = sync_write_v6___0(lsinfo, req, len);
    }
  } else {
    {
#line 833
    tmp___0 = write(lsinfo->fd, (void const   *)req, (size_t )len);
#line 833
    status = (int )tmp___0;
    }
  }
#line 835
  if (status < 0) {
#line 836
    return (-1);
  }
#line 842
  if (status > 0) {
#line 843
    lksb->sb_lkid = (__u32 )status;
  }
#line 844
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_lock___0(dlm_lshandle_t ls , uint32_t mode , struct dlm_lksb *lksb ,
                       uint32_t flags , void const   *name , unsigned int namelen ,
                       uint32_t parent , void (*astaddr)(void *astarg ) , void *astarg ,
                       void (*bastaddr)(void *astarg ) , void *range ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 860
  if (range) {
    {
#line 861
    tmp = __errno_location();
#line 861
    *tmp = 38;
    }
#line 862
    return (-1);
  }
#line 865
  if (flags & 8U) {
#line 865
    if (! lksb->sb_lvbptr) {
      {
#line 866
      tmp___0 = __errno_location();
#line 866
      *tmp___0 = 22;
      }
#line 867
      return (-1);
    }
  }
#line 870
  if (kernel_version___0.version[0] == 5U) {
    {
#line 871
    tmp___1 = ls_lock_v5___0(ls, mode, lksb, flags, name, namelen, parent, astaddr,
                             astarg, bastaddr);
    }
#line 871
    return (tmp___1);
  } else {
    {
#line 874
    tmp___2 = ls_lock_v6___0(ls, mode, lksb, flags, name, namelen, parent, astaddr,
                             astarg, bastaddr, (uint64_t *)((void *)0), (uint64_t *)((void *)0));
    }
#line 874
    return (tmp___2);
  }
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_unlock_v5___0(struct dlm_ls_info___0 *lsinfo , uint32_t lkid , uint32_t flags ,
                            struct dlm_lksb *lksb , void *astarg ) 
{ 
  struct dlm_write_request_v5 req ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 992
  set_version_v5___0(& req);
#line 993
  req.cmd = (__u8 )2;
#line 994
  req.i.lock.lkid = lkid;
#line 995
  req.i.lock.flags = (__u16 )(flags & 2147483647U);
#line 996
  req.i.lock.lksb = lksb;
#line 997
  req.i.lock.castparam = astarg;
#line 999
  req.i.lock.castaddr = (void *)0;
#line 1000
  lksb->sb_status = 65539;
  }
#line 1002
  if (flags & 2147483648U) {
    {
#line 1003
    tmp = sync_write_v5___0(lsinfo, & req, (int )sizeof(req));
    }
#line 1003
    return (tmp);
  } else {
    {
#line 1005
    tmp___0 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
    }
#line 1005
    return ((int )tmp___0);
  }
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int ls_unlock_v6___0(struct dlm_ls_info___0 *lsinfo , uint32_t lkid , uint32_t flags ,
                            struct dlm_lksb *lksb , void *astarg ) 
{ 
  struct dlm_write_request req ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1013
  set_version_v6___0(& req);
#line 1014
  req.cmd = (__u8 )2;
#line 1015
  req.i.lock.lkid = lkid;
#line 1016
  req.i.lock.flags = flags & 2147483647U;
#line 1017
  req.i.lock.lksb = lksb;
#line 1018
  req.i.lock.namelen = (__u8 )0;
#line 1019
  req.i.lock.castparam = astarg;
#line 1021
  req.i.lock.castaddr = (void *)0;
#line 1022
  lksb->sb_status = 65539;
  }
#line 1024
  if (flags & 2147483648U) {
    {
#line 1025
    tmp = sync_write_v6___0(lsinfo, & req, (int )sizeof(req));
    }
#line 1025
    return (tmp);
  } else {
    {
#line 1027
    tmp___0 = write(lsinfo->fd, (void const   *)(& req), sizeof(req));
    }
#line 1027
    return ((int )tmp___0);
  }
}
}
#line 1184 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static void *dlm_recv_thread(void *lsinfo ) 
{ 
  struct dlm_ls_info___0 *lsi ;

  {
#line 1186
  lsi = (struct dlm_ls_info___0 *)lsinfo;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1189
    do_dlm_dispatch___0(lsi->fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1191
  return ((void *)0);
}
}
#line 1195 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_pthread_init(void) 
{ 
  int tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1197
  tmp = open_default_lockspace___0();
  }
#line 1197
  if (tmp) {
#line 1198
    return (-1);
  }
#line 1200
  if (default_ls___0->tid) {
    {
#line 1202
    tmp___0 = __errno_location();
#line 1202
    *tmp___0 = 17;
    }
#line 1203
    return (-1);
  }
  {
#line 1206
  tmp___3 = pthread_create((pthread_t */* __restrict  */)(& default_ls___0->tid),
                           (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & dlm_recv_thread, (void */* __restrict  */)default_ls___0);
  }
#line 1206
  if (tmp___3) {
    {
#line 1208
    tmp___1 = __errno_location();
#line 1208
    saved_errno = *tmp___1;
#line 1209
    close(default_ls___0->fd);
#line 1210
    free((void *)default_ls___0);
#line 1211
    default_ls___0 = (struct dlm_ls_info___0 *)((void *)0);
#line 1212
    tmp___2 = __errno_location();
#line 1212
    *tmp___2 = saved_errno;
    }
#line 1213
    return (-1);
  }
#line 1215
  return (0);
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
int dlm_ls_pthread_init(dlm_lshandle_t ls ) 
{ 
  struct dlm_ls_info___0 *lsinfo ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1221
  lsinfo = (struct dlm_ls_info___0 *)ls;
#line 1223
  if (lsinfo->tid) {
    {
#line 1225
    tmp = __errno_location();
#line 1225
    *tmp = 17;
    }
#line 1226
    return (-1);
  }
  {
#line 1229
  tmp___0 = pthread_create((pthread_t */* __restrict  */)(& lsinfo->tid), (pthread_attr_t const   */* __restrict  */)((void *)0),
                           & dlm_recv_thread, (void */* __restrict  */)ls);
  }
#line 1229
  return (tmp___0);
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int create_lockspace_v5___0(char const   *name , uint32_t flags ) 
{ 
  char reqbuf[sizeof(struct dlm_write_request_v5 ) + 64UL] ;
  struct dlm_write_request_v5 *req ;
  int namelen ;
  size_t tmp ;
  int minor ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1241
  req = (struct dlm_write_request_v5 *)(reqbuf);
#line 1242
  tmp = strlen(name);
#line 1242
  namelen = (int )tmp;
#line 1245
  memset((void *)(reqbuf), 0, sizeof(reqbuf));
#line 1246
  set_version_v5___0(req);
#line 1248
  req->cmd = (__u8 )4;
#line 1249
  req->i.lspace.flags = flags;
  }
#line 1251
  if (namelen > 64) {
    {
#line 1252
    tmp___0 = __errno_location();
#line 1252
    *tmp___0 = 22;
    }
#line 1253
    return (-1);
  }
  {
#line 1255
  memcpy((void */* __restrict  */)(req->i.lspace.name), (void const   */* __restrict  */)name,
         (size_t )namelen);
#line 1257
  tmp___1 = write(control_fd___0, (void const   *)req, sizeof(*req) + (unsigned long )namelen);
#line 1257
  minor = (int )tmp___1;
  }
#line 1259
  return (minor);
}
}
#line 1262 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int create_lockspace_v6___0(char const   *name , uint32_t flags ) 
{ 
  char reqbuf[sizeof(struct dlm_write_request ) + 64UL] ;
  struct dlm_write_request *req ;
  int namelen ;
  size_t tmp ;
  int minor ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 1265
  req = (struct dlm_write_request *)(reqbuf);
#line 1266
  tmp = strlen(name);
#line 1266
  namelen = (int )tmp;
#line 1269
  memset((void *)(reqbuf), 0, sizeof(reqbuf));
#line 1270
  set_version_v6___0(req);
#line 1272
  req->cmd = (__u8 )4;
#line 1273
  req->i.lspace.flags = flags;
  }
#line 1275
  if (namelen > 64) {
    {
#line 1276
    tmp___0 = __errno_location();
#line 1276
    *tmp___0 = 22;
    }
#line 1277
    return (-1);
  }
  {
#line 1279
  memcpy((void */* __restrict  */)(req->i.lspace.name), (void const   */* __restrict  */)name,
         (size_t )namelen);
#line 1281
  tmp___1 = write(control_fd___0, (void const   *)req, sizeof(*req) + (unsigned long )namelen);
#line 1281
  minor = (int )tmp___1;
  }
#line 1283
  return (minor);
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static dlm_lshandle_t create_lockspace___0(char const   *name , mode_t mode , uint32_t flags ) 
{ 
  char dev_path[4096] ;
  char udev_path[4096] ;
  struct dlm_ls_info___0 *newls ;
  int error ;
  int saved_errno ;
  int minor ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1295
  tmp = open_control_device___0();
  }
#line 1295
  if (tmp) {
#line 1296
    return ((void *)0);
  }
  {
#line 1298
  tmp___0 = malloc(sizeof(struct dlm_ls_info___0 ));
#line 1298
  newls = (struct dlm_ls_info___0 *)tmp___0;
  }
#line 1299
  if (! newls) {
#line 1300
    return ((void *)0);
  }
  {
#line 1302
  ls_dev_name___0(name, dev_path, (int )sizeof(dev_path));
  }
#line 1304
  if (kernel_version___0.version[0] == 5U) {
    {
#line 1305
    minor = create_lockspace_v5___0(name, flags);
    }
  } else {
    {
#line 1307
    minor = create_lockspace_v6___0(name, flags);
    }
  }
#line 1309
  if (minor < 0) {
#line 1310
    goto fail;
  }
  {
#line 1315
  error = find_udev_device___0(name, minor, udev_path);
  }
#line 1316
  if (error) {
#line 1317
    goto fail;
  }
  {
#line 1322
  tmp___1 = strcmp((char const   *)(dev_path), (char const   *)(udev_path));
  }
#line 1322
  if (tmp___1) {
    {
#line 1323
    error = symlink((char const   *)(udev_path), (char const   *)(dev_path));
    }
#line 1324
    if (error) {
#line 1325
      goto fail;
    }
  }
  {
#line 1330
  newls->fd = open((char const   *)(dev_path), 2);
  }
#line 1331
  if (newls->fd == -1) {
#line 1332
    goto fail;
  }
#line 1333
  if (mode) {
    {
#line 1334
    fchmod(newls->fd, mode);
    }
  }
  {
#line 1335
  newls->tid = (pthread_t )0;
#line 1336
  fcntl(newls->fd, 2, 1);
  }
#line 1337
  return ((dlm_lshandle_t )newls);
  fail: 
  {
#line 1340
  tmp___2 = __errno_location();
#line 1340
  saved_errno = *tmp___2;
#line 1341
  free((void *)newls);
#line 1342
  tmp___3 = __errno_location();
#line 1342
  *tmp___3 = saved_errno;
  }
#line 1343
  return ((void *)0);
}
}
#line 1356 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace_v5___0(uint32_t minor , uint32_t flags ) 
{ 
  struct dlm_write_request_v5 req ;
  ssize_t tmp ;

  {
  {
#line 1360
  set_version_v5___0(& req);
#line 1361
  req.cmd = (__u8 )5;
#line 1362
  req.i.lspace.minor = minor;
#line 1363
  req.i.lspace.flags = flags;
#line 1365
  tmp = write(control_fd___0, (void const   *)(& req), sizeof(req));
  }
#line 1365
  return ((int )tmp);
}
}
#line 1368 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace_v6___0(uint32_t minor , uint32_t flags ) 
{ 
  struct dlm_write_request req ;
  ssize_t tmp ;

  {
  {
#line 1372
  set_version_v6___0(& req);
#line 1373
  req.cmd = (__u8 )5;
#line 1374
  req.i.lspace.minor = minor;
#line 1375
  req.i.lspace.flags = flags;
#line 1377
  tmp = write(control_fd___0, (void const   *)(& req), sizeof(req));
  }
#line 1377
  return ((int )tmp);
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/dlm-4.0.1/libdlm/libdlm.c"
static int release_lockspace___0(uint32_t minor , uint32_t flags ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1382
  if (kernel_version___0.version[0] == 5U) {
    {
#line 1383
    tmp = release_lockspace_v5___0(minor, flags);
    }
#line 1383
    return (tmp);
  } else {
    {
#line 1385
    tmp___0 = release_lockspace_v6___0(minor, flags);
    }
#line 1385
    return (tmp___0);
  }
}
}
