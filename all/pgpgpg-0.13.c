/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 26 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.h"
struct __anonstruct_Pgpopts_52 {
   char k ;
   char g ;
   char a ;
   char x ;
   char v ;
   char c ;
   char r ;
   char e ;
   char s ;
   char d ;
   char b ;
   char p ;
   char f ;
   char w ;
   char m ;
   char t ;
   char *passphrase ;
   char *outputfile ;
   char *localuserid ;
   char *charset ;
   char *comment ;
   char *pubring ;
   char *secring ;
   int batchmode ;
   int asciiarmor ;
   int textmode ;
   int clearsign ;
   int verbose ;
   int compress ;
   int encrypttoself ;
   char *completesneeded ;
   char *marginalsneeded ;
   char *certdepth ;
   int force ;
   int stdinisterminal ;
   char **args ;
   size_t args_size ;
   size_t args_used ;
   int passphrase_pipe[2] ;
};
#line 26 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.h"
typedef struct __anonstruct_Pgpopts_52 Pgpopts;
#line 27 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.h"
struct __anonstruct_ArgvFactory_53 {
   char **argv ;
   size_t used ;
   size_t size ;
};
#line 27 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.h"
typedef struct __anonstruct_ArgvFactory_53 ArgvFactory;
#line 92 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
struct __anonstruct_mapping_55 {
   char *keyword ;
   int minlen ;
   int index ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 162 "/home/wheatley/newnew/temp/pgpgpg-0.13/main.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 168 "/home/wheatley/newnew/temp/pgpgpg-0.13/main.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 55 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.h"
void pgpopts_init(Pgpopts *opts ) ;
#line 56
char **pgpopts_build_argv(Pgpopts *pgpopts ) ;
#line 57
int pgpopts_parse(Pgpopts *pgpopts , int argc , char **argv ) ;
#line 36 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.h"
void argv_factory_init(ArgvFactory *af ) ;
#line 37
void argv_factory_add(ArgvFactory *af , char *arg ) ;
#line 26 "/home/wheatley/newnew/temp/pgpgpg-0.13/defaultkey.h"
char *get_defaultkey(void) ;
#line 27 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.h"
char *myoptarg ;
#line 29
int myoptopt ;
#line 32
int mygetopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 33 "/home/wheatley/newnew/temp/pgpgpg-0.13/guessarmortype.h"
int guess_armor_type(char *filename ) ;
#line 43 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
void pgpopts_init(Pgpopts *opts ) 
{ 
  void *tmp ;

  {
  {
#line 47
  memset((void *)opts, 0, sizeof(Pgpopts ));
#line 48
  opts->clearsign = 1;
#line 49
  opts->force = -1;
#line 50
  opts->compress = -1;
#line 52
  opts->args_size = (size_t )64;
#line 53
  opts->args_used = (size_t )0;
#line 54
  tmp = malloc(opts->args_size * sizeof(char ));
#line 54
  opts->args = (char **)tmp;
#line 56
  opts->passphrase_pipe[0] = -1;
#line 57
  opts->passphrase_pipe[1] = -1;
  }
#line 58
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static struct __anonstruct_mapping_55 mapping[30]  = 
#line 92
  {      {(char *)"armor", 5, 3}, 
        {(char *)"armorlines", 6, -1}, 
        {(char *)"autosign", 2, -1}, 
        {(char *)"bakring", 3, -1}, 
        {(char *)"batchmode", 3, 2}, 
        {(char *)"cert_depth", 2, 11}, 
        {(char *)"charset", 2, 1}, 
        {(char *)"clearsig", 2, 5}, 
        {(char *)"comment", 4, 12}, 
        {(char *)"completes_needed", 5, 9}, 
        {(char *)"compress", 5, 7}, 
        {(char *)"encrypttoself", 1, 8}, 
        {(char *)"force", 1, 13}, 
        {(char *)"interactive", 1, -1}, 
        {(char *)"keepbinary", 1, -2}, 
        {(char *)"language", 2, -1}, 
        {(char *)"legal_kludge", 2, -1}, 
        {(char *)"marginals_needed", 3, 10}, 
        {(char *)"myname", 2, 0}, 
        {(char *)"nomanual", 1, -1}, 
        {(char *)"pager", 2, -1}, 
        {(char *)"pubring", 2, 14}, 
        {(char *)"randseed", 1, -1}, 
        {(char *)"secring", 2, 15}, 
        {(char *)"showpass", 2, -1}, 
        {(char *)"textmode", 2, 4}, 
        {(char *)"tmp", 2, -1}, 
        {(char *)"tzfix", 2, -1}, 
        {(char *)"verbose", 1, 6}, 
        {(char *)((void *)0), 0, -3}};
#line 144 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static int fetch_bool(char *keyword , char *value ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 148
  if (! value) {
#line 149
    return (1);
  } else {
    {
#line 150
    tmp___0 = strcasecmp((char const   *)value, "on");
    }
#line 150
    if (tmp___0) {
      {
#line 152
      tmp = strcasecmp((char const   *)value, "off");
      }
#line 152
      if (tmp) {
        {
#line 156
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid boolean value `%s\' for long option `%s\'.\n",
                value, keyword);
        }
#line 157
        return (-1);
      } else {
#line 153
        return (0);
      }
    } else {
#line 151
      return (1);
    }
  }
}
}
#line 163 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static int parse_longopt(Pgpopts *opts , char const   *s ) 
{ 
  char *keyword ;
  size_t keyword_len ;
  char *value ;
  char *end ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 174
  keyword = strdup(s);
  }
#line 175
  if (keyword) {
    {
#line 175
    tmp = strchr((char const   *)keyword, '=');
#line 175
    value = tmp;
    }
  } else {
#line 175
    value = (char *)((void *)0);
  }
#line 177
  if (value) {
#line 178
    tmp___0 = value;
#line 178
    value ++;
#line 178
    *tmp___0 = (char)0;
  }
  {
#line 181
  tmp___1 = strspn((char const   *)keyword, " \t");
#line 181
  keyword += tmp___1;
  }
#line 182
  if (*keyword) {
    {
#line 183
    tmp___2 = strlen((char const   *)keyword);
#line 183
    end = (keyword + tmp___2) - 1;
    }
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 183
      if (! ((int )*end == 32)) {
#line 183
        if (! ((int )*end == 9)) {
#line 183
          goto while_break;
        }
      }
#line 183
      tmp___3 = end;
#line 183
      end --;
#line 183
      *tmp___3 = (char)0;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 186
  if (value) {
    {
#line 188
    tmp___4 = strspn((char const   *)value, " \t");
#line 188
    value += tmp___4;
    }
#line 190
    if ((int )*value == 34) {
      {
#line 192
      end = strchr((char const   *)(value + 1), '\"');
      }
#line 194
      if (! end) {
        {
#line 196
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unterminated long option value string: \'%s\'\n",
                value);
        }
#line 197
        return (-1);
      }
#line 200
      value ++;
#line 201
      *end = (char)0;
    } else
#line 204
    if (*value) {
      {
#line 205
      tmp___5 = strlen((char const   *)value);
#line 205
      end = (value + tmp___5) - 1;
      }
      {
#line 205
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 205
        if (! ((int )*end == 32)) {
#line 205
          if (! ((int )*end == 9)) {
#line 205
            goto while_break___0;
          }
        }
#line 205
        tmp___6 = end;
#line 205
        end --;
#line 205
        *tmp___6 = (char)0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 208
  keyword_len = strlen((char const   *)keyword);
#line 214
  i = 0;
  }
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 214
    if (! mapping[i].keyword) {
#line 214
      goto while_break___1;
    }
#line 215
    if ((size_t )mapping[i].minlen <= keyword_len) {
      {
#line 215
      tmp___7 = strncasecmp((char const   *)mapping[i].keyword, (char const   *)keyword,
                            keyword_len);
      }
#line 215
      if (! tmp___7) {
#line 216
        goto while_break___1;
      }
    }
#line 214
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 221
  if (mapping[i].index == 2) {
#line 221
    goto case_2;
  }
#line 226
  if (mapping[i].index == 13) {
#line 226
    goto case_13;
  }
#line 231
  if (mapping[i].index == 0) {
#line 231
    goto case_0;
  }
#line 240
  if (mapping[i].index == 8) {
#line 240
    goto case_8;
  }
#line 245
  if (mapping[i].index == 10) {
#line 245
    goto case_10;
  }
#line 254
  if (mapping[i].index == 9) {
#line 254
    goto case_9;
  }
#line 263
  if (mapping[i].index == 11) {
#line 263
    goto case_11;
  }
#line 272
  if (mapping[i].index == 6) {
#line 272
    goto case_6;
  }
#line 281
  if (mapping[i].index == 7) {
#line 281
    goto case_7;
  }
#line 286
  if (mapping[i].index == 4) {
#line 286
    goto case_4;
  }
#line 291
  if (mapping[i].index == 3) {
#line 291
    goto case_3;
  }
#line 296
  if (mapping[i].index == 5) {
#line 296
    goto case_5;
  }
#line 301
  if (mapping[i].index == 12) {
#line 301
    goto case_12;
  }
#line 310
  if (mapping[i].index == 15) {
#line 310
    goto case_15;
  }
#line 319
  if (mapping[i].index == 14) {
#line 319
    goto case_14;
  }
#line 328
  if (mapping[i].index == 1) {
#line 328
    goto case_1;
  }
#line 347
  if (mapping[i].index == -3) {
#line 347
    goto case_neg_3;
  }
#line 351
  if (mapping[i].index == -2) {
#line 351
    goto case_neg_2;
  }
#line 355
  if (mapping[i].index == -1) {
#line 355
    goto case_neg_1;
  }
#line 359
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 222
  tmp___8 = fetch_bool(keyword, value);
#line 222
  opts->batchmode = tmp___8;
  }
#line 222
  if (tmp___8 == -1) {
#line 223
    return (-1);
  }
#line 224
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 227
  tmp___9 = fetch_bool(keyword, value);
#line 227
  opts->force = tmp___9;
  }
#line 227
  if (tmp___9 == -1) {
#line 228
    return (-1);
  }
#line 229
  goto switch_break;
  case_0: /* CIL Label */ 
#line 232
  if (! value) {
    {
#line 234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `myname\' requires an argument.\n");
    }
#line 235
    return (-1);
  }
#line 237
  opts->localuserid = value;
#line 238
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 241
  tmp___10 = fetch_bool(keyword, value);
#line 241
  opts->encrypttoself = tmp___10;
  }
#line 241
  if (tmp___10 == -1) {
#line 242
    return (-1);
  }
#line 243
  goto switch_break;
  case_10: /* CIL Label */ 
#line 246
  if (! value) {
    {
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `marginals_needed\' requires an argument.\n");
    }
#line 249
    return (-1);
  }
#line 251
  opts->marginalsneeded = value;
#line 252
  goto switch_break;
  case_9: /* CIL Label */ 
#line 255
  if (! value) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `completes_needed\' requires an argument.\n");
    }
#line 258
    return (-1);
  }
#line 260
  opts->completesneeded = value;
#line 261
  goto switch_break;
  case_11: /* CIL Label */ 
#line 264
  if (! value) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `certdepth\' requires an argument.\n");
    }
#line 267
    return (-1);
  }
#line 269
  opts->certdepth = value;
#line 270
  goto switch_break;
  case_6: /* CIL Label */ 
#line 273
  if (! value) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `verbose\' requires an argument.\n");
    }
#line 276
    return (-1);
  }
  {
#line 278
  opts->verbose = atoi((char const   *)value);
  }
#line 279
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 282
  tmp___11 = fetch_bool(keyword, value);
#line 282
  opts->compress = tmp___11;
  }
#line 282
  if (tmp___11 == -1) {
#line 283
    return (-1);
  }
#line 284
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 287
  tmp___12 = fetch_bool(keyword, value);
#line 287
  opts->textmode = tmp___12;
  }
#line 287
  if (tmp___12 == -1) {
#line 288
    return (-1);
  }
#line 289
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 292
  tmp___13 = fetch_bool(keyword, value);
#line 292
  opts->asciiarmor = tmp___13;
  }
#line 292
  if (tmp___13 == -1) {
#line 293
    return (-1);
  }
#line 294
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 297
  tmp___14 = fetch_bool(keyword, value);
#line 297
  opts->clearsign = tmp___14;
  }
#line 297
  if (tmp___14 == -1) {
#line 298
    return (-1);
  }
#line 299
  goto switch_break;
  case_12: /* CIL Label */ 
#line 302
  if (! value) {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `comment\' requires an argument.\n");
    }
#line 305
    return (-1);
  }
#line 307
  opts->comment = value;
#line 308
  goto switch_break;
  case_15: /* CIL Label */ 
#line 311
  if (! value) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `secring\' requires an argument.\n");
    }
#line 314
    return (-1);
  }
#line 316
  opts->secring = value;
#line 317
  goto switch_break;
  case_14: /* CIL Label */ 
#line 320
  if (! value) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `pubring\' requires an argument.\n");
    }
#line 323
    return (-1);
  }
#line 325
  opts->pubring = value;
#line 326
  goto switch_break;
  case_1: /* CIL Label */ 
#line 329
  if (! value) {
    {
#line 331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Long option `charset\' requires an argument.\n");
    }
#line 332
    return (-1);
  }
  {
#line 334
  tmp___17 = strcasecmp((char const   *)value, "noconv");
  }
#line 334
  if (tmp___17) {
    {
#line 336
    tmp___16 = strcasecmp((char const   *)value, "latin1");
    }
#line 336
    if (tmp___16) {
      {
#line 338
      tmp___15 = strcasecmp((char const   *)value, "koi8");
      }
#line 338
      if (tmp___15) {
        {
#line 342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Charset `%s\' not supported.\n",
                value);
        }
#line 343
        return (-1);
      } else {
#line 339
        opts->charset = (char *)"koi8-r";
      }
    } else {
#line 337
      opts->charset = (char *)"iso-8859-1";
    }
  } else {
#line 335
    opts->charset = (char *)((void *)0);
  }
#line 345
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 348
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unknown long option `%s\'\n",
          keyword);
  }
#line 349
  return (-1);
  case_neg_2: /* CIL Label */ 
  {
#line 352
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Sorry, but long option `%s\' is not supported.\n",
          mapping[i].keyword);
  }
#line 353
  return (-1);
  case_neg_1: /* CIL Label */ 
  {
#line 356
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Long option `%s\' is not translated/used.\n",
          mapping[i].keyword);
  }
#line 357
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: The long option `%s\' is currently not supported.\n     Please submit a bug report to <mroth@gnupg.org>\n",
          mapping[i].keyword);
  }
#line 362
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 365
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void add_argument(Pgpopts *pgpopts , char *arg ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
#line 393
  if (pgpopts->args_used + 1UL == pgpopts->args_size) {
    {
#line 395
    pgpopts->args_size *= 2UL;
#line 396
    tmp = realloc((void *)pgpopts->args, pgpopts->args_size * sizeof(char *));
#line 396
    pgpopts->args = (char **)tmp;
    }
  }
#line 400
  tmp___0 = pgpopts->args_used;
#line 400
  (pgpopts->args_used) ++;
#line 400
  *(pgpopts->args + tmp___0) = arg;
#line 401
  *(pgpopts->args + pgpopts->args_used) = (char *)((void *)0);
#line 402
  return;
}
}
#line 421 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static int check_opts_used(Pgpopts *pgpopts ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 423
  err = 0;
#line 427
  if (pgpopts->k) {
#line 427
    tmp = 1;
  } else {
#line 427
    tmp = 0;
  }
#line 427
  err += tmp;
#line 428
  if (pgpopts->g) {
#line 428
    tmp___0 = 1;
  } else {
#line 428
    tmp___0 = 0;
  }
#line 428
  err += tmp___0;
#line 430
  if (pgpopts->x) {
#line 430
    tmp___1 = 1;
  } else {
#line 430
    tmp___1 = 0;
  }
#line 430
  err += tmp___1;
#line 432
  if (pgpopts->c) {
#line 432
    tmp___2 = 1;
  } else {
#line 432
    tmp___2 = 0;
  }
#line 432
  err += tmp___2;
#line 433
  if (pgpopts->r) {
#line 433
    tmp___3 = 1;
  } else {
#line 433
    tmp___3 = 0;
  }
#line 433
  err += tmp___3;
#line 434
  if (pgpopts->e) {
#line 434
    tmp___4 = 1;
  } else {
#line 434
    tmp___4 = 0;
  }
#line 434
  err += tmp___4;
#line 435
  if (pgpopts->s) {
#line 435
    tmp___5 = 1;
  } else {
#line 435
    tmp___5 = 0;
  }
#line 435
  err += tmp___5;
#line 436
  if (pgpopts->d) {
#line 436
    tmp___6 = 1;
  } else {
#line 436
    tmp___6 = 0;
  }
#line 436
  err += tmp___6;
#line 437
  if (pgpopts->b) {
#line 437
    tmp___7 = 1;
  } else {
#line 437
    tmp___7 = 0;
  }
#line 437
  err += tmp___7;
#line 438
  if (pgpopts->p) {
#line 438
    tmp___8 = 1;
  } else {
#line 438
    tmp___8 = 0;
  }
#line 438
  err += tmp___8;
#line 439
  if (pgpopts->f) {
#line 439
    tmp___9 = 1;
  } else {
#line 439
    tmp___9 = 0;
  }
#line 439
  err += tmp___9;
#line 442
  if (pgpopts->t) {
#line 442
    tmp___10 = 1;
  } else {
#line 442
    tmp___10 = 0;
  }
#line 442
  err += tmp___10;
#line 449
  return (err);
}
}
#line 454 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_asciiarmor(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 459
  if (pgpopts->a) {
    {
#line 460
    argv_factory_add(af, (char *)"--armor");
    }
  } else
#line 459
  if (pgpopts->asciiarmor) {
    {
#line 460
    argv_factory_add(af, (char *)"--armor");
    }
  } else {
    {
#line 462
    argv_factory_add(af, (char *)"--no-armor");
    }
  }
#line 463
  return;
}
}
#line 467 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_textmode(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 472
  if (pgpopts->t) {
    {
#line 473
    argv_factory_add(af, (char *)"--textmode");
    }
  }
#line 474
  pgpopts->t = (char)0;
#line 475
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_force(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 484
  if (pgpopts->force == 1) {
    {
#line 485
    argv_factory_add(af, (char *)"--yes");
    }
  } else
#line 486
  if (pgpopts->force == 0) {
    {
#line 487
    argv_factory_add(af, (char *)"--no");
    }
  }
#line 488
  return;
}
}
#line 492 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_batchmode(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 497
  if (pgpopts->batchmode) {
    {
#line 499
    argv_factory_add(af, (char *)"--batch");
#line 500
    argv_factory_add(af, (char *)"--always-trust");
#line 501
    build_force(af, pgpopts);
    }
  } else {
    {
#line 504
    argv_factory_add(af, (char *)"--no-batch");
    }
  }
#line 505
  return;
}
}
#line 508 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_comment(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 513
  if (pgpopts->comment) {
    {
#line 515
    argv_factory_add(af, (char *)"--comment");
#line 516
    argv_factory_add(af, pgpopts->comment);
    }
  }
#line 518
  return;
}
}
#line 521 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_compress(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 526
  if (pgpopts->compress == 0) {
    {
#line 528
    argv_factory_add(af, (char *)"-z");
#line 529
    argv_factory_add(af, (char *)"0");
    }
  } else
#line 531
  if (pgpopts->compress == 1) {
    {
#line 533
    argv_factory_add(af, (char *)"-z");
#line 534
    argv_factory_add(af, (char *)"6");
    }
  }
#line 536
  return;
}
}
#line 539 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_certdepth(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 544
  if (pgpopts->completesneeded) {
    {
#line 546
    argv_factory_add(af, (char *)"--completes-needed");
#line 547
    argv_factory_add(af, pgpopts->completesneeded);
    }
  }
#line 549
  if (pgpopts->marginalsneeded) {
    {
#line 551
    argv_factory_add(af, (char *)"--marinals-needed");
#line 552
    argv_factory_add(af, pgpopts->marginalsneeded);
    }
  }
#line 554
  if (pgpopts->certdepth) {
    {
#line 556
    argv_factory_add(af, (char *)"--max-cert-depth");
#line 557
    argv_factory_add(af, pgpopts->certdepth);
    }
  }
#line 559
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_localuser(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 567
  if (pgpopts->localuserid) {
    {
#line 569
    argv_factory_add(af, (char *)"--local-user");
#line 570
    argv_factory_add(af, pgpopts->localuserid);
    }
  }
#line 572
  return;
}
}
#line 575 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_charset(ArgvFactory *af , Pgpopts *pgpopts ) 
{ 


  {
#line 580
  if (pgpopts->charset) {
    {
#line 582
    argv_factory_add(af, (char *)"--charset");
#line 583
    argv_factory_add(af, pgpopts->charset);
    }
  }
#line 585
  return;
}
}
#line 588 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static int build_input(ArgvFactory *af , Pgpopts *opts ) 
{ 
  int implicit_filter ;
  int tmp ;

  {
#line 590
  if (! opts->stdinisterminal) {
#line 590
    if (opts->args_used == 0UL) {
#line 590
      tmp = 1;
    } else {
#line 590
      tmp = 0;
    }
  } else {
#line 590
    tmp = 0;
  }
#line 590
  implicit_filter = tmp;
#line 592
  if (! opts->f) {
#line 592
    if (! implicit_filter) {
#line 592
      if (opts->args_used == 0UL) {
        {
#line 594
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Filename required.\n");
        }
#line 595
        return (-1);
      }
    }
  }
#line 598
  if (! opts->f) {
#line 598
    if (! implicit_filter) {
      {
#line 599
      argv_factory_add(af, *(opts->args + 0));
      }
    }
  }
#line 601
  opts->f = (char)0;
#line 603
  return (0);
}
}
#line 607 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_output(ArgvFactory *af , Pgpopts *opts ) 
{ 
  int implicit_filter ;
  int tmp ;
  char const   *tmp___0 ;
  char *s ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 609
  if (! opts->stdinisterminal) {
#line 609
    if (opts->args_used == 0UL) {
#line 609
      tmp = 1;
    } else {
#line 609
      tmp = 0;
    }
  } else {
#line 609
    tmp = 0;
  }
#line 609
  implicit_filter = tmp;
#line 615
  if (opts->f) {
    {
#line 617
    argv_factory_add(af, (char *)"--set-filename");
#line 618
    argv_factory_add(af, (char *)"stdin");
    }
  } else
#line 615
  if (implicit_filter) {
    {
#line 617
    argv_factory_add(af, (char *)"--set-filename");
#line 618
    argv_factory_add(af, (char *)"stdin");
    }
  }
#line 621
  if (opts->outputfile) {
    {
#line 623
    argv_factory_add(af, (char *)"--output");
#line 624
    argv_factory_add(af, opts->outputfile);
    }
  } else
#line 627
  if (! opts->f) {
#line 628
    if (implicit_filter) {
      {
#line 630
      argv_factory_add(af, (char *)"--output");
      }
#line 631
      if (opts->a) {
#line 631
        tmp___0 = "stdin.asc";
      } else
#line 631
      if (opts->asciiarmor) {
#line 631
        tmp___0 = "stdin.asc";
      } else {
#line 631
        tmp___0 = "stdin.pgp";
      }
      {
#line 631
      argv_factory_add(af, (char *)tmp___0);
      }
    } else
#line 633
    if (opts->args_used != 0UL) {
      {
#line 635
      tmp___1 = strlen((char const   *)*(opts->args + 0));
#line 635
      tmp___2 = malloc((tmp___1 + 5UL) * sizeof(char ));
#line 635
      s = (char *)tmp___2;
#line 637
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)*(opts->args + 0));
      }
#line 639
      if (opts->a) {
        {
#line 640
        strcat((char */* __restrict  */)s, (char const   */* __restrict  */)".asc");
        }
      } else
#line 639
      if (opts->asciiarmor) {
        {
#line 640
        strcat((char */* __restrict  */)s, (char const   */* __restrict  */)".asc");
        }
      } else
#line 641
      if (opts->s) {
#line 641
        if (opts->b) {
          {
#line 642
          strcat((char */* __restrict  */)s, (char const   */* __restrict  */)".sig");
          }
        } else {
          {
#line 644
          strcat((char */* __restrict  */)s, (char const   */* __restrict  */)".pgp");
          }
        }
      } else {
        {
#line 644
        strcat((char */* __restrict  */)s, (char const   */* __restrict  */)".pgp");
        }
      }
      {
#line 646
      argv_factory_add(af, (char *)"--output");
#line 647
      argv_factory_add(af, s);
      }
    }
  }
#line 649
  return;
}
}
#line 652 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_passfd(ArgvFactory *af , Pgpopts *opts ) 
{ 
  char *arg ;
  void *tmp ;

  {
#line 654
  if (opts->passphrase_pipe[0] != -1) {
    {
#line 656
    tmp = malloc((size_t )16);
#line 656
    arg = (char *)tmp;
#line 657
    sprintf((char */* __restrict  */)arg, (char const   */* __restrict  */)"%d", opts->passphrase_pipe[0]);
#line 658
    argv_factory_add(af, (char *)"--passphrase-fd");
#line 659
    argv_factory_add(af, arg);
    }
  }
#line 661
  return;
}
}
#line 678 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
static void build_keyrings(ArgvFactory *af , Pgpopts *opts ) 
{ 


  {
#line 680
  if (opts->pubring) {
    {
#line 682
    argv_factory_add(af, (char *)"--no-default-keyring");
#line 683
    argv_factory_add(af, (char *)"--keyring");
#line 684
    argv_factory_add(af, opts->pubring);
    }
  }
#line 687
  if (opts->secring) {
    {
#line 689
    argv_factory_add(af, (char *)"--secret-keyring");
#line 690
    argv_factory_add(af, opts->secring);
    }
  }
#line 692
  return;
}
}
#line 715 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
char **pgpopts_build_argv(Pgpopts *pgpopts ) 
{ 
  Pgpopts opts ;
  ArgvFactory af ;
  int tmp ;
  char *file_base ;
  char *tmp___0 ;
  char *file_ext ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int null_fd ;
  int tmp___5 ;
  int tmp___6 ;
  int textmode ;
  int tmp___7 ;
  int i ;
  char *id ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 722
  opts = *pgpopts;
#line 724
  argv_factory_init(& af);
#line 725
  argv_factory_add(& af, (char *)"/usr/bin/gpg");
  }
#line 727
  if (opts.k) {
    {
#line 730
    opts.k = (char )((int )opts.k - 1);
#line 732
    build_batchmode(& af, & opts);
#line 733
    build_force(& af, & opts);
#line 734
    build_certdepth(& af, & opts);
    }
#line 736
    if ((int )opts.g == 1) {
      {
#line 738
      argv_factory_add(& af, (char *)"--gen-key");
#line 739
      opts.g = (char)0;
      }
#line 741
      if (opts.args_used > 0UL) {
        {
#line 742
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Info: The optional keybits argument \'%s\' is not used.\n",
                *(opts.args + 0));
        }
      }
    } else
#line 744
    if ((int )opts.x == 0) {
#line 744
      if ((int )opts.a == 1) {
        {
#line 746
        argv_factory_add(& af, (char *)"--import");
#line 747
        opts.a = (char)0;
        }
#line 748
        if (! opts.f) {
#line 750
          if (opts.args_used == 0UL) {
            {
#line 752
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Keyfile required.\n");
            }
#line 753
            return ((char **)((void *)0));
          }
#line 756
          if (opts.args_used > 1UL) {
            {
#line 758
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
            }
#line 759
            return ((char **)((void *)0));
          }
          {
#line 762
          argv_factory_add(& af, *(opts.args + 0));
          }
        } else {
#line 765
          opts.f = (char)0;
        }
      } else {
#line 744
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 767
    if ((int )opts.x == 1) {
      {
#line 769
      build_asciiarmor(& af, & opts);
#line 770
      argv_factory_add(& af, (char *)"--export");
#line 771
      opts.x = (char)0;
      }
#line 772
      if (opts.args_used == 0UL) {
        {
#line 774
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: User-ID required for exporting a key.\n");
        }
#line 775
        return ((char **)((void *)0));
      }
#line 777
      if (opts.f) {
#line 779
        opts.f = (char)0;
#line 780
        if (opts.args_used == 1UL) {
          {
#line 781
          argv_factory_add(& af, *(opts.args + 0));
          }
        } else {
          {
#line 784
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
          }
#line 785
          return ((char **)((void *)0));
        }
      } else {
#line 790
        if (opts.args_used < 2UL) {
          {
#line 792
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: File to store exported key required.\n");
          }
#line 793
          return ((char **)((void *)0));
        }
#line 796
        if (opts.args_used > 2UL) {
          {
#line 798
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
          }
#line 799
          return ((char **)((void *)0));
        }
        {
#line 802
        argv_factory_add(& af, (char *)"--output");
#line 803
        argv_factory_add(& af, *(opts.args + 1));
#line 804
        argv_factory_add(& af, *(opts.args + 0));
        }
      }
    } else
#line 807
    if (opts.v) {
#line 809
      if ((int )opts.v >= 2) {
        {
#line 810
        argv_factory_add(& af, (char *)"--verbose");
        }
      }
#line 812
      if ((int )opts.c == 0) {
        {
#line 813
        argv_factory_add(& af, (char *)"--list-keys");
        }
      } else {
        {
#line 816
        argv_factory_add(& af, (char *)"--fingerprint");
#line 817
        opts.c = (char)0;
        }
      }
#line 820
      if (opts.args_used == 1UL) {
        {
#line 821
        argv_factory_add(& af, *(opts.args + 0));
        }
      }
#line 823
      if (opts.args_used >= 2UL) {
        {
#line 825
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
        }
#line 826
        return ((char **)((void *)0));
      }
    } else
#line 829
    if (opts.c) {
      {
#line 831
      argv_factory_add(& af, (char *)"--check-sigs");
#line 832
      opts.c = (char)0;
      }
#line 834
      if (opts.args_used == 1UL) {
        {
#line 835
        argv_factory_add(& af, *(opts.args + 0));
        }
      }
#line 837
      if (opts.args_used >= 2UL) {
        {
#line 839
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
        }
#line 840
        return ((char **)((void *)0));
      }
    } else
#line 843
    if ((int )opts.r == 1) {
#line 843
      if ((int )opts.s == 0) {
        {
#line 845
        opts.r = (char)0;
#line 846
        argv_factory_add(& af, (char *)"--delete-key");
        }
#line 848
        if (opts.args_used == 0UL) {
          {
#line 850
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: User ID required for deleting a key.\n");
          }
#line 851
          return ((char **)((void *)0));
        }
#line 854
        if (opts.args_used >= 2UL) {
          {
#line 856
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
          }
#line 857
          return ((char **)((void *)0));
        }
        {
#line 860
        argv_factory_add(& af, *(opts.args + 0));
        }
      } else {
#line 843
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 862
    if ((int )opts.r == 1) {
#line 862
      if ((int )opts.s == 1) {
        {
#line 864
        opts.r = (char)0;
#line 865
        opts.s = (char)0;
#line 867
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: GnuPG doesn\'t support removing a key signature.\n");
        }
#line 868
        return ((char **)((void *)0));
      } else {
#line 862
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 870
    if ((int )opts.r == 0) {
#line 870
      if ((int )opts.s == 1) {
        {
#line 872
        opts.s = (char)0;
#line 873
        argv_factory_add(& af, (char *)"--edit-key");
        }
#line 875
        if (opts.args_used == 0UL) {
          {
#line 877
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: User ID required for signing a key.\n");
          }
#line 878
          return ((char **)((void *)0));
        }
#line 881
        if (opts.args_used >= 2UL) {
          {
#line 883
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
          }
#line 884
          return ((char **)((void *)0));
        }
        {
#line 887
        argv_factory_add(& af, *(opts.args + 0));
#line 888
        argv_factory_add(& af, (char *)"sign");
#line 889
        argv_factory_add(& af, (char *)"quit");
        }
      } else {
#line 870
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 892
    if (opts.e) {
      {
#line 894
      argv_factory_add(& af, (char *)"--edit-key");
#line 895
      opts.e = (char)0;
      }
#line 897
      if (opts.args_used == 0UL) {
        {
#line 899
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: User ID required for editing a key.\n");
        }
#line 900
        return ((char **)((void *)0));
      }
#line 903
      if (opts.args_used >= 2UL) {
        {
#line 905
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
        }
#line 906
        return ((char **)((void *)0));
      }
      {
#line 909
      argv_factory_add(& af, *(opts.args + 0));
      }
    } else
#line 911
    if (opts.d) {
      {
#line 913
      argv_factory_add(& af, (char *)"--gen-revoke");
#line 914
      opts.d = (char)0;
      }
#line 916
      if (opts.args_used == 0UL) {
        {
#line 918
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: User ID required for generating key revokation certificate.\n");
        }
#line 919
        return ((char **)((void *)0));
      }
#line 922
      if (opts.args_used >= 2UL) {
        {
#line 924
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Keyring argument not supported.\n");
        }
#line 925
        return ((char **)((void *)0));
      }
      {
#line 928
      argv_factory_add(& af, *(opts.args + 0));
      }
    } else {
      {
#line 932
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid key command option\n");
      }
#line 933
      return ((char **)((void *)0));
    }
  } else
#line 936
  if ((int )opts.s == 0) {
#line 936
    if ((int )opts.e == 0) {
#line 936
      if ((int )opts.c == 0) {
        {
#line 938
        build_batchmode(& af, & opts);
        }
#line 940
        if (opts.a) {
#line 940
          goto _L___5;
        } else
#line 940
        if (opts.asciiarmor) {
          _L___5: /* CIL Label */ 
          {
#line 942
          build_comment(& af, & opts);
#line 943
          build_compress(& af, & opts);
#line 944
          build_charset(& af, & opts);
#line 945
          build_output(& af, & opts);
#line 946
          argv_factory_add(& af, (char *)"--armor");
#line 947
          argv_factory_add(& af, (char *)"--store");
#line 948
          tmp = build_input(& af, & opts);
          }
#line 948
          if (tmp) {
#line 949
            return ((char **)((void *)0));
          }
        } else {
          {
#line 953
          opts.d = (char)0;
#line 954
          opts.p = (char)0;
#line 956
          build_certdepth(& af, & opts);
#line 957
          build_keyrings(& af, & opts);
          }
#line 965
          if (opts.args_used == 0UL) {
            {
#line 971
            build_passfd(& af, & opts);
            }
#line 973
            if (opts.outputfile) {
              {
#line 975
              argv_factory_add(& af, (char *)"--output");
#line 976
              argv_factory_add(& af, opts.outputfile);
              }
            }
#line 979
            if (opts.f) {
              {
#line 981
              opts.f = (char)0;
#line 982
              argv_factory_add(& af, (char *)"--decrypt");
              }
            } else
#line 984
            if (opts.stdinisterminal) {
              {
#line 986
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Filename for decryption needed.\n");
              }
#line 987
              return ((char **)((void *)0));
            }
          } else
#line 990
          if (opts.args_used >= 2UL) {
            {
#line 999
            argv_factory_add(& af, (char *)"--verify");
#line 1000
            argv_factory_add(& af, *(opts.args + 0));
#line 1001
            argv_factory_add(& af, *(opts.args + 1));
            }
          } else {
            {
#line 1011
            tmp___0 = strdup((char const   *)*(opts.args + 0));
#line 1011
            file_base = tmp___0;
#line 1012
            tmp___1 = strrchr((char const   *)file_base, '.');
#line 1012
            file_ext = tmp___1;
            }
#line 1014
            if (file_ext) {
#line 1015
              tmp___2 = file_ext;
#line 1015
              file_ext ++;
#line 1015
              *tmp___2 = (char)0;
            }
#line 1017
            if (file_ext) {
              {
#line 1017
              tmp___6 = strcasecmp((char const   *)file_ext, "sig");
              }
#line 1017
              if (tmp___6) {
#line 1017
                goto _L___4;
              } else {
                {
#line 1024
                argv_factory_add(& af, (char *)"--verify");
#line 1025
                argv_factory_add(& af, *(opts.args + 0));
#line 1026
                argv_factory_add(& af, file_base);
                }
              }
            } else
            _L___4: /* CIL Label */ 
#line 1028
            if (file_ext) {
              {
#line 1028
              tmp___5 = strcasecmp((char const   *)file_ext, "asc");
              }
#line 1028
              if (tmp___5) {
#line 1028
                goto _L___3;
              } else {
                {
#line 1036
                tmp___3 = guess_armor_type(*(opts.args + 0));
                }
                {
#line 1038
                if (tmp___3 == 4) {
#line 1038
                  goto case_4;
                }
#line 1048
                if (tmp___3 == 3) {
#line 1048
                  goto case_3;
                }
#line 1065
                goto switch_default;
                case_4: /* CIL Label */ 
                {
#line 1043
                argv_factory_add(& af, (char *)"--verify");
#line 1044
                argv_factory_add(& af, *(opts.args + 0));
#line 1045
                argv_factory_add(& af, file_base);
                }
#line 1046
                goto switch_break;
                case_3: /* CIL Label */ 
#line 1052
                if (opts.outputfile) {
                  {
#line 1054
                  argv_factory_add(& af, (char *)"--output");
#line 1055
                  argv_factory_add(& af, opts.outputfile);
                  }
                }
#line 1057
                if (opts.f) {
                  {
#line 1059
                  opts.f = (char)0;
#line 1060
                  argv_factory_add(& af, (char *)"--decrypt");
                  }
                }
                {
#line 1062
                argv_factory_add(& af, *(opts.args + 0));
                }
#line 1063
                goto switch_break;
                switch_default: /* CIL Label */ 
                {
#line 1072
                tmp___4 = access((char const   *)file_base, 4);
                }
#line 1072
                if (tmp___4 == 0) {
                  {
#line 1075
                  argv_factory_add(& af, (char *)"--verify");
#line 1076
                  argv_factory_add(& af, *(opts.args + 0));
#line 1077
                  argv_factory_add(& af, file_base);
                  }
                } else {
#line 1081
                  if (opts.outputfile) {
                    {
#line 1083
                    argv_factory_add(& af, (char *)"--output");
#line 1084
                    argv_factory_add(& af, opts.outputfile);
                    }
                  }
#line 1087
                  if (opts.f) {
                    {
#line 1089
                    opts.f = (char)0;
#line 1090
                    argv_factory_add(& af, (char *)"--decrypt");
                    }
                  }
                  {
#line 1093
                  argv_factory_add(& af, *(opts.args + 0));
                  }
                }
                switch_break: /* CIL Label */ ;
                }
              }
            } else {
              _L___3: /* CIL Label */ 
#line 1108
              if (opts.outputfile) {
                {
#line 1110
                argv_factory_add(& af, (char *)"--output");
#line 1111
                argv_factory_add(& af, opts.outputfile);
                }
              }
#line 1114
              if (opts.f) {
                {
#line 1116
                opts.f = (char)0;
#line 1117
                argv_factory_add(& af, (char *)"--decrypt");
                }
              }
              {
#line 1120
              argv_factory_add(& af, *(opts.args + 0));
#line 1127
              null_fd = open("/dev/null", 2);
              }
#line 1127
              if (null_fd == -1) {
                {
#line 1129
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open /dev/null\n");
                }
#line 1130
                return ((char **)((void *)0));
              }
              {
#line 1132
              close(0);
#line 1133
              dup2(null_fd, 0);
#line 1134
              close(null_fd);
              }
            }
          }
        }
      } else {
#line 936
        goto _L___14;
      }
    } else {
#line 936
      goto _L___14;
    }
  } else {
    _L___14: /* CIL Label */ 
    {
#line 1141
    textmode = (int )opts.t;
#line 1143
    build_textmode(& af, & opts);
#line 1144
    build_asciiarmor(& af, & opts);
#line 1145
    build_batchmode(& af, & opts);
#line 1146
    build_force(& af, & opts);
#line 1147
    build_comment(& af, & opts);
#line 1148
    build_compress(& af, & opts);
#line 1149
    build_charset(& af, & opts);
#line 1150
    build_passfd(& af, & opts);
#line 1151
    build_keyrings(& af, & opts);
    }
#line 1153
    if ((int )opts.c == 1) {
#line 1153
      if ((int )opts.e == 0) {
#line 1153
        if ((int )opts.s == 0) {
          {
#line 1155
          opts.c = (char)0;
#line 1156
          build_output(& af, & opts);
#line 1157
          argv_factory_add(& af, (char *)"--symmetric");
#line 1158
          tmp___7 = build_input(& af, & opts);
          }
#line 1158
          if (tmp___7) {
#line 1159
            return ((char **)((void *)0));
          }
        } else {
#line 1153
          goto _L___12;
        }
      } else {
#line 1153
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 1161
    if ((int )opts.c == 0) {
#line 1161
      if ((int )opts.e == 1) {
        {
#line 1165
        opts.e = (char)0;
#line 1166
        build_certdepth(& af, & opts);
#line 1167
        build_output(& af, & opts);
        }
#line 1169
        if (! opts.f) {
#line 1169
          if (opts.args_used != 0UL) {
#line 1169
            i = 1;
          } else {
#line 1169
            i = 0;
          }
        } else {
#line 1169
          i = 0;
        }
        {
#line 1169
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1169
          if (! *(opts.args + i)) {
#line 1169
            goto while_break;
          }
          {
#line 1171
          argv_factory_add(& af, (char *)"--recipient");
#line 1172
          argv_factory_add(& af, *(opts.args + i));
#line 1169
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1175
        if (opts.encrypttoself) {
          {
#line 1177
          argv_factory_add(& af, (char *)"--encrypt-to");
          }
#line 1178
          if (opts.localuserid) {
            {
#line 1179
            argv_factory_add(& af, opts.localuserid);
            }
          } else {
            {
#line 1182
            tmp___8 = get_defaultkey();
#line 1182
            id = tmp___8;
            }
#line 1183
            if (! id) {
              {
#line 1185
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Can\'t get default key user id.\n");
              }
#line 1186
              return ((char **)((void *)0));
            }
            {
#line 1188
            argv_factory_add(& af, id);
            }
          }
        }
#line 1192
        if (opts.s) {
          {
#line 1194
          opts.s = (char)0;
#line 1195
          build_localuser(& af, & opts);
#line 1196
          argv_factory_add(& af, (char *)"--sign");
          }
        }
        {
#line 1199
        argv_factory_add(& af, (char *)"--encrypt");
#line 1201
        tmp___9 = build_input(& af, & opts);
        }
#line 1201
        if (tmp___9) {
#line 1202
          return ((char **)((void *)0));
        }
#line 1204
        opts.f = (char)0;
      } else {
#line 1161
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 1206
    if ((int )opts.c == 0) {
#line 1206
      if ((int )opts.e == 0) {
#line 1206
        if ((int )opts.s == 1) {
          {
#line 1208
          build_localuser(& af, & opts);
#line 1209
          build_output(& af, & opts);
#line 1211
          opts.s = (char)0;
          }
#line 1213
          if (opts.clearsign) {
#line 1213
            if (opts.a) {
#line 1213
              goto _L___9;
            } else
#line 1213
            if (opts.asciiarmor) {
              _L___9: /* CIL Label */ 
#line 1213
              if (textmode) {
#line 1213
                if ((int )opts.b == 0) {
                  {
#line 1215
                  argv_factory_add(& af, (char *)"--escape-from");
#line 1216
                  argv_factory_add(& af, (char *)"--clearsign");
                  }
                } else {
#line 1213
                  goto _L___8;
                }
              } else {
#line 1213
                goto _L___8;
              }
            } else {
#line 1213
              goto _L___8;
            }
          } else
          _L___8: /* CIL Label */ 
#line 1218
          if ((int )opts.b == 1) {
            {
#line 1220
            argv_factory_add(& af, (char *)"--detach-sign");
#line 1221
            opts.b = (char)0;
            }
          } else {
            {
#line 1224
            argv_factory_add(& af, (char *)"--sign");
            }
          }
          {
#line 1226
          tmp___10 = build_input(& af, & opts);
          }
#line 1226
          if (tmp___10) {
#line 1227
            return ((char **)((void *)0));
          }
        } else {
          {
#line 1231
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unknown command option combination.\n");
          }
#line 1232
          return ((char **)((void *)0));
        }
      } else {
        {
#line 1231
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unknown command option combination.\n");
        }
#line 1232
        return ((char **)((void *)0));
      }
    } else {
      {
#line 1231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unknown command option combination.\n");
      }
#line 1232
      return ((char **)((void *)0));
    }
  }
  {
#line 1236
  tmp___11 = check_opts_used(& opts);
  }
#line 1236
  if (tmp___11) {
    {
#line 1238
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid options\n");
    }
#line 1239
    return ((char **)((void *)0));
  }
#line 1242
  return (af.argv);
}
}
#line 1273 "/home/wheatley/newnew/temp/pgpgpg-0.13/pgpopts.c"
int pgpopts_parse(Pgpopts *pgpopts , int argc , char **argv ) 
{ 
  int result ;
  char *opt_format ;
  int tmp ;

  {
#line 1283
  opt_format = (char *)"hkesabcdpo:@:z:u:fwmt";
  {
#line 1284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1284
    result = mygetopt(argc, (char * const  *)argv, (char const   *)opt_format);
    }
#line 1284
    if (! (result != -1)) {
#line 1284
      goto while_break;
    }
    {
#line 1287
    if (result == 1) {
#line 1287
      goto case_1;
    }
#line 1297
    if (result == 107) {
#line 1297
      goto case_107;
    }
#line 1302
    if (result == 115) {
#line 1302
      goto case_115;
    }
#line 1308
    if (result == 101) {
#line 1308
      goto case_101;
    }
#line 1314
    if (result == 99) {
#line 1314
      goto case_99;
    }
#line 1320
    if (result == 100) {
#line 1320
      goto case_100;
    }
#line 1325
    if (result == 112) {
#line 1325
      goto case_112;
    }
#line 1330
    if (result == 122) {
#line 1330
      goto case_122;
    }
#line 1335
    if (result == 111) {
#line 1335
      goto case_111;
    }
#line 1336
    if (result == 117) {
#line 1336
      goto case_117;
    }
#line 1338
    if (result == 103) {
#line 1338
      goto case_103;
    }
#line 1339
    if (result == 97) {
#line 1339
      goto case_97;
    }
#line 1340
    if (result == 120) {
#line 1340
      goto case_120;
    }
#line 1341
    if (result == 118) {
#line 1341
      goto case_118;
    }
#line 1342
    if (result == 114) {
#line 1342
      goto case_114;
    }
#line 1343
    if (result == 98) {
#line 1343
      goto case_98;
    }
#line 1344
    if (result == 102) {
#line 1344
      goto case_102;
    }
#line 1345
    if (result == 119) {
#line 1345
      goto case_119;
    }
#line 1346
    if (result == 109) {
#line 1346
      goto case_109;
    }
#line 1347
    if (result == 116) {
#line 1347
      goto case_116;
    }
#line 1349
    if (result == 64) {
#line 1349
      goto case_64;
    }
#line 1353
    if (result == 63) {
#line 1353
      goto case_63;
    }
#line 1358
    if (result == 104) {
#line 1358
      goto case_104;
    }
#line 1363
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1288
    if ((int )*myoptarg == 43) {
      {
#line 1290
      tmp = parse_longopt(pgpopts, (char const   *)(myoptarg + 1));
      }
#line 1290
      if (tmp) {
#line 1291
        return (-1);
      }
    } else {
      {
#line 1294
      add_argument(pgpopts, myoptarg);
      }
    }
#line 1295
    goto switch_break;
    case_107: /* CIL Label */ 
#line 1298
    opt_format = (char *)"gafxcresdvu:";
#line 1299
    pgpopts->k = (char )((int )pgpopts->k + 1);
#line 1300
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1303
    pgpopts->s = (char )((int )pgpopts->s + 1);
#line 1304
    if (! pgpopts->k) {
#line 1305
      if (pgpopts->e) {
#line 1305
        opt_format = (char *)"atfo:@:z:u:wm";
      } else {
#line 1305
        opt_format = (char *)"aetfbo:z:u:wm";
      }
    }
#line 1306
    goto switch_break;
    case_101: /* CIL Label */ 
#line 1309
    pgpopts->e = (char )((int )pgpopts->e + 1);
#line 1310
    if (! pgpopts->k) {
#line 1311
      if (pgpopts->s) {
#line 1311
        opt_format = (char *)"atfo:@:z:u:wm";
      } else {
#line 1311
        opt_format = (char *)"astfo:@:z:u:wm";
      }
    }
#line 1312
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1315
    pgpopts->c = (char )((int )pgpopts->c + 1);
#line 1316
    if (! pgpopts->k) {
#line 1317
      opt_format = (char *)"atfo:z:u:wm";
    }
#line 1318
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1321
    pgpopts->d = (char )((int )pgpopts->d + 1);
#line 1322
    opt_format = (char *)"pdfo:@:z:";
#line 1323
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1326
    pgpopts->p = (char )((int )pgpopts->p + 1);
#line 1327
    opt_format = (char *)"pdfo:@:z:";
#line 1328
    goto switch_break;
    case_122: /* CIL Label */ 
#line 1331
    if (! pgpopts->passphrase) {
#line 1332
      pgpopts->passphrase = myoptarg;
    }
#line 1333
    goto switch_break;
    case_111: /* CIL Label */ 
#line 1335
    pgpopts->outputfile = myoptarg;
#line 1335
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1336
    pgpopts->localuserid = myoptarg;
#line 1336
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1338
    pgpopts->g = (char )((int )pgpopts->g + 1);
#line 1338
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1339
    pgpopts->a = (char )((int )pgpopts->a + 1);
#line 1339
    goto switch_break;
    case_120: /* CIL Label */ 
#line 1340
    pgpopts->x = (char )((int )pgpopts->x + 1);
#line 1340
    goto switch_break;
    case_118: /* CIL Label */ 
#line 1341
    pgpopts->v = (char )((int )pgpopts->v + 1);
#line 1341
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1342
    pgpopts->r = (char )((int )pgpopts->r + 1);
#line 1342
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1343
    pgpopts->b = (char )((int )pgpopts->b + 1);
#line 1343
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1344
    pgpopts->f = (char )((int )pgpopts->f + 1);
#line 1344
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1345
    pgpopts->w = (char )((int )pgpopts->w + 1);
#line 1345
    goto switch_break;
    case_109: /* CIL Label */ 
#line 1346
    pgpopts->m = (char )((int )pgpopts->m + 1);
#line 1346
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1347
    pgpopts->t = (char )((int )pgpopts->t + 1);
#line 1347
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 1350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Option `-@\' not supported.\n");
    }
#line 1351
    return (-1);
    case_63: /* CIL Label */ 
    {
#line 1354
    printf((char const   */* __restrict  */)"Invalid option: -%c\n", myoptopt);
    }
#line 1355
    return (-1);
#line 1356
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1359
    printf((char const   */* __restrict  */)"Help not supported.\n");
    }
#line 1360
    return (-1);
#line 1361
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Unhandled option: -%c\n",
            result);
    }
#line 1365
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1368
  return (0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 38 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.h"
void argv_factory_release(ArgvFactory *af ) ;
#line 40 "/home/wheatley/newnew/temp/pgpgpg-0.13/defaultkey.c"
char *get_defaultkey(void) 
{ 
  char buffer[1024] ;
  ArgvFactory af ;
  pid_t child_pid ;
  int child_status ;
  int child_pipe[2] ;
  int dev_null_fd ;
  FILE *in ;
  char *defaultid ;
  int err ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i ;
  char *tmp___29 ;
  char *end ;
  int tmp___30 ;
  char *tmp___31 ;

  {
  {
#line 50
  defaultid = (char *)((void *)0);
#line 51
  err = 0;
#line 53
  argv_factory_init(& af);
#line 54
  argv_factory_add(& af, (char *)"/usr/bin/gpg");
#line 55
  argv_factory_add(& af, (char *)"--with-colons");
#line 56
  argv_factory_add(& af, (char *)"--batch");
#line 57
  argv_factory_add(& af, (char *)"--quiet");
#line 58
  argv_factory_add(& af, (char *)"--no-verbose");
#line 59
  argv_factory_add(& af, (char *)"--list-secret-keys");
#line 61
  tmp = pipe((int *)(child_pipe));
  }
#line 61
  if (tmp) {
    {
#line 63
    perror("Can\'t setup a pipe for gpg.");
    }
#line 64
    return ((char *)((void *)0));
  }
  {
#line 67
  dev_null_fd = open("/dev/null", 2);
  }
#line 67
  if (dev_null_fd == -1) {
    {
#line 69
    perror("Can\'t open /dev/null for redirect");
    }
#line 70
    return ((char *)((void *)0));
  }
  {
#line 73
  child_pid = fork();
  }
  {
#line 75
  if (child_pid == -1) {
#line 75
    goto case_neg_1;
  }
#line 79
  if (child_pid == 0) {
#line 79
    goto case_0;
  }
#line 98
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 76
  perror("Can\'t fork to execute gpg");
  }
#line 77
  return ((char *)((void *)0));
  case_0: /* CIL Label */ 
  {
#line 80
  tmp___2 = close(0);
  }
#line 80
  if (tmp___2 == -1) {
#line 80
    tmp___1 = 1;
  } else {
#line 80
    tmp___1 = 0;
  }
  {
#line 80
  err += tmp___1;
#line 81
  tmp___5 = close(1);
  }
#line 81
  if (tmp___5 == -1) {
#line 81
    tmp___4 = 1;
  } else {
#line 81
    tmp___4 = 0;
  }
  {
#line 81
  err += tmp___4;
#line 82
  tmp___8 = close(2);
  }
#line 82
  if (tmp___8 == -1) {
#line 82
    tmp___7 = 1;
  } else {
#line 82
    tmp___7 = 0;
  }
  {
#line 82
  err += tmp___7;
#line 83
  tmp___11 = dup2(dev_null_fd, 0);
  }
#line 83
  if (tmp___11 == -1) {
#line 83
    tmp___10 = 1;
  } else {
#line 83
    tmp___10 = 0;
  }
  {
#line 83
  err += tmp___10;
#line 84
  tmp___14 = dup2(child_pipe[1], 1);
  }
#line 84
  if (tmp___14 == -1) {
#line 84
    tmp___13 = 1;
  } else {
#line 84
    tmp___13 = 0;
  }
  {
#line 84
  err += tmp___13;
#line 85
  tmp___17 = dup2(dev_null_fd, 2);
  }
#line 85
  if (tmp___17 == -1) {
#line 85
    tmp___16 = 1;
  } else {
#line 85
    tmp___16 = 0;
  }
  {
#line 85
  err += tmp___16;
#line 86
  tmp___20 = close(child_pipe[0]);
  }
#line 86
  if (tmp___20 == -1) {
#line 86
    tmp___19 = 1;
  } else {
#line 86
    tmp___19 = 0;
  }
  {
#line 86
  err += tmp___19;
#line 87
  tmp___23 = close(child_pipe[1]);
  }
#line 87
  if (tmp___23 == -1) {
#line 87
    tmp___22 = 1;
  } else {
#line 87
    tmp___22 = 0;
  }
  {
#line 87
  err += tmp___22;
#line 88
  tmp___26 = close(dev_null_fd);
  }
#line 88
  if (tmp___26 == -1) {
#line 88
    tmp___25 = 1;
  } else {
#line 88
    tmp___25 = 0;
  }
#line 88
  err += tmp___25;
#line 89
  if (err) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in redirecting stdin, stdout and stderr. Can\'t execute gpg.");
    }
#line 92
    return ((char *)((void *)0));
  }
  {
#line 94
  execv((char const   *)*(af.argv + 0), (char * const  *)af.argv);
#line 95
  perror("Can\'t execute gpg (execv failed).");
  }
#line 96
  return ((char *)((void *)0));
  switch_default: /* CIL Label */ 
  {
#line 99
  close(child_pipe[1]);
#line 100
  close(dev_null_fd);
#line 101
  in = fdopen(child_pipe[0], "r");
  }
#line 101
  if (! in) {
    {
#line 103
    perror("Can\'t associate stream with pipe.");
    }
#line 104
    return ((char *)((void *)0));
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___31 = fgets((char */* __restrict  */)(buffer), 1024, (FILE */* __restrict  */)in);
    }
#line 106
    if (! tmp___31) {
#line 106
      goto while_break;
    }
    {
#line 108
    tmp___30 = strncmp((char const   *)(buffer), "sec:", (size_t )4);
    }
#line 108
    if (tmp___30) {
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 111
        tmp___27 = strchr((char const   *)(buffer), '\n');
        }
#line 111
        if (tmp___27) {
#line 111
          goto while_break___0;
        } else {
          {
#line 111
          tmp___28 = fgets((char */* __restrict  */)(buffer), 1024, (FILE */* __restrict  */)in);
          }
#line 111
          if (! tmp___28) {
#line 111
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 117
      defaultid = buffer;
#line 118
      i = 0;
      {
#line 118
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 118
        if (! (i < 4)) {
#line 118
          goto while_break___1;
        }
#line 119
        if (defaultid) {
          {
#line 119
          tmp___29 = strchr((char const   *)(defaultid + 1), ':');
#line 119
          defaultid = tmp___29;
          }
        } else {
#line 119
          defaultid = (char *)((void *)0);
        }
#line 118
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 121
      if (defaultid) {
        {
#line 125
        defaultid --;
#line 126
        *(defaultid + 0) = (char )'0';
#line 127
        *(defaultid + 1) = (char )'x';
#line 129
        end = strchr((char const   *)defaultid, ':');
        }
#line 129
        if (! end) {
          {
#line 131
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong keylist format.\n");
#line 132
          defaultid = (char *)((void *)0);
          }
#line 133
          goto while_break;
        }
        {
#line 135
        *end = (char)0;
#line 137
        defaultid = strdup((char const   *)defaultid);
        }
#line 138
        goto while_break;
      } else {
        {
#line 142
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong keylist format.\n");
        }
#line 143
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  fclose(in);
#line 150
  kill(child_pid, 2);
#line 151
  waitpid(child_pid, & child_status, 0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 154
  argv_factory_release(& af);
  }
#line 156
  return (defaultid);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 70 "/home/wheatley/newnew/temp/pgpgpg-0.13/main.c"
int main(int argc , char **argv ) 
{ 
  Pgpopts pgpopts ;
  char **gpg_argv ;
  pid_t child_pid ;
  int child_status ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *s ;
  int tmp___1 ;
  size_t tmp___2 ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;

  {
  {
#line 90
  pgpopts_init(& pgpopts);
#line 92
  tmp = pgpopts_parse(& pgpopts, argc, argv);
  }
#line 92
  if (tmp) {
#line 93
    return (255);
  }
  {
#line 95
  pgpopts.stdinisterminal = isatty(0);
  }
#line 98
  if (pgpopts.passphrase) {
    {
#line 100
    tmp___0 = pipe((int *)(pgpopts.passphrase_pipe));
    }
#line 100
    if (tmp___0) {
      {
#line 102
      perror("Error: Can\'t setup pipe for passphrase");
      }
#line 103
      return (255);
    }
  } else {
    {
#line 110
    s = getenv("PGPPASSFD");
    }
#line 110
    if (s) {
      {
#line 111
      pgpopts.passphrase_pipe[0] = atoi((char const   *)s);
      }
    } else {
      {
#line 112
      s = getenv("PGPPASS");
      }
#line 112
      if (s) {
        {
#line 114
        pgpopts.passphrase = s;
#line 116
        tmp___1 = pipe((int *)(pgpopts.passphrase_pipe));
        }
#line 116
        if (tmp___1) {
          {
#line 118
          perror("Error: Can\'t setup pipe for passphrase");
          }
#line 119
          return (255);
        }
      }
    }
  }
  {
#line 124
  gpg_argv = pgpopts_build_argv(& pgpopts);
  }
#line 124
  if (! gpg_argv) {
#line 125
    return (1);
  }
  {
#line 140
  child_pid = fork();
  }
  {
#line 142
  if (child_pid == -1) {
#line 142
    goto case_neg_1;
  }
#line 146
  if (child_pid == 0) {
#line 146
    goto case_0;
  }
#line 151
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 143
  perror("Error: Can\'t execute gnupg");
  }
#line 144
  return (255);
  case_0: /* CIL Label */ 
  {
#line 147
  execv((char const   *)*(gpg_argv + 0), (char * const  *)gpg_argv);
#line 148
  perror("Can\'t execute gpg (Gnu Privacy Guard)");
  }
#line 149
  return (255);
  switch_default: /* CIL Label */ 
#line 152
  if (pgpopts.passphrase) {
    {
#line 154
    tmp___2 = strlen((char const   *)pgpopts.passphrase);
#line 154
    write(pgpopts.passphrase_pipe[1], (void const   *)pgpopts.passphrase, tmp___2);
#line 155
    write(pgpopts.passphrase_pipe[1], (void const   *)"\n", (size_t )1);
#line 156
    close(pgpopts.passphrase_pipe[1]);
    }
  }
  {
#line 158
  waitpid(child_pid, & child_status, 0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 162
  __constr_expr_0.__in = child_status;
#line 162
  if (! ((__constr_expr_0.__i & 127) == 0)) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Execution of `gpg\' failed (Unknown reason).\n");
    }
#line 165
    return (255);
  }
#line 168
  __constr_expr_1.__in = child_status;
  {
#line 170
  if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
#line 170
    goto case_0___0;
  }
#line 174
  if ((__constr_expr_1.__i & 65280) >> 8 == 1) {
#line 174
    goto case_1;
  }
#line 179
  if ((__constr_expr_1.__i & 65280) >> 8 == 2) {
#line 179
    goto case_2;
  }
#line 184
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 171
  result = 0;
#line 172
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 175
  result = 30;
#line 176
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Bad signature, doesn\'t match file contents!\n");
  }
#line 177
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 180
  result = 11;
#line 181
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Can\'t find the right public key-- can\'t check signature integrity.\n");
  }
#line 182
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 185
  result = 0;
#line 186
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 189
  return (result);
}
}
#line 26 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.h"
char *mynextchar ;
#line 28
int myoptind ;
#line 27 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.c"
char *mynextchar  =    (char *)((void *)0);
#line 28 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.c"
char *myoptarg  =    (char *)((void *)0);
#line 29 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.c"
int myoptind  =    1;
#line 30 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.c"
int myoptopt  =    0;
#line 34 "/home/wheatley/newnew/temp/pgpgpg-0.13/mygetopt.c"
int mygetopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  char *option ;
  int tmp ;

  {
#line 43
  if (myoptind >= argc) {
#line 44
    return (-1);
  }
#line 46
  if (! mynextchar) {
#line 48
    mynextchar = (char *)*(argv + myoptind);
#line 50
    if ((int )*mynextchar == 45) {
#line 52
      mynextchar ++;
    } else {
#line 56
      myoptarg = mynextchar;
#line 57
      myoptind ++;
#line 58
      mynextchar = (char *)((void *)0);
#line 59
      return (1);
    }
  }
#line 63
  if ((int )*mynextchar == 58) {
#line 65
    myoptopt = ':';
#line 66
    return ('?');
  }
  {
#line 69
  option = strchr(optstring, (int )*mynextchar);
  }
#line 69
  if (option) {
#line 71
    if ((int )*(option + 1) == 58) {
#line 75
      if (*(mynextchar + 1)) {
#line 77
        myoptarg = mynextchar + 1;
#line 78
        mynextchar = (char *)((void *)0);
#line 79
        myoptind ++;
#line 80
        return ((int )*option);
      } else {
#line 84
        myoptind ++;
#line 84
        if (myoptind >= argc) {
#line 86
          myoptopt = (int )*option;
#line 87
          return (':');
        }
#line 90
        tmp = myoptind;
#line 90
        myoptind ++;
#line 90
        myoptarg = (char *)*(argv + tmp);
#line 91
        mynextchar = (char *)((void *)0);
#line 92
        return ((int )*option);
      }
    } else {
#line 99
      mynextchar ++;
#line 100
      if (! *mynextchar) {
#line 102
        mynextchar = (char *)((void *)0);
#line 103
        myoptind ++;
      }
#line 106
      return ((int )*option);
    }
  }
#line 110
  myoptopt = (int )*mynextchar;
#line 111
  return ('?');
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 39 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.h"
void argv_factory_append(ArgvFactory *dest , ArgvFactory *src ) ;
#line 39 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.c"
void argv_factory_init(ArgvFactory *af ) 
{ 
  void *tmp ;

  {
  {
#line 42
  af->size = (size_t )64;
#line 43
  af->used = (size_t )0;
#line 44
  tmp = malloc(af->size * sizeof(char *));
#line 44
  af->argv = (char **)tmp;
#line 46
  *(af->argv) = (char *)((void *)0);
  }
#line 47
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.c"
void argv_factory_release(ArgvFactory *af ) 
{ 


  {
  {
#line 72
  free((void *)af->argv);
  }
#line 73
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.c"
void argv_factory_add(ArgvFactory *af , char *arg ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
#line 101
  if (af->used + 1UL == af->size) {
    {
#line 103
    af->size *= 2UL;
#line 104
    tmp = realloc((void *)af->argv, af->size * sizeof(char *));
#line 104
    af->argv = (char **)tmp;
    }
  }
  {
#line 108
  tmp___0 = af->used;
#line 108
  (af->used) ++;
#line 108
  *(af->argv + tmp___0) = strdup((char const   *)arg);
#line 109
  *(af->argv + af->used) = (char *)((void *)0);
  }
#line 112
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/pgpgpg-0.13/argvfactory.c"
void argv_factory_append(ArgvFactory *dest , ArgvFactory *src ) 
{ 
  char **argv ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 147
  argv = src->argv;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! *argv) {
#line 147
      goto while_break;
    }
#line 149
    if (dest->used + 1UL == dest->size) {
      {
#line 151
      dest->used *= 2UL;
#line 152
      tmp = realloc((void *)dest->argv, dest->size * sizeof(char *));
#line 152
      dest->argv = (char **)tmp;
      }
    }
    {
#line 156
    tmp___0 = dest->used;
#line 156
    (dest->used) ++;
#line 156
    *(dest->argv + tmp___0) = strdup((char const   *)*argv);
#line 157
    *(dest->argv + dest->used) = (char *)((void *)0);
#line 147
    argv ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 45 "/home/wheatley/newnew/temp/pgpgpg-0.13/guessarmortype.c"
int guess_armor_type(char *filename ) 
{ 
  FILE *in ;
  char buffer[512] ;
  int mode ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 49
  mode = 1;
#line 52
  in = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 52
  if (! in) {
#line 53
    return (0);
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! mode) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp = fgets((char */* __restrict  */)(buffer), 512, (FILE */* __restrict  */)in);
    }
#line 56
    if (! tmp) {
      {
#line 57
      fclose(in);
      }
#line 58
      return (0);
    }
#line 61
    if (mode == 1) {
      {
#line 62
      tmp___1 = strncmp((char const   *)(buffer), "-----BEGIN PGP ", (size_t )15);
      }
#line 62
      if (tmp___1 == 0) {
#line 63
        mode = 0;
      } else {
        {
#line 64
        tmp___0 = strncmp((char const   *)(buffer), "-----END PGP ", (size_t )13);
        }
#line 64
        if (tmp___0 == 0) {
          {
#line 65
          fclose(in);
          }
#line 66
          return (0);
        }
      }
    }
#line 70
    if (mode != 0) {
      {
#line 71
      tmp___2 = strlen((char const   *)(buffer));
      }
#line 71
      if (tmp___2) {
        {
#line 71
        tmp___3 = strlen((char const   *)(buffer));
        }
#line 71
        if ((int )buffer[tmp___3 - 1UL] == 10) {
#line 72
          mode = 1;
        } else {
#line 74
          mode = 2;
        }
      } else {
#line 74
        mode = 2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  fclose(in);
#line 85
  tmp___4 = strlen((char const   *)(buffer));
#line 85
  i = (int )(tmp___4 - 1UL);
  }
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 86
    tmp___6 = strchr(" \t\r\n", (int )buffer[i]);
    }
#line 86
    if (! tmp___6) {
#line 86
      goto while_break___0;
    }
#line 87
    tmp___5 = i;
#line 87
    i --;
#line 87
    buffer[tmp___5] = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 93
  tmp___9 = strcmp((char const   *)(buffer), "-----BEGIN PGP MESSAGE-----");
  }
#line 93
  if (tmp___9 == 0) {
#line 94
    return (2);
  } else {
    {
#line 95
    tmp___8 = strcmp((char const   *)(buffer), "-----BEGIN PGP SIGNED MESSAGE-----");
    }
#line 95
    if (tmp___8 == 0) {
#line 96
      return (3);
    } else {
      {
#line 97
      tmp___7 = strcmp((char const   *)(buffer), "-----BEGIN PGP SIGNATURE-----");
      }
#line 97
      if (tmp___7 == 0) {
#line 98
        return (4);
      } else {
#line 100
        return (1);
      }
    }
  }
}
}
