/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 83 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvh.h"
struct device_parameters {
   unsigned char dp_skew ;
   unsigned char dp_gap1 ;
   unsigned char dp_gap2 ;
   unsigned char dp_spares_cyl ;
   unsigned short dp_cyls ;
   unsigned short dp_shd0 ;
   unsigned short dp_trks0 ;
   unsigned char dp_ctq_depth ;
   unsigned char dp_cylshi ;
   unsigned short dp_unused ;
   unsigned short dp_secs ;
   unsigned short dp_secbytes ;
   unsigned short dp_interleave ;
   int dp_flags ;
   int dp_datarate ;
   int dp_nretries ;
   int dp_mspw ;
   unsigned short dp_xgap1 ;
   unsigned short dp_xsync ;
   unsigned short dp_xrdly ;
   unsigned short dp_xgap2 ;
   unsigned short dp_xrgate ;
   unsigned short dp_xwcont ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvh.h"
struct volume_directory {
   char vd_name[8] ;
   int vd_lbn ;
   int vd_nbytes ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvh.h"
struct partition_table {
   int pt_nblks ;
   int pt_firstlbn ;
   int pt_type ;
};
#line 150 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvh.h"
struct volume_header {
   int vh_magic ;
   short vh_rootpt ;
   short vh_swappt ;
   char vh_bootfile[16] ;
   struct device_parameters vh_dp ;
   struct volume_directory vh_vd[15] ;
   struct partition_table vh_pt[16] ;
   int vh_csum ;
   int vh_fill ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.h"
union __anonunion_dvh_vc_29 {
   struct volume_header vh ;
   uint32_t cs[sizeof(struct volume_header ) / sizeof(uint32_t )] ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.h"
struct dvh_handle {
   int dvh_fd ;
   union __anonunion_dvh_vc_29 dvh_vc ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhtool.c"
enum actions {
    no_action = 0,
    print_vh = 1,
    print_vd = 2,
    print_pt = 3,
    print_all = 4,
    vh_remove = 5,
    vh_to_unix = 6,
    unix_to_vh = 7,
    show_usage = 8
} ;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 36 "./getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 140
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.h"
struct dvh_handle *dvh_open(char const   *vh , int mode ) ;
#line 40
void dvh_close(struct dvh_handle *dvh ) ;
#line 41
void dvh_vh_remove(struct dvh_handle *dvh , char const   *vh_name ) ;
#line 42
void dvh_vh_to_file(struct dvh_handle  const  *dvh , char const   *vh_name , char const   *u_name ) ;
#line 44
void dvh_file_to_vh(struct dvh_handle *dvh , char const   *u_name , char const   *vh_name ) ;
#line 46
void dvh_print_vh(struct dvh_handle  const  *dvh ) ;
#line 47
void dvh_print_vd(struct dvh_handle  const  *dvh ) ;
#line 48
void dvh_print_pt(struct dvh_handle  const  *dvh ) ;
#line 49
 __attribute__((__noreturn__)) void die(char const   *message ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhtool.c"
static struct option long_options[10]  = 
#line 43 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhtool.c"
  {      {"device", 1, (int *)((void *)0), 'd'}, 
        {"print-volume-header", 0, (int *)((void *)0), 256}, 
        {"print-volume-directory", 0, (int *)((void *)0), 257}, 
        {"print-partitions", 0, (int *)((void *)0), 258}, 
        {"print-all", 0, (int *)((void *)0), 259}, 
        {"vh-remove", 0, (int *)((void *)0), 260}, 
        {"vh-to-unix", 0, (int *)((void *)0), 261}, 
        {"unix-to-vh", 0, (int *)((void *)0), 262}, 
        {"help", 0, (int *)((void *)0), 263}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 68 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhtool.c"
int main(int argc , char **argv ) 
{ 
  void *dvh ;
  char *device ;
  int c ;
  enum actions action ;
  int option_index ;
  struct dvh_handle *tmp ;
  char *vh_file ;
  struct dvh_handle *tmp___0 ;
  char *vh_file___0 ;
  char *u_file ;
  int tmp___1 ;
  char *vh_file___1 ;
  char *u_file___0 ;
  int tmp___2 ;
  struct dvh_handle *tmp___3 ;

  {
#line 72
  device = (char *)"volhdr-1.dat";
#line 74
  action = (enum actions )8;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    option_index = 0;
#line 79
    c = getopt_long(argc, (char * const  *)argv, "d:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 82
    if (c == -1) {
#line 83
      goto while_break;
    }
    {
#line 86
    if (c == 100) {
#line 86
      goto case_100;
    }
#line 90
    if (c == 256) {
#line 90
      goto case_256;
    }
#line 94
    if (c == 257) {
#line 94
      goto case_257;
    }
#line 98
    if (c == 258) {
#line 98
      goto case_258;
    }
#line 102
    if (c == 259) {
#line 102
      goto case_259;
    }
#line 106
    if (c == 260) {
#line 106
      goto case_260;
    }
#line 110
    if (c == 261) {
#line 110
      goto case_261;
    }
#line 114
    if (c == 262) {
#line 114
      goto case_262;
    }
#line 119
    goto switch_default;
    case_100: /* CIL Label */ 
#line 87
    device = optarg;
#line 88
    goto switch_break;
    case_256: /* CIL Label */ 
#line 91
    action = (enum actions )1;
#line 92
    goto switch_break;
    case_257: /* CIL Label */ 
#line 95
    action = (enum actions )2;
#line 96
    goto switch_break;
    case_258: /* CIL Label */ 
#line 99
    action = (enum actions )3;
#line 100
    goto switch_break;
    case_259: /* CIL Label */ 
#line 103
    action = (enum actions )4;
#line 104
    goto switch_break;
    case_260: /* CIL Label */ 
#line 107
    action = (enum actions )5;
#line 108
    goto switch_break;
    case_261: /* CIL Label */ 
#line 111
    action = (enum actions )6;
#line 112
    goto switch_break;
    case_262: /* CIL Label */ 
#line 115
    action = (enum actions )7;
#line 116
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 120
    action = (enum actions )8;
#line 121
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if ((unsigned int )action == 8U) {
    {
#line 126
    printf((char const   */* __restrict  */)"Usage: %s --device DEVNAME [OPTIONS]\nManipulate the volume header of DEVNAME\n\nOptions:\n\n--print-volume-header\t\tShow header data only\n--print-volume-directory\tShow volume table of contents\n--print-partitions\t\tShow partition data\n--print-all\t\t\tEquivalent to all three above options\n--vh-remove NAME\t\tRemove volhdr file NAME from volhdr\n--vh-to-unix NAME FILE\t\tCopy volhdr file NAME to Unix file FILE\n--unix-to-vh FILE NAME\t\tCopy Unix file FILE to volhdr as NAME\n--help\t\t\t\tShow usage information\n",
           *(argv + 0));
#line 139
    exit(0);
    }
  }
  {
#line 142
  tmp = dvh_open((char const   *)device, 1);
#line 142
  dvh = (void *)tmp;
  }
#line 143
  if ((unsigned long )dvh == (unsigned long )((void *)0)) {
    {
#line 144
    die("Can\'t open Disk Volume Header");
    }
  }
#line 146
  if ((unsigned int )action == 1U) {
    {
#line 147
    dvh_print_vh((struct dvh_handle  const  *)dvh);
    }
  }
#line 148
  if ((unsigned int )action == 2U) {
    {
#line 149
    dvh_print_vd((struct dvh_handle  const  *)dvh);
    }
  }
#line 150
  if ((unsigned int )action == 3U) {
    {
#line 151
    dvh_print_pt((struct dvh_handle  const  *)dvh);
    }
  }
#line 152
  if ((unsigned int )action == 4U) {
    {
#line 153
    dvh_print_pt((struct dvh_handle  const  *)dvh);
#line 154
    dvh_print_vh((struct dvh_handle  const  *)dvh);
#line 155
    dvh_print_vd((struct dvh_handle  const  *)dvh);
    }
  }
#line 157
  if ((unsigned int )action == 5U) {
#line 160
    if (optind + 1 > argc) {
      {
#line 161
      die("Missing argument");
      }
    }
    {
#line 162
    vh_file = *(argv + optind);
#line 165
    dvh_close((struct dvh_handle *)dvh);
#line 166
    tmp___0 = dvh_open((char const   *)device, 2);
#line 166
    dvh = (void *)tmp___0;
    }
#line 167
    if ((unsigned long )dvh == (unsigned long )((void *)0)) {
      {
#line 168
      die("Can\'t reopen Disk Volume Header rw");
      }
    }
    {
#line 170
    dvh_vh_remove((struct dvh_handle *)dvh, (char const   *)vh_file);
    }
  }
#line 172
  if ((unsigned int )action == 6U) {
#line 175
    if (optind + 2 > argc) {
      {
#line 176
      die("Missing arguments");
      }
    }
    {
#line 178
    tmp___1 = optind;
#line 178
    optind ++;
#line 178
    vh_file___0 = *(argv + tmp___1);
#line 179
    u_file = *(argv + optind);
#line 180
    dvh_vh_to_file((struct dvh_handle  const  *)dvh, (char const   *)vh_file___0,
                   (char const   *)u_file);
    }
  }
#line 182
  if ((unsigned int )action == 7U) {
#line 185
    if (optind + 2 > argc) {
      {
#line 186
      die("Missing arguments");
      }
    }
    {
#line 188
    tmp___2 = optind;
#line 188
    optind ++;
#line 188
    u_file___0 = *(argv + tmp___2);
#line 189
    vh_file___1 = *(argv + optind);
#line 192
    dvh_close((struct dvh_handle *)dvh);
#line 193
    tmp___3 = dvh_open((char const   *)device, 2);
#line 193
    dvh = (void *)tmp___3;
    }
#line 194
    if ((unsigned long )dvh == (unsigned long )((void *)0)) {
      {
#line 195
      die("Can\'t reopen Disk Volume Header rw");
      }
    }
    {
#line 197
    dvh_file_to_vh((struct dvh_handle *)dvh, (char const   *)u_file___0, (char const   *)vh_file___1);
    }
  }
  {
#line 201
  dvh_close((struct dvh_handle *)dvh);
#line 203
  exit(0);
  }
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
 __attribute__((__noreturn__)) void die(char const   *message ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void die(char const   *message ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 28
  tmp___1 = __errno_location();
  }
#line 28
  if (*tmp___1) {
    {
#line 29
    tmp = __errno_location();
#line 29
    tmp___0 = strerror(*tmp);
#line 29
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            message, tmp___0);
    }
  } else {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
    }
  }
  {
#line 32
  exit(1);
  }
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static char const   *ptype2str(int ptype ) 
{ 


  {
  {
#line 39
  if (ptype == 0) {
#line 39
    goto case_0;
  }
#line 40
  if (ptype == 1) {
#line 40
    goto case_1;
  }
#line 41
  if (ptype == 2) {
#line 41
    goto case_2;
  }
#line 42
  if (ptype == 3) {
#line 42
    goto case_3;
  }
#line 43
  if (ptype == 4) {
#line 43
    goto case_4;
  }
#line 44
  if (ptype == 5) {
#line 44
    goto case_5;
  }
#line 45
  if (ptype == 6) {
#line 45
    goto case_6;
  }
#line 46
  if (ptype == 7) {
#line 46
    goto case_7;
  }
#line 47
  if (ptype == 8) {
#line 47
    goto case_8;
  }
#line 48
  if (ptype == 9) {
#line 48
    goto case_9;
  }
#line 49
  if (ptype == 10) {
#line 49
    goto case_10;
  }
#line 50
  if (ptype == 11) {
#line 50
    goto case_11;
  }
#line 51
  if (ptype == 12) {
#line 51
    goto case_12;
  }
#line 52
  if (ptype == 13) {
#line 52
    goto case_13;
  }
#line 53
  if (ptype == 130) {
#line 53
    goto case_130;
  }
#line 54
  if (ptype == 131) {
#line 54
    goto case_131;
  }
#line 38
  goto switch_break;
  case_0: /* CIL Label */ 
#line 39
  return ("Volume Header");
  case_1: /* CIL Label */ 
#line 40
  return ("Bad Track Replacement");
  case_2: /* CIL Label */ 
#line 41
  return ("Bad Sector Replacement");
  case_3: /* CIL Label */ 
#line 42
  return ("Data");
  case_4: /* CIL Label */ 
#line 43
  return ("BSD filesystem");
  case_5: /* CIL Label */ 
#line 44
  return ("SysV filesystem");
  case_6: /* CIL Label */ 
#line 45
  return ("Volume");
  case_7: /* CIL Label */ 
#line 46
  return ("EFS");
  case_8: /* CIL Label */ 
#line 47
  return ("Logical Volume");
  case_9: /* CIL Label */ 
#line 48
  return ("Raw Logical Volume");
  case_10: /* CIL Label */ 
#line 49
  return ("XFS");
  case_11: /* CIL Label */ 
#line 50
  return ("XFS Log");
  case_12: /* CIL Label */ 
#line 51
  return ("XLV Volume");
  case_13: /* CIL Label */ 
#line 52
  return ("XVM Volume");
  case_130: /* CIL Label */ 
#line 53
  return ("Linux Swap");
  case_131: /* CIL Label */ 
#line 54
  return ("Linux Native");
  switch_break: /* CIL Label */ ;
  }
#line 56
  return ("Unknown Partition Type");
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_print_vh(struct dvh_handle  const  *dvh ) 
{ 
  struct volume_header  const  *vh ;

  {
  {
#line 62
  vh = & dvh->dvh_vc.vh;
#line 64
  printf((char const   */* __restrict  */)"----- bootinfo -----\n");
#line 65
  printf((char const   */* __restrict  */)"Root partition: %d\n", (int const   )vh->vh_rootpt);
#line 66
  printf((char const   */* __restrict  */)"Swap partition: %d\n", (int const   )vh->vh_swappt);
#line 67
  printf((char const   */* __restrict  */)"Bootfile: \"%s\"\n", vh->vh_bootfile);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_print_vd(struct dvh_handle  const  *dvh ) 
{ 
  struct volume_header  const  *vh ;
  char name[9] ;
  int i ;
  struct volume_directory  const  *vd ;

  {
  {
#line 73
  vh = & dvh->dvh_vc.vh;
#line 77
  memset((void *)(name), 0, (size_t )9);
#line 78
  printf((char const   */* __restrict  */)"----- directory entries -----\n");
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 15)) {
#line 79
      goto while_break;
    }
#line 82
    vd = (struct volume_directory  const  *)(& vh->vh_vd[i]);
#line 84
    if ((int )vd->vd_name[0] == 0) {
#line 85
      goto __Cont;
    }
    {
#line 86
    strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(vd->vd_name),
            (size_t )8);
#line 87
    printf((char const   */* __restrict  */)"Entry #%d, name \"%s\", start %d, bytes %d\n",
           i, name, vd->vd_lbn, vd->vd_nbytes);
    }
    __Cont: /* CIL Label */ 
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_print_pt(struct dvh_handle  const  *dvh ) 
{ 
  struct volume_header  const  *vh ;
  int i ;
  int32_t start ;
  int32_t size ;
  int32_t type ;
  char const   *tmp ;

  {
  {
#line 95
  vh = & dvh->dvh_vc.vh;
#line 98
  printf((char const   */* __restrict  */)"----- partitions -----\n");
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 16)) {
#line 99
      goto while_break;
    }
#line 102
    start = (int32_t )vh->vh_pt[i].pt_firstlbn;
#line 103
    size = (int32_t )vh->vh_pt[i].pt_nblks;
#line 104
    type = (int32_t )vh->vh_pt[i].pt_type;
#line 106
    if (size == 0) {
#line 106
      goto __Cont;
    }
    {
#line 108
    tmp = ptype2str(type);
#line 108
    printf((char const   */* __restrict  */)"Part# %2d, start %d, blks %d, type %s\n",
           i, start, size, tmp);
    }
    __Cont: /* CIL Label */ 
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void swap_short_f(short *sp ) 
{ 
  uint16_t tmp ;

  {
  {
#line 117
  tmp = ntohs((uint16_t )*sp);
#line 117
  *sp = (short )tmp;
  }
#line 118
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void swap_int_f(int *ip ) 
{ 
  uint32_t tmp ;

  {
  {
#line 124
  tmp = ntohl((uint32_t )*ip);
#line 124
  *ip = (int )tmp;
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static uint32_t twos_complement_32bit_sum(uint32_t *base , int size ) 
{ 
  int i ;
  uint32_t sum ;
  uint32_t tmp ;

  {
#line 131
  sum = (uint32_t )0;
#line 133
  size = (int )((unsigned long )size / sizeof(uint32_t ));
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < size)) {
#line 134
      goto while_break;
    }
    {
#line 135
    tmp = ntohl(*(base + i));
#line 135
    sum -= tmp;
#line 134
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return (sum);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static int verify_vh(struct dvh_handle  const  *dvh ) 
{ 
  uint32_t csum ;
  uint32_t tmp ;

  {
  {
#line 144
  tmp = ntohl((uint32_t )dvh->dvh_vc.vh.vh_magic);
  }
#line 144
  if (tmp != 199600449U) {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad magic\n");
    }
#line 146
    return (-1);
  }
  {
#line 149
  csum = twos_complement_32bit_sum((uint32_t *)(& dvh->dvh_vc.vh), (int )sizeof(struct volume_header ));
  }
#line 152
  return (csum != 0U);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void recalc_vh_csum(struct dvh_handle *dvh ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 158
  dvh->dvh_vc.vh.vh_csum = 0;
#line 159
  tmp = twos_complement_32bit_sum((uint32_t *)(& dvh->dvh_vc.vh), (int )sizeof(struct volume_header ));
#line 159
  tmp___0 = htonl(tmp);
#line 159
  dvh->dvh_vc.vh.vh_csum = (int )tmp___0;
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void dvh_swap_device_parameters(struct device_parameters *dp ) 
{ 


  {
  {
#line 166
  swap_short_f((short *)(& dp->dp_cyls));
#line 167
  swap_short_f((short *)(& dp->dp_shd0));
#line 168
  swap_short_f((short *)(& dp->dp_trks0));
#line 170
  swap_short_f((short *)(& dp->dp_secs));
#line 171
  swap_short_f((short *)(& dp->dp_secbytes));
#line 172
  swap_short_f((short *)(& dp->dp_interleave));
#line 174
  swap_int_f(& dp->dp_flags);
#line 175
  swap_int_f(& dp->dp_datarate);
#line 176
  swap_int_f(& dp->dp_nretries);
#line 177
  swap_int_f(& dp->dp_mspw);
#line 179
  swap_short_f((short *)(& dp->dp_xgap1));
#line 180
  swap_short_f((short *)(& dp->dp_xsync));
#line 181
  swap_short_f((short *)(& dp->dp_xrdly));
#line 182
  swap_short_f((short *)(& dp->dp_xgap2));
#line 183
  swap_short_f((short *)(& dp->dp_xrgate));
#line 184
  swap_short_f((short *)(& dp->dp_xwcont));
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void dvh_swap_volume_directory(struct volume_directory *vd ) 
{ 


  {
  {
#line 190
  swap_int_f(& vd->vd_lbn);
#line 191
  swap_int_f(& vd->vd_nbytes);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void dvh_swap_partition_table(struct partition_table *pt ) 
{ 


  {
  {
#line 197
  swap_int_f(& pt->pt_nblks);
#line 198
  swap_int_f(& pt->pt_firstlbn);
#line 199
  swap_int_f(& pt->pt_type);
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
static void dvh_swap_volume_header(struct volume_header *vh ) 
{ 
  int i ;

  {
  {
#line 207
  swap_int_f(& vh->vh_magic);
#line 208
  swap_short_f(& vh->vh_rootpt);
#line 209
  swap_short_f(& vh->vh_swappt);
#line 211
  dvh_swap_device_parameters(& vh->vh_dp);
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < 15)) {
#line 213
      goto while_break;
    }
    {
#line 214
    dvh_swap_volume_directory(vh->vh_vd + i);
#line 213
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 216
    if (! (i < 16)) {
#line 216
      goto while_break___0;
    }
    {
#line 217
    dvh_swap_partition_table(vh->vh_pt + i);
#line 216
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 219
  swap_int_f(& vh->vh_csum);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
struct dvh_handle *dvh_open(char const   *vh , int mode ) 
{ 
  struct dvh_handle *dvh ;
  int flags ;
  int res ;
  int fd ;
  void *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
#line 225
  dvh = (struct dvh_handle *)((void *)0);
#line 226
  fd = 0;
#line 228
  if (mode == 1) {
#line 229
    flags = 0;
  } else
#line 230
  if (mode == 2) {
#line 231
    flags = 2;
  } else {
#line 233
    return ((struct dvh_handle *)((void *)0));
  }
  {
#line 235
  tmp = malloc(sizeof(struct dvh_handle ));
#line 235
  dvh = (struct dvh_handle *)tmp;
  }
#line 236
  if ((unsigned long )dvh == (unsigned long )((struct dvh_handle *)0)) {
#line 237
    return ((struct dvh_handle *)((void *)0));
  }
  {
#line 239
  fd = open(vh, flags);
  }
#line 240
  if (fd == -1) {
#line 240
    goto out;
  }
  {
#line 242
  tmp___0 = pread(fd, (void *)(& dvh->dvh_vc.vh), sizeof(struct volume_header ), (__off_t )0);
#line 242
  res = (int )tmp___0;
  }
#line 243
  if ((unsigned long )res != sizeof(struct volume_header )) {
    {
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dvh_open: short read.\n");
    }
#line 245
    goto out;
  }
  {
#line 248
  tmp___1 = verify_vh((struct dvh_handle  const  *)dvh);
  }
#line 248
  if (tmp___1) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dvh_open: Bad volume header\n");
    }
#line 250
    goto out;
  }
  {
#line 253
  dvh_swap_volume_header(& dvh->dvh_vc.vh);
#line 255
  dvh->dvh_fd = fd;
  }
#line 257
  return (dvh);
  out: 
#line 260
  if (fd) {
    {
#line 260
    close(fd);
    }
  }
#line 261
  if (dvh) {
    {
#line 261
    free((void *)dvh);
    }
  }
#line 263
  return ((struct dvh_handle *)((void *)0));
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_close(struct dvh_handle *dvh ) 
{ 


  {
  {
#line 269
  close(dvh->dvh_fd);
#line 270
  free((void *)dvh);
  }
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_vh_to_file(struct dvh_handle  const  *dvh , char const   *vh_name , char const   *u_name ) 
{ 
  struct volume_header  const  *vh ;
  struct volume_directory  const  *vd ;
  char *buf ;
  int i ;
  int res ;
  int ofd ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 277
  vh = & dvh->dvh_vc.vh;
#line 278
  vd = (struct volume_directory  const  *)(vh->vh_vd);
#line 282
  i = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (i < 15)) {
#line 282
      goto while_break;
    }
    {
#line 283
    tmp = strncmp(vh_name, (char const   *)(vd->vd_name), (size_t )8);
    }
#line 283
    if (tmp == 0) {
#line 284
      goto while_break;
    }
#line 285
    vd ++;
#line 282
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  if (i == 15) {
    {
#line 289
    die("Not found");
    }
  }
  {
#line 291
  ofd = open(u_name, 578, 438);
  }
#line 292
  if (ofd == -1) {
    {
#line 293
    die("Couldn\'t open destination fd");
    }
  }
  {
#line 295
  tmp___0 = malloc((size_t )vd->vd_nbytes);
#line 295
  buf = (char *)tmp___0;
  }
#line 296
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 297
    die("No memory");
    }
  }
  {
#line 299
  tmp___1 = pread((int )dvh->dvh_fd, (void *)buf, (size_t )vd->vd_nbytes, (__off_t )(vd->vd_lbn * 512));
#line 299
  res = (int )tmp___1;
  }
#line 300
  if (res != (int )vd->vd_nbytes) {
    {
#line 301
    die("Short read");
    }
  }
  {
#line 303
  tmp___2 = pwrite(ofd, (void const   *)buf, (size_t )vd->vd_nbytes, (__off_t )0);
#line 303
  res = (int )tmp___2;
  }
#line 304
  if (res != (int )vd->vd_nbytes) {
    {
#line 305
    unlink(u_name);
#line 306
    die("Short write");
    }
  }
  {
#line 309
  free((void *)buf);
  }
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_file_to_vh(struct dvh_handle *dvh , char const   *u_name , char const   *vh_name ) 
{ 
  struct volume_header *vh ;
  struct volume_directory *vd ;
  struct stat istat ;
  long size ;
  int i ;
  int res ;
  int ifd ;
  int dest ;
  int num ;
  int newAdded ;
  char *buf[15] ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 315
  vh = & dvh->dvh_vc.vh;
#line 316
  vd = vh->vh_vd;
#line 319
  num = 0;
#line 319
  newAdded = 0;
#line 322
  ifd = open(u_name, 0);
  }
#line 323
  if (ifd == -1) {
    {
#line 324
    die("Couldn\'t open input fd");
    }
  }
  {
#line 326
  res = fstat(ifd, & istat);
  }
#line 327
  if (res == -1) {
    {
#line 328
    die("Couldn\'t stat source file");
    }
  }
#line 331
  size = (__off_t )(vh->vh_pt[8].pt_nblks - (vh->vh_pt[8].pt_firstlbn + 4)) - ((istat.st_size + 512L) - 1L) / 512L;
#line 338
  i = 0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < 15)) {
#line 338
      goto while_break;
    }
    {
#line 339
    tmp = strncmp(vh_name, (char const   *)(vd->vd_name), (size_t )8);
    }
#line 339
    if (tmp == 0) {
      {
#line 341
      memset((void *)(vd->vd_name), 0, (size_t )8);
#line 342
      vd->vd_nbytes = 0;
      }
    }
#line 344
    if (vd->vd_nbytes) {
#line 345
      size -= (long )(((vd->vd_nbytes + 512) - 1) / 512);
#line 346
      num ++;
    }
#line 348
    vd ++;
#line 338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  if (num == 15) {
    {
#line 352
    die("No more free entries in volume header");
    }
  }
#line 353
  if (size <= 0L) {
    {
#line 354
    die("Not enough space left in volume header");
    }
  }
#line 357
  vd = vh->vh_vd;
#line 358
  i = 0;
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 358
    if (! (i < 15)) {
#line 358
      goto while_break___0;
    }
#line 359
    if (vd->vd_nbytes) {
      {
#line 360
      tmp___0 = malloc((size_t )vd->vd_nbytes);
#line 360
      buf[i] = (char *)tmp___0;
      }
#line 361
      if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
        {
#line 362
        die("No memory");
        }
      }
      {
#line 363
      tmp___1 = pread(dvh->dvh_fd, (void *)buf[i], (size_t )vd->vd_nbytes, (__off_t )(vd->vd_lbn * 512));
#line 363
      res = (int )tmp___1;
      }
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 365
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      if (res != vd->vd_nbytes) {
        {
#line 367
        die("Short read");
        }
      }
    } else {
#line 369
      buf[i] = (char *)((void *)0);
    }
#line 370
    vd ++;
#line 358
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  vd = vh->vh_vd;
#line 376
  dest = vh->vh_pt[8].pt_firstlbn + 4;
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 377
    if (! (i < 15)) {
#line 377
      goto while_break___2;
    }
#line 382
    if (! vd->vd_nbytes) {
#line 382
      if (! newAdded) {
        {
#line 383
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 383
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 384
        vd->vd_nbytes = (int )istat.st_size;
#line 385
        strncpy((char */* __restrict  */)(vd->vd_name), (char const   */* __restrict  */)vh_name,
                (size_t )8);
#line 386
        newAdded = 1;
#line 388
        tmp___2 = malloc((size_t )vd->vd_nbytes);
#line 388
        buf[i] = (char *)tmp___2;
        }
#line 389
        if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
          {
#line 390
          die("No memory");
          }
        }
        {
#line 392
        tmp___3 = pread(ifd, (void *)buf[i], (size_t )vd->vd_nbytes, (__off_t )0);
#line 392
        res = (int )tmp___3;
        }
#line 393
        if (res != vd->vd_nbytes) {
          {
#line 394
          die("Short read");
          }
        }
        {
#line 396
        close(ifd);
        }
      }
    }
#line 398
    if (vd->vd_nbytes) {
      {
#line 399
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 399
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 400
      vd->vd_lbn = dest;
#line 401
      tmp___4 = pwrite(dvh->dvh_fd, (void const   *)buf[i], (size_t )vd->vd_nbytes,
                       (__off_t )(vd->vd_lbn * 512));
#line 401
      res = (int )tmp___4;
      }
#line 403
      if (res != vd->vd_nbytes) {
        {
#line 404
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrote %d not %d\n",
                res, vd->vd_nbytes);
#line 406
        die("Short write");
        }
      }
    }
#line 409
    dest += ((vd->vd_nbytes + 512) - 1) / 512;
#line 410
    vd ++;
#line 377
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 413
  i = 0;
  {
#line 413
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 413
    if (! (i < 15)) {
#line 413
      goto while_break___5;
    }
#line 414
    if (buf[i]) {
      {
#line 415
      free((void *)buf[i]);
      }
    }
#line 413
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 419
  dvh_swap_volume_header(vh);
#line 420
  recalc_vh_csum(dvh);
  }
  {
#line 422
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 422
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 423
  tmp___5 = pwrite(dvh->dvh_fd, (void const   *)vh, sizeof(struct volume_header ),
                   (__off_t )0);
#line 423
  res = (int )tmp___5;
  }
#line 424
  if ((unsigned long )res != sizeof(struct volume_header )) {
    {
#line 425
    die("Short write of volume header - bye bye\n");
    }
  }
  {
#line 427
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 427
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/dvhtool-1.0.1/dvhlib.c"
void dvh_vh_remove(struct dvh_handle *dvh , char const   *vh_name ) 
{ 
  struct volume_header *vh ;
  struct volume_directory *vd ;
  int i ;
  int res ;
  int dest ;
  int found ;
  char *buf[15] ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 433
  vh = & dvh->dvh_vc.vh;
#line 434
  vd = vh->vh_vd;
#line 435
  found = 0;
#line 439
  vd = vh->vh_vd;
#line 440
  i = 0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i < 15)) {
#line 440
      goto while_break;
    }
    {
#line 441
    tmp = strncmp(vh_name, (char const   *)(vd->vd_name), (size_t )8);
    }
#line 441
    if (tmp == 0) {
      {
#line 442
      memset((void *)(vd->vd_name), 0, (size_t )8);
#line 443
      vd->vd_nbytes = 0;
#line 444
      found = 1;
      }
    }
#line 446
    if (vd->vd_nbytes) {
      {
#line 447
      tmp___0 = malloc((size_t )vd->vd_nbytes);
#line 447
      buf[i] = (char *)tmp___0;
      }
#line 448
      if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
        {
#line 449
        die("No memory");
        }
      }
      {
#line 450
      tmp___1 = pread(dvh->dvh_fd, (void *)buf[i], (size_t )vd->vd_nbytes, (__off_t )(vd->vd_lbn * 512));
#line 450
      res = (int )tmp___1;
      }
      {
#line 452
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 452
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 453
      if (res != vd->vd_nbytes) {
        {
#line 454
        die("Short read");
        }
      }
    } else {
#line 456
      buf[i] = (char *)((void *)0);
    }
#line 457
    vd ++;
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if (! found) {
    {
#line 461
    die("Not found");
    }
  }
#line 463
  vd = vh->vh_vd;
#line 465
  dest = vh->vh_pt[8].pt_firstlbn + 4;
#line 466
  i = 0;
  {
#line 466
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 466
    if (! (i < 15)) {
#line 466
      goto while_break___1;
    }
#line 467
    if (vd->vd_nbytes) {
      {
#line 468
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 468
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 469
      vd->vd_lbn = dest;
#line 470
      tmp___2 = pwrite(dvh->dvh_fd, (void const   *)buf[i], (size_t )vd->vd_nbytes,
                       (__off_t )(vd->vd_lbn * 512));
#line 470
      res = (int )tmp___2;
      }
#line 472
      if (res != vd->vd_nbytes) {
        {
#line 473
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrote %d not %d\n",
                res, vd->vd_nbytes);
#line 475
        die("Short write");
        }
      }
      {
#line 477
      free((void *)buf[i]);
      }
    }
#line 479
    dest += (vd->vd_nbytes + 511) / 512;
#line 480
    vd ++;
#line 466
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 484
  dvh_swap_volume_header(vh);
#line 485
  recalc_vh_csum(dvh);
  }
  {
#line 487
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 487
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 488
  tmp___3 = pwrite(dvh->dvh_fd, (void const   *)vh, sizeof(struct volume_header ),
                   (__off_t )0);
#line 488
  res = (int )tmp___3;
  }
#line 489
  if ((unsigned long )res != sizeof(struct volume_header )) {
    {
#line 490
    die("Short write of volume header - bye bye\n");
    }
  }
  {
#line 492
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 492
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 493
  return;
}
}
