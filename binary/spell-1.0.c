/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 78 "/home/june/repo/benchmarks/collector/temp/spell-1.0/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 29 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.h"
enum add_line_return {
    ADD_LINE_OK = 0,
    ADD_LINE_ERR = 1,
    ADD_LINE_EOF = 2
} ;
#line 36 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.h"
struct str {
   char *str ;
   int len ;
   size_t mem ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.h"
typedef struct str str_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
struct pipe {
   int pin ;
   int pout ;
   int perr ;
   int cin ;
   int cout ;
   int cerr ;
   fd_set error_set ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
typedef struct pipe pipe_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 32 "/home/june/repo/benchmarks/collector/temp/spell-1.0/getopt.h"
extern char *optarg ;
#line 46
extern int optind ;
#line 107
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.h"
char *str_to_nstr(str_t *str ) ;
#line 45
int str_add_line(str_t *str , FILE *stream ) ;
#line 46
int str_add_line_from_desc(str_t *str , int file_desc ) ;
#line 48
str_t *nstr_to_str(char *nstr ) ;
#line 49
str_t *str_make(str_t *str ) ;
#line 50
void str_add_char(str_t *str , char c ) ;
#line 51
void str_add_str(str_t *str1 , str_t *str2 ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char *find_ispell(void) ;
#line 93
static char *xstrdup(char const   *str ) ;
#line 94
static void *xmalloc(size_t size ) ;
#line 96
static void error(int status , int errnum , char const   *message  , ...) ;
#line 97
static void sig_chld(int signo ) ;
#line 98
static void sig_pipe(int signo ) ;
#line 99
void new_pipe(pipe_t *the_pipe ) ;
#line 100
void parent(pipe_t *the_pipe , int argc , char **argv ) ;
#line 101
void read_file(pipe_t *the_pipe , FILE *stream , char *file ) ;
#line 102
void read_ispell(pipe_t *ispell_pipe , char *file , int line ) ;
#line 103
void read_ispell_errors(pipe_t *the_pipe ) ;
#line 104
void run_ispell_in_child(pipe_t *the_pipe ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char const   version[12]  = 
#line 107
  {      (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'0',      (char const   )'\000'};
#line 110 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
struct option  const  long_options[13]  = 
#line 110
  {      {"all-chains", 0, (int *)((void *)0), 'l'}, 
        {"british", 0, (int *)((void *)0), 'b'}, 
        {"dictionary", 1, (int *)((void *)0), 'd'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"ispell", 1, (int *)((void *)0), 'i'}, 
        {"ispell-version", 0, (int *)((void *)0), 'I'}, 
        {"number", 0, (int *)((void *)0), 'n'}, 
        {"print-file-name", 0, (int *)((void *)0), 'o'}, 
        {"print-stems", 0, (int *)((void *)0), 'x'}, 
        {"stop-list", 1, (int *)((void *)0), 's'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 128 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char *program_name  =    (char *)((void *)0);
#line 131 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char *ispell_prog  =    (char *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char *dictionary  =    (char *)((void *)0);
#line 137 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int show_ispell_version  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int read_stdin  =    0;
#line 143 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int british  =    0;
#line 147 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int verbose  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int number_lines  =    0;
#line 154 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int print_file_names  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int interactive  =    0;
#line 159 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
int main(int argc , char **argv ) 
{ 
  char opt ;
  int opt_error ;
  int show_help ;
  int show_version ;
  pid_t pid ;
  pipe_t ispell_pipe ;
  int tmp ;
  int *tmp___0 ;

  {
#line 162
  opt = (char)0;
#line 163
  opt_error = 0;
#line 164
  show_help = 0;
#line 165
  show_version = 0;
#line 166
  pid = 0;
#line 169
  program_name = *(argv + 0);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp = getopt_long(argc, (char * const  *)argv, "IVbdhilnosvx", long_options, (int *)0);
#line 174
    opt = (char )tmp;
    }
#line 177
    if ((int )opt == -1) {
#line 178
      goto while_break;
    }
    {
#line 182
    if ((int )opt == 73) {
#line 182
      goto case_73;
    }
#line 185
    if ((int )opt == 86) {
#line 185
      goto case_86;
    }
#line 188
    if ((int )opt == 98) {
#line 188
      goto case_98;
    }
#line 191
    if ((int )opt == 100) {
#line 191
      goto case_100;
    }
#line 197
    if ((int )opt == 104) {
#line 197
      goto case_104;
    }
#line 200
    if ((int )opt == 105) {
#line 200
      goto case_105;
    }
#line 206
    if ((int )opt == 108) {
#line 206
      goto case_108;
    }
#line 208
    if ((int )opt == 110) {
#line 208
      goto case_110;
    }
#line 211
    if ((int )opt == 111) {
#line 211
      goto case_111;
    }
#line 214
    if ((int )opt == 115) {
#line 214
      goto case_115;
    }
#line 216
    if ((int )opt == 118) {
#line 216
      goto case_118;
    }
#line 219
    if ((int )opt == 120) {
#line 219
      goto case_120;
    }
#line 221
    goto switch_default;
    case_73: /* CIL Label */ 
#line 183
    show_ispell_version = 1;
#line 184
    goto switch_break;
    case_86: /* CIL Label */ 
#line 186
    show_version = 1;
#line 187
    goto switch_break;
    case_98: /* CIL Label */ 
#line 189
    british = 1;
#line 190
    goto switch_break;
    case_100: /* CIL Label */ 
#line 192
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 193
      dictionary = xstrdup((char const   *)optarg);
      }
    } else {
      {
#line 195
      error(0, 0, "option argument not given");
      }
    }
#line 196
    goto switch_break;
    case_104: /* CIL Label */ 
#line 198
    show_help = 1;
#line 199
    goto switch_break;
    case_105: /* CIL Label */ 
#line 201
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 202
      ispell_prog = xstrdup((char const   *)optarg);
      }
    } else {
      {
#line 204
      error(0, 0, "option argument not given");
      }
    }
#line 205
    goto switch_break;
    case_108: /* CIL Label */ 
#line 207
    goto switch_break;
    case_110: /* CIL Label */ 
#line 209
    number_lines = 1;
#line 210
    goto switch_break;
    case_111: /* CIL Label */ 
#line 212
    print_file_names = 1;
#line 213
    goto switch_break;
    case_115: /* CIL Label */ 
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
#line 217
    verbose = 1;
#line 218
    goto switch_break;
    case_120: /* CIL Label */ 
#line 220
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 222
    opt_error = 1;
#line 223
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if (opt_error) {
    {
#line 229
    printf((char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
           program_name);
#line 230
    exit(1);
    }
  }
#line 233
  if (show_version) {
    {
#line 235
    error(0, 0, version);
    }
#line 237
    if (! show_help) {
      {
#line 238
      exit(0);
      }
    }
  }
#line 241
  if (show_help) {
    {
#line 243
    printf((char const   */* __restrict  */)"Usage: %s [OPTION]... [FILE]...\n", program_name);
#line 244
    fputs((char const   */* __restrict  */)"This is GNU Spell, a Unix spell emulator.\n\n  -I, --ispell-version\t\tPrint Ispell\'s version.\n  -V, --version\t\t\tPrint the version number.\n  -b, --british\t\t\tUse the British dictionary.\n  -d, --dictionary=FILE\t\tUse FILE to look up words.\n  -h, --help\t\t\tPrint a summary of the options.\n  -i, --ispell=PROGRAM\t\tCalls PROGRAM as Ispell.\n  -l, --all-chains\t\tIgnored; for compatibility.\n  -n, --number\t\t\tPrint line numbers before lines.\n  -o, --print-file-name\t\tPrint file names before lines.\n  -s, --stop-list=FILE\t\tIgnored; for compatibility.\n  -v, --verbose\t\t\tPrint words not literally found.\n  -x, --print-stems\t\tIgnored; for compatibility.\n\nPlease use Info to read more (type `info spell\').\n",
          (FILE */* __restrict  */)stderr);
#line 258
    exit(0);
    }
  }
#line 261
  if (! ispell_prog) {
    {
#line 262
    ispell_prog = find_ispell();
    }
  }
  {
#line 264
  new_pipe(& ispell_pipe);
#line 266
  pid = fork();
  }
#line 268
  if (pid < 0) {
    {
#line 269
    tmp___0 = __errno_location();
#line 269
    error(1, *tmp___0, "error forking to run Ispell");
    }
  } else
#line 270
  if (pid > 0) {
    {
#line 271
    parent(& ispell_pipe, argc, argv);
    }
  } else {
    {
#line 273
    run_ispell_in_child(& ispell_pipe);
    }
  }
  {
#line 275
  exit(0);
  }
}
}
#line 282
static char *find_file_in_path(char *program ) ;
#line 285 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
char *find_ispell(void) 
{ 
  char *ret ;

  {
  {
#line 289
  ret = find_file_in_path((char *)"ispell");
  }
#line 289
  if ((unsigned long )((void *)0) != (unsigned long )ret) {
#line 290
    return (ret);
  }
  {
#line 291
  ret = find_file_in_path((char *)"aspell");
  }
#line 291
  if ((unsigned long )((void *)0) != (unsigned long )ret) {
#line 292
    return (ret);
  }
  {
#line 293
  error(1, 0, "unable to locate Ispell/Aspell");
  }
#line 294
  return ((char *)0);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static char *find_file_in_path(char *program ) 
{ 
  char *ispell ;
  char *path ;
  int path_len ;
  int pos ;
  str_t *file ;
  str_t *tmp ;
  struct stat stat_buf ;
  char *tmp___0 ;
  size_t tmp___1 ;
  str_t *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 299
  ispell = (char *)((void *)0);
#line 300
  path = (char *)((void *)0);
#line 301
  path_len = 0;
#line 302
  pos = 0;
#line 303
  tmp = str_make((str_t *)0);
#line 303
  file = tmp;
#line 306
  tmp___0 = getenv("PATH");
#line 306
  path = xstrdup((char const   *)tmp___0);
#line 307
  tmp___1 = strlen((char const   *)path);
#line 307
  path_len = (int )tmp___1;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 311
    file = str_make(file);
    }
#line 313
    if (! pos) {
#line 313
      if ((int )*(path + pos) == 58) {
        {
#line 316
        str_add_char(file, (char )'.');
        }
      } else {
#line 313
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 318
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 318
        if (pos < path_len) {
#line 318
          if (! ((int )*(path + pos) != 58)) {
#line 318
            goto while_break___0;
          }
        } else {
#line 318
          goto while_break___0;
        }
        {
#line 319
        str_add_char(file, *(path + pos));
#line 318
        pos ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 321
    if ((int )*(file->str + (file->len - 1)) != 47) {
      {
#line 322
      str_add_char(file, (char )'/');
      }
    }
    {
#line 323
    tmp___2 = nstr_to_str(program);
#line 323
    str_add_str(file, tmp___2);
#line 325
    tmp___5 = str_to_nstr(file);
#line 325
    tmp___6 = stat((char const   */* __restrict  */)tmp___5, (struct stat */* __restrict  */)(& stat_buf));
    }
#line 325
    if (tmp___6 != -1) {
      {
#line 326
      tmp___3 = str_to_nstr(file);
#line 326
      tmp___4 = xstrdup((char const   *)tmp___3);
      }
#line 326
      return (tmp___4);
    }
#line 328
    if (pos >= path_len) {
#line 329
      return ((char *)((void *)0));
    }
#line 330
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  abort();
  }
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void read_file(pipe_t *the_pipe , FILE *stream , char *file ) 
{ 
  str_t *str ;
  str_t *tmp ;
  enum add_line_return add_line_ret ;
  int line ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 343
  tmp = str_make((str_t *)0);
#line 343
  str = tmp;
#line 344
  add_line_ret = (enum add_line_return )0;
#line 345
  line = 0;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    str = str_make(str);
#line 351
    str_add_char(str, (char )'^');
#line 352
    tmp___0 = str_add_line(str, stream);
#line 352
    add_line_ret = (enum add_line_return )tmp___0;
#line 353
    line ++;
    }
#line 355
    if ((unsigned int )add_line_ret == 1U) {
      {
#line 356
      tmp___1 = __errno_location();
#line 356
      error(1, *tmp___1, "%s: error reading line", file);
      }
    }
#line 357
    if ((unsigned int )add_line_ret == 2U) {
#line 357
      if (! str->len) {
#line 358
        return;
      }
    }
#line 361
    if ((int )*(str->str + (str->len - 1)) != 10) {
      {
#line 362
      str_add_char(str, (char )'\n');
      }
    }
    {
#line 364
    tmp___3 = str_to_nstr(str);
#line 364
    tmp___4 = write(the_pipe->pout, (void const   *)tmp___3, (size_t )str->len);
    }
#line 364
    if (tmp___4 != (ssize_t )str->len) {
      {
#line 365
      tmp___2 = __errno_location();
#line 365
      error(1, *tmp___2, "error writing to Ispell");
      }
    }
    {
#line 367
    read_ispell_errors(the_pipe);
#line 368
    read_ispell(the_pipe, file, line);
#line 369
    read_ispell_errors(the_pipe);
    }
#line 371
    if ((unsigned int )add_line_ret == 2U) {
#line 372
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  tmp___6 = fclose(stream);
  }
#line 375
  if (tmp___6 == -1) {
    {
#line 376
    tmp___5 = __errno_location();
#line 376
    error(0, *tmp___5, "%s: close error", file);
    }
  }
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void read_ispell(pipe_t *ispell_pipe , char *file , int line ) 
{ 
  str_t *str ;
  str_t *tmp ;
  int tmp___0 ;
  int pos ;
  char *tmp___1 ;

  {
  {
#line 388
  tmp = str_make((str_t *)0);
#line 388
  str = tmp;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    str = str_make(str);
#line 394
    tmp___0 = str_add_line_from_desc(str, ispell_pipe->pin);
    }
#line 394
    if (tmp___0 == 2) {
      {
#line 395
      exit(0);
      }
    }
#line 399
    if (str->len == 1) {
#line 399
      if ((int )*(str->str + 0) == 10) {
#line 400
        return;
      }
    }
#line 403
    if ((int )*(str->str + 0) == 42) {
#line 405
      goto while_continue;
    } else
#line 403
    if ((int )*(str->str + 0) == 43) {
#line 405
      goto while_continue;
    } else
#line 403
    if ((int )*(str->str + 0) == 45) {
#line 405
      goto while_continue;
    }
#line 408
    if ((int )*(str->str + 0) == 38) {
#line 408
      goto _L;
    } else
#line 408
    if ((int )*(str->str + 0) == 35) {
#line 408
      goto _L;
    } else
#line 408
    if ((int )*(str->str + 0) == 63) {
#line 408
      if (verbose) {
        _L: /* CIL Label */ 
#line 413
        if (print_file_names) {
          {
#line 415
          printf((char const   */* __restrict  */)"%s:", file);
          }
#line 416
          if (! number_lines) {
            {
#line 417
            putchar(' ');
            }
          }
        }
#line 419
        if (number_lines) {
          {
#line 420
          printf((char const   */* __restrict  */)"%d: ", line);
          }
        }
#line 422
        pos = 2;
        {
#line 422
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 422
          if (! ((int )*(str->str + pos) != 32)) {
#line 422
            goto while_break___0;
          }
          {
#line 423
          putchar((int )*(str->str + pos));
#line 422
          pos ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 424
        putchar('\n');
        }
#line 426
        goto while_continue;
      }
    }
#line 429
    if ((int )*(str->str + 0) == 63) {
#line 429
      if (! verbose) {
#line 430
        goto while_continue;
      }
    }
    {
#line 432
    tmp___1 = str_to_nstr(str);
#line 432
    error(0, 0, "unrecognized Ispell line `%s\'", tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void read_ispell_errors(pipe_t *the_pipe ) 
{ 
  struct timeval time_out ;
  str_t *str ;
  str_t *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 445
  tmp = str_make((str_t *)0);
#line 445
  str = tmp;
#line 447
  time_out.tv_usec = (__suseconds_t )0;
#line 447
  time_out.tv_sec = time_out.tv_usec;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 449
    tmp___4 = select(1024, (fd_set */* __restrict  */)(& the_pipe->error_set), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& time_out));
    }
#line 449
    if (! (tmp___4 == 1)) {
#line 449
      goto while_break;
    }
    {
#line 452
    str = str_make(str);
#line 454
    tmp___0 = str_add_line_from_desc(str, the_pipe->perr);
    }
#line 454
    if (tmp___0 == 2) {
      {
#line 456
      error(1, 0, "premature EOF from Ispell\'s stderr");
      }
    }
    {
#line 459
    str->len -= 2;
#line 460
    *(str->str + (str->len - 1)) = (char)0;
#line 462
    tmp___2 = strlen("Can\'t open ");
#line 462
    tmp___3 = memcmp((void const   *)str->str, (void const   *)"Can\'t open ", tmp___2);
    }
#line 462
    if (! tmp___3) {
      {
#line 463
      tmp___1 = strlen("Can\'t open ");
#line 463
      error(1, 0, "%s: cannot open", str->str + tmp___1);
      }
    }
    {
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            ispell_prog, str->str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void new_pipe(pipe_t *the_pipe ) 
{ 
  int ifd[2] ;
  int ofd[2] ;
  int efd[2] ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 480
  tmp___0 = signal(13, & sig_pipe);
  }
#line 480
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 481
    tmp = __errno_location();
#line 481
    error(1, *tmp, "error creating SIGPIPE handler");
    }
  }
  {
#line 482
  tmp___2 = signal(17, & sig_chld);
  }
#line 482
  if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 483
    tmp___1 = __errno_location();
#line 483
    error(1, *tmp___1, "error creating SIGCHLD handler");
    }
  }
  {
#line 485
  tmp___4 = pipe((int *)(ifd));
  }
#line 485
  if (tmp___4 < 0) {
    {
#line 486
    tmp___3 = __errno_location();
#line 486
    error(1, *tmp___3, "error creating pipe to Ispell");
    }
  }
  {
#line 487
  the_pipe->pin = ifd[0];
#line 488
  the_pipe->cout = ifd[1];
#line 490
  tmp___6 = pipe((int *)(ofd));
  }
#line 490
  if (tmp___6 < 0) {
    {
#line 491
    tmp___5 = __errno_location();
#line 491
    error(1, *tmp___5, "error creating pipe to Ispell");
    }
  }
  {
#line 492
  the_pipe->cin = ofd[0];
#line 493
  the_pipe->pout = ofd[1];
#line 495
  tmp___8 = pipe((int *)(efd));
  }
#line 495
  if (tmp___8 < 0) {
    {
#line 496
    tmp___7 = __errno_location();
#line 496
    error(1, *tmp___7, "error creating pipe to Ispell");
    }
  }
#line 497
  the_pipe->perr = efd[0];
#line 498
  the_pipe->cerr = efd[1];
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& the_pipe->error_set.__fds_bits[0]): "memory");
#line 500
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  the_pipe->error_set.__fds_bits[the_pipe->perr / (8 * (int )sizeof(__fd_mask ))] |= 1L << the_pipe->perr % (8 * (int )sizeof(__fd_mask ));
#line 502
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static void sig_pipe(int signo ) 
{ 


  {
  {
#line 509
  error(1, 0, "broken pipe");
  }
#line 510
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static void sig_chld(int signo ) 
{ 


  {
  {
#line 517
  error(1, 0, "Ispell died");
  }
#line 518
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void parent(pipe_t *the_pipe , int argc , char **argv ) 
{ 
  FILE *stream ;
  char *file ;
  int arg_error ;
  int arg_index ;
  int pos ;
  str_t *ispell_version ;
  str_t *tmp ;
  str_t *str ;
  str_t *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  struct stat stat_buf ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 530
  file = (char *)((void *)0);
#line 531
  arg_error = 0;
#line 532
  arg_index = optind;
#line 536
  close(the_pipe->cin);
#line 537
  close(the_pipe->cout);
#line 538
  close(the_pipe->cerr);
#line 540
  read_ispell_errors(the_pipe);
#line 548
  pos = 0;
#line 549
  tmp = str_make((str_t *)0);
#line 549
  ispell_version = tmp;
#line 550
  tmp___0 = str_make((str_t *)0);
#line 550
  str = tmp___0;
#line 552
  tmp___1 = str_add_line_from_desc(str, the_pipe->pin);
  }
#line 552
  if (tmp___1 == 2) {
    {
#line 553
    error(1, 0, "premature EOF from Ispell\'s stdout");
    }
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 555
    tmp___2 = __ctype_b_loc();
    }
#line 555
    if ((int const   )*(*tmp___2 + (int )*(str->str + pos)) & 2048) {
#line 555
      goto while_break;
    } else
#line 555
    if (! (pos <= str->len)) {
#line 555
      goto while_break;
    }
#line 555
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 556
    if ((int )*(str->str + pos) != 32) {
#line 556
      if (! (pos <= str->len)) {
#line 556
        goto while_break___0;
      }
    } else {
#line 556
      goto while_break___0;
    }
    {
#line 557
    str_add_char(ispell_version, *(str->str + pos));
#line 556
    pos ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 559
  if (show_ispell_version) {
    {
#line 561
    tmp___3 = str_to_nstr(ispell_version);
#line 561
    printf((char const   */* __restrict  */)"%s: Ispell version %s\n", program_name,
           tmp___3);
#line 563
    exit(0);
    }
  }
  {
#line 567
  file = xstrdup("-");
  }
#line 569
  if (argc == 1) {
    {
#line 570
    read_file(the_pipe, stdin, (char *)"-");
    }
  }
  {
#line 572
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 572
    if (! (arg_index < argc)) {
#line 572
      goto while_break___1;
    }
#line 574
    arg_error = 0;
#line 576
    file = *(argv + arg_index);
#line 578
    if ((int )*(file + 0) == 45) {
#line 578
      if ((int )*(file + 1) == 0) {
#line 580
        if (! read_stdin) {
#line 582
          read_stdin = 1;
#line 583
          stream = stdin;
        }
      } else {
#line 578
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 590
      tmp___5 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& stat_buf));
      }
#line 590
      if (tmp___5 == -1) {
        {
#line 592
        tmp___4 = __errno_location();
#line 592
        error(0, *tmp___4, "%s: stat error", file);
#line 593
        arg_index ++;
        }
#line 594
        goto while_continue___1;
      }
#line 596
      if ((stat_buf.st_mode & 61440U) == 16384U) {
        {
#line 598
        error(0, 0, "%s: is a directory", file);
#line 599
        arg_index ++;
        }
#line 600
        goto while_continue___1;
      }
      {
#line 603
      stream = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
      }
#line 604
      if (! stream) {
        {
#line 606
        tmp___6 = __errno_location();
#line 606
        error(0, *tmp___6, "%s: open error", file);
#line 607
        arg_error = 1;
        }
      }
    }
#line 611
    if (! arg_error) {
      {
#line 612
      read_file(the_pipe, stream, file);
      }
    }
#line 614
    arg_index ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 616
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
void run_ispell_in_child(pipe_t *the_pipe ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 626
  close(the_pipe->pin);
#line 627
  close(the_pipe->pout);
#line 628
  close(the_pipe->perr);
  }
#line 630
  if (the_pipe->cin != 0) {
    {
#line 631
    tmp___0 = dup2(the_pipe->cin, 0);
    }
#line 631
    if (tmp___0 != 0) {
      {
#line 632
      tmp = __errno_location();
#line 632
      error(1, *tmp, "error duping to stdin");
      }
    }
  }
#line 634
  if (the_pipe->cout != 1) {
    {
#line 635
    tmp___2 = dup2(the_pipe->cout, 1);
    }
#line 635
    if (tmp___2 != 1) {
      {
#line 636
      tmp___1 = __errno_location();
#line 636
      error(1, *tmp___1, "error duping to stdout");
      }
    }
  }
#line 638
  if (the_pipe->cerr != 2) {
    {
#line 639
    tmp___4 = dup2(the_pipe->cerr, 2);
    }
#line 639
    if (tmp___4 != 2) {
      {
#line 640
      tmp___3 = __errno_location();
#line 640
      error(1, *tmp___3, "error duping to stderr");
      }
    }
  }
#line 642
  if ((unsigned long )dictionary != (unsigned long )((void *)0)) {
    {
#line 643
    tmp___6 = execl((char const   *)ispell_prog, "ispell", "-a", "-p", dictionary,
                    (void *)0);
    }
#line 643
    if (tmp___6 < 0) {
      {
#line 645
      tmp___5 = __errno_location();
#line 645
      error(1, *tmp___5, "error executing %s", ispell_prog);
      }
    }
  }
#line 647
  if (british) {
    {
#line 648
    tmp___8 = execl((char const   *)ispell_prog, "ispell", "-a", "-d", "british",
                    (void *)0);
    }
#line 648
    if (tmp___8 < 0) {
      {
#line 650
      tmp___7 = __errno_location();
#line 650
      error(1, *tmp___7, "error executing %s", ispell_prog);
      }
    }
  }
  {
#line 652
  tmp___10 = execl((char const   *)ispell_prog, "ispell", "-a", (void *)0);
  }
#line 652
  if (tmp___10 < 0) {
    {
#line 653
    tmp___9 = __errno_location();
#line 653
    error(1, *tmp___9, "error executing %s", ispell_prog);
    }
  }
#line 654
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static void error(int status , int errnum , char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 683
  fflush(stdout);
#line 684
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program_name);
#line 686
  __builtin_va_start(args, message);
#line 687
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 688
  __builtin_va_end(args);
  }
#line 690
  if (errnum) {
    {
#line 691
    tmp = strerror(errnum);
#line 691
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 692
  _IO_putc('\n', stderr);
#line 693
  fflush(stderr);
  }
#line 694
  if (status) {
    {
#line 695
    exit(status);
    }
  }
#line 696
  return;
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static void *xmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 704
  tmp = malloc(size);
#line 704
  ptr = tmp;
  }
#line 706
  if (! ptr) {
    {
#line 707
    error(1, 0, "virtual memory exhausted");
    }
  }
#line 708
  return (ptr);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/spell-1.0/spell.c"
static char *xstrdup(char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *new ;
  void *tmp___0 ;

  {
  {
#line 733
  tmp = strlen(str);
#line 733
  len = tmp + 1UL;
#line 734
  tmp___0 = xmalloc(len);
#line 734
  new = tmp___0;
#line 736
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)((void *)str),
         len);
  }
#line 738
  return ((char *)new);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.h"
str_t *int_to_str(int num ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
static void *xmalloc___0(size_t size ) ;
#line 62
static void *xrealloc(void *ptr , size_t size ) ;
#line 63
static void error___0(int status , int errnum , char const   *message  , ...) ;
#line 64
static int safe_read(int desc , char *ptr , int len ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
str_t *str_make(str_t *str ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 80
  if (! str) {
    {
#line 82
    tmp = xmalloc___0(sizeof(*str));
#line 82
    str = (str_t *)tmp;
#line 83
    tmp___0 = (size_t )64;
#line 83
    str->mem = tmp___0;
#line 83
    tmp___1 = xmalloc___0(tmp___0);
#line 83
    str->str = (char *)tmp___1;
    }
  } else {
    {
#line 86
    tmp___2 = (size_t )64;
#line 86
    str->mem = tmp___2;
#line 86
    tmp___3 = xrealloc((void *)str->str, tmp___2);
#line 86
    str->str = (char *)tmp___3;
    }
  }
#line 87
  str->len = 0;
#line 89
  return (str);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
void str_add_char(str_t *str , char c ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 98
  if (! str) {
    {
#line 99
    str = str_make(str);
    }
  } else
#line 98
  if (! str->str) {
    {
#line 99
    str = str_make(str);
    }
  }
#line 101
  (str->len) ++;
#line 101
  if ((size_t )str->len > str->mem) {
    {
#line 102
    tmp = str->mem + 64UL;
#line 102
    str->mem = tmp;
#line 102
    tmp___0 = xrealloc((void *)str->str, tmp);
#line 102
    str->str = (char *)tmp___0;
    }
  }
#line 104
  *(str->str + (str->len - 1)) = c;
#line 105
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
void str_add_str(str_t *str1 , str_t *str2 ) 
{ 
  int pos ;

  {
#line 113
  pos = 0;
#line 115
  if (! str2) {
#line 116
    return;
  } else
#line 115
  if (! str2->str) {
#line 116
    return;
  }
#line 117
  if (! str1) {
    {
#line 118
    str1 = str_make(str1);
    }
  } else
#line 117
  if (! str1->str) {
    {
#line 118
    str1 = str_make(str1);
    }
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (pos < str2->len)) {
#line 120
      goto while_break;
    }
    {
#line 121
    str_add_char(str1, *(str2->str + pos));
#line 120
    pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
int str_add_line(str_t *str , FILE *stream ) 
{ 
  register char c ;
  int tmp ;
  int tmp___0 ;

  {
#line 132
  if (! str) {
    {
#line 133
    str = str_make(str);
    }
  } else
#line 132
  if (! str->str) {
    {
#line 133
    str = str_make(str);
    }
  }
#line 134
  if (! stream) {
#line 135
    return (1);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    tmp = _IO_getc(stream);
#line 139
    c = (char )tmp;
    }
#line 141
    if ((int )c == -1) {
#line 142
      return (2);
    } else {
      {
#line 141
      tmp___0 = ferror(stream);
      }
#line 141
      if (tmp___0) {
#line 142
        return (2);
      }
    }
    {
#line 143
    str_add_char(str, c);
    }
#line 144
    if ((int )c == 10) {
#line 145
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (0);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
int str_add_line_from_desc(str_t *str , int file_desc ) 
{ 
  int nchars ;
  char c ;

  {
#line 160
  nchars = 0;
#line 161
  c = (char)0;
#line 163
  if (! str) {
    {
#line 164
    str = str_make(str);
    }
  } else
#line 163
  if (! str->str) {
    {
#line 164
    str = str_make(str);
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    nchars = safe_read(file_desc, & c, 1);
    }
#line 170
    if (! nchars) {
#line 171
      return (2);
    }
#line 172
    if (nchars < 0) {
#line 173
      return (1);
    }
    {
#line 175
    str_add_char(str, c);
    }
#line 176
    if ((int )c == 10) {
#line 177
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (0);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
str_t *nstr_to_str(char *nstr ) 
{ 
  str_t *str ;
  int pos ;

  {
  {
#line 189
  str = (str_t *)0;
#line 190
  pos = 0;
#line 192
  str = str_make(str);
  }
#line 194
  if (! nstr) {
#line 195
    return (str);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! *(nstr + pos)) {
#line 196
      goto while_break;
    }
    {
#line 197
    str_add_char(str, *(nstr + pos));
#line 196
    pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (str);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
char *str_to_nstr(str_t *str ) 
{ 
  char *nstr ;
  void *tmp ;
  int pos ;

  {
  {
#line 208
  tmp = xmalloc___0((size_t )(str->len + 1));
#line 208
  nstr = (char *)tmp;
#line 209
  pos = 0;
  }
#line 211
  if (! str) {
#line 212
    return (nstr);
  } else
#line 211
  if (! str->str) {
#line 212
    return (nstr);
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (pos < str->len)) {
#line 214
      goto while_break;
    }
#line 216
    if (! *(str->str + pos)) {
#line 220
      *(str->str + pos) = (char )' ';
    }
#line 222
    *(nstr + pos) = *(str->str + pos);
#line 214
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  *(nstr + (pos + 1)) = (char)0;
#line 226
  return (nstr);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
str_t *int_to_str(int num ) 
{ 
  char c[2] ;
  int pos ;
  int rem ;
  str_t *rstr ;
  str_t *tmp ;
  str_t *str ;
  str_t *tmp___0 ;

  {
  {
#line 240
  pos = 0;
#line 241
  rem = 0;
#line 242
  tmp = str_make((str_t *)0);
#line 242
  rstr = tmp;
#line 243
  tmp___0 = str_make((str_t *)0);
#line 243
  str = tmp___0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (num > 0)) {
#line 247
      goto while_break;
    }
    {
#line 249
    rem = num % 10;
#line 250
    num /= 10;
#line 251
    sprintf((char */* __restrict  */)(c), (char const   */* __restrict  */)"%d", rem);
#line 252
    str_add_char(rstr, c[0]);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  pos = rstr->len - 1;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (pos >= 0)) {
#line 256
      goto while_break___0;
    }
    {
#line 257
    str_add_char(str, *(rstr->str + pos));
#line 256
    pos --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  return (str);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
static void error___0(int status , int errnum , char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
#line 289
  if (! interactive) {
    {
#line 291
    fflush(stdout);
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
    }
  }
  {
#line 295
  __builtin_va_start(args, message);
#line 296
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 297
  __builtin_va_end(args);
  }
#line 299
  if (errnum) {
    {
#line 300
    tmp = strerror(errnum);
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 301
  _IO_putc('\n', stderr);
#line 302
  fflush(stderr);
  }
#line 303
  if (status) {
    {
#line 304
    exit(status);
    }
  }
#line 305
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
static void *xmalloc___0(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 313
  tmp = malloc(size);
#line 313
  ptr = tmp;
  }
#line 315
  if (! ptr) {
    {
#line 316
    error___0(1, 0, "virtual memory exhausted");
    }
  }
#line 317
  return (ptr);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
static void *xrealloc(void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
#line 327
  if (! ptr) {
    {
#line 328
    tmp = xmalloc___0(size);
    }
#line 328
    return (tmp);
  }
  {
#line 329
  ptr = realloc(ptr, size);
  }
#line 330
  if (! ptr) {
    {
#line 331
    error___0(1, 0, "virtual memory exhausted");
    }
  }
#line 332
  return (ptr);
}
}
#line 350
extern int ( /* missing proto */  read)() ;
#line 339 "/home/june/repo/benchmarks/collector/temp/spell-1.0/str.c"
static int safe_read(int desc , char *ptr , int len ) 
{ 
  int n_chars ;
  int *tmp ;

  {
#line 344
  if (len <= 0) {
#line 345
    return (len);
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 350
    n_chars = read(desc, ptr, len);
    }
#line 348
    if (n_chars < 0) {
      {
#line 348
      tmp = __errno_location();
      }
#line 348
      if (! (*tmp == 4)) {
#line 348
        goto while_break;
      }
    } else {
#line 348
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (n_chars);
}
}
