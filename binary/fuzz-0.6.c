/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 81 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 560 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 560 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 538
extern int getchar(void) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern char const   * const  sys_errlist[] ;
#line 873 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 35 "./getopt.h"
extern char *optarg ;
#line 49
extern int optind ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 944 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char *chomp(char *str ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char *readline(char const   *prompt ) 
{ 
  char *retval ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 46
  printf((char const   */* __restrict  */)"%s", prompt);
#line 47
  tmp = malloc((size_t )10240);
#line 47
  retval = (char *)tmp;
#line 48
  *(retval + 10239) = (char)0;
#line 49
  fgets((char */* __restrict  */)retval, 10239, (FILE */* __restrict  */)stdin);
#line 50
  tmp___0 = chomp(retval);
  }
#line 50
  return (tmp___0);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
unsigned long runs  =    10000UL;
#line 99 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char progname[10240]  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char outfilename[10240]  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
pid_t newpid  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char rundone  =    (char)0;
#line 103 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
unsigned long max_args  =    0UL;
#line 104 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char *argfilename  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
int g_argc  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char **g_argv  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
int report  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char sendmail[10240]  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char distribution[10240]  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char dontask  =    (char)0;
#line 112
void print_arglist(FILE *errs , char **argv , char expand_args , char hex ) ;
#line 113
int setup_user(char *distribution___0 , char *sendmail___0 ) ;
#line 114
void handle_sigalrm(int dummy ) ;
#line 115
void handle_sigchld(int dummy ) ;
#line 116
void do_child(int *progpipe , char **argv , char *execute_filename , unsigned long max_arglen ,
              char printable_only , int nullfd , int randfd ) ;
#line 119
void send_report(char result , char report___0 , char *sendmail___0 , char *distribution___0 ) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
char *chomp(char *str ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 122
  tmp = strlen((char const   *)str);
#line 122
  i = (int )tmp;
  }
#line 123
  if ((int )*(str + (i - 1)) == 10) {
#line 124
    *(str + (i - 1)) = (char)0;
  }
#line 125
  return (str);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void usage(void) 
{ 


  {
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: fuzz [-p] [-r runcount] [-p] [-n linemod] [-l length] [-m maxlinelen]\n            [-t timeout] [-c] [-u user] [-x maxargs] [-y maxarglen] [-e number]\n            command [arg...]\n");
#line 130
  exit(1);
  }
}
}
#line 147
int main(int argc , char **argv ) ;
#line 147 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
static struct option  const  longopts[18]  = 
#line 147
  {      {"args", 0, (int *)((void *)0), 'a'}, 
        {"bytes", 0, (int *)((void *)0), 'b'}, 
        {"chroot", 0, (int *)((void *)0), 'c'}, 
        {"dontask", 0, (int *)((void *)0), 'd'}, 
        {"execute", 1, (int *)((void *)0), 'e'}, 
        {"priority", 1, (int *)((void *)0), 'i'}, 
        {"length", 1, (int *)((void *)0), 'l'}, 
        {"maxline", 1, (int *)((void *)0), 'm'}, 
        {"newlines", 1, (int *)((void *)0), 'n'}, 
        {"omitdata", 0, (int *)((void *)0), 'o'}, 
        {"printable", 0, (int *)((void *)0), 'p'}, 
        {"runcount", 1, (int *)((void *)0), 'r'}, 
        {"timeout", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"maxargs", 1, (int *)((void *)0), 'x'}, 
        {"maxarglen", 1, (int *)((void *)0), 'y'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 133 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
int main(int argc , char **argv ) 
{ 
  char binfound ;
  unsigned long max_arglen ;
  char *execute_filename ;
  char printable_only ;
  int curarg ;
  unsigned long len ;
  unsigned long timeout ;
  unsigned long maxline ;
  unsigned long linemod ;
  char print_bytes ;
  char omit_data ;
  char chr ;
  int prio ;
  char *path ;
  char bin_found ;
  FILE *outfile ;
  FILE *infile ;
  struct sigaction act ;
  struct passwd *userinfo ;
  int nullfd ;
  int randfd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char curpath[10240] ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  __uid_t tmp___11 ;
  char *modpath ;
  char *tok ;
  char *tmp___12 ;
  struct stat statbuf ;
  int tmp___13 ;
  struct stat statbuf___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int progpipe[2] ;
  char sendnewline ;
  unsigned long curchar ;
  unsigned long linelen ;
  char *tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char byte ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned short const   **tmp___24 ;
  int *tmp___25 ;
  ssize_t tmp___26 ;
  long tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 134
  binfound = (char)0;
#line 135
  max_arglen = 256UL;
#line 136
  execute_filename = (char *)((void *)0);
#line 137
  printable_only = (char)0;
#line 139
  len = 100000UL;
#line 140
  timeout = 120UL;
#line 141
  maxline = 0UL;
#line 142
  linemod = 0UL;
#line 143
  print_bytes = (char)0;
#line 144
  omit_data = (char)0;
#line 145
  chr = (char)0;
#line 168
  bin_found = (char)0;
#line 172
  userinfo = (struct passwd *)((void *)0);
#line 176
  g_argc = argc;
#line 177
  g_argv = argv;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    curarg = getopt_long(argc, (char * const  *)argv, "+a::bcde:i:l:m:n:opr:t:u:Vx:y:",
                         longopts, (int *)((void *)0));
    }
#line 178
    if (! (curarg != -1)) {
#line 178
      goto while_break;
    }
    {
#line 181
    if (curarg == 114) {
#line 181
      goto case_114;
    }
#line 187
    if (curarg == 108) {
#line 187
      goto case_108;
    }
#line 193
    if (curarg == 112) {
#line 193
      goto case_112;
    }
#line 196
    if (curarg == 110) {
#line 196
      goto case_110;
    }
#line 202
    if (curarg == 109) {
#line 202
      goto case_109;
    }
#line 208
    if (curarg == 116) {
#line 208
      goto case_116;
    }
#line 214
    if (curarg == 98) {
#line 214
      goto case_98;
    }
#line 217
    if (curarg == 99) {
#line 217
      goto case_99;
    }
#line 220
    if (curarg == 117) {
#line 220
      goto case_117;
    }
#line 227
    if (curarg == 111) {
#line 227
      goto case_111;
    }
#line 230
    if (curarg == 97) {
#line 230
      goto case_97;
    }
#line 233
    if (curarg == 120) {
#line 233
      goto case_120;
    }
#line 239
    if (curarg == 121) {
#line 239
      goto case_121;
    }
#line 245
    if (curarg == 101) {
#line 245
      goto case_101;
    }
#line 249
    if (curarg == 105) {
#line 249
      goto case_105;
    }
#line 259
    if (curarg == 86) {
#line 259
      goto case_86;
    }
#line 262
    if (curarg == 100) {
#line 262
      goto case_100;
    }
#line 268
    if (curarg == 63) {
#line 268
      goto case_63;
    }
#line 265
    goto switch_default;
    case_114: /* CIL Label */ 
    {
#line 182
    tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                 & runs);
    }
#line 182
    if (tmp != 1) {
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad number of runs.\n");
#line 184
      usage();
      }
    }
#line 186
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 188
    tmp___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & len);
    }
#line 188
    if (tmp___0 != 1) {
      {
#line 189
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad length of data stream.\n");
#line 190
      usage();
      }
    }
#line 192
    goto switch_break;
    case_112: /* CIL Label */ 
#line 194
    printable_only = (char)1;
#line 195
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 197
    tmp___1 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & linemod);
    }
#line 197
    if (tmp___1 != 1) {
      {
#line 198
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad line length modifier.\n");
#line 199
      usage();
      }
    }
#line 201
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 203
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & maxline);
    }
#line 203
    if (tmp___2 != 1) {
      {
#line 204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad max line length.\n");
#line 205
      usage();
      }
    }
#line 207
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 209
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & timeout);
    }
#line 209
    if (tmp___3 != 1) {
      {
#line 210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad max line length.\n");
#line 211
      usage();
      }
    }
#line 213
    goto switch_break;
    case_98: /* CIL Label */ 
#line 215
    print_bytes = (char)1;
#line 216
    goto switch_break;
    case_99: /* CIL Label */ 
#line 218
    chr = (char)1;
#line 219
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 221
    userinfo = getpwnam((char const   *)optarg);
    }
#line 221
    if ((unsigned long )userinfo == (unsigned long )((void *)0)) {
      {
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t look up user id.\n");
#line 223
      perror((char const   *)*(argv + 0));
#line 224
      exit(1);
      }
    }
#line 226
    goto switch_break;
    case_111: /* CIL Label */ 
#line 228
    omit_data = (char)0;
#line 229
    goto switch_break;
    case_97: /* CIL Label */ 
#line 231
    max_args = 256UL;
#line 232
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 234
    tmp___4 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & max_args);
    }
#line 234
    if (tmp___4 != 1) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad max number of args.\n");
#line 236
      usage();
      }
    }
#line 238
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 240
    tmp___5 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ul",
                     & max_arglen);
    }
#line 240
    if (tmp___5 != 1) {
      {
#line 241
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad max argument length.\n");
#line 242
      usage();
      }
    }
#line 244
    goto switch_break;
    case_101: /* CIL Label */ 
#line 246
    execute_filename = optarg;
#line 247
    runs = 1UL;
#line 248
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 250
    tmp___6 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & prio);
    }
#line 250
    if (tmp___6 != 1) {
      {
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad priority argument.\n");
#line 252
      usage();
      }
    }
    {
#line 254
    tmp___7 = setpriority(0, (id_t )0, prio);
    }
#line 254
    if (tmp___7) {
      {
#line 255
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error setting nice priority.\n");
#line 256
      perror((char const   *)*(argv + 0));
      }
    }
#line 258
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 260
    printf((char const   */* __restrict  */)"full %s\n", "0.6");
#line 261
    exit(0);
    }
    case_100: /* CIL Label */ 
#line 263
    dontask = (char)1;
#line 264
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad argument.\n");
    }
    case_63: /* CIL Label */ 
    {
#line 269
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  report = setup_user(distribution, sendmail);
  }
#line 278
  if (execute_filename) {
    {
#line 279
    infile = fopen((char const   */* __restrict  */)execute_filename, (char const   */* __restrict  */)"r");
    }
#line 279
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 280
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t seem to open file to read from.\n");
#line 281
      perror((char const   *)*(argv + 0));
#line 282
      exit(1);
      }
    }
  } else {
    {
#line 286
    randfd = open("/dev/urandom", 0);
    }
#line 286
    if (randfd == -1) {
      {
#line 287
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s.\n",
              execute_filename);
#line 288
      exit(4);
      }
    }
    {
#line 291
    infile = fdopen(randfd, "r");
    }
#line 291
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 292
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open /dev/random for reading\n");
#line 293
      exit(4);
      }
    }
  }
  {
#line 297
  nullfd = open("/dev/null", 1);
  }
#line 297
  if (nullfd == -1) {
    {
#line 298
    perror("fuzz");
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open /dev/null.\n");
#line 300
    exit(8);
    }
  }
#line 305
  if (chr) {
    {
#line 307
    tmp___8 = getcwd(curpath, (size_t )10240);
    }
#line 307
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t get current path name to chroot to.\n");
#line 309
      perror((char const   *)*(argv + 0));
#line 310
      usage();
      }
    }
    {
#line 312
    tmp___9 = chroot((char const   *)(curpath));
    }
#line 312
    if (tmp___9 == -1) {
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t chroot.\n");
#line 314
      perror((char const   *)*(argv + 0));
#line 315
      exit(2);
      }
    }
  }
#line 319
  if (userinfo) {
    {
#line 319
    tmp___10 = setreuid(userinfo->pw_uid, userinfo->pw_uid);
    }
#line 319
    if (tmp___10 == -1) {
      {
#line 320
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t change to user: %s\n",
              optarg);
#line 321
      perror((char const   *)*(argv + 0));
#line 322
      exit(1);
      }
    }
  }
  {
#line 326
  tmp___11 = getuid();
  }
#line 326
  if (tmp___11 == 0U) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Don\'t run this program as root! ***\n");
    }
#line 328
    if (chr) {
      {
#line 329
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Need option --user USER with --chroot\n");
      }
    }
    {
#line 330
    usage();
    }
  }
#line 334
  if (optind == argc) {
    {
#line 335
    usage();
    }
  }
#line 336
  if ((int )*(*(argv + optind) + 0) == 47) {
#line 336
    goto _L;
  } else
#line 336
  if ((int )*(*(argv + optind) + 0) == 46) {
    _L: /* CIL Label */ 
    {
#line 360
    strcpy((char */* __restrict  */)(progname), (char const   */* __restrict  */)*(argv + optind));
#line 361
    tmp___14 = stat((char const   */* __restrict  */)(progname), (struct stat */* __restrict  */)(& statbuf___0));
    }
#line 361
    if (tmp___14 == 0) {
#line 362
      binfound = (char)1;
    }
  } else {
    {
#line 339
    tmp___12 = getenv("PATH");
    }
#line 339
    if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: no path set using /bin:/usr/bin\n");
#line 341
      path = (char *)"/bin:/usr/bin";
      }
    } else {
      {
#line 343
      path = getenv("PATH");
      }
    }
    {
#line 344
    modpath = strdup((char const   *)path);
#line 345
    tok = strtok((char */* __restrict  */)modpath, (char const   */* __restrict  */)":");
    }
    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 345
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 345
        goto while_break___0;
      }
      {
#line 348
      progname[0] = (char)0;
#line 349
      strncpy((char */* __restrict  */)(progname), (char const   */* __restrict  */)tok,
              (size_t )10240);
#line 350
      strncat((char */* __restrict  */)(progname), (char const   */* __restrict  */)"/",
              (size_t )10240);
#line 351
      strncat((char */* __restrict  */)(progname), (char const   */* __restrict  */)*(argv + optind),
              (size_t )10240);
#line 352
      tmp___13 = stat((char const   */* __restrict  */)(progname), (struct stat */* __restrict  */)(& statbuf));
      }
#line 352
      if (tmp___13 == 0) {
#line 353
        binfound = (char)1;
#line 354
        goto while_break___0;
      }
      {
#line 345
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 364
  if (! binfound) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Program not found.\n");
#line 366
    usage();
    }
  }
  {
#line 370
  act.__sigaction_handler.sa_handler = & handle_sigalrm;
#line 371
  tmp___15 = sigemptyset(& act.sa_mask);
  }
#line 371
  if (tmp___15 == -1) {
    {
#line 372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t clear signal mask.\n");
#line 373
    abort();
    }
  }
  {
#line 375
  act.sa_flags = 0;
#line 376
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 378
  act.__sigaction_handler.sa_handler = & handle_sigchld;
#line 379
  tmp___16 = sigaddset(& act.sa_mask, 14);
  }
#line 379
  if (tmp___16 == -1) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t add SIGALRM to signal mask.\n");
#line 381
    abort();
    }
  }
  {
#line 383
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 388
    if (! runs) {
#line 388
      goto while_break___1;
    }
#line 390
    sendnewline = (char)0;
#line 391
    curchar = 0UL;
#line 391
    linelen = 0UL;
#line 394
    if (! execute_filename) {
      {
#line 395
      tmp___17 = strrchr((char const   *)(progname), '/');
#line 395
      snprintf((char */* __restrict  */)(outfilename), (size_t )10240, (char const   */* __restrict  */)"/tmp%s.%lu",
               tmp___17, runs);
#line 396
      outfile = fopen((char const   */* __restrict  */)(outfilename), (char const   */* __restrict  */)"w");
      }
#line 396
      if ((unsigned long )outfile == (unsigned long )((void *)0)) {
        {
#line 397
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t fopen outfile.\n");
#line 398
        abort();
        }
      }
      {
#line 400
      argfilename = strdup((char const   *)(outfilename));
      }
#line 400
      if ((unsigned long )argfilename == (unsigned long )((void *)0)) {
        {
#line 401
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to strdup outfilename.\n");
#line 402
        exit(5);
        }
      }
      {
#line 405
      tmp___18 = strlen((char const   *)argfilename);
#line 405
      tmp___19 = realloc((void *)argfilename, tmp___18 + 5UL);
#line 405
      argfilename = (char *)tmp___19;
      }
#line 405
      if ((unsigned long )argfilename == (unsigned long )((char *)0)) {
        {
#line 406
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to realloc outfilename.\n");
#line 407
        exit(5);
        }
      }
      {
#line 409
      strcat((char */* __restrict  */)argfilename, (char const   */* __restrict  */)".arg");
      }
    }
#line 412
    if (print_bytes) {
#line 412
      tmp___20 = '\n';
    } else {
#line 412
      tmp___20 = '\r';
    }
    {
#line 412
    printf((char const   */* __restrict  */)"Run: %u         %c", runs, tmp___20);
#line 413
    tmp___21 = pipe((int *)(progpipe));
    }
#line 413
    if (tmp___21 == -1) {
      {
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t pipe.\n");
#line 415
      abort();
      }
    }
#line 418
    if (omit_data) {
#line 418
      rundone = (char)1;
    } else {
#line 418
      rundone = (char)0;
    }
    {
#line 420
    newpid = fork();
    }
#line 420
    if (newpid == -1) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t fork.\n");
#line 422
      abort();
      }
    } else
#line 423
    if (newpid == 0) {
      {
#line 424
      do_child(progpipe, argv + optind, execute_filename, max_arglen, printable_only,
               nullfd, randfd);
      }
    }
    {
#line 430
    alarm((unsigned int )timeout);
#line 444
    curchar = 0UL;
#line 444
    linelen = 0UL;
    }
    {
#line 444
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 444
      if (! rundone) {
#line 444
        if (! (curchar < len)) {
#line 444
          goto while_break___2;
        }
      } else {
#line 444
        goto while_break___2;
      }
#line 447
      if (print_bytes) {
        {
#line 448
        printf((char const   */* __restrict  */)"\t%ld\r", curchar);
        }
      }
#line 449
      if (! sendnewline) {
        {
#line 450
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 451
          tmp___22 = fgetc(infile);
#line 451
          byte = (char )tmp___22;
#line 452
          tmp___23 = feof(infile);
          }
#line 452
          if (tmp___23) {
#line 453
            if (execute_filename) {
#line 454
              goto while_break___3;
            } else {
              {
#line 456
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of random data.\n");
#line 457
              exit(4);
              }
            }
          }
#line 450
          if (printable_only) {
            {
#line 450
            tmp___24 = __ctype_b_loc();
            }
#line 450
            if ((int const   )*(*tmp___24 + (int )byte) & 16384) {
#line 450
              goto while_break___3;
            }
          } else {
#line 450
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 462
        sendnewline = (char)0;
#line 463
        byte = (char )'\n';
      }
#line 467
      if (rundone) {
#line 469
        goto while_break___2;
      }
      {
#line 471
      tmp___26 = write(progpipe[1], (void const   *)(& byte), (size_t )1);
      }
#line 471
      if (tmp___26 == -1L) {
        {
#line 472
        tmp___25 = __errno_location();
        }
#line 472
        if (*tmp___25 == 4) {
#line 473
          goto while_break___2;
        } else {
          {
#line 475
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write failed on pipe.\n");
#line 476
          perror((char const   *)*(argv + 0));
          }
        }
      }
#line 479
      if (! execute_filename) {
        {
#line 480
        fputc((int )byte, outfile);
        }
      }
#line 481
      linelen ++;
#line 482
      if ((int )byte == 10) {
#line 483
        linelen = 0UL;
      }
#line 484
      if (maxline != 0UL) {
#line 484
        if (linelen == maxline) {
#line 486
          sendnewline = (char)1;
        } else {
#line 484
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 484
      if (linemod != 0UL) {
        {
#line 484
        tmp___27 = random();
        }
#line 484
        if ((unsigned long )tmp___27 % linemod == 0UL) {
#line 486
          sendnewline = (char)1;
        }
      }
#line 444
      curchar ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 494
    alarm(0U);
#line 495
    tmp___28 = close(progpipe[0]);
    }
#line 495
    if (tmp___28 == -1) {
      {
#line 496
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Can\'t close pipe ends.\n");
#line 497
      perror((char const   *)*(argv + 0));
      }
    } else {
      {
#line 495
      tmp___29 = close(progpipe[1]);
      }
#line 495
      if (tmp___29 == -1) {
        {
#line 496
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Can\'t close pipe ends.\n");
#line 497
        perror((char const   *)*(argv + 0));
        }
      }
    }
    {
#line 499
    kill(newpid, 2);
    }
#line 501
    if (! execute_filename) {
      {
#line 502
      fclose(outfile);
      }
    }
    {
#line 503
    tmp___30 = unlink((char const   *)(outfilename));
    }
#line 503
    if (tmp___30 == -1) {
      {
#line 504
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t unlink data file.\n");
#line 505
      perror((char const   *)*(argv + 0));
      }
    }
#line 507
    if (max_args) {
      {
#line 507
      tmp___31 = unlink((char const   *)argfilename);
      }
#line 507
      if (tmp___31 == -1) {
        {
#line 508
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t unlink arguments file.\n");
#line 509
        perror((char const   *)*(argv + 0));
        }
      }
    }
    {
#line 511
    fflush(stdout);
#line 388
    runs --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 515
  printf((char const   */* __restrict  */)"Testing %s done -- No faults found.\n",
         progname);
#line 517
  send_report((char)1, (char )report, sendmail, distribution);
#line 518
  exit(0);
  }
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void print_arglist(FILE *errs , char **argv , char expand_args , char hex ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
  {
#line 524
  fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"argv=0x%x\n",
          argv);
#line 525
  i = 0U;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! ((unsigned long )*(argv + i) != (unsigned long )((void *)0))) {
#line 525
      goto while_break;
    }
    {
#line 526
    fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"\targv[%u]=0x%x\n",
            i, *(argv + i));
    }
#line 527
    if (expand_args) {
#line 528
      if (hex) {
        {
#line 530
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"argv[%u]: ",
                i);
#line 531
        j = 0U;
        }
        {
#line 531
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 531
          if (! ((int )*(*(argv + i) + j) != 0)) {
#line 531
            goto while_break___0;
          }
          {
#line 532
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"%0.2x ",
                  (int )*(*(argv + i) + j));
#line 531
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 534
        fputc('\n', errs);
        }
      } else {
        {
#line 536
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"argv[%u]: %s\n",
                i, *(argv + i));
        }
      }
    }
#line 525
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void handle_sigalrm(int dummy ) 
{ 
  int status ;

  {
  {
#line 546
  printf((char const   */* __restrict  */)"\nProgram killed by signal.\n");
#line 547
  signal(17, (void (*)(int  ))0);
#line 548
  kill(newpid, 9);
#line 549
  wait((union wait *)(& status));
#line 550
  printf((char const   */* __restrict  */)"\n");
#line 551
  exit(0);
  }
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void handle_sigchld(int dummy ) 
{ 
  int status ;
  int termsig ;
  union __anonunion_67 __constr_expr_0 ;
  union __anonunion_68 __constr_expr_1 ;

  {
  {
#line 557
  rundone = (char)1;
#line 558
  alarm(0U);
#line 559
  wait((union wait *)(& status));
#line 560
  __constr_expr_0.__in = status;
  }
#line 560
  if ((int )((signed char )((__constr_expr_0.__i & 127) + 1)) >> 1 > 0) {
#line 560
    __constr_expr_1.__in = status;
#line 560
    termsig = __constr_expr_1.__i & 127;
#line 560
    if (termsig == 4) {
      {
#line 563
      printf((char const   */* __restrict  */)"Program: %s\n\tProblem: CRASH\tSignal: %d\tRun: %lu\tDatafile: %s\n",
             progname, termsig, runs, outfilename);
#line 565
      send_report((char)0, (char )report, sendmail, distribution);
#line 566
      printf((char const   */* __restrict  */)"\n");
#line 567
      exit(0);
      }
    } else
#line 560
    if (termsig == 11) {
      {
#line 563
      printf((char const   */* __restrict  */)"Program: %s\n\tProblem: CRASH\tSignal: %d\tRun: %lu\tDatafile: %s\n",
             progname, termsig, runs, outfilename);
#line 565
      send_report((char)0, (char )report, sendmail, distribution);
#line 566
      printf((char const   */* __restrict  */)"\n");
#line 567
      exit(0);
      }
    } else
#line 560
    if (termsig == 7) {
      {
#line 563
      printf((char const   */* __restrict  */)"Program: %s\n\tProblem: CRASH\tSignal: %d\tRun: %lu\tDatafile: %s\n",
             progname, termsig, runs, outfilename);
#line 565
      send_report((char)0, (char )report, sendmail, distribution);
#line 566
      printf((char const   */* __restrict  */)"\n");
#line 567
      exit(0);
      }
    } else
#line 560
    if (termsig == 9) {
      {
#line 563
      printf((char const   */* __restrict  */)"Program: %s\n\tProblem: CRASH\tSignal: %d\tRun: %lu\tDatafile: %s\n",
             progname, termsig, runs, outfilename);
#line 565
      send_report((char)0, (char )report, sendmail, distribution);
#line 566
      printf((char const   */* __restrict  */)"\n");
#line 567
      exit(0);
      }
    }
  }
#line 570
  return;
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void do_child(int *progpipe , char **argv , char *execute_filename , unsigned long max_arglen ,
              char printable_only , int nullfd , int randfd ) 
{ 
  int cpy_stderr ;
  char **arguments ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  unsigned int numoldargs ;
  unsigned int numargs ;
  long tmp___5 ;
  unsigned int totalargs ;
  size_t dummy ;
  char **curarg ;
  int argfilefd ;
  FILE *errs ;
  size_t tmp___6 ;
  unsigned int i ;
  size_t tmp___7 ;
  void *tmp___8 ;
  ssize_t tmp___9 ;
  void *tmp___10 ;
  unsigned int paramlen ;
  ssize_t tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;
  ssize_t tmp___14 ;
  void *tmp___15 ;
  ssize_t tmp___16 ;
  size_t arglen ;
  size_t tmp___17 ;
  ssize_t tmp___18 ;
  ssize_t tmp___19 ;
  unsigned long curarglen ;
  long tmp___20 ;
  unsigned int i___0 ;
  void *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  ssize_t tmp___24 ;
  FILE *randfile ;
  FILE *tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  ssize_t tmp___28 ;
  ssize_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int *tmp___32 ;
  size_t tmp___33 ;
  int *tmp___34 ;

  {
  {
#line 578
  arguments = argv;
#line 581
  tmp = chdir("/tmp");
  }
#line 581
  if (tmp == -1) {
    {
#line 582
    perror("fuzz");
#line 583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t change working dir to /tmp.\n");
#line 584
    exit(8);
    }
  }
  {
#line 587
  tmp___0 = dup2(*(progpipe + 0), 0);
  }
#line 587
  if (tmp___0 == -1) {
    {
#line 588
    perror("fuzz");
#line 589
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t dup2 stdin to pipe.\n");
#line 590
    exit(8);
    }
  }
  {
#line 592
  close(*(progpipe + 0));
#line 593
  close(*(progpipe + 1));
#line 596
  tmp___1 = dup2(nullfd, 1);
  }
#line 596
  if (tmp___1 == -1) {
    {
#line 597
    perror("fuzz");
#line 598
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t dup2 stdout to /dev/null.\n");
#line 599
    exit(8);
    }
  }
  {
#line 605
  cpy_stderr = dup(2);
  }
#line 605
  if (cpy_stderr == -1) {
    {
#line 606
    perror("fuzz");
#line 607
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t dup stderr.\n");
#line 608
    exit(8);
    }
  }
  {
#line 611
  tmp___2 = fcntl(cpy_stderr, 2);
  }
#line 611
  if (tmp___2 == -1) {
    {
#line 612
    perror("fuzz");
#line 613
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t close on exec cpy_stderr\n");
#line 614
    exit(8);
    }
  }
  {
#line 617
  tmp___4 = dup2(nullfd, 2);
  }
#line 617
  if (tmp___4 == -1) {
    {
#line 618
    perror("fuzz");
#line 619
    tmp___3 = strlen("Can\'t dup2 stderr to /dev/null.\n");
#line 619
    write(cpy_stderr, (void const   *)"Can\'t dup2 stderr to /dev/null.\n", tmp___3);
#line 621
    exit(8);
    }
  }
  {
#line 623
  close(nullfd);
  }
#line 627
  if (max_args) {
    {
#line 628
    numoldargs = 0U;
#line 629
    tmp___5 = random();
#line 629
    numargs = (unsigned int )((unsigned long )tmp___5 % max_args);
#line 637
    errs = fdopen(cpy_stderr, "w");
    }
#line 637
    if ((unsigned long )errs == (unsigned long )((void *)0)) {
      {
#line 638
      tmp___6 = strlen("fdopen fails\n");
#line 638
      write(cpy_stderr, (void const   *)"fdopen fails\n", tmp___6);
#line 639
      exit(8);
      }
    }
#line 643
    if (execute_filename) {
      {
#line 646
      tmp___7 = strlen((char const   *)execute_filename);
#line 646
      tmp___8 = realloc((void *)execute_filename, tmp___7 + 5UL);
#line 646
      execute_filename = (char *)tmp___8;
      }
#line 646
      if (execute_filename) {
        {
#line 648
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t realloc execute_filename.\n");
#line 649
        exit(6);
        }
      }
      {
#line 652
      strcat((char */* __restrict  */)execute_filename, (char const   */* __restrict  */)".arg");
#line 655
      tmp___9 = read(randfd, (void *)(& totalargs), sizeof(totalargs));
#line 655
      dummy = (size_t )tmp___9;
      }
#line 655
      if (dummy == 0xffffffffffffffffUL) {
        {
#line 657
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read number of arguments.\n");
#line 658
        exit(5);
        }
      } else
#line 655
      if (dummy != sizeof(totalargs)) {
        {
#line 657
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read number of arguments.\n");
#line 658
        exit(5);
        }
      }
      {
#line 661
      tmp___10 = malloc((unsigned long )(1U + totalargs) * sizeof(char *));
#line 661
      argv = (char **)tmp___10;
#line 661
      curarg = argv;
#line 661
      arguments = curarg;
      }
#line 661
      if ((unsigned long )arguments == (unsigned long )((void *)0)) {
        {
#line 662
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to malloc space for args.\n");
#line 663
        exit(6);
        }
      }
#line 665
      *(argv + totalargs) = (char *)((void *)0);
#line 667
      i = 0U;
      {
#line 667
      while (1) {
        while_continue: /* CIL Label */ ;
#line 667
        if (! (i < totalargs)) {
#line 667
          goto while_break;
        }
        {
#line 669
        tmp___11 = read(randfd, (void *)(& paramlen), sizeof(paramlen));
#line 669
        dummy = (size_t )tmp___11;
        }
#line 669
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 671
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read number of arguments.\n");
#line 672
          exit(5);
          }
        } else
#line 669
        if (dummy != sizeof(paramlen)) {
          {
#line 671
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read number of arguments.\n");
#line 672
          exit(5);
          }
        }
        {
#line 674
        tmp___13 = malloc((size_t )(paramlen + 1U));
#line 674
        tmp___12 = (char *)tmp___13;
#line 674
        *curarg = tmp___12;
        }
#line 674
        if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
          {
#line 675
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to malloc space for arg.\n");
#line 676
          exit(6);
          }
        }
        {
#line 678
        *(*curarg + paramlen) = (char)0;
#line 680
        tmp___14 = read(randfd, (void *)*curarg, (size_t )paramlen);
#line 680
        dummy = (size_t )tmp___14;
        }
#line 680
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 681
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read parameter.\n");
#line 682
          exit(5);
          }
        } else
#line 680
        if (dummy != (size_t )paramlen) {
          {
#line 681
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed to read parameter.\n");
#line 682
          exit(5);
          }
        }
#line 667
        i ++;
#line 667
        curarg ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 685
      close(randfd);
      }
    } else {
      {
#line 687
      argfilefd = open((char const   *)argfilename, 577, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
      }
#line 687
      if (argfilefd == -1) {
        {
#line 689
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t open argument file.\n");
#line 690
        exit(5);
        }
      }
#line 694
      curarg = argv + 1;
      {
#line 694
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 694
        if (! ((unsigned long )*curarg != (unsigned long )((void *)0))) {
#line 694
          goto while_break___0;
        }
        {
#line 695
        numoldargs ++;
#line 698
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"counting - %s\n",
                *curarg);
#line 694
        curarg ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 703
      totalargs = numoldargs + numargs;
#line 709
      tmp___15 = malloc((unsigned long )(totalargs + 1U) * sizeof(char *));
#line 709
      curarg = (char **)tmp___15;
#line 709
      arguments = curarg;
      }
#line 709
      if ((unsigned long )arguments == (unsigned long )((void *)0)) {
        {
#line 710
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Not enough memory to allocate random args.\n");
#line 711
        exit(6);
        }
      }
#line 715
      dummy = (size_t )0;
      {
#line 715
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 715
        if (! (dummy <= (size_t )totalargs)) {
#line 715
          goto while_break___1;
        }
#line 716
        *(arguments + dummy) = (char *)((void *)0);
#line 715
        dummy ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 720
      tmp___16 = write(argfilefd, (void const   *)(& totalargs), sizeof(totalargs));
#line 720
      dummy = (size_t )tmp___16;
      }
#line 720
      if (dummy == 0xffffffffffffffffUL) {
        {
#line 722
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write number of args.\n");
#line 723
        exit(5);
        }
      } else
#line 720
      if (dummy != sizeof(totalargs)) {
        {
#line 722
        fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write number of args.\n");
#line 723
        exit(5);
        }
      }
#line 731
      argv ++;
      {
#line 731
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 731
        if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 731
          goto while_break___2;
        }
        {
#line 732
        tmp___17 = strlen((char const   *)*argv);
#line 732
        arglen = tmp___17;
#line 737
        *curarg = *argv;
#line 738
        tmp___18 = write(argfilefd, (void const   *)(& arglen), sizeof(arglen));
#line 738
        dummy = (size_t )tmp___18;
        }
#line 738
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 740
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write old arg length.\n");
#line 741
          exit(5);
          }
        } else
#line 738
        if (dummy != sizeof(arglen)) {
          {
#line 740
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write old arg length.\n");
#line 741
          exit(5);
          }
        }
        {
#line 743
        tmp___19 = write(argfilefd, (void const   *)*curarg, arglen);
#line 743
        dummy = (size_t )tmp___19;
        }
#line 743
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 744
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write old arg.\n");
#line 745
          exit(5);
          }
        } else
#line 743
        if (dummy != arglen) {
          {
#line 744
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write old arg.\n");
#line 745
          exit(5);
          }
        }
#line 731
        curarg ++;
#line 731
        argv ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 754
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 754
        if (! numargs) {
#line 754
          goto while_break___3;
        }
        {
#line 755
        tmp___20 = random();
#line 755
        curarglen = (unsigned long )tmp___20 % max_arglen;
#line 762
        tmp___21 = malloc(curarglen + 1UL);
#line 762
        *(curarg + 0) = (char *)tmp___21;
        }
#line 765
        if ((unsigned long )*(curarg + 0) == (unsigned long )((void *)0)) {
          {
#line 766
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Not enough memory to allocate parameters.\n");
#line 767
          exit(6);
          }
        }
        {
#line 773
        *(*curarg + curarglen) = (char)0;
#line 775
        tmp___24 = read(randfd, (void *)*curarg, curarglen);
        }
#line 775
        if ((unsigned long )tmp___24 != curarglen) {
          {
#line 776
          tmp___22 = __errno_location();
#line 776
          tmp___23 = strerror(*tmp___22);
#line 776
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Failed read on /dev/random. - %s\n",
                  tmp___23);
#line 777
          exit(4);
          }
        }
#line 780
        if (printable_only) {
          {
#line 781
          tmp___25 = fopen((char const   */* __restrict  */)"/dev/urandom", (char const   */* __restrict  */)"r");
#line 781
          randfile = tmp___25;
#line 782
          i___0 = 0U;
          }
          {
#line 782
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 782
            if (! ((unsigned long )i___0 < curarglen)) {
#line 782
              goto while_break___4;
            }
            {
#line 783
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 783
              tmp___27 = __ctype_b_loc();
              }
#line 783
              if ((int const   )*(*tmp___27 + (int )*(*curarg + i___0)) & 16384) {
#line 783
                goto while_break___5;
              }
              {
#line 784
              tmp___26 = fgetc(randfile);
#line 784
              *(*curarg + i___0) = (char )tmp___26;
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 782
            i___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 787
          fclose(randfile);
          }
        }
        {
#line 792
        tmp___28 = write(argfilefd, (void const   *)(& curarglen), sizeof(curarglen));
#line 792
        dummy = (size_t )tmp___28;
        }
#line 792
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 794
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write arg length.\n");
#line 795
          exit(5);
          }
        } else
#line 792
        if (dummy != sizeof(curarglen)) {
          {
#line 794
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write arg length.\n");
#line 795
          exit(5);
          }
        }
        {
#line 797
        tmp___29 = write(argfilefd, (void const   *)*curarg, curarglen);
#line 797
        dummy = (size_t )tmp___29;
        }
#line 797
        if (dummy == 0xffffffffffffffffUL) {
          {
#line 799
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write arg.\n");
#line 800
          exit(5);
          }
        } else
#line 797
        if (dummy != curarglen) {
          {
#line 799
          fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Can\'t write arg.\n");
#line 800
          exit(5);
          }
        }
#line 754
        numargs --;
#line 754
        curarg ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 804
    tmp___30 = fcntl(randfd, 2);
    }
#line 804
    if (tmp___30 == -1) {
      {
#line 805
      fprintf((FILE */* __restrict  */)errs, (char const   */* __restrict  */)"Cant set close on exec for randfd.\n");
#line 806
      exit(8);
      }
    }
    {
#line 808
    close(argfilefd);
#line 809
    close(randfd);
    }
  }
  {
#line 815
  execv((char const   *)(progname), (char * const  *)arguments);
#line 816
  tmp___31 = strlen("Exec failed.\n");
#line 816
  write(cpy_stderr, (void const   *)"Exec failed.\n", tmp___31);
#line 817
  tmp___32 = __errno_location();
#line 817
  tmp___33 = strlen((char const   *)sys_errlist[*tmp___32]);
#line 817
  tmp___34 = __errno_location();
#line 817
  write(cpy_stderr, (void const   *)sys_errlist[*tmp___34], tmp___33);
#line 818
  exit(7);
  }
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
int setup_user(char *distribution___0 , char *sendmail___0 ) 
{ 
  char strbuf[10240] ;
  char *tmpbuf ;
  int rcf ;
  int fd ;
  int tmp ;
  struct stat statbuf ;
  int report___0 ;
  char const   *tmp___0 ;
  __off_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char tmp___10 ;
  int tmp___11 ;
  char tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  ssize_t tmp___19 ;
  ssize_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;

  {
  {
#line 830
  tmpbuf = getenv("HOME");
  }
#line 830
  if ((unsigned long )tmpbuf != (unsigned long )((void *)0)) {
#line 830
    tmp___0 = (char const   *)tmpbuf;
  } else {
#line 830
    tmp___0 = ".";
  }
  {
#line 830
  snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"%s/.fuzzrc",
           tmp___0);
#line 832
  rcf = open((char const   *)(strbuf), 66, 420);
  }
#line 832
  if (rcf == -1) {
    {
#line 833
    perror("fuzz");
#line 834
    exit(9);
    }
  }
  {
#line 836
  tmp___1 = lseek(rcf, (__off_t )0, 2);
  }
  {
#line 837
  if (tmp___1 == 0L) {
#line 837
    goto case_0;
  }
#line 972
  if (tmp___1 == -1L) {
#line 972
    goto case_neg_1;
  }
#line 976
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 839
  report___0 = 0;
#line 840
  printf((char const   */* __restrict  */)"To make it possible to better coordinate the debugging of Linux, can fuzz \nreport results back to the master fuzz site using email? EVERY EFFORT WILL BE\nMADE TO KEEP INFORMATION ANONYMOUS. Your email address will not be recorded or\ndisclosed to anyone including the fuzz developers. The email will contain only\nthe following information:\n\t1. The operating system you are running.\n\t2. The distribution that you are running.\n\t3. Whether fuzz was able to automatically determine the distribution\n\t   you were running.\n\t4. The version of fuzz you are running.\n\t5. The command line options passed to fuzz.\n\t6. The name of the program being tested.\n\t7. The version of the program being tested.\n\t8. The dynamic libraries that it is linked against.\n\t9. The results of the test.\nIf the program is part of an RPM or dpkg based distribuion:\n\t10. The package that the program belogs to.\nIn the case where a program fails the fuzz test, then:\n\t11. The data set which caused it to fail.\n");
  }
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! (! report___0)) {
#line 860
      goto while_break;
    }
    {
#line 861
    printf((char const   */* __restrict  */)"Allow fuzz to report findings? (Y/n) ");
#line 862
    tmp___2 = getchar();
    }
    {
#line 865
    if (tmp___2 == 89) {
#line 865
      goto case_89;
    }
#line 865
    if (tmp___2 == 121) {
#line 865
      goto case_89;
    }
#line 865
    if (tmp___2 == 10) {
#line 865
      goto case_89;
    }
#line 869
    if (tmp___2 == 78) {
#line 869
      goto case_78;
    }
#line 869
    if (tmp___2 == 110) {
#line 869
      goto case_78;
    }
#line 872
    goto switch_default;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 866
    report___0 = 1;
#line 867
    goto switch_break___0;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 870
    report___0 = 2;
#line 871
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 873
    printf((char const   */* __restrict  */)"\a\nDidn\'t understand that. ");
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  if (report___0 != 1) {
    {
#line 889
    report___0 = 0;
#line 890
    tmp___3 = write(rcf, (void const   *)"report=0\n", (size_t )9);
    }
#line 890
    if (tmp___3 == -1L) {
      {
#line 891
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t write to .fuzzrc\n");
#line 892
      perror("fuzz");
#line 893
      exit(9);
      }
    }
    {
#line 895
    tmp___4 = write(rcf, (void const   *)"sendmail=0\n", (size_t )9);
    }
#line 895
    if (tmp___4 == -1L) {
      {
#line 896
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t write to .fuzzrc\n");
#line 897
      perror("fuzz");
#line 898
      exit(9);
      }
    }
  } else {
    {
#line 901
    tmp___5 = write(rcf, (void const   *)"report=1\n", (size_t )9);
    }
#line 901
    if (tmp___5 == -1L) {
      {
#line 902
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t write to .fuzzrc\n");
#line 903
      perror("fuzz");
#line 904
      exit(9);
      }
    }
    {
#line 906
    tmp___9 = stat((char const   */* __restrict  */)"/bin/rpm", (struct stat */* __restrict  */)(& statbuf));
    }
#line 906
    if (tmp___9 != -1) {
      {
#line 908
      fd = open("/etc/redhat-release", 0);
      }
#line 908
      if (fd != -1) {
        {
#line 909
        tmp___6 = read(fd, (void *)(distribution___0 + 1), (size_t )10239);
#line 909
        tmp = (int )tmp___6;
        }
#line 909
        if (tmp == -1) {
          {
#line 910
          strcpy((char */* __restrict  */)distribution___0, (char const   */* __restrict  */)"Runknown RPM based release");
          }
        } else {
          {
#line 913
          *(distribution___0 + 0) = (char )'K';
#line 914
          chomp(distribution___0);
          }
        }
        {
#line 916
        close(fd);
        }
      } else {
        {
#line 918
        strcpy((char */* __restrict  */)distribution___0, (char const   */* __restrict  */)"Nunknown RPM based release");
        }
      }
    } else {
      {
#line 920
      tmp___8 = stat((char const   */* __restrict  */)"/bin/dpkg", (struct stat */* __restrict  */)(& statbuf));
      }
#line 920
      if (tmp___8 == -1) {
        {
#line 921
        fd = open("/etc/debian_version", 0);
        }
#line 921
        if (fd != -1) {
          {
#line 922
          tmp___7 = read(fd, (void *)(distribution___0 + 1), (size_t )10239);
#line 922
          tmp = (int )tmp___7;
          }
#line 922
          if (tmp == -1) {
            {
#line 923
            strcpy((char */* __restrict  */)distribution___0, (char const   */* __restrict  */)"Sunknown dpkg based release");
            }
          } else {
            {
#line 926
            *(distribution___0 + 0) = (char )'D';
#line 927
            chomp(distribution___0);
            }
          }
          {
#line 929
          close(fd);
          }
        } else {
          {
#line 931
          strcpy((char */* __restrict  */)distribution___0, (char const   */* __restrict  */)"Ounknown dpkg based release");
          }
        }
      } else {
#line 934
        *(distribution___0 + 0) = (char )'U';
#line 935
        *(distribution___0 + 1) = (char )'?';
      }
    }
    {
#line 937
    snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"\n\nDistribution? [%s] ",
             distribution___0 + 1);
#line 938
    tmpbuf = readline((char const   *)(strbuf));
    }
#line 939
    if ((unsigned long )tmpbuf != (unsigned long )((void *)0)) {
#line 940
      if ((int )*(tmpbuf + 0) != 0) {
        {
#line 941
        tmp___11 = strncmp((char const   *)(distribution___0 + 1), (char const   *)tmpbuf,
                           (size_t )10240);
#line 941
        tmp___10 = (char )(tmp___11 != 0);
#line 941
        *(distribution___0 + 0) = tmp___10;
        }
#line 941
        if (tmp___10) {
#line 942
          *(distribution___0 + 0) = (char )'C';
        }
        {
#line 943
        tmp___13 = strncmp((char const   *)(distribution___0 + 1), (char const   *)tmpbuf,
                           (size_t )10240);
#line 943
        tmp___12 = (char )(tmp___13 != 0);
#line 943
        *(distribution___0 + 0) = tmp___12;
        }
#line 943
        if (tmp___12) {
#line 944
          *(distribution___0 + 0) = (char )'B';
        }
        {
#line 945
        strncpy((char */* __restrict  */)(distribution___0 + 1), (char const   */* __restrict  */)tmpbuf,
                (size_t )10238);
        }
      }
      {
#line 947
      free((void *)tmpbuf);
      }
    }
    {
#line 949
    tmp = snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"dist_certainty=%c\ndist=%s\n",
                   (int )*(distribution___0 + 0), distribution___0 + 1);
#line 951
    tmp___14 = write(rcf, (void const   *)(strbuf), (size_t )tmp);
    }
#line 951
    if (tmp___14 == -1L) {
      {
#line 952
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t write to .fuzzrc\n");
#line 953
      perror("fuzz");
#line 954
      exit(9);
      }
    }
    {
#line 957
    sendmail___0 = (char *)"/usr/lib/sendmail";
#line 957
    tmp___17 = stat((char const   */* __restrict  */)sendmail___0, (struct stat */* __restrict  */)(& statbuf));
    }
#line 957
    if (tmp___17 == -1) {
      {
#line 957
      sendmail___0 = (char *)"/usr/sbin/sendmail";
#line 957
      tmp___18 = stat((char const   */* __restrict  */)sendmail___0, (struct stat */* __restrict  */)(& statbuf));
      }
#line 957
      if (tmp___18 == -1) {
        {
#line 959
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 960
          sendmail___0 = readline("Where is sendmail? ");
#line 959
          tmp___15 = stat((char const   */* __restrict  */)sendmail___0, (struct stat */* __restrict  */)(& statbuf));
          }
#line 959
          if (tmp___15) {
            {
#line 959
            tmp___16 = printf((char const   */* __restrict  */)"Didn\'t understand that. ");
            }
#line 959
            if (! tmp___16) {
#line 959
              goto while_break___0;
            }
          } else {
#line 959
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 963
    tmp = snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"sendmail=%s\n",
                   sendmail___0);
#line 964
    tmp___19 = write(rcf, (void const   *)(strbuf), (size_t )tmp);
    }
#line 964
    if (tmp___19 == -1L) {
      {
#line 965
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t write to .fuzzrc\n");
#line 966
      perror("fuzz");
#line 967
      exit(9);
      }
    }
  }
  {
#line 970
  close(rcf);
  }
#line 971
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 973
  perror("fuzz");
#line 974
  exit(9);
  }
#line 975
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 979
  lseek(rcf, (__off_t )0, 0);
#line 980
  tmp___20 = read(rcf, (void *)(strbuf), (size_t )10240);
  }
#line 980
  if (tmp___20 == -1L) {
    {
#line 981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read failed on .fuzzrc\n");
#line 982
    perror("fuzz");
#line 983
    exit(9);
    }
  }
  {
#line 985
  tmpbuf = strtok((char */* __restrict  */)(strbuf), (char const   */* __restrict  */)"\n");
  }
  {
#line 985
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 985
    if (! ((unsigned long )tmpbuf != (unsigned long )((void *)0))) {
#line 985
      goto while_break___1;
    }
    {
#line 986
    tmp___27 = strncmp((char const   *)tmpbuf, "report=", (size_t )7);
    }
#line 986
    if (tmp___27) {
      {
#line 992
      tmp___26 = strncmp((char const   *)tmpbuf, "dist_certainty=", (size_t )15);
      }
#line 992
      if (tmp___26) {
        {
#line 997
        tmp___25 = strncmp((char const   *)tmpbuf, "dist=", (size_t )5);
        }
#line 997
        if (tmp___25) {
          {
#line 999
          tmp___24 = strncmp((char const   *)tmpbuf, "sendmail=", (size_t )9);
          }
#line 999
          if (tmp___24) {
            {
#line 1005
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Corrupt .fuzzrc\n");
#line 1006
            exit(9);
            }
          } else {
            {
#line 1000
            tmp___23 = sscanf((char const   */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"sendmail=%s",
                              sendmail___0);
            }
#line 1000
            if (tmp___23 != 1) {
              {
#line 1001
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read sendmail from .fuzzrc\n");
#line 1002
              exit(9);
              }
            }
          }
        } else {
          {
#line 998
          strcpy((char */* __restrict  */)(distribution___0 + 1), (char const   */* __restrict  */)(tmpbuf + 5));
          }
        }
      } else {
        {
#line 993
        tmp___22 = sscanf((char const   */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"dist_certainty=%c",
                          distribution___0);
        }
#line 993
        if (tmp___22 != 1) {
          {
#line 994
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read dist_certainty from .fuzzrc\n");
#line 995
          exit(9);
          }
        }
      }
    } else {
      {
#line 987
      tmp___21 = sscanf((char const   */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"report=%d",
                        & report___0);
      }
#line 987
      if (tmp___21 != 1) {
        {
#line 988
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read report from .fuzzrc\n");
#line 989
        exit(9);
        }
      } else
#line 990
      if (report___0 == 0) {
#line 991
        goto while_break___1;
      }
    }
    {
#line 985
    tmpbuf = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1009
  if (report___0) {
#line 1010
    if ((int )*distribution___0 != 82) {
#line 1010
      if ((int )*distribution___0 != 75) {
#line 1010
        if ((int )*distribution___0 != 78) {
#line 1010
          if ((int )*distribution___0 != 68) {
#line 1010
            if ((int )*distribution___0 != 85) {
#line 1010
              if ((int )*distribution___0 != 67) {
                {
#line 1013
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not all required variables are present in .fuzzrc\n");
#line 1014
                exit(9);
                }
              } else {
#line 1010
                goto _L___3;
              }
            } else {
#line 1010
              goto _L___3;
            }
          } else {
#line 1010
            goto _L___3;
          }
        } else {
#line 1010
          goto _L___3;
        }
      } else {
#line 1010
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 1010
      tmp___28 = strlen((char const   *)(distribution___0 + 1));
      }
#line 1010
      if (tmp___28 == 0UL) {
        {
#line 1013
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not all required variables are present in .fuzzrc\n");
#line 1014
        exit(9);
        }
      } else {
        {
#line 1010
        tmp___29 = strlen((char const   *)sendmail___0);
        }
#line 1010
        if (tmp___29 == 0UL) {
          {
#line 1013
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not all required variables are present in .fuzzrc\n");
#line 1014
          exit(9);
          }
        }
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1018
  return (report___0);
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/fuzz-0.6/fuzz.c"
void send_report(char result , char report___0 , char *sendmail___0 , char *distribution___0 ) 
{ 
  FILE *mail ;
  FILE *version ;
  int i ;
  char strbuf[10240] ;
  char *tmp ;
  time_t tm ;
  char *tmp___0 ;
  int tmp___1 ;
  char *cur ;
  struct stat statbuf ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char tmpbuf[10240] ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int fd ;
  int len ;
  int i___0 ;
  ssize_t tmp___17 ;
  ssize_t tmp___18 ;

  {
#line 1022
  if (report___0) {
#line 1028
    if (dontask) {
      {
#line 1029
      tmp = strdup("NULL");
      }
    } else {
      {
#line 1031
      tmp = readline("Version of program tested? ");
      }
    }
    {
#line 1033
    fputs((char const   */* __restrict  */)"Sending report", (FILE */* __restrict  */)stdout);
#line 1034
    fflush(stdout);
#line 1035
    snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"%s %s %s",
             sendmail___0, "-odi -oem -Ffuzz", "fuzzmonster@zgp.org");
#line 1037
    mail = popen((char const   *)(strbuf), "w");
    }
#line 1037
    if ((unsigned long )mail == (unsigned long )((void *)0)) {
      {
#line 1038
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t send report\n");
#line 1039
      exit(10);
      }
    }
    {
#line 1042
    time(& tm);
#line 1043
    tmp___0 = ctime((time_t const   *)(& tm));
#line 1043
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"From: fuzz program\nTo: %s\nSubject: results\nDate: %s\n",
            "fuzzmonster@zgp.org", tmp___0);
#line 1047
    fputs((char const   */* __restrict  */)" 1", (FILE */* __restrict  */)stdout);
#line 1048
    fflush(stdout);
#line 1049
    version = popen("uname -a", "r");
    }
#line 1049
    if ((unsigned long )version == (unsigned long )((void *)0)) {
      {
#line 1050
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t figure out system type with uname -a.\n");
#line 1051
      perror("fuzz");
#line 1052
      exit(10);
      }
    }
    {
#line 1054
    fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
    }
    {
#line 1056
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1056
      tmp___1 = feof(version);
      }
#line 1056
      if (tmp___1) {
#line 1056
        goto while_break;
      }
      {
#line 1057
      fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1059
    pclose(version);
#line 1060
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"os=%s",
            strbuf);
#line 1063
    fputs((char const   */* __restrict  */)" 2 3 4", (FILE */* __restrict  */)stdout);
#line 1064
    fflush(stdout);
#line 1065
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"distribution=%s\nfuzz_version=%s\n",
            distribution___0, "0.6");
#line 1068
    fputs((char const   */* __restrict  */)" 5", (FILE */* __restrict  */)stdout);
#line 1069
    fflush(stdout);
#line 1070
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"num_args=%d\n",
            g_argc);
#line 1071
    i = 0;
    }
    {
#line 1071
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1071
      if (! (i < g_argc)) {
#line 1071
        goto while_break___0;
      }
      {
#line 1072
      fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"arg[%d]=\"%s\"\n",
              i, *(g_argv + i));
#line 1071
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1076
    fputs((char const   */* __restrict  */)" 6 7", (FILE */* __restrict  */)stdout);
#line 1077
    fflush(stdout);
#line 1078
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"program_name=%s\nprogram_version=%s\n",
            progname, tmp);
#line 1079
    free((void *)tmp);
#line 1082
    fputs((char const   */* __restrict  */)" 8", (FILE */* __restrict  */)stdout);
#line 1083
    fflush(stdout);
#line 1084
    snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"ldd %s",
             progname);
#line 1085
    version = popen((char const   *)(strbuf), "r");
    }
#line 1085
    if ((unsigned long )version == (unsigned long )((void *)0)) {
      {
#line 1086
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t run ldd.\n");
#line 1087
      perror("fuzz");
#line 1088
      exit(10);
      }
    }
#line 1090
    i = 0;
    {
#line 1090
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1090
      tmp___7 = feof(version);
      }
#line 1090
      if (tmp___7) {
#line 1090
        goto while_break___1;
      }
      {
#line 1094
      fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
#line 1095
      tmp___2 = strstr((char const   *)(strbuf), "not a dynamic executable");
      }
#line 1095
      if (! tmp___2) {
#line 1096
        goto while_break___1;
      }
      {
#line 1097
      tmp___3 = feof(version);
      }
#line 1097
      if (tmp___3) {
#line 1098
        goto while_break___1;
      }
      {
#line 1099
      cur = strstr((char const   *)(strbuf), " => ");
      }
#line 1099
      if ((unsigned long )cur == (unsigned long )((void *)0)) {
        {
#line 1100
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error processing ldd output -- can\'t find =>\n");
#line 1101
        exit(10);
        }
      }
      {
#line 1103
      cur += 4;
#line 1104
      tmp___4 = strtok((char */* __restrict  */)cur, (char const   */* __restrict  */)" ");
      }
#line 1104
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
#line 1105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error processing ldd output -- can\'t find space\n");
#line 1106
        exit(10);
        }
      }
      {
#line 1109
      tmp___5 = lstat((char const   */* __restrict  */)cur, (struct stat */* __restrict  */)(& statbuf));
      }
#line 1109
      if (tmp___5 == -1) {
        {
#line 1110
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t stat library %s.\n",
                cur);
#line 1111
        exit(10);
        }
      }
#line 1113
      if ((statbuf.st_mode & 61440U) == 40960U) {
        {
#line 1115
        memset((void *)(tmpbuf), 0, (size_t )10240);
#line 1116
        tmp___6 = readlink((char const   */* __restrict  */)cur, (char */* __restrict  */)(tmpbuf),
                           (size_t )10239);
        }
#line 1116
        if (tmp___6 == -1L) {
          {
#line 1117
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t readlink library %s\n",
                  cur);
#line 1118
          perror("fuzz");
#line 1119
          exit(10);
          }
        }
        {
#line 1121
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"library[%d]=%s\n",
                i, tmpbuf);
        }
      } else {
        {
#line 1123
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"library[%d]=%s\n",
                i, cur);
        }
      }
#line 1090
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1126
    pclose(version);
#line 1129
    fputs((char const   */* __restrict  */)" 9", (FILE */* __restrict  */)stdout);
#line 1130
    fflush(stdout);
    }
#line 1131
    if ((int )result == 1) {
#line 1131
      tmp___8 = "pass";
    } else {
#line 1131
      tmp___8 = "fail";
    }
    {
#line 1131
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"results=%s\n",
            tmp___8);
#line 1134
    fputs((char const   */* __restrict  */)" 10", (FILE */* __restrict  */)stdout);
#line 1135
    fflush(stdout);
#line 1136
    strbuf[0] = (char)0;
#line 1137
    fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"version=");
    }
#line 1138
    if ((int )*(distribution___0 + 0) == 75) {
#line 1138
      goto _L___0;
    } else
#line 1138
    if ((int )*(distribution___0 + 0) == 78) {
#line 1138
      goto _L___0;
    } else
#line 1138
    if ((int )*(distribution___0 + 0) == 67) {
#line 1138
      goto _L___0;
    } else
#line 1138
    if ((int )*(distribution___0 + 0) == 82) {
      _L___0: /* CIL Label */ 
      {
#line 1140
      snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"rpm -qf %s",
               progname);
#line 1141
      version = popen((char const   *)(strbuf), "r");
      }
#line 1141
      if ((unsigned long )version == (unsigned long )((void *)0)) {
        {
#line 1142
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t execute %s\n",
                strbuf);
#line 1143
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK1\n.\n");
#line 1144
        exit(10);
        }
      }
      {
#line 1146
      tmp___9 = fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
      }
#line 1146
      if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
        {
#line 1147
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange output from rpm -qf\n");
#line 1148
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK2\n.\n");
#line 1149
        exit(10);
        }
      }
      {
#line 1151
      fputs((char const   */* __restrict  */)(strbuf), (FILE */* __restrict  */)mail);
      }
      {
#line 1153
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1153
        tmp___10 = feof(version);
        }
#line 1153
        if (tmp___10) {
#line 1153
          goto while_break___2;
        }
        {
#line 1154
        fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1156
      pclose(version);
      }
    } else
#line 1157
    if ((int )*(distribution___0 + 0) == 83) {
#line 1157
      goto _L;
    } else
#line 1157
    if ((int )*(distribution___0 + 0) == 79) {
#line 1157
      goto _L;
    } else
#line 1157
    if ((int )*(distribution___0 + 0) == 66) {
#line 1157
      goto _L;
    } else
#line 1157
    if ((int )*(distribution___0 + 0) == 68) {
      _L: /* CIL Label */ 
      {
#line 1159
      snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"dpkg -S %s",
               progname);
#line 1160
      version = popen((char const   *)(strbuf), "r");
      }
#line 1160
      if ((unsigned long )version == (unsigned long )((void *)0)) {
        {
#line 1161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t execute %s\n",
                strbuf);
#line 1162
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK\n.\n");
#line 1163
        exit(10);
        }
      }
      {
#line 1165
      tmp___11 = fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
      }
#line 1165
      if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
        {
#line 1166
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read dpkg -S output.\n");
#line 1167
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK2\n.\n");
#line 1168
        exit(10);
        }
      }
      {
#line 1171
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1171
        tmp___12 = feof(version);
        }
#line 1171
        if (tmp___12) {
#line 1171
          goto while_break___3;
        }
        {
#line 1172
        fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1174
      pclose(version);
#line 1175
      tmp___13 = strtok((char */* __restrict  */)(strbuf), (char const   */* __restrict  */)":");
      }
#line 1175
      if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
        {
#line 1176
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Strange output from dpkg -S.\n");
#line 1177
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK3\n.\n");
#line 1178
        exit(10);
        }
      }
      {
#line 1180
      tmp = strdup((char const   *)(strbuf));
#line 1181
      fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"%s-",
              tmp);
#line 1182
      snprintf((char */* __restrict  */)(strbuf), (size_t )10239, (char const   */* __restrict  */)"dpkg -s %s",
               tmp);
#line 1183
      free((void *)tmp);
#line 1184
      version = popen((char const   *)(strbuf), "r");
      }
#line 1184
      if ((unsigned long )version == (unsigned long )((void *)0)) {
        {
#line 1185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t execute %s\n",
                strbuf);
#line 1186
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"UNK4\n.\n");
#line 1187
        exit(10);
        }
      }
      {
#line 1189
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1189
        tmp___16 = feof(version);
        }
#line 1189
        if (tmp___16) {
#line 1189
          goto while_break___4;
        }
        {
#line 1190
        fgets((char */* __restrict  */)(strbuf), 10239, (FILE */* __restrict  */)version);
#line 1191
        tmp___14 = feof(version);
        }
#line 1191
        if (tmp___14) {
#line 1192
          goto while_break___4;
        }
        {
#line 1193
        tmp___15 = strncmp((char const   *)(strbuf), "Version: ", (size_t )9);
        }
#line 1193
        if (! tmp___15) {
          {
#line 1194
          fputs((char const   */* __restrict  */)(strbuf + 9), (FILE */* __restrict  */)mail);
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1196
      pclose(version);
      }
    }
    {
#line 1200
    fputs((char const   */* __restrict  */)" 11", (FILE */* __restrict  */)stdout);
#line 1201
    fflush(stdout);
    }
#line 1202
    if ((int )result == 1) {
      {
#line 1203
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)mail);
#line 1204
      fputs((char const   */* __restrict  */)" done\n", (FILE */* __restrict  */)stdout);
#line 1205
      fflush(stdout);
      }
    } else {
      {
#line 1210
      fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"data\n");
#line 1211
      fd = open((char const   *)(outfilename), 0);
      }
#line 1211
      if (fd == -1) {
        {
#line 1213
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t reopen outfile.\n");
#line 1214
        perror("fuzz");
#line 1215
        pclose(mail);
#line 1216
        exit(10);
        }
      }
      {
#line 1218
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1218
        tmp___17 = read(fd, (void *)(strbuf), (size_t )10240);
#line 1218
        len = (int )tmp___17;
        }
#line 1218
        if (len != -1) {
#line 1218
          if (! (len != 0)) {
#line 1218
            goto while_break___5;
          }
        } else {
#line 1218
          goto while_break___5;
        }
#line 1219
        i___0 = 0;
        {
#line 1219
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1219
          if (! (i___0 < len)) {
#line 1219
            goto while_break___6;
          }
          {
#line 1220
          fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"%2.2x ",
                  (int )strbuf[i___0] & 255);
          }
#line 1221
          if (i___0 % 25 == 0) {
            {
#line 1222
            fputc('\n', mail);
            }
          }
#line 1219
          i___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1225
      close(fd);
#line 1226
      fputs((char const   */* __restrict  */)"\nend\n", (FILE */* __restrict  */)mail);
      }
#line 1228
      if (max_args) {
        {
#line 1229
        fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"args\n");
#line 1231
        fd = open((char const   *)argfilename, 0);
        }
#line 1231
        if (fd == -1) {
          {
#line 1233
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t reopen argfilename.\n");
#line 1234
          perror("fuzz");
#line 1235
          pclose(mail);
#line 1236
          exit(10);
          }
        }
        {
#line 1238
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1238
          tmp___18 = read(fd, (void *)(strbuf), (size_t )10240);
#line 1238
          len = (int )tmp___18;
          }
#line 1238
          if (len != -1) {
#line 1238
            if (! (len != 0)) {
#line 1238
              goto while_break___7;
            }
          } else {
#line 1238
            goto while_break___7;
          }
#line 1239
          i___0 = 0;
          {
#line 1239
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1239
            if (! (i___0 < len)) {
#line 1239
              goto while_break___8;
            }
            {
#line 1240
            fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"%x ",
                    (int )strbuf[i___0]);
            }
#line 1241
            if (i___0 % 25 == 0) {
              {
#line 1242
              fputc('\n', mail);
              }
            }
#line 1239
            i___0 ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1245
        close(fd);
#line 1246
        fputs((char const   */* __restrict  */)"\nend\n", (FILE */* __restrict  */)mail);
        }
      }
      {
#line 1248
      pclose(mail);
#line 1249
      fputs((char const   */* __restrict  */)" done\n", (FILE */* __restrict  */)stdout);
#line 1250
      fflush(stdout);
      }
    }
  }
#line 1253
  return;
}
}
