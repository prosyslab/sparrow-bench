/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 39 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.h"
struct filelist {
   int id ;
   int flags ;
   off_t osize ;
   off_t csize ;
   off_t tsize ;
   time_t rtime ;
   char rdate[31] ;
   char date[31] ;
   char charset[31] ;
   char compress[31] ;
   char *sign ;
   char *comment ;
   char *fname ;
   struct filelist *next ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.h"
struct senderlist {
   char from[4096] ;
   struct senderlist *next ;
   struct filelist *flist ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.h"
struct outfilelist {
   struct outfilelist *next ;
   char *to ;
   char *from ;
   char *fname ;
   char *oshfn ;
   off_t size ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.h"
struct hostlist {
   struct hostlist *next ;
   char host[4096] ;
   struct outfilelist *flist ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.h"
struct __anonstruct_pstr_t_25 {
   int size ;
   int length ;
   char *string ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.h"
typedef struct __anonstruct_pstr_t_25 pstr_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.h"
FILE *rfopen(char const   *file , char const   *mode ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.h"
struct senderlist *scanspool(char *sender ) ;
#line 105
struct hostlist *scanoutspool(char *sender ) ;
#line 108
struct senderlist *newsle(struct filelist *flp , char const   *from ) ;
#line 111
struct hostlist *newhle(struct outfilelist *oflp , char const   *host ) ;
#line 114
int delete_sf(struct filelist *flp , int verbose___0 ) ;
#line 117
int spoolid(int maxfiles ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.h"
int utf2iso(int fnf , char *iso , char *show , char *shell , char *utf ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/message.h"
void message(char *cmd , char severity , char const   *text ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.h"
char *str_trim(char *string ) ;
#line 49
char *str_toupper(char *string ) ;
#line 52
char *str_tolower(char *string ) ;
#line 55
int simplematch(char *text , char *pattern , int nocase ) ;
#line 89
char *sfgetl(char *s , int z , FILE *f ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/reply.h"
void reply(int x ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
int client ;
#line 78
char userspool[4096] ;
#line 125 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
static struct senderlist *sll  =    (struct senderlist *)((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
struct senderlist *scanspool(char *sender ) 
{ 
  unsigned char *ucp ;
  char *cp ;
  char *arg ;
  char *compress ;
  char line[4096] ;
  char hline[4096] ;
  char from[4096] ;
  char fname[4096] ;
  char comment[4096] ;
  char tmp[4096] ;
  char msg[4096] ;
  char sign[4096] ;
  char date[31] ;
  char charset[31] ;
  char rdate[31] ;
  char file[257] ;
  int i ;
  int id ;
  int hfc ;
  int keep ;
  int deljunk ;
  int flags ;
  off_t osize ;
  off_t csize ;
  off_t tsize ;
  time_t ctime___0 ;
  time_t rtime ;
  FILE *hf ;
  FILE *inf ;
  struct stat finfo ;
  struct dirent *dire ;
  DIR *dp ;
  struct filelist *flp ;
  struct filelist *fln ;
  struct senderlist *sls ;
  struct senderlist *sln ;
  struct senderlist *slp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct tm *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  char *tmp___32 ;
  size_t tmp___33 ;
  void *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
  {
#line 128
  keep = 0;
#line 129
  deljunk = 10;
#line 130
  ctime___0 = time((time_t *)((void *)0));
#line 131
  flp = (struct filelist *)((void *)0);
  }
#line 134
  if (sll) {
#line 137
    slp = sll;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! ((unsigned long )slp != (unsigned long )((void *)0))) {
#line 137
        goto while_break;
      }
#line 138
      flp = slp->flist;
      {
#line 138
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 138
        if (! ((unsigned long )flp != (unsigned long )((void *)0))) {
#line 138
          goto while_break___0;
        }
        {
#line 139
        fln = flp->next;
#line 140
        free((void *)flp->sign);
#line 141
        free((void *)flp->fname);
#line 142
        free((void *)flp->comment);
#line 143
        free((void *)flp);
#line 144
        flp = fln;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 146
      sln = slp->next;
#line 147
      free((void *)slp);
#line 148
      slp = sln;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 151
  sll = (struct senderlist *)((void *)0);
#line 151
  sls = sll;
#line 154
  inf = rfopen("/usr/local/etc/sendfile.cf", "r");
  }
#line 154
  if (inf) {
    {
#line 155
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 155
      tmp___2 = sfgetl(line, (int )sizeof(line), inf);
      }
#line 155
      if (! tmp___2) {
#line 155
        goto while_break___1;
      }
      {
#line 158
      cp = strchr((char const   *)(line), '#');
      }
#line 158
      if (cp) {
#line 158
        *cp = (char)0;
      }
      {
#line 159
      cp = strchr((char const   *)(line), '\n');
      }
#line 159
      if (cp) {
#line 159
        *cp = (char)0;
      }
      {
#line 160
      cp = strchr((char const   *)(line), '=');
      }
#line 160
      if (cp) {
#line 160
        *cp = (char )' ';
      }
      {
#line 161
      str_trim(line);
#line 162
      str_tolower(line);
#line 165
      cp = strchr((char const   *)(line), ' ');
      }
#line 165
      if (cp) {
        {
#line 166
        *cp = (char)0;
#line 166
        cp ++;
#line 167
        tmp___0 = strcmp((char const   *)(line), "keep");
        }
#line 167
        if (tmp___0 == 0) {
          {
#line 168
          keep = atoi((char const   *)cp);
          }
#line 169
          goto while_continue___1;
        }
        {
#line 171
        tmp___1 = strcmp((char const   *)(line), "deljunk");
        }
#line 171
        if (tmp___1 == 0) {
          {
#line 172
          deljunk = atoi((char const   *)cp);
          }
#line 173
          goto while_continue___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 178
    fclose(inf);
    }
  }
  {
#line 205
  dp = opendir((char const   *)(userspool));
  }
#line 205
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 205
    return ((struct senderlist *)((void *)0));
  }
  {
#line 208
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 208
    dire = readdir(dp);
    }
#line 208
    if (! dire) {
#line 208
      goto while_break___2;
    }
    {
#line 211
    cp = strchr((char const   *)(dire->d_name), '.');
    }
#line 211
    if (cp) {
      {
#line 211
      tmp___38 = strcmp((char const   *)cp, ".h");
      }
#line 211
      if (tmp___38 == 0) {
        {
#line 214
        *cp = (char)0;
#line 215
        id = atoi((char const   *)(dire->d_name));
#line 219
        snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                 userspool, id);
#line 220
        hf = rfopen((char const   *)(file), "r");
        }
#line 223
        if (! hf) {
#line 226
          if (client) {
            {
#line 227
            snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"cannot open spool file %s",
                     file);
#line 228
            message((char *)"", (char )'E', (char const   *)(msg));
            }
          }
#line 232
          goto while_continue___2;
        }
        {
#line 236
        flags = 0;
#line 237
        csize = (off_t )0;
#line 238
        tsize = (off_t )0;
#line 239
        osize = (off_t )0;
#line 240
        from[0] = (char)0;
#line 241
        date[0] = (char)0;
#line 242
        sign[0] = (char)0;
#line 243
        fname[0] = (char)0;
#line 244
        charset[0] = (char)0;
#line 245
        comment[0] = (char)0;
#line 246
        compress = (char *)"";
#line 249
        snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.d",
                 userspool, id);
#line 250
        tmp___3 = stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
        }
#line 250
        if (tmp___3 < 0) {
          {
#line 251
          snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                   userspool, id);
#line 252
          unlink((char const   *)(file));
          }
#line 253
          goto while_continue___2;
        }
#line 257
        rtime = finfo.st_mtim.tv_sec;
#line 260
        if (keep > 0) {
#line 260
          if ((ctime___0 - rtime) / 86400L >= (time_t )keep) {
            {
#line 261
            fclose(hf);
#line 262
            unlink((char const   *)(file));
#line 263
            snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                     userspool, id);
#line 264
            unlink((char const   *)(file));
            }
#line 265
            goto while_continue___2;
          }
        }
        {
#line 268
        tmp___4 = localtime((time_t const   *)(& rtime));
#line 268
        strftime((char */* __restrict  */)(rdate), (size_t )21, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
                 (struct tm  const  */* __restrict  */)tmp___4);
#line 271
        hfc = 0;
        }
        {
#line 272
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 272
          tmp___24 = sfgetl(hline, (int )sizeof(hline), hf);
          }
#line 272
          if (tmp___24) {
#line 272
            if (! (hfc == 0)) {
#line 272
              goto while_break___3;
            }
          } else {
#line 272
            goto while_break___3;
          }
          {
#line 275
          cp = strchr((char const   *)(hline), '\n');
          }
#line 275
          if (cp) {
#line 275
            *cp = (char)0;
          }
          {
#line 276
          cp = strchr((char const   *)(hline), '\t');
          }
#line 279
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 280
            hfc = 1;
#line 281
            goto while_continue___3;
          }
          {
#line 284
          str_trim(hline);
#line 285
          cp = strchr((char const   *)(hline), ' ');
          }
#line 286
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 286
            goto while_continue___3;
          }
          {
#line 288
          arg = cp + 1;
#line 289
          *cp = (char)0;
#line 293
          tmp___5 = strcmp((char const   *)(hline), "FROM");
          }
#line 293
          if (tmp___5 == 0) {
            {
#line 294
            cp = strchr((char const   *)arg, ' ');
            }
#line 294
            if (cp) {
              {
#line 295
              *cp = (char)0;
#line 296
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s (%s)",
                       arg, cp + 1);
              }
            } else {
              {
#line 298
              strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)arg);
              }
            }
            {
#line 299
            utf2iso(0, from, (char *)((void *)0), (char *)((void *)0), tmp);
            }
#line 300
            goto while_continue___3;
          }
          {
#line 303
          tmp___6 = strcmp((char const   *)(hline), "FILE");
          }
#line 303
          if (tmp___6 == 0) {
            {
#line 304
            strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)arg);
            }
#line 305
            goto while_continue___3;
          }
          {
#line 308
          tmp___7 = strcmp((char const   *)(hline), "DATE");
          }
#line 308
          if (tmp___7 == 0) {
            {
#line 309
            strncpy((char */* __restrict  */)(date), (char const   */* __restrict  */)arg,
                    (size_t )30);
            }
#line 310
            goto while_continue___3;
          }
          {
#line 313
          tmp___8 = strcmp((char const   *)(hline), "SIZE");
          }
#line 313
          if (tmp___8 == 0) {
            {
#line 314
            sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lld %lld",
                   & csize, & osize);
#line 315
            tsize = finfo.st_size;
            }
#line 316
            goto while_continue___3;
          }
          {
#line 319
          tmp___11 = strcmp((char const   *)(hline), "ATTR");
          }
#line 319
          if (tmp___11 == 0) {
            {
#line 320
            str_toupper(arg);
#line 321
            tmp___9 = strcmp((char const   *)arg, "TAR");
            }
#line 321
            if (tmp___9 == 0) {
#line 321
              flags |= 32;
            }
            {
#line 322
            tmp___10 = strcmp((char const   *)arg, "EXE");
            }
#line 322
            if (tmp___10 == 0) {
#line 322
              flags |= 64;
            }
#line 323
            goto while_continue___3;
          }
          {
#line 326
          tmp___20 = strcmp((char const   *)(hline), "TYPE");
          }
#line 326
          if (tmp___20 == 0) {
            {
#line 327
            str_toupper(arg);
#line 328
            tmp___12 = strstr((char const   *)arg, "SOURCE");
            }
#line 328
            if (tmp___12) {
#line 328
              flags |= 1;
            }
            {
#line 329
            tmp___13 = strstr((char const   *)arg, "TEXT");
            }
#line 329
            if (tmp___13) {
#line 329
              flags |= 2;
            }
            {
#line 330
            tmp___14 = strstr((char const   *)arg, "MIME");
            }
#line 330
            if (tmp___14) {
#line 330
              flags |= 4;
            }
            {
#line 331
            tmp___15 = strstr((char const   *)arg, "CRYPTED");
            }
#line 331
            if (tmp___15) {
#line 331
              flags |= 16;
            }
            {
#line 332
            tmp___17 = strstr((char const   *)arg, "COMPRESSED");
            }
#line 332
            if (tmp___17) {
              {
#line 333
              flags |= 8;
#line 334
              tmp___16 = strstr((char const   *)arg, "COMPRESSED=BZIP2");
              }
#line 334
              if (tmp___16) {
#line 335
                compress = (char *)"BZIP2";
              } else {
#line 337
                compress = (char *)"GZIP";
              }
            }
            {
#line 339
            tmp___19 = strstr((char const   *)arg, "TEXT=");
            }
#line 339
            if (tmp___19) {
              {
#line 340
              tmp___18 = strchr((char const   *)arg, '=');
#line 340
              strncpy((char */* __restrict  */)(charset), (char const   */* __restrict  */)(tmp___18 + 1),
                      (size_t )30);
#line 341
              charset[30] = (char)0;
#line 342
              cp = strchr((char const   *)(charset), ' ');
              }
#line 342
              if (cp) {
#line 342
                *cp = (char)0;
              }
            }
#line 344
            goto while_continue___3;
          }
#line 348
          if (client) {
            {
#line 350
            tmp___22 = strcmp((char const   *)(hline), "COMMENT");
            }
#line 350
            if (tmp___22 == 0) {
              {
#line 353
              utf2iso(0, comment, (char *)((void *)0), (char *)((void *)0), arg);
#line 354
              ucp = (unsigned char *)(comment);
#line 354
              i = 0;
              }
              {
#line 354
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 354
                if (! *ucp) {
#line 354
                  goto while_break___4;
                }
#line 355
                if ((int )*ucp == 9) {
#line 356
                  tmp___21 = i;
#line 356
                  i ++;
#line 356
                  comment[tmp___21] = (char )*ucp;
                } else
#line 355
                if ((int )*ucp == 10) {
#line 356
                  tmp___21 = i;
#line 356
                  i ++;
#line 356
                  comment[tmp___21] = (char )*ucp;
                } else
#line 355
                if ((int )*ucp > 31) {
#line 355
                  if ((int )*ucp < 127) {
#line 356
                    tmp___21 = i;
#line 356
                    i ++;
#line 356
                    comment[tmp___21] = (char )*ucp;
                  } else {
#line 355
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 355
                if ((int )*ucp > 159) {
#line 356
                  tmp___21 = i;
#line 356
                  i ++;
#line 356
                  comment[tmp___21] = (char )*ucp;
                }
#line 354
                ucp ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 357
              comment[i] = (char)0;
#line 358
              goto while_continue___3;
            }
            {
#line 361
            tmp___23 = strcmp((char const   *)(hline), "SIGN");
            }
#line 361
            if (tmp___23 == 0) {
              {
#line 362
              utf2iso(0, sign, (char *)((void *)0), (char *)((void *)0), arg);
              }
#line 363
              goto while_continue___3;
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 370
        fclose(hf);
        }
#line 373
        if ((int )from[0] == 0) {
          {
#line 375
          snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.d",
                   userspool, id);
#line 376
          unlink((char const   *)(file));
#line 377
          snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                   userspool, id);
#line 378
          unlink((char const   *)(file));
          }
#line 379
          goto while_continue___2;
        } else
#line 373
        if ((int )fname[0] == 0) {
          {
#line 375
          snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.d",
                   userspool, id);
#line 376
          unlink((char const   *)(file));
#line 377
          snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                   userspool, id);
#line 378
          unlink((char const   *)(file));
          }
#line 379
          goto while_continue___2;
        } else
#line 373
        if (tsize != csize) {
#line 373
          if (deljunk > 0) {
#line 373
            if ((ctime___0 - rtime) / 86400L >= (time_t )deljunk) {
              {
#line 375
              snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.d",
                       userspool, id);
#line 376
              unlink((char const   *)(file));
#line 377
              snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
                       userspool, id);
#line 378
              unlink((char const   *)(file));
              }
#line 379
              goto while_continue___2;
            }
          }
        }
#line 383
        if ((int )from[0] == 0) {
#line 383
          goto while_continue___2;
        } else
#line 383
        if ((int )fname[0] == 0) {
#line 383
          goto while_continue___2;
        }
        {
#line 386
        strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(from));
#line 386
        cp = strchr((char const   *)(line), ' ');
        }
#line 386
        if (cp) {
#line 386
          *cp = (char)0;
        }
        {
#line 387
        strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)sender);
#line 387
        cp = strchr((char const   *)(tmp), ' ');
        }
#line 387
        if (cp) {
#line 387
          *cp = (char)0;
        }
#line 388
        if ((unsigned long )sender == (unsigned long )((void *)0)) {
#line 388
          goto _L___1;
        } else
#line 388
        if ((int )*sender == 0) {
#line 388
          goto _L___1;
        } else {
          {
#line 388
          tmp___37 = simplematch(line, tmp, 1);
          }
#line 388
          if (tmp___37) {
            _L___1: /* CIL Label */ 
            {
#line 391
            tmp___25 = malloc(sizeof(struct filelist ));
#line 391
            fln = (struct filelist *)tmp___25;
            }
#line 391
            if ((unsigned long )fln == (unsigned long )((void *)0)) {
#line 391
              goto _L___0;
            } else {
              {
#line 391
              tmp___27 = strlen((char const   *)(fname));
#line 391
              tmp___28 = malloc(tmp___27 + 1UL);
#line 391
              tmp___26 = (char *)tmp___28;
#line 391
              fln->fname = tmp___26;
              }
#line 391
              if ((unsigned long )tmp___26 == (unsigned long )((void *)0)) {
#line 391
                goto _L___0;
              } else {
                {
#line 391
                tmp___30 = strlen((char const   *)(comment));
#line 391
                tmp___31 = malloc(tmp___30 + 1UL);
#line 391
                tmp___29 = (char *)tmp___31;
#line 391
                fln->comment = tmp___29;
                }
#line 391
                if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
#line 391
                  goto _L___0;
                } else {
                  {
#line 391
                  tmp___33 = strlen((char const   *)(sign));
#line 391
                  tmp___34 = malloc(tmp___33 + 1UL);
#line 391
                  tmp___32 = (char *)tmp___34;
#line 391
                  fln->sign = tmp___32;
                  }
#line 391
                  if ((unsigned long )tmp___32 == (unsigned long )((void *)0)) {
                    _L___0: /* CIL Label */ 
#line 395
                    if (client) {
                      {
#line 395
                      message((char *)"", (char )'F', "cannot allocate memory");
                      }
                    } else {
                      {
#line 395
                      reply(453);
                      }
                    }
                  }
                }
              }
            }
            {
#line 399
            fln->id = id;
#line 400
            fln->next = (struct filelist *)((void *)0);
#line 401
            fln->osize = osize;
#line 402
            fln->csize = csize;
#line 403
            fln->tsize = tsize;
#line 404
            fln->flags = flags;
#line 405
            fln->rtime = rtime;
#line 406
            strcpy((char */* __restrict  */)(fln->date), (char const   */* __restrict  */)(date));
#line 407
            strcpy((char */* __restrict  */)fln->sign, (char const   */* __restrict  */)(sign));
#line 408
            strcpy((char */* __restrict  */)fln->fname, (char const   */* __restrict  */)(fname));
#line 409
            strcpy((char */* __restrict  */)(fln->rdate), (char const   */* __restrict  */)(rdate));
#line 410
            strcpy((char */* __restrict  */)(fln->charset), (char const   */* __restrict  */)(charset));
#line 411
            strcpy((char */* __restrict  */)fln->comment, (char const   */* __restrict  */)(comment));
#line 412
            strcpy((char */* __restrict  */)(fln->compress), (char const   */* __restrict  */)compress);
            }
#line 415
            if ((unsigned long )sls == (unsigned long )((void *)0)) {
              {
#line 416
              sls = newsle(fln, (char const   *)(from));
              }
            } else {
#line 420
              slp = sls;
              {
#line 421
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 421
                if (slp->next) {
                  {
#line 421
                  tmp___35 = strcmp((char const   *)(slp->from), (char const   *)(from));
                  }
#line 421
                  if (tmp___35 == 0) {
#line 421
                    goto while_break___5;
                  }
                } else {
#line 421
                  goto while_break___5;
                }
#line 421
                slp = slp->next;
              }
              while_break___5: /* CIL Label */ ;
              }
              {
#line 424
              tmp___36 = strcmp((char const   *)(slp->from), (char const   *)(from));
              }
#line 424
              if (tmp___36 == 0) {
#line 432
                if (id < (slp->flist)->id) {
#line 433
                  fln->next = slp->flist;
#line 434
                  slp->flist = fln;
                } else {
#line 438
                  flp = slp->flist;
                  {
#line 438
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 438
                    if (! ((unsigned long )flp->next != (unsigned long )((void *)0))) {
#line 438
                      goto while_break___6;
                    }
#line 439
                    if (id < (flp->next)->id) {
#line 440
                      fln->next = flp->next;
#line 441
                      flp->next = fln;
#line 442
                      goto while_break___6;
                    }
#line 438
                    flp = flp->next;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
#line 447
                  if ((unsigned long )flp->next == (unsigned long )((void *)0)) {
#line 447
                    flp->next = fln;
                  }
                }
              } else {
                {
#line 427
                slp->next = newsle(fln, (char const   *)(from));
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 459
  closedir(dp);
#line 461
  sll = sls;
  }
#line 462
  return (sls);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
static struct hostlist *hll  =    (struct hostlist *)((void *)0);
#line 480 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
struct hostlist *scanoutspool(char *sender ) 
{ 
  char *cp ;
  char *arg ;
  char hline[4096] ;
  char host[4096] ;
  char to[4096] ;
  char from[4096] ;
  char fname[4096] ;
  char tmp[4096] ;
  char msg[4096] ;
  char hfn[4096] ;
  char dfn[4096] ;
  int hfc ;
  off_t size ;
  FILE *hf ;
  struct stat finfo ;
  struct dirent *dire ;
  DIR *dp ;
  struct outfilelist *oflp ;
  struct outfilelist *ofln ;
  struct hostlist *hls ;
  struct hostlist *hln ;
  struct hostlist *hlp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 514
  oflp = (struct outfilelist *)((void *)0);
#line 517
  if (hll) {
#line 520
    hlp = hll;
    {
#line 520
    while (1) {
      while_continue: /* CIL Label */ ;
#line 520
      if (! hlp) {
#line 520
        goto while_break;
      }
#line 521
      oflp = hlp->flist;
      {
#line 521
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 521
        if (! oflp) {
#line 521
          goto while_break___0;
        }
        {
#line 522
        ofln = oflp->next;
#line 523
        free((void *)oflp->to);
#line 524
        free((void *)oflp->oshfn);
#line 525
        free((void *)oflp->fname);
#line 526
        free((void *)oflp);
#line 527
        oflp = ofln;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 529
      hln = hlp->next;
#line 530
      free((void *)hlp);
#line 531
      hlp = hln;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 537
  hll = newhle((struct outfilelist *)((void *)0), "");
#line 537
  hls = hll;
#line 555
  dp = opendir("/var/spool/sendfile/OUTGOING");
  }
#line 555
  if (! dp) {
#line 555
    return ((struct hostlist *)((void *)0));
  }
  {
#line 558
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 558
    dire = readdir(dp);
    }
#line 558
    if (! dire) {
#line 558
      goto while_break___1;
    }
    {
#line 560
    strcpy((char */* __restrict  */)(hfn), (char const   */* __restrict  */)(dire->d_name));
#line 564
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s*.h",
             sender);
#line 565
    tmp___0 = simplematch(hfn, tmp, 1);
    }
#line 565
    if (tmp___0 == 0) {
#line 565
      goto while_continue___1;
    }
    {
#line 567
    strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(hfn));
#line 568
    snprintf((char */* __restrict  */)(hfn), sizeof(hfn) - 1UL, (char const   */* __restrict  */)"/var/spool/sendfile/OUTGOING/%s",
             tmp);
#line 571
    hf = rfopen((char const   *)(hfn), "r");
    }
#line 571
    if ((unsigned long )hf == (unsigned long )((void *)0)) {
#line 574
      if (client) {
        {
#line 575
        snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"cannot open outgoing spool file %s",
                 hfn);
#line 576
        message((char *)"", (char )'E', (char const   *)(msg));
        }
      }
#line 579
      goto while_continue___1;
    }
#line 583
    size = (off_t )0;
#line 584
    to[0] = (char)0;
#line 585
    host[0] = (char)0;
#line 586
    from[0] = (char)0;
#line 587
    fname[0] = (char)0;
#line 590
    hfc = 0;
    {
#line 591
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 591
      tmp___8 = sfgetl(hline, (int )sizeof(hline), hf);
      }
#line 591
      if (tmp___8) {
#line 591
        if (! (hfc == 0)) {
#line 591
          goto while_break___2;
        }
      } else {
#line 591
        goto while_break___2;
      }
      {
#line 594
      cp = strchr((char const   *)(hline), '\n');
      }
#line 594
      if (cp) {
#line 594
        *cp = (char)0;
      }
      {
#line 595
      cp = strchr((char const   *)(hline), '\t');
      }
#line 598
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 599
        hfc = 1;
#line 600
        goto while_continue___2;
      }
      {
#line 603
      arg = cp + 1;
#line 604
      *cp = (char)0;
#line 609
      tmp___2 = strcmp((char const   *)(hline), "FROM");
      }
#line 609
      if (tmp___2 == 0) {
        {
#line 610
        cp = strchr((char const   *)arg, ' ');
        }
#line 610
        if (cp) {
#line 610
          *cp = (char)0;
        }
        {
#line 611
        utf2iso(0, from, (char *)((void *)0), (char *)((void *)0), arg);
        }
#line 614
        if (*sender) {
          {
#line 614
          tmp___1 = strcmp((char const   *)(from), (char const   *)sender);
          }
#line 614
          if (! (tmp___1 == 0)) {
#line 614
            hfc = 1;
          }
        }
#line 616
        goto while_continue___2;
      }
      {
#line 620
      tmp___3 = strcmp((char const   *)(hline), "TO");
      }
#line 620
      if (tmp___3 == 0) {
        {
#line 621
        cp = strchr((char const   *)arg, '@');
        }
#line 621
        if (cp) {
          {
#line 624
          strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(cp + 1));
#line 625
          *cp = (char)0;
#line 626
          utf2iso(0, to, (char *)((void *)0), (char *)((void *)0), arg);
          }
        } else {
#line 622
          hfc = 1;
        }
#line 628
        goto while_continue___2;
      }
      {
#line 631
      tmp___4 = strcmp((char const   *)(hline), "FILE");
      }
#line 631
      if (tmp___4 == 0) {
        {
#line 632
        strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)arg);
        }
#line 633
        goto while_continue___2;
      }
      {
#line 636
      tmp___7 = strcmp((char const   *)(hline), "SIZE");
      }
#line 636
      if (tmp___7 == 0) {
        {
#line 637
        sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lld",
               & size);
#line 638
        strcpy((char */* __restrict  */)(dfn), (char const   */* __restrict  */)(hfn));
#line 639
        tmp___5 = strlen((char const   *)(dfn));
#line 639
        dfn[tmp___5 - 1UL] = (char )'d';
#line 642
        tmp___6 = stat((char const   */* __restrict  */)(dfn), (struct stat */* __restrict  */)(& finfo));
        }
#line 642
        if (tmp___6 < 0) {
#line 642
          hfc = 1;
        } else
#line 642
        if (finfo.st_size != size) {
#line 642
          hfc = 1;
        }
#line 644
        goto while_continue___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 649
    fclose(hf);
    }
#line 652
    if ((int )from[0] == 0) {
#line 652
      goto _L;
    } else
#line 652
    if ((int )fname[0] == 0) {
#line 652
      goto _L;
    } else
#line 652
    if ((int )to[0] == 0) {
#line 652
      goto _L;
    } else
#line 652
    if ((int )host[0] == 0) {
#line 652
      goto _L;
    } else
#line 652
    if (hfc) {
      _L: /* CIL Label */ 
      {
#line 653
      strcpy((char */* __restrict  */)(dfn), (char const   */* __restrict  */)(hfn));
#line 654
      tmp___9 = strlen((char const   *)(dfn));
#line 654
      dfn[tmp___9 - 1UL] = (char )'d';
#line 655
      unlink((char const   *)(dfn));
#line 656
      unlink((char const   *)(hfn));
      }
#line 657
      goto while_continue___1;
    }
    {
#line 661
    tmp___10 = malloc(sizeof(struct outfilelist ));
#line 661
    ofln = (struct outfilelist *)tmp___10;
    }
#line 661
    if ((unsigned long )ofln == (unsigned long )((void *)0)) {
#line 661
      goto _L___0;
    } else {
      {
#line 661
      tmp___12 = strlen((char const   *)(fname));
#line 661
      tmp___13 = malloc(tmp___12 + 1UL);
#line 661
      tmp___11 = (char *)tmp___13;
#line 661
      ofln->fname = tmp___11;
      }
#line 661
      if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 661
        goto _L___0;
      } else {
        {
#line 661
        tmp___15 = strlen((char const   *)(to));
#line 661
        tmp___16 = malloc(tmp___15 + 1UL);
#line 661
        tmp___14 = (char *)tmp___16;
#line 661
        ofln->to = tmp___14;
        }
#line 661
        if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 661
          goto _L___0;
        } else {
          {
#line 661
          tmp___18 = strlen((char const   *)(hfn));
#line 661
          tmp___19 = malloc(tmp___18 + 1UL);
#line 661
          tmp___17 = (char *)tmp___19;
#line 661
          ofln->oshfn = tmp___17;
          }
#line 661
          if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
#line 661
            goto _L___0;
          } else {
            {
#line 661
            tmp___21 = strlen((char const   *)(from));
#line 661
            tmp___22 = malloc(tmp___21 + 1UL);
#line 661
            tmp___20 = (char *)tmp___22;
#line 661
            ofln->from = tmp___20;
            }
#line 661
            if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
              _L___0: /* CIL Label */ 
#line 666
              if (client) {
                {
#line 666
                message((char *)"", (char )'F', "cannot allocate memory");
                }
              } else {
                {
#line 666
                reply(453);
                }
              }
            }
          }
        }
      }
    }
    {
#line 670
    ofln->next = (struct outfilelist *)((void *)0);
#line 671
    ofln->size = size;
#line 672
    strcpy((char */* __restrict  */)ofln->to, (char const   */* __restrict  */)(to));
#line 673
    strcpy((char */* __restrict  */)ofln->from, (char const   */* __restrict  */)(from));
#line 674
    strcpy((char */* __restrict  */)ofln->oshfn, (char const   */* __restrict  */)(hfn));
#line 675
    strcpy((char */* __restrict  */)ofln->fname, (char const   */* __restrict  */)(fname));
    }
#line 678
    if ((unsigned long )hls->flist == (unsigned long )((void *)0)) {
      {
#line 679
      hls->flist = ofln;
#line 680
      strcpy((char */* __restrict  */)(hls->host), (char const   */* __restrict  */)(host));
      }
    } else {
#line 685
      hlp = hls;
      {
#line 686
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 686
        if (hlp->next) {
          {
#line 686
          tmp___23 = strcmp((char const   *)(hlp->host), (char const   *)(host));
          }
#line 686
          if (tmp___23 == 0) {
#line 686
            goto while_break___3;
          }
        } else {
#line 686
          goto while_break___3;
        }
#line 686
        hlp = hlp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 689
      tmp___24 = strcmp((char const   *)(hlp->host), (char const   *)(host));
      }
#line 689
      if (tmp___24 == 0) {
#line 695
        oflp = hlp->flist;
        {
#line 695
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 695
          if (! ((unsigned long )oflp->next != (unsigned long )((void *)0))) {
#line 695
            goto while_break___4;
          }
#line 695
          oflp = oflp->next;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 696
        oflp->next = ofln;
      } else {
        {
#line 692
        hlp->next = newhle(ofln, (char const   *)(host));
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 705
  closedir(dp);
#line 707
  hll = hls;
  }
#line 708
  return (hls);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
struct senderlist *newsle(struct filelist *flp , char const   *from ) 
{ 
  struct senderlist *sln ;
  void *tmp ;

  {
  {
#line 725
  tmp = malloc(sizeof(struct senderlist ));
#line 725
  sln = (struct senderlist *)tmp;
  }
#line 725
  if ((unsigned long )sln == (unsigned long )((void *)0)) {
#line 726
    if (client) {
      {
#line 726
      message((char *)"", (char )'F', "cannot allocate memory");
      }
    } else {
      {
#line 726
      reply(453);
      }
    }
  }
  {
#line 730
  sln->next = (struct senderlist *)((void *)0);
#line 731
  sln->flist = flp;
#line 732
  strcpy((char */* __restrict  */)(sln->from), (char const   */* __restrict  */)from);
  }
#line 734
  return (sln);
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
struct hostlist *newhle(struct outfilelist *oflp , char const   *host ) 
{ 
  struct hostlist *hln ;
  void *tmp ;

  {
  {
#line 751
  tmp = malloc(sizeof(struct hostlist ));
#line 751
  hln = (struct hostlist *)tmp;
  }
#line 751
  if ((unsigned long )hln == (unsigned long )((void *)0)) {
#line 752
    if (client) {
      {
#line 752
      message((char *)"", (char )'F', "cannot allocate memory");
      }
    } else {
      {
#line 752
      reply(453);
      }
    }
  }
  {
#line 756
  hln->next = (struct hostlist *)((void *)0);
#line 757
  hln->flist = oflp;
#line 758
  strcpy((char */* __restrict  */)(hln->host), (char const   */* __restrict  */)host);
  }
#line 760
  return (hln);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
int delete_sf(struct filelist *flp , int verbose___0 ) 
{ 
  char msg[4096] ;
  char file[4096] ;
  char fname[4096] ;
  int tmp ;

  {
  {
#line 779
  snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.d",
           userspool, flp->id);
#line 780
  unlink((char const   *)(file));
#line 781
  snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%s/%d.h",
           userspool, flp->id);
#line 782
  utf2iso(1, (char *)((void *)0), fname, (char *)((void *)0), flp->fname);
#line 783
  tmp = unlink((char const   *)(file));
  }
#line 783
  if (tmp < 0) {
#line 784
    if (client) {
      {
#line 785
      snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"cannot delete spoolfile #%d",
               flp->id);
#line 786
      message((char *)"", (char )'W', (char const   *)(msg));
      }
    }
#line 788
    return (-1);
  } else {
#line 790
    if (verbose___0) {
      {
#line 791
      snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"%s deleted",
               fname);
#line 792
      message((char *)"", (char )'I', (char const   *)(msg));
      }
    }
#line 794
    return (0);
  }
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/spool.c"
int spoolid(int maxfiles ) 
{ 
  int i ;
  int n ;
  int fd ;
  int id ;
  int idmax ;
  char *cp ;
  char file[4096] ;
  struct dirent *dire ;
  DIR *dp ;
  int tmp ;
  int tmp___0 ;

  {
#line 828
  i = 1;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! (i < 5)) {
#line 828
      goto while_break;
    }
    {
#line 831
    n = 0;
#line 832
    id = 0;
#line 833
    fd = 0;
#line 834
    idmax = 0;
#line 858
    dp = opendir(".");
    }
    {
#line 861
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 861
      dire = readdir(dp);
      }
#line 861
      if (! dire) {
#line 861
        goto while_break___0;
      }
      {
#line 862
      cp = strchr((char const   *)(dire->d_name), '.');
      }
#line 863
      if (cp) {
        {
#line 863
        tmp = strcmp((char const   *)cp, ".h");
        }
#line 863
        if (tmp == 0) {
          {
#line 864
          *cp = (char)0;
#line 865
          n ++;
#line 866
          id = atoi((char const   *)(dire->d_name));
          }
#line 867
          if (id > idmax) {
#line 867
            idmax = id;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 870
    closedir(dp);
#line 873
    id = idmax + 1;
    }
#line 874
    if (n > maxfiles) {
#line 874
      return (- n);
    }
    {
#line 877
    snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%d.h",
             id);
#line 878
    fd = open((char const   *)(file), 192, 384);
    }
#line 881
    if (fd >= 0) {
      {
#line 883
      close(fd);
#line 886
      snprintf((char */* __restrict  */)(file), sizeof(file) - 1UL, (char const   */* __restrict  */)"%d.d",
               id);
#line 887
      tmp___0 = open((char const   *)(file), 64, 384);
#line 887
      close(tmp___0);
      }
#line 889
      return (id);
    }
    {
#line 893
    sleep(1U);
#line 828
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 897
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.h"
pstr_t *pstr_create(int size ) ;
#line 27
void pstr_delete(pstr_t *pstr ) ;
#line 30
int pstr_addchar(pstr_t *pstr , char c ) ;
#line 33
int pstr_assign(pstr_t *p1 , pstr_t *p2 ) ;
#line 36
int pstr_addstring(pstr_t *pstr , char const   *s ) ;
#line 39
int pstr_addpstring(pstr_t *s0 , pstr_t const   *s1 ) ;
#line 42
void pstr_print(pstr_t *pstr ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
pstr_t *pstr_create(int size ) 
{ 
  pstr_t *pstr ;
  char *string ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 38
  tmp = malloc(sizeof(pstr_t ));
#line 38
  pstr = (pstr_t *)tmp;
  }
#line 38
  if ((unsigned long )pstr == (unsigned long )((void *)0)) {
#line 38
    return ((pstr_t *)((void *)0));
  }
  {
#line 39
  tmp___0 = malloc((size_t )(size + 1));
#line 39
  string = (char *)tmp___0;
  }
#line 39
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 39
    return ((pstr_t *)((void *)0));
  }
#line 43
  pstr->size = size;
#line 44
  pstr->length = 0;
#line 45
  pstr->string = string;
#line 47
  return (pstr);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
void pstr_delete(pstr_t *pstr ) 
{ 


  {
  {
#line 59
  free((void *)pstr->string);
#line 60
  free((void *)pstr);
  }
#line 61
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
int pstr_addchar(pstr_t *pstr , char c ) 
{ 


  {
#line 77
  if (pstr->length >= pstr->size) {
#line 77
    return (-1);
  }
#line 80
  (pstr->length) ++;
#line 83
  *(pstr->string + pstr->length) = c;
#line 85
  return (0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
int pstr_assign(pstr_t *p1 , pstr_t *p2 ) 
{ 


  {
#line 102
  if (p2->length > p1->size) {
#line 102
    return (-1);
  }
  {
#line 105
  memcpy((void */* __restrict  */)p1->string, (void const   */* __restrict  */)p2->string,
         (size_t )(p2->length + 1));
#line 108
  p1->length = p2->length;
  }
#line 110
  return (0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
int pstr_addstring(pstr_t *pstr , char const   *s ) 
{ 
  int plen ;
  int slen ;
  size_t tmp ;

  {
  {
#line 129
  tmp = strlen(s);
#line 129
  slen = (int )tmp;
#line 130
  plen = pstr->length;
  }
#line 133
  if (plen + slen > pstr->size) {
#line 133
    return (-1);
  }
  {
#line 136
  memcpy((void */* __restrict  */)((pstr->string + plen) + 1), (void const   */* __restrict  */)s,
         (size_t )slen);
#line 139
  pstr->length += slen;
  }
#line 141
  return (0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
int pstr_addpstring(pstr_t *s0 , pstr_t const   *s1 ) 
{ 


  {
#line 158
  if (s0->length + (int )s1->length > s0->size) {
#line 158
    return (-1);
  }
  {
#line 161
  memcpy((void */* __restrict  */)((s0->string + s0->length) + 1), (void const   */* __restrict  */)s1->string,
         (size_t )s1->length);
#line 164
  s0->length += (int )s1->length;
  }
#line 166
  return (0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/pstring.c"
void pstr_print(pstr_t *pstr ) 
{ 
  int i ;

  {
#line 179
  i = 1;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i <= pstr->length)) {
#line 179
      goto while_break;
    }
    {
#line 180
    printf((char const   */* __restrict  */)"%c", (int )*(pstr->string + i));
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/message.h"
void cleanup(void) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/message.c"
int xonf ;
#line 51
char *prg ;
#line 49 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/message.c"
void message(char *cmd , char severity , char const   *text ) 
{ 
  char *facility ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 54
  if ((int )*cmd == 0) {
#line 54
    cmd = prg;
  }
  {
#line 57
  facility = strrchr((char const   *)cmd, '/');
  }
#line 58
  if (! facility) {
#line 59
    facility = cmd;
  } else {
#line 61
    facility ++;
  }
  {
#line 64
  tmp = toupper((int )severity);
#line 64
  severity = (char )tmp;
  }
#line 68
  if ((int )severity == 70) {
#line 68
    tmp___4 = "Fatalerror";
  } else {
#line 68
    if ((int )severity == 88) {
#line 68
      tmp___3 = "Fatalerror";
    } else {
#line 68
      if ((int )severity == 69) {
#line 68
        tmp___2 = "Error";
      } else {
#line 68
        if ((int )severity == 87) {
#line 68
          tmp___1 = "Warning";
        } else {
#line 68
          if ((int )severity == 73) {
#line 68
            tmp___0 = "Info";
          } else {
#line 68
            tmp___0 = "Unknown";
          }
#line 68
          tmp___1 = tmp___0;
        }
#line 68
        tmp___2 = tmp___1;
      }
#line 68
      tmp___3 = tmp___2;
    }
#line 68
    tmp___4 = tmp___3;
  }
  {
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%%%s-%s: %s",
          facility, tmp___4, text);
  }
#line 79
  if ((int )severity == 69) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )severity == 70) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )severity == 88) {
    _L: /* CIL Label */ 
    {
#line 79
    tmp___7 = __errno_location();
    }
#line 79
    if (*tmp___7) {
      {
#line 80
      tmp___5 = __errno_location();
#line 80
      tmp___6 = strerror(*tmp___5);
#line 80
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" : %s",
              tmp___6);
      }
    }
  }
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 84
  tmp___8 = toupper((int )severity);
  }
#line 84
  if (tmp___8 == 88) {
    {
#line 84
    exit(1);
    }
  }
  {
#line 85
  tmp___9 = toupper((int )severity);
  }
#line 85
  if (tmp___9 == 70) {
    {
#line 86
    cleanup();
    }
#line 87
    if (xonf) {
      {
#line 87
      exit(1);
      }
    }
  }
#line 90
  return;
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 261 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.h"
int str_beq(char const   *s1 , char const   *s2 ) ;
#line 61
int str_neq_nocase(char const   *s1 , char const   *s2 , int len ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.h"
int open_connection(char *adr , int port ) ;
#line 32
int sock_getline(int fd , char *line ) ;
#line 35
int sock_putline(int fd , char const   *line ) ;
#line 38
char *sendcommand(int fd , char const   *command , char *answer ) ;
#line 44
int sendheader(int fd , char *line ) ;
#line 47
int send_data(int sockfd , off_t size , char const   *file , char const   *tinfo ,
              char const   *iso_name , char const   *type , float mtp , float *ttime ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.h"
int fcopy(char const   *from , char const   *to , mode_t mode ) ;
#line 48
char *whereis(char *prg___0 ) ;
#line 54
char *mktmpdir(int verbose___0 ) ;
#line 57
void rmtmpdir(char *tmpdir___1 ) ;
#line 60
int spawn(char **sad , char const   *output , mode_t cmask ) ;
#line 63
int vsystem(char const   *cmd ) ;
#line 66
FILE *vpopen(char const   *cmd , char const   *type ) ;
#line 69
char *shell_quote(char const   *string ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.h"
void iso2utf(char *utf_name , char *iso_name ) ;
#line 41
void iso2utf7(char *utf_name , char *iso_name , int withspace ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.h"
void destination(int argc , char **argv , char *user , char *recipient , char *host ,
                 char *aopt ) ;
#line 27
int saft_connect(char const   *type , char *recipient , char *user , char *host ,
                 char *redirect ) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int usage(void) ;
#line 186
void cleanexit(void) ;
#line 192
void pgp_encrypt(int pgpcrypt , char *pgprid , char *file ) ;
#line 195
void pgp_sign(char const   *pgpsign , char const   *infile , int sockfd ) ;
#line 198
FILE *outspool(char const   *user , char const   *outgoing , char *oshf ) ;
#line 201
void start_spooldaemon(char *localhost___0 ) ;
#line 204
void outlog(char *to , char *host , char *file , char *sizes ) ;
#line 207
void forward(char *host , float mtp ) ;
#line 210
void get_header(char const   *cmd , char *arg ) ;
#line 213
char guess_ftype(char const   *file , char *type ) ;
#line 216
int linkspeed(char const   *host , int lanspeed , char **compress ) ;
#line 219
void notespeed(char const   *host , unsigned long size , float ttime ) ;
#line 222
int list_spool(void) ;
#line 225
void spooled_info(char const   *file , char const   *sdf , int compressed ) ;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int pgppass  =    0;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int verbose  =    0;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int xonf  =    1;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int client  =    1;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int quiet  =    0;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int test  =    0;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int outlogging  =    0;
#line 229 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int packet_size  =    0;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char *prg  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char *pgpvm  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char *tmpdir  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char *dontcompress[99]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char pw_name[256]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char localhost[256]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char outlogtmp[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char userspool[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char tar_bin[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char gzip_bin[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char bzip2_bin[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char zprg[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char pgp_bin[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char stdintmp[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char tartmp[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char ziptmp[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char texttmp[4096]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char pgptmp[4096]  ;
#line 259 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int n ;
  int pid ;
  int status ;
  int bytes ;
  int sockfd ;
  int opt ;
  int fn ;
  int tfn ;
  int stdinf ;
  int ch ;
  int lanspeed ;
  int pgpcrypt ;
  int del ;
  int tar ;
  int zip ;
  int exe ;
  int pgp ;
  int guess ;
  int text ;
  int mime ;
  int source ;
  int spool ;
  int list ;
  int info ;
  int bounce ;
  int extended ;
  int spooling ;
  int overwrite ;
  int do_compress ;
  off_t size ;
  off_t orgsize ;
  float mtp ;
  float tsize ;
  float attime ;
  float tttime ;
  float thruput ;
  char *cp ;
  char *argp ;
  char *pop ;
  char *fnp ;
  char *type ;
  char *compress ;
  char **sad ;
  char mode ;
  char to[512] ;
  char file[256] ;
  char tinfo[256] ;
  char sdfn[256] ;
  char shfn[256] ;
  char rto[512] ;
  char ftype[256] ;
  char archive[256] ;
  char where[256] ;
  char aopt[256] ;
  char recipient[256] ;
  char bouncearg[30] ;
  char sizes[256] ;
  char user[256] ;
  char date[30] ;
  char host[256] ;
  char pgpopt[256] ;
  char pgprid[256] ;
  char pgpsign[256] ;
  char redirect[4096] ;
  char cmd[4096] ;
  char line[4096] ;
  char reply___1[4096] ;
  char tmp[4096] ;
  char iobuf[4096] ;
  char comment[4096] ;
  char outgoing[4096] ;
  char oshfn[4096] ;
  char osdfn[4096] ;
  char filelist[32768] ;
  char force_compress[4096] ;
  char const   *cft[10] ;
  FILE *shf ;
  FILE *oshf ;
  FILE *inf ;
  FILE *outf ;
  struct passwd *pwe ;
  struct stat finfo ;
  char utf_name[8192] ;
  char iso_name[4096] ;
  struct hostlist *hls ;
  struct hostlist *hlp ;
  struct outfilelist *oflp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  __uid_t tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  int *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  ssize_t tmp___57 ;
  int tmp___58 ;
  ssize_t tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int *tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  char *tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  char *tmp___83 ;
  int tmp___84 ;
  int *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  size_t tmp___88 ;
  int tmp___89 ;
  size_t tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  void *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  char *tmp___100 ;
  size_t tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int *tmp___109 ;
  int tmp___110 ;
  int *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int *tmp___114 ;
  int tmp___115 ;
  size_t tmp___116 ;
  size_t tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  char *tmp___120 ;
  size_t tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int *tmp___127 ;
  struct tm *tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  char *tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int *tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;

  {
  {
#line 340
  cft[0] = "compress";
#line 340
  cft[1] = "zip";
#line 340
  cft[2] = "zoo";
#line 340
  cft[3] = "frozen";
#line 340
  cft[4] = "gif";
#line 340
  cft[5] = "jpg";
#line 340
  cft[6] = "jpeg";
#line 340
  cft[7] = "mpg";
#line 340
  cft[8] = "mpeg";
#line 340
  cft[9] = "";
#line 391
  mtp = (float )0;
#line 392
  tfn = 0;
#line 393
  del = 0;
#line 394
  tar = 0;
#line 395
  zip = 0;
#line 396
  exe = 0;
#line 397
  pgp = 0;
#line 398
  text = 0;
#line 399
  spool = 0;
#line 400
  quiet = 0;
#line 401
  mime = 0;
#line 402
  list = 0;
#line 403
  info = 0;
#line 404
  guess = 0;
#line 405
  tsize = (float )0;
#line 406
  source = 0;
#line 407
  bounce = 0;
#line 408
  sockfd = 0;
#line 409
  stdinf = 0;
#line 410
  tttime = (float )0;
#line 411
  thruput = (float )0;
#line 412
  verbose = 0;
#line 413
  extended = 0;
#line 414
  spooling = 0;
#line 415
  pgpcrypt = 0;
#line 416
  lanspeed = 100;
#line 417
  overwrite = 0;
#line 418
  do_compress = 0;
#line 419
  aopt[0] = (char)0;
#line 420
  host[0] = (char)0;
#line 421
  date[0] = (char)0;
#line 422
  zprg[0] = (char)0;
#line 423
  where[0] = (char)0;
#line 424
  tinfo[0] = (char)0;
#line 425
  comment[0] = (char)0;
#line 426
  archive[0] = (char)0;
#line 427
  redirect[0] = (char)0;
#line 428
  filelist[0] = (char)0;
#line 429
  pgprid[0] = (char)0;
#line 430
  pgpopt[0] = (char)0;
#line 431
  pgpsign[0] = (char)0;
#line 432
  force_compress[0] = (char)0;
#line 433
  dontcompress[0] = (char *)"";
#line 434
  type = (char *)"BINARY";
#line 435
  compress = (char *)"GZIP";
#line 436
  oshf = (FILE *)((void *)0);
#line 437
  tmp___0 = getpid();
#line 437
  pid = tmp___0;
#line 439
  prg = *(argv + 0);
#line 440
  cp = strrchr((char const   *)prg, '/');
  }
#line 440
  if (cp) {
#line 440
    prg = cp + 1;
  }
  {
#line 443
  setvbuf((FILE */* __restrict  */)stdin, (char */* __restrict  */)((void *)0), 2,
          (size_t )0);
#line 445
  tmp___1 = getenv("PGPPASS");
  }
#line 445
  if (tmp___1) {
#line 446
    pgppass = 1;
#line 447
    pgpvm = (char *)"+verbose=0";
  } else {
#line 449
    pgppass = 0;
#line 450
    pgpvm = (char *)"+verbose=1";
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 464
    opt = getopt(argc, (char * const  *)argv, "ivVTgtsuqoMQPdSlzh?a:c:p:b:m:X:C:W:Z:");
    }
#line 464
    if (! (opt > 0)) {
#line 464
      goto while_break;
    }
    {
#line 473
    if (opt == 63) {
#line 473
      goto case_63;
    }
#line 473
    if (opt == 104) {
#line 473
      goto case_63;
    }
#line 473
    if (opt == 58) {
#line 473
      goto case_63;
    }
#line 474
    if (opt == 100) {
#line 474
      goto case_100;
    }
#line 475
    if (opt == 103) {
#line 475
      goto case_103;
    }
#line 476
    if (opt == 116) {
#line 476
      goto case_116;
    }
#line 477
    if (opt == 84) {
#line 477
      goto case_84;
    }
#line 478
    if (opt == 83) {
#line 478
      goto case_83;
    }
#line 479
    if (opt == 108) {
#line 479
      goto case_108;
    }
#line 480
    if (opt == 105) {
#line 480
      goto case_105;
    }
#line 481
    if (opt == 113) {
#line 481
      goto case_113;
    }
#line 482
    if (opt == 81) {
#line 482
      goto case_81;
    }
#line 483
    if (opt == 80) {
#line 483
      goto case_80;
    }
#line 484
    if (opt == 115) {
#line 484
      goto case_115;
    }
#line 485
    if (opt == 77) {
#line 485
      goto case_77;
    }
#line 486
    if (opt == 109) {
#line 486
      goto case_109;
    }
#line 487
    if (opt == 118) {
#line 487
      goto case_118;
    }
#line 488
    if (opt == 117) {
#line 488
      goto case_117;
    }
#line 489
    if (opt == 67) {
#line 489
      goto case_67;
    }
#line 491
    if (opt == 111) {
#line 491
      goto case_111;
    }
#line 492
    if (opt == 99) {
#line 492
      goto case_99;
    }
#line 494
    if (opt == 97) {
#line 494
      goto case_97;
    }
#line 495
    if (opt == 65) {
#line 495
      goto case_65;
    }
#line 496
    if (opt == 98) {
#line 496
      goto case_98;
    }
#line 497
    if (opt == 88) {
#line 497
      goto case_88;
    }
#line 498
    if (opt == 87) {
#line 498
      goto case_87;
    }
#line 500
    if (opt == 90) {
#line 500
      goto case_90;
    }
#line 502
    if (opt == 112) {
#line 502
      goto case_112;
    }
#line 506
    if (opt == 86) {
#line 506
      goto case_86;
    }
#line 508
    if (opt == 122) {
#line 508
      goto case_122;
    }
#line 470
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_58: /* CIL Label */ 
    {
#line 473
    tmp___2 = usage();
#line 473
    exit(tmp___2);
    }
    case_100: /* CIL Label */ 
#line 474
    del = 1;
#line 474
    goto switch_break;
    case_103: /* CIL Label */ 
#line 475
    guess = 1;
#line 475
    goto switch_break;
    case_116: /* CIL Label */ 
#line 476
    text = 1;
#line 476
    goto switch_break;
    case_84: /* CIL Label */ 
#line 477
    test = 1;
#line 477
    goto switch_break;
    case_83: /* CIL Label */ 
#line 478
    spool = 1;
#line 478
    goto switch_break;
    case_108: /* CIL Label */ 
#line 479
    list = 1;
#line 479
    goto switch_break;
    case_105: /* CIL Label */ 
#line 480
    info ++;
#line 480
    goto switch_break;
    case_113: /* CIL Label */ 
#line 481
    quiet ++;
#line 481
    goto switch_break;
    case_81: /* CIL Label */ 
#line 482
    quiet = 2;
#line 482
    goto switch_break;
    case_80: /* CIL Label */ 
#line 483
    stdinf = 1;
#line 483
    goto switch_break;
    case_115: /* CIL Label */ 
#line 484
    source = 1;
#line 484
    goto switch_break;
    case_77: /* CIL Label */ 
#line 485
    mime = 1;
#line 485
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 486
    tmp___3 = atof((char const   *)optarg);
#line 486
    mtp = (float )tmp___3;
    }
#line 486
    if (mtp < (float )0) {
#line 486
      mtp = (float )0;
    }
#line 486
    goto switch_break;
    case_118: /* CIL Label */ 
#line 487
    verbose ++;
#line 487
    goto switch_break;
    case_117: /* CIL Label */ 
#line 488
    compress = (char *)"";
#line 488
    goto switch_break;
    case_67: /* CIL Label */ 
#line 489
    if ((int )*optarg == 61) {
      {
#line 489
      strcpy((char */* __restrict  */)(force_compress), (char const   */* __restrict  */)(optarg + 1));
      }
    } else {
      {
#line 490
      strcpy((char */* __restrict  */)(force_compress), (char const   */* __restrict  */)optarg);
      }
    }
#line 490
    goto switch_break;
    case_111: /* CIL Label */ 
#line 491
    overwrite = 1;
#line 491
    goto switch_break;
    case_99: /* CIL Label */ 
#line 492
    if ((int )*optarg == 61) {
      {
#line 492
      strcpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)(optarg + 1));
      }
    } else {
      {
#line 493
      strcpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)optarg);
      }
    }
#line 493
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 494
    tar = 1;
#line 494
    strcpy((char */* __restrict  */)(archive), (char const   */* __restrict  */)optarg);
    }
#line 494
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 495
    zip = 1;
#line 495
    strcpy((char */* __restrict  */)(archive), (char const   */* __restrict  */)optarg);
    }
#line 495
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 496
    bounce = 1;
#line 496
    strcpy((char */* __restrict  */)(bouncearg), (char const   */* __restrict  */)optarg);
    }
#line 496
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 497
    extended = 1;
#line 497
    strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)optarg);
    }
#line 497
    goto switch_break;
    case_87: /* CIL Label */ 
#line 498
    if ((int )*optarg == 61) {
      {
#line 498
      strcpy((char */* __restrict  */)(where), (char const   */* __restrict  */)(optarg + 1));
      }
    } else {
      {
#line 499
      strcpy((char */* __restrict  */)(where), (char const   */* __restrict  */)optarg);
      }
    }
#line 499
    goto switch_break;
    case_90: /* CIL Label */ 
#line 500
    if ((int )*optarg == 61) {
      {
#line 500
      packet_size = atoi((char const   *)(optarg + 1));
      }
    } else {
      {
#line 501
      packet_size = atoi((char const   *)optarg);
      }
    }
#line 501
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 502
    pgp = 1;
#line 503
    snprintf((char */* __restrict  */)(tmp), (size_t )255, (char const   */* __restrict  */)"%s\n%s",
             pgpopt, optarg);
#line 504
    strcpy((char */* __restrict  */)(pgpopt), (char const   */* __restrict  */)(tmp));
    }
#line 505
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 506
    message(prg, (char )'I', "version 2.1b revision 20080311");
#line 507
    exit(0);
    }
    case_122: /* CIL Label */ 
    {
#line 508
    strcpy((char */* __restrict  */)(force_compress), (char const   */* __restrict  */)"gzip");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  if (argc - optind < 2) {
#line 517
    if (! extended) {
#line 517
      if (! list) {
#line 517
        if (! where[0]) {
#line 518
          if (argc - optind < 1) {
            {
#line 518
            tmp___4 = usage();
#line 518
            exit(tmp___4);
            }
          }
          {
#line 519
          tmp___5 = __errno_location();
#line 519
          *tmp___5 = 0;
#line 520
          message(prg, (char )'F', "too few arguments: you must specify at least a file name and recipient");
          }
        }
      }
    }
  }
#line 525
  if (! quiet) {
    {
#line 526
    cp = getenv("TERM");
    }
#line 527
    if (! cp) {
#line 527
      quiet = 1;
    } else
#line 527
    if (! *cp) {
#line 527
      quiet = 1;
    } else {
      {
#line 527
      tmp___6 = strstr("tty|dumb", (char const   *)cp);
      }
#line 527
      if (tmp___6) {
#line 527
        quiet = 1;
      }
    }
  }
#line 532
  if (test) {
#line 532
    if (spool) {
      {
#line 533
      tmp___7 = __errno_location();
#line 533
      *tmp___7 = 0;
#line 534
      message(prg, (char )'F', "you cannot specify :NULL: and -S option together");
      }
    }
  }
#line 537
  if (extended) {
    {
#line 538
    tmp___9 = strchr((char const   *)(host), '@');
    }
#line 538
    if (tmp___9) {
      {
#line 539
      tmp___8 = __errno_location();
#line 539
      *tmp___8 = 0;
#line 540
      message(prg, (char )'F', "you must specify only a host name with the -X option");
      }
    }
#line 542
    if (del) {
#line 542
      goto _L;
    } else
#line 542
    if (text) {
#line 542
      goto _L;
    } else
#line 542
    if (spool) {
#line 542
      goto _L;
    } else
#line 542
    if (stdinf) {
#line 542
      goto _L;
    } else
#line 542
    if (source) {
#line 542
      goto _L;
    } else
#line 542
    if (mime) {
#line 542
      goto _L;
    } else
#line 542
    if (overwrite) {
#line 542
      goto _L;
    } else
#line 542
    if (tar) {
#line 542
      goto _L;
    } else
#line 542
    if (bounce) {
#line 542
      goto _L;
    } else
#line 542
    if (pgp) {
#line 542
      goto _L;
    } else
#line 542
    if (comment[0]) {
      _L: /* CIL Label */ 
#line 544
      if (quiet < 2) {
        {
#line 544
        message(prg, (char )'W', "you cannot use any other option with the extended header option - ignored");
        }
      }
#line 546
      pgp = 0;
#line 546
      bounce = pgp;
#line 546
      tar = bounce;
#line 546
      overwrite = tar;
#line 546
      mime = overwrite;
#line 546
      source = mime;
#line 546
      stdinf = source;
#line 546
      spool = stdinf;
#line 546
      text = spool;
#line 546
      del = text;
#line 547
      comment[0] = (char)0;
    }
  }
#line 551
  if (bounce) {
    {
#line 552
    tmp___11 = strcmp((char const   *)(bouncearg), "k=y");
    }
#line 552
    if (! (tmp___11 == 0)) {
      {
#line 552
      tmp___12 = strcmp((char const   *)(bouncearg), "k=n");
      }
#line 552
      if (! (tmp___12 == 0)) {
        {
#line 553
        tmp___10 = __errno_location();
#line 553
        *tmp___10 = 0;
#line 554
        message(prg, (char )'F', "wrong bouncing argument");
        }
      }
    }
#line 556
    if (source) {
#line 556
      goto _L___0;
    } else
#line 556
    if (mime) {
#line 556
      goto _L___0;
    } else
#line 556
    if (text) {
#line 556
      goto _L___0;
    } else
#line 556
    if (tar) {
#line 556
      goto _L___0;
    } else
#line 556
    if (del | stdinf) {
      _L___0: /* CIL Label */ 
#line 557
      if (quiet < 2) {
        {
#line 557
        message(prg, (char )'W', "you cannot use any other option when bouncing a file - ignored");
        }
      }
    }
#line 559
    stdinf = 0;
#line 559
    del = stdinf;
#line 559
    tar = del;
#line 559
    mime = tar;
#line 559
    source = mime;
#line 559
    text = source;
#line 560
    compress = (char *)"";
  }
#line 563
  if (del) {
#line 564
    if (source) {
#line 564
      goto _L___1;
    } else
#line 564
    if (mime) {
#line 564
      goto _L___1;
    } else
#line 564
    if (text) {
#line 564
      goto _L___1;
    } else
#line 564
    if (tar) {
#line 564
      goto _L___1;
    } else
#line 564
    if (overwrite) {
#line 564
      goto _L___1;
    } else
#line 564
    if (stdinf) {
#line 564
      goto _L___1;
    } else
#line 564
    if (pgp) {
#line 564
      goto _L___1;
    } else
#line 564
    if (comment[0]) {
      _L___1: /* CIL Label */ 
#line 565
      if (quiet < 2) {
        {
#line 565
        message(prg, (char )'W', "you cannot use any other option when deleting a file - ignored");
        }
      }
    }
#line 567
    stdinf = 0;
#line 567
    tar = stdinf;
#line 567
    mime = tar;
#line 567
    source = mime;
#line 567
    text = source;
#line 568
    compress = (char *)"";
  }
#line 571
  if (guess) {
#line 572
    if (source) {
#line 572
      goto _L___2;
    } else
#line 572
    if (mime) {
#line 572
      goto _L___2;
    } else
#line 572
    if (text) {
#line 572
      goto _L___2;
    } else
#line 572
    if (tar) {
      _L___2: /* CIL Label */ 
#line 573
      if (quiet < 2) {
        {
#line 573
        message(prg, (char )'W', "you cannot use source, text, mime or archive option when guessing the file type - ignored");
        }
      }
    }
#line 576
    tar = 0;
#line 576
    mime = tar;
#line 576
    source = mime;
#line 576
    text = source;
  }
#line 579
  if (stdinf) {
#line 580
    if (tar) {
#line 581
      if (quiet < 2) {
        {
#line 581
        message(prg, (char )'W', "you cannot send stdin as an archive file; -a option will be ignored");
        }
      }
    }
#line 583
    tar = 0;
  }
#line 586
  if (tar) {
#line 586
    if (zip) {
      {
#line 587
      tmp___13 = __errno_location();
#line 587
      *tmp___13 = 0;
#line 588
      message(prg, (char )'F', "you cannot use the -a and -A archive options together");
      }
    }
  }
#line 591
  if (tar) {
#line 591
    goto _L___3;
  } else
#line 591
  if (zip) {
    _L___3: /* CIL Label */ 
#line 592
    if (source) {
#line 593
      if (quiet < 2) {
        {
#line 593
        message(prg, (char )'W', "option SOURCE is not allowed when sending in archive format - ignored");
        }
      }
    }
#line 595
    if (mime) {
#line 596
      if (quiet < 2) {
        {
#line 596
        message(prg, (char )'W', "option MIME is not allowed when sending in archive format - ignored");
        }
      }
    }
#line 598
    if (text) {
#line 599
      if (quiet < 2) {
        {
#line 599
        message(prg, (char )'W', "option TEXT is not allowed when sending in archive format - ignored");
        }
      }
    }
#line 601
    mime = 0;
#line 601
    source = mime;
#line 601
    text = source;
  }
#line 605
  if (archive[0]) {
#line 606
    if ((int )archive[0] == 61) {
      {
#line 607
      strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(archive + 1));
#line 608
      strcpy((char */* __restrict  */)(archive), (char const   */* __restrict  */)(tmp));
      }
    } else {
      {
#line 610
      tmp___14 = __errno_location();
#line 610
      *tmp___14 = 0;
#line 611
      message(prg, (char )'F', "you have not specified an archive name with -a=name-of-archive");
      }
    }
  }
#line 617
  if (comment[0]) {
#line 617
    if (argc - optind > 2) {
#line 617
      if (! tar) {
        {
#line 618
        tmp___15 = __errno_location();
#line 618
        *tmp___15 = 0;
#line 619
        message(prg, (char )'F', "you can only comment a single file");
        }
      }
    }
  }
  {
#line 623
  umask((__mode_t )(~ 384));
#line 626
  memset((void *)(tar_bin), 0, sizeof(tar_bin));
#line 627
  memset((void *)(pgp_bin), 0, sizeof(pgp_bin));
#line 628
  memset((void *)(gzip_bin), 0, sizeof(gzip_bin));
#line 629
  memset((void *)(bzip2_bin), 0, sizeof(bzip2_bin));
#line 631
  strcpy((char */* __restrict  */)(tar_bin), (char const   */* __restrict  */)"tar");
#line 632
  strcpy((char */* __restrict  */)(pgp_bin), (char const   */* __restrict  */)"pgp");
#line 633
  strcpy((char */* __restrict  */)(gzip_bin), (char const   */* __restrict  */)"gzip");
#line 634
  strcpy((char */* __restrict  */)(bzip2_bin), (char const   */* __restrict  */)"bzip2");
#line 637
  cp = getenv("SF_TAR");
  }
#line 637
  if (cp) {
    {
#line 637
    strncpy((char */* __restrict  */)(tar_bin), (char const   */* __restrict  */)cp,
            sizeof(tar_bin) - 1UL);
    }
  }
  {
#line 638
  cp = getenv("SF_PGP");
  }
#line 638
  if (cp) {
    {
#line 638
    strncpy((char */* __restrict  */)(pgp_bin), (char const   */* __restrict  */)cp,
            sizeof(pgp_bin) - 1UL);
    }
  }
  {
#line 639
  cp = getenv("SF_GZIP");
  }
#line 639
  if (cp) {
    {
#line 639
    strncpy((char */* __restrict  */)(gzip_bin), (char const   */* __restrict  */)cp,
            sizeof(gzip_bin) - 1UL);
    }
  }
  {
#line 640
  cp = getenv("SF_BZIP2");
  }
#line 640
  if (cp) {
    {
#line 640
    strncpy((char */* __restrict  */)(bzip2_bin), (char const   */* __restrict  */)cp,
            sizeof(bzip2_bin) - 1UL);
    }
  }
  {
#line 643
  tmp___16 = access((char const   *)(tar_bin), 1);
  }
#line 643
  if (tmp___16 < 0) {
    {
#line 643
    strcpy((char */* __restrict  */)(tar_bin), (char const   */* __restrict  */)"tar");
    }
  }
  {
#line 644
  tmp___17 = access((char const   *)(pgp_bin), 1);
  }
#line 644
  if (tmp___17 < 0) {
    {
#line 644
    strcpy((char */* __restrict  */)(pgp_bin), (char const   */* __restrict  */)"pgp");
    }
  }
  {
#line 645
  tmp___18 = access((char const   *)(gzip_bin), 1);
  }
#line 645
  if (tmp___18 < 0) {
    {
#line 645
    strcpy((char */* __restrict  */)(gzip_bin), (char const   */* __restrict  */)"gzip");
    }
  }
  {
#line 646
  tmp___19 = access((char const   *)(bzip2_bin), 1);
  }
#line 646
  if (tmp___19 < 0) {
    {
#line 646
    strcpy((char */* __restrict  */)(bzip2_bin), (char const   */* __restrict  */)"bzip2");
    }
  }
#line 649
  if (force_compress[0]) {
    {
#line 650
    compress = (char *)"";
#line 651
    tmp___20 = strstr((char const   *)(force_compress), "gzip");
    }
#line 651
    if (tmp___20) {
#line 651
      compress = (char *)"GZIP";
    }
    {
#line 652
    tmp___21 = strstr((char const   *)(force_compress), "bzip2");
    }
#line 652
    if (tmp___21) {
#line 652
      compress = (char *)"BZIP2";
    }
#line 653
    if (! *compress) {
      {
#line 654
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"unsupported compression program %s",
               force_compress);
#line 655
      tmp___22 = __errno_location();
#line 655
      *tmp___22 = 0;
#line 656
      message(prg, (char )'F', (char const   *)(tmp));
      }
    }
    {
#line 658
    strcpy((char */* __restrict  */)(zprg), (char const   */* __restrict  */)(force_compress));
    }
  } else
#line 660
  if (*compress) {
    {
#line 693
    tmp___23 = whereis(gzip_bin);
    }
#line 693
    if (tmp___23) {
#line 693
      if (! zprg[0]) {
        {
#line 694
        strcpy((char */* __restrict  */)(zprg), (char const   */* __restrict  */)(gzip_bin));
#line 695
        compress = (char *)"GZIP";
        }
      }
    }
#line 698
    if (! zprg[0]) {
#line 699
      compress = (char *)"";
#line 700
      if (quiet < 2) {
        {
#line 700
        message(prg, (char )'W', "no compression program found - sending uncompressed");
        }
      }
    }
  }
  {
#line 706
  tmp___24 = gethostname(localhost, (size_t )255);
  }
#line 706
  if (tmp___24 < 0) {
    {
#line 706
    strcpy((char */* __restrict  */)(localhost), (char const   */* __restrict  */)"localhost");
    }
  }
#line 709
  if (extended) {
    {
#line 710
    forward(host, mtp);
#line 711
    exit(0);
    }
  }
  {
#line 715
  destination(argc, argv, user, recipient, host, aopt);
#line 719
  tmp___25 = strcmp((char const   *)(host), "127.0.0.1");
  }
#line 719
  if (tmp___25 == 0) {
    {
#line 719
    strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(localhost));
    }
  } else {
    {
#line 719
    tmp___26 = strcmp((char const   *)(host), "0");
    }
#line 719
    if (tmp___26 == 0) {
      {
#line 719
      strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(localhost));
      }
    }
  }
#line 721
  if (aopt[0]) {
    {
#line 722
    snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s %s ",
             *(argv + 0), aopt);
#line 723
    i = 1;
    }
    {
#line 723
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 723
      if (! (i < argc - 1)) {
#line 723
        goto while_break___0;
      }
      {
#line 724
      strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"\'");
#line 725
      strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)*(argv + i));
#line 726
      strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"\' ");
#line 723
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 728
    strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"saft://");
#line 729
    strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)(host));
#line 730
    strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"/");
#line 731
    strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)(recipient));
#line 732
    vsystem((char const   *)(cmd));
#line 733
    exit(0);
    }
  }
  {
#line 737
  tmp___27 = strcmp((char const   *)(recipient), "/dev/null");
  }
#line 737
  if (tmp___27 == 0) {
    {
#line 737
    strcpy((char */* __restrict  */)(recipient), (char const   */* __restrict  */)":NULL:");
    }
  }
  {
#line 738
  tmp___29 = strcmp((char const   *)(recipient), ":NULL:");
  }
#line 738
  if (tmp___29 == 0) {
    {
#line 739
    compress = (char *)"";
#line 740
    tmp___28 = strcmp((char const   *)(host), (char const   *)(localhost));
    }
#line 740
    if (tmp___28 == 0) {
#line 740
      test = 1;
    }
  }
  {
#line 744
  tmp___30 = getuid();
#line 744
  pwe = getpwuid(tmp___30);
  }
#line 744
  if ((unsigned long )pwe == (unsigned long )((void *)0)) {
    {
#line 745
    message(prg, (char )'F', "cannot determine own user name");
    }
  }
  {
#line 746
  strcpy((char */* __restrict  */)(pw_name), (char const   */* __restrict  */)pwe->pw_name);
#line 747
  tmpdir = mktmpdir(verbose);
  }
#line 750
  if (pgp) {
    {
#line 751
    pop = pgpopt;
#line 754
    tmp___32 = strcmp((char const   *)pop, "\nc");
    }
#line 754
    if (tmp___32 == 0) {
#line 755
      pgpcrypt = 'c';
#line 756
      compress = (char *)"";
    } else {
      {
#line 759
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 759
        if (! *pop) {
#line 759
          goto while_break___1;
        }
#line 760
        pop ++;
#line 763
        if ((int )*pop == 101) {
          {
#line 764
          pgpcrypt = 'e';
#line 765
          compress = (char *)"";
#line 766
          pop ++;
#line 767
          snprintf((char */* __restrict  */)(pgprid), sizeof(pgprid) - 1UL, (char const   */* __restrict  */)"%s@%s",
                   recipient, host);
          }
#line 770
          if ((int )*pop > 10) {
#line 771
            if ((int )*pop == 61) {
              {
#line 771
              pop ++;
#line 771
              strcpy((char */* __restrict  */)(pgprid), (char const   */* __restrict  */)pop);
              }
            }
            {
#line 774
            cp = strchr((char const   *)(pgprid), '\n');
            }
#line 774
            if (cp) {
              {
#line 775
              *cp = (char)0;
#line 776
              pop = strchr((char const   *)pop, '\n');
              }
            } else {
#line 778
              *pop = (char)0;
            }
          }
#line 788
          goto while_continue___1;
        }
#line 792
        if ((int )*pop == 115) {
          {
#line 793
          strcpy((char */* __restrict  */)(pgpsign), (char const   */* __restrict  */)" ");
#line 794
          pop ++;
          }
#line 797
          if ((int )*pop > 10) {
#line 798
            if ((int )*pop == 61) {
#line 798
              pop ++;
            }
            {
#line 799
            snprintf((char */* __restrict  */)(pgpsign), sizeof(pgpsign) - 1UL, (char const   */* __restrict  */)"-u \'%s",
                     pop);
#line 802
            cp = strchr((char const   *)(pgpsign), '\n');
            }
#line 802
            if (cp) {
              {
#line 803
              *cp = (char)0;
#line 804
              pop = strchr((char const   *)pop, '\n');
              }
            } else {
#line 806
              *pop = (char)0;
            }
            {
#line 808
            strcat((char */* __restrict  */)(pgpsign), (char const   */* __restrict  */)"\'");
            }
          }
#line 811
          goto while_continue___1;
        }
        {
#line 815
        tmp___31 = __errno_location();
#line 815
        *tmp___31 = 0;
#line 816
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"wrong pgp option, see \'man %s\'",
                 prg);
#line 817
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 824
  snprintf((char */* __restrict  */)(userspool), sizeof(userspool) - 1UL, (char const   */* __restrict  */)"/var/spool/sendfile/%s",
           pw_name);
#line 825
  snprintf((char */* __restrict  */)(outlogtmp), sizeof(outlogtmp) - 1UL, (char const   */* __restrict  */)"%s/.sendfile_%d.log",
           userspool, pid);
#line 826
  snprintf((char */* __restrict  */)(tartmp), sizeof(tartmp) - 1UL, (char const   */* __restrict  */)"%s/sendfile.tar",
           tmpdir);
#line 827
  snprintf((char */* __restrict  */)(ziptmp), sizeof(ziptmp) - 1UL, (char const   */* __restrict  */)"%s/sendfile.zip",
           tmpdir);
#line 828
  snprintf((char */* __restrict  */)(pgptmp), sizeof(pgptmp) - 1UL, (char const   */* __restrict  */)"%s/sendfile.pgp",
           tmpdir);
#line 829
  snprintf((char */* __restrict  */)(texttmp), sizeof(texttmp) - 1UL, (char const   */* __restrict  */)"%s/sendfile.txt",
           tmpdir);
#line 830
  snprintf((char */* __restrict  */)(stdintmp), sizeof(stdintmp) - 1UL, (char const   */* __restrict  */)"%s/sendfile.tmp",
           tmpdir);
  }
#line 833
  if (where[0]) {
    {
#line 834
    tmp___36 = strcmp((char const   *)(where), "config");
    }
#line 834
    if (tmp___36 == 0) {
#line 834
      goto _L___4;
    } else {
      {
#line 834
      tmp___37 = strcmp((char const   *)(where), "sendfile.cf");
      }
#line 834
      if (tmp___37 == 0) {
        _L___4: /* CIL Label */ 
#line 835
        if (quiet) {
          {
#line 836
          printf((char const   */* __restrict  */)"/usr/local/etc/sendfile.cf\n");
          }
        } else {
          {
#line 838
          message(prg, (char )'I', "the global configuration file is: /usr/local/etc/sendfile.cf");
          }
        }
      } else {
        {
#line 839
        tmp___35 = strcmp((char const   *)(where), "spool");
        }
#line 839
        if (tmp___35 == 0) {
#line 840
          if (quiet) {
            {
#line 841
            printf((char const   */* __restrict  */)"/var/spool/sendfile\n");
            }
          } else {
            {
#line 843
            message(prg, (char )'I', "the spool directory is: /var/spool/sendfile");
            }
          }
        } else {
          {
#line 844
          tmp___34 = strcmp((char const   *)(where), "userspool");
          }
#line 844
          if (tmp___34 == 0) {
#line 845
            if (quiet) {
              {
#line 846
              printf((char const   */* __restrict  */)"%s\n", userspool);
              }
            } else {
              {
#line 848
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"the user spool directory is: %s",
                       userspool);
#line 849
              message(prg, (char )'I', (char const   *)(tmp));
              }
            }
          } else {
            {
#line 852
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is an unknown -W argument",
                     where);
#line 853
            tmp___33 = __errno_location();
#line 853
            *tmp___33 = 0;
#line 854
            message(prg, (char )'E', (char const   *)(tmp));
            }
#line 855
            if (quiet < 2) {
              {
#line 855
              message(prg, (char )'I', "you may specify -W=config, -W=spool, or -W=userspool");
              }
            }
          }
        }
      }
    }
#line 858
    if (argc - optind < 1) {
      {
#line 858
      cleanup();
#line 858
      exit(0);
      }
    }
  }
  {
#line 862
  unlink((char const   *)(tartmp));
#line 863
  unlink((char const   *)(ziptmp));
#line 864
  unlink((char const   *)(texttmp));
#line 865
  unlink((char const   *)(pgptmp));
#line 866
  unlink((char const   *)(stdintmp));
#line 867
  tmp___38 = stat((char const   */* __restrict  */)(tartmp), (struct stat */* __restrict  */)(& finfo));
  }
#line 867
  if (tmp___38 == 0) {
    {
#line 868
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"tmp-file %s does already exist and cannot be deleted",
             tartmp);
#line 870
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 872
  tmp___39 = stat((char const   */* __restrict  */)(ziptmp), (struct stat */* __restrict  */)(& finfo));
  }
#line 872
  if (tmp___39 == 0) {
    {
#line 873
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"tmp-file %s does already exist and cannot be deleted",
             ziptmp);
#line 875
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 877
  tmp___40 = stat((char const   */* __restrict  */)(texttmp), (struct stat */* __restrict  */)(& finfo));
  }
#line 877
  if (tmp___40 == 0) {
    {
#line 878
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"tmp-file %s does already exist and cannot be deleted",
             texttmp);
#line 880
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 882
  tmp___41 = stat((char const   */* __restrict  */)(pgptmp), (struct stat */* __restrict  */)(& finfo));
  }
#line 882
  if (tmp___41 == 0) {
    {
#line 883
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"tmp-file %s does already exist and cannot be deleted",
             pgptmp);
#line 885
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 887
  tmp___42 = stat((char const   */* __restrict  */)(stdintmp), (struct stat */* __restrict  */)(& finfo));
  }
#line 887
  if (tmp___42 == 0) {
    {
#line 888
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"tmp-file %s does already exist and cannot be deleted",
             stdintmp);
#line 890
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 894
  inf = rfopen("/usr/local/etc/sendfile.cf", "r");
  }
#line 894
  if (inf) {
    {
#line 895
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 895
      tmp___53 = sfgetl(line, (int )sizeof(line), inf);
      }
#line 895
      if (! tmp___53) {
#line 895
        goto while_break___2;
      }
      {
#line 898
      cp = strchr((char const   *)(line), '#');
      }
#line 898
      if (cp) {
#line 898
        *cp = (char)0;
      }
      {
#line 899
      cp = strchr((char const   *)(line), '=');
      }
#line 899
      if (cp) {
#line 899
        *cp = (char )' ';
      }
      {
#line 900
      tmp___43 = str_trim(line);
#line 900
      str_tolower(tmp___43);
#line 903
      argp = strchr((char const   *)(line), ' ');
      }
#line 903
      if (argp) {
        {
#line 904
        *argp = (char)0;
#line 904
        argp ++;
#line 905
        tmp___44 = strcmp((char const   *)(line), "packet");
        }
#line 905
        if (tmp___44 == 0) {
#line 905
          if (packet_size == 0) {
            {
#line 906
            packet_size = atoi((char const   *)argp);
            }
#line 907
            goto while_continue___2;
          }
        }
        {
#line 909
        tmp___45 = strcmp((char const   *)(line), "lanspeed");
        }
#line 909
        if (tmp___45 == 0) {
          {
#line 910
          lanspeed = atoi((char const   *)argp);
          }
#line 911
          if (lanspeed < 0) {
#line 911
            lanspeed = 0;
          }
#line 912
          goto while_continue___2;
        }
        {
#line 914
        tmp___48 = strcmp((char const   *)(line), "log");
        }
#line 914
        if (tmp___48 == 0) {
          {
#line 915
          tmp___46 = strcmp((char const   *)argp, "out");
          }
#line 915
          if (tmp___46 == 0) {
#line 915
            outlogging = 1;
          } else {
            {
#line 915
            tmp___47 = strcmp((char const   *)argp, "both");
            }
#line 915
            if (tmp___47 == 0) {
#line 915
              outlogging = 1;
            }
          }
#line 916
          goto while_continue___2;
        }
        {
#line 918
        tmp___51 = strcmp((char const   *)(line), "spooling");
        }
#line 918
        if (tmp___51 == 0) {
          {
#line 919
          tmp___49 = strcmp((char const   *)argp, "nostart");
          }
#line 919
          if (tmp___49 == 0) {
#line 919
            spooling = 1;
          }
          {
#line 920
          tmp___50 = strcmp((char const   *)argp, "on");
          }
#line 920
          if (tmp___50 == 0) {
#line 920
            spooling = 2;
          }
#line 921
          goto while_continue___2;
        }
        {
#line 923
        tmp___52 = strcmp((char const   *)(line), "dontcompress");
        }
#line 923
        if (tmp___52 == 0) {
#line 924
          if (*argp) {
            {
#line 926
            dontcompress[0] = strdup((char const   *)argp);
            }
#line 926
            if (! dontcompress[0]) {
              {
#line 927
              message(prg, (char )'F', "out of memory");
              }
            }
            {
#line 929
            n = 1;
#line 929
            cp = strtok((char */* __restrict  */)dontcompress[0], (char const   */* __restrict  */)", \t");
            }
            {
#line 929
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 929
              if (cp) {
#line 929
                if (! (n < 99)) {
#line 929
                  goto while_break___3;
                }
              } else {
#line 929
                goto while_break___3;
              }
              {
#line 933
              dontcompress[n] = cp;
#line 929
              n ++;
#line 929
              cp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", \t");
              }
            }
            while_break___3: /* CIL Label */ ;
            }
#line 935
            dontcompress[n] = (char *)"";
          }
#line 937
          goto while_continue___2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 942
    fclose(inf);
    }
  }
#line 946
  if (spool) {
#line 946
    goto _L___5;
  } else
#line 946
  if (list) {
    _L___5: /* CIL Label */ 
#line 946
    if (! spooling) {
      {
#line 947
      tmp___54 = __errno_location();
#line 947
      *tmp___54 = 0;
#line 948
      message(prg, (char )'F', "outgoing spooling of files is not allowed on this system");
      }
    }
  }
#line 952
  if (list) {
    {
#line 952
    tmp___55 = list_spool();
#line 952
    exit(tmp___55);
    }
  }
#line 955
  if (packet_size < 1) {
#line 955
    packet_size = 512;
  }
#line 956
  if (verbose) {
#line 956
    if (! spool) {
#line 956
      if (! del) {
        {
#line 957
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"packet size = %d bytes",
                 packet_size);
#line 958
        message(prg, (char )'I', (char const   *)(tmp));
        }
      }
    }
  }
  {
#line 962
  signal(15, (void (*)(int  ))(& cleanexit));
#line 963
  signal(6, (void (*)(int  ))(& cleanexit));
#line 964
  signal(3, (void (*)(int  ))(& cleanexit));
#line 965
  signal(1, (void (*)(int  ))(& cleanexit));
#line 966
  signal(2, (void (*)(int  ))(& cleanexit));
  }
#line 969
  if (stdinf) {
    {
#line 972
    outf = rfopen((char const   *)(stdintmp), "w");
    }
#line 972
    if (! outf) {
      {
#line 973
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open tmp-file %s",
               stdintmp);
#line 974
      message(prg, (char )'F', (char const   *)(tmp));
      }
    }
    {
#line 977
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 977
      tmp___58 = fileno(stdin);
#line 977
      tmp___59 = read(tmp___58, (void *)(iobuf), (size_t )4096);
#line 977
      bytes = (int )tmp___59;
      }
#line 977
      if (! bytes) {
#line 977
        goto while_break___4;
      }
#line 978
      if (bytes < 0) {
        {
#line 978
        message(prg, (char )'F', "error while reading from stdin");
        }
      }
      {
#line 979
      tmp___56 = fileno(outf);
#line 979
      tmp___57 = write(tmp___56, (void const   *)(iobuf), (size_t )bytes);
      }
#line 979
      if (tmp___57 != (ssize_t )bytes) {
        {
#line 980
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error while writing stdin to %s",
                 stdintmp);
#line 981
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 984
    fclose(outf);
    }
  }
#line 989
  type = (char *)"BINARY";
#line 990
  if (text) {
#line 990
    type = (char *)"TEXT=ISO_8859-1:1987";
  }
#line 991
  if (mime) {
#line 991
    type = (char *)"MIME";
  }
#line 992
  if (source) {
#line 992
    type = (char *)"SOURCE";
  }
#line 995
  if (! test) {
#line 998
    if (! spool) {
      {
#line 1001
      sockfd = saft_connect("file", recipient, user, host, redirect);
      }
#line 1004
      if (*compress) {
#line 1004
        do_compress = 1;
      }
#line 1005
      if (do_compress) {
#line 1005
        if (! force_compress[0]) {
          {
#line 1006
          do_compress = linkspeed((char const   *)(host), lanspeed, & compress);
          }
        }
      }
#line 1009
      if (do_compress) {
#line 1009
        if (zprg[0]) {
          {
#line 1009
          tmp___61 = strstr((char const   *)(zprg), "bzip2");
          }
#line 1009
          if (tmp___61) {
            {
#line 1010
            sendcommand(sockfd, "TYPE BINARY COMPRESSED=BZIP2", reply___1);
#line 1012
            tmp___60 = str_beq((char const   *)(reply___1), "200 ");
            }
#line 1012
            if (tmp___60) {
#line 1016
              compress = (char *)"BZIP2";
            } else
#line 1012
            if (gzip_bin[0]) {
#line 1012
              if (! force_compress[0]) {
                {
#line 1013
                compress = (char *)"GZIP";
#line 1014
                strcpy((char */* __restrict  */)(zprg), (char const   */* __restrict  */)(gzip_bin));
                }
              } else {
#line 1016
                compress = (char *)"BZIP2";
              }
            } else {
#line 1016
              compress = (char *)"BZIP2";
            }
          }
        }
      }
    } else {
      {
#line 1023
      strcpy((char */* __restrict  */)(outgoing), (char const   */* __restrict  */)"/var/spool/sendfile/OUTGOING");
#line 1024
      tmp___62 = stat((char const   */* __restrict  */)(outgoing), (struct stat */* __restrict  */)(& finfo));
      }
#line 1024
      if (tmp___62 < 0) {
        {
#line 1025
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"spool directory %s does not exist",
                 outgoing);
#line 1026
        message(prg, (char )'F', (char const   *)(tmp));
        }
      } else
#line 1024
      if (! ((finfo.st_mode & 61440U) == 16384U)) {
        {
#line 1025
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"spool directory %s does not exist",
                 outgoing);
#line 1026
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
#line 1030
      if (finfo.st_mode & 512U) {
#line 1030
        if (! (finfo.st_mode & (unsigned int )((448 >> 3) >> 3))) {
          {
#line 1031
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"spool directory %s has wrong protection (must have 1777)",
                   outgoing);
#line 1034
          message(prg, (char )'F', (char const   *)(tmp));
          }
        }
      } else {
        {
#line 1031
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"spool directory %s has wrong protection (must have 1777)",
                 outgoing);
#line 1034
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
      {
#line 1038
      tmp___63 = strcmp((char const   *)(host), "127.0.0.1");
      }
#line 1038
      if (tmp___63 == 0) {
        {
#line 1038
        strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(localhost));
        }
      } else {
        {
#line 1038
        tmp___64 = strcmp((char const   *)(host), "0");
        }
#line 1038
        if (tmp___64 == 0) {
          {
#line 1038
          strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(localhost));
          }
        }
      }
    }
  }
#line 1044
  if (bounce) {
    {
#line 1047
    tmp___65 = chdir((char const   *)(userspool));
    }
#line 1047
    if (tmp___65 < 0) {
      {
#line 1048
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot access spool directory %s",
               userspool);
#line 1049
      message(prg, (char )'F', (char const   *)(tmp));
      }
    }
#line 1053
    fn = optind;
    {
#line 1053
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1053
      if (! (fn < argc - 1)) {
#line 1053
        goto while_break___5;
      }
      {
#line 1054
      snprintf((char */* __restrict  */)(sdfn), sizeof(sdfn) - 1UL, (char const   */* __restrict  */)"%s.d",
               *(argv + fn));
#line 1055
      snprintf((char */* __restrict  */)(shfn), sizeof(shfn) - 1UL, (char const   */* __restrict  */)"%s.h",
               *(argv + fn));
      }
#line 1056
      if (info) {
        {
#line 1056
        snprintf((char */* __restrict  */)(tinfo), sizeof(tinfo) - 1UL, (char const   */* __restrict  */)"#%d/%d: ",
                 (fn - optind) + 1, (argc - optind) - 1);
        }
      }
      {
#line 1059
      shf = rfopen((char const   *)(shfn), "r");
      }
#line 1059
      if (! shf) {
        {
#line 1060
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open spool file #%s",
                 *(argv + fn));
#line 1061
        message(prg, (char )'E', (char const   *)(tmp));
        }
#line 1062
        goto __Cont;
      }
#line 1066
      if (spool) {
        {
#line 1069
        oshf = outspool((char const   *)(pw_name), (char const   *)(outgoing), oshfn);
        }
#line 1069
        if ((unsigned long )oshf == (unsigned long )((void *)0)) {
          {
#line 1070
          message(prg, (char )'F', "cannot create outgoing spool file");
          }
        }
        {
#line 1073
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"FROM\t%s\n",
                user);
#line 1074
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TO\t%s@%s\n",
                recipient, host);
        }
      }
#line 1078
      file[0] = (char)0;
#line 1079
      comment[0] = (char)0;
#line 1080
      compress = (char *)"";
      {
#line 1083
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1083
        tmp___83 = sfgetl(line, (int )sizeof(line), shf);
        }
#line 1083
        if (! tmp___83) {
#line 1083
          goto while_break___6;
        }
        {
#line 1084
        str_trim(line);
#line 1087
        tmp___66 = strchr((char const   *)(line), ' ');
        }
#line 1087
        if (! tmp___66) {
#line 1087
          goto while_continue___6;
        }
        {
#line 1090
        tmp___68 = str_beq((char const   *)(line), "FROM");
        }
#line 1090
        if (tmp___68) {
          {
#line 1091
          tmp___67 = strchr((char const   *)(line), ' ');
#line 1091
          strcpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)(tmp___67 + 1));
#line 1092
          cp = strchr((char const   *)(comment), ' ');
          }
#line 1092
          if (cp) {
            {
#line 1093
            *cp = (char)0;
#line 1094
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s+ACA-(%s)",
                     comment, cp + 1);
#line 1095
            strcpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)(tmp));
            }
          }
#line 1097
          goto while_continue___6;
        }
        {
#line 1101
        tmp___69 = str_beq((char const   *)(line), "FILE");
        }
#line 1101
        if (tmp___69) {
          {
#line 1101
          utf2iso(0, (char *)((void *)0), file, (char *)((void *)0), line + 5);
          }
        }
        {
#line 1104
        tmp___79 = str_beq((char const   *)(line), "TYPE");
        }
#line 1104
        if (tmp___79) {
          {
#line 1104
          tmp___80 = strstr((char const   *)(line), " COMPRESSED");
          }
#line 1104
          if (tmp___80) {
            {
#line 1105
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 1106
              type = (char *)"";
#line 1109
              tmp___71 = strstr((char const   *)(line), " COMPRESSED=BZIP2");
              }
#line 1109
              if (tmp___71) {
                {
#line 1110
                type = (char *)"BZIP2";
#line 1111
                compress = (char *)"BZIP2";
#line 1112
                sendcommand(sockfd, (char const   *)(line), reply___1);
#line 1113
                tmp___70 = str_beq((char const   *)(reply___1), "200 ");
                }
#line 1113
                if (tmp___70) {
#line 1113
                  goto while_break___7;
                }
                {
#line 1114
                cp = strrchr((char const   *)(line), '=');
#line 1115
                *cp = (char)0;
                }
              }
#line 1119
              if (! *type) {
#line 1119
                type = (char *)"GZIP";
              }
              {
#line 1120
              compress = (char *)"GZIP";
#line 1121
              sendcommand(sockfd, (char const   *)(line), reply___1);
#line 1122
              tmp___72 = str_beq((char const   *)(reply___1), "200 ");
              }
#line 1122
              if (tmp___72) {
#line 1122
                goto while_break___7;
              }
              {
#line 1125
              cp = strrchr((char const   *)(line), ' ');
#line 1126
              *cp = (char)0;
#line 1127
              compress = (char *)"";
#line 1128
              sendcommand(sockfd, (char const   *)(line), reply___1);
#line 1129
              tmp___73 = str_beq((char const   *)(reply___1), "200 ");
              }
#line 1129
              if (tmp___73) {
#line 1129
                goto while_break___7;
              }
              {
#line 1132
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot send %s : %s",
                       file, reply___1 + 4);
#line 1133
              tmp___74 = __errno_location();
#line 1133
              *tmp___74 = 0;
#line 1134
              message(prg, (char )'E', (char const   *)(tmp));
#line 1135
              fclose(inf);
              }
#line 1136
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 1140
            tmp___78 = strcmp((char const   *)type, (char const   *)compress);
            }
#line 1140
            if (! (tmp___78 == 0)) {
              {
#line 1143
              tmp___76 = strcmp((char const   *)type, "BZIP2");
              }
#line 1143
              if (tmp___76 == 0) {
                {
#line 1144
                tmp___75 = strcmp((char const   *)compress, "GZIP");
                }
#line 1144
                if (tmp___75 == 0) {
                  {
#line 1145
                  snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s -d <%s|%s>%s",
                           "bzip2", sdfn, "gzip", ziptmp);
                  }
                } else {
                  {
#line 1147
                  snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s -d < %s > %s",
                           "bzip2", sdfn, ziptmp);
                  }
                }
              } else {
                {
#line 1149
                snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s -dc %s > %s",
                         "gzip", sdfn, ziptmp);
                }
              }
              {
#line 1152
              tmp___77 = vsystem((char const   *)(cmd));
              }
#line 1152
              if (tmp___77) {
                {
#line 1153
                snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot recompress spool file #%s",
                         *(argv + fn));
#line 1154
                message(prg, (char )'E', (char const   *)(tmp));
#line 1155
                fclose(inf);
                }
#line 1156
                goto while_break___6;
              }
            }
#line 1160
            goto while_continue___6;
          }
        }
        {
#line 1164
        tmp___81 = str_beq((char const   *)(line), "SIZE ");
        }
#line 1164
        if (tmp___81) {
          {
#line 1165
          sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"SIZE %lld %lld",
                 & size, & orgsize);
#line 1166
          strcpy((char */* __restrict  */)(sizes), (char const   */* __restrict  */)(line + 5));
          }
        }
        {
#line 1170
        tmp___82 = str_beq((char const   *)(line), "COMMENT");
        }
#line 1170
        if (tmp___82) {
#line 1171
          if (redirect[0]) {
            {
#line 1172
            snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"%s+AA0ACg-%s",
                     comment, redirect);
            }
          } else {
            {
#line 1174
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s+AA0ACg-forward+ACA-from+ACA-%s",
                     line, comment);
#line 1176
            strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(tmp));
            }
          }
#line 1178
          if (spool) {
            {
#line 1179
            fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"%s\n",
                    line);
            }
          } else {
            {
#line 1181
            sendcommand(sockfd, (char const   *)(line), (char *)((void *)0));
            }
          }
#line 1182
          comment[0] = (char)0;
#line 1183
          goto while_continue___6;
        }
#line 1187
        if (spool) {
          {
#line 1188
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"%s\n",
                  line);
          }
        } else {
          {
#line 1190
          sendheader(sockfd, line);
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1195
      tmp___84 = fclose(shf);
      }
#line 1195
      if (tmp___84) {
#line 1196
        if (spool) {
          {
#line 1196
          fclose(oshf);
          }
        }
#line 1197
        goto __Cont;
      }
#line 1201
      if (comment[0]) {
        {
#line 1202
        iso2utf(tmp, (char *)"forward from ");
#line 1203
        snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"COMMENT %s%s",
                 tmp, comment);
        }
#line 1204
        if (redirect[0]) {
          {
#line 1205
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"\r\n%s",
                   redirect);
#line 1206
          iso2utf(comment, tmp);
#line 1207
          strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(comment));
          }
        }
#line 1209
        if (spool) {
          {
#line 1210
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"%s\n",
                  line);
          }
        } else {
          {
#line 1212
          sendcommand(sockfd, (char const   *)(line), (char *)((void *)0));
          }
        }
      }
      {
#line 1216
      tmp___87 = stat((char const   */* __restrict  */)(ziptmp), (struct stat */* __restrict  */)(& finfo));
      }
#line 1216
      if (tmp___87 == 0) {
        {
#line 1217
        size = finfo.st_size;
#line 1218
        snprintf((char */* __restrict  */)(sizes), sizeof(sizes) - 1UL, (char const   */* __restrict  */)"%lld %lld",
                 size, orgsize);
#line 1219
        snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"SIZE %s",
                 sizes);
#line 1220
        sendcommand(sockfd, (char const   *)(line), (char *)((void *)0));
        }
      } else {
        {
#line 1222
        tmp___86 = stat((char const   */* __restrict  */)(sdfn), (struct stat */* __restrict  */)(& finfo));
        }
#line 1222
        if (tmp___86 < 0) {
#line 1222
          goto _L___6;
        } else
#line 1222
        if (size != finfo.st_size) {
          _L___6: /* CIL Label */ 
          {
#line 1223
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"spool file #%s has wrong size count - ignored",
                   *(argv + fn));
#line 1225
          tmp___85 = __errno_location();
#line 1225
          *tmp___85 = 0;
#line 1226
          message(prg, (char )'E', (char const   *)(tmp));
          }
#line 1227
          if (spool) {
            {
#line 1227
            fclose(oshf);
            }
          }
#line 1228
          goto __Cont;
        }
      }
#line 1233
      if (spool) {
        {
#line 1234
        fclose(oshf);
#line 1235
        strcpy((char */* __restrict  */)(osdfn), (char const   */* __restrict  */)(oshfn));
#line 1236
        tmp___88 = strlen((char const   *)(osdfn));
#line 1236
        osdfn[tmp___88 - 1UL] = (char )'d';
#line 1237
        tmp___91 = fcopy((char const   *)(sdfn), (char const   *)(osdfn), (mode_t )384);
        }
#line 1237
        if (tmp___91 < 0) {
          {
#line 1238
          unlink((char const   *)(oshfn));
#line 1239
          unlink((char const   *)(osdfn));
          }
        } else {
          {
#line 1241
          tmp___89 = strcmp((char const   *)(bouncearg), "k=n");
          }
#line 1241
          if (tmp___89 == 0) {
            {
#line 1242
            unlink((char const   *)(shfn));
#line 1243
            unlink((char const   *)(sdfn));
            }
          }
          {
#line 1245
          strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(oshfn));
#line 1246
          tmp___90 = strlen((char const   *)(oshfn));
#line 1246
          oshfn[tmp___90 - 1UL] = (char )'h';
#line 1247
          rename((char const   *)(tmp), (char const   *)(oshfn));
#line 1248
          spooled_info((char const   *)(iso_name), (char const   *)(osdfn), do_compress);
          }
        }
      } else {
        {
#line 1253
        tmp___92 = stat((char const   */* __restrict  */)(ziptmp), (struct stat */* __restrict  */)(& finfo));
        }
#line 1253
        if (tmp___92 == 0) {
          {
#line 1254
          status = send_data(sockfd, size, (char const   *)(ziptmp), (char const   *)(tinfo),
                             (char const   *)(file), "", mtp, & attime);
#line 1255
          unlink((char const   *)(ziptmp));
          }
        } else {
          {
#line 1257
          status = send_data(sockfd, size, (char const   *)(sdfn), (char const   *)(tinfo),
                             (char const   *)(file), "", mtp, & attime);
          }
        }
#line 1260
        if (attime) {
#line 1261
          tfn ++;
#line 1262
          tsize += (float )size;
#line 1263
          tttime += attime;
        }
#line 1266
        if (status == 0) {
          {
#line 1269
          outlog(recipient, host, file, sizes);
#line 1270
          notespeed((char const   *)(host), (unsigned long )size, attime);
#line 1273
          tmp___93 = strcmp((char const   *)(bouncearg), "k=n");
          }
#line 1273
          if (tmp___93 == 0) {
            {
#line 1274
            unlink((char const   *)(shfn));
#line 1275
            unlink((char const   *)(sdfn));
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1053
      fn ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1282
  if (tar) {
#line 1282
    goto _L___11;
  } else
#line 1282
  if (zip) {
    _L___11: /* CIL Label */ 
    {
#line 1285
    iso2utf7(utf_name, archive, 0);
#line 1288
    tmp___94 = malloc(sizeof(char *) * (unsigned long )((argc - optind) + 4));
#line 1288
    sad = (char **)tmp___94;
    }
#line 1289
    if (! sad) {
      {
#line 1289
      message(prg, (char )'F', "out of memory");
      }
    }
#line 1290
    *(sad + 0) = tar_bin;
#line 1291
    *(sad + 1) = (char *)"cf";
#line 1292
    *(sad + 2) = tartmp;
#line 1293
    n = 3;
    {
#line 1293
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1293
      if (! (n - 2 < argc - optind)) {
#line 1293
        goto while_break___8;
      }
#line 1294
      *(sad + n) = *(argv + ((n - 3) + optind));
#line 1293
      n ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1296
    *(sad + n) = (char *)((void *)0);
#line 1298
    if (verbose) {
#line 1299
      *(sad + 1) = (char *)"cvf";
    } else {
#line 1301
      if (! quiet) {
        {
#line 1301
        printf((char const   */* __restrict  */)"making archive...\r");
        }
      }
      {
#line 1302
      fflush(stdout);
      }
    }
#line 1304
    if (verbose) {
      {
#line 1305
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s",
               cmd);
#line 1306
      message(prg, (char )'I', (char const   *)(tmp));
      }
    }
    {
#line 1310
    tmp___96 = spawn(sad, (char const   *)((void *)0), (mode_t )0);
    }
#line 1310
    if (tmp___96 < 0) {
      {
#line 1311
      message(prg, (char )'E', "no complete archive file");
      }
#line 1312
      if (! quiet) {
        {
#line 1313
        printf((char const   */* __restrict  */)"Continue? ");
#line 1314
        sfgetl(tmp, (int )sizeof(tmp), stdin);
#line 1315
        tmp___95 = toupper((int )tmp[0]);
        }
#line 1315
        if (tmp___95 != 89) {
          {
#line 1315
          exit(1);
          }
        }
      }
    }
    {
#line 1320
    strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(tartmp));
#line 1321
    tmp___97 = stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
    }
#line 1321
    if (tmp___97 < 0) {
      {
#line 1321
      message(prg, (char )'F', "cannot access tmp file");
      }
    }
#line 1322
    orgsize = finfo.st_size;
#line 1323
    size = orgsize;
#line 1326
    if (*compress) {
#line 1326
      do_compress = 1;
    }
#line 1329
    if (do_compress) {
#line 1332
      if (! quiet) {
        {
#line 1332
        printf((char const   */* __restrict  */)"compressing...       \r");
        }
      }
      {
#line 1333
      fflush(stdout);
#line 1334
      snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s < %s > %s",
               zprg, tartmp, ziptmp);
      }
#line 1335
      if (verbose) {
        {
#line 1336
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s",
                 cmd);
#line 1337
        message(prg, (char )'I', (char const   *)(tmp));
        }
      }
      {
#line 1339
      tmp___98 = vsystem((char const   *)(cmd));
      }
#line 1339
      if (tmp___98) {
        {
#line 1339
        message(prg, (char )'F', "cannot compress archive file");
        }
      }
      {
#line 1341
      strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(ziptmp));
      }
    }
#line 1345
    if (pgpcrypt) {
      {
#line 1345
      pgp_encrypt(pgpcrypt, pgprid, file);
      }
    }
#line 1348
    if (pgpsign[0]) {
      {
#line 1348
      pgp_sign((char const   *)(pgpsign), (char const   *)(file), sockfd);
      }
    }
    {
#line 1351
    tmp___99 = stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
    }
#line 1351
    if (tmp___99 < 0) {
      {
#line 1351
      message(prg, (char )'F', "cannot access tmp file");
      }
    }
    {
#line 1352
    size = finfo.st_size;
#line 1353
    snprintf((char */* __restrict  */)(sizes), sizeof(sizes) - 1UL, (char const   */* __restrict  */)"%lld %lld",
             size, orgsize);
    }
#line 1356
    if (spool) {
#line 1359
      if (overwrite) {
        {
#line 1359
        hls = scanoutspool(pw_name);
        }
#line 1359
        if (hls) {
          {
#line 1362
          tmp___100 = strchr((char const   *)*(argv + (argc - 1)), '*');
          }
#line 1362
          if (tmp___100) {
            {
#line 1363
            snprintf((char */* __restrict  */)(to), sizeof(to) - 1UL, (char const   */* __restrict  */)"%s",
                     *(argv + (argc - 1)));
            }
          } else {
            {
#line 1365
            snprintf((char */* __restrict  */)(to), sizeof(to) - 1UL, (char const   */* __restrict  */)"%s@%s",
                     recipient, host);
            }
          }
#line 1368
          hlp = hls;
          {
#line 1368
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1368
            if (! hlp) {
#line 1368
              goto while_break___9;
            }
#line 1369
            oflp = hlp->flist;
            {
#line 1369
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 1369
              if (! oflp) {
#line 1369
                goto while_break___10;
              }
              {
#line 1372
              tmp___103 = simplematch(oflp->fname, utf_name, 0);
              }
#line 1372
              if (tmp___103) {
                {
#line 1375
                snprintf((char */* __restrict  */)(rto), sizeof(rto) - 1UL, (char const   */* __restrict  */)"%s@%s",
                         oflp->to, hlp->host);
#line 1376
                tmp___102 = simplematch(rto, to, 0);
                }
#line 1376
                if (tmp___102) {
                  {
#line 1377
                  unlink((char const   *)oflp->oshfn);
#line 1378
                  tmp___101 = strlen((char const   *)oflp->oshfn);
#line 1378
                  *(oflp->oshfn + (tmp___101 - 1UL)) = (char )'d';
#line 1379
                  unlink((char const   *)oflp->oshfn);
                  }
                }
              }
#line 1369
              oflp = oflp->next;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 1368
            hlp = hlp->next;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
      {
#line 1388
      oshf = outspool((char const   *)(pw_name), (char const   *)(outgoing), oshfn);
      }
#line 1388
      if ((unsigned long )oshf == (unsigned long )((void *)0)) {
        {
#line 1389
        message(prg, (char )'F', "cannot create outgoing spool file");
        }
      }
      {
#line 1392
      fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"FROM\t%s\n",
              user);
#line 1393
      fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TO\t%s@%s\n",
              recipient, host);
#line 1394
      fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"FILE\t%s\n",
              utf_name);
      }
#line 1395
      if (*compress) {
        {
#line 1396
        tmp___104 = strcmp((char const   *)compress, "GZIP");
        }
#line 1396
        if (tmp___104 == 0) {
          {
#line 1397
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY COMPRESSED\n");
          }
        } else {
          {
#line 1399
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY COMPRESSED=%s\n",
                  compress);
          }
        }
      } else
#line 1400
      if (pgpcrypt) {
        {
#line 1401
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY CRYPTED\n");
        }
      } else {
        {
#line 1403
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY\n");
        }
      }
      {
#line 1404
      fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"SIZE\t%s\n",
              sizes);
#line 1405
      fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"ATTR\tTAR\n");
      }
    } else {
      {
#line 1409
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"FILE %s",
               utf_name);
#line 1411
      client = 0;
#line 1412
      sendcommand(sockfd, (char const   *)(tmp), reply___1);
#line 1413
      client = 1;
#line 1416
      tmp___105 = str_beq((char const   *)(reply___1), "429 ");
      }
#line 1416
      if (tmp___105) {
        {
#line 1417
        sockfd = saft_connect("file", recipient, user, host, redirect);
#line 1418
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"FILE %s",
                 utf_name);
#line 1419
        sendcommand(sockfd, (char const   *)(tmp), reply___1);
        }
      }
#line 1422
      if (! test) {
        {
#line 1422
        tmp___106 = str_beq((char const   *)(reply___1), "200 ");
        }
#line 1422
        if (! tmp___106) {
#line 1422
          if (quiet < 2) {
            {
#line 1423
            message(prg, (char )'W', "remote site does not support file names");
            }
          }
        }
      }
#line 1425
      if (overwrite) {
        {
#line 1426
        tmp___107 = str_beq((char const   *)(reply___1), "200 ");
        }
#line 1426
        if (tmp___107) {
          {
#line 1426
          sendcommand(sockfd, "DEL", reply___1);
          }
        }
        {
#line 1427
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"FILE %s",
                 utf_name);
#line 1428
        sendcommand(sockfd, (char const   *)(tmp), reply___1);
        }
      }
#line 1430
      if (*compress) {
        {
#line 1431
        tmp___108 = strcmp((char const   *)compress, "GZIP");
        }
#line 1431
        if (tmp___108 == 0) {
          {
#line 1432
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"TYPE BINARY COMPRESSED");
          }
        } else {
          {
#line 1434
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"TYPE BINARY COMPRESSED=%s",
                   compress);
          }
        }
        {
#line 1435
        sendcommand(sockfd, (char const   *)(tmp), reply___1);
        }
#line 1436
        if (! test) {
          {
#line 1436
          tmp___110 = str_beq((char const   *)(reply___1), "200 ");
          }
#line 1436
          if (! tmp___110) {
#line 1436
            if (quiet < 2) {
              {
#line 1437
              tmp___109 = __errno_location();
#line 1437
              *tmp___109 = 0;
#line 1438
              message(prg, (char )'F', "remote site does not support compressed files");
              }
            }
          }
        }
      } else
#line 1440
      if (pgpcrypt) {
        {
#line 1441
        sendcommand(sockfd, "TYPE BINARY CRYPTED", reply___1);
        }
#line 1442
        if (! test) {
          {
#line 1442
          tmp___112 = str_beq((char const   *)(reply___1), "200 ");
          }
#line 1442
          if (! tmp___112) {
#line 1442
            if (quiet < 2) {
              {
#line 1443
              tmp___111 = __errno_location();
#line 1443
              *tmp___111 = 0;
#line 1444
              message(prg, (char )'F', "remote site does not support encrypted files");
              }
            }
          }
        }
      } else {
        {
#line 1447
        sendcommand(sockfd, "TYPE BINARY", reply___1);
        }
#line 1448
        if (! test) {
          {
#line 1448
          tmp___113 = str_beq((char const   *)(reply___1), "200 ");
          }
#line 1448
          if (! tmp___113) {
#line 1448
            if (quiet < 2) {
              {
#line 1449
              message(prg, (char )'W', "remote site does not support binary files");
              }
            }
          }
        }
      }
      {
#line 1451
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"SIZE %s",
               sizes);
#line 1452
      sendheader(sockfd, tmp);
#line 1453
      sendcommand(sockfd, "ATTR TAR", reply___1);
      }
#line 1454
      if (! test) {
        {
#line 1454
        tmp___115 = str_beq((char const   *)(reply___1), "200 ");
        }
#line 1454
        if (! tmp___115) {
#line 1454
          if (quiet < 2) {
            {
#line 1455
            tmp___114 = __errno_location();
#line 1455
            *tmp___114 = 0;
#line 1456
            message(prg, (char )'F', "remote site does not support archive file type");
            }
          }
        }
      }
    }
#line 1461
    if (comment[0]) {
#line 1461
      goto _L___7;
    } else
#line 1461
    if (redirect[0]) {
      _L___7: /* CIL Label */ 
#line 1462
      line[0] = (char)0;
#line 1463
      if (comment[0]) {
        {
#line 1463
        strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(comment));
        }
      }
#line 1464
      if (redirect[0]) {
#line 1465
        if (line[0]) {
          {
#line 1466
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s\r\n%s",
                   line, redirect);
#line 1467
          strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(tmp));
          }
        } else {
          {
#line 1469
          strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(redirect));
          }
        }
      }
      {
#line 1471
      iso2utf(tmp, line);
      }
#line 1472
      if (spool) {
        {
#line 1473
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"COMMENT\t%s\n",
                tmp);
        }
      } else {
        {
#line 1475
        snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"COMMENT %s",
                 tmp);
#line 1476
        sendcommand(sockfd, (char const   *)(line), (char *)((void *)0));
        }
      }
    }
#line 1481
    if (spool) {
      {
#line 1482
      fclose(oshf);
#line 1483
      strcpy((char */* __restrict  */)(osdfn), (char const   */* __restrict  */)(oshfn));
#line 1484
      tmp___116 = strlen((char const   *)(osdfn));
#line 1484
      osdfn[tmp___116 - 1UL] = (char )'d';
#line 1485
      tmp___118 = fcopy((char const   *)(file), (char const   *)(osdfn), (mode_t )384);
      }
#line 1485
      if (tmp___118 < 0) {
        {
#line 1486
        unlink((char const   *)(oshfn));
#line 1487
        unlink((char const   *)(osdfn));
        }
      } else {
        {
#line 1489
        strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(oshfn));
#line 1490
        tmp___117 = strlen((char const   *)(oshfn));
#line 1490
        oshfn[tmp___117 - 1UL] = (char )'h';
#line 1491
        rename((char const   *)(tmp), (char const   *)(oshfn));
#line 1492
        spooled_info((char const   *)(archive), (char const   *)(osdfn), do_compress);
        }
      }
    } else {
      {
#line 1495
      strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"archive");
      }
#line 1496
      if (*compress) {
        {
#line 1496
        strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)" compressed");
        }
      }
#line 1497
      if (pgpcrypt) {
        {
#line 1497
        strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)" crypted");
        }
      }
      {
#line 1498
      tmp___119 = send_data(sockfd, size, (char const   *)(file), "", (char const   *)(archive),
                            (char const   *)(tmp), mtp, & attime);
      }
#line 1498
      if (tmp___119 == 0) {
#line 1501
        if (attime) {
#line 1502
          tfn ++;
#line 1503
          tsize += (float )size;
#line 1504
          tttime += attime;
        }
        {
#line 1508
        outlog(recipient, host, utf_name, sizes);
#line 1509
        notespeed((char const   *)(host), (unsigned long )size, attime);
        }
      }
    }
  } else {
#line 1517
    fn = optind;
    {
#line 1517
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1517
      if (! (fn < argc - 1)) {
#line 1517
        goto while_break___11;
      }
#line 1518
      if (info) {
        {
#line 1518
        snprintf((char */* __restrict  */)(tinfo), sizeof(tinfo) - 1UL, (char const   */* __restrict  */)"#%d/%d: ",
                 (fn - optind) + 1, (argc - optind) - 1);
        }
      }
#line 1521
      if (stdinf) {
        {
#line 1524
        strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(stdintmp));
#line 1525
        strcpy((char */* __restrict  */)(iso_name), (char const   */* __restrict  */)*(argv + fn));
#line 1526
        stdinf = 0;
        }
      } else {
        {
#line 1530
        strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)*(argv + fn));
#line 1533
        fnp = strrchr((char const   *)(file), '/');
        }
#line 1534
        if (! fnp) {
#line 1534
          fnp = file;
        } else {
#line 1534
          fnp ++;
        }
        {
#line 1537
        strcpy((char */* __restrict  */)(iso_name), (char const   */* __restrict  */)fnp);
        }
      }
      {
#line 1542
      iso2utf7(utf_name, iso_name, 0);
      }
#line 1545
      if (spool) {
#line 1548
        if (del) {
#line 1548
          goto _L___8;
        } else
#line 1548
        if (overwrite) {
          _L___8: /* CIL Label */ 
          {
#line 1548
          hls = scanoutspool(pw_name);
          }
#line 1548
          if (hls) {
            {
#line 1551
            tmp___120 = strchr((char const   *)*(argv + (argc - 1)), '*');
            }
#line 1551
            if (tmp___120) {
              {
#line 1552
              snprintf((char */* __restrict  */)(to), sizeof(to) - 1UL, (char const   */* __restrict  */)"%s",
                       *(argv + (argc - 1)));
              }
            } else {
              {
#line 1554
              snprintf((char */* __restrict  */)(to), sizeof(to) - 1UL, (char const   */* __restrict  */)"%s@%s",
                       recipient, host);
              }
            }
#line 1557
            hlp = hls;
            {
#line 1557
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 1557
              if (! hlp) {
#line 1557
                goto while_break___12;
              }
#line 1558
              oflp = hlp->flist;
              {
#line 1558
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 1558
                if (! oflp) {
#line 1558
                  goto while_break___13;
                }
                {
#line 1561
                tmp___123 = simplematch(oflp->fname, utf_name, 0);
                }
#line 1561
                if (tmp___123) {
                  {
#line 1564
                  snprintf((char */* __restrict  */)(rto), sizeof(rto) - 1UL, (char const   */* __restrict  */)"%s@%s",
                           oflp->to, hlp->host);
#line 1565
                  tmp___122 = simplematch(rto, to, 0);
                  }
#line 1565
                  if (tmp___122) {
                    {
#line 1566
                    unlink((char const   *)oflp->oshfn);
#line 1567
                    tmp___121 = strlen((char const   *)oflp->oshfn);
#line 1567
                    *(oflp->oshfn + (tmp___121 - 1UL)) = (char )'d';
#line 1568
                    unlink((char const   *)oflp->oshfn);
                    }
#line 1569
                    if (del) {
                      {
#line 1570
                      del = 2;
#line 1571
                      utf2iso(0, (char *)((void *)0), file, (char *)((void *)0), oflp->fname);
#line 1572
                      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL,
                               (char const   */* __restrict  */)"deleted from outgoing spool: \'%s\' for %s ",
                               file, rto);
                      }
#line 1575
                      if (quiet < 2) {
                        {
#line 1575
                        message(prg, (char )'I', (char const   *)(tmp));
                        }
                      }
                    }
                  }
                }
#line 1558
                oflp = oflp->next;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 1557
              hlp = hlp->next;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
#line 1584
        if (del) {
#line 1584
          goto __Cont___0;
        }
        {
#line 1587
        oshf = outspool((char const   *)(pw_name), (char const   *)(outgoing), oshfn);
        }
#line 1587
        if ((unsigned long )oshf == (unsigned long )((void *)0)) {
          {
#line 1588
          message(prg, (char )'F', "cannot create outgoing spool file");
          }
        }
        {
#line 1590
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"FROM\t%s\n",
                user);
#line 1591
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TO\t%s@%s\n",
                recipient, host);
#line 1592
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"FILE\t%s\n",
                utf_name);
        }
      } else {
        {
#line 1598
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"FILE %s",
                 utf_name);
#line 1599
        sendcommand(sockfd, (char const   *)(tmp), reply___1);
        }
#line 1600
        if (! test) {
          {
#line 1600
          tmp___124 = str_beq((char const   *)(reply___1), "200 ");
          }
#line 1600
          if (! tmp___124) {
#line 1600
            if (quiet < 2) {
              {
#line 1601
              message(prg, (char )'W', "remote site does not support file names");
              }
            }
          }
        }
#line 1604
        if (overwrite) {
          {
#line 1604
          sendcommand(sockfd, "DEL", (char *)((void *)0));
          }
        }
#line 1605
        if (del) {
          {
#line 1606
          tmp___125 = sendheader(sockfd, (char *)"DEL");
          }
#line 1606
          if (tmp___125) {
#line 1607
            if (quiet < 2) {
              {
#line 1607
              message(prg, (char )'W', "remote site cannot delete files");
              }
            }
          } else {
            {
#line 1609
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"\'%s\' deleted",
                     iso_name);
            }
#line 1610
            if (quiet < 2) {
              {
#line 1610
              message(prg, (char )'I', (char const   *)(tmp));
              }
            }
          }
#line 1612
          goto __Cont___0;
        }
      }
      {
#line 1618
      tmp___126 = stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
      }
#line 1618
      if (tmp___126 < 0) {
        {
#line 1619
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot access \'%s\'",
                 file);
#line 1620
        message(prg, (char )'E', (char const   *)(tmp));
        }
#line 1621
        if (spool) {
          {
#line 1622
          fclose(oshf);
#line 1623
          unlink((char const   *)(oshfn));
          }
        }
#line 1625
        goto __Cont___0;
      }
#line 1629
      if (! ((finfo.st_mode & 61440U) == 32768U)) {
        {
#line 1630
        tmp___127 = __errno_location();
#line 1630
        *tmp___127 = 0;
#line 1631
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is not a regular file, skipping",
                 file);
#line 1632
        message(prg, (char )'E', (char const   *)(tmp));
        }
#line 1633
        if (spool) {
          {
#line 1634
          fclose(oshf);
#line 1635
          unlink((char const   *)(oshfn));
          }
        }
#line 1637
        goto __Cont___0;
      }
#line 1641
      if (finfo.st_mode & 64U) {
#line 1641
        exe = 1;
      } else {
#line 1641
        exe = 0;
      }
      {
#line 1644
      mode = guess_ftype((char const   *)(file), ftype);
      }
#line 1645
      if (! guess) {
#line 1645
        mode = (char)0;
      }
      {
#line 1648
      tmp___128 = gmtime((time_t const   *)(& finfo.st_mtim.tv_sec));
#line 1648
      strftime((char */* __restrict  */)(date), (size_t )20, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
               (struct tm  const  */* __restrict  */)tmp___128);
      }
#line 1656
      if (text) {
#line 1656
        goto _L___9;
      } else
#line 1656
      if (source) {
#line 1656
        goto _L___9;
      } else
#line 1656
      if ((int )mode == 116) {
#line 1656
        goto _L___9;
      } else
#line 1656
      if ((int )mode == 115) {
        _L___9: /* CIL Label */ 
        {
#line 1659
        inf = rfopen((char const   *)(file), "r");
#line 1660
        outf = rfopen((char const   *)(texttmp), "w");
        }
#line 1661
        if (! inf) {
          {
#line 1662
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open \'%s\'",
                   file);
#line 1663
          message(prg, (char )'E', (char const   *)(tmp));
          }
#line 1664
          if (spool) {
            {
#line 1665
            fclose(oshf);
#line 1666
            unlink((char const   *)(oshfn));
            }
          }
#line 1668
          goto __Cont___0;
        }
#line 1670
        if (! outf) {
          {
#line 1670
          message(prg, (char )'F', "cannot open tmp-file");
          }
        }
        {
#line 1673
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 1674
          ch = fgetc(inf);
          }
#line 1675
          if (ch != -1) {
#line 1676
            if (ch == 10) {
              {
#line 1677
              fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"\r\n");
              }
            } else {
              {
#line 1679
              fputc(ch, outf);
              }
            }
          }
          {
#line 1673
          tmp___129 = feof(inf);
          }
#line 1673
          if (tmp___129) {
#line 1673
            goto while_break___14;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 1683
        fclose(inf);
#line 1684
        fclose(outf);
#line 1685
        strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(texttmp));
        }
      }
      {
#line 1689
      stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
#line 1690
      orgsize = finfo.st_size;
      }
#line 1693
      if (*compress) {
#line 1693
        do_compress = 1;
      }
#line 1696
      if (do_compress) {
#line 1696
        if (! force_compress[0]) {
#line 1699
          if (finfo.st_size < 1024L) {
#line 1699
            do_compress = 0;
          }
#line 1703
          n = 0;
          {
#line 1703
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 1703
            if (do_compress) {
#line 1703
              if (! *(cft[n])) {
#line 1703
                goto while_break___15;
              }
            } else {
#line 1703
              goto while_break___15;
            }
            {
#line 1706
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"*%s*",
                     cft[n]);
#line 1707
            tmp___130 = simplematch(ftype, tmp, 1);
            }
#line 1707
            if (tmp___130) {
#line 1707
              do_compress = 0;
            }
#line 1703
            n ++;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      }
#line 1713
      if (do_compress) {
#line 1716
        if (! quiet) {
          {
#line 1716
          printf((char const   */* __restrict  */)"compressing...       \r");
          }
        }
        {
#line 1717
        fflush(stdout);
#line 1718
        snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s < \'%s\' > %s",
                 zprg, file, ziptmp);
        }
#line 1719
        if (verbose) {
          {
#line 1720
          tmp___131 = strchr((char const   *)(cmd), ';');
#line 1720
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s",
                   tmp___131 + 1);
#line 1721
          message(prg, (char )'I', (char const   *)(tmp));
          }
        }
        {
#line 1723
        tmp___132 = vsystem((char const   *)(cmd));
        }
#line 1723
        if (tmp___132) {
          {
#line 1724
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot compress %s",
                   file);
#line 1725
          message(prg, (char )'E', (char const   *)(tmp));
          }
#line 1726
          if (spool) {
            {
#line 1727
            fclose(oshf);
#line 1728
            unlink((char const   *)(oshfn));
            }
          }
#line 1730
          goto __Cont___0;
        }
        {
#line 1732
        strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(ziptmp));
        }
      } else {
#line 1735
        size = orgsize;
      }
#line 1738
      if (pgpcrypt) {
        {
#line 1738
        pgp_encrypt(pgpcrypt, pgprid, file);
        }
      }
#line 1741
      if (pgpsign[0]) {
        {
#line 1741
        pgp_sign((char const   *)(pgpsign), (char const   *)(file), sockfd);
        }
      }
      {
#line 1744
      tmp___133 = stat((char const   */* __restrict  */)(file), (struct stat */* __restrict  */)(& finfo));
      }
#line 1744
      if (tmp___133 < 0) {
        {
#line 1744
        message(prg, (char )'F', "cannot access tmp file");
        }
      }
      {
#line 1745
      size = finfo.st_size;
#line 1746
      snprintf((char */* __restrict  */)(sizes), sizeof(sizes) - 1UL, (char const   */* __restrict  */)"%lld %lld",
               size, orgsize);
#line 1753
      type = (char *)"BINARY";
      }
#line 1754
      if (guess) {
#line 1755
        if ((int )mode == 115) {
#line 1755
          type = (char *)"SOURCE";
        }
#line 1756
        if ((int )mode == 116) {
#line 1756
          type = (char *)"TEXT=ISO_8859-1:1987";
        }
      } else
#line 1758
      if (mime) {
#line 1758
        type = (char *)"MIME";
      } else
#line 1759
      if (source) {
#line 1759
        type = (char *)"SOURCE";
      } else
#line 1760
      if (text) {
#line 1760
        type = (char *)"TEXT=ISO_8859-1:1987";
      }
#line 1763
      if (spool) {
#line 1765
        if (do_compress) {
          {
#line 1766
          tmp___134 = strcmp((char const   *)compress, "GZIP");
          }
#line 1766
          if (tmp___134 == 0) {
            {
#line 1767
            fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY COMPRESSED\n");
            }
          } else {
            {
#line 1769
            fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\tBINARY COMPRESSED=%s\n",
                    compress);
            }
          }
        } else
#line 1770
        if (pgpcrypt) {
          {
#line 1771
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\t%s CRYPTED\n",
                  type);
          }
        } else {
          {
#line 1773
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"TYPE\t%s\n",
                  type);
          }
        }
        {
#line 1774
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"SIZE\t%s\n",
                sizes);
#line 1775
        fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"DATE\t%s\n",
                date);
        }
#line 1776
        if (exe) {
          {
#line 1777
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"ATTR\tEXE\n");
          }
        } else {
          {
#line 1779
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"ATTR\tNONE\n");
          }
        }
      } else {
#line 1782
        if (do_compress) {
          {
#line 1783
          tmp___135 = strcmp((char const   *)compress, "GZIP");
          }
#line 1783
          if (tmp___135 == 0) {
            {
#line 1784
            snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"TYPE %s COMPRESSED",
                     type);
            }
          } else {
            {
#line 1786
            snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"TYPE %s COMPRESSED=%s",
                     type, compress);
            }
          }
        } else
#line 1787
        if (pgpcrypt) {
          {
#line 1788
          snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"TYPE %s CRYPTED",
                   type);
          }
        } else {
          {
#line 1790
          snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"TYPE %s",
                   type);
          }
        }
        {
#line 1791
        sendcommand(sockfd, (char const   *)(line), reply___1);
        }
#line 1792
        if (! test) {
          {
#line 1792
          tmp___137 = str_beq((char const   *)(reply___1), "200 ");
          }
#line 1792
          if (! tmp___137) {
#line 1792
            if (quiet < 2) {
              {
#line 1793
              tmp___136 = __errno_location();
#line 1793
              *tmp___136 = 0;
#line 1794
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"remote site does not support file of %s",
                       line);
#line 1795
              message(prg, (char )'F', (char const   *)(tmp));
              }
            }
          }
        }
        {
#line 1797
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"SIZE %s",
                 sizes);
#line 1798
        sendheader(sockfd, tmp);
#line 1799
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"DATE %s",
                 date);
#line 1800
        tmp___138 = sendheader(sockfd, tmp);
        }
#line 1800
        if (tmp___138) {
#line 1800
          if (quiet < 2) {
            {
#line 1801
            message(prg, (char )'W', "remote site does not support dates");
            }
          }
        }
#line 1802
        if (exe) {
          {
#line 1803
          sendcommand(sockfd, "ATTR EXE", (char *)((void *)0));
          }
        } else {
          {
#line 1805
          sendcommand(sockfd, "ATTR NONE", (char *)((void *)0));
          }
        }
      }
#line 1809
      if (comment[0]) {
#line 1809
        goto _L___10;
      } else
#line 1809
      if (redirect[0]) {
        _L___10: /* CIL Label */ 
#line 1810
        line[0] = (char)0;
#line 1811
        if (comment[0]) {
          {
#line 1811
          strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(comment));
          }
        }
#line 1812
        if (redirect[0]) {
#line 1813
          if (line[0]) {
            {
#line 1814
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s\r\n%s",
                     line, redirect);
#line 1815
            strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(tmp));
            }
          } else {
            {
#line 1817
            strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)(redirect));
            }
          }
        }
        {
#line 1819
        iso2utf(tmp, line);
        }
#line 1820
        if (spool) {
          {
#line 1821
          fprintf((FILE */* __restrict  */)oshf, (char const   */* __restrict  */)"COMMENT\t%s\n",
                  tmp);
          }
        } else {
          {
#line 1823
          snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"COMMENT %s",
                   tmp);
#line 1824
          sendcommand(sockfd, (char const   *)(line), (char *)((void *)0));
          }
        }
      }
#line 1829
      if (spool) {
        {
#line 1830
        fclose(oshf);
#line 1831
        strcpy((char */* __restrict  */)(osdfn), (char const   */* __restrict  */)(oshfn));
#line 1832
        tmp___139 = strlen((char const   *)(osdfn));
#line 1832
        osdfn[tmp___139 - 1UL] = (char )'d';
#line 1833
        tmp___141 = fcopy((char const   *)(file), (char const   *)(osdfn), (mode_t )384);
        }
#line 1833
        if (tmp___141 < 0) {
          {
#line 1834
          unlink((char const   *)(oshfn));
#line 1835
          unlink((char const   *)(osdfn));
          }
        } else {
          {
#line 1837
          strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(oshfn));
#line 1838
          tmp___140 = strlen((char const   *)(oshfn));
#line 1838
          oshfn[tmp___140 - 1UL] = (char )'h';
#line 1839
          rename((char const   *)(tmp), (char const   *)(oshfn));
#line 1840
          spooled_info((char const   *)(iso_name), (char const   *)(osdfn), do_compress);
          }
        }
      } else {
        {
#line 1843
        strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)type);
#line 1844
        cp = strchr((char const   *)(tmp), '=');
        }
#line 1844
        if (cp) {
#line 1844
          *cp = (char)0;
        }
        {
#line 1845
        str_tolower(tmp);
        }
#line 1846
        if (do_compress) {
          {
#line 1846
          strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)" compressed");
          }
        }
#line 1847
        if (pgpcrypt) {
          {
#line 1847
          strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)" crypted");
          }
        }
        {
#line 1848
        tmp___142 = send_data(sockfd, size, (char const   *)(file), (char const   *)(tinfo),
                              (char const   *)(iso_name), (char const   *)(tmp), mtp,
                              & attime);
        }
#line 1848
        if (tmp___142 == 0) {
#line 1851
          if (attime) {
#line 1852
            tfn ++;
#line 1853
            tsize += (float )size;
#line 1854
            tttime += attime;
          }
          {
#line 1858
          outlog(recipient, host, utf_name, sizes);
#line 1859
          notespeed((char const   *)(host), (unsigned long )size, attime);
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1517
      fn ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 1867
  if (spool) {
#line 1868
    if (del) {
#line 1869
      if (del < 2) {
#line 1869
        if (quiet < 2) {
          {
#line 1870
          message(prg, (char )'W', "no matching files found in outgoing spool");
          }
        }
      }
    } else
#line 1872
    if (spooling == 2) {
      {
#line 1872
      start_spooldaemon(localhost);
      }
    }
  } else {
    {
#line 1875
    sendcommand(sockfd, "QUIT", (char *)((void *)0));
#line 1876
    close(sockfd);
    }
  }
#line 1880
  if (tsize) {
#line 1880
    if (info) {
#line 1880
      if (tfn > 1) {
#line 1880
        if (quiet < 2) {
#line 1881
          thruput = (tsize * (float )1000) / tttime;
#line 1882
          if (tsize / (float )1024 > (float )9999) {
            {
#line 1883
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%d files sent with %.1f MB",
                     tfn, (double )((tsize / (float )1024) / (float )1024));
            }
          } else
#line 1884
          if (tsize > (float )9999) {
            {
#line 1885
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%d files sent with %.1f kB",
                     tfn, (double )(tsize / (float )1024));
            }
          } else {
            {
#line 1887
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%d files sent with %d byte",
                     tfn, (int )tsize);
            }
          }
#line 1888
          if (thruput > (float )9999) {
            {
#line 1889
            snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"%s at %.1f kB/s",
                     tmp, (double )(thruput / (float )1024));
            }
          } else {
            {
#line 1891
            snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"%s at %d byte/s",
                     tmp, (int )thruput);
            }
          }
          {
#line 1892
          message((char *)"", (char )'I', (char const   *)(line));
          }
        }
      }
    }
  }
  {
#line 1897
  cleanup();
#line 1898
  exit(0);
  }
}
}
#line 1907 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void cleanexit(void) 
{ 


  {
  {
#line 1909
  printf((char const   */* __restrict  */)"\r\n");
#line 1910
  cleanup();
#line 1911
  exit(0);
  }
}
}
#line 1919 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void cleanup(void) 
{ 
  int sockfd ;
  char line[4096] ;
  char reply___1[4096] ;
  char server[256] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1928
  signal(15, (void (*)(int  ))1);
#line 1929
  signal(6, (void (*)(int  ))1);
#line 1930
  signal(3, (void (*)(int  ))1);
#line 1931
  signal(1, (void (*)(int  ))1);
#line 1932
  signal(2, (void (*)(int  ))1);
  }
#line 1934
  if (verbose < 2) {
#line 1934
    verbose = 0;
  }
  {
#line 1935
  reply___1[0] = (char)0;
#line 1938
  rmtmpdir(tmpdir);
  }
#line 1940
  if (outlogging) {
    {
#line 1943
    tmp___5 = access((char const   *)(outlogtmp), 4);
    }
#line 1943
    if (tmp___5 == 0) {
#line 1943
      if (! test) {
        {
#line 1943
        sockfd = open_connection((char *)"127.0.0.1", 487);
        }
#line 1943
        if (sockfd >= 0) {
          {
#line 1951
          sock_getline(sockfd, reply___1);
#line 1952
          tmp___3 = str_beq((char const   *)(reply___1), "220 ");
          }
#line 1952
          if (tmp___3) {
            {
#line 1952
            tmp___4 = strstr((char const   *)(reply___1), "SAFT");
            }
#line 1952
            if (tmp___4) {
              {
#line 1955
              snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"LOG %s %s",
                       pw_name, outlogtmp);
#line 1956
              sock_putline(sockfd, (char const   *)(line));
#line 1957
              sock_getline(sockfd, reply___1);
#line 1958
              str_trim(reply___1);
              }
#line 1961
              if ((int )reply___1[0] == 52) {
                {
#line 1962
                unlink((char const   *)(outlogtmp));
#line 1963
                exit(0);
                }
              }
              {
#line 1967
              tmp___2 = str_beq((char const   *)(reply___1), "510 ");
              }
#line 1967
              if (tmp___2) {
                {
#line 1968
                tmp = strrchr((char const   *)(reply___1), ' ');
#line 1968
                strcpy((char */* __restrict  */)(server), (char const   */* __restrict  */)(tmp + 1));
#line 1971
                sendcommand(sockfd, "QUIT", (char *)((void *)0));
#line 1972
                shutdown(sockfd, 2);
                }
#line 1976
                if (! test) {
                  {
#line 1976
                  sockfd = open_connection(server, 487);
                  }
#line 1976
                  if (sockfd >= 0) {
                    {
#line 1980
                    sock_getline(sockfd, reply___1);
#line 1981
                    tmp___0 = str_beq((char const   *)(reply___1), "220 ");
                    }
#line 1981
                    if (tmp___0) {
                      {
#line 1981
                      tmp___1 = strstr((char const   *)(reply___1), "SAFT");
                      }
#line 1981
                      if (tmp___1) {
                        {
#line 1984
                        snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL,
                                 (char const   */* __restrict  */)"LOG %s %s", pw_name,
                                 outlogtmp);
#line 1985
                        sock_putline(sockfd, (char const   *)(line));
#line 1986
                        sock_getline(sockfd, reply___1);
#line 1987
                        str_trim(reply___1);
                        }
#line 1990
                        if ((int )reply___1[0] == 52) {
                          {
#line 1991
                          unlink((char const   *)(outlogtmp));
#line 1992
                          exit(0);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          {
#line 2001
          sendcommand(sockfd, "QUIT", (char *)((void *)0));
#line 2002
          shutdown(sockfd, 2);
          }
        }
      }
    }
  }
  {
#line 2006
  unlink((char const   *)(outlogtmp));
  }
#line 2010
  return;
}
}
#line 2022 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void pgp_encrypt(int pgpcrypt , char *pgprid , char *file ) 
{ 
  char *cp ;
  char cmd[32768] ;
  char line[4096] ;
  struct stat finfo ;
  FILE *inf ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2030
  inf = (FILE *)((void *)0);
#line 2032
  if (! quiet) {
    {
#line 2032
    message(prg, (char )'I', "call to pgp...");
    }
  }
  {
#line 2035
  tmp___5 = strlen((char const   *)pgprid);
  }
#line 2035
  if (tmp___5 > 1UL) {
    {
#line 2036
    snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s -kvf %s > %s 2>/dev/null",
             pgp_bin, pgprid, pgptmp);
#line 2037
    vsystem((char const   *)(cmd));
#line 2038
    tmp___0 = stat((char const   */* __restrict  */)(pgptmp), (struct stat */* __restrict  */)(& finfo));
    }
#line 2038
    if (tmp___0 < 0) {
      {
#line 2039
      tmp = __errno_location();
#line 2039
      *tmp = 0;
#line 2040
      message(prg, (char )'F', "call to pgp failed");
      }
    } else
#line 2038
    if (finfo.st_size == 0L) {
      {
#line 2039
      tmp = __errno_location();
#line 2039
      *tmp = 0;
#line 2040
      message(prg, (char )'F', "call to pgp failed");
      }
    } else {
      {
#line 2038
      inf = rfopen((char const   *)(pgptmp), "r");
      }
#line 2038
      if (! inf) {
        {
#line 2039
        tmp = __errno_location();
#line 2039
        *tmp = 0;
#line 2040
        message(prg, (char )'F', "call to pgp failed");
        }
      }
    }
    {
#line 2042
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2042
      tmp___1 = sfgetl(line, (int )sizeof(line), inf);
      }
#line 2042
      if (tmp___1) {
        {
#line 2042
        tmp___2 = strstr((char const   *)(line), "matching key");
        }
#line 2042
        if (tmp___2) {
#line 2042
          goto while_break;
        }
      } else {
#line 2042
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2043
    fclose(inf);
#line 2044
    cp = strchr((char const   *)(line), '.');
    }
#line 2044
    if (cp) {
#line 2044
      *cp = (char)0;
    }
    {
#line 2045
    tmp___4 = strcmp((char const   *)(line), "1 matching key found");
    }
#line 2045
    if (! (tmp___4 == 0)) {
#line 2046
      if (! quiet) {
        {
#line 2047
        snprintf((char */* __restrict  */)(line), sizeof(line) - 1UL, (char const   */* __restrict  */)"ambigous pgp-ID \'%s\'",
                 pgprid);
#line 2048
        message(prg, (char )'W', (char const   *)(line));
#line 2049
        inf = rfopen((char const   *)(pgptmp), "r");
        }
        {
#line 2050
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2050
          tmp___3 = sfgetl(line, (int )sizeof(line), inf);
          }
#line 2050
          if (! tmp___3) {
#line 2050
            goto while_break___0;
          }
          {
#line 2050
          printf((char const   */* __restrict  */)"%s", line);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2051
        fclose(inf);
        }
      }
#line 2053
      *pgprid = (char)0;
    }
  } else {
#line 2056
    *pgprid = (char)0;
  }
#line 2059
  if (pgpcrypt == 99) {
#line 2059
    goto _L;
  } else
#line 2059
  if (! *pgprid) {
    _L: /* CIL Label */ 
    {
#line 2060
    tmp___6 = shell_quote((char const   *)file);
#line 2060
    snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s +armor=off -f%c < %s > %s",
             pgp_bin, pgpcrypt, tmp___6, pgptmp);
#line 2062
    tmp___8 = vsystem((char const   *)(cmd));
    }
#line 2062
    if (tmp___8) {
      {
#line 2063
      tmp___7 = __errno_location();
#line 2063
      *tmp___7 = 0;
#line 2064
      message(prg, (char )'F', "call to pgp failed");
      }
    } else {
      {
#line 2062
      tmp___9 = stat((char const   */* __restrict  */)(pgptmp), (struct stat */* __restrict  */)(& finfo));
      }
#line 2062
      if (tmp___9 < 0) {
        {
#line 2063
        tmp___7 = __errno_location();
#line 2063
        *tmp___7 = 0;
#line 2064
        message(prg, (char )'F', "call to pgp failed");
        }
      } else
#line 2062
      if (finfo.st_size == 0L) {
        {
#line 2063
        tmp___7 = __errno_location();
#line 2063
        *tmp___7 = 0;
#line 2064
        message(prg, (char )'F', "call to pgp failed");
        }
      }
    }
    {
#line 2066
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 2070
    tmp___10 = shell_quote((char const   *)file);
#line 2070
    snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s +armor=off -fe %s < %s > %s 2>/dev/null",
             pgp_bin, pgprid, tmp___10, pgptmp);
#line 2072
    tmp___12 = vsystem((char const   *)(cmd));
    }
#line 2072
    if (tmp___12) {
      {
#line 2073
      tmp___11 = __errno_location();
#line 2073
      *tmp___11 = 0;
#line 2074
      message(prg, (char )'F', "call to pgp failed (wrong pgp user id?)");
      }
    } else {
      {
#line 2072
      tmp___13 = stat((char const   */* __restrict  */)(pgptmp), (struct stat */* __restrict  */)(& finfo));
      }
#line 2072
      if (tmp___13 < 0) {
        {
#line 2073
        tmp___11 = __errno_location();
#line 2073
        *tmp___11 = 0;
#line 2074
        message(prg, (char )'F', "call to pgp failed (wrong pgp user id?)");
        }
      } else
#line 2072
      if (finfo.st_size == 0L) {
        {
#line 2073
        tmp___11 = __errno_location();
#line 2073
        *tmp___11 = 0;
#line 2074
        message(prg, (char )'F', "call to pgp failed (wrong pgp user id?)");
        }
      }
    }
  }
  {
#line 2078
  strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)(pgptmp));
  }
#line 2079
  return;
}
}
#line 2089 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void pgp_sign(char const   *pgpsign , char const   *infile , int sockfd ) 
{ 
  int check ;
  char *cp ;
  char tmp[4096] ;
  char sign[4096] ;
  char line[4096] ;
  char cmd[8192] ;
  FILE *pipe___0 ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 2100
  check = 0;
#line 2101
  sign[0] = (char)0;
#line 2103
  if (! quiet) {
#line 2103
    if (! pgppass) {
      {
#line 2103
      message(prg, (char )'I', "call to pgp...");
      }
    }
  }
  {
#line 2105
  tmp___0 = shell_quote(infile);
#line 2105
  snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s %s -fsba %s < %s",
           pgp_bin, pgpvm, pgpsign, tmp___0);
  }
#line 2107
  if (verbose) {
    {
#line 2108
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s",
             cmd);
#line 2109
    message(prg, (char )'I', (char const   *)(tmp));
    }
  }
  {
#line 2111
  pipe___0 = popen((char const   *)(cmd), "r");
  }
#line 2111
  if (! pipe___0) {
    {
#line 2111
    message(prg, (char )'F', "call to pgp (signature) failed");
    }
  }
  {
#line 2114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2114
    tmp___3 = sfgetl(line, (int )sizeof(line), pipe___0);
    }
#line 2114
    if (! tmp___3) {
#line 2114
      goto while_break;
    }
    {
#line 2115
    cp = strchr((char const   *)(line), '\n');
    }
#line 2115
    if (cp) {
#line 2115
      *cp = (char)0;
    }
    {
#line 2116
    tmp___1 = strcmp((char const   *)(line), "-----BEGIN PGP MESSAGE-----");
    }
#line 2116
    if (tmp___1 == 0) {
#line 2116
      check ++;
    }
    {
#line 2117
    tmp___2 = strcmp((char const   *)(line), "-----END PGP MESSAGE-----");
    }
#line 2117
    if (tmp___2 == 0) {
#line 2117
      check += 2;
    }
    {
#line 2118
    strcat((char */* __restrict  */)(sign), (char const   */* __restrict  */)(line));
#line 2119
    strcat((char */* __restrict  */)(sign), (char const   */* __restrict  */)"\r\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2121
  pclose(pipe___0);
  }
#line 2123
  if (! pgppass) {
    {
#line 2123
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2124
  if (check != 3) {
    {
#line 2124
    message(prg, (char )'F', "call to pgp (signature) failed");
    }
  }
  {
#line 2126
  iso2utf(tmp, sign);
#line 2127
  snprintf((char */* __restrict  */)(sign), sizeof(sign) - 1UL, (char const   */* __restrict  */)"SIGN %s",
           tmp);
  }
#line 2128
  if (sockfd) {
    {
#line 2128
    sendcommand(sockfd, (char const   *)(sign), (char *)((void *)0));
    }
  }
#line 2129
  return;
}
}
#line 2146 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
FILE *outspool(char const   *user , char const   *outgoing , char *oshf ) 
{ 
  struct stat finfo ;
  struct timeval tv ;
  struct timezone tz ;
  int tmp ;
  FILE *tmp___0 ;

  {
  {
#line 2161
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
#line 2165
  snprintf((char */* __restrict  */)oshf, (size_t )4095, (char const   */* __restrict  */)"%s/%s_%d.t",
           outgoing, user, (int )tv.tv_usec);
#line 2168
  tmp = stat((char const   */* __restrict  */)oshf, (struct stat */* __restrict  */)(& finfo));
  }
#line 2168
  if (tmp == 0) {
#line 2168
    return ((FILE *)((void *)0));
  }
  {
#line 2170
  tmp___0 = rfopen((char const   *)oshf, "w");
  }
#line 2170
  return (tmp___0);
}
}
#line 2177 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void reply(int x ) 
{ 


  {
#line 2177
  return;
}
}
#line 2185 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void start_spooldaemon(char *localhost___0 ) 
{ 
  int sockfd ;
  char *host ;
  char reply___1[4096] ;
  char tmp[4096] ;
  char line[4096] ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2196
  sockfd = open_connection(localhost___0, 487);
  }
#line 2200
  if (sockfd == -1) {
    {
#line 2200
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot create a network socket - cannot start local spool daemon");
    }
  }
#line 2202
  if (sockfd == -2) {
    {
#line 2202
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open connection to %s - cannot start local spool daemon",
             localhost___0);
    }
  }
#line 2204
  if (sockfd == -3) {
    {
#line 2204
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is unknown (name server down?) - cannot start local spool daemon",
             localhost___0);
    }
  }
#line 2206
  if (sockfd == -4) {
    {
#line 2206
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"out of memory - cannot start local spool daemon");
    }
  }
#line 2208
  if (sockfd < 0) {
    {
#line 2209
    tmp___0 = __errno_location();
#line 2209
    *tmp___0 = 0;
#line 2210
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 2214
  sock_getline(sockfd, line);
#line 2215
  tmp___2 = str_beq((char const   *)(line), "220 ");
  }
#line 2215
  if (tmp___2) {
    {
#line 2215
    tmp___3 = strstr((char const   *)(line), "SAFT");
    }
#line 2215
    if (! tmp___3) {
      {
#line 2216
      tmp___1 = __errno_location();
#line 2216
      *tmp___1 = 0;
#line 2218
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"No SAFT server on port %d at %s - cannot start local spool daemon",
               487, localhost___0);
#line 2224
      message(prg, (char )'F', (char const   *)(tmp));
      }
    }
  } else {
    {
#line 2216
    tmp___1 = __errno_location();
#line 2216
    *tmp___1 = 0;
#line 2218
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"No SAFT server on port %d at %s - cannot start local spool daemon",
             487, localhost___0);
#line 2224
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
  {
#line 2227
  sendcommand(sockfd, "START SPOOLDAEMON", reply___1);
#line 2228
  str_trim(reply___1);
#line 2231
  tmp___8 = str_beq((char const   *)(reply___1), "510 ");
  }
#line 2231
  if (tmp___8) {
    {
#line 2231
    host = strrchr((char const   *)(reply___1), ' ');
    }
#line 2231
    if (host) {
      {
#line 2232
      host ++;
#line 2235
      sendcommand(sockfd, "QUIT", (char *)((void *)0));
#line 2236
      shutdown(sockfd, 2);
#line 2240
      sockfd = open_connection(host, 487);
      }
#line 2244
      if (sockfd == -1) {
        {
#line 2244
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot create a network socket - cannot start local spool daemon");
        }
      }
#line 2246
      if (sockfd == -2) {
        {
#line 2246
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open connection to %s - cannot start local spool daemon",
                 host);
        }
      }
#line 2248
      if (sockfd == -3) {
        {
#line 2248
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is unknown (name server down?) - cannot start local spool daemon",
                 host);
        }
      }
#line 2250
      if (sockfd == -4) {
        {
#line 2250
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"out of memory - cannot start local spool daemon");
        }
      }
#line 2252
      if (sockfd < 0) {
        {
#line 2253
        tmp___4 = __errno_location();
#line 2253
        *tmp___4 = 0;
#line 2254
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
      {
#line 2258
      sock_getline(sockfd, line);
#line 2259
      tmp___6 = str_beq((char const   *)(line), "220 ");
      }
#line 2259
      if (tmp___6) {
        {
#line 2259
        tmp___7 = strstr((char const   *)(line), "SAFT");
        }
#line 2259
        if (! tmp___7) {
          {
#line 2260
          tmp___5 = __errno_location();
#line 2260
          *tmp___5 = 0;
#line 2262
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"No SAFT server on port %d at %s - cannot start local spool daemon",
                   487, host);
#line 2268
          message(prg, (char )'F', (char const   *)(tmp));
          }
        }
      } else {
        {
#line 2260
        tmp___5 = __errno_location();
#line 2260
        *tmp___5 = 0;
#line 2262
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"No SAFT server on port %d at %s - cannot start local spool daemon",
                 487, host);
#line 2268
        message(prg, (char )'F', (char const   *)(tmp));
        }
      }
      {
#line 2271
      sendheader(sockfd, (char *)"START SPOOLDAEMON");
#line 2272
      sendheader(sockfd, (char *)"QUIT");
      }
    }
  }
#line 2275
  return;
}
}
#line 2287 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void outlog(char *to , char *host , char *file , char *sizes ) 
{ 
  char currentdate[256] ;
  FILE *outf ;
  time_t timetick ;
  struct tm *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2292
  if (outlogging) {
    {
#line 2292
    tmp___0 = strcmp((char const   *)host, (char const   *)(localhost));
    }
#line 2292
    if (tmp___0) {
      {
#line 2292
      tmp___1 = strcmp((char const   *)host, "localhost");
      }
#line 2292
      if (tmp___1) {
        {
#line 2292
        outf = rfopen((char const   *)(outlogtmp), "a");
        }
#line 2292
        if (outf) {
          {
#line 2296
          timetick = time((time_t *)((void *)0));
#line 2297
          tmp = localtime((time_t const   *)(& timetick));
#line 2297
          strftime((char */* __restrict  */)(currentdate), (size_t )20, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
                   (struct tm  const  */* __restrict  */)tmp);
#line 2300
          fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"FROM\t%s\nTO\t%s@%s\nDATE\t%s\nFILE\t%s\nSIZES\t%s\n\n",
                  pw_name, to, host, currentdate, file, sizes);
#line 2303
          fclose(outf);
          }
        }
      }
    }
  }
#line 2306
  return;
}
}
#line 2317 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void forward(char *host , float mtp ) 
{ 
  int sockfd ;
  off_t size ;
  float ttime ;
  char *arg ;
  char from[256] ;
  char recipient[256] ;
  char line[4096] ;
  char tmp[4096] ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 2331
  size = (off_t )0;
#line 2332
  from[0] = (char)0;
#line 2332
  recipient[0] = from[0];
#line 2332
  line[0] = recipient[0];
#line 2334
  get_header("FROM", from);
#line 2335
  get_header("TO", recipient);
#line 2338
  sockfd = saft_connect("file", recipient, from, host, tmp);
  }
  {
#line 2341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2341
    tmp___6 = sfgetl(line, (int )sizeof(line), stdin);
    }
#line 2341
    if (! tmp___6) {
#line 2341
      goto while_break;
    }
    {
#line 2343
    str_trim(line);
#line 2344
    tmp___0 = strlen((char const   *)(line));
#line 2344
    tmp___1 = str_neq_nocase("DATA", (char const   *)(line), (int )tmp___0);
    }
#line 2344
    if (tmp___1) {
#line 2344
      goto while_break;
    }
    {
#line 2345
    tmp___3 = strlen((char const   *)(line));
#line 2345
    tmp___4 = str_neq_nocase("RESEND", (char const   *)(line), (int )tmp___3);
    }
#line 2345
    if (tmp___4) {
      {
#line 2346
      tmp___2 = __errno_location();
#line 2346
      *tmp___2 = 0;
#line 2347
      message(prg, (char )'F', "the RESEND command is not supported with the -X option");
      }
    }
    {
#line 2351
    arg = strchr((char const   *)(line), ' ');
    }
#line 2351
    if (arg) {
      {
#line 2352
      tmp___5 = str_neq_nocase("SIZE", (char const   *)(line), 4);
      }
#line 2352
      if (tmp___5) {
        {
#line 2352
        sscanf((char const   */* __restrict  */)(arg + 1), (char const   */* __restrict  */)"%lld",
               & size);
        }
      }
    }
    {
#line 2356
    sendheader(sockfd, line);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2360
  if (! size) {
    {
#line 2361
    tmp___7 = __errno_location();
#line 2361
    *tmp___7 = 0;
#line 2362
    message(prg, (char )'F', "SIZE command is missing");
    }
  }
  {
#line 2364
  send_data(sockfd, size, "", "", "STDIN", "", mtp, & ttime);
  }
#line 2365
  return;
}
}
#line 2375 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void get_header(char const   *cmd , char *arg ) 
{ 
  char *cp ;
  char line[4096] ;
  char tmp[4096] ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2382
  sfgetl(line, (int )sizeof(line), stdin);
#line 2383
  str_trim(line);
#line 2386
  tmp___0 = strlen((char const   *)(line));
  }
#line 2386
  if (tmp___0 > 3UL) {
    {
#line 2386
    cp = strchr((char const   *)(line), ' ');
    }
#line 2386
    if (cp) {
      {
#line 2387
      *cp = (char)0;
#line 2388
      strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)(cp + 1));
#line 2389
      str_toupper(line);
      }
    }
  }
  {
#line 2392
  tmp___2 = strcmp(cmd, (char const   *)(line));
  }
#line 2392
  if (! (tmp___2 == 0)) {
    {
#line 2393
    tmp___1 = __errno_location();
#line 2393
    *tmp___1 = 0;
#line 2394
    line[4016] = (char)0;
#line 2395
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"illegal SAFT command \"%s\", \"%s\" was expected",
             line, cmd);
#line 2397
    message(prg, (char )'F', (char const   *)(tmp));
    }
  }
#line 2400
  return;
}
}
#line 2423 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char const   *set[19]  = 
#line 2423
  {      "Makefile",      "Makefile.",      ".c",      ".f", 
        ".f77",      ".for",      ".f90",      ".p", 
        ".pas",      ".java",      ".h",      ".ada", 
        ".pl",      ".sl",      ".cc",      ".tcl", 
        ".tk",      ".ps",      ""};
#line 2427 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char *tet[3]  = {      (char *)"README",      (char *)".txt",      (char *)""};
#line 2429 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char *sft[12]  = 
#line 2429
  {      (char *)"source",      (char *)"shell",      (char *)"program",      (char *)"command", 
        (char *)"script",      (char *)"perl",      (char *)"pascal",      (char *)" c ", 
        (char *)"c++",      (char *)"java",      (char *)"fortran",      (char *)""};
#line 2432 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char const   *tft[4]  = {      "text",      "ASCII",      "english",      ""};
#line 2434 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char const   *bft[5]  = {      "data",      "archive",      "zip",      "stripped", 
        ""};
#line 2436 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
static char *cet[17]  = 
#line 2436
  {      (char *)".zip",      (char *)".z",      (char *)".zoo",      (char *)".gz", 
        (char *)".bz",      (char *)".bz2",      (char *)".tgz",      (char *)".rpm", 
        (char *)".mp3",      (char *)".gif",      (char *)".jpg",      (char *)".tif", 
        (char *)".tiff",      (char *)".png",      (char *)".avi",      (char *)".mpeg", 
        (char *)""};
#line 2415 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
char guess_ftype(char const   *file , char *type ) 
{ 
  int i ;
  char *cp ;
  char **cpp ;
  char tmp[4096] ;
  char cmd[4096] ;
  FILE *pipe___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 2443
  i = 0;
  {
#line 2443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2443
    if (! *(set[i])) {
#line 2443
      goto while_break;
    }
#line 2444
    if ((int const   )*(set[i]) == 46) {
      {
#line 2445
      cp = strrchr(file, '.');
      }
#line 2445
      if (cp) {
        {
#line 2445
        tmp___0 = strcmp((char const   *)cp, set[i]);
        }
#line 2445
        if (tmp___0 == 0) {
#line 2445
          return ((char )'s');
        }
      }
    } else {
      {
#line 2447
      tmp___1 = strcmp(file, set[i]);
      }
#line 2447
      if (tmp___1 == 0) {
#line 2447
        return ((char )'s');
      }
    }
#line 2443
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2452
  i = 0;
  {
#line 2452
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2452
    if (! *(tet[i])) {
#line 2452
      goto while_break___0;
    }
#line 2453
    if ((int )*(tet[i]) == 46) {
      {
#line 2454
      cp = strrchr(file, '.');
      }
#line 2454
      if (cp) {
        {
#line 2454
        tmp___2 = strcmp((char const   *)cp, (char const   *)tet[i]);
        }
#line 2454
        if (tmp___2 == 0) {
#line 2454
          return ((char )'t');
        }
      }
    } else {
      {
#line 2456
      tmp___3 = strcmp(file, (char const   *)tet[i]);
      }
#line 2456
      if (tmp___3 == 0) {
#line 2456
        return ((char )'t');
      }
    }
#line 2452
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2461
  if (*(dontcompress[0])) {
#line 2462
    cpp = dontcompress;
  } else {
#line 2464
    cpp = cet;
  }
#line 2465
  i = 0;
  {
#line 2465
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2465
    if (! *(*(cpp + i))) {
#line 2465
      goto while_break___1;
    }
    {
#line 2467
    cp = strrchr(file, '.');
    }
#line 2467
    if (cp) {
      {
#line 2467
      tmp___4 = strcmp((char const   *)cp, (char const   *)*(cpp + i));
      }
#line 2467
      if (tmp___4 == 0) {
        {
#line 2468
        strcpy((char */* __restrict  */)type, (char const   */* __restrict  */)"already compressed");
        }
#line 2469
        return ((char )'b');
      }
    }
#line 2465
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2476
  tmp___5 = shell_quote(file);
#line 2476
  snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"file %s",
           tmp___5);
#line 2477
  pipe___0 = vpopen((char const   *)(cmd), "r");
  }
#line 2477
  if (pipe___0) {
    {
#line 2477
    tmp___11 = sfgetl(tmp, (int )sizeof(tmp), pipe___0);
    }
#line 2477
    if (tmp___11) {
      {
#line 2478
      pclose(pipe___0);
#line 2481
      tmp___7 = str_beq((char const   *)(tmp), file);
      }
#line 2481
      if (tmp___7) {
        {
#line 2482
        tmp___6 = strlen(file);
#line 2482
        strcpy((char */* __restrict  */)type, (char const   */* __restrict  */)(tmp + tmp___6));
        }
      } else {
        {
#line 2484
        strcpy((char */* __restrict  */)type, (char const   */* __restrict  */)(tmp));
        }
      }
      {
#line 2485
      cp = strchr((char const   *)type, '\n');
      }
#line 2485
      if (cp) {
#line 2485
        *cp = (char)0;
      }
#line 2487
      if (verbose) {
        {
#line 2488
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is of type %s",
                 file, type);
#line 2489
        message(prg, (char )'I', (char const   *)(tmp));
        }
      }
      {
#line 2493
      str_tolower(type);
#line 2494
      i = 0;
      }
      {
#line 2494
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2494
        if (! *(bft[i])) {
#line 2494
          goto while_break___2;
        }
        {
#line 2494
        tmp___8 = strstr((char const   *)type, bft[i]);
        }
#line 2494
        if (tmp___8) {
#line 2494
          return ((char )'b');
        }
#line 2494
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2495
      i = 0;
      {
#line 2495
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2495
        if (! *(sft[i])) {
#line 2495
          goto while_break___3;
        }
        {
#line 2495
        tmp___9 = strstr((char const   *)type, (char const   *)sft[i]);
        }
#line 2495
        if (tmp___9) {
#line 2495
          return ((char )'s');
        }
#line 2495
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2496
      i = 0;
      {
#line 2496
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2496
        if (! *(tft[i])) {
#line 2496
          goto while_break___4;
        }
        {
#line 2496
        tmp___10 = strstr((char const   *)type, tft[i]);
        }
#line 2496
        if (tmp___10) {
#line 2496
          return ((char )'t');
        }
#line 2496
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 2500
  return ((char )'b');
}
}
#line 2516 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int linkspeed(char const   *host , int lanspeed , char **compress ) 
{ 
  int speed ;
  char msg[4096] ;
  char speeddir[4096] ;
  char hostfile[4096] ;
  FILE *inf ;
  struct stat finfo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2525
  speed = 0;
#line 2528
  tmp = strcmp(host, (char const   *)(localhost));
  }
#line 2528
  if (tmp == 0) {
#line 2528
    goto _L;
  } else {
    {
#line 2528
    tmp___0 = strcmp(host, "localhost");
    }
#line 2528
    if (tmp___0 == 0) {
      _L: /* CIL Label */ 
#line 2529
      if (verbose) {
        {
#line 2529
        message(prg, (char )'I', "disabling compressing for localhost");
        }
      }
#line 2530
      *compress = (char *)"";
#line 2531
      return (0);
    }
  }
#line 2535
  if (lanspeed < 1) {
#line 2535
    return (1);
  }
  {
#line 2538
  snprintf((char */* __restrict  */)(speeddir), sizeof(speeddir) - 1UL, (char const   */* __restrict  */)"%s/speeds",
           userspool);
#line 2539
  tmp___2 = stat((char const   */* __restrict  */)(speeddir), (struct stat */* __restrict  */)(& finfo));
  }
#line 2539
  if (tmp___2 < 0) {
#line 2539
    goto _L___0;
  } else
#line 2539
  if (! ((finfo.st_mode & 61440U) == 16384U)) {
    _L___0: /* CIL Label */ 
    {
#line 2540
    unlink((char const   *)(speeddir));
#line 2541
    tmp___1 = mkdir((char const   *)(speeddir), (__mode_t )448);
    }
#line 2541
    if (tmp___1 < 0) {
#line 2541
      return (1);
    }
    {
#line 2542
    chmod((char const   *)(speeddir), (__mode_t )448);
    }
  }
  {
#line 2545
  snprintf((char */* __restrict  */)(hostfile), sizeof(hostfile) - 1UL, (char const   */* __restrict  */)"%s/%s",
           speeddir, host);
#line 2548
  inf = rfopen((char const   *)(hostfile), "r");
  }
#line 2548
  if (! inf) {
#line 2548
    return (1);
  }
  {
#line 2549
  fscanf((FILE */* __restrict  */)inf, (char const   */* __restrict  */)"%d", & speed);
#line 2550
  fclose(inf);
  }
#line 2552
  if (speed < lanspeed) {
#line 2552
    return (1);
  }
#line 2554
  if (verbose) {
    {
#line 2555
    snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"disabling compressing because last link speed to %s was %d kB/s",
             host, speed);
#line 2558
    message(prg, (char )'I', (char const   *)(msg));
#line 2559
    snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"LAN speed is defined as min %d kB/s",
             lanspeed);
#line 2560
    message(prg, (char )'I', (char const   *)(msg));
    }
  }
#line 2563
  if (compress) {
#line 2563
    *compress = (char *)"";
  }
#line 2565
  return (0);
}
}
#line 2576 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void notespeed(char const   *host , unsigned long size , float ttime ) 
{ 
  char speeddir[4096] ;
  char hostfile[4096] ;
  FILE *outf ;
  struct stat finfo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2584
  tmp = strcmp(host, (char const   *)(localhost));
  }
#line 2584
  if (tmp == 0) {
#line 2584
    return;
  } else {
    {
#line 2584
    tmp___0 = strcmp(host, "localhost");
    }
#line 2584
    if (tmp___0 == 0) {
#line 2584
      return;
    }
  }
#line 2587
  if (ttime < (float )1) {
#line 2587
    return;
  } else
#line 2587
  if (size < 102400UL) {
#line 2587
    return;
  }
  {
#line 2590
  snprintf((char */* __restrict  */)(speeddir), sizeof(speeddir) - 1UL, (char const   */* __restrict  */)"%s/speeds",
           userspool);
#line 2591
  tmp___2 = stat((char const   */* __restrict  */)(speeddir), (struct stat */* __restrict  */)(& finfo));
  }
#line 2591
  if (tmp___2 < 0) {
#line 2591
    goto _L;
  } else
#line 2591
  if (! ((finfo.st_mode & 61440U) == 16384U)) {
    _L: /* CIL Label */ 
    {
#line 2592
    unlink((char const   *)(speeddir));
#line 2593
    tmp___1 = mkdir((char const   *)(speeddir), (__mode_t )448);
    }
#line 2593
    if (tmp___1 < 0) {
#line 2593
      return;
    }
    {
#line 2594
    chmod((char const   *)(speeddir), (__mode_t )448);
    }
  }
  {
#line 2597
  snprintf((char */* __restrict  */)(hostfile), sizeof(hostfile) - 1UL, (char const   */* __restrict  */)"%s/%s",
           speeddir, host);
#line 2599
  outf = rfopen((char const   *)(hostfile), "w");
  }
#line 2599
  if (outf) {
    {
#line 2600
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%d\n",
            (int )((double )((float )size / ttime) / 1.024));
#line 2601
    fclose(outf);
    }
  }
#line 2604
  return;
}
}
#line 2612 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int list_spool(void) 
{ 
  char file[256] ;
  struct hostlist *hls ;
  struct hostlist *hlp ;
  struct outfilelist *oflp ;

  {
  {
#line 2621
  hls = scanoutspool(pw_name);
  }
#line 2622
  if (! hls) {
#line 2623
    if (quiet < 2) {
      {
#line 2623
      message(prg, (char )'W', "no files found in outgoing spool");
      }
    }
#line 2624
    return (1);
  }
  {
#line 2627
  printf((char const   */* __restrict  */)"Files in outgoing spool:\n");
#line 2630
  hlp = hls;
  }
  {
#line 2630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2630
    if (! hlp) {
#line 2630
      goto while_break;
    }
    {
#line 2631
    printf((char const   */* __restrict  */)"\n");
#line 2632
    oflp = hlp->flist;
    }
    {
#line 2632
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2632
      if (! oflp) {
#line 2632
        goto while_break___0;
      }
      {
#line 2633
      utf2iso(0, (char *)((void *)0), file, (char *)((void *)0), oflp->fname);
#line 2634
      printf((char const   */* __restrict  */)"%s@%s : %s (%lld KB)\n", oflp->to,
             hlp->host, file, (oflp->size + 512L) / 1024L);
#line 2632
      oflp = oflp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2630
    hlp = hlp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2641
  return (0);
}
}
#line 2653 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
void spooled_info(char const   *file , char const   *sdf , int compressed ) 
{ 
  int size ;
  char tmp[4096] ;
  struct stat finfo ;
  int tmp___0 ;

  {
#line 2658
  if (quiet > 1) {
#line 2658
    return;
  }
  {
#line 2660
  tmp___0 = stat((char const   */* __restrict  */)sdf, (struct stat */* __restrict  */)(& finfo));
  }
#line 2660
  if (tmp___0 < 0) {
    {
#line 2661
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot access spool file %s",
             sdf);
#line 2662
    message(prg, (char )'E', (char const   *)(tmp));
    }
#line 2663
    return;
  }
#line 2666
  size = (int )((finfo.st_size + 512L) / 1024L);
#line 2668
  if (compressed) {
    {
#line 2669
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"\'%s\' spooled (%d KB [compressed])",
             file, size);
    }
  } else {
    {
#line 2671
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"\'%s\' spooled (%d KB)",
             file, size);
    }
  }
  {
#line 2672
  message(prg, (char )'I', (char const   *)(tmp));
  }
#line 2673
  return;
}
}
#line 2679 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/sendfile.c"
int usage(void) 
{ 


  {
  {
#line 2710
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 2711
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [OPTIONS] file [...] user[@host]\n",
          prg);
#line 2712
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   or: %s [OPTIONS] -a=archive-name file-or-directory [...] user[@host]\n",
          prg);
#line 2713
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"options: -s   send file(s) in source mode\n");
#line 2714
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -t   send file(s) in text mode\n");
#line 2715
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -g   send file(s) in guessed mode (does not work in every case!)\n");
#line 2716
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -d   delete previously sent file(s)\n");
#line 2717
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -o   overwrite file(s) with the same name\n");
#line 2718
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -u   send file(s) uncompressed\n");
#line 2719
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -v   verbose mode\n");
#line 2720
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -q   quiet mode 1: no transfer messages or questions\n");
#line 2721
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -Q   quiet mode 2: no transfer, information or warning messages\n");
#line 2722
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -P   read file from stdin (this is usually a pipe)\n");
#line 2723
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -S   spool file(s) for later processing\n");
#line 2724
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -l   list file(s) in outgoing spool\n");
#line 2725
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -V   show version\n");
#line 2726
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -z   force compression (with gzip)\n");
#line 2727
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m LIMIT      maximum thruput at LIMIT KB/s\n");
#line 2728
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -a=name       send all files in one archive\n");
#line 2729
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -c=\'comment\'  add a one line text comment to a single file\n");
#line 2730
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -ps           pgp-sign\n");
#line 2731
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -pe[=ID]      pgp-encrypt [for ID]\n");
#line 2736
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"example: %s rabbit.gif beate@juhu.lake.de\n",
          prg);
#line 2737
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"see also: sfconf\n");
  }
#line 2742
  return (2);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.h"
int str_beq_nocase(char const   *s1 , char const   *s2 ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
char *str_trim(char *string ) 
{ 
  char *rp ;
  char *wp ;
  int ws ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 69
  ws = 0;
#line 71
  if (*string) {
#line 74
    rp = string;
#line 74
    wp = rp;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! *rp) {
#line 74
        goto while_break;
      }
#line 77
      if ((int )*rp == 32) {
#line 77
        goto _L;
      } else
#line 77
      if ((int )*rp == 9) {
#line 77
        goto _L;
      } else
#line 77
      if ((int )*rp == 10) {
#line 77
        goto _L;
      } else
#line 77
      if ((int )*rp == 13) {
        _L: /* CIL Label */ 
#line 80
        if (! ws) {
#line 81
          tmp = wp;
#line 81
          wp ++;
#line 81
          *tmp = (char )' ';
#line 82
          ws = 1;
        }
      } else {
#line 88
        tmp___0 = wp;
#line 88
        wp ++;
#line 88
        *tmp___0 = *rp;
#line 89
        ws = 0;
      }
#line 74
      rp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 95
    if (ws) {
#line 95
      wp --;
    }
#line 96
    *wp = (char)0;
  }
#line 100
  return (string);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
char *str_toupper(char *string ) 
{ 
  char *cp ;
  int tmp ;

  {
#line 117
  cp = string;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! *cp) {
#line 117
      goto while_break;
    }
    {
#line 117
    tmp = toupper((int )*cp);
#line 117
    *cp = (char )tmp;
#line 117
    cp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (string);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
char *str_tolower(char *string ) 
{ 
  char *cp ;
  int tmp ;

  {
#line 136
  cp = string;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! *cp) {
#line 136
      goto while_break;
    }
    {
#line 136
    tmp = tolower((int )*cp);
#line 136
    *cp = (char )tmp;
#line 136
    cp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (string);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
int str_beq(char const   *s1 , char const   *s2 ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 152
  tmp___1 = strlen(s1);
#line 152
  tmp___2 = strlen(s2);
  }
#line 152
  if (tmp___1 < tmp___2) {
    {
#line 153
    tmp = strlen(s1);
#line 153
    len = (int )tmp;
    }
  } else {
    {
#line 155
    tmp___0 = strlen(s2);
#line 155
    len = (int )tmp___0;
    }
  }
  {
#line 156
  tmp___3 = strncmp(s1, s2, (size_t )len);
  }
#line 156
  if (tmp___3 == 0) {
#line 157
    return (1);
  } else {
#line 159
    return (0);
  }
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
int str_neq_nocase(char const   *s1 , char const   *s2 , int len ) 
{ 
  int i ;
  char a ;
  char b ;
  int tmp ;
  int tmp___0 ;

  {
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < len)) {
#line 175
      goto while_break;
    }
    {
#line 176
    a = (char )*(s1 + i);
#line 177
    b = (char )*(s2 + i);
#line 178
    tmp = tolower((int )a);
#line 178
    tmp___0 = tolower((int )b);
    }
#line 178
    if (tmp != tmp___0) {
#line 178
      return (0);
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (1);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
int str_beq_nocase(char const   *s1 , char const   *s2 ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 194
  tmp___1 = strlen(s1);
#line 194
  tmp___2 = strlen(s2);
  }
#line 194
  if (tmp___1 < tmp___2) {
    {
#line 194
    tmp = strlen(s1);
#line 194
    len = (int )tmp;
    }
  } else {
    {
#line 194
    tmp___0 = strlen(s2);
#line 194
    len = (int )tmp___0;
    }
  }
  {
#line 195
  tmp___3 = str_neq_nocase(s1, s2, len);
  }
#line 195
  return (tmp___3);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
static char sm_escchar(char c ) 
{ 


  {
  {
#line 251
  if ((int )c == 97) {
#line 251
    goto case_97;
  }
#line 252
  if ((int )c == 98) {
#line 252
    goto case_98;
  }
#line 253
  if ((int )c == 102) {
#line 253
    goto case_102;
  }
#line 254
  if ((int )c == 110) {
#line 254
    goto case_110;
  }
#line 255
  if ((int )c == 114) {
#line 255
    goto case_114;
  }
#line 256
  if ((int )c == 116) {
#line 256
    goto case_116;
  }
#line 257
  if ((int )c == 118) {
#line 257
    goto case_118;
  }
#line 250
  goto switch_break;
  case_97: /* CIL Label */ 
#line 251
  c = (char )'\a';
#line 251
  goto switch_break;
  case_98: /* CIL Label */ 
#line 252
  c = (char )'\b';
#line 252
  goto switch_break;
  case_102: /* CIL Label */ 
#line 253
  c = (char )'\f';
#line 253
  goto switch_break;
  case_110: /* CIL Label */ 
#line 254
  c = (char )'\n';
#line 254
  goto switch_break;
  case_114: /* CIL Label */ 
#line 255
  c = (char )'\r';
#line 255
  goto switch_break;
  case_116: /* CIL Label */ 
#line 256
  c = (char )'\t';
#line 256
  goto switch_break;
  case_118: /* CIL Label */ 
#line 257
  c = (char )'\v';
#line 257
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 259
  return (c);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
int simplematch(char *text , char *pattern , int nocase ) 
{ 
  char *retrypat ;
  char *retrytxt ;
  unsigned char c ;
  unsigned char c1 ;
  unsigned char c2 ;
  int notfound ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char tmp___12 ;
  int tmp___13 ;

  {
#line 267
  retrypat = (char *)((void *)0);
#line 271
  retrytxt = text;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! *text) {
#line 273
      if (! *pattern) {
#line 273
        goto while_break;
      }
    }
#line 274
    tmp = pattern;
#line 274
    pattern ++;
#line 274
    c = (unsigned char )*tmp;
#line 275
    if (nocase) {
      {
#line 275
      tmp___0 = tolower((int )c);
#line 275
      c = (unsigned char )tmp___0;
      }
    }
    {
#line 278
    if ((int )c == 42) {
#line 278
      goto case_42;
    }
#line 282
    if ((int )c == 91) {
#line 282
      goto case_91;
    }
#line 307
    if ((int )c == 63) {
#line 307
      goto case_63;
    }
#line 310
    if ((int )c == 92) {
#line 310
      goto case_92;
    }
#line 313
    goto switch_default;
    case_42: /* CIL Label */ 
#line 279
    retrypat = pattern;
#line 280
    retrytxt = text;
#line 281
    goto switch_break;
    case_91: /* CIL Label */ 
#line 283
    notfound = 1;
#line 284
    if ((int )*pattern == 94) {
#line 285
      notfound = 0;
#line 286
      pattern ++;
    }
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 288
      tmp___9 = pattern;
#line 288
      pattern ++;
#line 288
      c = (unsigned char )*tmp___9;
#line 288
      if (! ((int )c != 93)) {
#line 288
        goto while_break___0;
      }
#line 289
      if ((int )c == 92) {
        {
#line 289
        tmp___1 = pattern;
#line 289
        pattern ++;
#line 289
        tmp___2 = sm_escchar(*tmp___1);
#line 289
        c = (unsigned char )tmp___2;
        }
      }
#line 290
      if ((int )c == 0) {
#line 290
        return (-1);
      }
#line 291
      if ((int )*pattern == 45) {
#line 292
        c1 = c;
#line 293
        pattern ++;
#line 293
        c2 = (unsigned char )*pattern;
#line 294
        if ((int )c2 == 93) {
#line 294
          return (-1);
        } else
#line 294
        if ((int )c2 == 0) {
#line 294
          return (-1);
        } else
#line 294
        if ((int )c1 == 91) {
#line 294
          return (-1);
        }
#line 295
        if ((int )*text >= (int )c1) {
#line 295
          if ((int )*text <= (int )c2) {
#line 298
            notfound = ! notfound;
          } else {
#line 295
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 295
          tmp___3 = tolower((int )*text);
#line 295
          tmp___4 = tolower((int )c1);
          }
#line 295
          if (tmp___3 >= tmp___4) {
            {
#line 295
            tmp___5 = tolower((int )*text);
#line 295
            tmp___6 = tolower((int )c2);
            }
#line 295
            if (tmp___5 <= tmp___6) {
#line 295
              if (nocase) {
#line 298
                notfound = ! notfound;
              }
            }
          }
        }
#line 299
        pattern ++;
      } else
#line 300
      if ((int )*text == (int )c) {
#line 301
        notfound = ! notfound;
      } else
#line 300
      if (nocase) {
        {
#line 300
        tmp___7 = tolower((int )*text);
#line 300
        tmp___8 = tolower((int )c);
        }
#line 300
        if (tmp___7 == tmp___8) {
#line 301
          notfound = ! notfound;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    if (notfound) {
#line 304
      pattern = retrypat;
#line 305
      retrytxt ++;
#line 305
      text = retrytxt;
    }
    case_63: /* CIL Label */ 
#line 308
    tmp___10 = text;
#line 308
    text ++;
#line 308
    if ((int )*tmp___10 == 0) {
#line 308
      return (0);
    }
#line 309
    goto switch_break;
    case_92: /* CIL Label */ 
    {
#line 311
    tmp___11 = pattern;
#line 311
    pattern ++;
#line 311
    tmp___12 = sm_escchar(*tmp___11);
#line 311
    c = (unsigned char )tmp___12;
    }
#line 312
    if ((int )c == 0) {
#line 312
      return (-1);
    }
    switch_default: /* CIL Label */ 
#line 314
    if ((int )*text == (int )c) {
#line 314
      goto _L___0;
    } else
#line 314
    if (nocase) {
      {
#line 314
      tmp___13 = tolower((int )*text);
      }
#line 314
      if (tmp___13 == (int )c) {
        _L___0: /* CIL Label */ 
#line 315
        if (*text) {
#line 315
          text ++;
        }
      } else {
#line 314
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 317
    if (*text) {
#line 318
      pattern = retrypat;
#line 319
      retrytxt ++;
#line 319
      text = retrytxt;
    } else {
#line 321
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
#line 325
    if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 325
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return (1);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/string.c"
char *sfgetl(char *s , int z , FILE *f ) 
{ 
  char *S ;
  int c ;
  size_t tmp ;

  {
  {
#line 398
  S = fgets((char */* __restrict  */)s, z, (FILE */* __restrict  */)f);
  }
#line 401
  if (S) {
#line 401
    if (*s) {
      {
#line 401
      tmp = strlen((char const   *)s);
      }
#line 401
      if ((int )*(s + (tmp - 1UL)) != 10) {
        {
#line 402
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 403
          c = fgetc(f);
          }
#line 402
          if (c != -1) {
#line 402
            if (c != 10) {
#line 402
              if (! (c != 0)) {
#line 402
                goto while_break;
              }
            } else {
#line 402
              goto while_break;
            }
          } else {
#line 402
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 407
  return (S);
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.h"
void iso2uni(pstr_t *uni , char *iso ) ;
#line 47
void uni2utf(char *utf , pstr_t *uni ) ;
#line 50
void utf2uni(pstr_t *uni , char *utf ) ;
#line 53
void add_char(int fnf , char *iso , char *show , char *shell , char c , int *flags ) ;
#line 56
void decode_mbase64(pstr_t *outstring , char *instring ) ;
#line 59
void encode_mbase64(char *outstring , pstr_t *instring ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
int utf2iso(int fnf , char *iso , char *show , char *shell , char *utf ) 
{ 
  int ucc ;
  int flags ;
  char *cp ;
  char *cp2 ;
  char *cp3 ;
  char mbase_part[12288] ;
  pstr_t *uni_part ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 52
  flags = 0;
#line 59
  if (iso) {
#line 59
    *iso = (char)0;
  }
#line 60
  if (show) {
#line 60
    *show = (char)0;
  }
#line 61
  if (shell) {
#line 61
    *shell = (char)0;
  }
  {
#line 62
  uni_part = pstr_create(8192);
#line 65
  cp = utf;
#line 65
  cp2 = utf + 1;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((int )*cp != 0)) {
#line 65
      goto while_break;
    }
#line 68
    if ((int )*cp == 43) {
#line 71
      if ((int )*cp2 == 45) {
#line 71
        goto _L;
      } else
#line 71
      if ((int )*cp2 == 0) {
        _L: /* CIL Label */ 
#line 73
        if (iso) {
          {
#line 73
          strcat((char */* __restrict  */)iso, (char const   */* __restrict  */)"+");
          }
        }
#line 74
        if (show) {
          {
#line 74
          strcat((char */* __restrict  */)show, (char const   */* __restrict  */)"+");
          }
        }
#line 75
        if (shell) {
          {
#line 75
          strcat((char */* __restrict  */)shell, (char const   */* __restrict  */)"+");
          }
        }
#line 78
        if ((int )*cp2 != 0) {
#line 79
          cp ++;
#line 80
          cp2 ++;
        }
      } else {
#line 86
        cp3 = cp2;
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (! ((int )*cp3 != 45)) {
#line 86
            goto while_break___0;
          }
#line 86
          cp3 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 89
        mbase_part[0] = (char)0;
#line 90
        strncat((char */* __restrict  */)(mbase_part), (char const   */* __restrict  */)cp2,
                (size_t )(cp3 - cp2));
#line 93
        decode_mbase64(uni_part, mbase_part);
#line 96
        ucc = 1;
        }
        {
#line 96
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 96
          if (! (ucc <= uni_part->length)) {
#line 96
            goto while_break___1;
          }
#line 99
          if ((int )*(uni_part->string + ucc) == 0) {
            {
#line 100
            add_char(fnf, iso, show, shell, *(uni_part->string + (ucc + 1)), & flags);
            }
          } else {
#line 104
            flags |= 1;
#line 105
            if (iso) {
              {
#line 105
              strcat((char */* __restrict  */)iso, (char const   */* __restrict  */)"_");
              }
            }
#line 106
            if (show) {
              {
#line 106
              strcat((char */* __restrict  */)show, (char const   */* __restrict  */)"_");
              }
            }
#line 107
            if (shell) {
              {
#line 107
              strcat((char */* __restrict  */)shell, (char const   */* __restrict  */)"_");
              }
            }
          }
#line 96
          ucc += 2;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 112
        cp = cp3;
#line 113
        cp3 ++;
#line 113
        cp2 = cp3;
      }
    } else {
      {
#line 119
      add_char(fnf, iso, show, shell, *cp, & flags);
      }
    }
#line 65
    cp ++;
#line 65
    cp2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if (fnf) {
#line 124
    if (iso) {
      {
#line 124
      tmp = strcmp((char const   *)iso, ".");
      }
#line 124
      if (tmp == 0) {
        {
#line 125
        strcpy((char */* __restrict  */)iso, (char const   */* __restrict  */)"_");
#line 126
        flags |= 1;
        }
      }
    }
#line 128
    if (show) {
      {
#line 128
      tmp___0 = strcmp((char const   *)show, ".");
      }
#line 128
      if (tmp___0 == 0) {
        {
#line 129
        strcpy((char */* __restrict  */)show, (char const   */* __restrict  */)"_");
#line 130
        flags |= 1;
        }
      }
    }
#line 132
    if (shell) {
      {
#line 132
      tmp___1 = strcmp((char const   *)shell, ".");
      }
#line 132
      if (tmp___1 == 0) {
        {
#line 133
        strcpy((char */* __restrict  */)shell, (char const   */* __restrict  */)"_");
#line 134
        flags |= 1;
        }
      }
    }
#line 136
    if (iso) {
      {
#line 136
      tmp___2 = strcmp((char const   *)iso, "..");
      }
#line 136
      if (tmp___2 == 0) {
        {
#line 137
        strcpy((char */* __restrict  */)iso, (char const   */* __restrict  */)"__");
#line 138
        flags |= 1;
        }
      }
    }
#line 140
    if (show) {
      {
#line 140
      tmp___3 = strcmp((char const   *)show, "..");
      }
#line 140
      if (tmp___3 == 0) {
        {
#line 141
        strcpy((char */* __restrict  */)show, (char const   */* __restrict  */)"__");
#line 142
        flags |= 1;
        }
      }
    }
#line 144
    if (shell) {
      {
#line 144
      tmp___4 = strcmp((char const   *)shell, "..");
      }
#line 144
      if (tmp___4 == 0) {
        {
#line 145
        strcpy((char */* __restrict  */)shell, (char const   */* __restrict  */)"__");
#line 146
        flags |= 1;
        }
      }
    }
  }
  {
#line 151
  pstr_delete(uni_part);
  }
#line 153
  return (flags);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void add_char(int fnf , char *iso , char *show , char *shell , char c , int *flags ) 
{ 
  unsigned char sc[2] ;
  char const   *meta ;
  char *tmp ;

  {
#line 171
  meta = "\"!#$&\'()*?\\`| ";
#line 174
  sc[0] = (unsigned char )c;
#line 175
  sc[1] = (unsigned char)0;
#line 178
  if ((int )sc[0] == 0) {
#line 179
    *flags |= 1;
#line 180
    sc[0] = (unsigned char )'_';
  } else
#line 178
  if ((int )sc[0] == 47) {
#line 178
    if (fnf) {
#line 179
      *flags |= 1;
#line 180
      sc[0] = (unsigned char )'_';
    }
  }
#line 184
  if (iso) {
    {
#line 184
    strcat((char */* __restrict  */)iso, (char const   */* __restrict  */)((char *)(sc)));
    }
  }
#line 187
  if ((int )sc[0] < 32) {
#line 188
    *flags |= 2;
#line 189
    sc[0] = (unsigned char )'_';
  } else
#line 187
  if ((int )sc[0] > 126) {
#line 187
    if ((int )sc[0] < 161) {
#line 188
      *flags |= 2;
#line 189
      sc[0] = (unsigned char )'_';
    }
  }
#line 193
  if (show) {
    {
#line 193
    strcat((char */* __restrict  */)show, (char const   */* __restrict  */)((char *)(sc)));
    }
  }
  {
#line 196
  tmp = strchr(meta, (int )*((char *)(sc)));
  }
#line 196
  if (tmp) {
#line 197
    *flags |= 2;
#line 198
    sc[0] = (unsigned char )'_';
  }
#line 202
  if (shell) {
    {
#line 202
    strcat((char */* __restrict  */)shell, (char const   */* __restrict  */)((char *)(sc)));
    }
  }
#line 203
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void iso2utf(char *utf_name , char *iso_name ) 
{ 


  {
  {
#line 214
  iso2utf7(utf_name, iso_name, 1);
  }
#line 215
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void iso2utf7(char *utf_name , char *iso_name , int withspace ) 
{ 
  char *cp ;
  char *cp2 ;
  char *DO_set ;
  char iso_part[4096] ;
  char mbase_part[12288] ;
  pstr_t *uni_part ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 227
  DO_set = (char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\'(),-./:?!\"#$%&*;<>@[]^_`{}|";
#line 237
  *(utf_name + 0) = (char)0;
#line 238
  uni_part = pstr_create(8192);
#line 241
  cp = iso_name;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((int )*cp != 0)) {
#line 241
      goto while_break;
    }
    {
#line 244
    tmp___0 = strchr((char const   *)DO_set, (int )*cp);
    }
#line 244
    if (tmp___0) {
      {
#line 246
      strncat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)cp,
              (size_t )1);
      }
    } else
#line 244
    if ((unsigned long )cp != (unsigned long )iso_name) {
#line 244
      if (*(cp + 1)) {
#line 244
        if (withspace) {
#line 244
          if ((int )*cp == 32) {
#line 244
            if ((int )*(cp + 1) != 32) {
              {
#line 246
              strncat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)cp,
                      (size_t )1);
              }
            } else {
#line 244
              goto _L___2;
            }
          } else {
#line 244
            goto _L___2;
          }
        } else {
#line 244
          goto _L___2;
        }
      } else {
#line 244
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 250
      strcat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)"+");
      }
#line 253
      if ((int )*cp == 43) {
        {
#line 254
        strcat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)"-");
        }
      } else {
#line 258
        cp2 = cp;
#line 259
        cp2 ++;
        {
#line 260
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 260
          tmp = strchr((char const   *)DO_set, (int )*cp2);
          }
#line 260
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 260
            if (! ((int )*cp2 != 0)) {
#line 260
              goto while_break___0;
            }
          } else {
#line 260
            goto while_break___0;
          }
#line 260
          cp2 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 264
        iso_part[0] = (char)0;
#line 265
        strncat((char */* __restrict  */)(iso_part), (char const   */* __restrict  */)cp,
                (size_t )(cp2 - cp));
#line 268
        iso2uni(uni_part, iso_part);
#line 271
        encode_mbase64(mbase_part, uni_part);
#line 274
        strcat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)(mbase_part));
#line 275
        strcat((char */* __restrict  */)utf_name, (char const   */* __restrict  */)"-");
#line 276
        cp = cp2 - 1;
        }
      }
    }
#line 241
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  pstr_delete(uni_part);
  }
#line 284
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void uni2utf(char *utf , pstr_t *uni ) 
{ 


  {
  {
#line 297
  encode_mbase64(utf + 1, uni);
#line 300
  *(utf + 0) = (char )'+';
#line 301
  strcat((char */* __restrict  */)utf, (char const   */* __restrict  */)"-");
  }
#line 302
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void utf2uni(pstr_t *uni , char *utf ) 
{ 
  char *cp ;
  char *cp2 ;
  char *cp3 ;
  char mbase_part[12288] ;
  pstr_t *uni_part ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 317
  uni_part = pstr_create(8192);
#line 320
  cp = utf;
#line 320
  cp2 = utf + 1;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ((int )*cp != 0)) {
#line 320
      goto while_break;
    }
#line 323
    if ((int )*cp == 43) {
#line 326
      if ((int )*cp2 == 45) {
#line 326
        goto _L;
      } else
#line 326
      if ((int )*cp2 == 0) {
        _L: /* CIL Label */ 
        {
#line 328
        tmp = pstr_addchar(uni, (char)0);
        }
#line 328
        if (tmp < 0) {
#line 328
          return;
        }
        {
#line 329
        tmp___0 = pstr_addchar(uni, (char )'+');
        }
#line 329
        if (tmp___0 < 0) {
#line 329
          return;
        }
#line 332
        if ((int )*cp2 != 0) {
#line 333
          cp ++;
#line 334
          cp2 ++;
        }
      } else {
#line 340
        cp3 = cp2;
        {
#line 340
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 340
          if (! ((int )*cp3 != 45)) {
#line 340
            goto while_break___0;
          }
#line 340
          cp3 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 343
        mbase_part[0] = (char)0;
#line 344
        strncat((char */* __restrict  */)(mbase_part), (char const   */* __restrict  */)cp2,
                (size_t )(cp3 - cp2));
#line 347
        decode_mbase64(uni_part, mbase_part);
#line 350
        tmp___1 = pstr_addpstring(uni, (pstr_t const   *)uni_part);
        }
#line 350
        if (tmp___1 < 0) {
#line 350
          return;
        }
#line 353
        cp = cp3;
#line 354
        cp3 ++;
#line 354
        cp2 = cp3;
      }
    } else {
      {
#line 361
      tmp___2 = pstr_addchar(uni, (char)0);
      }
#line 361
      if (tmp___2 < 0) {
#line 361
        return;
      }
      {
#line 362
      tmp___3 = pstr_addchar(uni, *cp);
      }
#line 362
      if (tmp___3 < 0) {
#line 362
        return;
      }
    }
#line 320
    cp ++;
#line 320
    cp2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 368
  pstr_delete(uni_part);
  }
#line 369
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void iso2uni(pstr_t *uni , char *iso ) 
{ 
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 383
  uni->length = 0;
#line 386
  cp = iso;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! ((int )*cp != 0)) {
#line 386
      goto while_break;
    }
    {
#line 389
    tmp = pstr_addchar(uni, (char)0);
    }
#line 389
    if (tmp < 0) {
#line 389
      return;
    }
    {
#line 392
    tmp___0 = pstr_addchar(uni, *cp);
    }
#line 392
    if (tmp___0 < 0) {
#line 392
      return;
    }
#line 386
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
static char vec[66]  = 
#line 420
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'=',      (char )'\000'};
#line 416 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void decode_mbase64(pstr_t *outstring , char *instring ) 
{ 
  int i ;
  int j ;
  int num ;
  int len ;
  int err ;
  long d ;
  long val ;
  char *p ;
  char *c ;
  unsigned char nw[4] ;
  size_t tmp ;

  {
  {
#line 424
  outstring->length = 0;
#line 425
  tmp = strlen((char const   *)instring);
#line 425
  len = (int )tmp;
#line 426
  strcat((char */* __restrict  */)instring, (char const   */* __restrict  */)"==");
#line 427
  i = 0;
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < len - 1)) {
#line 427
      goto while_break;
    }
#line 428
    err = 0;
#line 429
    val = 0L;
#line 430
    num = 3;
#line 431
    c = instring + i;
#line 432
    if ((int )*(c + 2) == 61) {
#line 432
      num = 1;
    }
#line 433
    if ((int )*(c + 3) == 61) {
#line 433
      num = 2;
    }
#line 434
    j = 0;
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 434
      if (! (j <= num)) {
#line 434
        goto while_break___0;
      }
      {
#line 435
      p = strchr((char const   *)(vec), (int )*(c + j));
      }
#line 435
      if (! p) {
#line 436
        err = 1;
#line 437
        goto while_break___0;
      }
#line 439
      d = p - vec;
#line 440
      d <<= (3 - j) * 6;
#line 441
      val += d;
#line 434
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 443
    if (err) {
#line 443
      goto __Cont;
    }
#line 444
    j = 2;
    {
#line 444
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 444
      if (! (j >= 0)) {
#line 444
        goto while_break___1;
      }
#line 445
      nw[j] = (unsigned char )(val & 255L);
#line 446
      val >>= 8;
#line 444
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 448
    j = 0;
    {
#line 448
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 448
      if (! (j < num)) {
#line 448
        goto while_break___2;
      }
      {
#line 448
      pstr_addchar(outstring, (char )nw[j]);
#line 448
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 427
    i += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if ((double )(outstring->length / 2) != (double )outstring->length / 2.) {
#line 450
    (outstring->length) --;
  }
#line 451
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
static char vec___0[66]  = 
#line 459
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'=',      (char )'\000'};
#line 454 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/utf7.c"
void encode_mbase64(char *outstring , pstr_t *instring ) 
{ 
  int n ;
  int iz ;
  int oz ;
  int i ;
  unsigned char c ;
  long val ;
  unsigned char enc[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 455
  n = 0;
#line 455
  oz = 0;
#line 457
  val = 0L;
#line 462
  iz = 1;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (iz <= instring->length)) {
#line 462
      goto while_break;
    }
#line 463
    c = (unsigned char )*(instring->string + iz);
#line 464
    tmp = n;
#line 464
    n ++;
#line 464
    if (tmp <= 2) {
#line 465
      val <<= 8;
#line 466
      val += (long )c;
#line 467
      goto __Cont;
    }
#line 469
    i = 0;
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (! (i < 4)) {
#line 469
        goto while_break___0;
      }
#line 470
      enc[i] = (unsigned char )(val & 63L);
#line 471
      val >>= 6;
#line 469
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 473
    i = 3;
    {
#line 473
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 473
      if (! (i >= 0)) {
#line 473
        goto while_break___1;
      }
#line 473
      tmp___0 = oz;
#line 473
      oz ++;
#line 473
      *(outstring + tmp___0) = vec___0[(int )enc[i]];
#line 473
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 474
    n = 1;
#line 475
    val = (long )c;
    __Cont: /* CIL Label */ 
#line 462
    iz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  if (n == 1) {
#line 478
    val <<= 16;
#line 479
    i = 0;
    {
#line 479
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 479
      if (! (i < 4)) {
#line 479
        goto while_break___2;
      }
#line 480
      enc[i] = (unsigned char )(val & 63L);
#line 481
      val >>= 6;
#line 479
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 483
    enc[1] = (unsigned char)64;
#line 483
    enc[0] = enc[1];
  }
#line 485
  if (n == 2) {
#line 486
    val <<= 8;
#line 487
    i = 0;
    {
#line 487
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 487
      if (! (i < 4)) {
#line 487
        goto while_break___3;
      }
#line 488
      enc[i] = (unsigned char )(val & 63L);
#line 489
      val >>= 6;
#line 487
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 491
    enc[0] = (unsigned char)64;
  }
#line 493
  if (n == 3) {
#line 494
    i = 0;
    {
#line 494
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 494
      if (! (i < 4)) {
#line 494
        goto while_break___4;
      }
#line 495
      enc[i] = (unsigned char )(val & 63L);
#line 496
      val >>= 6;
#line 494
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 498
  if (n) {
#line 499
    i = 3;
    {
#line 499
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 499
      if (! (i >= 0)) {
#line 499
        goto while_break___5;
      }
#line 500
      c = (unsigned char )vec___0[(int )enc[i]];
#line 501
      if ((int )c != 61) {
#line 501
        tmp___1 = oz;
#line 501
        oz ++;
#line 501
        *(outstring + tmp___1) = (char )c;
      }
#line 499
      i --;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 503
  *(outstring + oz) = (char)0;
#line 504
  return;
}
}
#line 283 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 195 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode )  __asm__("creat64")  ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.h"
int readn(int fd , char *ptr , int nbytes ) ;
#line 42
int writen(int fd , char *ptr , int nbytes ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
int readn(int fd , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nread ;
  ssize_t tmp ;

  {
#line 66
  nleft = nbytes;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (nleft > 0)) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = read(fd, (void *)ptr, (size_t )nleft);
#line 68
    nread = (int )tmp;
    }
#line 69
    if (nread < 0) {
#line 70
      return (nread);
    } else
#line 72
    if (nread == 0) {
#line 72
      goto while_break;
    }
#line 73
    nleft -= nread;
#line 74
    ptr += nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (nbytes - nleft);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
int writen(int fd , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  ssize_t tmp ;

  {
#line 95
  nleft = nbytes;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (nleft > 0)) {
#line 96
      goto while_break;
    }
    {
#line 97
    tmp = write(fd, (void const   *)ptr, (size_t )nleft);
#line 97
    nwritten = (int )tmp;
    }
#line 98
    if (nwritten < 0) {
#line 98
      return (nwritten);
    }
#line 99
    nleft -= nwritten;
#line 100
    ptr += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (nbytes - nleft);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
int fcopy(char const   *from , char const   *to , mode_t mode ) 
{ 
  int fdin ;
  int fdout ;
  int rbytes ;
  int wbytes ;
  char tmp[4096] ;
  char *buf ;
  struct stat finfo ;
  off_t fsize ;
  off_t wtotal ;
  long blksize ;
  int tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 131
  wtotal = (off_t )0;
#line 134
  tmp___0 = stat((char const   */* __restrict  */)from, (struct stat */* __restrict  */)(& finfo));
  }
#line 134
  if (tmp___0 < 0) {
    {
#line 135
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot access \'%s\'",
             from);
#line 136
    message((char *)"", (char )'E', (char const   *)(tmp));
    }
#line 137
    return (-1);
  }
  {
#line 139
  fsize = finfo.st_size;
#line 141
  blksize = finfo.st_blksize;
#line 148
  fdin = open(from, 0, 0);
  }
#line 149
  if (fdin < 0) {
    {
#line 150
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error opening \'%s\'",
             from);
#line 151
    message((char *)"", (char )'E', (char const   *)(tmp));
    }
#line 152
    return (-1);
  }
#line 156
  if (*to) {
    {
#line 159
    fdout = creat(to, mode);
    }
#line 160
    if (fdout < 0) {
      {
#line 161
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error creating \'%s\'",
               to);
#line 162
      message((char *)"", (char )'E', (char const   *)(tmp));
#line 163
      close(fdin);
      }
#line 164
      return (-1);
    }
    {
#line 169
    tmp___1 = malloc((size_t )blksize);
#line 169
    buf = (char *)tmp___1;
    }
#line 170
    if (! buf) {
      {
#line 170
      message((char *)"", (char )'F', "out of memory");
      }
    }
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 173
      tmp___3 = read(fdin, (void *)buf, (size_t )blksize);
#line 173
      rbytes = (int )tmp___3;
      }
#line 173
      if (! (rbytes > 0)) {
#line 173
        goto while_break;
      }
      {
#line 176
      tmp___2 = write(fdout, (void const   *)buf, (size_t )rbytes);
#line 176
      wbytes = (int )tmp___2;
      }
#line 177
      if (wbytes != rbytes) {
        {
#line 180
        close(fdin);
#line 181
        close(fdout);
#line 182
        free((void *)buf);
#line 183
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error writing \'%s\'",
                 to);
#line 184
        message((char *)"", (char )'E', (char const   *)(tmp));
        }
#line 185
        return (-1);
      }
#line 188
      wtotal += (off_t )wbytes;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 192
    close(fdout);
    }
  } else {
    {
#line 197
    tmp___4 = malloc((size_t )blksize);
#line 197
    buf = (char *)tmp___4;
    }
#line 198
    if (! buf) {
      {
#line 198
      message((char *)"", (char )'F', "out of memory");
      }
    }
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 201
      tmp___7 = read(fdin, (void *)buf, (size_t )blksize);
#line 201
      rbytes = (int )tmp___7;
      }
#line 201
      if (! (rbytes > 0)) {
#line 201
        goto while_break___0;
      }
      {
#line 204
      tmp___5 = fileno(stdout);
#line 204
      tmp___6 = write(tmp___5, (void const   *)buf, (size_t )rbytes);
#line 204
      wbytes = (int )tmp___6;
#line 205
      wtotal += (off_t )wbytes;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 210
  close(fdin);
#line 211
  free((void *)buf);
  }
#line 214
  if (rbytes < 0) {
    {
#line 215
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error reading \'%s\'",
             from);
#line 216
    message((char *)"", (char )'E', (char const   *)(tmp));
    }
#line 217
    return (-1);
  }
#line 221
  if (fsize != wtotal) {
    {
#line 222
    tmp___8 = __errno_location();
#line 222
    *tmp___8 = 0;
#line 223
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"wrong byte count for \'%s\'",
             from);
#line 224
    message((char *)"", (char )'E', (char const   *)(tmp));
    }
#line 225
    return (-1);
  }
#line 228
  return (0);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
static char filepath[4096]  ;
#line 239 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
char *whereis(char *prg___0 ) 
{ 
  int len ;
  char *path ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 246
  tmp___0 = strchr((char const   *)prg___0, '/');
  }
#line 246
  if (tmp___0) {
    {
#line 247
    tmp = access((char const   *)prg___0, 1);
    }
#line 247
    if (tmp == 0) {
#line 248
      return (prg___0);
    } else {
#line 250
      return ((char *)((void *)0));
    }
  }
  {
#line 253
  tmp___1 = strlen((char const   *)prg___0);
#line 253
  len = (int )tmp___1;
#line 254
  path = getenv("PATH");
  }
#line 255
  if (! path) {
#line 255
    return ((char *)((void *)0));
  } else {
    {
#line 255
    tmp___2 = strchr((char const   *)path, '/');
    }
#line 255
    if (! tmp___2) {
#line 255
      return ((char *)((void *)0));
    }
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! ((int )*path == 58)) {
#line 257
      goto while_break;
    }
#line 257
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! *path) {
#line 259
      goto while_break___0;
    }
    {
#line 260
    snprintf((char */* __restrict  */)(filepath), (size_t )(4094 - len), (char const   */* __restrict  */)"%s",
             path);
#line 261
    cp = strchr((char const   *)(filepath), ':');
    }
#line 261
    if (cp) {
#line 261
      *cp = (char)0;
    }
    {
#line 262
    strcat((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"/");
#line 263
    strcat((char */* __restrict  */)(filepath), (char const   */* __restrict  */)prg___0);
#line 264
    tmp___3 = access((char const   *)(filepath), 1);
    }
#line 264
    if (tmp___3 == 0) {
#line 264
      return (filepath);
    }
    {
#line 265
    cp = strchr((char const   *)path, ':');
    }
#line 265
    if (cp) {
#line 266
      path = cp + 1;
    } else {
#line 268
      return ((char *)((void *)0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  return ((char *)((void *)0));
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
FILE *rfopen(char const   *file , char const   *mode ) 
{ 
  struct stat finfo ;
  FILE *tmp ;
  int *tmp___0 ;
  FILE *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 288
  tmp___3 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& finfo));
  }
#line 288
  if (tmp___3 < 0) {
    {
#line 291
    tmp___0 = __errno_location();
    }
#line 291
    if (*tmp___0 == 2) {
      {
#line 292
      tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
      }
#line 292
      return (tmp);
    } else {
#line 295
      return ((FILE *)((void *)0));
    }
  } else
#line 300
  if (finfo.st_mode & 32768U) {
    {
#line 301
    tmp___1 = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)mode);
    }
#line 301
    return (tmp___1);
  } else {
    {
#line 303
    tmp___2 = __errno_location();
#line 303
    *tmp___2 = 5;
    }
#line 304
    return ((FILE *)((void *)0));
  }
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
static char tmpdir___0[256]  ;
#line 320 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
char *mktmpdir(int verbose___0 ) 
{ 
  char *cp ;
  char tmp[4096] ;
  time_t tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 326
  cp = getenv("SF_TMPDIR");
  }
#line 326
  if (cp) {
    {
#line 327
    snprintf((char */* __restrict  */)(tmpdir___0), (size_t )226, (char const   */* __restrict  */)"%s",
             cp);
    }
  } else {
    {
#line 328
    cp = getenv("TMPDIR");
    }
#line 328
    if (cp) {
      {
#line 329
      snprintf((char */* __restrict  */)(tmpdir___0), (size_t )226, (char const   */* __restrict  */)"%s",
               cp);
      }
    } else {
      {
#line 331
      strcpy((char */* __restrict  */)(tmpdir___0), (char const   */* __restrict  */)"/tmp");
      }
    }
  }
  {
#line 333
  tmp___0 = time((time_t *)((void *)0));
#line 333
  tmp___1 = getpid();
#line 333
  snprintf((char */* __restrict  */)(tmp), (size_t )30, (char const   */* __restrict  */)"/sf_%u.tmp",
           (unsigned int )(tmp___0 * (time_t )tmp___1));
#line 334
  strcat((char */* __restrict  */)(tmpdir___0), (char const   */* __restrict  */)(tmp));
#line 336
  tmp___2 = mkdir((char const   *)(tmpdir___0), (__mode_t )448);
  }
#line 336
  if (tmp___2 < 0) {
    {
#line 337
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot create tmpdir %s",
             tmpdir___0);
#line 338
    message((char *)"", (char )'F', (char const   *)(tmp));
    }
  } else {
    {
#line 336
    tmp___3 = chmod((char const   *)(tmpdir___0), (__mode_t )448);
    }
#line 336
    if (tmp___3 < 0) {
      {
#line 337
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot create tmpdir %s",
               tmpdir___0);
#line 338
      message((char *)"", (char )'F', (char const   *)(tmp));
      }
    }
  }
#line 341
  if (verbose___0) {
    {
#line 342
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"directory for temporary files is: %s",
             tmpdir___0);
#line 343
    message((char *)"", (char )'I', (char const   *)(tmp));
    }
  }
#line 346
  return (tmpdir___0);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
void rmtmpdir(char *tmpdir___1 ) 
{ 
  char cwd[256] ;
  char tmp[4096] ;
  struct dirent *dire ;
  DIR *dp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 359
  dp = (DIR *)((void *)0);
#line 361
  if (! tmpdir___1) {
#line 361
    return;
  } else
#line 361
  if (! *tmpdir___1) {
#line 361
    return;
  }
  {
#line 363
  tmp___0 = getcwd(cwd, sizeof(cwd) - 1UL);
  }
#line 363
  if (! tmp___0) {
    {
#line 363
    strcpy((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/tmp");
    }
  }
  {
#line 366
  tmp___1 = chdir((char const   *)tmpdir___1);
  }
#line 366
  if (tmp___1 < 0) {
#line 371
    return;
  } else {
    {
#line 366
    dp = opendir((char const   *)tmpdir___1);
    }
#line 366
    if (! dp) {
#line 371
      return;
    }
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 374
    dire = readdir(dp);
    }
#line 374
    if (! dire) {
#line 374
      goto while_break;
    }
    {
#line 377
    tmp___2 = strcmp((char const   *)(dire->d_name), ".");
    }
#line 377
    if (tmp___2 == 0) {
#line 377
      goto while_continue;
    } else {
      {
#line 377
      tmp___3 = strcmp((char const   *)(dire->d_name), "..");
      }
#line 377
      if (tmp___3 == 0) {
#line 377
        goto while_continue;
      }
    }
    {
#line 380
    tmp___4 = unlink((char const   *)(dire->d_name));
    }
#line 380
    if (tmp___4 < 0) {
      {
#line 381
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot remove %s/%s",
               tmpdir___1, dire->d_name);
#line 382
      message((char *)"", (char )'W', (char const   *)(tmp));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 387
  chdir((char const   *)(cwd));
#line 388
  tmp___5 = rmdir((char const   *)tmpdir___1);
  }
#line 388
  if (tmp___5 < 0) {
    {
#line 389
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot remove %s",
             tmpdir___1);
#line 390
    message((char *)"", (char )'X', (char const   *)(tmp));
    }
  }
#line 393
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
int spawn(char **sad , char const   *output , mode_t cmask ) 
{ 
  int status ;
  int fd ;
  pid_t pid ;
  int *tmp ;

  {
  {
#line 423
  pid = fork();
  }
#line 426
  if (pid < 0) {
    {
#line 427
    message((char *)"", (char )'E', "cannot fork subprocess");
    }
#line 428
    return (-1);
  }
#line 432
  if (pid == 0) {
#line 435
    if (output) {
      {
#line 438
      close(1);
#line 441
      fd = creat(output, 438U & ~ cmask);
      }
#line 442
      if (fd != 1) {
        {
#line 443
        tmp = __errno_location();
#line 443
        *tmp = 0;
#line 444
        message((char *)"", (char )'E', "file descriptor mismatch");
#line 445
        cleanup();
#line 446
        exit(1);
        }
      }
    }
    {
#line 452
    execvp((char const   *)*(sad + 0), (char * const  *)sad);
#line 455
    message((char *)"", (char )'F', "execvp() failed!");
#line 456
    cleanup();
#line 457
    exit(2);
    }
  }
  {
#line 464
  waitpid(pid, & status, 0);
  }
#line 468
  if (status) {
#line 468
    return (-1);
  }
#line 470
  return (0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
int vsystem(char const   *cmd ) 
{ 
  char tmp[4096] ;
  int tmp___0 ;

  {
#line 485
  if (verbose) {
    {
#line 486
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s\n",
             cmd);
#line 487
    message(prg, (char )'I', (char const   *)(tmp));
    }
  }
  {
#line 489
  tmp___0 = system(cmd);
  }
#line 489
  return (tmp___0);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
FILE *vpopen(char const   *cmd , char const   *type ) 
{ 
  char tmp[4096] ;
  FILE *tmp___0 ;

  {
#line 506
  if (verbose) {
#line 507
    tmp[0] = (char)0;
    {
#line 509
    if ((int const   )*type == 114) {
#line 509
      goto case_114;
    }
#line 510
    if ((int const   )*type == 119) {
#line 510
      goto case_119;
    }
#line 508
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 509
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: %s|",
             cmd);
    }
#line 509
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 510
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"shell-call: |%s",
             cmd);
    }
#line 510
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 512
    message(prg, (char )'I', (char const   *)(tmp));
    }
  }
  {
#line 514
  tmp___0 = popen(cmd, type);
  }
#line 514
  return (tmp___0);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
static char quoted[4096]  ;
#line 527 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/io.c"
char *shell_quote(char const   *string ) 
{ 
  char const   *special ;
  char const   *sp ;
  char *qp ;
  char *tmp ;

  {
#line 529
  special = " [](){}<>?*~#$&|;\'\n\t\v\b\r\f\a\"\\";
#line 533
  qp = quoted;
#line 535
  sp = string;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! *sp) {
#line 535
      goto while_break;
    }
    {
#line 536
    tmp = strchr(special, (int )*sp);
    }
#line 536
    if (tmp) {
#line 537
      if ((qp - quoted) + 2L >= 4096L) {
#line 537
        goto while_break;
      }
#line 538
      *qp = (char )'\\';
#line 539
      qp ++;
    }
#line 541
    if ((qp - quoted) + 1L >= 4096L) {
#line 541
      goto while_break;
    }
#line 542
    *qp = (char )*sp;
#line 543
    qp ++;
#line 535
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  qp ++;
#line 546
  *qp = (char)0;
#line 547
  return (quoted);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 803 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.h"
char *getreply(int fd ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.h"
int check_forward(int sockfd , char *recipient , char *host , char *redirect ) ;
#line 30
int saft2rfc822(char *adr ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int check_alias(char *aliasfile , char *recipient , char *host , char *aopt ) ;
#line 87
int finger_saft_port(char *user , char *host ) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
void destination(int argc , char **argv , char *user , char *recipient , char *host ,
                 char *aopt ) 
{ 
  char *cp ;
  char *at ;
  char *larg ;
  char gecos[256] ;
  char tmp[4096] ;
  char line[4096] ;
  char localhost___0[256] ;
  char userconfig[4096] ;
  char aliasfile[4096] ;
  FILE *inf ;
  struct passwd *pwe ;
  struct stat finfo ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 128
  tmp___0 = getuid();
#line 128
  pwe = getpwuid(tmp___0);
  }
#line 128
  if ((unsigned long )pwe == (unsigned long )((void *)0)) {
    {
#line 129
    message(prg, (char )'F', "could not determine own user name");
    }
  }
  {
#line 132
  iso2utf(gecos, pwe->pw_gecos);
#line 133
  cp = strchr((char const   *)(gecos), ',');
  }
#line 133
  if (cp) {
#line 133
    *cp = (char)0;
  }
  {
#line 134
  snprintf((char */* __restrict  */)user, (size_t )255, (char const   */* __restrict  */)"%s %s",
           pwe->pw_name, gecos);
#line 137
  snprintf((char */* __restrict  */)(userconfig), sizeof(userconfig) - 1UL, (char const   */* __restrict  */)"%s/.sendfile",
           pwe->pw_dir);
#line 138
  snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"/var/spool/sendfile/%s/config",
           pwe->pw_name);
#line 139
  tmp___1 = stat((char const   */* __restrict  */)(userconfig), (struct stat */* __restrict  */)(& finfo));
  }
#line 139
  if (tmp___1 < 0) {
    {
#line 139
    tmp___2 = stat((char const   */* __restrict  */)(tmp), (struct stat */* __restrict  */)(& finfo));
    }
#line 139
    if (tmp___2 == 0) {
      {
#line 140
      symlink((char const   *)(tmp), (char const   *)(userconfig));
      }
    }
  }
#line 143
  if (argc == 0) {
    {
#line 144
    tmp___3 = gethostname(localhost___0, (size_t )255);
    }
#line 144
    if (tmp___3 < 0) {
      {
#line 144
      strcpy((char */* __restrict  */)(localhost___0), (char const   */* __restrict  */)"localhost");
      }
    }
    {
#line 145
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s/msg@%s",
             userconfig, localhost___0);
#line 146
    inf = rfopen((char const   *)(tmp), "r");
    }
#line 146
    if (inf) {
      {
#line 146
      tmp___4 = sfgetl(line, (int )sizeof(line), inf);
      }
#line 146
      if (tmp___4) {
        {
#line 147
        cp = strchr((char const   *)(line), '\n');
        }
#line 147
        if (cp) {
#line 147
          *cp = (char)0;
        }
        {
#line 148
        cp = strchr((char const   *)(line), '@');
        }
#line 148
        if (cp) {
          {
#line 149
          *cp = (char)0;
#line 150
          snprintf((char */* __restrict  */)host, (size_t )255, (char const   */* __restrict  */)"%s",
                   cp + 1);
          }
        }
        {
#line 152
        snprintf((char */* __restrict  */)recipient, (size_t )255, (char const   */* __restrict  */)"%s",
                 line);
        }
      }
    }
    {
#line 154
    fclose(inf);
    }
#line 155
    return;
  }
#line 159
  if (argc < 0) {
#line 160
    larg = *(argv + - argc);
  } else {
#line 162
    larg = *(argv + (argc - 1));
  }
  {
#line 164
  *host = (char)0;
#line 167
  at = strchr((char const   *)larg, '@');
  }
#line 167
  if (at) {
    {
#line 170
    *recipient = (char)0;
#line 171
    strncat((char */* __restrict  */)recipient, (char const   */* __restrict  */)larg,
            (size_t )(at - larg));
#line 172
    strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)(at + 1));
    }
  } else {
    {
#line 175
    tmp___8 = str_neq_nocase((char const   *)larg, "saft", 4);
    }
#line 175
    if (tmp___8) {
      {
#line 175
      tmp___9 = strchr((char const   *)larg, '/');
      }
#line 175
      if (tmp___9) {
        {
#line 176
        tmp___5 = str_neq_nocase((char const   *)larg, "saft://", 7);
        }
#line 176
        if (tmp___5) {
#line 176
          larg += 7;
        }
        {
#line 177
        cp = strrchr((char const   *)larg, '/');
        }
#line 178
        if (! cp) {
          {
#line 178
          message(prg, (char )'F', "illegal SAFT-URL");
          }
        } else {
          {
#line 178
          tmp___6 = strchr((char const   *)larg, '@');
          }
#line 178
          if (tmp___6) {
            {
#line 178
            message(prg, (char )'F', "illegal SAFT-URL");
            }
          }
        }
        {
#line 179
        strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)(cp + 1));
#line 180
        *cp = (char)0;
        }
        {
#line 181
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 181
          cp = strchr((char const   *)larg, '/');
          }
#line 181
          if (! cp) {
#line 181
            goto while_break;
          }
#line 181
          *cp = (char )'.';
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 182
        strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)larg);
        }
      } else {
#line 175
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 187
      strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)larg);
#line 190
      snprintf((char */* __restrict  */)(aliasfile), sizeof(aliasfile) - 1UL, (char const   */* __restrict  */)"%s/aliases",
               userconfig);
#line 191
      tmp___7 = check_alias(aliasfile, recipient, host, aopt);
      }
#line 191
      if (tmp___7 < 0) {
#line 201
        if (argc <= 0) {
          {
#line 202
          strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)*(argv + - argc));
          }
        } else {
          {
#line 204
          strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)*(argv + (argc - 1)));
          }
        }
        {
#line 205
        strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)"127.0.0.1");
        }
      }
    }
  }
#line 213
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int check_alias(char *aliasfile , char *recipient , char *host , char *aopt ) 
{ 
  char *cp ;
  char line[4096] ;
  char address[4096] ;
  FILE *inf ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 233
  inf = rfopen((char const   *)aliasfile, "r");
  }
#line 234
  if ((unsigned long )inf == (unsigned long )((void *)0)) {
#line 234
    return (-1);
  }
#line 236
  address[0] = (char)0;
#line 237
  if (aopt) {
#line 237
    *aopt = (char)0;
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 240
    tmp___0 = sfgetl(line, (int )sizeof(line), inf);
    }
#line 240
    if (! tmp___0) {
#line 240
      goto while_break;
    }
    {
#line 243
    cp = strchr((char const   *)(line), '\n');
    }
#line 243
    if (cp) {
#line 243
      *cp = (char)0;
    }
    {
#line 244
    cp = strchr((char const   *)(line), '#');
    }
#line 244
    if (cp) {
#line 244
      *cp = (char)0;
    }
    {
#line 245
    str_trim(line);
    }
#line 246
    if (! line[0]) {
#line 246
      goto while_continue;
    }
    {
#line 249
    cp = strchr((char const   *)(line), ' ');
    }
#line 250
    if (cp) {
#line 251
      *cp = (char)0;
    } else {
#line 253
      goto while_continue;
    }
    {
#line 254
    strcpy((char */* __restrict  */)(address), (char const   */* __restrict  */)(cp + 1));
#line 255
    cp = strchr((char const   *)(address), ' ');
    }
#line 255
    if (cp) {
#line 256
      *cp = (char)0;
#line 257
      if (aopt) {
        {
#line 257
        snprintf((char */* __restrict  */)aopt, (size_t )255, (char const   */* __restrict  */)"%s",
                 cp + 1);
        }
      }
    }
    {
#line 261
    tmp = strcmp((char const   *)recipient, (char const   *)(line));
    }
#line 261
    if (tmp == 0) {
#line 261
      goto while_break;
    }
#line 263
    address[0] = (char)0;
#line 264
    if (aopt) {
#line 264
      *aopt = (char)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  fclose(inf);
  }
#line 270
  if (address[0]) {
    {
#line 273
    tmp___1 = str_beq_nocase((char const   *)(address), "saft://");
    }
#line 273
    if (tmp___1) {
      {
#line 273
      saft2rfc822(address);
      }
    }
    {
#line 276
    cp = strchr((char const   *)(address), '@');
    }
#line 277
    if (cp) {
      {
#line 278
      *cp = (char)0;
#line 279
      strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)(cp + 1));
      }
    } else {
      {
#line 281
      strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)"0");
      }
    }
    {
#line 283
    strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)(address));
    }
#line 284
    return (0);
  }
#line 287
  return (-1);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int check_forward(int sockfd , char *recipient , char *host , char *redirect ) 
{ 
  char *cp ;
  char *at ;
  char *adr ;
  char *reply___1 ;
  char tmp[4096] ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 313
  reply___1 = getreply(sockfd);
#line 314
  str_trim(reply___1);
#line 317
  tmp___2 = str_beq((char const   *)reply___1, "510 ");
  }
#line 317
  if (tmp___2) {
    {
#line 319
    tmp___0 = strrchr((char const   *)reply___1, ' ');
#line 319
    adr = tmp___0 + 1;
#line 322
    tmp___1 = str_beq_nocase((char const   *)adr, "saft://");
    }
#line 322
    if (tmp___1) {
      {
#line 322
      saft2rfc822(adr);
      }
    }
#line 324
    if (quiet < 2) {
      {
#line 324
      message(prg, (char )'I', "forward address found");
      }
    }
#line 325
    if (*redirect) {
      {
#line 326
      strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)redirect);
#line 327
      snprintf((char */* __restrict  */)redirect, (size_t )4095, (char const   */* __restrict  */)"%s\r\nredirected by %s@%s",
               tmp, recipient, host);
      }
    } else {
      {
#line 330
      snprintf((char */* __restrict  */)redirect, (size_t )4095, (char const   */* __restrict  */)"redirected by %s@%s",
               recipient, host);
      }
    }
    {
#line 334
    at = strchr((char const   *)adr, '@');
    }
#line 334
    if (at) {
      {
#line 335
      *at = (char)0;
#line 336
      strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)(at + 1));
      }
    }
    {
#line 338
    strcpy((char */* __restrict  */)recipient, (char const   */* __restrict  */)adr);
    }
#line 340
    return (1);
  }
  {
#line 344
  tmp___4 = str_beq((char const   *)reply___1, "200 ");
  }
#line 344
  if (! tmp___4) {
    {
#line 345
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"server error: %s",
             reply___1 + 4);
#line 346
    tmp___3 = __errno_location();
#line 346
    *tmp___3 = 0;
    }
#line 347
    if (client) {
      {
#line 347
      message(prg, (char )'F', (char const   *)(tmp));
      }
    }
    {
#line 348
    strcpy((char */* __restrict  */)redirect, (char const   */* __restrict  */)(reply___1 + 4));
#line 349
    cp = strrchr((char const   *)redirect, '.');
    }
#line 349
    if (cp) {
#line 349
      *cp = (char)0;
    }
#line 350
    return (-1);
  }
#line 353
  return (0);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int saft_connect(char const   *type , char *recipient , char *user , char *host ,
                 char *redirect ) 
{ 
  int port ;
  int sockfd ;
  int hopcount ;
  char *cp ;
  char answer[256] ;
  char tmp[4096] ;
  char ahost[4096] ;
  char line[4096] ;
  struct servent *sinfo ;
  uint16_t tmp___0 ;
  int *tmp___1 ;
  struct hostent *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
  {
#line 389
  port = 487;
#line 390
  hopcount = 0;
#line 391
  answer[0] = (char)0;
#line 394
  cp = strchr((char const   *)host, ':');
  }
#line 394
  if (cp) {
#line 395
    cp ++;
#line 396
    if ((int )*cp > 57) {
      {
#line 397
      sinfo = getservbyname((char const   *)cp, "tcp");
      }
#line 397
      if (sinfo) {
        {
#line 397
        tmp___0 = ntohs((uint16_t )sinfo->s_port);
#line 397
        port = (int )tmp___0;
        }
      }
    } else {
      {
#line 399
      port = atoi((char const   *)cp);
      }
    }
  }
#line 403
  hopcount = 1;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (hopcount < 11)) {
#line 403
      goto while_break;
    }
#line 406
    if (port == 79) {
#line 406
      goto _L;
    } else
#line 406
    if (! port) {
      _L: /* CIL Label */ 
      {
#line 407
      cp = strchr((char const   *)host, ':');
      }
#line 407
      if (cp) {
#line 407
        *cp = (char)0;
      }
      {
#line 408
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"opening connection to finger://%s/%s",
               host, recipient);
      }
#line 409
      if (quiet < 2) {
        {
#line 409
        message(prg, (char )'I', (char const   *)(tmp));
        }
      }
      {
#line 410
      port = finger_saft_port(recipient, host);
      }
#line 411
      if (port < 1) {
        {
#line 412
        tmp___1 = __errno_location();
#line 412
        *tmp___1 = 0;
#line 413
        message(prg, (char )'F', "no SAFT port information");
        }
      }
      {
#line 415
      snprintf((char */* __restrict  */)(tmp), (size_t )255, (char const   */* __restrict  */)"%s:%d",
               host, port);
#line 416
      strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)(tmp));
      }
    }
    {
#line 420
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"opening connection to saft://%s/%s",
             host, recipient);
    }
#line 421
    if (quiet < 2) {
      {
#line 421
      message(prg, (char )'I', (char const   *)(tmp));
      }
    }
    {
#line 422
    sockfd = open_connection(host, port);
    }
#line 424
    if (port == 487) {
#line 427
      if (sockfd == -3) {
        {
#line 427
        tmp___4 = strcmp(type, "file");
        }
#line 427
        if (tmp___4 == 0) {
#line 428
          if (client) {
            {
#line 429
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s has no internet-address",
                     host);
            }
#line 430
            if (quiet < 2) {
              {
#line 430
              message(prg, (char )'W', (char const   *)(tmp));
              }
            }
          }
#line 434
          if (port == 487) {
            {
#line 435
            snprintf((char */* __restrict  */)(ahost), sizeof(ahost) - 1UL, (char const   */* __restrict  */)"saft.%s",
                     host);
            }
#line 436
            if (client) {
              {
#line 437
              tmp___2 = gethostbyname((char const   *)(ahost));
              }
#line 437
              if (tmp___2) {
#line 438
                if (! quiet) {
                  {
#line 439
                  printf((char const   */* __restrict  */)"try sending to %s@%s ? ",
                         recipient, ahost);
#line 440
                  sfgetl(answer, (int )sizeof(answer), stdin);
                  }
                } else {
#line 442
                  answer[0] = (char )'y';
                }
              } else {
#line 444
                answer[0] = (char )'n';
              }
            }
            {
#line 446
            tmp___3 = tolower((int )answer[0]);
            }
#line 446
            if (tmp___3 != 110) {
#line 446
              goto _L___0;
            } else
#line 446
            if (! client) {
              _L___0: /* CIL Label */ 
              {
#line 447
              strcpy((char */* __restrict  */)host, (char const   */* __restrict  */)(ahost));
              }
#line 448
              if (client) {
                {
#line 449
                snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"opening connection to %s@%s",
                         recipient, host);
                }
#line 450
                if (quiet < 2) {
                  {
#line 450
                  message(prg, (char )'I', (char const   *)(tmp));
                  }
                }
              }
              {
#line 452
              sockfd = open_connection(host, port);
              }
            }
          }
        }
      }
#line 459
      if (sockfd == -2) {
        {
#line 459
        tmp___5 = strcmp(type, "file");
        }
#line 459
        if (tmp___5 == 0) {
#line 460
          if (verbose) {
            {
#line 461
            snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot connect to SAFT port %d on %s",
                     port, host);
#line 463
            message(prg, (char )'E', (char const   *)(tmp));
            }
          }
          {
#line 465
          port = finger_saft_port(recipient, host);
          }
#line 466
          if (port > 0) {
#line 466
            if (port != 487) {
              {
#line 467
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s has no system SAFT server, trying user SAFT server on port %d",
                       host, port);
              }
#line 469
              if (quiet < 2) {
                {
#line 469
                message(prg, (char )'W', (char const   *)(tmp));
                }
              }
              {
#line 470
              sockfd = open_connection(host, port);
              }
            } else {
#line 472
              port = 487;
            }
          } else {
#line 472
            port = 487;
          }
        }
      }
    }
#line 477
    if (sockfd == -1) {
      {
#line 477
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot create a network socket");
      }
    }
#line 478
    if (sockfd == -2) {
      {
#line 478
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"cannot open connection to %s",
               host);
      }
    }
#line 479
    if (sockfd == -3) {
      {
#line 479
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"%s is unknown",
               host);
      }
    }
#line 480
    if (sockfd < 0) {
#line 481
      if (client) {
        {
#line 482
        tmp___6 = __errno_location();
#line 482
        *tmp___6 = 0;
#line 483
        message(prg, (char )'F', (char const   *)(tmp));
        }
      } else {
#line 485
        return (-1);
      }
    }
    {
#line 489
    sock_getline(sockfd, line);
#line 490
    tmp___8 = str_beq((char const   *)(line), "220 ");
    }
#line 490
    if (tmp___8) {
      {
#line 490
      tmp___9 = strstr((char const   *)(line), "SAFT");
      }
#line 490
      if (! tmp___9) {
        _L___1: /* CIL Label */ 
        {
#line 491
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"No SAFT server on port %d at %s",
                 port, host);
#line 492
        cp = strrchr((char const   *)(tmp), ':');
        }
#line 492
        if (cp) {
#line 492
          *cp = (char)0;
        }
#line 493
        if (client) {
          {
#line 494
          tmp___7 = __errno_location();
#line 494
          *tmp___7 = 0;
#line 495
          message(prg, (char )'F', (char const   *)(tmp));
          }
        } else {
          {
#line 497
          strcpy((char */* __restrict  */)redirect, (char const   */* __restrict  */)(tmp));
          }
#line 498
          return (-1);
        }
      }
    } else {
#line 490
      goto _L___1;
    }
    {
#line 503
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"FROM %s",
             user);
#line 504
    sendheader(sockfd, tmp);
#line 505
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"TO %s",
             recipient);
#line 506
    sock_putline(sockfd, (char const   *)(tmp));
#line 509
    tmp___10 = check_forward(sockfd, recipient, host, redirect);
    }
#line 509
    if (tmp___10) {
      {
#line 512
      sock_putline(sockfd, "QUIT");
#line 513
      getreply(sockfd);
#line 514
      shutdown(sockfd, 2);
      }
#line 515
      goto __Cont;
    }
    {
#line 519
    tmp___12 = strcmp(type, "file");
    }
#line 519
    if (tmp___12 == 0) {
#line 521
      if (verbose) {
        {
#line 521
        message(prg, (char )'I', "testing remote server");
        }
      }
      {
#line 524
      sock_putline(sockfd, "FILE test");
#line 525
      tmp___11 = check_forward(sockfd, recipient, host, redirect);
      }
#line 525
      if (tmp___11) {
        {
#line 528
        sock_putline(sockfd, "QUIT");
#line 529
        getreply(sockfd);
#line 530
        shutdown(sockfd, 2);
        }
#line 531
        goto __Cont;
      }
    }
#line 537
    goto while_break;
    __Cont: /* CIL Label */ 
#line 403
    hopcount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  if (hopcount > 10) {
    {
#line 542
    strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"maximum hopcount reached (forward loop?)");
    }
#line 543
    if (client) {
      {
#line 544
      tmp___13 = __errno_location();
#line 544
      *tmp___13 = 0;
#line 545
      message(prg, (char )'F', (char const   *)(tmp));
      }
    } else {
      {
#line 547
      strcpy((char */* __restrict  */)redirect, (char const   */* __restrict  */)(tmp));
      }
#line 548
      return (-1);
    }
  }
#line 552
  return (sockfd);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int finger_saft_port(char *user , char *host ) 
{ 
  int port ;
  int sockfd ;
  char *cp ;
  char line[4096] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 573
  port = -1;
#line 574
  line[0] = (char)0;
#line 577
  sockfd = open_connection(host, 79);
  }
#line 578
  if (sockfd > 0) {
    {
#line 579
    sock_putline(sockfd, (char const   *)user);
    }
    {
#line 580
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 580
      tmp___0 = sock_getline(sockfd, line);
      }
#line 580
      if (! (tmp___0 >= 0)) {
#line 580
        goto while_break;
      }
      {
#line 581
      str_trim(line);
#line 582
      tmp = str_beq_nocase((char const   *)(line), "saftport");
      }
#line 582
      if (tmp) {
        {
#line 582
        cp = strchr((char const   *)(line), '=');
        }
#line 582
        if (cp) {
          {
#line 583
          port = atoi((char const   *)(cp + 1));
          }
#line 584
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 587
    shutdown(sockfd, 2);
    }
  }
#line 590
  return (port);
}
}
#line 868 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/address.c"
int saft2rfc822(char *adr ) 
{ 
  char *cp ;
  char *user ;
  char host[4096] ;
  int tmp ;

  {
  {
#line 874
  tmp = str_beq_nocase((char const   *)adr, "saft://");
  }
#line 874
  if (! tmp) {
#line 874
    return (-1);
  }
  {
#line 875
  strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(adr + 7));
#line 876
  cp = strchr((char const   *)(host), '/');
  }
#line 877
  if (! cp) {
#line 877
    return (-1);
  }
  {
#line 878
  *cp = (char)0;
#line 879
  user = cp + 1;
#line 880
  sprintf((char */* __restrict  */)adr, (char const   */* __restrict  */)"%s@%s",
          user, host);
  }
#line 881
  return (0);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
int open_connection(char *adr , int port ) 
{ 
  int sockfd ;
  int num ;
  struct sockaddr_in serv_addr ;
  struct in_addr hostaddr ;
  struct hostent *hostp ;
  char *cp ;
  char hostip[17] ;
  char hostname[4096] ;
  char *tmp ;
  int flag ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 146
  num = 1;
#line 156
  strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)adr);
#line 157
  cp = strchr((char const   *)(hostname), ':');
  }
#line 157
  if (cp) {
#line 157
    *cp = (char)0;
  }
  {
#line 160
  sockfd = socket(2, 1, 0);
  }
#line 161
  if (sockfd < 0) {
#line 161
    return (-1);
  }
  {
#line 167
  memset((void *)((char *)(& serv_addr)), 0, sizeof(serv_addr));
#line 170
  cp = hostname;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((int )*cp > 0)) {
#line 170
      goto while_break;
    }
#line 171
    if ((int )*cp > 64) {
#line 172
      num = 0;
#line 173
      goto while_break;
    }
#line 170
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  num = 0;
#line 181
  if (num) {
    {
#line 182
    hostaddr.s_addr = inet_addr((char const   *)(hostname));
#line 183
    hostp = gethostbyaddr((void const   *)((char *)(& hostaddr)), (__socklen_t )sizeof(hostaddr),
                          2);
    }
  } else {
    {
#line 185
    hostp = gethostbyname((char const   *)(hostname));
    }
  }
#line 186
  if ((unsigned long )hostp == (unsigned long )((void *)0)) {
#line 186
    return (-3);
  }
  {
#line 189
  tmp = inet_ntoa(*((struct in_addr *)*(hostp->h_addr_list)));
#line 189
  strcpy((char */* __restrict  */)(hostip), (char const   */* __restrict  */)tmp);
#line 195
  serv_addr.sin_family = (sa_family_t )2;
#line 196
  serv_addr.sin_addr.s_addr = inet_addr((char const   *)(hostip));
#line 197
  serv_addr.sin_port = htons((uint16_t )port);
#line 202
  flag = 1;
#line 204
  tmp___0 = setsockopt(sockfd, 1, 9, (void const   *)((void *)(& flag)), (socklen_t )sizeof(flag));
  }
#line 204
  if (tmp___0 < 0) {
    {
#line 206
    message(prg, (char )'W', "could not configure socket");
    }
  }
  {
#line 240
  tmp___1 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 240
  if (tmp___1 < 0) {
#line 241
    return (-2);
  }
#line 246
  return (sockfd);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
int sock_getline(int fd , char *line ) 
{ 
  int n ;
  int rc ;
  unsigned char c ;
  char tmp[4096] ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
#line 449
  *line = (char)0;
#line 451
  n = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (n < 4095)) {
#line 451
      goto while_break;
    }
    {
#line 452
    tmp___0 = read(fd, (void *)(& c), (size_t )1);
#line 452
    rc = (int )tmp___0;
    }
#line 453
    if (rc == 1) {
#line 454
      *(line + n) = (char )c;
#line 455
      if ((int )c == 10) {
#line 455
        goto while_break;
      }
    } else {
#line 457
      return (-1);
    }
#line 451
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (n + 1 == 4096) {
#line 461
    if ((int )*(line + n) != 10) {
#line 462
      if (client) {
        {
#line 463
        tmp___1 = __errno_location();
#line 463
        *tmp___1 = 0;
#line 464
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"network socket data overrun (read bytes: %d)",
                 n);
#line 465
        message((char *)"", (char )'E', (char const   *)(tmp));
#line 466
        message((char *)"", (char )'F', (char const   *)line);
        }
      }
#line 468
      return (-1);
    }
  }
#line 472
  *(line + n) = (char)0;
#line 473
  if (n > 0) {
#line 473
    if ((int )*(line + (n - 1)) == 13) {
#line 473
      n --;
#line 473
      *(line + n) = (char)0;
    }
  }
#line 476
  if (verbose) {
    {
#line 476
    printf((char const   */* __restrict  */)"%s\n", line);
    }
  }
#line 478
  return (n);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
int sock_putline(int fd , char const   *line ) 
{ 
  int n ;
  char cmd[4096] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 495
  strcpy((char */* __restrict  */)(cmd), (char const   */* __restrict  */)line);
#line 496
  strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"\r\n");
  }
#line 499
  if (verbose) {
    {
#line 499
    printf((char const   */* __restrict  */)"-> %s\n", line);
    }
  }
#line 502
  if (fd) {
    {
#line 503
    tmp = strlen((char const   *)(cmd));
#line 503
    n = writen(fd, cmd, (int )tmp);
    }
  } else {
    {
#line 506
    tmp___0 = strlen((char const   *)(cmd));
#line 506
    n = (int )tmp___0;
    }
  }
#line 508
  return (n);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
static char reply___0[4096]  ;
#line 519 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
char *getreply(int fd ) 
{ 
  int len ;
  char msg[4096] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (fd) {
      {
#line 530
      len = sock_getline(fd, reply___0);
      }
#line 533
      if (len < 0) {
        {
#line 534
        tmp = __errno_location();
#line 534
        *tmp = 0;
#line 535
        strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"server has closed the connection");
        }
#line 536
        if (reply___0[0]) {
          {
#line 536
          snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"%s, last data: \"%s\"",
                   msg, reply___0);
          }
        }
#line 537
        if (client) {
          {
#line 538
          tmp___0 = __errno_location();
#line 538
          *tmp___0 = 0;
#line 539
          message((char *)"", (char )'F', (char const   *)(msg));
          }
        }
#line 542
        return (reply___0);
      }
#line 546
      if (len < 4) {
        {
#line 547
        tmp___1 = __errno_location();
#line 547
        *tmp___1 = 0;
#line 548
        snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"corrupt reply: \"%s\"",
                 reply___0);
        }
#line 549
        if (client) {
          {
#line 550
          tmp___2 = __errno_location();
#line 550
          *tmp___2 = 0;
#line 551
          message(prg, (char )'F', (char const   *)(msg));
#line 552
          strcpy((char */* __restrict  */)(reply___0), (char const   */* __restrict  */)(msg));
          }
#line 553
          return (reply___0);
        } else {
#line 555
          return ((char *)"");
        }
      }
    } else {
      {
#line 560
      strcpy((char */* __restrict  */)(reply___0), (char const   */* __restrict  */)"222 test mode");
      }
    }
#line 525
    if (! ((int )reply___0[3] == 45)) {
#line 525
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  if ((int )reply___0[0] == 52) {
    {
#line 567
    tmp___3 = __errno_location();
#line 567
    *tmp___3 = 0;
#line 568
    snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"server error: %s",
             & reply___0[4]);
    }
#line 569
    if (client) {
      {
#line 570
      tmp___4 = __errno_location();
#line 570
      *tmp___4 = 0;
#line 571
      message(prg, (char )'F', (char const   *)(msg));
#line 572
      strcpy((char */* __restrict  */)(reply___0), (char const   */* __restrict  */)(msg));
      }
#line 573
      return (reply___0);
    } else {
#line 575
      return ((char *)"");
    }
  }
#line 579
  return (reply___0);
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
char *sendcommand(int fd , char const   *command , char *answer ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 600
  if (answer) {
#line 600
    *answer = (char)0;
  }
  {
#line 602
  sock_putline(fd, command);
  }
#line 604
  if (answer) {
    {
#line 605
    tmp = getreply(fd);
#line 605
    strcpy((char */* __restrict  */)answer, (char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 606
    tmp___0 = strcmp(command, "QUIT");
    }
#line 606
    if (! (tmp___0 == 0)) {
      {
#line 606
      getreply(fd);
      }
    }
  }
#line 608
  return (answer);
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
int sendheader(int fd , char *line ) 
{ 
  char msg[4096] ;
  char *reply___1 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 628
  if (! fd) {
#line 628
    return (0);
  }
  {
#line 631
  sock_putline(fd, (char const   *)line);
#line 634
  reply___1 = getreply(fd);
#line 636
  tmp = str_beq((char const   *)reply___1, "200");
  }
#line 636
  if (tmp) {
#line 636
    return (0);
  }
  {
#line 637
  tmp___0 = str_beq((char const   *)reply___1, "202");
  }
#line 637
  if (tmp___0) {
#line 637
    return (1);
  }
  {
#line 639
  tmp___1 = __errno_location();
#line 639
  *tmp___1 = 0;
#line 640
  snprintf((char */* __restrict  */)(msg), sizeof(msg) - 1UL, (char const   */* __restrict  */)"server error: %s",
           reply___1 + 4);
#line 641
  message(prg, (char )'F', (char const   *)(msg));
  }
#line 643
  return (-1);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/sendfile-2.1b.20080616/src/net.c"
int send_data(int sockfd , off_t size , char const   *file , char const   *tinfo ,
              char const   *iso_name , char const   *type , float mtp , float *ttime ) 
{ 
  int n ;
  int nblocks ;
  int bn ;
  int percent ;
  int ffd ;
  unsigned long msec ;
  off_t bytes ;
  off_t offset ;
  float thruput ;
  char packet[32768] ;
  char tmp[4096] ;
  char fname[4096] ;
  char *reply___1 ;
  time_t sec0 ;
  time_t sec1 ;
  time_t sec2 ;
  struct timeval tv1 ;
  struct timeval tv2 ;
  struct timezone tz ;
  struct winsize wsize ;
  char *thisfile ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  __off64_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  time_t tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 693
  thisfile = (char *)((void *)0);
#line 695
  msec = 0UL;
#line 696
  offset = (off_t )0;
#line 699
  if (packet_size < 1) {
#line 699
    packet_size = 512;
  }
#line 701
  if (ttime) {
#line 701
    *ttime = (float )0;
  }
  {
#line 702
  strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)iso_name);
  }
#line 703
  if (*type) {
    {
#line 704
    strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)" (");
#line 705
    strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)type);
#line 706
    strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)")");
    }
  }
#line 708
  if (! quiet) {
#line 708
    if (! verbose) {
      {
#line 708
      printf((char const   */* __restrict  */)"sending...                        \r");
      }
    }
  }
  {
#line 709
  fflush(stdout);
  }
#line 712
  if (sockfd) {
#line 715
    if (*file) {
      {
#line 717
      sock_putline(sockfd, "RESEND");
#line 718
      reply___1 = getreply(sockfd);
#line 721
      tmp___2 = str_beq((char const   *)reply___1, "500 ");
      }
#line 721
      if (! tmp___2) {
        {
#line 721
        tmp___3 = str_beq((char const   *)reply___1, "502 ");
        }
#line 721
        if (! tmp___3) {
          {
#line 724
          tmp___1 = str_beq((char const   *)reply___1, "230 ");
          }
#line 724
          if (! tmp___1) {
#line 725
            if (quiet < 3) {
              {
#line 726
              tmp___0 = __errno_location();
#line 726
              *tmp___0 = 0;
#line 727
              snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"server error: %s",
                       reply___1 + 4);
#line 728
              message((char *)"", (char )'F', (char const   *)(tmp));
              }
            }
#line 730
            return (-1);
          }
          {
#line 733
          sscanf((char const   */* __restrict  */)(reply___1 + 4), (char const   */* __restrict  */)"%lld",
                 & offset);
          }
        }
      }
    }
    {
#line 739
    sock_putline(sockfd, "DATA");
#line 740
    reply___1 = getreply(sockfd);
#line 743
    tmp___4 = str_beq((char const   *)reply___1, "531 ");
    }
#line 743
    if (tmp___4) {
      {
#line 744
      snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"file %s has been already transmitted - ignored.",
               iso_name);
      }
#line 746
      if (quiet < 2) {
        {
#line 746
        message((char *)"", (char )'W', (char const   *)(tmp));
        }
      }
#line 747
      return (1);
    }
    {
#line 751
    tmp___6 = str_beq((char const   *)reply___1, "302 ");
    }
#line 751
    if (! tmp___6) {
#line 752
      if (quiet < 3) {
        {
#line 753
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"corrupt server reply: %s",
                 reply___1 + 4);
#line 754
        tmp___5 = __errno_location();
#line 754
        *tmp___5 = 0;
#line 755
        message((char *)"", (char )'F', (char const   *)(tmp));
        }
      }
#line 757
      return (-1);
    }
  }
#line 762
  if (*file) {
    {
#line 763
    ffd = open(file, 0, 0);
    }
#line 764
    if (ffd < 0) {
#line 764
      goto _L;
    } else {
      {
#line 764
      tmp___7 = lseek(ffd, offset, 0);
      }
#line 764
      if (tmp___7 < 0L) {
        _L: /* CIL Label */ 
#line 765
        if (quiet < 3) {
          {
#line 766
          snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error reading %s",
                   iso_name);
#line 767
          message((char *)"", (char )'E', (char const   *)(tmp));
          }
        }
#line 769
        return (-1);
      }
    }
  } else {
    {
#line 773
    ffd = fileno(stdin);
    }
  }
#line 776
  if (offset) {
    {
#line 777
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"resuming %s at byte %lld",
             iso_name, offset);
    }
#line 778
    if (quiet < 2) {
      {
#line 778
      message((char *)"", (char )'I', (char const   *)(tmp));
      }
    }
  }
#line 781
  if (quiet == 1) {
    {
#line 782
    snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"begin transfer of %s with %lld bytes",
             fname, size);
#line 783
    message((char *)"", (char )'I', (char const   *)(tmp));
    }
  }
#line 786
  if (! quiet) {
    {
#line 787
    tmp___8 = fileno(stdout);
#line 787
    tmp___9 = ioctl(tmp___8, 21523UL, & wsize);
    }
#line 787
    if (tmp___9 != 0) {
#line 788
      wsize.ws_col = (unsigned short)80;
    }
    {
#line 789
    tmp___12 = strlen((char const   *)(fname));
    }
#line 789
    if (tmp___12 + 40UL <= (size_t )wsize.ws_col) {
#line 790
      thisfile = fname;
    } else {
      {
#line 792
      tmp___10 = malloc((size_t )(((int )wsize.ws_col - 40) + 1));
#line 792
      thisfile = (char *)tmp___10;
      }
#line 792
      if ((unsigned long )thisfile == (unsigned long )((void *)0)) {
        {
#line 793
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error allocating %d bytes",
                 ((int )wsize.ws_col - 40) + 1);
#line 794
        message((char *)"", (char )'E', (char const   *)(tmp));
        }
      }
      {
#line 796
      memset((void *)thisfile, 0, (size_t )(((int )wsize.ws_col - 40) + 1));
#line 798
      strncpy((char */* __restrict  */)thisfile, (char const   */* __restrict  */)(fname),
              (size_t )((((int )wsize.ws_col - 40) - 2) / 2));
#line 799
      strcat((char */* __restrict  */)thisfile, (char const   */* __restrict  */)"..");
#line 800
      tmp___11 = strlen((char const   *)(fname));
#line 800
      strncat((char */* __restrict  */)thisfile, (char const   */* __restrict  */)(fname + (tmp___11 - (size_t )((((int )wsize.ws_col - 40) - 2) / 2))),
              (size_t )((((int )wsize.ws_col - 40) - 2) / 2));
      }
    }
  }
  {
#line 812
  gettimeofday((struct timeval */* __restrict  */)(& tv1), (__timezone_ptr_t )(& tz));
#line 814
  sec1 = (time_t )0;
#line 815
  sec0 = time((time_t *)0);
#line 818
  bytes = (off_t )0;
#line 819
  size -= offset;
#line 820
  nblocks = (int )(size / (off_t )packet_size);
#line 821
  bn = 1;
  }
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (bn <= nblocks)) {
#line 821
      goto while_break;
    }
    {
#line 822
    tmp___13 = readn(ffd, packet, packet_size);
    }
#line 822
    if (tmp___13 < packet_size) {
#line 823
      if (quiet < 3) {
#line 824
        if (! quiet) {
          {
#line 824
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 825
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error reading %s",
                 iso_name);
#line 826
        message((char *)"", (char )'E', (char const   *)(tmp));
        }
      }
      {
#line 828
      close(ffd);
      }
#line 829
      return (-1);
    }
#line 831
    if (sockfd) {
      {
#line 831
      tmp___15 = writen(sockfd, packet, packet_size);
      }
#line 831
      if (tmp___15 < packet_size) {
#line 832
        if (quiet < 3) {
#line 833
          if (! quiet) {
            {
#line 833
            printf((char const   */* __restrict  */)"\n");
            }
          }
          {
#line 834
          tmp___14 = __errno_location();
#line 834
          *tmp___14 = 0;
#line 835
          message((char *)"", (char )'F', "error sending data");
          }
        }
        {
#line 837
        close(ffd);
        }
#line 838
        return (-1);
      }
    }
#line 842
    bytes += (off_t )packet_size;
#line 843
    percent = (int )(((double )(bytes + offset) * 100.0) / (double )(size + offset));
#line 844
    if (! quiet) {
      {
#line 846
      tmp___16 = fileno(stdout);
#line 846
      tmp___17 = ioctl(tmp___16, 21523UL, & wsize);
      }
#line 846
      if (tmp___17 != 0) {
#line 847
        return (-1);
      }
      {
#line 850
      sec2 = time((time_t *)0);
      }
#line 851
      if (sec2 > sec1) {
        {
#line 852
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s: %3d%%  (%lld of %lld kB)\r",
                tinfo, thisfile, percent, ((bytes + offset) - 1L) / 1024L + 1L, ((size + offset) - 1L) / 1024L + 1L);
#line 855
        fflush(stderr);
#line 856
        sec1 = sec2;
        }
      }
    }
#line 861
    if (mtp) {
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 861
        tmp___18 = time((time_t *)0);
        }
#line 861
        if (! ((double )bytes / ((double )(tmp___18 - sec0) + 0.001) > (double )(mtp * (float )1024))) {
#line 861
          goto while_break___0;
        }
        {
#line 861
        sleep(1U);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 821
    bn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  n = (int )(size - (off_t )(nblocks * packet_size));
#line 866
  if (n > 0) {
    {
#line 867
    tmp___19 = readn(ffd, packet, n);
    }
#line 867
    if (tmp___19 < n) {
#line 868
      if (quiet < 3) {
        {
#line 869
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"error reading %s",
                 iso_name);
#line 870
        message((char *)"", (char )'E', (char const   *)(tmp));
        }
      }
      {
#line 872
      close(ffd);
      }
#line 873
      return (-1);
    }
#line 875
    if (sockfd) {
      {
#line 875
      tmp___21 = writen(sockfd, packet, n);
      }
#line 875
      if (tmp___21 < n) {
#line 876
        if (quiet < 3) {
          {
#line 877
          tmp___20 = __errno_location();
#line 877
          *tmp___20 = 0;
#line 878
          message((char *)"", (char )'F', "error sending data");
          }
        } else {
#line 880
          return (-1);
        }
      }
    }
#line 882
    bytes += (off_t )n;
  }
  {
#line 885
  close(ffd);
  }
#line 887
  if (thisfile) {
    {
#line 887
    tmp___22 = strlen((char const   *)(fname));
    }
#line 887
    if (tmp___22 + 40UL > (size_t )wsize.ws_col) {
      {
#line 888
      free((void *)thisfile);
      }
    }
  }
#line 890
  if (quiet < 2) {
    {
#line 900
    gettimeofday((struct timeval */* __restrict  */)(& tv2), (__timezone_ptr_t )(& tz));
#line 902
    msec = (unsigned long )((tv2.tv_usec - tv1.tv_usec) / 1000L + (tv2.tv_sec - tv1.tv_sec) * 1000L);
    }
#line 903
    if (msec < 1UL) {
#line 903
      msec = 1UL;
    }
#line 904
    thruput = (float )(((double )bytes * 1000.0) / (double )msec);
#line 907
    if (quiet == 1) {
#line 909
      if (thruput > (float )9999) {
        {
#line 910
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"transfer of %s completed: %.1f kB/s",
                 fname, (double )(thruput / (float )1024));
        }
      } else {
        {
#line 913
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"transfer of %s completed: %d byte/s",
                 fname, (int )thruput);
        }
      }
      {
#line 915
      message((char *)"", (char )'I', (char const   *)(tmp));
      }
    } else {
      {
#line 919
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s: 100%%  (",
              tinfo, fname);
      }
#line 920
      if (bytes > 9999L) {
        {
#line 921
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld kB, ",
                bytes / 1024L);
        }
      } else {
        {
#line 923
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lld byte, ",
                bytes);
        }
      }
#line 924
      if (thruput > (float )9999) {
        {
#line 925
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.1f kB/s)            \n",
                (double )(thruput / (float )1024));
        }
      } else {
        {
#line 927
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u byte/s)            \n",
                (int )thruput);
        }
      }
      {
#line 928
      fflush(stderr);
      }
    }
  }
#line 932
  if (ttime) {
#line 932
    *ttime = (float )msec;
  }
#line 935
  if (sockfd) {
    {
#line 935
    tmp___24 = getreply(sockfd);
#line 935
    tmp___25 = str_beq((char const   *)tmp___24, "201 ");
    }
#line 935
    if (! tmp___25) {
#line 936
      if (quiet < 3) {
        {
#line 937
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp) - 1UL, (char const   */* __restrict  */)"transfer failed for %s",
                 iso_name);
#line 938
        tmp___23 = __errno_location();
#line 938
        *tmp___23 = 0;
#line 939
        message((char *)"", (char )'E', (char const   *)(tmp));
        }
      }
#line 941
      return (-1);
    }
  }
#line 944
  return (0);
}
}
