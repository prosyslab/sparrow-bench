/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 36 "/home/wheatley/newnew/temp/mpack-1.6/common.h"
typedef char **params;
#line 33 "/home/wheatley/newnew/temp/mpack-1.6/part.h"
struct part {
   FILE *infile ;
   unsigned char *buf ;
   int buf_alloc ;
   unsigned char *ptr ;
   int cnt ;
   char (*boundary)[71] ;
   int *boundary_length ;
   int boundary_alloc ;
   int boundary_num ;
   int boundary_seen ;
};
#line 679 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
enum __anonenum_state_29 {
    st_start = 0,
    st_inactive = 1,
    st_decode = 2,
    st_nextlast = 3,
    st_last = 4,
    st_binhex = 5
} ;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 46 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
typedef uint32_t UINT4;
#line 59 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
struct __anonstruct_MD5_CTX_29 {
   UINT4 state[4] ;
   UINT4 count[2] ;
   unsigned char buffer[64] ;
};
#line 59 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
typedef struct __anonstruct_MD5_CTX_29 MD5_CTX;
#line 57 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
enum encoding {
    enc_none = 0,
    enc_qp = 1,
    enc_base64 = 2
} ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 40 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
typedef unsigned char *POINTER;
#line 29 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
struct magic {
   char *name ;
   char *num ;
   int len ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/home/wheatley/newnew/temp/mpack-1.6/part.h"
struct part *part_init(FILE *infile ) ;
#line 58
char *part_gets(char *s , int n , struct part *part ) ;
#line 34 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
char *os_idtodir(char *id ) ;
#line 35
FILE *os_newtypedfile(char *fname , char *contentType , int flags , params contentParams ) ;
#line 36
FILE *os_createnewfile(char *fname ) ;
#line 37
int os_binhex(struct part *inpart , int part , int nparts ) ;
#line 38
void os_closetypedfile(FILE *outfile ) ;
#line 39
void os_donewithdir(char *dir ) ;
#line 40
void os_perror(char *file ) ;
#line 41
void chat(char *s ) ;
#line 43
void part_ungets(char *s , struct part *part ) ;
#line 44
void part_close(struct part *part ) ;
#line 45
int handleMessage(struct part *inpart , char *defaultContentType , int inAppleDouble ,
                  int extractText ) ;
#line 48
static FILE *startDescFile(char *fname ) ;
#line 49
static void uudecodeline(char *line , FILE *outfile ) ;
#line 51
int parseSubject(char *subject , char **fnamep , int *partp , int *npartsp ) ;
#line 52
int saveUuFile(struct part *inpart , char *fname , int part , int nparts , char *firstline ) ;
#line 54
int descEnd(char *line ) ;
#line 55
int uudecodefiles(char *dir , int nparts ) ;
#line 70 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
static char bchar[256]  = 
#line 70
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)0,      (char)0,      (char)2, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
#line 92 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
int handleUuencode(struct part *inpart , char *subject , int extractText ) 
{ 
  char *fname ;
  char *tmpfname ;
  int part ;
  int nparts ;
  int tmppart ;
  int tmpnparts ;
  char buf___1[1024] ;
  char buf2[1024] ;
  char fnamebuf[80] ;
  char *boundary_end ;
  char *p ;
  int wantdescfile ;
  FILE *descfile ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  unsigned short const   **tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  unsigned short const   **tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  unsigned short const   **tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  unsigned short const   **tmp___57 ;
  int tmp___58 ;
  unsigned short const   **tmp___59 ;
  unsigned short const   **tmp___60 ;
  unsigned short const   **tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  unsigned short const   **tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;

  {
  {
#line 94
  fname = (char *)0;
#line 100
  wantdescfile = 0;
#line 101
  descfile = (FILE *)0;
#line 104
  tmp = parseSubject(subject, & fname, & part, & nparts);
  }
#line 104
  if (tmp != 0) {
#line 105
    part = -1;
  }
#line 107
  if (part == 0) {
    {
#line 108
    tmp___0 = saveUuFile(inpart, fname, part, nparts, (char *)0);
    }
#line 108
    return (tmp___0);
  }
#line 110
  if (part == 1) {
#line 111
    wantdescfile = 1;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    tmp___68 = part_gets(buf___1, (int )sizeof(buf___1), inpart);
    }
#line 115
    if (! tmp___68) {
#line 115
      goto while_break;
    }
    {
#line 117
    tmp___58 = strncmp((char const   *)(buf___1), "begin ", (size_t )6);
    }
#line 117
    if (tmp___58) {
      _L___11: /* CIL Label */ 
      {
#line 132
      tmp___56 = strncmp((char const   *)(buf___1), "section ", (size_t )8);
      }
#line 132
      if (tmp___56) {
        _L___7: /* CIL Label */ 
        {
#line 171
        tmp___55 = strncmp((char const   *)(buf___1), "POST V", (size_t )6);
        }
#line 171
        if (tmp___55) {
          {
#line 191
          tmp___54 = strncmp((char const   *)(buf___1), "File: ", (size_t )6);
          }
#line 191
          if (tmp___54) {
            {
#line 210
            tmp___53 = strncmp((char const   *)(buf___1), "[Section: ", (size_t )10);
            }
#line 210
            if (tmp___53) {
#line 232
              if ((int )buf___1[0] == 91) {
                {
#line 237
                tmpfname = buf___1 + 1;
#line 238
                p = strchr((char const   *)tmpfname, ' ');
                }
#line 239
                if (! p) {
#line 239
                  goto while_continue;
                }
#line 240
                tmp___32 = p;
#line 240
                p ++;
#line 240
                *tmp___32 = (char )'\000';
                {
#line 241
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 241
                  if (p) {
                    {
#line 241
                    tmp___33 = strncmp((char const   *)p, "- part ", (size_t )7);
                    }
#line 241
                    if (! (tmp___33 != 0)) {
#line 241
                      goto while_break___0;
                    }
                  } else {
#line 241
                    goto while_break___0;
                  }
                  {
#line 242
                  p = strchr((char const   *)(p + 1), '-');
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
#line 244
                if (! p) {
#line 244
                  goto while_continue;
                }
#line 245
                p += 7;
#line 246
                tmppart = 0;
                {
#line 247
                while (1) {
                  while_continue___1: /* CIL Label */ ;
                  {
#line 247
                  tmp___35 = __ctype_b_loc();
                  }
#line 247
                  if (! ((int const   )*(*tmp___35 + (int )*p) & 2048)) {
#line 247
                    goto while_break___1;
                  }
#line 247
                  tmp___34 = p;
#line 247
                  p ++;
#line 247
                  tmppart = (tmppart * 10 + (int )*tmp___34) - 48;
                }
                while_break___1: /* CIL Label */ ;
                }
#line 248
                if (tmppart == 0) {
#line 248
                  goto while_continue;
                } else {
                  {
#line 248
                  tmp___36 = strncmp((char const   *)p, " of ", (size_t )4);
                  }
#line 248
                  if (tmp___36 != 0) {
#line 248
                    goto while_continue;
                  }
                }
#line 249
                p += 4;
#line 250
                tmpnparts = 0;
                {
#line 251
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  {
#line 251
                  tmp___38 = __ctype_b_loc();
                  }
#line 251
                  if (! ((int const   )*(*tmp___38 + (int )*p) & 2048)) {
#line 251
                    goto while_break___2;
                  }
#line 251
                  tmp___37 = p;
#line 251
                  p ++;
#line 251
                  tmpnparts = (tmpnparts * 10 + (int )*tmp___37) - 48;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 252
                if (tmppart > tmpnparts) {
#line 252
                  goto while_continue;
                } else
#line 252
                if ((int )*p != 93) {
#line 252
                  goto while_continue;
                }
#line 253
                if (descfile) {
                  {
#line 253
                  fclose(descfile);
                  }
                }
                {
#line 254
                tmp___39 = saveUuFile(inpart, tmpfname, tmppart, tmpnparts, (char *)0);
                }
#line 254
                return (tmp___39);
              } else
#line 256
              if (fname) {
#line 256
                if (part > 0) {
#line 256
                  if (nparts > 0) {
#line 256
                    if (part <= nparts) {
                      {
#line 256
                      tmp___50 = strncmp((char const   *)(buf___1), "BEGIN", (size_t )5);
                      }
#line 256
                      if (tmp___50) {
                        {
#line 256
                        tmp___51 = strncmp((char const   *)(buf___1), "--- BEGIN ---",
                                           (size_t )12);
                        }
#line 256
                        if (tmp___51) {
#line 256
                          if ((int )buf___1[0] == 77) {
                            {
#line 256
                            tmp___52 = strlen((char const   *)(buf___1));
                            }
#line 256
                            if (tmp___52 == 62UL) {
                              _L___3: /* CIL Label */ 
#line 264
                              if (descfile) {
                                {
#line 264
                                fclose(descfile);
                                }
                              }
                              {
#line 265
                              tmp___40 = saveUuFile(inpart, fname, part, nparts, buf___1);
                              }
#line 265
                              return (tmp___40);
                            } else {
#line 256
                              goto _L___6;
                            }
                          } else {
#line 256
                            goto _L___6;
                          }
                        } else {
#line 256
                          goto _L___3;
                        }
                      } else {
#line 256
                        goto _L___3;
                      }
                    } else {
#line 256
                      goto _L___6;
                    }
                  } else {
#line 256
                    goto _L___6;
                  }
                } else {
#line 256
                  goto _L___6;
                }
              } else {
                _L___6: /* CIL Label */ 
                {
#line 267
                tmp___49 = strncasecmp((char const   *)(buf___1), "x-file-name: ",
                                       (size_t )13);
                }
#line 267
                if (tmp___49) {
                  {
#line 275
                  tmp___48 = strncasecmp((char const   *)(buf___1), "x-part: ", (size_t )8);
                  }
#line 275
                  if (tmp___48) {
                    {
#line 280
                    tmp___47 = strncasecmp((char const   *)(buf___1), "x-part-total: ",
                                           (size_t )14);
                    }
#line 280
                    if (tmp___47) {
#line 285
                      if (part == 1) {
#line 285
                        if (fname) {
#line 285
                          if (! descfile) {
                            {
#line 285
                            tmp___46 = strncasecmp((char const   *)(buf___1), "x-file-desc: ",
                                                   (size_t )13);
                            }
#line 285
                            if (tmp___46) {
#line 285
                              goto _L___1;
                            } else {
                              {
#line 287
                              descfile = startDescFile(fname);
                              }
#line 287
                              if (descfile) {
                                {
#line 288
                                fputs((char const   */* __restrict  */)(buf___1 + 13),
                                      (FILE */* __restrict  */)descfile);
#line 289
                                fclose(descfile);
#line 290
                                descfile = (FILE *)0;
                                }
                              }
#line 292
                              goto while_continue;
                            }
                          } else {
#line 285
                            goto _L___1;
                          }
                        } else {
#line 285
                          goto _L___1;
                        }
                      } else {
                        _L___1: /* CIL Label */ 
                        {
#line 294
                        tmp___45 = strcmp((char const   *)(buf___1), "(This file must be converted with BinHex 4.0)\n");
                        }
#line 294
                        if (tmp___45) {
                          {
#line 299
                          tmp___44 = strncasecmp((char const   *)(buf___1), "content-",
                                                 (size_t )8);
                          }
#line 299
                          if (! tmp___44) {
#line 304
                            p = buf___1 + 8;
                            {
#line 306
                            while (1) {
                              while_continue___3: /* CIL Label */ ;
#line 306
                              if (! *p) {
#line 306
                                goto while_break___3;
                              }
#line 307
                              if ((int )*p == 58) {
#line 307
                                goto while_break___3;
                              } else
#line 307
                              if ((int )*p <= 32) {
#line 307
                                goto while_break___3;
                              } else
#line 307
                              if ((int )*p >= 127) {
#line 307
                                goto while_break___3;
                              }
#line 308
                              p ++;
                            }
                            while_break___3: /* CIL Label */ ;
                            }
#line 310
                            if ((int )*p == 58) {
                              {
#line 311
                              part_ungets(buf___1, inpart);
                              }
#line 312
                              if (descfile) {
                                {
#line 312
                                fclose(descfile);
                                }
                              }
                              {
#line 313
                              tmp___43 = handleMessage(inpart, (char *)"text/plain",
                                                       0, extractText);
                              }
#line 313
                              return (tmp___43);
                            }
                          }
                        } else {
#line 296
                          if (descfile) {
                            {
#line 296
                            fclose(descfile);
                            }
                          }
                          {
#line 297
                          tmp___42 = os_binhex(inpart, 1, 1);
                          }
#line 297
                          return (tmp___42);
                        }
                      }
                    } else {
                      {
#line 281
                      tmpnparts = atoi((char const   *)(buf___1 + 14));
                      }
#line 282
                      if (tmpnparts > 0) {
#line 282
                        nparts = tmpnparts;
                      }
#line 283
                      goto while_continue;
                    }
                  } else {
                    {
#line 276
                    tmppart = atoi((char const   *)(buf___1 + 8));
                    }
#line 277
                    if (tmppart > 0) {
#line 277
                      part = tmppart;
                    }
#line 278
                    goto while_continue;
                  }
                } else {
#line 268
                  p = buf___1 + 13;
                  {
#line 268
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 268
                    if (*p) {
                      {
#line 268
                      tmp___41 = __ctype_b_loc();
                      }
#line 268
                      if ((int const   )*(*tmp___41 + (int )*p) & 8192) {
#line 268
                        goto while_break___4;
                      }
                    } else {
#line 268
                      goto while_break___4;
                    }
#line 268
                    p ++;
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                  {
#line 269
                  *p = (char )'\000';
#line 270
                  strncpy((char */* __restrict  */)(fnamebuf), (char const   */* __restrict  */)(buf___1 + 13),
                          sizeof(fnamebuf) - 1UL);
#line 271
                  fnamebuf[sizeof(fnamebuf) - 1UL] = (char )'\000';
#line 272
                  fname = fnamebuf;
                  }
#line 273
                  goto while_continue;
                }
              }
            } else {
#line 214
              tmppart = 0;
#line 215
              p = buf___1 + 10;
              {
#line 215
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 215
                tmp___27 = __ctype_b_loc();
                }
#line 215
                if (! ((int const   )*(*tmp___27 + (int )*p) & 2048)) {
#line 215
                  goto while_break___5;
                }
#line 215
                tmppart = (tmppart * 10 + (int )*p) - 48;
#line 215
                p ++;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 216
              if (tmppart == 0) {
#line 216
                goto while_continue;
              }
#line 217
              tmpnparts = 0;
#line 218
              p ++;
              {
#line 218
              while (1) {
                while_continue___6: /* CIL Label */ ;
                {
#line 218
                tmp___28 = __ctype_b_loc();
                }
#line 218
                if (! ((int const   )*(*tmp___28 + (int )*p) & 2048)) {
#line 218
                  goto while_break___6;
                }
#line 219
                tmpnparts = (tmpnparts * 10 + (int )*p) - 48;
#line 218
                p ++;
              }
              while_break___6: /* CIL Label */ ;
              }
              {
#line 221
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 221
                if (*p) {
                  {
#line 221
                  tmp___29 = __ctype_b_loc();
                  }
#line 221
                  if (! ((int const   )*(*tmp___29 + (int )*p) & 8192)) {
#line 221
                    goto while_break___7;
                  }
                } else {
#line 221
                  goto while_break___7;
                }
#line 221
                p ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 222
              if (tmppart > tmpnparts) {
#line 223
                goto while_continue;
              } else {
                {
#line 222
                tmp___30 = strncmp((char const   *)p, "File: ", (size_t )6);
                }
#line 222
                if (tmp___30 != 0) {
#line 223
                  goto while_continue;
                }
              }
              {
#line 225
              tmpfname = p + 6;
#line 226
              p = strchr((char const   *)tmpfname, ' ');
              }
#line 227
              if (! p) {
#line 227
                goto while_continue;
              }
#line 228
              *p = (char )'\000';
#line 229
              if (descfile) {
                {
#line 229
                fclose(descfile);
                }
              }
              {
#line 230
              tmp___31 = saveUuFile(inpart, tmpfname, tmppart, tmpnparts, (char *)0);
              }
#line 230
              return (tmp___31);
            }
          } else {
            {
#line 195
            tmpfname = buf___1 + 6;
#line 196
            p = strchr((char const   *)tmpfname, ' ');
            }
#line 197
            if (! p) {
#line 197
              goto while_continue;
            } else {
              {
#line 197
              tmp___19 = strncmp((char const   *)p, " -- part ", (size_t )9);
              }
#line 197
              if (tmp___19 != 0) {
#line 197
                goto while_continue;
              }
            }
#line 198
            *p = (char )'\000';
#line 199
            p += 9;
#line 200
            tmppart = 0;
            {
#line 201
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 201
              tmp___21 = __ctype_b_loc();
              }
#line 201
              if (! ((int const   )*(*tmp___21 + (int )*p) & 2048)) {
#line 201
                goto while_break___8;
              }
#line 201
              tmp___20 = p;
#line 201
              p ++;
#line 201
              tmppart = (tmppart * 10 + (int )*tmp___20) - 48;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 202
            if (tmppart == 0) {
#line 202
              goto while_continue;
            } else {
              {
#line 202
              tmp___22 = strncmp((char const   *)p, " of ", (size_t )4);
              }
#line 202
              if (tmp___22 != 0) {
#line 202
                goto while_continue;
              }
            }
#line 203
            p += 4;
#line 204
            tmpnparts = 0;
            {
#line 205
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 205
              tmp___24 = __ctype_b_loc();
              }
#line 205
              if (! ((int const   )*(*tmp___24 + (int )*p) & 2048)) {
#line 205
                goto while_break___9;
              }
#line 205
              tmp___23 = p;
#line 205
              p ++;
#line 205
              tmpnparts = (tmpnparts * 10 + (int )*tmp___23) - 48;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 206
            if (tmppart > tmpnparts) {
#line 206
              goto while_continue;
            } else {
              {
#line 206
              tmp___25 = strncmp((char const   *)p, " -- ", (size_t )4);
              }
#line 206
              if (tmp___25 != 0) {
#line 206
                goto while_continue;
              }
            }
#line 207
            if (descfile) {
              {
#line 207
              fclose(descfile);
              }
            }
            {
#line 208
            tmp___26 = saveUuFile(inpart, tmpfname, tmppart, tmpnparts, (char *)0);
            }
#line 208
            return (tmp___26);
          }
        } else {
          {
#line 175
          p = strchr((char const   *)(buf___1 + 6), ' ');
          }
#line 176
          if (! p) {
#line 176
            goto while_continue;
          }
          {
#line 177
          tmpfname = p + 1;
#line 178
          p = strchr((char const   *)tmpfname, ' ');
          }
#line 179
          if (! p) {
#line 179
            goto while_continue;
          } else {
            {
#line 179
            tmp___12 = strncmp((char const   *)p, " (Part ", (size_t )7);
            }
#line 179
            if (tmp___12 != 0) {
#line 179
              goto while_continue;
            }
          }
#line 180
          *p = (char )'\000';
#line 181
          p += 7;
#line 182
          tmppart = 0;
          {
#line 183
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 183
            tmp___14 = __ctype_b_loc();
            }
#line 183
            if (! ((int const   )*(*tmp___14 + (int )*p) & 2048)) {
#line 183
              goto while_break___10;
            }
#line 183
            tmp___13 = p;
#line 183
            p ++;
#line 183
            tmppart = (tmppart * 10 + (int )*tmp___13) - 48;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 184
          if (tmppart == 0) {
#line 184
            goto while_continue;
          } else {
#line 184
            tmp___15 = p;
#line 184
            p ++;
#line 184
            if ((int )*tmp___15 != 47) {
#line 184
              goto while_continue;
            }
          }
#line 185
          tmpnparts = 0;
          {
#line 186
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 186
            tmp___17 = __ctype_b_loc();
            }
#line 186
            if (! ((int const   )*(*tmp___17 + (int )*p) & 2048)) {
#line 186
              goto while_break___11;
            }
#line 186
            tmp___16 = p;
#line 186
            p ++;
#line 186
            tmpnparts = (tmpnparts * 10 + (int )*tmp___16) - 48;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 187
          if (tmppart > tmpnparts) {
#line 187
            goto while_continue;
          } else
#line 187
          if ((int )*p != 41) {
#line 187
            goto while_continue;
          }
#line 188
          if (descfile) {
            {
#line 188
            fclose(descfile);
            }
          }
          {
#line 189
          tmp___18 = saveUuFile(inpart, tmpfname, tmppart, tmpnparts, (char *)0);
          }
#line 189
          return (tmp___18);
        }
      } else {
        {
#line 132
        tmp___57 = __ctype_b_loc();
        }
#line 132
        if ((int const   )*(*tmp___57 + (int )buf___1[8]) & 2048) {
#line 133
          tmppart = 0;
#line 134
          p = buf___1 + 8;
          {
#line 134
          while (1) {
            while_continue___12: /* CIL Label */ ;
            {
#line 134
            tmp___3 = __ctype_b_loc();
            }
#line 134
            if (! ((int const   )*(*tmp___3 + (int )*p) & 2048)) {
#line 134
              goto while_break___12;
            }
#line 134
            tmppart = (tmppart * 10 + (int )*p) - 48;
#line 134
            p ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 135
          if (tmppart == 0) {
#line 135
            goto while_continue;
          }
          {
#line 136
          tmp___11 = strncmp((char const   *)p, " of ", (size_t )4);
          }
#line 136
          if (tmp___11 == 0) {
#line 140
            p += 4;
            {
#line 140
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 140
              if (*p) {
                {
#line 140
                tmp___4 = strncmp((char const   *)p, " of file ", (size_t )9);
                }
#line 140
                if (! (tmp___4 != 0)) {
#line 140
                  goto while_break___13;
                }
              } else {
#line 140
                goto while_break___13;
              }
#line 140
              p ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 141
            if (! *p) {
#line 141
              goto while_continue;
            }
            {
#line 142
            p += 9;
#line 143
            tmpfname = p;
#line 144
            p = strchr((char const   *)p, ' ');
            }
#line 145
            if (! p) {
#line 145
              goto while_continue;
            }
#line 146
            *p = (char )'\000';
#line 147
            if (descfile) {
              {
#line 147
              fclose(descfile);
              }
            }
            {
#line 148
            tmp___5 = saveUuFile(inpart, tmpfname, tmppart, 0, (char *)0);
            }
#line 148
            return (tmp___5);
          } else
#line 150
          if ((int )*p == 47) {
            {
#line 150
            tmp___10 = __ctype_b_loc();
            }
#line 150
            if ((int const   )*(*tmp___10 + (int )*(p + 1)) & 2048) {
#line 154
              tmpnparts = 0;
#line 155
              p ++;
              {
#line 155
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 155
                tmp___6 = __ctype_b_loc();
                }
#line 155
                if (! ((int const   )*(*tmp___6 + (int )*p) & 2048)) {
#line 155
                  goto while_break___14;
                }
#line 156
                tmpnparts = (tmpnparts * 10 + (int )*p) - 48;
#line 155
                p ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              {
#line 158
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 158
                if (*p) {
                  {
#line 158
                  tmp___7 = __ctype_b_loc();
                  }
#line 158
                  if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 158
                    goto while_break___15;
                  }
                } else {
#line 158
                  goto while_break___15;
                }
#line 158
                p ++;
              }
              while_break___15: /* CIL Label */ ;
              }
#line 159
              if (tmppart > tmpnparts) {
#line 160
                goto while_continue;
              } else {
                {
#line 159
                tmp___8 = strncmp((char const   *)p, "file ", (size_t )5);
                }
#line 159
                if (tmp___8 != 0) {
#line 160
                  goto while_continue;
                }
              }
              {
#line 162
              tmpfname = p + 5;
#line 163
              p = strchr((char const   *)tmpfname, ' ');
              }
#line 164
              if (! p) {
#line 164
                goto while_continue;
              }
#line 165
              *p = (char )'\000';
#line 166
              if (descfile) {
                {
#line 166
                fclose(descfile);
                }
              }
              {
#line 167
              tmp___9 = saveUuFile(inpart, tmpfname, tmppart, tmpnparts, (char *)0);
              }
#line 167
              return (tmp___9);
            }
          }
        } else {
#line 132
          goto _L___7;
        }
      }
    } else {
      {
#line 117
      tmp___59 = __ctype_b_loc();
      }
#line 117
      if ((int const   )*(*tmp___59 + (int )buf___1[6]) & 2048) {
        {
#line 117
        tmp___60 = __ctype_b_loc();
        }
#line 117
        if ((int const   )*(*tmp___60 + (int )buf___1[7]) & 2048) {
          {
#line 117
          tmp___61 = __ctype_b_loc();
          }
#line 117
          if ((int const   )*(*tmp___61 + (int )buf___1[8]) & 2048) {
#line 117
            if ((int )buf___1[9] == 32) {
#line 120
              if (part == -1) {
                {
#line 125
                tmp___1 = saveUuFile(inpart, (char *)0, 1, 0, buf___1);
                }
#line 125
                return (tmp___1);
              } else {
#line 128
                if (descfile) {
                  {
#line 128
                  fclose(descfile);
                  }
                }
                {
#line 129
                tmp___2 = saveUuFile(inpart, fname, part, nparts, buf___1);
                }
#line 129
                return (tmp___2);
              }
            } else {
#line 117
              goto _L___11;
            }
          } else {
#line 117
            goto _L___11;
          }
        } else {
#line 117
          goto _L___11;
        }
      } else {
#line 117
        goto _L___11;
      }
    }
#line 316
    if ((int )buf___1[0] == 45) {
#line 316
      if ((int )buf___1[1] == 45) {
#line 322
        p = buf___1 + 2;
        {
#line 323
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 323
          if (! *p) {
#line 323
            goto while_break___16;
          }
#line 324
          if (! bchar[(unsigned char )*p]) {
#line 324
            goto while_break___16;
          }
#line 325
          p ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 327
        if ((int )*p != 10) {
#line 332
          p = buf___1 + 2;
        }
        {
#line 335
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 335
          if ((unsigned long )p > (unsigned long )(buf___1 + 2)) {
#line 335
            if (! ((int )*(p + -1) == 32)) {
#line 335
              goto while_break___17;
            }
          } else {
#line 335
            goto while_break___17;
          }
#line 335
          p --;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 341
        if (p - buf___1 > 2L) {
#line 341
          if (p - buf___1 <= 72L) {
            {
#line 341
            tmp___63 = part_gets(buf2, (int )sizeof(buf2), inpart);
            }
#line 341
            if (tmp___63) {
#line 343
              boundary_end = p;
#line 344
              p = buf2;
              {
#line 357
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 357
                if (! *p) {
#line 357
                  goto while_break___18;
                }
#line 358
                if ((int )*p == 58) {
#line 358
                  goto while_break___18;
                } else
#line 358
                if ((int )*p <= 32) {
#line 358
                  goto while_break___18;
                } else
#line 358
                if ((int )*p >= 127) {
#line 358
                  goto while_break___18;
                }
#line 359
                p ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 363
              part_ungets(buf2, inpart);
              }
#line 365
              if ((unsigned long )p > (unsigned long )(buf2)) {
#line 365
                if ((int )*p == 58) {
                  {
#line 367
                  part_ungets(buf___1, inpart);
#line 373
                  *boundary_end = (char )'\000';
#line 374
                  sprintf((char */* __restrict  */)(buf2), (char const   */* __restrict  */)"Content-type: multipart/mixed; boundary=\"%s\"\n\n",
                          buf___1 + 2);
#line 377
                  part_ungets(buf2, inpart);
                  }
#line 379
                  if (descfile) {
                    {
#line 379
                    fclose(descfile);
                    }
                  }
                  {
#line 380
                  tmp___62 = handleMessage(inpart, (char *)"text/plain", 0, extractText);
                  }
#line 380
                  return (tmp___62);
                }
              }
            }
          }
        }
      }
    }
#line 389
    if (wantdescfile) {
#line 389
      if (! descfile) {
#line 390
        p = buf___1;
        {
#line 390
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 390
          if (*p) {
            {
#line 390
            tmp___64 = __ctype_b_loc();
            }
#line 390
            if (! ((int const   )*(*tmp___64 + (int )*p) & 8192)) {
#line 390
              goto while_break___19;
            }
          } else {
#line 390
            goto while_break___19;
          }
#line 390
          p ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 391
        if (*p) {
          {
#line 392
          tmp___65 = strncasecmp((char const   *)p, "x-", (size_t )2);
          }
#line 392
          if (! tmp___65) {
            {
#line 398
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 398
              if ((int )*p != 58) {
#line 398
                if ((int )*p > 32) {
#line 398
                  if (! ((int )*p < 127)) {
#line 398
                    goto while_break___20;
                  }
                } else {
#line 398
                  goto while_break___20;
                }
              } else {
#line 398
                goto while_break___20;
              }
#line 398
              p ++;
            }
            while_break___20: /* CIL Label */ ;
            }
#line 399
            if ((int )*p == 58) {
#line 399
              goto while_continue;
            }
          }
          {
#line 401
          tmp___66 = descEnd(buf___1);
          }
#line 401
          if (! tmp___66) {
            {
#line 401
            descfile = startDescFile(fname);
            }
#line 401
            if (descfile) {
              {
#line 402
              fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)descfile);
              }
            }
          }
#line 404
          wantdescfile = 0;
        }
      } else {
#line 389
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 407
    if (descfile) {
      {
#line 408
      tmp___67 = descEnd(buf___1);
      }
#line 408
      if (tmp___67) {
        {
#line 409
        fclose(descfile);
#line 410
        descfile = (FILE *)0;
        }
      } else {
        {
#line 413
        fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)descfile);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  if (descfile) {
    {
#line 418
    fclose(descfile);
    }
  }
#line 419
  return (0);
}
}
#line 428 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
int saveUuFile(struct part *inpart , char *fname , int part , int nparts , char *firstline ) 
{ 
  char buf___1[1024] ;
  char *dir ;
  FILE *partfile ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 435
  if (fname) {
    {
#line 436
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"Saving part %d ",
            part);
    }
#line 437
    if (nparts) {
      {
#line 437
      tmp = strlen((char const   *)(buf___1));
#line 437
      sprintf((char */* __restrict  */)(buf___1 + tmp), (char const   */* __restrict  */)"of %d ",
              nparts);
      }
    }
    {
#line 438
    strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)fname);
#line 439
    chat(buf___1);
    }
  } else {
#line 441
    fname = (char *)"unknown";
  }
  {
#line 444
  dir = os_idtodir(fname);
  }
#line 445
  if (! dir) {
#line 445
    return (1);
  }
  {
#line 446
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
          dir, part);
#line 447
  partfile = os_createnewfile(buf___1);
  }
#line 448
  if (! partfile) {
    {
#line 449
    os_perror(buf___1);
    }
#line 450
    return (1);
  }
#line 452
  if (firstline) {
    {
#line 452
    fputs((char const   */* __restrict  */)firstline, (FILE */* __restrict  */)partfile);
    }
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 453
    tmp___1 = part_gets(buf___1, (int )sizeof(buf___1), inpart);
    }
#line 453
    if (! tmp___1) {
#line 453
      goto while_break;
    }
    {
#line 454
    fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)partfile);
    }
#line 455
    if (nparts == 0) {
      {
#line 455
      tmp___0 = strcmp((char const   *)(buf___1), "end\n");
      }
#line 455
      if (tmp___0 == 0) {
        {
#line 457
        nparts = part;
#line 458
        fclose(partfile);
#line 459
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
                dir);
#line 460
        partfile = os_createnewfile(buf___1);
        }
#line 461
        if (! partfile) {
          {
#line 462
          os_perror(buf___1);
          }
        } else {
          {
#line 465
          fprintf((FILE */* __restrict  */)partfile, (char const   */* __restrict  */)"%d\n",
                  nparts);
          }
        }
#line 467
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  fclose(partfile);
  }
#line 473
  if (nparts == 0) {
    {
#line 474
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
            dir);
#line 475
    partfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 475
    if (partfile) {
      {
#line 476
      tmp___2 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)partfile);
      }
#line 476
      if (tmp___2) {
        {
#line 477
        nparts = atoi((char const   *)(buf___1));
        }
#line 478
        if (nparts < 0) {
#line 478
          nparts = 0;
        }
      }
      {
#line 480
      fclose(partfile);
      }
    }
  }
#line 484
  if (nparts == 0) {
#line 484
    return (0);
  }
#line 489
  part = nparts;
  {
#line 489
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 489
    if (! part) {
#line 489
      goto while_break___0;
    }
    {
#line 490
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, part);
#line 491
    partfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 492
    if (partfile) {
      {
#line 493
      fclose(partfile);
      }
    } else {
#line 496
      return (0);
    }
#line 489
    part --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 500
  tmp___3 = uudecodefiles(dir, nparts);
  }
#line 500
  return (tmp___3);
}
}
#line 507 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
int parseSubject(char *subject , char **fnamep , int *partp , int *npartsp ) 
{ 
  char *scan ;
  char *bak ;
  char *start ;
  int part ;
  int nparts ;
  int hasdot ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  char *tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  char *tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  unsigned short const   **tmp___25 ;
  char *tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  char *tmp___29 ;
  unsigned short const   **tmp___30 ;
  unsigned short const   **tmp___31 ;
  int tmp___32 ;

  {
#line 511
  part = -1;
#line 511
  nparts = 0;
#line 511
  hasdot = 0;
#line 514
  if (! subject) {
#line 514
    return (1);
  }
#line 517
  scan = subject;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! ((int )*scan == 32)) {
#line 518
      if (! ((int )*scan == 9)) {
#line 518
        if (! ((int )*scan == 45)) {
#line 518
          goto while_break;
        }
      }
    }
#line 518
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 519
  tmp = strncasecmp((char const   *)scan, "repost", (size_t )6);
  }
#line 519
  if (! tmp) {
#line 520
    scan += 6;
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (! ((int )*scan == 32)) {
#line 520
        if (! ((int )*scan == 9)) {
#line 520
          if (! ((int )*scan == 58)) {
#line 520
            if (! ((int )*scan == 45)) {
#line 520
              goto while_break___0;
            }
          }
        }
      }
#line 520
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 525
  tmp___0 = strncasecmp((char const   *)scan, "re:", (size_t )3);
  }
#line 525
  if (! tmp___0) {
#line 525
    return (1);
  }
  {
#line 533
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 534
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 534
      if ((int )*scan != 10) {
        {
#line 534
        tmp___1 = __ctype_b_loc();
        }
#line 534
        if ((int const   )*(*tmp___1 + (int )*scan) & 8) {
#line 534
          goto while_break___2;
        } else
#line 534
        if (! ((int )*scan != 95)) {
#line 534
          goto while_break___2;
        }
      } else {
#line 534
        goto while_break___2;
      }
#line 534
      scan ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 535
    start = scan;
#line 535
    *fnamep = start;
    {
#line 536
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 536
      tmp___3 = __ctype_b_loc();
      }
#line 536
      if (! ((int const   )*(*tmp___3 + (int )*scan) & 8)) {
#line 536
        if (! ((int )*scan == 45)) {
#line 536
          if (! ((int )*scan == 43)) {
#line 536
            if (! ((int )*scan == 38)) {
#line 536
              if (! ((int )*scan == 95)) {
#line 536
                if (! ((int )*scan == 46)) {
#line 536
                  goto while_break___3;
                }
              }
            }
          }
        }
      }
#line 538
      tmp___2 = scan;
#line 538
      scan ++;
#line 538
      if ((int )*tmp___2 == 46) {
#line 538
        hasdot = 1;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 540
    if (! *scan) {
#line 540
      return (1);
    } else
#line 540
    if ((int )*scan == 10) {
#line 540
      return (1);
    }
#line 533
    if (! ((unsigned long )start == (unsigned long )scan)) {
#line 533
      if ((int )*(start + 0) == 118) {
        {
#line 533
        tmp___4 = __ctype_b_loc();
        }
#line 533
        if ((int const   )*(*tmp___4 + (int )*(start + 1)) & 2048) {
#line 533
          if (! ((int )*scan == 58)) {
#line 533
            goto while_break___1;
          }
        } else {
#line 533
          goto while_break___1;
        }
      } else {
#line 533
        goto while_break___1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 543
  tmp___5 = scan;
#line 543
  scan ++;
#line 543
  *tmp___5 = (char )'\000';
#line 548
  if (! hasdot) {
    {
#line 549
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 549
      start = scan;
#line 549
      if ((int )*start != 0) {
#line 549
        if (! ((int )*scan != 10)) {
#line 549
          goto while_break___4;
        }
      } else {
#line 549
        goto while_break___4;
      }
      {
#line 550
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 550
        tmp___6 = __ctype_b_loc();
        }
#line 550
        if (! ((int const   )*(*tmp___6 + (int )*start) & 8192)) {
#line 550
          goto while_break___5;
        }
#line 550
        start ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 551
      scan = start;
      {
#line 551
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 551
        tmp___9 = __ctype_b_loc();
        }
#line 551
        if (! ((int const   )*(*tmp___9 + (int )*scan) & 8)) {
#line 551
          if (! ((int )*scan == 45)) {
#line 551
            if (! ((int )*scan == 43)) {
#line 551
              if (! ((int )*scan == 38)) {
#line 551
                if (! ((int )*scan == 95)) {
#line 551
                  if (! ((int )*scan == 46)) {
#line 551
                    goto while_break___6;
                  }
                }
              }
            }
          }
        }
#line 553
        if ((int )*scan == 46) {
          {
#line 553
          tmp___7 = __ctype_b_loc();
          }
#line 553
          if ((int const   )*(*tmp___7 + (int )*(scan + -1)) & 2048) {
            {
#line 553
            tmp___8 = __ctype_b_loc();
            }
#line 553
            if (! ((int const   )*(*tmp___8 + (int )*(scan + 1)) & 2048)) {
#line 555
              hasdot = 1;
            }
          } else {
#line 555
            hasdot = 1;
          }
        }
#line 551
        scan ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 558
      if (hasdot) {
#line 558
        if ((unsigned long )scan > (unsigned long )start) {
#line 559
          *fnamep = start;
#line 560
          tmp___10 = scan;
#line 560
          scan ++;
#line 560
          *tmp___10 = (char )'\000';
#line 561
          goto while_break___4;
        }
      }
      {
#line 563
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 563
        if (*scan) {
#line 563
          if ((int )*scan != 10) {
            {
#line 563
            tmp___11 = __ctype_b_loc();
            }
#line 563
            if ((int const   )*(*tmp___11 + (int )*scan) & 8) {
#line 563
              goto while_break___7;
            }
          } else {
#line 563
            goto while_break___7;
          }
        } else {
#line 563
          goto while_break___7;
        }
#line 563
        scan ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 565
    tmp___12 = strlen((char const   *)*fnamep);
#line 565
    scan = (*fnamep + tmp___12) + 1;
    }
  }
  {
#line 569
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 569
    if (*scan) {
#line 569
      if (! ((int )*scan != 10)) {
#line 569
        goto while_break___8;
      }
    } else {
#line 569
      goto while_break___8;
    }
#line 571
    if ((int )*scan == 118) {
      {
#line 571
      tmp___14 = __ctype_b_loc();
      }
#line 571
      if ((int const   )*(*tmp___14 + (int )*(scan + 1)) & 2048) {
#line 572
        scan ++;
        {
#line 573
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 573
          tmp___13 = __ctype_b_loc();
          }
#line 573
          if (! ((int const   )*(*tmp___13 + (int )*scan) & 2048)) {
#line 573
            goto while_break___9;
          }
#line 573
          scan ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
    {
#line 576
    tmp___22 = __ctype_b_loc();
    }
#line 576
    if ((int const   )*(*tmp___22 + (int )*scan) & 2048) {
#line 576
      if ((int )*(scan + 1) == 47) {
#line 576
        goto _L;
      } else
#line 576
      if ((int )*(scan + 1) == 32) {
#line 576
        if ((int )*(scan + 2) == 47) {
#line 576
          goto _L;
        } else {
#line 576
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 576
      if ((int )*(scan + 1) == 32) {
#line 576
        if ((int )*(scan + 2) == 111) {
#line 576
          if ((int )*(scan + 3) == 102) {
#line 576
            goto _L;
          } else {
#line 576
            goto _L___3;
          }
        } else {
#line 576
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 576
      if ((int )*(scan + 1) == 45) {
#line 576
        if ((int )*(scan + 2) == 111) {
#line 576
          if ((int )*(scan + 3) == 102) {
#line 576
            goto _L;
          } else {
#line 576
            goto _L___1;
          }
        } else {
#line 576
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 576
      if ((int )*(scan + 1) == 111) {
        {
#line 576
        tmp___23 = __ctype_b_loc();
        }
#line 576
        if ((int const   )*(*tmp___23 + (int )*(scan + 2)) & 2048) {
          _L: /* CIL Label */ 
          {
#line 582
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 582
            tmp___15 = __ctype_b_loc();
            }
#line 582
            if (! ((int const   )*(*tmp___15 + (int )*(scan + -1)) & 2048)) {
#line 582
              goto while_break___10;
            }
#line 582
            scan --;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 583
          part = 0;
          {
#line 584
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 584
            tmp___17 = __ctype_b_loc();
            }
#line 584
            if (! ((int const   )*(*tmp___17 + (int )*scan) & 2048)) {
#line 584
              goto while_break___11;
            }
#line 585
            tmp___16 = scan;
#line 585
            scan ++;
#line 585
            part = (part * 10 + (int )*tmp___16) - 48;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 587
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 587
            if ((int )*scan != 0) {
#line 587
              if ((int )*scan != 10) {
                {
#line 587
                tmp___18 = __ctype_b_loc();
                }
#line 587
                if ((int const   )*(*tmp___18 + (int )*scan) & 2048) {
#line 587
                  goto while_break___12;
                }
              } else {
#line 587
                goto while_break___12;
              }
            } else {
#line 587
              goto while_break___12;
            }
#line 587
            scan ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 588
          tmp___21 = __ctype_b_loc();
          }
#line 588
          if ((int const   )*(*tmp___21 + (int )*scan) & 2048) {
#line 589
            nparts = 0;
            {
#line 590
            while (1) {
              while_continue___13: /* CIL Label */ ;
              {
#line 590
              tmp___20 = __ctype_b_loc();
              }
#line 590
              if (! ((int const   )*(*tmp___20 + (int )*scan) & 2048)) {
#line 590
                goto while_break___13;
              }
#line 591
              tmp___19 = scan;
#line 591
              scan ++;
#line 591
              nparts = (nparts * 10 + (int )*tmp___19) - 48;
            }
            while_break___13: /* CIL Label */ ;
            }
          }
#line 594
          goto while_break___8;
        }
      }
    }
    {
#line 598
    tmp___32 = strncasecmp("part", (char const   *)scan, (size_t )4);
    }
#line 598
    if (! tmp___32) {
#line 599
      if ((int )*(scan + 4) == 115) {
#line 600
        bak = scan;
        {
#line 600
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 600
          if ((unsigned long )bak >= (unsigned long )subject) {
            {
#line 600
            tmp___24 = __ctype_b_loc();
            }
#line 600
            if ((int const   )*(*tmp___24 + (int )*bak) & 2048) {
#line 600
              goto while_break___14;
            }
          } else {
#line 600
            goto while_break___14;
          }
#line 600
          bak --;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 601
        if ((unsigned long )bak > (unsigned long )subject) {
          {
#line 602
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 602
            if ((unsigned long )bak > (unsigned long )subject) {
              {
#line 602
              tmp___25 = __ctype_b_loc();
              }
#line 602
              if (! ((int const   )*(*tmp___25 + (int )*(bak + -1)) & 2048)) {
#line 602
                goto while_break___15;
              }
            } else {
#line 602
              goto while_break___15;
            }
#line 602
            bak --;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 603
          nparts = 0;
          {
#line 604
          while (1) {
            while_continue___16: /* CIL Label */ ;
            {
#line 604
            tmp___27 = __ctype_b_loc();
            }
#line 604
            if (! ((int const   )*(*tmp___27 + (int )*bak) & 2048)) {
#line 604
              goto while_break___16;
            }
#line 605
            tmp___26 = bak;
#line 605
            bak ++;
#line 605
            nparts = (nparts * 10 + (int )*tmp___26) - 48;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 609
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 609
          if (*scan) {
#line 609
            if ((int )*scan != 10) {
              {
#line 609
              tmp___28 = __ctype_b_loc();
              }
#line 609
              if ((int const   )*(*tmp___28 + (int )*scan) & 2048) {
#line 609
                goto while_break___17;
              }
            } else {
#line 609
              goto while_break___17;
            }
          } else {
#line 609
            goto while_break___17;
          }
#line 609
          scan ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        {
#line 610
        bak = scan - 1;
#line 611
        tmp___31 = __ctype_b_loc();
        }
#line 611
        if ((int const   )*(*tmp___31 + (int )*scan) & 2048) {
#line 612
          part = 0;
          {
#line 613
          while (1) {
            while_continue___18: /* CIL Label */ ;
            {
#line 614
            tmp___29 = scan;
#line 614
            scan ++;
#line 614
            part = (part * 10 + (int )*tmp___29) - 48;
#line 613
            tmp___30 = __ctype_b_loc();
            }
#line 613
            if (! ((int const   )*(*tmp___30 + (int )*scan) & 2048)) {
#line 613
              goto while_break___18;
            }
          }
          while_break___18: /* CIL Label */ ;
          }
        }
#line 617
        scan = bak;
      }
    }
#line 620
    scan ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 623
  if (nparts == 0) {
#line 623
    return (1);
  } else
#line 623
  if (part == -1) {
#line 623
    return (1);
  } else
#line 623
  if (part > nparts) {
#line 623
    return (1);
  }
#line 624
  *partp = part;
#line 625
  *npartsp = nparts;
#line 626
  return (0);
}
}
#line 632 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
int descEnd(char *line ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 635
  tmp = strncmp((char const   *)line, "---", (size_t )3);
  }
#line 635
  if (tmp) {
    {
#line 635
    tmp___0 = strncmp((char const   *)line, "#!", (size_t )2);
    }
#line 635
    if (tmp___0) {
      {
#line 635
      tmp___1 = strncasecmp((char const   *)line, "part=", (size_t )5);
      }
#line 635
      if (tmp___1) {
        {
#line 635
        tmp___2 = strncasecmp((char const   *)line, "begin", (size_t )5);
        }
#line 635
        if (tmp___2) {
#line 635
          tmp___3 = 0;
        } else {
#line 635
          tmp___3 = 1;
        }
      } else {
#line 635
        tmp___3 = 1;
      }
    } else {
#line 635
      tmp___3 = 1;
    }
  } else {
#line 635
    tmp___3 = 1;
  }
#line 635
  return (tmp___3);
}
}
#line 646 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
static FILE *startDescFile(char *fname ) 
{ 
  char buf___1[1024] ;
  char *dir ;
  FILE *descfile ;

  {
  {
#line 653
  dir = os_idtodir(fname);
  }
#line 654
  if (! dir) {
#line 654
    return ((FILE *)0);
  }
  {
#line 655
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s0",
          dir);
#line 658
  descfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
  }
#line 659
  if (descfile) {
    {
#line 660
    fclose(descfile);
    }
#line 661
    return ((FILE *)0);
  }
  {
#line 664
  descfile = os_createnewfile(buf___1);
  }
#line 665
  if (! descfile) {
    {
#line 666
    os_perror(buf___1);
    }
#line 667
    return ((FILE *)0);
  }
#line 669
  return (descfile);
}
}
#line 675 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
int uudecodefiles(char *dir , int nparts ) 
{ 
  int part ;
  enum __anonenum_state_29 state ;
  FILE *infile ;
  FILE *outfile ;
  struct part *inpart ;
  char buf___1[1024] ;
  char lastline[63] ;
  char *fname ;
  char *p ;
  char *contentType ;
  int line_length ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 682
  outfile = (FILE *)((void *)0);
#line 687
  contentType = (char *)"application/octet-stream";
#line 688
  line_length = 0;
#line 691
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s0",
          dir);
#line 692
  infile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
  }
#line 693
  if (infile) {
    {
#line 694
    outfile = os_createnewfile((char *)"tempdesc.txt");
    }
#line 695
    if (outfile) {
      {
#line 696
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 696
        tmp = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)infile);
        }
#line 696
        if (! tmp) {
#line 696
          goto while_break;
        }
        {
#line 697
        fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)outfile);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 699
      fclose(outfile);
#line 700
      outfile = (FILE *)((void *)0);
      }
    }
    {
#line 702
    fclose(infile);
#line 703
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s0",
            dir);
#line 704
    unlink((char const   *)(buf___1));
    }
  }
#line 707
  state = (enum __anonenum_state_29 )0;
#line 710
  part = 1;
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    if (! (part <= nparts)) {
#line 710
      goto while_break___0;
    }
    {
#line 711
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, part);
#line 712
    infile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 713
    if (! infile) {
      {
#line 714
      os_perror(buf___1);
      }
#line 715
      if (outfile) {
        {
#line 715
        fclose(outfile);
        }
      }
      {
#line 716
      unlink("tempdesc.txt");
      }
#line 717
      return (1);
    }
    {
#line 720
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 720
      tmp___18 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1),
                       (FILE */* __restrict  */)infile);
      }
#line 720
      if (! tmp___18) {
#line 720
        goto while_break___1;
      }
      {
#line 722
      if ((unsigned int )state == 0U) {
#line 722
        goto case_0;
      }
#line 761
      if ((unsigned int )state == 1U) {
#line 761
        goto case_1;
      }
#line 770
      if ((unsigned int )state == 2U) {
#line 770
        goto case_2;
      }
#line 793
      if ((unsigned int )state == 3U) {
#line 793
        goto case_3;
      }
#line 802
      if ((unsigned int )state == 4U) {
#line 802
        goto case_4;
      }
#line 820
      if ((unsigned int )state == 5U) {
#line 820
        goto case_5;
      }
#line 721
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 724
      tmp___0 = strcmp((char const   *)(buf___1), "(This file must be converted with BinHex 4.0)\n");
      }
#line 724
      if (! tmp___0) {
        {
#line 726
        state = (enum __anonenum_state_29 )5;
#line 727
        inpart = part_init(infile);
#line 728
        os_binhex(inpart, part, nparts);
#line 729
        part_close(inpart);
        }
#line 730
        goto endbinhex;
      }
      {
#line 732
      tmp___1 = strncmp((char const   *)(buf___1), "begin ", (size_t )6);
      }
#line 732
      if (tmp___1) {
#line 732
        goto switch_break;
      }
#line 734
      p = buf___1 + 6;
      {
#line 735
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 735
        if (*p) {
          {
#line 735
          tmp___2 = __ctype_b_loc();
          }
#line 735
          if ((int const   )*(*tmp___2 + (int )*p) & 8192) {
#line 735
            goto while_break___2;
          }
        } else {
#line 735
          goto while_break___2;
        }
#line 735
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 736
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 736
        if (*p) {
          {
#line 736
          tmp___3 = __ctype_b_loc();
          }
#line 736
          if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 736
            goto while_break___3;
          }
        } else {
#line 736
          goto while_break___3;
        }
#line 736
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 737
      fname = p;
      {
#line 738
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 738
        if (*p) {
          {
#line 738
          tmp___4 = __ctype_b_loc();
          }
#line 738
          if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
#line 738
            goto while_break___4;
          }
        } else {
#line 738
          goto while_break___4;
        }
#line 738
        p ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 739
      *p = (char )'\000';
#line 740
      if (! *fname) {
#line 740
        return (1);
      }
      {
#line 743
      p = strrchr((char const   *)fname, '.');
      }
#line 743
      if (p) {
        {
#line 744
        tmp___5 = strcasecmp((char const   *)p, ".gif");
        }
#line 744
        if (! tmp___5) {
#line 744
          contentType = (char *)"image/gif";
        }
        {
#line 745
        tmp___6 = strcasecmp((char const   *)p, ".jpg");
        }
#line 745
        if (! tmp___6) {
#line 745
          contentType = (char *)"image/jpeg";
        }
        {
#line 746
        tmp___7 = strcasecmp((char const   *)p, ".jpeg");
        }
#line 746
        if (! tmp___7) {
#line 746
          contentType = (char *)"image/jpeg";
        }
        {
#line 747
        tmp___8 = strcasecmp((char const   *)p, ".mpg");
        }
#line 747
        if (! tmp___8) {
#line 747
          contentType = (char *)"video/mpeg";
        }
        {
#line 748
        tmp___9 = strcasecmp((char const   *)p, ".mpeg");
        }
#line 748
        if (! tmp___9) {
#line 748
          contentType = (char *)"video/mpeg";
        }
      }
      {
#line 752
      outfile = os_newtypedfile(fname, contentType, 1, (params )0);
      }
#line 754
      if (! outfile) {
        {
#line 755
        fclose(infile);
        }
#line 756
        return (1);
      }
#line 758
      state = (enum __anonenum_state_29 )2;
#line 759
      goto switch_break;
      case_1: /* CIL Label */ 
#line 762
      if ((int )buf___1[0] != 77) {
#line 762
        goto _L;
      } else {
        {
#line 762
        tmp___11 = strlen((char const   *)(buf___1));
        }
#line 762
        if (tmp___11 != (size_t )line_length) {
          _L: /* CIL Label */ 
#line 763
          if ((int )buf___1[0] == 66) {
            {
#line 763
            tmp___10 = strncmp((char const   *)(buf___1), "BEGIN", (size_t )5);
            }
#line 763
            if (! tmp___10) {
#line 764
              state = (enum __anonenum_state_29 )2;
            }
          }
#line 766
          goto switch_break;
        }
      }
#line 768
      state = (enum __anonenum_state_29 )2;
      case_2: /* CIL Label */ 
#line 771
      if (line_length == 0) {
        {
#line 771
        tmp___12 = strlen((char const   *)(buf___1));
#line 771
        line_length = (int )tmp___12;
        }
      }
#line 772
      if ((int )buf___1[0] == 77) {
        {
#line 772
        tmp___13 = strlen((char const   *)(buf___1));
        }
#line 772
        if (tmp___13 == (size_t )line_length) {
          {
#line 773
          uudecodeline(buf___1, outfile);
          }
#line 774
          goto switch_break;
        }
      }
      {
#line 776
      tmp___14 = strlen((char const   *)(buf___1));
      }
#line 776
      if (tmp___14 > (size_t )line_length) {
#line 777
        state = (enum __anonenum_state_29 )1;
#line 778
        goto switch_break;
      }
      {
#line 784
      strcpy((char */* __restrict  */)(lastline), (char const   */* __restrict  */)(buf___1));
      }
#line 785
      if ((int )buf___1[0] == 32) {
#line 786
        state = (enum __anonenum_state_29 )4;
      } else
#line 785
      if ((int )buf___1[0] == 96) {
#line 786
        state = (enum __anonenum_state_29 )4;
      } else {
#line 789
        state = (enum __anonenum_state_29 )3;
      }
#line 791
      goto switch_break;
      case_3: /* CIL Label */ 
#line 794
      if ((int )buf___1[0] == 32) {
#line 795
        state = (enum __anonenum_state_29 )4;
      } else
#line 794
      if ((int )buf___1[0] == 96) {
#line 795
        state = (enum __anonenum_state_29 )4;
      } else {
#line 798
        state = (enum __anonenum_state_29 )1;
      }
#line 800
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 803
      tmp___15 = strncmp((char const   *)(buf___1), "end", (size_t )3);
      }
#line 803
      if (! tmp___15) {
        {
#line 803
        tmp___16 = __ctype_b_loc();
        }
#line 803
        if ((int const   )*(*tmp___16 + (int )buf___1[3]) & 8192) {
          {
#line 805
          uudecodeline(lastline, outfile);
#line 806
          fclose(infile);
#line 807
          os_closetypedfile(outfile);
          }
          {
#line 808
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 808
            if (! (part <= nparts)) {
#line 808
              goto while_break___5;
            }
            {
#line 809
            sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
                    dir, part);
#line 810
            unlink((char const   *)(buf___1));
#line 808
            part ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 812
          sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
                  dir);
#line 813
          unlink((char const   *)(buf___1));
#line 814
          os_donewithdir(dir);
          }
#line 815
          return (0);
        }
      }
#line 817
      state = (enum __anonenum_state_29 )1;
#line 818
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 821
      tmp___17 = strncmp((char const   *)(buf___1), "---", (size_t )3);
      }
#line 821
      if (tmp___17) {
#line 821
        goto switch_break;
      }
      {
#line 822
      inpart = part_init(infile);
#line 823
      os_binhex(inpart, part, nparts);
#line 824
      part_close(inpart);
      }
#line 825
      goto endbinhex;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 828
    if ((unsigned int )state != 5U) {
#line 828
      state = (enum __anonenum_state_29 )1;
    }
    {
#line 829
    fclose(infile);
    }
    endbinhex: 
    {
#line 831
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, part);
#line 832
    unlink((char const   *)(buf___1));
#line 710
    part ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 834
  if (outfile) {
    {
#line 834
    os_closetypedfile(outfile);
    }
  }
#line 835
  if ((unsigned int )state == 5U) {
    {
#line 835
    os_binhex((struct part *)0, 0, 0);
    }
  }
  {
#line 836
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
          dir);
#line 837
  unlink((char const   *)(buf___1));
#line 838
  os_donewithdir(dir);
  }
#line 839
  return (0);
}
}
#line 847 "/home/wheatley/newnew/temp/mpack-1.6/uudecode.c"
static void uudecodeline(char *line , FILE *outfile ) 
{ 
  int c ;
  int len ;
  char *tmp ;

  {
#line 851
  tmp = line;
#line 851
  line ++;
#line 851
  len = ((int )*tmp - 32) & 63;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! len) {
#line 852
      goto while_break;
    }
    {
#line 853
    c = ((((int )*line - 32) & 63) << 2) | ((((int )*(line + 1) - 32) & 63) >> 4);
#line 854
    _IO_putc(c, outfile);
#line 855
    len --;
    }
#line 855
    if (len) {
      {
#line 856
      c = ((((int )*(line + 1) - 32) & 63) << 4) | ((((int )*(line + 2) - 32) & 63) >> 2);
#line 857
      _IO_putc(c, outfile);
#line 858
      len --;
      }
#line 858
      if (len) {
        {
#line 859
        c = ((((int )*(line + 2) - 32) & 63) << 6) | (((int )*(line + 3) - 32) & 63);
#line 860
        _IO_putc(c, outfile);
#line 861
        len --;
        }
      }
    }
#line 864
    line += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 32 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
int overwrite_files ;
#line 33
int didchat ;
#line 34 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
int quiet  ;
#line 36
void usage(void) ;
#line 40 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  FILE *file ;
  int extractText ;
  int tmp ;
  struct part *tmp___0 ;
  struct part *tmp___1 ;

  {
#line 44
  extractText = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    opt = getopt(argc, (char * const  *)argv, "qftC:");
    }
#line 46
    if (! (opt != -1)) {
#line 46
      goto while_break;
    }
    {
#line 48
    if (opt == 102) {
#line 48
      goto case_102;
    }
#line 52
    if (opt == 113) {
#line 52
      goto case_113;
    }
#line 56
    if (opt == 116) {
#line 56
      goto case_116;
    }
#line 60
    if (opt == 67) {
#line 60
      goto case_67;
    }
#line 67
    goto switch_default;
    case_102: /* CIL Label */ 
#line 49
    overwrite_files = 1;
#line 50
    goto switch_break;
    case_113: /* CIL Label */ 
#line 53
    quiet = 1;
#line 54
    goto switch_break;
    case_116: /* CIL Label */ 
#line 57
    extractText = 1;
#line 58
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 61
    tmp = chdir((char const   *)optarg);
    }
#line 61
    if (tmp) {
      {
#line 62
      perror((char const   *)optarg);
#line 63
      exit(1);
      }
    }
#line 65
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 68
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (optind == argc) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"munpack: reading from standard input\n");
#line 74
    didchat = 0;
#line 75
    tmp___0 = part_init(stdin);
#line 75
    handleMessage(tmp___0, (char *)"text/plain", 0, extractText);
    }
#line 76
    if (! didchat) {
      {
#line 77
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Did not find anything to unpack from standard input\n");
      }
    }
    {
#line 80
    exit(0);
    }
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! *(argv + optind)) {
#line 83
      goto while_break___0;
    }
    {
#line 84
    file = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r");
    }
#line 85
    if (! file) {
      {
#line 86
      perror((char const   *)*(argv + optind));
      }
    } else {
      {
#line 89
      didchat = 0;
#line 90
      tmp___1 = part_init(file);
#line 90
      handleMessage(tmp___1, (char *)"text/plain", 0, extractText);
#line 91
      fclose(file);
      }
#line 92
      if (! didchat) {
        {
#line 93
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Did not find anything to unpack from %s\n",
                *(argv + optind));
        }
      }
    }
#line 98
    optind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 100
  exit(0);
  }
}
}
#line 103 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
void usage(void) 
{ 


  {
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"munpack version %s\n",
          "1.6");
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: munpack [-f] [-q] [-t] [-C directory] [files...]\n");
#line 106
  exit(1);
  }
}
}
#line 109 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
void warn(char *s ) 
{ 


  {
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"munpack: warning: %s\n",
          s);
  }
#line 112
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/mpack-1.6/unixunpk.c"
void chat(char *s ) 
{ 


  {
#line 116
  didchat = 1;
#line 117
  if (! quiet) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            s);
    }
  }
#line 118
  return;
}
}
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 25 "/home/wheatley/newnew/temp/mpack-1.6/xmalloc.h"
char *xmalloc(int size ) ;
#line 26
char *xrealloc(char *ptr , int size ) ;
#line 27
char *strsave(char *str ) ;
#line 65 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
void MD5Init(MD5_CTX *context ) ;
#line 66
void MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) ;
#line 41 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
char *md5contextTo64(MD5_CTX *context ) ;
#line 46
void os_warnMD5mismatch(void) ;
#line 49
int part_depth(struct part *part ) ;
#line 52
int part_fill(struct part *part ) ;
#line 53
void part_addboundary(struct part *part , char *boundary ) ;
#line 54
int part_readboundary(struct part *part ) ;
#line 59
char *ParseHeaders(struct part *inpart , char **subjectp , char **contentTypep , enum encoding *contentEncodingp ,
                   char **contentDispositionp , char **contentMD5p ) ;
#line 60
enum encoding parseEncoding(char *s ) ;
#line 61
params ParseContent(char **headerp ) ;
#line 62
char *getParam(params cParams , char *key ) ;
#line 63
char *getDispositionFilename(char *disposition ) ;
#line 64
void from64(struct part *inpart , FILE *outfile , char **digestp , int suppressCR ) ;
#line 65
void fromqp(struct part *inpart , FILE *outfile , char **digestp ) ;
#line 66
void fromnone(struct part *inpart , FILE *outfile , char **digestp ) ;
#line 67
int handlePartial(struct part *inpart , char *headers___0 , params contentParams ,
                  int extractText ) ;
#line 69
int ignoreMessage(struct part *inpart ) ;
#line 70
int handleMultipart(struct part *inpart , char *contentType , params contentParams ,
                    int extractText ) ;
#line 73
int handleText(struct part *inpart , enum encoding contentEncoding ) ;
#line 74
int saveToFile(struct part *inpart , int inAppleDouble , char *contentType , params contentParams ,
               enum encoding contentEncoding , char *contentDisposition , char *contentMD5 ) ;
#line 81 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int handleMessage(struct part *inpart , char *defaultContentType , int inAppleDouble ,
                  int extractText ) 
{ 
  char *headers___0 ;
  char *subject ;
  char *contentType ;
  char *contentDisposition ;
  char *contentMD5 ;
  enum encoding contentEncoding ;
  params contentParams ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 88
  headers___0 = ParseHeaders(inpart, & subject, & contentType, & contentEncoding,
                             & contentDisposition, & contentMD5);
  }
#line 90
  if (! headers___0) {
#line 90
    return (1);
  }
#line 93
  if (! contentType) {
#line 94
    contentType = defaultContentType;
  } else {
    {
#line 93
    tmp = strchr((char const   *)contentType, '/');
    }
#line 93
    if (! tmp) {
#line 94
      contentType = defaultContentType;
    }
  }
  {
#line 96
  contentParams = ParseContent(& contentType);
#line 98
  tmp___17 = strcasecmp((char const   *)contentType, "message/rfc822");
  }
#line 98
  if (tmp___17) {
    {
#line 106
    tmp___16 = strcasecmp((char const   *)contentType, "message/partial");
    }
#line 106
    if (tmp___16) {
      {
#line 112
      tmp___15 = strncasecmp((char const   *)contentType, "message/", (size_t )8);
      }
#line 112
      if (tmp___15) {
        {
#line 116
        tmp___14 = strncasecmp((char const   *)contentType, "multipart/", (size_t )10);
        }
#line 116
        if (tmp___14) {
          {
#line 123
          tmp___10 = part_depth(inpart);
          }
#line 123
          if (tmp___10 == 0) {
            {
#line 123
            tmp___11 = strncasecmp((char const   *)contentType, "text/", (size_t )5);
            }
#line 123
            if (tmp___11) {
#line 123
              goto _L___2;
            } else
#line 123
            if ((unsigned int )contentEncoding == 0U) {
              {
#line 123
              tmp___12 = getDispositionFilename(contentDisposition);
              }
#line 123
              if (tmp___12) {
#line 123
                goto _L___2;
              } else {
                {
#line 123
                tmp___13 = getParam(contentParams, (char *)"name");
                }
#line 123
                if (tmp___13) {
#line 123
                  goto _L___2;
                } else {
                  {
#line 129
                  tmp___4 = handleUuencode(inpart, subject, extractText);
                  }
#line 129
                  return (tmp___4);
                }
              }
            } else {
#line 123
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 131
          if (! extractText) {
#line 131
            if (! inAppleDouble) {
              {
#line 131
              tmp___7 = strncasecmp((char const   *)contentType, "text/", (size_t )5);
              }
#line 131
              if (tmp___7) {
                {
#line 139
                tmp___6 = saveToFile(inpart, inAppleDouble, contentType, contentParams,
                                     contentEncoding, contentDisposition, contentMD5);
                }
#line 139
                return (tmp___6);
              } else {
                {
#line 131
                tmp___8 = getDispositionFilename(contentDisposition);
                }
#line 131
                if (tmp___8) {
                  {
#line 139
                  tmp___6 = saveToFile(inpart, inAppleDouble, contentType, contentParams,
                                       contentEncoding, contentDisposition, contentMD5);
                  }
#line 139
                  return (tmp___6);
                } else {
                  {
#line 131
                  tmp___9 = getParam(contentParams, (char *)"name");
                  }
#line 131
                  if (tmp___9) {
                    {
#line 139
                    tmp___6 = saveToFile(inpart, inAppleDouble, contentType, contentParams,
                                         contentEncoding, contentDisposition, contentMD5);
                    }
#line 139
                    return (tmp___6);
                  } else {
                    {
#line 135
                    tmp___5 = handleText(inpart, contentEncoding);
                    }
#line 135
                    return (tmp___5);
                  }
                }
              }
            } else {
              {
#line 139
              tmp___6 = saveToFile(inpart, inAppleDouble, contentType, contentParams,
                                   contentEncoding, contentDisposition, contentMD5);
              }
#line 139
              return (tmp___6);
            }
          } else {
            {
#line 139
            tmp___6 = saveToFile(inpart, inAppleDouble, contentType, contentParams,
                                 contentEncoding, contentDisposition, contentMD5);
            }
#line 139
            return (tmp___6);
          }
        } else {
#line 117
          if ((unsigned int )contentEncoding != 0U) {
            {
#line 118
            warn((char *)"ignoring invalid content encoding on multipart");
            }
          }
          {
#line 120
          tmp___3 = handleMultipart(inpart, contentType, contentParams, extractText);
          }
#line 120
          return (tmp___3);
        }
      } else {
        {
#line 114
        tmp___2 = ignoreMessage(inpart);
        }
#line 114
        return (tmp___2);
      }
    } else {
#line 107
      if ((unsigned int )contentEncoding != 0U) {
        {
#line 108
        warn((char *)"ignoring invalid content encoding on message/partial");
        }
      }
      {
#line 110
      tmp___1 = handlePartial(inpart, headers___0, contentParams, extractText);
      }
#line 110
      return (tmp___1);
    }
  } else {
#line 99
    if ((unsigned int )contentEncoding != 0U) {
      {
#line 100
      warn((char *)"ignoring invalid content encoding on message/rfc822");
      }
    }
    {
#line 104
    tmp___0 = handleMessage(inpart, (char *)"text/plain", 0, extractText);
    }
#line 104
    return (tmp___0);
  }
}
}
#line 147 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
void SkipWhitespace(char **s ) 
{ 
  char *p ;
  int commentlevel ;
  unsigned short const   **tmp ;

  {
#line 149
  p = *s;
#line 150
  commentlevel = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (*p) {
      {
#line 152
      tmp = __ctype_b_loc();
      }
#line 152
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 152
        if (! ((int )*p == 40)) {
#line 152
          goto while_break;
        }
      }
    } else {
#line 152
      goto while_break;
    }
#line 153
    if ((int )*p == 10) {
#line 154
      p ++;
#line 155
      if ((int )*p != 32) {
#line 155
        if ((int )*p != 9) {
#line 156
          *s = (char *)0;
#line 157
          return;
        }
      }
    } else
#line 160
    if ((int )*p == 40) {
#line 161
      p ++;
#line 162
      commentlevel ++;
      {
#line 163
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 163
        if (! commentlevel) {
#line 163
          goto while_break___0;
        }
        {
#line 165
        if ((int )*p == 10) {
#line 165
          goto case_10;
        }
#line 169
        if ((int )*p == 0) {
#line 169
          goto case_0;
        }
#line 173
        if ((int )*p == 92) {
#line 173
          goto case_92;
        }
#line 177
        if ((int )*p == 40) {
#line 177
          goto case_40;
        }
#line 181
        if ((int )*p == 41) {
#line 181
          goto case_41;
        }
#line 164
        goto switch_break;
        case_10: /* CIL Label */ 
#line 166
        p ++;
#line 167
        if ((int )*p == 32) {
#line 167
          goto switch_break;
        } else
#line 167
        if ((int )*p == 9) {
#line 167
          goto switch_break;
        }
        case_0: /* CIL Label */ 
#line 170
        *s = (char *)0;
#line 171
        return;
        case_92: /* CIL Label */ 
#line 174
        p ++;
#line 175
        goto switch_break;
        case_40: /* CIL Label */ 
#line 178
        commentlevel ++;
#line 179
        goto switch_break;
        case_41: /* CIL Label */ 
#line 182
        commentlevel --;
#line 183
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 185
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 188
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if ((int )*p == 0) {
#line 191
    *s = (char *)0;
  } else {
#line 194
    *s = p;
  }
#line 196
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static int alloced  =    0;
#line 211 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char *headers  ;
#line 208 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
char *ParseHeaders(struct part *inpart , char **subjectp , char **contentTypep , enum encoding *contentEncodingp ,
                   char **contentDispositionp , char **contentMD5p ) 
{ 
  int left ;
  int len ;
  int i ;
  char *next ;
  char *val ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 216
  if (! alloced) {
    {
#line 217
    alloced = 1000;
#line 217
    headers = xmalloc(alloced);
    }
  }
#line 219
  next = headers;
#line 220
  tmp = next;
#line 220
  next ++;
#line 220
  *tmp = (char )'\n';
#line 221
  left = alloced - 2;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp___1 = part_gets(next, left, inpart);
    }
#line 223
    if (tmp___1) {
#line 223
      if (! ((int )*next != 10)) {
#line 223
        if (! ((int )*(next + -1) != 10)) {
#line 223
          goto while_break;
        }
      }
    } else {
#line 223
      goto while_break;
    }
    {
#line 224
    tmp___0 = strlen((char const   *)next);
#line 224
    len = (int )tmp___0;
    }
#line 226
    if ((int )*(next + -1) == 10) {
#line 228
      i = 0;
      {
#line 228
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 228
        if (! (i < len)) {
#line 228
          goto while_break___0;
        }
#line 229
        if ((int )*(next + i) == 58) {
#line 230
          goto while_break___0;
        } else
#line 229
        if ((int )*(next + i) <= 32) {
#line 230
          goto while_break___0;
        } else
#line 229
        if ((int )*(next + i) >= 127) {
#line 230
          goto while_break___0;
        }
#line 228
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 232
      if (i == 0) {
#line 232
        goto _L;
      } else
#line 232
      if ((int )*(next + i) != 58) {
        _L: /* CIL Label */ 
#line 234
        if ((unsigned long )next == (unsigned long )(headers + 1)) {
          {
#line 239
          part_ungets(next, inpart);
          }
#line 240
          goto while_break;
        } else
#line 234
        if ((int )*(next + 0) != 32) {
#line 234
          if ((int )*(next + 0) != 9) {
            {
#line 239
            part_ungets(next, inpart);
            }
#line 240
            goto while_break;
          }
        }
      }
    }
#line 245
    left -= len;
#line 246
    next += len;
#line 248
    if (left < 100) {
      {
#line 249
      len = (int )(next - headers);
#line 250
      alloced += 1000;
#line 251
      left += 1000;
#line 252
      headers = xrealloc(headers, alloced);
#line 253
      next = headers + len;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  *next = (char )'\000';
#line 260
  tmp___4 = (char *)0;
#line 260
  *contentMD5p = tmp___4;
#line 260
  tmp___3 = tmp___4;
#line 260
  *contentDispositionp = tmp___3;
#line 260
  tmp___2 = tmp___3;
#line 260
  *contentTypep = tmp___2;
#line 260
  *subjectp = tmp___2;
#line 261
  *contentEncodingp = (enum encoding )0;
#line 262
  next = headers;
  {
#line 262
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 262
    if (! *next) {
#line 262
      goto while_break___1;
    }
#line 263
    if ((int )*next == 10) {
      {
#line 266
      if ((int )*(next + 1) == 83) {
#line 266
        goto case_83;
      }
#line 266
      if ((int )*(next + 1) == 115) {
#line 266
        goto case_83;
      }
#line 275
      if ((int )*(next + 1) == 67) {
#line 275
        goto case_67;
      }
#line 275
      if ((int )*(next + 1) == 99) {
#line 275
        goto case_67;
      }
#line 264
      goto switch_break;
      case_83: /* CIL Label */ 
      case_115: /* CIL Label */ 
      {
#line 267
      tmp___5 = strncasecmp((char const   *)(next + 2), "ubject:", (size_t )7);
      }
#line 267
      if (! tmp___5) {
        {
#line 268
        val = next + 9;
#line 269
        SkipWhitespace(& val);
        }
#line 270
        if (val) {
#line 270
          *subjectp = val;
        }
      }
#line 272
      goto switch_break;
      case_67: /* CIL Label */ 
      case_99: /* CIL Label */ 
      {
#line 276
      tmp___9 = strncasecmp((char const   *)(next + 2), "ontent-type:", (size_t )12);
      }
#line 276
      if (tmp___9) {
        {
#line 281
        tmp___8 = strncasecmp((char const   *)(next + 2), "ontent-transfer-encoding:",
                              (size_t )25);
        }
#line 281
        if (tmp___8) {
          {
#line 284
          tmp___7 = strncasecmp((char const   *)(next + 2), "ontent-disposition:",
                                (size_t )19);
          }
#line 284
          if (tmp___7) {
            {
#line 289
            tmp___6 = strncasecmp((char const   *)(next + 2), "ontent-md5:", (size_t )11);
            }
#line 289
            if (! tmp___6) {
              {
#line 290
              val = next + 13;
#line 291
              SkipWhitespace(& val);
              }
#line 292
              if (val) {
#line 292
                *contentMD5p = val;
              }
            }
          } else {
            {
#line 285
            val = next + 21;
#line 286
            SkipWhitespace(& val);
            }
#line 287
            if (val) {
#line 287
              *contentDispositionp = val;
            }
          }
        } else {
          {
#line 282
          *contentEncodingp = parseEncoding(next + 27);
          }
        }
      } else {
        {
#line 277
        val = next + 14;
#line 278
        SkipWhitespace(& val);
        }
#line 279
        if (val) {
#line 279
          *contentTypep = val;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 262
    next ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 297
  return (headers);
}
}
#line 304 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
enum encoding parseEncoding(char *s ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 306
  SkipWhitespace(& s);
  }
#line 307
  if (s) {
    {
#line 310
    if ((int )*s == 81) {
#line 310
      goto case_81;
    }
#line 310
    if ((int )*s == 113) {
#line 310
      goto case_81;
    }
#line 318
    if ((int )*s == 56) {
#line 318
      goto case_56;
    }
#line 318
    if ((int )*s == 55) {
#line 318
      goto case_56;
    }
#line 326
    if ((int )*s == 66) {
#line 326
      goto case_66;
    }
#line 326
    if ((int )*s == 98) {
#line 326
      goto case_66;
    }
#line 308
    goto switch_break;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    {
#line 311
    tmp = strncasecmp((char const   *)(s + 1), "uoted-printable", (size_t )15);
    }
#line 311
    if (! tmp) {
      {
#line 311
      tmp___0 = __ctype_b_loc();
      }
#line 311
      if ((int const   )*(*tmp___0 + (int )*(s + 16)) & 8192) {
#line 313
        return ((enum encoding )1);
      } else
#line 311
      if ((int )*(s + 16) == 40) {
#line 313
        return ((enum encoding )1);
      }
    }
#line 315
    goto switch_break;
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    {
#line 319
    tmp___1 = strncasecmp((char const   *)(s + 1), "bit", (size_t )3);
    }
#line 319
    if (! tmp___1) {
      {
#line 319
      tmp___2 = __ctype_b_loc();
      }
#line 319
      if ((int const   )*(*tmp___2 + (int )*(s + 4)) & 8192) {
#line 321
        return ((enum encoding )0);
      } else
#line 319
      if ((int )*(s + 4) == 40) {
#line 321
        return ((enum encoding )0);
      }
    }
#line 323
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    {
#line 327
    tmp___3 = strncasecmp((char const   *)(s + 1), "ase64", (size_t )5);
    }
#line 327
    if (! tmp___3) {
      {
#line 327
      tmp___4 = __ctype_b_loc();
      }
#line 327
      if ((int const   )*(*tmp___4 + (int )*(s + 6)) & 8192) {
#line 329
        return ((enum encoding )2);
      } else
#line 327
      if ((int )*(s + 6) == 40) {
#line 329
        return ((enum encoding )2);
      }
    }
    {
#line 331
    tmp___5 = strncasecmp((char const   *)(s + 1), "inary", (size_t )5);
    }
#line 331
    if (! tmp___5) {
      {
#line 331
      tmp___6 = __ctype_b_loc();
      }
#line 331
      if ((int const   )*(*tmp___6 + (int )*(s + 6)) & 8192) {
#line 333
        return ((enum encoding )0);
      } else
#line 331
      if ((int )*(s + 6) == 40) {
#line 333
        return ((enum encoding )0);
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 336
    warn((char *)"ignoring unknown content transfer encoding\n");
    }
  }
#line 338
  return ((enum encoding )0);
}
}
#line 353 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static int palloced  =    0;
#line 354 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char **param  ;
#line 355 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static int calloced  =    0;
#line 356 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char *cbuf  ;
#line 350 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
params ParseContent(char **headerp ) 
{ 
  char *header ;
  char *p ;
  int nparam ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 360
  header = *headerp;
#line 360
  p = header;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    p = strchr((char const   *)(p + 1), '\n');
    }
#line 363
    if (p) {
      {
#line 363
      tmp = __ctype_b_loc();
      }
#line 363
      if (! ((int const   )*(*tmp + (int )*(p + 1)) & 8192)) {
#line 363
        goto while_break;
      }
    } else {
#line 363
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  if (! p) {
    {
#line 367
    tmp___0 = strlen((char const   *)header);
#line 367
    p = header + tmp___0;
    }
  }
#line 371
  if (p - header >= (long )calloced) {
#line 372
    calloced = (int )((p - header) + 1L);
#line 373
    if (calloced < 200) {
#line 373
      calloced = 200;
    }
    {
#line 374
    cbuf = xrealloc(cbuf, calloced);
    }
  }
  {
#line 378
  strncpy((char */* __restrict  */)cbuf, (char const   */* __restrict  */)header,
          (size_t )(p - header));
#line 379
  *(cbuf + (p - header)) = (char)0;
#line 380
  tmp___1 = cbuf;
#line 380
  *headerp = tmp___1;
#line 380
  header = tmp___1;
#line 382
  nparam = 0;
#line 386
  p = header;
  }
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    if (header) {
#line 387
      if (*header) {
#line 387
        if (! ((int )*header != 59)) {
#line 387
          goto while_break___0;
        }
      } else {
#line 387
        goto while_break___0;
      }
    } else {
#line 387
      goto while_break___0;
    }
    {
#line 388
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 388
      if (*header) {
        {
#line 388
        tmp___4 = __ctype_b_loc();
        }
#line 388
        if ((int const   )*(*tmp___4 + (int )*header) & 8192) {
#line 388
          goto while_break___1;
        } else
#line 388
        if ((int )*header != 40) {
#line 388
          if (! ((int )*header != 59)) {
#line 388
            goto while_break___1;
          }
        } else {
#line 388
          goto while_break___1;
        }
      } else {
#line 388
        goto while_break___1;
      }
#line 390
      tmp___2 = p;
#line 390
      p ++;
#line 390
      tmp___3 = header;
#line 390
      header ++;
#line 390
      *tmp___2 = *tmp___3;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 392
    SkipWhitespace(& header);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  if (! header) {
#line 394
    return ((params )0);
  } else
#line 394
  if (! *header) {
#line 394
    return ((params )0);
  }
#line 395
  header ++;
#line 396
  *p = (char )'\000';
  {
#line 399
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 399
    if (! *header) {
#line 399
      goto while_break___2;
    }
    {
#line 400
    SkipWhitespace(& header);
    }
#line 401
    if (! header) {
#line 401
      goto while_break___2;
    }
#line 403
    if (nparam + 1 >= palloced) {
      {
#line 404
      palloced += 10;
#line 405
      tmp___5 = xrealloc((char *)param, (int )((unsigned long )palloced * sizeof(char *)));
#line 405
      param = (char **)tmp___5;
      }
    }
#line 407
    tmp___6 = nparam;
#line 407
    nparam ++;
#line 407
    *(param + tmp___6) = header;
    {
#line 410
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 410
      if (*header) {
#line 410
        if (! ((int )*header != 59)) {
#line 410
          goto while_break___3;
        }
      } else {
#line 410
        goto while_break___3;
      }
#line 411
      if ((int )*header == 34) {
#line 412
        header ++;
        {
#line 413
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 413
          if (*header) {
#line 413
            if (! ((int )*header != 34)) {
#line 413
              goto while_break___4;
            }
          } else {
#line 413
            goto while_break___4;
          }
#line 414
          if ((int )*header == 92) {
#line 415
            header ++;
#line 416
            if (! *header) {
#line 416
              goto while_break___4;
            }
          }
#line 418
          header ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 420
        if (! *header) {
#line 420
          goto while_break___3;
        }
      } else
#line 422
      if ((int )*header == 40) {
        {
#line 424
        p = header;
#line 425
        SkipWhitespace(& p);
        }
#line 426
        if (! p) {
#line 427
          goto while_break___3;
        }
        {
#line 429
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 429
          if (! ((unsigned long )header < (unsigned long )p)) {
#line 429
            goto while_break___5;
          }
#line 429
          tmp___7 = header;
#line 429
          header ++;
#line 429
          *tmp___7 = (char )' ';
        }
        while_break___5: /* CIL Label */ ;
        }
#line 430
        header --;
      }
#line 432
      header ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 434
    if (*header) {
#line 434
      tmp___8 = header;
#line 434
      header ++;
#line 434
      *tmp___8 = (char )'\000';
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 437
  if (nparam == 0) {
#line 438
    return ((params )0);
  }
#line 440
  *(param + nparam) = (char *)0;
#line 441
  return (param);
}
}
#line 452 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char *value  ;
#line 453 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static int alloced___0  =    0;
#line 450 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
char *getParam(params cParams , char *key ) 
{ 
  int left ;
  int keylen ;
  size_t tmp ;
  char *from ;
  char *to ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
  {
#line 455
  tmp = strlen((char const   *)key);
#line 455
  keylen = (int )tmp;
  }
#line 458
  if (! cParams) {
#line 458
    return ((char *)0);
  }
#line 460
  if (! alloced___0) {
    {
#line 461
    alloced___0 = 100;
#line 461
    value = xmalloc(alloced___0);
    }
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! *cParams) {
#line 465
      goto while_break;
    }
    {
#line 466
    tmp___0 = strncasecmp((char const   *)key, (char const   *)*cParams, (size_t )keylen);
    }
#line 466
    if (! tmp___0) {
#line 466
      if ((int )*(*cParams + keylen) == 61) {
#line 467
        goto while_break;
      } else {
        {
#line 466
        tmp___1 = __ctype_b_loc();
        }
#line 466
        if ((int const   )*(*tmp___1 + (int )*(*cParams + keylen)) & 8192) {
#line 467
          goto while_break;
        }
      }
    }
#line 468
    cParams ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  if (! *cParams) {
#line 470
    return ((char *)0);
  }
#line 473
  from = *cParams + keylen;
  {
#line 474
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 474
    if (*from) {
      {
#line 474
      tmp___2 = __ctype_b_loc();
      }
#line 474
      if (! ((int const   )*(*tmp___2 + (int )*from) & 8192)) {
#line 474
        goto while_break___0;
      }
    } else {
#line 474
      goto while_break___0;
    }
#line 474
    from ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 475
  tmp___3 = from;
#line 475
  from ++;
#line 475
  if ((int )*tmp___3 != 61) {
#line 475
    return ((char *)0);
  }
  {
#line 476
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 476
    if (*from) {
      {
#line 476
      tmp___4 = __ctype_b_loc();
      }
#line 476
      if (! ((int const   )*(*tmp___4 + (int )*from) & 8192)) {
#line 476
        goto while_break___1;
      }
    } else {
#line 476
      goto while_break___1;
    }
#line 476
    from ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 477
  if (! *from) {
#line 477
    return ((char *)0);
  }
#line 480
  to = value;
#line 481
  left = alloced___0 - 1;
#line 482
  if ((int )*from == 34) {
#line 484
    from ++;
    {
#line 485
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 485
      if (*from) {
#line 485
        if (! ((int )*from != 34)) {
#line 485
          goto while_break___2;
        }
      } else {
#line 485
        goto while_break___2;
      }
#line 486
      left --;
#line 486
      if (! left) {
        {
#line 487
        alloced___0 += 100;
#line 488
        left += 100;
#line 489
        value = xrealloc(value, alloced___0);
#line 490
        to = ((value + alloced___0) - left) - 2;
        }
      }
#line 492
      if ((int )*from == 92) {
#line 493
        from ++;
#line 494
        if (! *from) {
#line 494
          return ((char *)0);
        }
      }
#line 496
      tmp___5 = to;
#line 496
      to ++;
#line 496
      tmp___6 = from;
#line 496
      from ++;
#line 496
      *tmp___5 = *tmp___6;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 498
    if (! *from) {
#line 498
      return ((char *)0);
    }
  } else {
    {
#line 502
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 502
      if (*from) {
        {
#line 502
        tmp___9 = __ctype_b_loc();
        }
#line 502
        if ((int const   )*(*tmp___9 + (int )*from) & 8192) {
#line 502
          goto while_break___3;
        }
      } else {
#line 502
        goto while_break___3;
      }
#line 503
      left --;
#line 503
      if (! left) {
        {
#line 504
        alloced___0 += 100;
#line 505
        left += 100;
#line 506
        value = xrealloc(value, alloced___0);
#line 507
        to = ((value + alloced___0) - left) - 2;
        }
      }
#line 509
      tmp___7 = to;
#line 509
      to ++;
#line 509
      tmp___8 = from;
#line 509
      from ++;
#line 509
      *tmp___7 = *tmp___8;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 512
  *to = (char )'\000';
#line 513
  return (value);
}
}
#line 524 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char *value___0  ;
#line 525 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static int alloced___1  =    0;
#line 521 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
char *getDispositionFilename(char *disposition ) 
{ 
  int left ;
  char *to ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 529
  if (! disposition) {
#line 529
    return ((char *)0);
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 534
      if (! ((int )*disposition != 59)) {
#line 534
        goto while_break___0;
      }
#line 535
      if (! *disposition) {
#line 535
        return ((char *)0);
      } else
#line 536
      if ((int )*disposition == 34) {
#line 537
        disposition ++;
        {
#line 538
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 538
          if (*disposition) {
#line 538
            if (! ((int )*disposition != 34)) {
#line 538
              goto while_break___1;
            }
          } else {
#line 538
            goto while_break___1;
          }
#line 539
          if ((int )*disposition == 92) {
#line 540
            disposition ++;
#line 541
            if (! *disposition) {
#line 541
              return ((char *)0);
            }
          }
#line 543
          disposition ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 545
        if (! *disposition) {
#line 545
          return ((char *)0);
        }
      } else
#line 547
      if ((int )*disposition == 40) {
        {
#line 548
        SkipWhitespace(& disposition);
        }
#line 549
        if (! disposition) {
#line 549
          return ((char *)0);
        }
#line 550
        disposition --;
      }
#line 552
      disposition ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 556
    disposition ++;
#line 557
    SkipWhitespace(& disposition);
    }
#line 558
    if (! disposition) {
#line 558
      return ((char *)0);
    }
    {
#line 565
    tmp = strncasecmp((char const   *)disposition, "filename", (size_t )8);
    }
#line 565
    if (tmp != 0) {
#line 565
      goto __Cont;
    }
    {
#line 566
    disposition += 8;
#line 567
    tmp___0 = __ctype_b_loc();
    }
#line 567
    if (! ((int const   )*(*tmp___0 + (int )*disposition) & 8192)) {
#line 567
      if ((int )*disposition != 61) {
#line 567
        if ((int )*disposition != 40) {
#line 569
          goto __Cont;
        }
      }
    }
    {
#line 571
    SkipWhitespace(& disposition);
    }
#line 572
    if (! disposition) {
#line 572
      return ((char *)0);
    }
#line 575
    tmp___1 = disposition;
#line 575
    disposition ++;
#line 575
    if ((int )*tmp___1 == 61) {
#line 575
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 578
  SkipWhitespace(& disposition);
  }
#line 579
  if (! disposition) {
#line 579
    return ((char *)0);
  }
#line 581
  if (! alloced___1) {
    {
#line 582
    alloced___1 = 100;
#line 582
    value___0 = xmalloc(alloced___1);
    }
  }
#line 586
  to = value___0;
#line 587
  left = alloced___1 - 1;
#line 588
  if ((int )*disposition == 34) {
#line 590
    disposition ++;
    {
#line 591
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 591
      if (*disposition) {
#line 591
        if (! ((int )*disposition != 34)) {
#line 591
          goto while_break___2;
        }
      } else {
#line 591
        goto while_break___2;
      }
#line 592
      left --;
#line 592
      if (! left) {
        {
#line 593
        alloced___1 += 100;
#line 594
        left += 100;
#line 595
        value___0 = xrealloc(value___0, alloced___1);
#line 596
        to = ((value___0 + alloced___1) - left) - 2;
        }
      }
#line 598
      if ((int )*disposition == 92) {
#line 599
        disposition ++;
#line 600
        if (! *disposition) {
#line 600
          return ((char *)0);
        }
      }
#line 602
      tmp___2 = to;
#line 602
      to ++;
#line 602
      tmp___3 = disposition;
#line 602
      disposition ++;
#line 602
      *tmp___2 = *tmp___3;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 604
    if (! *disposition) {
#line 604
      return ((char *)0);
    }
  } else {
    {
#line 608
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 608
      if (*disposition) {
        {
#line 608
        tmp___6 = __ctype_b_loc();
        }
#line 608
        if ((int const   )*(*tmp___6 + (int )*disposition) & 8192) {
#line 608
          goto while_break___3;
        } else
#line 608
        if (! ((int )*disposition != 40)) {
#line 608
          goto while_break___3;
        }
      } else {
#line 608
        goto while_break___3;
      }
#line 610
      left --;
#line 610
      if (! left) {
        {
#line 611
        alloced___1 += 100;
#line 612
        left += 100;
#line 613
        value___0 = xrealloc(value___0, alloced___1);
#line 614
        to = ((value___0 + alloced___1) - left) - 2;
        }
      }
#line 616
      tmp___4 = to;
#line 616
      to ++;
#line 616
      tmp___5 = disposition;
#line 616
      disposition ++;
#line 616
      *tmp___4 = *tmp___5;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 619
  *to = (char )'\000';
#line 620
  return (value___0);
}
}
#line 626 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int handlePartial(struct part *inpart , char *headers___0 , params contentParams ,
                  int extractText ) 
{ 
  char *id ;
  char *dir ;
  char *p ;
  int thispart ;
  int nparts ;
  char buf___1[1024] ;
  FILE *partfile ;
  FILE *outfile ;
  struct part *outpart ;
  int i ;
  int docopy ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int skippedfirstbyte ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 630
  nparts = 0;
#line 636
  id = getParam(contentParams, (char *)"id");
  }
#line 637
  if (! id) {
    {
#line 638
    warn((char *)"partial message has no id parameter");
    }
#line 639
    goto ignore;
  }
  {
#line 643
  dir = os_idtodir(id);
  }
#line 644
  if (! dir) {
#line 644
    goto ignore;
  }
  {
#line 646
  p = getParam(contentParams, (char *)"number");
  }
#line 647
  if (! p) {
    {
#line 648
    warn((char *)"partial message doesn\'t have number parameter");
    }
#line 649
    goto ignore;
  }
  {
#line 651
  thispart = atoi((char const   *)p);
#line 653
  p = getParam(contentParams, (char *)"total");
  }
#line 653
  if (p) {
    {
#line 654
    nparts = atoi((char const   *)p);
    }
#line 655
    if (nparts <= 0) {
      {
#line 656
      warn((char *)"partial message has invalid number of parts");
      }
#line 657
      goto ignore;
    }
    {
#line 660
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
            dir);
#line 661
    partfile = os_createnewfile(buf___1);
    }
#line 662
    if (! partfile) {
      {
#line 663
      os_perror(buf___1);
      }
#line 664
      goto ignore;
    }
    {
#line 666
    fprintf((FILE */* __restrict  */)partfile, (char const   */* __restrict  */)"%d\n",
            nparts);
#line 667
    fclose(partfile);
    }
  } else {
    {
#line 671
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
            dir);
#line 672
    partfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 672
    if (partfile) {
      {
#line 673
      tmp = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)partfile);
      }
#line 673
      if (tmp) {
        {
#line 674
        nparts = atoi((char const   *)(buf___1));
        }
#line 675
        if (nparts < 0) {
#line 675
          nparts = 0;
        }
      }
      {
#line 677
      fclose(partfile);
      }
    }
  }
#line 682
  if (thispart <= 0) {
    {
#line 683
    warn((char *)"partial message has invalid number");
    }
#line 684
    goto ignore;
  } else
#line 682
  if (nparts) {
#line 682
    if (thispart > nparts) {
      {
#line 683
      warn((char *)"partial message has invalid number");
      }
#line 684
      goto ignore;
    }
  }
  {
#line 687
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"Saving part %d ",
          thispart);
  }
#line 688
  if (nparts) {
    {
#line 688
    tmp___0 = strlen((char const   *)(buf___1));
#line 688
    sprintf((char */* __restrict  */)(buf___1 + tmp___0), (char const   */* __restrict  */)"of %d ",
            nparts);
    }
  }
  {
#line 689
  tmp___1 = getParam(contentParams, (char *)"id");
#line 689
  strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)tmp___1);
#line 690
  chat(buf___1);
#line 693
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
          dir, thispart);
#line 694
  partfile = os_createnewfile(buf___1);
  }
#line 695
  if (! partfile) {
    {
#line 696
    os_perror(buf___1);
    }
#line 697
    goto ignore;
  }
#line 701
  if (thispart == 1) {
#line 702
    skippedfirstbyte = 0;
    {
#line 704
    while (1) {
      while_continue: /* CIL Label */ ;
#line 704
      if (! *headers___0) {
#line 704
        goto while_break;
      }
#line 705
      if ((int )*headers___0 == 10) {
        {
#line 705
        tmp___4 = strncasecmp((char const   *)headers___0, "\ncontent-", (size_t )9);
        }
#line 705
        if (tmp___4) {
          {
#line 705
          tmp___5 = strncasecmp((char const   *)headers___0, "\nmessage-id:", (size_t )12);
          }
#line 705
          if (tmp___5) {
#line 705
            goto _L;
          } else {
            _L___0: /* CIL Label */ 
#line 709
            headers___0 ++;
            {
#line 710
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 710
              if (*headers___0) {
#line 710
                if (! ((int )*headers___0 != 10)) {
                  {
#line 710
                  tmp___2 = __ctype_b_loc();
                  }
#line 710
                  if (! ((int const   )*(*tmp___2 + (int )*(headers___0 + 1)) & 8192)) {
#line 710
                    goto while_break___0;
                  }
                }
              } else {
#line 710
                goto while_break___0;
              }
#line 711
              headers___0 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        } else {
#line 705
          goto _L___0;
        }
      } else {
        _L: /* CIL Label */ 
#line 716
        tmp___3 = skippedfirstbyte;
#line 716
        skippedfirstbyte ++;
#line 716
        if (tmp___3) {
          {
#line 716
          _IO_putc((int )*headers___0, partfile);
          }
        }
#line 717
        headers___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 720
    docopy = 0;
    {
#line 722
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 722
      tmp___11 = part_gets(buf___1, (int )sizeof(buf___1), inpart);
      }
#line 722
      if (! tmp___11) {
#line 722
        goto while_break___1;
      }
#line 723
      if ((int )buf___1[0] == 10) {
        {
#line 724
        _IO_putc('\n', partfile);
        }
#line 725
        goto while_break___1;
      }
      {
#line 727
      tmp___7 = strncasecmp((char const   *)(buf___1), "content-", (size_t )8);
      }
#line 727
      if (tmp___7) {
        {
#line 727
        tmp___8 = strncasecmp((char const   *)(buf___1), "message-id:", (size_t )11);
        }
#line 727
        if (tmp___8) {
          {
#line 730
          tmp___6 = __ctype_b_loc();
          }
#line 730
          if (! ((int const   )*(*tmp___6 + (int )buf___1[0]) & 8192)) {
#line 731
            docopy = 0;
          }
        } else {
#line 728
          docopy = 1;
        }
      } else {
#line 728
        docopy = 1;
      }
#line 734
      if (docopy) {
        {
#line 734
        fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)partfile);
        }
      }
      {
#line 735
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 735
        tmp___9 = strlen((char const   *)(buf___1));
        }
#line 735
        if ((int )buf___1[tmp___9 - 1UL] != 10) {
          {
#line 735
          tmp___10 = part_gets(buf___1, (int )sizeof(buf___1), inpart);
          }
#line 735
          if (! tmp___10) {
#line 735
            goto while_break___2;
          }
        } else {
#line 735
          goto while_break___2;
        }
#line 736
        if (docopy) {
          {
#line 736
          fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)partfile);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 742
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 742
    tmp___12 = part_gets(buf___1, (int )sizeof(buf___1), inpart);
    }
#line 742
    if (! tmp___12) {
#line 742
      goto while_break___3;
    }
    {
#line 743
    fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)partfile);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 745
  fclose(partfile);
#line 750
  i = nparts;
  }
  {
#line 750
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 750
    if (! i) {
#line 750
      goto while_break___4;
    }
    {
#line 751
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, i);
#line 752
    partfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 753
    if (partfile) {
      {
#line 754
      fclose(partfile);
      }
    } else {
#line 757
      goto while_break___4;
    }
#line 750
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 761
  if (i) {
#line 763
    return (0);
  } else
#line 761
  if (! nparts) {
#line 763
    return (0);
  }
  {
#line 767
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sFULL",
          dir);
#line 768
  outfile = os_createnewfile(buf___1);
  }
#line 769
  if (! outfile) {
    {
#line 770
    os_perror(buf___1);
    }
#line 771
    return (1);
  }
#line 773
  i = 1;
  {
#line 773
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 773
    if (! (i <= nparts)) {
#line 773
      goto while_break___5;
    }
    {
#line 774
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, i);
#line 775
    partfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
    }
#line 776
    if (! partfile) {
      {
#line 777
      os_perror(buf___1);
      }
#line 778
      return (1);
    }
    {
#line 780
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 780
      tmp___13 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1),
                       (FILE */* __restrict  */)partfile);
      }
#line 780
      if (! tmp___13) {
#line 780
        goto while_break___6;
      }
      {
#line 781
      fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)outfile);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 783
    fclose(partfile);
#line 786
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s%d",
            dir, i);
#line 787
    unlink((char const   *)(buf___1));
#line 773
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 791
  fclose(outfile);
#line 792
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sFULL",
          dir);
#line 793
  outfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
  }
#line 794
  if (! outfile) {
    {
#line 795
    os_perror(buf___1);
    }
#line 796
    return (1);
  }
  {
#line 798
  outpart = part_init(outfile);
#line 799
  handleMessage(outpart, (char *)"text/plain", 0, extractText);
#line 800
  part_close(outpart);
#line 803
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sFULL",
          dir);
#line 804
  unlink((char const   *)(buf___1));
#line 805
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%sCT",
          dir);
#line 806
  unlink((char const   *)(buf___1));
#line 807
  os_donewithdir(dir);
  }
#line 809
  return (0);
  ignore: 
  {
#line 812
  ignoreMessage(inpart);
  }
#line 813
  return (1);
}
}
#line 819 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int ignoreMessage(struct part *inpart ) 
{ 
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    tmp___3 = inpart->cnt;
#line 821
    (inpart->cnt) --;
#line 821
    if (tmp___3 > 0) {
#line 821
      if ((int )*(inpart->ptr + 0) != 10) {
#line 821
        tmp___0 = inpart->ptr;
#line 821
        (inpart->ptr) ++;
#line 821
        tmp___2 = (int )*tmp___0;
      } else {
        {
#line 821
        tmp___1 = part_fill(inpart);
#line 821
        tmp___2 = tmp___1;
        }
      }
    } else {
      {
#line 821
      tmp___1 = part_fill(inpart);
#line 821
      tmp___2 = tmp___1;
      }
    }
#line 821
    if (! (tmp___2 != -1)) {
#line 821
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 822
  return (0);
}
}
#line 828 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int handleMultipart(struct part *inpart , char *contentType , params contentParams ,
                    int extractText ) 
{ 
  char *id ;
  char *defaultContentType ;
  int isAppleDouble ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 831
  defaultContentType = (char *)"text/plain";
#line 832
  isAppleDouble = 0;
#line 835
  tmp = strcasecmp((char const   *)contentType, "multipart/digest");
  }
#line 835
  if (! tmp) {
#line 836
    defaultContentType = (char *)"message/rfc822";
  }
  {
#line 838
  tmp___0 = strcasecmp((char const   *)contentType, "multipart/appledouble");
  }
#line 838
  if (! tmp___0) {
#line 839
    isAppleDouble ++;
  }
  {
#line 842
  id = getParam(contentParams, (char *)"boundary");
  }
#line 842
  if (! id) {
    {
#line 843
    warn((char *)"multipart message has no boundary parameter");
#line 844
    id = (char *)"";
    }
  }
  {
#line 848
  part_addboundary(inpart, id);
#line 865
  (inpart->cnt) ++;
#line 865
  inpart->boundary_seen = inpart->boundary_num;
#line 865
  (inpart->ptr) --;
#line 865
  *(inpart->ptr) = (unsigned char )'\n';
#line 866
  ignoreMessage(inpart);
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 869
    tmp___1 = part_readboundary(inpart);
    }
#line 869
    if (tmp___1) {
#line 869
      goto while_break;
    }
    {
#line 870
    handleMessage(inpart, defaultContentType, isAppleDouble, extractText);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 878
  ignoreMessage(inpart);
#line 881
  unlink("tempdesc.txt");
  }
#line 883
  return (0);
}
}
#line 890 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int handleText(struct part *inpart , enum encoding contentEncoding ) 
{ 
  FILE *descfile ;

  {
  {
#line 894
  descfile = os_createnewfile((char *)"tempdesc.txt");
  }
#line 895
  if (! descfile) {
    {
#line 896
    os_perror((char *)"tempdesc.txt");
#line 897
    ignoreMessage(inpart);
    }
#line 898
    return (1);
  }
  {
#line 903
  if ((unsigned int )contentEncoding == 0U) {
#line 903
    goto case_0;
  }
#line 907
  if ((unsigned int )contentEncoding == 1U) {
#line 907
    goto case_1;
  }
#line 911
  if ((unsigned int )contentEncoding == 2U) {
#line 911
    goto case_2;
  }
#line 902
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 904
  fromnone(inpart, descfile, (char **)0);
  }
#line 905
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 908
  fromqp(inpart, descfile, (char **)0);
  }
#line 909
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 912
  from64(inpart, descfile, (char **)0, 1);
  }
#line 913
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 916
  fclose(descfile);
  }
#line 917
  return (0);
}
}
#line 923 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
int saveToFile(struct part *inpart , int inAppleDouble , char *contentType , params contentParams ,
               enum encoding contentEncoding , char *contentDisposition , char *contentMD5 ) 
{ 
  FILE *outfile ;
  int flags ;
  int suppressCR ;
  char *outputmd5 ;
  char *fname ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 925
  outfile = (FILE *)0;
#line 926
  flags = 0;
#line 927
  suppressCR = 0;
#line 931
  tmp = strncasecmp((char const   *)contentType, "text/", (size_t )5);
  }
#line 931
  if (tmp) {
#line 934
    if ((unsigned int )contentEncoding == 2U) {
#line 946
      flags |= 1;
    }
  } else {
#line 932
    suppressCR = 1;
  }
#line 949
  if (inAppleDouble) {
#line 949
    flags |= 2;
  }
  {
#line 952
  fname = getDispositionFilename(contentDisposition);
  }
#line 953
  if (! fname) {
    {
#line 953
    fname = getParam(contentParams, (char *)"name");
    }
  }
#line 954
  if (fname) {
    {
#line 954
    fname = strsave(fname);
    }
  }
  {
#line 955
  outfile = os_newtypedfile(fname, contentType, flags, contentParams);
  }
#line 956
  if (fname) {
    {
#line 956
    free((void *)fname);
    }
  }
#line 957
  if (! outfile) {
    {
#line 958
    ignoreMessage(inpart);
    }
#line 959
    return (1);
  }
  {
#line 964
  if ((unsigned int )contentEncoding == 0U) {
#line 964
    goto case_0;
  }
#line 968
  if ((unsigned int )contentEncoding == 1U) {
#line 968
    goto case_1;
  }
#line 972
  if ((unsigned int )contentEncoding == 2U) {
#line 972
    goto case_2;
  }
#line 963
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 965
  fromnone(inpart, outfile, & outputmd5);
  }
#line 966
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 969
  fromqp(inpart, outfile, & outputmd5);
  }
#line 970
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 973
  from64(inpart, outfile, & outputmd5, suppressCR);
  }
#line 974
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 976
  rewind(outfile);
  }
#line 979
  if (contentMD5) {
    {
#line 980
    tmp___0 = strlen((char const   *)outputmd5);
#line 980
    tmp___1 = strncmp((char const   *)outputmd5, (char const   *)contentMD5, tmp___0);
    }
#line 980
    if (tmp___1 != 0) {
      {
#line 981
      os_warnMD5mismatch();
      }
    }
  }
  {
#line 984
  free((void *)outputmd5);
#line 986
  os_closetypedfile(outfile);
  }
#line 987
  return (0);
}
}
#line 994 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char index_hex[256]  = 
#line 994
  {      (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)0,      (char)1,      (char)2,      (char)3, 
        (char)4,      (char)5,      (char)6,      (char)7, 
        (char)8,      (char)9,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)10,      (char)11,      (char)12, 
        (char)13,      (char)14,      (char)15,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127};
#line 1017 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
static char index_64[256]  = 
#line 1017
  {      (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)62, 
        (char)127,      (char)127,      (char)127,      (char)63, 
        (char)52,      (char)53,      (char)54,      (char)55, 
        (char)56,      (char)57,      (char)58,      (char)59, 
        (char)60,      (char)61,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)0,      (char)1,      (char)2, 
        (char)3,      (char)4,      (char)5,      (char)6, 
        (char)7,      (char)8,      (char)9,      (char)10, 
        (char)11,      (char)12,      (char)13,      (char)14, 
        (char)15,      (char)16,      (char)17,      (char)18, 
        (char)19,      (char)20,      (char)21,      (char)22, 
        (char)23,      (char)24,      (char)25,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)26,      (char)27,      (char)28, 
        (char)29,      (char)30,      (char)31,      (char)32, 
        (char)33,      (char)34,      (char)35,      (char)36, 
        (char)37,      (char)38,      (char)39,      (char)40, 
        (char)41,      (char)42,      (char)43,      (char)44, 
        (char)45,      (char)46,      (char)47,      (char)48, 
        (char)49,      (char)50,      (char)51,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127, 
        (char)127,      (char)127,      (char)127,      (char)127};
#line 1037 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
void from64(struct part *inpart , FILE *outfile , char **digestp , int suppressCR ) 
{ 
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  int DataDone ;
  char buf___1[3] ;
  MD5_CTX context ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1040
  DataDone = 0;
#line 1044
  if (digestp) {
    {
#line 1044
    MD5Init(& context);
    }
  }
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1045
    tmp___14 = inpart->cnt;
#line 1045
    (inpart->cnt) --;
#line 1045
    if (tmp___14 > 0) {
#line 1045
      if ((int )*(inpart->ptr + 0) != 10) {
#line 1045
        tmp___12 = inpart->ptr;
#line 1045
        (inpart->ptr) ++;
#line 1045
        c1 = (int )*tmp___12;
      } else {
        {
#line 1045
        tmp___13 = part_fill(inpart);
#line 1045
        c1 = tmp___13;
        }
      }
    } else {
      {
#line 1045
      tmp___13 = part_fill(inpart);
#line 1045
      c1 = tmp___13;
      }
    }
#line 1045
    if (! (c1 != -1)) {
#line 1045
      goto while_break;
    }
#line 1046
    if (c1 != 61) {
#line 1046
      if ((int )index_64[(unsigned char )c1] == 127) {
#line 1047
        goto while_continue;
      }
    }
#line 1049
    if (DataDone) {
#line 1049
      goto while_continue;
    }
    {
#line 1050
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1051
      tmp___2 = inpart->cnt;
#line 1051
      (inpart->cnt) --;
#line 1051
      if (tmp___2 > 0) {
#line 1051
        if ((int )*(inpart->ptr + 0) != 10) {
#line 1051
          tmp___0 = inpart->ptr;
#line 1051
          (inpart->ptr) ++;
#line 1051
          c2 = (int )*tmp___0;
        } else {
          {
#line 1051
          tmp___1 = part_fill(inpart);
#line 1051
          c2 = tmp___1;
          }
        }
      } else {
        {
#line 1051
        tmp___1 = part_fill(inpart);
#line 1051
        c2 = tmp___1;
        }
      }
#line 1050
      if (c2 != -1) {
#line 1050
        if (c2 != 61) {
#line 1050
          if (! ((int )index_64[(unsigned char )c2] == 127)) {
#line 1050
            goto while_break___0;
          }
        } else {
#line 1050
          goto while_break___0;
        }
      } else {
#line 1050
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1053
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1054
      tmp___6 = inpart->cnt;
#line 1054
      (inpart->cnt) --;
#line 1054
      if (tmp___6 > 0) {
#line 1054
        if ((int )*(inpart->ptr + 0) != 10) {
#line 1054
          tmp___4 = inpart->ptr;
#line 1054
          (inpart->ptr) ++;
#line 1054
          c3 = (int )*tmp___4;
        } else {
          {
#line 1054
          tmp___5 = part_fill(inpart);
#line 1054
          c3 = tmp___5;
          }
        }
      } else {
        {
#line 1054
        tmp___5 = part_fill(inpart);
#line 1054
        c3 = tmp___5;
        }
      }
#line 1053
      if (c3 != -1) {
#line 1053
        if (c3 != 61) {
#line 1053
          if (! ((int )index_64[(unsigned char )c3] == 127)) {
#line 1053
            goto while_break___1;
          }
        } else {
#line 1053
          goto while_break___1;
        }
      } else {
#line 1053
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1056
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1057
      tmp___10 = inpart->cnt;
#line 1057
      (inpart->cnt) --;
#line 1057
      if (tmp___10 > 0) {
#line 1057
        if ((int )*(inpart->ptr + 0) != 10) {
#line 1057
          tmp___8 = inpart->ptr;
#line 1057
          (inpart->ptr) ++;
#line 1057
          c4 = (int )*tmp___8;
        } else {
          {
#line 1057
          tmp___9 = part_fill(inpart);
#line 1057
          c4 = tmp___9;
          }
        }
      } else {
        {
#line 1057
        tmp___9 = part_fill(inpart);
#line 1057
        c4 = tmp___9;
        }
      }
#line 1056
      if (c4 != -1) {
#line 1056
        if (c4 != 61) {
#line 1056
          if (! ((int )index_64[(unsigned char )c4] == 127)) {
#line 1056
            goto while_break___2;
          }
        } else {
#line 1056
          goto while_break___2;
        }
      } else {
#line 1056
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1059
    if (c2 == -1) {
      {
#line 1060
      warn((char *)"Premature EOF");
      }
#line 1061
      goto while_break;
    } else
#line 1059
    if (c3 == -1) {
      {
#line 1060
      warn((char *)"Premature EOF");
      }
#line 1061
      goto while_break;
    } else
#line 1059
    if (c4 == -1) {
      {
#line 1060
      warn((char *)"Premature EOF");
      }
#line 1061
      goto while_break;
    }
#line 1063
    if (c1 == 61) {
#line 1064
      DataDone = 1;
#line 1065
      goto while_continue;
    } else
#line 1063
    if (c2 == 61) {
#line 1064
      DataDone = 1;
#line 1065
      goto while_continue;
    }
#line 1067
    c1 = (int )index_64[(unsigned char )c1];
#line 1068
    c2 = (int )index_64[(unsigned char )c2];
#line 1069
    buf___1[0] = (char )((c1 << 2) | ((c2 & 48) >> 4));
#line 1070
    if (! suppressCR) {
      {
#line 1070
      _IO_putc((int )buf___1[0], outfile);
      }
    } else
#line 1070
    if ((int )buf___1[0] != 13) {
      {
#line 1070
      _IO_putc((int )buf___1[0], outfile);
      }
    }
#line 1071
    if (c3 == 61) {
#line 1072
      if (digestp) {
        {
#line 1072
        MD5Update(& context, buf___1, 1);
        }
      }
#line 1073
      DataDone = 1;
    } else {
#line 1075
      c3 = (int )index_64[(unsigned char )c3];
#line 1076
      buf___1[1] = (char )(((c2 & 15) << 4) | ((c3 & 60) >> 2));
#line 1077
      if (! suppressCR) {
        {
#line 1077
        _IO_putc((int )buf___1[1], outfile);
        }
      } else
#line 1077
      if ((int )buf___1[1] != 13) {
        {
#line 1077
        _IO_putc((int )buf___1[1], outfile);
        }
      }
#line 1078
      if (c4 == 61) {
#line 1079
        if (digestp) {
          {
#line 1079
          MD5Update(& context, buf___1, 2);
          }
        }
#line 1080
        DataDone = 1;
      } else {
#line 1082
        c4 = (int )index_64[(unsigned char )c4];
#line 1083
        buf___1[2] = (char )(((c3 & 3) << 6) | c4);
#line 1084
        if (! suppressCR) {
          {
#line 1084
          _IO_putc((int )buf___1[2], outfile);
          }
        } else
#line 1084
        if ((int )buf___1[2] != 13) {
          {
#line 1084
          _IO_putc((int )buf___1[2], outfile);
          }
        }
#line 1085
        if (digestp) {
          {
#line 1085
          MD5Update(& context, buf___1, 3);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1089
  if (digestp) {
    {
#line 1089
    *digestp = md5contextTo64(& context);
    }
  }
#line 1090
  return;
}
}
#line 1092 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
void fromqp(struct part *inpart , FILE *outfile , char **digestp ) 
{ 
  int c1 ;
  int c2 ;
  MD5_CTX context ;
  char c ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1098
  if (digestp) {
    {
#line 1098
    MD5Init(& context);
    }
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    tmp___10 = inpart->cnt;
#line 1100
    (inpart->cnt) --;
#line 1100
    if (tmp___10 > 0) {
#line 1100
      if ((int )*(inpart->ptr + 0) != 10) {
#line 1100
        tmp___8 = inpart->ptr;
#line 1100
        (inpart->ptr) ++;
#line 1100
        c1 = (int )*tmp___8;
      } else {
        {
#line 1100
        tmp___9 = part_fill(inpart);
#line 1100
        c1 = tmp___9;
        }
      }
    } else {
      {
#line 1100
      tmp___9 = part_fill(inpart);
#line 1100
      c1 = tmp___9;
      }
    }
#line 1100
    if (! (c1 != -1)) {
#line 1100
      goto while_break;
    }
#line 1101
    if (c1 == 61) {
#line 1102
      tmp___2 = inpart->cnt;
#line 1102
      (inpart->cnt) --;
#line 1102
      if (tmp___2 > 0) {
#line 1102
        if ((int )*(inpart->ptr + 0) != 10) {
#line 1102
          tmp___0 = inpart->ptr;
#line 1102
          (inpart->ptr) ++;
#line 1102
          c1 = (int )*tmp___0;
        } else {
          {
#line 1102
          tmp___1 = part_fill(inpart);
#line 1102
          c1 = tmp___1;
          }
        }
      } else {
        {
#line 1102
        tmp___1 = part_fill(inpart);
#line 1102
        c1 = tmp___1;
        }
      }
#line 1103
      if (c1 != 10) {
#line 1104
        c1 = (int )index_hex[(unsigned char )c1];
#line 1105
        tmp___6 = inpart->cnt;
#line 1105
        (inpart->cnt) --;
#line 1105
        if (tmp___6 > 0) {
#line 1105
          if ((int )*(inpart->ptr + 0) != 10) {
#line 1105
            tmp___4 = inpart->ptr;
#line 1105
            (inpart->ptr) ++;
#line 1105
            c2 = (int )*tmp___4;
          } else {
            {
#line 1105
            tmp___5 = part_fill(inpart);
#line 1105
            c2 = tmp___5;
            }
          }
        } else {
          {
#line 1105
          tmp___5 = part_fill(inpart);
#line 1105
          c2 = tmp___5;
          }
        }
#line 1106
        c2 = (int )index_hex[(unsigned char )c2];
#line 1107
        c = (char )((c1 << 4) | c2);
#line 1108
        if ((int )c != 13) {
          {
#line 1108
          _IO_putc((int )c, outfile);
          }
        }
#line 1109
        if (digestp) {
          {
#line 1109
          MD5Update(& context, & c, 1);
          }
        }
      }
    } else {
      {
#line 1112
      _IO_putc(c1, outfile);
      }
#line 1113
      if (c1 == 10) {
#line 1114
        if (digestp) {
          {
#line 1114
          MD5Update(& context, "\r", 1);
          }
        }
      }
#line 1116
      c = (char )c1;
#line 1117
      if (digestp) {
        {
#line 1117
        MD5Update(& context, & c, 1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1120
  if (digestp) {
    {
#line 1120
    *digestp = md5contextTo64(& context);
    }
  }
#line 1121
  return;
}
}
#line 1123 "/home/wheatley/newnew/temp/mpack-1.6/decode.c"
void fromnone(struct part *inpart , FILE *outfile , char **digestp ) 
{ 
  int c ;
  char ch ;
  MD5_CTX context ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1129
  if (digestp) {
    {
#line 1129
    MD5Init(& context);
    }
  }
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    tmp___2 = inpart->cnt;
#line 1131
    (inpart->cnt) --;
#line 1131
    if (tmp___2 > 0) {
#line 1131
      if ((int )*(inpart->ptr + 0) != 10) {
#line 1131
        tmp___0 = inpart->ptr;
#line 1131
        (inpart->ptr) ++;
#line 1131
        c = (int )*tmp___0;
      } else {
        {
#line 1131
        tmp___1 = part_fill(inpart);
#line 1131
        c = tmp___1;
        }
      }
    } else {
      {
#line 1131
      tmp___1 = part_fill(inpart);
#line 1131
      c = tmp___1;
      }
    }
#line 1131
    if (! (c != -1)) {
#line 1131
      goto while_break;
    }
    {
#line 1132
    _IO_putc(c, outfile);
    }
#line 1133
    if (c == 10) {
#line 1134
      if (digestp) {
        {
#line 1134
        MD5Update(& context, "\r", 1);
        }
      }
    }
#line 1136
    ch = (char )c;
#line 1137
    if (digestp) {
      {
#line 1137
      MD5Update(& context, & ch, 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  if (digestp) {
    {
#line 1139
    *digestp = md5contextTo64(& context);
    }
  }
#line 1140
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 29 "/home/wheatley/newnew/temp/mpack-1.6/xmalloc.c"
char *xmalloc(int size ) 
{ 
  char *ret ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc((size_t )((unsigned int )size));
#line 33
  ret = (char *)tmp;
  }
#line 33
  if (ret) {
#line 34
    return (ret);
  }
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory exhausted\n");
#line 37
  exit(1);
  }
}
}
#line 41 "/home/wheatley/newnew/temp/mpack-1.6/xmalloc.c"
char *xrealloc(char *ptr , int size ) 
{ 
  char *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 46
  if (! ptr) {
    {
#line 46
    tmp = malloc((size_t )((unsigned int )size));
#line 46
    ret = (char *)tmp;
    }
  } else {
    {
#line 46
    tmp___0 = realloc((void *)ptr, (size_t )((unsigned int )size));
#line 46
    ret = (char *)tmp___0;
    }
  }
#line 46
  if (ret) {
#line 47
    return (ret);
  }
  {
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory exhausted\n");
#line 50
  exit(1);
  }
}
}
#line 53 "/home/wheatley/newnew/temp/mpack-1.6/xmalloc.c"
char *strsave(char *str ) 
{ 
  char *p ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 55
  tmp = strlen((char const   *)str);
#line 55
  tmp___0 = xmalloc((int )(tmp + 1UL));
#line 55
  p = tmp___0;
#line 56
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)str);
  }
#line 57
  return (p);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 51 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
int overwrite_files  =    0;
#line 52 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
int didchat  ;
#line 55 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char *output_fname  =    (char *)0;
#line 63
char *os_genid(void) ;
#line 63 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static int pid  =    0;
#line 64 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static time_t curtime  ;
#line 65 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char hostname[65]  ;
#line 61 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
char *os_genid(void) 
{ 
  char *result ;
  struct hostent *hp ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  time_t tmp___2 ;

  {
#line 70
  if (pid == 0) {
    {
#line 71
    pid = getpid();
#line 72
    time(& curtime);
#line 73
    gethostname(hostname, sizeof(hostname));
#line 76
    tmp = strchr((char const   *)(hostname), '.');
    }
#line 76
    if (! tmp) {
      {
#line 77
      hp = gethostbyname((char const   *)(hostname));
      }
#line 78
      if (hp) {
        {
#line 79
        strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)hp->h_name);
        }
      }
    }
  }
  {
#line 84
  tmp___0 = strlen((char const   *)(hostname));
#line 84
  tmp___1 = malloc(25UL + tmp___0);
#line 84
  result = (char *)tmp___1;
#line 85
  tmp___2 = curtime;
#line 85
  curtime ++;
#line 85
  sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%d.%lu@%s",
          pid, (unsigned long )tmp___2, hostname);
  }
#line 86
  return (result);
}
}
#line 92 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char buf[4096]  ;
#line 90 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
char *os_idtodir(char *id ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 95
  tmp___0 = getenv("TMPDIR");
  }
#line 95
  if (tmp___0) {
    {
#line 96
    tmp = getenv("TMPDIR");
#line 96
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 99
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/var/tmp");
    }
  }
  {
#line 101
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/m-prts-");
#line 102
  p = getenv("USER");
  }
#line 103
  if (! p) {
    {
#line 103
    p = getenv("LOGNAME");
    }
  }
#line 104
  if (! p) {
#line 104
    p = (char *)"x";
  }
  {
#line 105
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)p);
#line 107
  mkdir((char const   *)(buf), (__mode_t )448);
#line 109
  tmp___1 = strlen((char const   *)(buf));
#line 109
  p = buf + tmp___1;
#line 110
  tmp___2 = p;
#line 110
  p ++;
#line 110
  *tmp___2 = (char )'/';
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (*id) {
#line 111
      if (! ((unsigned long )p < (unsigned long )((buf + sizeof(buf)) - 10))) {
#line 111
        goto while_break;
      }
    } else {
#line 111
      goto while_break;
    }
    {
#line 112
    tmp___4 = __ctype_b_loc();
    }
#line 112
    if ((int const   )*(*tmp___4 + (int )*id) & 16384) {
      {
#line 112
      tmp___5 = strchr("!$&*()|\'\";<>[]{}?/`\\ \t", (int )*id);
      }
#line 112
      if (! tmp___5) {
#line 112
        tmp___3 = p;
#line 112
        p ++;
#line 112
        *tmp___3 = *id;
      }
    }
#line 113
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  *p = (char )'\000';
#line 116
  tmp___6 = mkdir((char const   *)(buf), (__mode_t )448);
  }
#line 116
  if (tmp___6 == -1) {
    {
#line 116
    tmp___7 = __errno_location();
    }
#line 116
    if (*tmp___7 != 17) {
      {
#line 117
      perror((char const   *)(buf));
      }
#line 118
      return ((char *)0);
    }
  }
#line 120
  tmp___8 = p;
#line 120
  p ++;
#line 120
  *tmp___8 = (char )'/';
#line 121
  *p = (char )'\000';
#line 122
  return (buf);
}
}
#line 129 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
void os_donewithdir(char *dir ) 
{ 
  char *p ;
  size_t tmp ;

  {
  {
#line 134
  tmp = strlen((char const   *)dir);
#line 134
  p = (dir + tmp) - 1;
#line 135
  *p = (char )'\000';
#line 137
  rmdir((char const   *)dir);
  }
#line 138
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
FILE *os_createnewfile(char *fname ) 
{ 
  int fd ;
  FILE *ret ;
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 148
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& statbuf));
  }
#line 148
  if (tmp == 0) {
#line 148
    if ((statbuf.st_mode & 61440U) == 8192U) {
      {
#line 149
      fd = open((char const   *)fname, 2);
      }
    } else {
      {
#line 152
      fd = open((char const   *)fname, 194, 384);
      }
    }
  } else {
    {
#line 152
    fd = open((char const   *)fname, 194, 384);
    }
  }
#line 158
  if (fd == -1) {
#line 159
    return ((FILE *)((void *)0));
  }
  {
#line 161
  ret = fdopen(fd, "w");
  }
#line 162
  return (ret);
}
}
#line 176 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static int filesuffix  =    0;
#line 173 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
FILE *os_newtypedfile(char *fname , char *contentType , int flags , params contentParams ) 
{ 
  char *p ;
  char buf___1[128] ;
  char *descfname ;
  FILE *outfile ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 177
  descfname = (char *)0;
#line 178
  outfile = (FILE *)0;
#line 180
  if (! fname) {
#line 180
    fname = (char *)"";
  }
#line 183
  if ((int )*fname == 47) {
    {
#line 184
    p = strrchr((char const   *)fname, '/');
#line 185
    fname = p + 1;
    }
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((int )*fname == 126)) {
#line 189
      if (! ((int )*fname == 47)) {
#line 189
        goto while_break;
      }
    }
#line 189
    fname ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 191
    tmp = strncmp((char const   *)fname, "../", (size_t )3);
    }
#line 191
    if (tmp) {
#line 191
      goto while_break___0;
    }
#line 191
    fname += 3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  p = fname;
  {
#line 194
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 194
    if (! *p) {
#line 194
      goto while_break___1;
    }
#line 195
    if ((int )*p == 47) {
      {
#line 196
      tmp___1 = strncmp((char const   *)p, "/../", (size_t )4);
      }
#line 196
      if (! tmp___1) {
#line 197
        tmp___0 = (char )'X';
#line 197
        *(p + 2) = tmp___0;
#line 197
        *(p + 1) = tmp___0;
      }
      {
#line 199
      *p = (char )'\000';
#line 200
      mkdir((char const   *)fname, (__mode_t )511);
#line 201
      *p = (char )'/';
      }
    } else {
      {
#line 203
      tmp___2 = __ctype_b_loc();
      }
#line 203
      if ((int const   )*(*tmp___2 + (int )*p) & 16384) {
        {
#line 203
        tmp___3 = strchr("!$&*()|\'\";<>[]{}?/`\\ \t", (int )*p);
        }
#line 203
        if (tmp___3) {
#line 203
          *p = (char )'X';
        }
      } else {
#line 203
        *p = (char )'X';
      }
    }
#line 194
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 206
  if (! *(fname + 0)) {
    {
#line 207
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 208
      if (outfile) {
        {
#line 208
        fclose(outfile);
        }
      }
      {
#line 209
      filesuffix ++;
#line 209
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"part%d",
              filesuffix);
#line 207
      outfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
      }
#line 207
      if (! outfile) {
#line 207
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 211
    fname = buf___1;
  } else
#line 213
  if (! overwrite_files) {
    {
#line 213
    outfile = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 213
    if (outfile) {
      {
#line 214
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 215
        fclose(outfile);
#line 216
        filesuffix ++;
#line 216
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s.%d",
                fname, filesuffix);
#line 214
        outfile = fopen((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"r");
        }
#line 214
        if (! outfile) {
#line 214
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 219
      fname = buf___1;
    }
  }
#line 222
  if (overwrite_files) {
    {
#line 223
    outfile = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
    }
  } else {
    {
#line 225
    outfile = os_createnewfile(fname);
    }
  }
#line 227
  if (! outfile) {
    {
#line 228
    perror((char const   *)fname);
    }
  }
#line 231
  if (output_fname) {
    {
#line 231
    free((void *)output_fname);
    }
  }
  {
#line 232
  output_fname = strsave(fname);
#line 234
  tmp___5 = strlen((char const   *)fname);
  }
#line 234
  if (tmp___5 > sizeof(buf___1) - 6UL) {
    {
#line 235
    tmp___4 = strlen((char const   *)fname);
#line 235
    descfname = xmalloc((int )(tmp___4 + 6UL));
    }
  } else {
#line 238
    descfname = buf___1;
  }
  {
#line 240
  strcpy((char */* __restrict  */)descfname, (char const   */* __restrict  */)fname);
#line 242
  p = strchr((char const   *)descfname, '/');
  }
#line 243
  if (! p) {
#line 243
    p = descfname;
  }
  {
#line 244
  p = strrchr((char const   *)p, '.');
  }
#line 244
  if (p) {
#line 244
    *p = (char )'\000';
  }
  {
#line 246
  strcat((char */* __restrict  */)descfname, (char const   */* __restrict  */)".desc");
#line 247
  rename("tempdesc.txt", (char const   *)descfname);
  }
#line 248
  if ((unsigned long )descfname != (unsigned long )(buf___1)) {
    {
#line 248
    free((void *)descfname);
    }
  }
  {
#line 250
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s (%s)\n",
          output_fname, contentType);
#line 251
  didchat = 1;
  }
#line 253
  return (outfile);
}
}
#line 259 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
void os_closetypedfile(FILE *outfile ) 
{ 


  {
  {
#line 261
  fclose(outfile);
  }
#line 262
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
int os_binhex(struct part *inpart , int part , int nparts ) 
{ 


  {
#line 270
  return (1);
}
}
#line 277 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
void os_warnMD5mismatch(void) 
{ 
  char *warning ;
  size_t tmp ;

  {
  {
#line 281
  tmp = strlen((char const   *)output_fname);
#line 281
  warning = xmalloc((int )(tmp + 100UL));
#line 282
  sprintf((char */* __restrict  */)warning, (char const   */* __restrict  */)"%s was corrupted in transit",
          output_fname);
#line 284
  warn(warning);
#line 285
  free((void *)warning);
  }
#line 286
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
void os_perror(char *file ) 
{ 


  {
  {
#line 293
  perror((char const   *)file);
  }
#line 294
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/mpack-1.6/md5.h"
void MD5Final(unsigned char *digest , MD5_CTX *context ) ;
#line 48 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) ;
#line 49
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) ;
#line 51
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) ;
#line 53
static void MD5_memcpy(POINTER output , POINTER input , unsigned int len ) ;
#line 54
static void MD5_memset(POINTER output , int value___1 , unsigned int len ) ;
#line 56 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static unsigned char PADDING[64]  = 
#line 56
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 99 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
void MD5Init(MD5_CTX *context ) 
{ 
  UINT4 tmp ;

  {
#line 102
  tmp = (UINT4 )0;
#line 102
  context->count[1] = tmp;
#line 102
  context->count[0] = tmp;
#line 105
  context->state[0] = (UINT4 )1732584193;
#line 106
  context->state[1] = 4023233417U;
#line 107
  context->state[2] = 2562383102U;
#line 108
  context->state[3] = (UINT4 )271733878;
#line 109
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
void MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) 
{ 
  unsigned int i ;
  unsigned int index ;
  unsigned int partLen ;
  UINT4 tmp ;

  {
#line 123
  index = (context->count[0] >> 3) & 63U;
#line 126
  tmp = context->count[0] + (inputLen << 3);
#line 126
  context->count[0] = tmp;
#line 126
  if (tmp < inputLen << 3) {
#line 128
    (context->count[1]) ++;
  }
#line 129
  context->count[1] += inputLen >> 29;
#line 131
  partLen = 64U - index;
#line 135
  if (inputLen >= partLen) {
    {
#line 136
    MD5_memcpy(& context->buffer[index], input, partLen);
#line 138
    MD5Transform(context->state, context->buffer);
#line 140
    i = partLen;
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (i + 63U < inputLen)) {
#line 140
        goto while_break;
      }
      {
#line 141
      MD5Transform(context->state, input + i);
#line 140
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    index = 0U;
  } else {
#line 146
    i = 0U;
  }
  {
#line 149
  MD5_memcpy(& context->buffer[index], input + i, inputLen - i);
  }
#line 152
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
void MD5Final(unsigned char *digest , MD5_CTX *context ) 
{ 
  unsigned char bits[8] ;
  unsigned int index ;
  unsigned int padLen ;

  {
  {
#line 165
  Encode(bits, context->count, 8);
#line 169
  index = (context->count[0] >> 3) & 63U;
  }
#line 170
  if (index < 56U) {
#line 170
    padLen = 56U - index;
  } else {
#line 170
    padLen = 120U - index;
  }
  {
#line 171
  MD5Update(context, PADDING, padLen);
#line 174
  MD5Update(context, bits, 8U);
#line 177
  Encode(digest, context->state, 16);
#line 181
  MD5_memset((POINTER )context, 0, sizeof(*context));
  }
#line 182
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) 
{ 
  UINT4 a ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d ;
  UINT4 x[16] ;

  {
  {
#line 188
  a = *(state + 0);
#line 188
  b = *(state + 1);
#line 188
  c = *(state + 2);
#line 188
  d = *(state + 3);
#line 190
  Decode(x, block, 64);
#line 193
  a += (((b & c) | (~ b & d)) + x[0]) + 3614090360U;
#line 193
  a = (a << 7) | (a >> 25);
#line 193
  a += b;
#line 194
  d += (((a & b) | (~ a & c)) + x[1]) + 3905402710U;
#line 194
  d = (d << 12) | (d >> 20);
#line 194
  d += a;
#line 195
  c += (((d & a) | (~ d & b)) + x[2]) + 606105819U;
#line 195
  c = (c << 17) | (c >> 15);
#line 195
  c += d;
#line 196
  b += (((c & d) | (~ c & a)) + x[3]) + 3250441966U;
#line 196
  b = (b << 22) | (b >> 10);
#line 196
  b += c;
#line 197
  a += (((b & c) | (~ b & d)) + x[4]) + 4118548399U;
#line 197
  a = (a << 7) | (a >> 25);
#line 197
  a += b;
#line 198
  d += (((a & b) | (~ a & c)) + x[5]) + 1200080426U;
#line 198
  d = (d << 12) | (d >> 20);
#line 198
  d += a;
#line 199
  c += (((d & a) | (~ d & b)) + x[6]) + 2821735955U;
#line 199
  c = (c << 17) | (c >> 15);
#line 199
  c += d;
#line 200
  b += (((c & d) | (~ c & a)) + x[7]) + 4249261313U;
#line 200
  b = (b << 22) | (b >> 10);
#line 200
  b += c;
#line 201
  a += (((b & c) | (~ b & d)) + x[8]) + 1770035416U;
#line 201
  a = (a << 7) | (a >> 25);
#line 201
  a += b;
#line 202
  d += (((a & b) | (~ a & c)) + x[9]) + 2336552879U;
#line 202
  d = (d << 12) | (d >> 20);
#line 202
  d += a;
#line 203
  c += (((d & a) | (~ d & b)) + x[10]) + 4294925233U;
#line 203
  c = (c << 17) | (c >> 15);
#line 203
  c += d;
#line 204
  b += (((c & d) | (~ c & a)) + x[11]) + 2304563134U;
#line 204
  b = (b << 22) | (b >> 10);
#line 204
  b += c;
#line 205
  a += (((b & c) | (~ b & d)) + x[12]) + 1804603682U;
#line 205
  a = (a << 7) | (a >> 25);
#line 205
  a += b;
#line 206
  d += (((a & b) | (~ a & c)) + x[13]) + 4254626195U;
#line 206
  d = (d << 12) | (d >> 20);
#line 206
  d += a;
#line 207
  c += (((d & a) | (~ d & b)) + x[14]) + 2792965006U;
#line 207
  c = (c << 17) | (c >> 15);
#line 207
  c += d;
#line 208
  b += (((c & d) | (~ c & a)) + x[15]) + 1236535329U;
#line 208
  b = (b << 22) | (b >> 10);
#line 208
  b += c;
#line 211
  a += (((b & d) | (c & ~ d)) + x[1]) + 4129170786U;
#line 211
  a = (a << 5) | (a >> 27);
#line 211
  a += b;
#line 212
  d += (((a & c) | (b & ~ c)) + x[6]) + 3225465664U;
#line 212
  d = (d << 9) | (d >> 23);
#line 212
  d += a;
#line 213
  c += (((d & b) | (a & ~ b)) + x[11]) + 643717713U;
#line 213
  c = (c << 14) | (c >> 18);
#line 213
  c += d;
#line 214
  b += (((c & a) | (d & ~ a)) + x[0]) + 3921069994U;
#line 214
  b = (b << 20) | (b >> 12);
#line 214
  b += c;
#line 215
  a += (((b & d) | (c & ~ d)) + x[5]) + 3593408605U;
#line 215
  a = (a << 5) | (a >> 27);
#line 215
  a += b;
#line 216
  d += (((a & c) | (b & ~ c)) + x[10]) + 38016083U;
#line 216
  d = (d << 9) | (d >> 23);
#line 216
  d += a;
#line 217
  c += (((d & b) | (a & ~ b)) + x[15]) + 3634488961U;
#line 217
  c = (c << 14) | (c >> 18);
#line 217
  c += d;
#line 218
  b += (((c & a) | (d & ~ a)) + x[4]) + 3889429448U;
#line 218
  b = (b << 20) | (b >> 12);
#line 218
  b += c;
#line 219
  a += (((b & d) | (c & ~ d)) + x[9]) + 568446438U;
#line 219
  a = (a << 5) | (a >> 27);
#line 219
  a += b;
#line 220
  d += (((a & c) | (b & ~ c)) + x[14]) + 3275163606U;
#line 220
  d = (d << 9) | (d >> 23);
#line 220
  d += a;
#line 221
  c += (((d & b) | (a & ~ b)) + x[3]) + 4107603335U;
#line 221
  c = (c << 14) | (c >> 18);
#line 221
  c += d;
#line 222
  b += (((c & a) | (d & ~ a)) + x[8]) + 1163531501U;
#line 222
  b = (b << 20) | (b >> 12);
#line 222
  b += c;
#line 223
  a += (((b & d) | (c & ~ d)) + x[13]) + 2850285829U;
#line 223
  a = (a << 5) | (a >> 27);
#line 223
  a += b;
#line 224
  d += (((a & c) | (b & ~ c)) + x[2]) + 4243563512U;
#line 224
  d = (d << 9) | (d >> 23);
#line 224
  d += a;
#line 225
  c += (((d & b) | (a & ~ b)) + x[7]) + 1735328473U;
#line 225
  c = (c << 14) | (c >> 18);
#line 225
  c += d;
#line 226
  b += (((c & a) | (d & ~ a)) + x[12]) + 2368359562U;
#line 226
  b = (b << 20) | (b >> 12);
#line 226
  b += c;
#line 229
  a += (((b ^ c) ^ d) + x[5]) + 4294588738U;
#line 229
  a = (a << 4) | (a >> 28);
#line 229
  a += b;
#line 230
  d += (((a ^ b) ^ c) + x[8]) + 2272392833U;
#line 230
  d = (d << 11) | (d >> 21);
#line 230
  d += a;
#line 231
  c += (((d ^ a) ^ b) + x[11]) + 1839030562U;
#line 231
  c = (c << 16) | (c >> 16);
#line 231
  c += d;
#line 232
  b += (((c ^ d) ^ a) + x[14]) + 4259657740U;
#line 232
  b = (b << 23) | (b >> 9);
#line 232
  b += c;
#line 233
  a += (((b ^ c) ^ d) + x[1]) + 2763975236U;
#line 233
  a = (a << 4) | (a >> 28);
#line 233
  a += b;
#line 234
  d += (((a ^ b) ^ c) + x[4]) + 1272893353U;
#line 234
  d = (d << 11) | (d >> 21);
#line 234
  d += a;
#line 235
  c += (((d ^ a) ^ b) + x[7]) + 4139469664U;
#line 235
  c = (c << 16) | (c >> 16);
#line 235
  c += d;
#line 236
  b += (((c ^ d) ^ a) + x[10]) + 3200236656U;
#line 236
  b = (b << 23) | (b >> 9);
#line 236
  b += c;
#line 237
  a += (((b ^ c) ^ d) + x[13]) + 681279174U;
#line 237
  a = (a << 4) | (a >> 28);
#line 237
  a += b;
#line 238
  d += (((a ^ b) ^ c) + x[0]) + 3936430074U;
#line 238
  d = (d << 11) | (d >> 21);
#line 238
  d += a;
#line 239
  c += (((d ^ a) ^ b) + x[3]) + 3572445317U;
#line 239
  c = (c << 16) | (c >> 16);
#line 239
  c += d;
#line 240
  b += (((c ^ d) ^ a) + x[6]) + 76029189U;
#line 240
  b = (b << 23) | (b >> 9);
#line 240
  b += c;
#line 241
  a += (((b ^ c) ^ d) + x[9]) + 3654602809U;
#line 241
  a = (a << 4) | (a >> 28);
#line 241
  a += b;
#line 242
  d += (((a ^ b) ^ c) + x[12]) + 3873151461U;
#line 242
  d = (d << 11) | (d >> 21);
#line 242
  d += a;
#line 243
  c += (((d ^ a) ^ b) + x[15]) + 530742520U;
#line 243
  c = (c << 16) | (c >> 16);
#line 243
  c += d;
#line 244
  b += (((c ^ d) ^ a) + x[2]) + 3299628645U;
#line 244
  b = (b << 23) | (b >> 9);
#line 244
  b += c;
#line 247
  a += ((c ^ (b | ~ d)) + x[0]) + 4096336452U;
#line 247
  a = (a << 6) | (a >> 26);
#line 247
  a += b;
#line 248
  d += ((b ^ (a | ~ c)) + x[7]) + 1126891415U;
#line 248
  d = (d << 10) | (d >> 22);
#line 248
  d += a;
#line 249
  c += ((a ^ (d | ~ b)) + x[14]) + 2878612391U;
#line 249
  c = (c << 15) | (c >> 17);
#line 249
  c += d;
#line 250
  b += ((d ^ (c | ~ a)) + x[5]) + 4237533241U;
#line 250
  b = (b << 21) | (b >> 11);
#line 250
  b += c;
#line 251
  a += ((c ^ (b | ~ d)) + x[12]) + 1700485571U;
#line 251
  a = (a << 6) | (a >> 26);
#line 251
  a += b;
#line 252
  d += ((b ^ (a | ~ c)) + x[3]) + 2399980690U;
#line 252
  d = (d << 10) | (d >> 22);
#line 252
  d += a;
#line 253
  c += ((a ^ (d | ~ b)) + x[10]) + 4293915773U;
#line 253
  c = (c << 15) | (c >> 17);
#line 253
  c += d;
#line 254
  b += ((d ^ (c | ~ a)) + x[1]) + 2240044497U;
#line 254
  b = (b << 21) | (b >> 11);
#line 254
  b += c;
#line 255
  a += ((c ^ (b | ~ d)) + x[8]) + 1873313359U;
#line 255
  a = (a << 6) | (a >> 26);
#line 255
  a += b;
#line 256
  d += ((b ^ (a | ~ c)) + x[15]) + 4264355552U;
#line 256
  d = (d << 10) | (d >> 22);
#line 256
  d += a;
#line 257
  c += ((a ^ (d | ~ b)) + x[6]) + 2734768916U;
#line 257
  c = (c << 15) | (c >> 17);
#line 257
  c += d;
#line 258
  b += ((d ^ (c | ~ a)) + x[13]) + 1309151649U;
#line 258
  b = (b << 21) | (b >> 11);
#line 258
  b += c;
#line 259
  a += ((c ^ (b | ~ d)) + x[4]) + 4149444226U;
#line 259
  a = (a << 6) | (a >> 26);
#line 259
  a += b;
#line 260
  d += ((b ^ (a | ~ c)) + x[11]) + 3174756917U;
#line 260
  d = (d << 10) | (d >> 22);
#line 260
  d += a;
#line 261
  c += ((a ^ (d | ~ b)) + x[2]) + 718787259U;
#line 261
  c = (c << 15) | (c >> 17);
#line 261
  c += d;
#line 262
  b += ((d ^ (c | ~ a)) + x[9]) + 3951481745U;
#line 262
  b = (b << 21) | (b >> 11);
#line 262
  b += c;
#line 264
  *(state + 0) += a;
#line 265
  *(state + 1) += b;
#line 266
  *(state + 2) += c;
#line 267
  *(state + 3) += d;
#line 271
  MD5_memset((POINTER )(x), 0, sizeof(x));
  }
#line 272
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 281
  i = 0U;
#line 281
  j = 0U;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (j < len)) {
#line 281
      goto while_break;
    }
#line 282
    *(output + j) = (unsigned char )(*(input + i) & 255U);
#line 283
    *(output + (j + 1U)) = (unsigned char )((*(input + i) >> 8) & 255U);
#line 284
    *(output + (j + 2U)) = (unsigned char )((*(input + i) >> 16) & 255U);
#line 285
    *(output + (j + 3U)) = (unsigned char )((*(input + i) >> 24) & 255U);
#line 281
    i ++;
#line 281
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 296
  i = 0U;
#line 296
  j = 0U;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (j < len)) {
#line 296
      goto while_break;
    }
#line 297
    *(output + i) = (((UINT4 )*(input + j) | ((UINT4 )*(input + (j + 1U)) << 8)) | ((UINT4 )*(input + (j + 2U)) << 16)) | ((UINT4 )*(input + (j + 3U)) << 24);
#line 296
    i ++;
#line 296
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5_memcpy(POINTER output , POINTER input , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 308
  i = 0U;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < len)) {
#line 308
      goto while_break;
    }
#line 309
    *(output + i) = *(input + i);
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5_memset(POINTER output , int value___1 , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 318
  i = 0U;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (i < len)) {
#line 318
      goto while_break;
    }
#line 319
    *((char *)output + i) = (char )value___1;
#line 318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 44 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
void output64chunk(int c1 , int c2 , int c3 , int pads , FILE *outfile ) ;
#line 45 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
static char basis_64[65]  = 
#line 45
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 48 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
int to64(FILE *infile , FILE *outfile , long limit ) 
{ 
  int c1 ;
  int c2 ;
  int c3 ;
  int ct ;
  int written ;

  {
#line 50
  ct = 0;
#line 50
  written = 0;
#line 52
  if (limit) {
#line 52
    if (limit < 73L) {
#line 52
      return (1);
    }
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    c1 = _IO_getc(infile);
    }
#line 54
    if (! (c1 != -1)) {
#line 54
      goto while_break;
    }
    {
#line 55
    c2 = _IO_getc(infile);
    }
#line 56
    if (c2 == -1) {
      {
#line 57
      output64chunk(c1, 0, 0, 2, outfile);
      }
    } else {
      {
#line 59
      c3 = _IO_getc(infile);
      }
#line 60
      if (c3 == -1) {
        {
#line 61
        output64chunk(c1, c2, 0, 1, outfile);
        }
      } else {
        {
#line 63
        output64chunk(c1, c2, c3, 0, outfile);
        }
      }
    }
#line 66
    ct += 4;
#line 67
    if (ct > 71) {
      {
#line 68
      _IO_putc('\n', outfile);
      }
#line 69
      if (limit) {
#line 70
        limit -= (long )(ct + 1);
#line 71
        if (limit < 73L) {
#line 71
          return (1);
        }
      }
#line 73
      written += 73;
#line 74
      ct = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (ct) {
    {
#line 78
    _IO_putc('\n', outfile);
#line 79
    ct ++;
    }
  }
#line 81
  return (written + ct);
}
}
#line 84 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
void output64chunk(int c1 , int c2 , int c3 , int pads , FILE *outfile ) 
{ 


  {
  {
#line 86
  _IO_putc((int )basis_64[c1 >> 2], outfile);
#line 87
  _IO_putc((int )basis_64[((c1 & 3) << 4) | ((c2 & 240) >> 4)], outfile);
  }
#line 88
  if (pads == 2) {
    {
#line 89
    _IO_putc('=', outfile);
#line 90
    _IO_putc('=', outfile);
    }
  } else
#line 91
  if (pads) {
    {
#line 92
    _IO_putc((int )basis_64[((c2 & 15) << 2) | ((c3 & 192) >> 6)], outfile);
#line 93
    _IO_putc('=', outfile);
    }
  } else {
    {
#line 95
    _IO_putc((int )basis_64[((c2 & 15) << 2) | ((c3 & 192) >> 6)], outfile);
#line 96
    _IO_putc((int )basis_64[c3 & 63], outfile);
    }
  }
#line 98
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
char *md5contextTo64(MD5_CTX *context ) 
{ 
  unsigned char digest[18] ;
  char encodedDigest[25] ;
  int i ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 107
  MD5Final(digest, context);
#line 108
  digest[sizeof(digest) - 2UL] = (unsigned char)0;
#line 108
  digest[sizeof(digest) - 1UL] = digest[sizeof(digest) - 2UL];
#line 110
  p = encodedDigest;
#line 111
  i = 0;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )i < sizeof(digest))) {
#line 111
      goto while_break;
    }
#line 112
    tmp = p;
#line 112
    p ++;
#line 112
    *tmp = basis_64[(int )digest[i] >> 2];
#line 113
    tmp___0 = p;
#line 113
    p ++;
#line 113
    *tmp___0 = basis_64[(((int )digest[i] & 3) << 4) | (((int )digest[i + 1] & 240) >> 4)];
#line 114
    tmp___1 = p;
#line 114
    p ++;
#line 114
    *tmp___1 = basis_64[(((int )digest[i + 1] & 15) << 2) | (((int )digest[i + 2] & 192) >> 6)];
#line 115
    tmp___2 = p;
#line 115
    p ++;
#line 115
    *tmp___2 = basis_64[(int )digest[i + 2] & 63];
#line 111
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  tmp___3 = p;
#line 117
  p --;
#line 117
  *tmp___3 = (char )'\000';
#line 118
  tmp___4 = p;
#line 118
  p --;
#line 118
  *tmp___4 = (char )'=';
#line 119
  tmp___5 = p;
#line 119
  p --;
#line 119
  *tmp___5 = (char )'=';
#line 120
  tmp___6 = strsave(encodedDigest);
  }
#line 120
  return (tmp___6);
}
}
#line 123 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
char *md5digest(FILE *infile , long *len ) 
{ 
  MD5_CTX context ;
  char buf___1[1000] ;
  long length ;
  int nbytes ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 127
  length = 0L;
#line 130
  MD5Init(& context);
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp = fread((void */* __restrict  */)(buf___1), (size_t )1, sizeof(buf___1), (FILE */* __restrict  */)infile);
#line 131
    nbytes = (int )tmp;
    }
#line 131
    if (! nbytes) {
#line 131
      goto while_break;
    }
    {
#line 132
    length += (long )nbytes;
#line 133
    MD5Update(& context, buf___1, nbytes);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  rewind(infile);
  }
#line 136
  if (len) {
#line 136
    *len = length;
  }
  {
#line 137
  tmp___0 = md5contextTo64(& context);
  }
#line 137
  return (tmp___0);
}
}
#line 39 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
static int pendingboundary(struct part *part ) ;
#line 47 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
static struct part zeropart  ;
#line 45 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
struct part *part_init(FILE *infile ) 
{ 
  struct part *newpart ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 50
  tmp = xmalloc((int )sizeof(struct part ));
#line 50
  newpart = (struct part *)tmp;
#line 51
  *newpart = zeropart;
#line 52
  newpart->infile = infile;
#line 53
  tmp___0 = xmalloc(1024);
#line 53
  newpart->buf = (unsigned char *)tmp___0;
#line 54
  newpart->buf_alloc = 1024;
  }
#line 56
  return (newpart);
}
}
#line 62 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
void part_close(struct part *part ) 
{ 


  {
  {
#line 64
  fclose(part->infile);
  }
#line 65
  if (part->buf) {
    {
#line 65
    free((void *)part->buf);
    }
  }
#line 66
  if (part->boundary) {
    {
#line 66
    free((void *)part->boundary);
    }
  }
#line 67
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
int part_depth(struct part *part ) 
{ 


  {
#line 75
  return (part->boundary_num);
}
}
#line 81 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
void part_addboundary(struct part *part , char *boundary ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 84
  if (part->boundary_num == part->boundary_alloc) {
    {
#line 85
    part->boundary_alloc += 20;
#line 86
    tmp = xrealloc((char *)part->boundary, part->boundary_alloc * 71);
#line 86
    part->boundary = (char (*)[71])tmp;
#line 89
    tmp___0 = xrealloc((char *)part->boundary_length, (int )((unsigned long )part->boundary_alloc * sizeof(int )));
#line 89
    part->boundary_length = (int *)tmp___0;
    }
  }
  {
#line 94
  strncpy((char */* __restrict  */)(*(part->boundary + part->boundary_num)), (char const   */* __restrict  */)boundary,
          (size_t )70);
#line 96
  (*(part->boundary + part->boundary_num))[70] = (char )'\000';
#line 97
  tmp___1 = strlen((char const   *)(*(part->boundary + part->boundary_num)));
#line 97
  *(part->boundary_length + part->boundary_num) = (int )tmp___1;
#line 99
  (part->boundary_num) ++;
  }
#line 100
  if (part->boundary_seen + 1 == part->boundary_num) {
#line 101
    (part->boundary_seen) ++;
  }
#line 103
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
int part_fill(struct part *part ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 115
  (part->cnt) ++;
#line 118
  if (part->boundary_seen < part->boundary_num) {
#line 118
    return (-1);
  }
#line 121
  if (part->cnt == 0) {
    {
#line 122
    part->ptr = part->buf;
#line 123
    tmp = fread((void */* __restrict  */)part->buf, (size_t )1, (size_t )part->buf_alloc,
                (FILE */* __restrict  */)part->infile);
#line 123
    part->cnt = (int )tmp;
    }
#line 124
    if (part->cnt == 0) {
#line 125
      part->boundary_seen = 0;
#line 126
      return (-1);
    }
  }
#line 131
  if ((int )*(part->ptr + 0) == 10) {
    {
#line 131
    tmp___0 = pendingboundary(part);
    }
#line 131
    if (tmp___0) {
#line 132
      return (-1);
    }
  }
#line 135
  (part->cnt) --;
#line 136
  tmp___1 = part->ptr;
#line 136
  (part->ptr) ++;
#line 136
  return ((int )*tmp___1);
}
}
#line 146 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
char *part_gets(char *s , int n , struct part *part ) 
{ 
  int c ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 150
  p = s;
#line 152
  if (n == 0) {
#line 152
    return ((char *)0);
  }
#line 153
  n --;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    tmp___0 = n;
#line 154
    n --;
#line 154
    if (tmp___0) {
#line 154
      tmp___4 = part->cnt;
#line 154
      (part->cnt) --;
#line 154
      if (tmp___4 > 0) {
#line 154
        if ((int )*(part->ptr + 0) != 10) {
#line 154
          tmp___2 = part->ptr;
#line 154
          (part->ptr) ++;
#line 154
          c = (int )*tmp___2;
        } else {
          {
#line 154
          tmp___3 = part_fill(part);
#line 154
          c = tmp___3;
          }
        }
      } else {
        {
#line 154
        tmp___3 = part_fill(part);
#line 154
        c = tmp___3;
        }
      }
#line 154
      if (! (c != -1)) {
#line 154
        goto while_break;
      }
    } else {
#line 154
      goto while_break;
    }
#line 155
    tmp = p;
#line 155
    p ++;
#line 155
    *tmp = (char )c;
#line 156
    if (c == 10) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if ((unsigned long )p == (unsigned long )s) {
#line 158
    return ((char *)0);
  }
#line 159
  tmp___5 = p;
#line 159
  p ++;
#line 159
  *tmp___5 = (char )'\000';
#line 160
  return (s);
}
}
#line 168 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
void part_ungets(char *s , struct part *part ) 
{ 
  int len ;
  size_t tmp ;
  int i ;
  char *tmp___0 ;

  {
  {
#line 170
  tmp = strlen((char const   *)s);
#line 170
  len = (int )tmp;
  }
#line 174
  if ((part->cnt + len) + 1 > part->buf_alloc) {
    {
#line 175
    i = (int )(part->ptr - part->buf);
#line 176
    part->buf_alloc = (part->cnt + len) + 1;
#line 177
    tmp___0 = xrealloc((char *)part->buf, part->buf_alloc);
#line 177
    part->buf = (unsigned char *)tmp___0;
#line 179
    part->ptr = part->buf + i;
    }
  }
#line 183
  if ((long )(len + 1) > part->ptr - part->buf) {
#line 184
    i = part->cnt - 1;
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 184
      if (! (i >= 0)) {
#line 184
        goto while_break;
      }
#line 185
      *(part->buf + ((len + 1) + i)) = *(part->ptr + i);
#line 184
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 187
    part->ptr = (part->buf + len) + 1;
  }
#line 191
  part->ptr -= len;
#line 192
  part->cnt += len;
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    if (! (i < len)) {
#line 193
      goto while_break___0;
    }
#line 194
    *(part->ptr + i) = (unsigned char )*(s + i);
#line 193
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
int part_readboundary(struct part *part ) 
{ 
  int c ;
  int sawfinal ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 207
  sawfinal = 0;
#line 209
  if (part->boundary_seen < part->boundary_num - 1) {
#line 213
    (part->boundary_num) --;
#line 214
    return (1);
  }
#line 218
  if (part->cnt == 0) {
#line 218
    return (1);
  }
#line 221
  part->ptr += *(part->boundary_length + part->boundary_seen) + 3;
#line 222
  part->cnt -= *(part->boundary_length + part->boundary_seen) + 3;
#line 223
  part->boundary_seen = part->boundary_num;
#line 226
  tmp___2 = part->cnt;
#line 226
  (part->cnt) --;
#line 226
  if (tmp___2 > 0) {
#line 226
    if ((int )*(part->ptr + 0) != 10) {
#line 226
      tmp___0 = part->ptr;
#line 226
      (part->ptr) ++;
#line 226
      c = (int )*tmp___0;
    } else {
      {
#line 226
      tmp___1 = part_fill(part);
#line 226
      c = tmp___1;
      }
    }
  } else {
    {
#line 226
    tmp___1 = part_fill(part);
#line 226
    c = tmp___1;
    }
  }
#line 227
  if (c == 45) {
#line 228
    tmp___6 = part->cnt;
#line 228
    (part->cnt) --;
#line 228
    if (tmp___6 > 0) {
#line 228
      if ((int )*(part->ptr + 0) != 10) {
#line 228
        tmp___4 = part->ptr;
#line 228
        (part->ptr) ++;
#line 228
        c = (int )*tmp___4;
      } else {
        {
#line 228
        tmp___5 = part_fill(part);
#line 228
        c = tmp___5;
        }
      }
    } else {
      {
#line 228
      tmp___5 = part_fill(part);
#line 228
      c = tmp___5;
      }
    }
#line 229
    if (c == 45) {
#line 230
      sawfinal = 1;
#line 231
      (part->boundary_num) --;
    }
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (c != 10) {
#line 236
      if (! (c != -1)) {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
#line 237
    tmp___10 = part->cnt;
#line 237
    (part->cnt) --;
#line 237
    if (tmp___10 > 0) {
#line 237
      if ((int )*(part->ptr + 0) != 10) {
#line 237
        tmp___8 = part->ptr;
#line 237
        (part->ptr) ++;
#line 237
        c = (int )*tmp___8;
      } else {
        {
#line 237
        tmp___9 = part_fill(part);
#line 237
        c = tmp___9;
        }
      }
    } else {
      {
#line 237
      tmp___9 = part_fill(part);
#line 237
      c = tmp___9;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (sawfinal);
}
}
#line 248 "/home/wheatley/newnew/temp/mpack-1.6/part.c"
static int pendingboundary(struct part *part ) 
{ 
  int bufleft ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 255
  if (part->cnt < 3) {
#line 255
    goto _L;
  } else
#line 255
  if (part->cnt < 73) {
#line 255
    if ((int )*(part->ptr + 1) == 45) {
#line 255
      if ((int )*(part->ptr + 2) == 45) {
        _L: /* CIL Label */ 
#line 259
        bufleft = (int )((long )(part->buf_alloc - part->cnt) - (part->ptr - part->buf));
#line 262
        if ((unsigned long )part->ptr != (unsigned long )part->buf) {
#line 262
          if (bufleft + part->cnt < 73) {
#line 263
            i = 0;
            {
#line 263
            while (1) {
              while_continue: /* CIL Label */ ;
#line 263
              if (! (i < part->cnt)) {
#line 263
                goto while_break;
              }
#line 264
              *(part->buf + i) = *(part->ptr + i);
#line 263
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
#line 266
            part->ptr = part->buf;
#line 267
            bufleft = part->buf_alloc - part->cnt;
          }
        }
        {
#line 271
        tmp = fread((void */* __restrict  */)(part->ptr + part->cnt), (size_t )1,
                    (size_t )bufleft, (FILE */* __restrict  */)part->infile);
#line 271
        part->cnt = (int )((size_t )part->cnt + tmp);
        }
      }
    }
  }
#line 275
  if (part->cnt < 3) {
#line 276
    return (0);
  } else
#line 275
  if ((int )*(part->ptr + 1) != 45) {
#line 276
    return (0);
  } else
#line 275
  if ((int )*(part->ptr + 2) != 45) {
#line 276
    return (0);
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 279
    if (! (i < part->boundary_num)) {
#line 279
      goto while_break___0;
    }
#line 280
    if (part->cnt - 3 >= *(part->boundary_length + i)) {
      {
#line 280
      tmp___0 = strncmp((char const   *)((char *)part->ptr + 3), (char const   *)(*(part->boundary + i)),
                        (size_t )*(part->boundary_length + i));
      }
#line 280
      if (! tmp___0) {
#line 283
        goto while_break___0;
      }
    }
#line 279
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 287
  if (i == part->boundary_num) {
#line 287
    return (0);
  }
#line 290
  part->boundary_seen = i;
#line 291
  return (1);
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 29 "/home/wheatley/newnew/temp/mpack-1.6/encode.c"
char *magic_look(FILE *infile ) ;
#line 37 "/home/wheatley/newnew/temp/mpack-1.6/encode.c"
int attachment  ;
#line 45 "/home/wheatley/newnew/temp/mpack-1.6/encode.c"
int encode(FILE *infile , FILE *applefile , char *fname , FILE *descfile , char *subject ,
           char *headers___0 , long maxsize , char *typeoverride , char *outfname ) 
{ 
  char *type ;
  FILE *outfile ;
  char *cleanfname ;
  char *p ;
  char *digest ;
  char *appledigest ;
  long filesize ;
  long l ;
  long written ;
  int thispart ;
  int numparts ;
  int wrotefiletype ;
  char *multipartid ;
  char *msgid ;
  char *referenceid[4] ;
  char buf___1[1024] ;
  int i ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;

  {
  {
#line 50
  appledigest = (char *)((void *)0);
#line 52
  numparts = 1;
#line 53
  wrotefiletype = 0;
#line 59
  cleanfname = fname;
#line 66
  p = strrchr((char const   *)cleanfname, '/');
  }
#line 66
  if (p) {
#line 66
    cleanfname = p + 1;
  }
  {
#line 67
  p = strrchr((char const   *)cleanfname, '\\');
  }
#line 67
  if (p) {
#line 67
    cleanfname = p + 1;
  }
  {
#line 69
  p = strrchr((char const   *)cleanfname, ':');
  }
#line 69
  if (p) {
#line 69
    cleanfname = p + 1;
  }
#line 72
  if (typeoverride) {
#line 73
    type = typeoverride;
  } else {
    {
#line 76
    type = magic_look(infile);
    }
  }
  {
#line 80
  digest = md5digest(infile, & filesize);
  }
#line 81
  if (applefile) {
    {
#line 82
    appledigest = md5digest(applefile, & l);
#line 83
    filesize += l;
    }
  }
#line 87
  if (maxsize) {
#line 88
    filesize = (filesize / 54L) * 73L;
#line 91
    if (descfile) {
      {
#line 92
      tmp = md5digest(descfile, & l);
#line 92
      free((void *)tmp);
#line 93
      filesize += l;
      }
    }
#line 96
    numparts = (int )((filesize - 1000L) / maxsize + 1L);
#line 97
    if (numparts < 1) {
#line 97
      numparts = 1;
    }
  }
  {
#line 100
  multipartid = os_genid();
#line 101
  i = 0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < 4)) {
#line 101
      goto while_break;
    }
#line 102
    referenceid[i] = (char *)0;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  thispart = 1;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (thispart <= numparts)) {
#line 105
      goto while_break___0;
    }
#line 106
    written = 0L;
#line 109
    if (numparts == 1) {
      {
#line 110
      outfile = os_createnewfile(outfname);
      }
    } else {
      {
#line 117
      sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s.%02d",
              outfname, thispart);
#line 119
      outfile = os_createnewfile(buf___1);
      }
    }
#line 121
    if (! outfile) {
      {
#line 122
      os_perror(buf___1);
      }
#line 123
      return (1);
    }
    {
#line 126
    msgid = os_genid();
#line 127
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Message-ID: <%s>\n",
            msgid);
#line 128
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Mime-Version: 1.0\n");
    }
#line 129
    if (headers___0) {
      {
#line 129
      fputs((char const   */* __restrict  */)headers___0, (FILE */* __restrict  */)outfile);
      }
    }
#line 130
    if (numparts > 1) {
      {
#line 131
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Subject: %s (%02d/%02d)\n",
              subject, thispart, numparts);
      }
#line 133
      if (thispart == 1) {
#line 134
        referenceid[0] = msgid;
      } else {
        {
#line 138
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"References: <%s>\n",
                referenceid[0]);
#line 139
        i = 1;
        }
        {
#line 139
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 139
          if (! (i < 4)) {
#line 139
            goto while_break___1;
          }
#line 140
          if (referenceid[i]) {
            {
#line 140
            fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\t <%s>\n",
                    referenceid[i]);
            }
          }
#line 139
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 143
        i = 2;
        {
#line 143
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 143
          if (! (i < 4)) {
#line 143
            goto while_break___2;
          }
#line 144
          referenceid[i - 1] = referenceid[i];
#line 143
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 146
        referenceid[3] = msgid;
      }
      {
#line 148
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Type: message/partial; number=%d; total=%d;\n",
              thispart, numparts);
#line 151
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\t id=\"%s\"\n",
              multipartid);
#line 152
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n");
      }
    }
#line 155
    if (thispart == 1) {
#line 156
      if (numparts > 1) {
        {
#line 157
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Message-ID: <%s>\n",
                multipartid);
#line 158
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"MIME-Version: 1.0\n");
        }
      }
      {
#line 160
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Subject: %s\n",
              subject);
#line 161
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Type: multipart/mixed; boundary=\"-\"\n");
#line 163
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\nThis is a MIME encoded message.  Decode it with \"munpack\"\n");
#line 165
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"or any other MIME reading software.  Mpack/munpack is available\n");
#line 167
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"via anonymous FTP in ftp.andrew.cmu.edu:pub/mpack/\n");
#line 169
      written = 300L;
      }
#line 172
      if (descfile) {
        {
#line 173
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"---\n\n");
        }
        {
#line 174
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 174
          tmp___1 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1),
                          (FILE */* __restrict  */)descfile);
          }
#line 174
          if (! tmp___1) {
#line 174
            goto while_break___3;
          }
#line 178
          p = buf___1;
#line 179
          if ((int )*p == 45) {
            {
#line 180
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 180
              if (! ((int )*(p + 1) == 45)) {
#line 180
                goto while_break___4;
              }
#line 180
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 183
          fputs((char const   */* __restrict  */)p, (FILE */* __restrict  */)outfile);
#line 184
          tmp___0 = strlen((char const   *)p);
#line 184
          written = (long )((size_t )written + tmp___0);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 186
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 189
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"---\n");
      }
#line 191
      if (applefile) {
        {
#line 192
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Type: multipart/appledouble; boundary=\"=\"; name=\"%s\"\n",
                cleanfname);
        }
#line 195
        if (attachment) {
#line 195
          tmp___2 = "attachment";
        } else {
#line 195
          tmp___2 = "inline";
        }
        {
#line 195
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Disposition: %s; filename=\"%s\"\n",
                tmp___2, cleanfname);
#line 198
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n\n--=\n");
#line 199
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Type: application/applefile\n");
#line 200
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Transfer-Encoding: base64\n");
#line 201
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-MD5: %s\n\n",
                appledigest);
#line 202
        free((void *)appledigest);
#line 203
        written += 100L;
        }
      }
    }
#line 208
    if (applefile) {
      {
#line 208
      tmp___6 = feof(applefile);
      }
#line 208
      if (! tmp___6) {
#line 209
        if (written == maxsize) {
#line 209
          written --;
        }
#line 210
        if (thispart == numparts) {
#line 210
          tmp___3 = 0L;
        } else {
#line 210
          tmp___3 = maxsize - written;
        }
        {
#line 210
        tmp___4 = to64(applefile, outfile, tmp___3);
#line 210
        written += (long )tmp___4;
#line 213
        tmp___5 = feof(applefile);
        }
#line 213
        if (! tmp___5) {
          {
#line 214
          fclose(outfile);
          }
#line 215
          goto __Cont;
        }
        {
#line 218
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n--=\n");
        }
      }
    }
#line 222
    tmp___8 = wrotefiletype;
#line 222
    wrotefiletype ++;
#line 222
    if (! tmp___8) {
      {
#line 223
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Type: %s; name=\"%s\"\n",
              type, cleanfname);
#line 225
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Transfer-Encoding: base64\n");
      }
#line 226
      if (attachment) {
#line 226
        tmp___7 = "attachment";
      } else {
#line 226
        tmp___7 = "inline";
      }
      {
#line 226
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-Disposition: %s; filename=\"%s\"\n",
              tmp___7, cleanfname);
#line 228
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"Content-MD5: %s\n\n",
              digest);
#line 229
      free((void *)digest);
#line 230
      written += 80L;
      }
    }
#line 233
    if (written == maxsize) {
#line 233
      written --;
    }
#line 235
    if (thispart == numparts) {
#line 235
      tmp___9 = 0L;
    } else {
#line 235
      tmp___9 = maxsize - written;
    }
    {
#line 235
    tmp___10 = to64(infile, outfile, tmp___9);
#line 235
    written += (long )tmp___10;
    }
#line 238
    if (thispart == numparts) {
#line 239
      if (applefile) {
        {
#line 239
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n--=--\n");
        }
      }
      {
#line 240
      fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"\n-----\n");
      }
    }
    {
#line 243
    fclose(outfile);
    }
    __Cont: /* CIL Label */ 
#line 105
    thispart ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 246
  return (0);
}
}
#line 36 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
static struct magic magic[4]  = {      {(char *)"image/gif", (char *)"GIF", 0}, 
        {(char *)"image/jpeg", (char *)"\377\330\377", 0}, 
        {(char *)"video/mpeg", (char *)"\000\000\001\263", 4}, 
        {(char *)"application/postscript", (char *)"%!", 0}};
#line 42 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
static int num_magic  =    (int )(sizeof(magic) / sizeof(magic[0]));
#line 43 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
static char *default_type  =    (char *)"application/octet-stream";
#line 46 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
static int max_magiclen  =    0;
#line 52 "/home/wheatley/newnew/temp/mpack-1.6/magic.c"
char *magic_look(FILE *infile ) 
{ 
  int i ;
  int j ;
  char buf___1[80] ;
  int numread ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 56
  numread = 0;
#line 58
  if (max_magiclen == 0) {
#line 59
    i = 0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! (i < num_magic)) {
#line 59
        goto while_break;
      }
#line 60
      if (magic[i].len == 0) {
        {
#line 60
        tmp = strlen((char const   *)magic[i].num);
#line 60
        magic[i].len = (int )tmp;
        }
      }
#line 61
      if (magic[i].len > max_magiclen) {
#line 61
        max_magiclen = magic[i].len;
      }
#line 59
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 65
  tmp___0 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )max_magiclen,
                  (FILE */* __restrict  */)infile);
#line 65
  numread = (int )tmp___0;
#line 66
  rewind(infile);
#line 68
  i = 0;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i < num_magic)) {
#line 68
      goto while_break___0;
    }
#line 69
    if (numread >= magic[i].len) {
#line 70
      j = 0;
      {
#line 70
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 70
        if (! (j < magic[i].len)) {
#line 70
          goto while_break___1;
        }
#line 71
        if ((int )buf___1[j] != (int )*(magic[i].num + j)) {
#line 71
          goto while_break___1;
        }
#line 70
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 73
      if (j == magic[i].len) {
#line 73
        return (magic[i].name);
      }
    }
#line 68
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 77
  return (default_type);
}
}
#line 45 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
static char basis_64___0[65]  = 
#line 45 "/home/wheatley/newnew/temp/mpack-1.6/codes.c"
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 42 "/home/wheatley/newnew/temp/mpack-1.6/unixpk.c"
void sendmail(FILE *infile , char **addr , int start ) ;
#line 43
void inews(FILE *infile ) ;
#line 234 "/home/wheatley/newnew/temp/mpack-1.6/unixpk.c"
void sendmail(FILE *infile , char **addr , int start ) 
{ 
  int status ;
  int pid___1 ;
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
#line 239
  if (start < 2) {
    {
#line 239
    abort();
    }
  }
#line 244
  start --;
#line 244
  *(addr + start) = (char *)"-oi";
#line 245
  start --;
#line 245
  *(addr + start) = (char *)"sendmail";
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    pid___1 = fork();
    }
#line 248
    if (pid___1 == -1) {
      {
#line 248
      tmp = __errno_location();
      }
#line 248
      if (! (*tmp == 11)) {
#line 248
        goto while_break;
      }
    } else {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (pid___1 == -1) {
    {
#line 253
    perror("fork");
    }
#line 254
    return;
  }
#line 256
  if (pid___1 != 0) {
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 257
      tmp___0 = wait((union wait *)(& status));
      }
#line 257
      if (! (pid___1 != tmp___0)) {
#line 257
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    return;
  }
  {
#line 261
  tmp___1 = fileno(infile);
#line 261
  dup2(tmp___1, 0);
#line 262
  fclose(infile);
#line 266
  execv("/usr/lib/sendmail", (char * const  *)(addr + start));
#line 267
  execv("/usr/sbin/sendmail", (char * const  *)(addr + start));
#line 269
  perror("execv");
#line 270
  _exit(1);
  }
}
}
#line 273 "/home/wheatley/newnew/temp/mpack-1.6/unixpk.c"
void inews(FILE *infile ) 
{ 
  int status ;
  int pid___1 ;
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    pid___1 = fork();
    }
#line 278
    if (pid___1 == -1) {
      {
#line 278
      tmp = __errno_location();
      }
#line 278
      if (! (*tmp == 11)) {
#line 278
        goto while_break;
      }
    } else {
#line 278
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if (pid___1 == -1) {
    {
#line 283
    perror("fork");
    }
#line 284
    return;
  }
#line 286
  if (pid___1 != 0) {
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 287
      tmp___0 = wait((union wait *)(& status));
      }
#line 287
      if (! (pid___1 != tmp___0)) {
#line 287
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 288
    return;
  }
  {
#line 291
  tmp___1 = fileno(infile);
#line 291
  dup2(tmp___1, 0);
#line 292
  fclose(infile);
#line 293
  execlp("inews", "inews", "-h", "-S", (char *)0);
#line 294
  execl("/usr/local/news/inews", "inews", "-h", "-S", (char *)0);
#line 295
  execl("/usr/local/lib/news/inews", "inews", "-h", "-S", (char *)0);
#line 296
  execl("/etc/inews", "inews", "-h", "-S", (char *)0);
#line 297
  execl("/usr/etc/inews", "inews", "-h", "-S", (char *)0);
#line 298
  execl("/usr/news/inews", "inews", "-h", "-S", (char *)0);
#line 299
  execl("/usr/news/bin/inews", "inews", "-h", "-S", (char *)0);
#line 300
  perror("execl");
#line 301
  _exit(1);
  }
}
}
#line 41 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
extern void warn(char *s ) ;
#line 55 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char *output_fname___0  =    (char *)0;
#line 63 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static int pid___0  =    0;
#line 64 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static time_t curtime___0  ;
#line 65 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char hostname___0[65]  ;
#line 92 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static char buf___0[4096]  ;
#line 176 "/home/wheatley/newnew/temp/mpack-1.6/unixos.c"
static int filesuffix___0  =    0;
#line 48 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5Transform___0(UINT4 *state , unsigned char *block ) ;
#line 49
static void Encode___0(unsigned char *output , UINT4 *input , unsigned int len ) ;
#line 51
static void Decode___0(UINT4 *output , unsigned char *input , unsigned int len ) ;
#line 53
static void MD5_memcpy___0(POINTER output , POINTER input , unsigned int len ) ;
#line 54
static void MD5_memset___0(POINTER output , int value___1 , unsigned int len ) ;
#line 56 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static unsigned char PADDING___0[64]  = 
#line 56
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 186 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5Transform___0(UINT4 *state , unsigned char *block ) 
{ 
  UINT4 a ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d ;
  UINT4 x[16] ;

  {
  {
#line 188
  a = *(state + 0);
#line 188
  b = *(state + 1);
#line 188
  c = *(state + 2);
#line 188
  d = *(state + 3);
#line 190
  Decode___0(x, block, 64);
#line 193
  a += (((b & c) | (~ b & d)) + x[0]) + 3614090360U;
#line 193
  a = (a << 7) | (a >> 25);
#line 193
  a += b;
#line 194
  d += (((a & b) | (~ a & c)) + x[1]) + 3905402710U;
#line 194
  d = (d << 12) | (d >> 20);
#line 194
  d += a;
#line 195
  c += (((d & a) | (~ d & b)) + x[2]) + 606105819U;
#line 195
  c = (c << 17) | (c >> 15);
#line 195
  c += d;
#line 196
  b += (((c & d) | (~ c & a)) + x[3]) + 3250441966U;
#line 196
  b = (b << 22) | (b >> 10);
#line 196
  b += c;
#line 197
  a += (((b & c) | (~ b & d)) + x[4]) + 4118548399U;
#line 197
  a = (a << 7) | (a >> 25);
#line 197
  a += b;
#line 198
  d += (((a & b) | (~ a & c)) + x[5]) + 1200080426U;
#line 198
  d = (d << 12) | (d >> 20);
#line 198
  d += a;
#line 199
  c += (((d & a) | (~ d & b)) + x[6]) + 2821735955U;
#line 199
  c = (c << 17) | (c >> 15);
#line 199
  c += d;
#line 200
  b += (((c & d) | (~ c & a)) + x[7]) + 4249261313U;
#line 200
  b = (b << 22) | (b >> 10);
#line 200
  b += c;
#line 201
  a += (((b & c) | (~ b & d)) + x[8]) + 1770035416U;
#line 201
  a = (a << 7) | (a >> 25);
#line 201
  a += b;
#line 202
  d += (((a & b) | (~ a & c)) + x[9]) + 2336552879U;
#line 202
  d = (d << 12) | (d >> 20);
#line 202
  d += a;
#line 203
  c += (((d & a) | (~ d & b)) + x[10]) + 4294925233U;
#line 203
  c = (c << 17) | (c >> 15);
#line 203
  c += d;
#line 204
  b += (((c & d) | (~ c & a)) + x[11]) + 2304563134U;
#line 204
  b = (b << 22) | (b >> 10);
#line 204
  b += c;
#line 205
  a += (((b & c) | (~ b & d)) + x[12]) + 1804603682U;
#line 205
  a = (a << 7) | (a >> 25);
#line 205
  a += b;
#line 206
  d += (((a & b) | (~ a & c)) + x[13]) + 4254626195U;
#line 206
  d = (d << 12) | (d >> 20);
#line 206
  d += a;
#line 207
  c += (((d & a) | (~ d & b)) + x[14]) + 2792965006U;
#line 207
  c = (c << 17) | (c >> 15);
#line 207
  c += d;
#line 208
  b += (((c & d) | (~ c & a)) + x[15]) + 1236535329U;
#line 208
  b = (b << 22) | (b >> 10);
#line 208
  b += c;
#line 211
  a += (((b & d) | (c & ~ d)) + x[1]) + 4129170786U;
#line 211
  a = (a << 5) | (a >> 27);
#line 211
  a += b;
#line 212
  d += (((a & c) | (b & ~ c)) + x[6]) + 3225465664U;
#line 212
  d = (d << 9) | (d >> 23);
#line 212
  d += a;
#line 213
  c += (((d & b) | (a & ~ b)) + x[11]) + 643717713U;
#line 213
  c = (c << 14) | (c >> 18);
#line 213
  c += d;
#line 214
  b += (((c & a) | (d & ~ a)) + x[0]) + 3921069994U;
#line 214
  b = (b << 20) | (b >> 12);
#line 214
  b += c;
#line 215
  a += (((b & d) | (c & ~ d)) + x[5]) + 3593408605U;
#line 215
  a = (a << 5) | (a >> 27);
#line 215
  a += b;
#line 216
  d += (((a & c) | (b & ~ c)) + x[10]) + 38016083U;
#line 216
  d = (d << 9) | (d >> 23);
#line 216
  d += a;
#line 217
  c += (((d & b) | (a & ~ b)) + x[15]) + 3634488961U;
#line 217
  c = (c << 14) | (c >> 18);
#line 217
  c += d;
#line 218
  b += (((c & a) | (d & ~ a)) + x[4]) + 3889429448U;
#line 218
  b = (b << 20) | (b >> 12);
#line 218
  b += c;
#line 219
  a += (((b & d) | (c & ~ d)) + x[9]) + 568446438U;
#line 219
  a = (a << 5) | (a >> 27);
#line 219
  a += b;
#line 220
  d += (((a & c) | (b & ~ c)) + x[14]) + 3275163606U;
#line 220
  d = (d << 9) | (d >> 23);
#line 220
  d += a;
#line 221
  c += (((d & b) | (a & ~ b)) + x[3]) + 4107603335U;
#line 221
  c = (c << 14) | (c >> 18);
#line 221
  c += d;
#line 222
  b += (((c & a) | (d & ~ a)) + x[8]) + 1163531501U;
#line 222
  b = (b << 20) | (b >> 12);
#line 222
  b += c;
#line 223
  a += (((b & d) | (c & ~ d)) + x[13]) + 2850285829U;
#line 223
  a = (a << 5) | (a >> 27);
#line 223
  a += b;
#line 224
  d += (((a & c) | (b & ~ c)) + x[2]) + 4243563512U;
#line 224
  d = (d << 9) | (d >> 23);
#line 224
  d += a;
#line 225
  c += (((d & b) | (a & ~ b)) + x[7]) + 1735328473U;
#line 225
  c = (c << 14) | (c >> 18);
#line 225
  c += d;
#line 226
  b += (((c & a) | (d & ~ a)) + x[12]) + 2368359562U;
#line 226
  b = (b << 20) | (b >> 12);
#line 226
  b += c;
#line 229
  a += (((b ^ c) ^ d) + x[5]) + 4294588738U;
#line 229
  a = (a << 4) | (a >> 28);
#line 229
  a += b;
#line 230
  d += (((a ^ b) ^ c) + x[8]) + 2272392833U;
#line 230
  d = (d << 11) | (d >> 21);
#line 230
  d += a;
#line 231
  c += (((d ^ a) ^ b) + x[11]) + 1839030562U;
#line 231
  c = (c << 16) | (c >> 16);
#line 231
  c += d;
#line 232
  b += (((c ^ d) ^ a) + x[14]) + 4259657740U;
#line 232
  b = (b << 23) | (b >> 9);
#line 232
  b += c;
#line 233
  a += (((b ^ c) ^ d) + x[1]) + 2763975236U;
#line 233
  a = (a << 4) | (a >> 28);
#line 233
  a += b;
#line 234
  d += (((a ^ b) ^ c) + x[4]) + 1272893353U;
#line 234
  d = (d << 11) | (d >> 21);
#line 234
  d += a;
#line 235
  c += (((d ^ a) ^ b) + x[7]) + 4139469664U;
#line 235
  c = (c << 16) | (c >> 16);
#line 235
  c += d;
#line 236
  b += (((c ^ d) ^ a) + x[10]) + 3200236656U;
#line 236
  b = (b << 23) | (b >> 9);
#line 236
  b += c;
#line 237
  a += (((b ^ c) ^ d) + x[13]) + 681279174U;
#line 237
  a = (a << 4) | (a >> 28);
#line 237
  a += b;
#line 238
  d += (((a ^ b) ^ c) + x[0]) + 3936430074U;
#line 238
  d = (d << 11) | (d >> 21);
#line 238
  d += a;
#line 239
  c += (((d ^ a) ^ b) + x[3]) + 3572445317U;
#line 239
  c = (c << 16) | (c >> 16);
#line 239
  c += d;
#line 240
  b += (((c ^ d) ^ a) + x[6]) + 76029189U;
#line 240
  b = (b << 23) | (b >> 9);
#line 240
  b += c;
#line 241
  a += (((b ^ c) ^ d) + x[9]) + 3654602809U;
#line 241
  a = (a << 4) | (a >> 28);
#line 241
  a += b;
#line 242
  d += (((a ^ b) ^ c) + x[12]) + 3873151461U;
#line 242
  d = (d << 11) | (d >> 21);
#line 242
  d += a;
#line 243
  c += (((d ^ a) ^ b) + x[15]) + 530742520U;
#line 243
  c = (c << 16) | (c >> 16);
#line 243
  c += d;
#line 244
  b += (((c ^ d) ^ a) + x[2]) + 3299628645U;
#line 244
  b = (b << 23) | (b >> 9);
#line 244
  b += c;
#line 247
  a += ((c ^ (b | ~ d)) + x[0]) + 4096336452U;
#line 247
  a = (a << 6) | (a >> 26);
#line 247
  a += b;
#line 248
  d += ((b ^ (a | ~ c)) + x[7]) + 1126891415U;
#line 248
  d = (d << 10) | (d >> 22);
#line 248
  d += a;
#line 249
  c += ((a ^ (d | ~ b)) + x[14]) + 2878612391U;
#line 249
  c = (c << 15) | (c >> 17);
#line 249
  c += d;
#line 250
  b += ((d ^ (c | ~ a)) + x[5]) + 4237533241U;
#line 250
  b = (b << 21) | (b >> 11);
#line 250
  b += c;
#line 251
  a += ((c ^ (b | ~ d)) + x[12]) + 1700485571U;
#line 251
  a = (a << 6) | (a >> 26);
#line 251
  a += b;
#line 252
  d += ((b ^ (a | ~ c)) + x[3]) + 2399980690U;
#line 252
  d = (d << 10) | (d >> 22);
#line 252
  d += a;
#line 253
  c += ((a ^ (d | ~ b)) + x[10]) + 4293915773U;
#line 253
  c = (c << 15) | (c >> 17);
#line 253
  c += d;
#line 254
  b += ((d ^ (c | ~ a)) + x[1]) + 2240044497U;
#line 254
  b = (b << 21) | (b >> 11);
#line 254
  b += c;
#line 255
  a += ((c ^ (b | ~ d)) + x[8]) + 1873313359U;
#line 255
  a = (a << 6) | (a >> 26);
#line 255
  a += b;
#line 256
  d += ((b ^ (a | ~ c)) + x[15]) + 4264355552U;
#line 256
  d = (d << 10) | (d >> 22);
#line 256
  d += a;
#line 257
  c += ((a ^ (d | ~ b)) + x[6]) + 2734768916U;
#line 257
  c = (c << 15) | (c >> 17);
#line 257
  c += d;
#line 258
  b += ((d ^ (c | ~ a)) + x[13]) + 1309151649U;
#line 258
  b = (b << 21) | (b >> 11);
#line 258
  b += c;
#line 259
  a += ((c ^ (b | ~ d)) + x[4]) + 4149444226U;
#line 259
  a = (a << 6) | (a >> 26);
#line 259
  a += b;
#line 260
  d += ((b ^ (a | ~ c)) + x[11]) + 3174756917U;
#line 260
  d = (d << 10) | (d >> 22);
#line 260
  d += a;
#line 261
  c += ((a ^ (d | ~ b)) + x[2]) + 718787259U;
#line 261
  c = (c << 15) | (c >> 17);
#line 261
  c += d;
#line 262
  b += ((d ^ (c | ~ a)) + x[9]) + 3951481745U;
#line 262
  b = (b << 21) | (b >> 11);
#line 262
  b += c;
#line 264
  *(state + 0) += a;
#line 265
  *(state + 1) += b;
#line 266
  *(state + 2) += c;
#line 267
  *(state + 3) += d;
#line 271
  MD5_memset___0((POINTER )(x), 0, sizeof(x));
  }
#line 272
  return;
}
}
#line 277 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void Encode___0(unsigned char *output , UINT4 *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 281
  i = 0U;
#line 281
  j = 0U;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (j < len)) {
#line 281
      goto while_break;
    }
#line 282
    *(output + j) = (unsigned char )(*(input + i) & 255U);
#line 283
    *(output + (j + 1U)) = (unsigned char )((*(input + i) >> 8) & 255U);
#line 284
    *(output + (j + 2U)) = (unsigned char )((*(input + i) >> 16) & 255U);
#line 285
    *(output + (j + 3U)) = (unsigned char )((*(input + i) >> 24) & 255U);
#line 281
    i ++;
#line 281
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void Decode___0(UINT4 *output , unsigned char *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 296
  i = 0U;
#line 296
  j = 0U;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (j < len)) {
#line 296
      goto while_break;
    }
#line 297
    *(output + i) = (((UINT4 )*(input + j) | ((UINT4 )*(input + (j + 1U)) << 8)) | ((UINT4 )*(input + (j + 2U)) << 16)) | ((UINT4 )*(input + (j + 3U)) << 24);
#line 296
    i ++;
#line 296
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5_memcpy___0(POINTER output , POINTER input , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 308
  i = 0U;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < len)) {
#line 308
      goto while_break;
    }
#line 309
    *(output + i) = *(input + i);
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/mpack-1.6/md5c.c"
static void MD5_memset___0(POINTER output , int value___1 , unsigned int len ) 
{ 
  unsigned int i ;

  {
#line 318
  i = 0U;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (i < len)) {
#line 318
      goto while_break;
    }
#line 319
    *((char *)output + i) = (char )value___1;
#line 318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
