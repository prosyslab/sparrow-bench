/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 27 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 49 "/usr/include/linux/usbdevice_fs.h"
struct usbdevfs_bulktransfer {
   unsigned int ep ;
   unsigned int len ;
   unsigned int timeout ;
   void *data ;
};
#line 258 "/usr/include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 314 "/usr/include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
#line 351 "/usr/include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
#line 369 "/usr/include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
#line 32 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb.h"
struct usb_handle;
#line 32 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb.h"
typedef struct usb_handle usb_handle;
#line 34
struct usb_ifc_info;
#line 34 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb.h"
typedef struct usb_ifc_info usb_ifc_info;
#line 36 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb.h"
struct usb_ifc_info {
   unsigned short dev_vendor ;
   unsigned short dev_product ;
   unsigned char dev_class ;
   unsigned char dev_subclass ;
   unsigned char dev_protocol ;
   unsigned char ifc_class ;
   unsigned char ifc_subclass ;
   unsigned char ifc_protocol ;
   unsigned char has_bulk_in ;
   unsigned char has_bulk_out ;
   unsigned char writable ;
   char serial_number[256] ;
};
#line 58 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
struct usb_handle {
   char fname[64] ;
   int desc ;
   unsigned char ep_in ;
   unsigned char ep_out ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 60 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb.h"
usb_handle *usb_open(int (*callback)(usb_ifc_info *ifc ) ) ;
#line 61
int usb_close(usb_handle *h ) ;
#line 62
int usb_read(usb_handle *h , void *_data , int len ) ;
#line 63
int usb_write(usb_handle *h , void const   *_data , int len ) ;
#line 65 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
__inline static int badname(char const   *name ) 
{ 
  unsigned short const   **tmp ;
  char const   *tmp___0 ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! *name) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = __ctype_b_loc();
#line 68
    tmp___0 = name;
#line 68
    name ++;
    }
#line 68
    if (! ((int const   )*(*tmp + (int )*tmp___0) & 2048)) {
#line 69
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 74 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
static int check(void *_desc , int len , unsigned int type , int size ) 
{ 
  unsigned char *desc ;

  {
#line 76
  desc = (unsigned char *)_desc;
#line 78
  if (len < size) {
#line 79
    return (-1);
  }
#line 80
  if ((int )*(desc + 0) < size) {
#line 81
    return (-1);
  }
#line 82
  if ((int )*(desc + 0) > len) {
#line 83
    return (-1);
  }
#line 84
  if ((unsigned int )*(desc + 1) != type) {
#line 85
    return (-1);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
static int filter_usb_device(int fd , char *ptr , int len , int writable , int (*callback)(usb_ifc_info *ifc ) ,
                             int *ept_in_id , int *ept_out_id , int *ifc_id ) 
{ 
  struct usb_device_descriptor *dev ;
  struct usb_config_descriptor *cfg ;
  struct usb_interface_descriptor *ifc ;
  struct usb_endpoint_descriptor *ept ;
  struct usb_ifc_info info ;
  int in ;
  int out ;
  unsigned int i ;
  unsigned int e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 104
  tmp = check((void *)ptr, len, 1U, 18);
  }
#line 104
  if (tmp) {
#line 105
    return (-1);
  }
  {
#line 106
  dev = (struct usb_device_descriptor *)((void *)ptr);
#line 107
  len -= (int )dev->bLength;
#line 108
  ptr += (int )dev->bLength;
#line 110
  tmp___0 = check((void *)ptr, len, 2U, 9);
  }
#line 110
  if (tmp___0) {
#line 111
    return (-1);
  }
#line 112
  cfg = (struct usb_config_descriptor *)((void *)ptr);
#line 113
  len -= (int )cfg->bLength;
#line 114
  ptr += (int )cfg->bLength;
#line 116
  info.dev_vendor = dev->idVendor;
#line 117
  info.dev_product = dev->idProduct;
#line 118
  info.dev_class = dev->bDeviceClass;
#line 119
  info.dev_subclass = dev->bDeviceSubClass;
#line 120
  info.dev_protocol = dev->bDeviceProtocol;
#line 121
  info.writable = (unsigned char )writable;
#line 123
  i = 0U;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < (unsigned int )cfg->bNumInterfaces)) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___1 = check((void *)ptr, len, 4U, 9);
    }
#line 124
    if (tmp___1) {
#line 125
      return (-1);
    }
#line 126
    ifc = (struct usb_interface_descriptor *)((void *)ptr);
#line 127
    len -= (int )ifc->bLength;
#line 128
    ptr += (int )ifc->bLength;
#line 130
    in = -1;
#line 131
    out = -1;
#line 132
    info.ifc_class = ifc->bInterfaceClass;
#line 133
    info.ifc_subclass = ifc->bInterfaceSubClass;
#line 134
    info.ifc_protocol = ifc->bInterfaceProtocol;
#line 136
    e = 0U;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (e < (unsigned int )ifc->bNumEndpoints)) {
#line 136
        goto while_break___0;
      }
      {
#line 137
      tmp___2 = check((void *)ptr, len, 5U, 7);
      }
#line 137
      if (tmp___2) {
#line 139
        return (-1);
      }
#line 140
      ept = (struct usb_endpoint_descriptor *)((void *)ptr);
#line 141
      len -= (int )ept->bLength;
#line 142
      ptr += (int )ept->bLength;
#line 144
      if (((int )ept->bmAttributes & 3) != 2) {
#line 145
        goto __Cont;
      }
#line 147
      if ((int )ept->bEndpointAddress & 128) {
#line 148
        in = (int )ept->bEndpointAddress;
      } else {
#line 150
        out = (int )ept->bEndpointAddress;
      }
      __Cont: /* CIL Label */ 
#line 136
      e ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 154
    info.has_bulk_in = (unsigned char )(in != -1);
#line 155
    info.has_bulk_out = (unsigned char )(out != -1);
#line 157
    tmp___3 = (*callback)(& info);
    }
#line 157
    if (tmp___3 == 0) {
#line 158
      *ept_in_id = in;
#line 159
      *ept_out_id = out;
#line 160
      *ifc_id = (int )ifc->bInterfaceNumber;
#line 161
      return (0);
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (-1);
}
}
#line 168 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
static void scanning(char *str ) 
{ 


  {
  {
#line 173
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"scanning %24s\r",
          str);
  }
#line 175
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
static usb_handle *find_usb_device(char const   *base , int (*callback)(usb_ifc_info *ifc ) ) 
{ 
  usb_handle *usb ;
  char busname[64] ;
  char devname[64] ;
  char desc[1024] ;
  int n ;
  int in ;
  int out ;
  int ifc ;
  DIR *busdir ;
  DIR *devdir ;
  struct dirent *de ;
  int fd ;
  int writable ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 179
  usb = (usb_handle *)0;
#line 189
  busdir = opendir(base);
  }
#line 190
  if ((unsigned long )busdir == (unsigned long )((DIR *)0)) {
#line 191
    return ((usb_handle *)0);
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    de = readdir(busdir);
    }
#line 193
    if (de) {
#line 193
      if (! ((unsigned long )usb == (unsigned long )((usb_handle *)0))) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
#line 194
    tmp = badname((char const   *)(de->d_name));
    }
#line 194
    if (tmp) {
#line 195
      goto while_continue;
    }
    {
#line 197
    sprintf((char */* __restrict  */)(busname), (char const   */* __restrict  */)"%s/%s",
            base, de->d_name);
#line 198
    devdir = opendir((char const   *)(busname));
    }
#line 199
    if ((unsigned long )devdir == (unsigned long )((DIR *)0)) {
#line 200
      goto while_continue;
    }
    {
#line 202
    scanning(busname);
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 203
      de = readdir(devdir);
      }
#line 203
      if (de) {
#line 203
        if (! ((unsigned long )usb == (unsigned long )((usb_handle *)0))) {
#line 203
          goto while_break___0;
        }
      } else {
#line 203
        goto while_break___0;
      }
      {
#line 205
      tmp___0 = badname((char const   *)(de->d_name));
      }
#line 205
      if (tmp___0) {
#line 206
        goto while_continue___0;
      }
      {
#line 207
      sprintf((char */* __restrict  */)(devname), (char const   */* __restrict  */)"%s/%s",
              busname, de->d_name);
#line 209
      scanning(devname);
#line 210
      writable = 1;
#line 211
      fd = open((char const   *)(devname), 2);
      }
#line 211
      if (fd < 0) {
        {
#line 216
        writable = 0;
#line 217
        fd = open((char const   *)(devname), 0);
        }
#line 217
        if (fd < 0) {
#line 218
          goto while_continue___0;
        }
      }
      {
#line 222
      tmp___1 = read(fd, (void *)(desc), sizeof(desc));
#line 222
      n = (int )tmp___1;
#line 224
      tmp___3 = filter_usb_device(fd, desc, n, writable, callback, & in, & out, & ifc);
      }
#line 224
      if (tmp___3 == 0) {
        {
#line 226
        tmp___2 = calloc((size_t )1, sizeof(usb_handle ));
#line 226
        usb = (usb_handle *)tmp___2;
#line 227
        strcpy((char */* __restrict  */)(usb->fname), (char const   */* __restrict  */)(devname));
#line 228
        usb->ep_in = (unsigned char )in;
#line 229
        usb->ep_out = (unsigned char )out;
#line 230
        usb->desc = fd;
#line 232
        n = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 15U) | (sizeof(unsigned int ) << 16),
                  & ifc);
        }
#line 233
        if (n != 0) {
          {
#line 234
          close(fd);
#line 235
          free((void *)usb);
#line 236
          usb = (usb_handle *)0;
          }
#line 237
          goto while_continue___0;
        }
      } else {
        {
#line 240
        close(fd);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 243
    closedir(devdir);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 245
  closedir(busdir);
  }
#line 247
  if (usb) {
    {
#line 248
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
    }
  }
#line 251
  return (usb);
}
}
#line 254 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
int usb_write(usb_handle *h , void const   *_data , int len ) 
{ 
  unsigned char *data ;
  unsigned int count ;
  struct usbdevfs_bulktransfer bulk ;
  int n ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int xfer ;

  {
#line 256
  data = (unsigned char *)_data;
#line 257
  count = 0U;
#line 261
  if ((int )h->ep_out == 0) {
#line 262
    return (-1);
  }
#line 265
  if (len == 0) {
    {
#line 266
    bulk.ep = (unsigned int )h->ep_out;
#line 267
    bulk.len = 0U;
#line 268
    bulk.data = (void *)data;
#line 269
    bulk.timeout = 0U;
#line 271
    n = ioctl(h->desc, (unsigned long )(((3U << 30) | (unsigned int )(85 << 8)) | 2U) | (sizeof(struct usbdevfs_bulktransfer ) << 16),
              & bulk);
    }
#line 272
    if (n != 0) {
      {
#line 273
      tmp = __errno_location();
#line 273
      tmp___0 = strerror(*tmp);
#line 273
      tmp___1 = __errno_location();
#line 273
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: n = %d, errno = %d (%s)\n",
              n, *tmp___1, tmp___0);
      }
#line 275
      return (-1);
    }
#line 277
    return (0);
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (len > 0)) {
#line 280
      goto while_break;
    }
#line 282
    if (len > 4096) {
#line 282
      xfer = 4096;
    } else {
#line 282
      xfer = len;
    }
    {
#line 284
    bulk.ep = (unsigned int )h->ep_out;
#line 285
    bulk.len = (unsigned int )xfer;
#line 286
    bulk.data = (void *)data;
#line 287
    bulk.timeout = 0U;
#line 289
    n = ioctl(h->desc, (unsigned long )(((3U << 30) | (unsigned int )(85 << 8)) | 2U) | (sizeof(struct usbdevfs_bulktransfer ) << 16),
              & bulk);
    }
#line 290
    if (n != xfer) {
#line 293
      return (-1);
    }
#line 296
    count += (unsigned int )xfer;
#line 297
    len -= xfer;
#line 298
    data += xfer;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return ((int )count);
}
}
#line 304 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
int usb_read(usb_handle *h , void *_data , int len ) 
{ 
  unsigned char *data ;
  unsigned int count ;
  struct usbdevfs_bulktransfer bulk ;
  int n ;
  int retry ;
  int xfer ;
  int tmp ;

  {
#line 306
  data = (unsigned char *)_data;
#line 307
  count = 0U;
#line 311
  if ((int )h->ep_in == 0) {
#line 312
    return (-1);
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (len > 0)) {
#line 315
      goto while_break;
    }
#line 316
    if (len > 4096) {
#line 316
      tmp = 4096;
    } else {
#line 316
      tmp = len;
    }
#line 316
    xfer = tmp;
#line 318
    bulk.ep = (unsigned int )h->ep_in;
#line 319
    bulk.len = (unsigned int )xfer;
#line 320
    bulk.data = (void *)data;
#line 321
    bulk.timeout = 0U;
#line 322
    retry = 0;
    {
#line 324
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 327
      n = ioctl(h->desc, (unsigned long )(((3U << 30) | (unsigned int )(85 << 8)) | 2U) | (sizeof(struct usbdevfs_bulktransfer ) << 16),
                & bulk);
      }
#line 331
      if (n < 0) {
#line 334
        retry ++;
#line 334
        if (retry > 5) {
#line 335
          return (-1);
        }
        {
#line 336
        sleep(1U);
        }
      }
#line 324
      if (! (n < 0)) {
#line 324
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    count += (unsigned int )n;
#line 342
    len -= n;
#line 343
    data += n;
#line 345
    if (n < xfer) {
#line 346
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return ((int )count);
}
}
#line 353 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
int usb_close(usb_handle *h ) 
{ 
  int fd ;

  {
#line 357
  fd = h->desc;
#line 358
  h->desc = -1;
#line 359
  if (fd >= 0) {
    {
#line 360
    close(fd);
    }
  }
#line 364
  return (0);
}
}
#line 367 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usb_linux.c"
usb_handle *usb_open(int (*callback)(usb_ifc_info *ifc ) ) 
{ 
  usb_handle *tmp ;

  {
  {
#line 369
  tmp = find_usb_device("/dev/bus/usb", callback);
  }
#line 369
  return (tmp);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 39 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usbboot.c"
int usb_boot(usb_handle *usb , void *data1 , unsigned int sz1 , void *data2 , unsigned int sz2 ) 
{ 
  uint32_t msg_boot ;
  uint32_t msg_getid ;
  uint32_t msg_size ;
  uint8_t id[81] ;
  int i ;
  char command[64] ;
  char response[64] ;
  long rsz ;
  int tmp ;
  int tmp___0 ;

  {
#line 42
  if (data1) {
    {
#line 43
    msg_boot = 4026728450U;
#line 44
    msg_getid = 4026728451U;
#line 45
    msg_size = sz1;
#line 52
    memset((void *)(id), 238, (size_t )81);
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading ASIC ID\n");
#line 54
    usb_write(usb, (void const   *)(& msg_getid), (int )sizeof(msg_getid));
#line 55
    usb_read(usb, (void *)(id), (int )sizeof(id));
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CHIP: %02x%02x\n",
            (int )id[4], (int )id[5]);
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IDEN: ");
#line 60
    i = 0;
    }
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! (i < 20)) {
#line 60
        goto while_break;
      }
      {
#line 61
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int )id[15 + i]);
#line 60
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMPKH: ");
#line 63
    i = 0;
    }
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      if (! (i < 32)) {
#line 63
        goto while_break___0;
      }
      {
#line 64
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
              (int )id[38 + i]);
#line 63
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nCRC0: %02x%02x%02x%02x\n",
            (int )id[73], (int )id[74], (int )id[75], (int )id[76]);
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC1: %02x%02x%02x%02x\n",
            (int )id[77], (int )id[78], (int )id[79], (int )id[80]);
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sending u-boot-spl to target... %08x\n",
            msg_boot);
#line 72
    sleep(1U);
#line 73
    usb_write(usb, (void const   *)(& msg_boot), (int )sizeof(msg_boot));
#line 74
    sleep(1U);
#line 75
    usb_write(usb, (void const   *)(& msg_size), (int )sizeof(msg_size));
#line 76
    sleep(1U);
#line 77
    usb_write(usb, (void const   *)data1, (int )sz1);
    }
  }
#line 80
  if (data2) {
    {
#line 85
    sleep(1U);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sending download command to u-boot-spl\n");
#line 87
    sprintf((char */* __restrict  */)(command), (char const   */* __restrict  */)"download:%08x",
            sz2);
#line 88
    usb_write(usb, (void const   *)(command), (int )sizeof(command));
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waiting for \"DATA\" response to download: command\n");
#line 90
    usb_read(usb, (void *)(response), (int )sizeof(response));
#line 91
    tmp = strncmp("DATA", (char const   *)(response), (size_t )4);
    }
#line 91
    if (tmp) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected response\"%s\"\n",
              response);
      }
#line 93
      return (-1);
    }
    {
#line 95
    rsz = strtol((char const   */* __restrict  */)(response + 4), (char **/* __restrict  */)0,
                 16);
    }
#line 96
    if (rsz != (long )sz2) {
      {
#line 97
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad returned size\"%s\"\n",
              response);
      }
#line 98
      return (-1);
    }
    {
#line 100
    sleep(1U);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"transferring %d bytes of data\n",
            sz2);
#line 102
    usb_write(usb, (void const   *)data2, (int )sz2);
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write finished, waiting for \"OKAY\"\n");
#line 104
    usb_read(usb, (void *)(response), (int )sizeof(response));
#line 105
    tmp___0 = strncmp("OKAY", (char const   *)(response), (size_t )4);
    }
#line 105
    if (tmp___0 == 0) {
      {
#line 106
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data transfer successful\n");
      }
    } else {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected response to data xfer\"%s\"\n",
              response);
      }
#line 109
      return (-1);
    }
  }
#line 113
  return (0);
}
}
#line 116 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usbboot.c"
int match_omap4_bootloader(usb_ifc_info *ifc ) 
{ 


  {
#line 118
  if ((int )ifc->dev_vendor != 1105) {
#line 119
    return (-1);
  }
#line 120
  if ((int )ifc->dev_product != 53264) {
#line 120
    if ((int )ifc->dev_product != 53263) {
#line 121
      return (-1);
    }
  }
#line 122
  return (0);
}
}
#line 128 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usbboot.c"
int match_u_boot_spl(usb_ifc_info *ifc ) 
{ 


  {
#line 130
  if ((int )ifc->dev_vendor != 1317) {
#line 131
    return (-1);
  }
#line 132
  if ((int )ifc->dev_product != 65535) {
#line 133
    return (-1);
  }
#line 134
  return (0);
}
}
#line 137 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usbboot.c"
void *load_file(char const   *file , unsigned int *sz ) 
{ 
  void *data ;
  struct stat s ;
  int fd ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 143
  fd = open(file, 0);
  }
#line 144
  if (fd < 0) {
#line 145
    return ((void *)0);
  }
  {
#line 147
  tmp = fstat(fd, & s);
  }
#line 147
  if (tmp) {
#line 148
    goto fail;
  }
  {
#line 150
  data = malloc((size_t )s.st_size);
  }
#line 151
  if (! data) {
#line 152
    goto fail;
  }
  {
#line 154
  tmp___0 = read(fd, data, (size_t )s.st_size);
  }
#line 154
  if (tmp___0 != s.st_size) {
    {
#line 155
    free(data);
    }
#line 156
    goto fail;
  }
  {
#line 159
  close(fd);
#line 160
  *sz = (unsigned int )s.st_size;
  }
#line 161
  return (data);
  fail: 
  {
#line 164
  close(fd);
  }
#line 165
  return ((void *)0);
}
}
#line 171 "/home/wheatley/newnew/temp/linaro-boot-utils-0.1/usbboot.c"
int main(int argc , char **argv ) 
{ 
  void *data[2] ;
  unsigned int sz[2] ;
  usb_handle *usb ;
  int i ;
  int once ;
  int tmp ;

  {
#line 177
  once = 1;
#line 179
  if (argc < 3) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: usbboot u-boot-spl.bin u-boot.bin\n");
    }
#line 181
    return (0);
  }
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < 2)) {
#line 184
      goto while_break;
    }
    {
#line 185
    data[i] = load_file((char const   *)*(argv + (i + 1)), sz + i);
    }
#line 186
    if ((unsigned long )data[i] == (unsigned long )((void *)0)) {
      {
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot load \'%s\'\n",
              *(argv + (i + 1)));
      }
#line 188
      return (-1);
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 196
    usb = usb_open(& match_omap4_bootloader);
    }
#line 197
    if (usb) {
      {
#line 198
      usb_boot(usb, data[0], sz[0], (void *)0, 0U);
      }
#line 199
      goto while_break___0;
    }
#line 201
    if (once) {
      {
#line 202
      once = 0;
#line 203
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waiting for OMAP44xx device...\n");
      }
    }
    {
#line 205
    usleep((__useconds_t )2500);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 207
  usb_close(usb);
#line 215
  once = 1;
  }
  {
#line 216
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 217
    usb = usb_open(& match_u_boot_spl);
    }
#line 218
    if (usb) {
      {
#line 219
      tmp = usb_boot(usb, (void *)0, 0U, data[1], sz[1]);
      }
#line 219
      return (tmp);
    }
#line 220
    if (once) {
      {
#line 221
      once = 0;
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waiting for U-Boot-spl bootloader...\n");
      }
    }
    {
#line 224
    usleep((__useconds_t )2500);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 227
  return (-1);
}
}
