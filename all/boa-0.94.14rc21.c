/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 202 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct status {
   long requests ;
   long errors ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_39 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_40 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_41 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_42 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_43 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_44 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_45 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_38 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_39 _kill ;
   struct __anonstruct__timer_40 _timer ;
   struct __anonstruct__rt_41 _rt ;
   struct __anonstruct__sigchld_42 _sigchld ;
   struct __anonstruct__sigfault_43 _sigfault ;
   struct __anonstruct__sigpoll_44 _sigpoll ;
   struct __anonstruct__sigsys_45 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_37 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_38 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_37 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_57 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_57 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 104 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct mmap_entry {
   dev_t dev ;
   ino_t ino ;
   char *mmap ;
   int use_count ;
   off_t len ;
};
#line 29
enum HTTP_METHOD {
    M_GET = 1,
    M_HEAD = 2,
    M_PUT = 3,
    M_POST = 4,
    M_DELETE = 5,
    M_LINK = 6,
    M_UNLINK = 7,
    M_MOVE = 8,
    M_TRACE = 9
} ;
#line 34
enum HTTP_VERSION {
    HTTP09 = 1,
    HTTP10 = 2,
    HTTP11 = 3
} ;
#line 37
enum REQ_STATUS {
    READ_HEADER = 0,
    ONE_CR = 1,
    ONE_LF = 2,
    TWO_CR = 3,
    BODY_READ = 4,
    BODY_WRITE = 5,
    WRITE = 6,
    PIPE_READ = 7,
    PIPE_WRITE = 8,
    IOSHUFFLE = 9,
    DONE = 10,
    TIMED_OUT = 11,
    DEAD = 12
} ;
#line 48
enum RESPONSE_CODE {
    R_CONTINUE = 100,
    R_REQUEST_OK = 200,
    R_CREATED = 201,
    R_ACCEPTED = 202,
    R_PROVISIONAL = 203,
    R_NO_CONTENT = 204,
    R_205 = 205,
    R_PARTIAL_CONTENT = 206,
    R_MULTIPLE = 300,
    R_MOVED_PERM = 301,
    R_MOVED_TEMP = 302,
    R_303 = 303,
    R_NOT_MODIFIED = 304,
    R_BAD_REQUEST = 400,
    R_UNAUTHORIZED = 401,
    R_PAYMENT = 402,
    R_FORBIDDEN = 403,
    R_NOT_FOUND = 404,
    R_METHOD_NA = 405,
    R_NON_ACC = 406,
    R_PROXY = 407,
    R_REQUEST_TO = 408,
    R_CONFLICT = 409,
    R_GONE = 410,
    R_LENGTH_REQUIRED = 411,
    R_PRECONDITION_FAILED = 412,
    R_REQUEST_URI_TOO_LONG = 414,
    R_INVALID_RANGE = 416,
    R_ERROR = 500,
    R_NOT_IMP = 501,
    R_BAD_GATEWAY = 502,
    R_SERVICE_UNAV = 503,
    R_GATEWAY_TO = 504,
    R_BAD_VERSION = 505
} ;
#line 87
enum KA_STATUS {
    KA_INACTIVE = 0,
    KA_ACTIVE = 1,
    KA_STOPPED = 2
} ;
#line 90
enum CGI_STATUS {
    CGI_PARSE = 0,
    CGI_BUFFER = 1,
    CGI_DONE = 2
} ;
#line 93
enum CGI_TYPE {
    NPH = 1,
    CGI = 2
} ;
#line 96 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct range {
   unsigned long start ;
   unsigned long stop ;
   struct range *next ;
};
#line 102 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
typedef struct range Range;
#line 112 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct request {
   enum REQ_STATUS status ;
   enum KA_STATUS keepalive ;
   enum HTTP_VERSION http_version ;
   enum HTTP_METHOD method ;
   enum RESPONSE_CODE response_status ;
   enum CGI_TYPE cgi_type ;
   enum CGI_STATUS cgi_status ;
   char *pathname ;
   Range *ranges ;
   int numranges ;
   int data_fd ;
   off_t filesize ;
   off_t filepos ;
   size_t bytes_written ;
   char *data_mem ;
   char *logline ;
   char *header_line ;
   char *header_end ;
   int parse_pos ;
   int buffer_start ;
   int buffer_end ;
   char *if_modified_since ;
   time_t last_modified ;
   int cgi_env_index ;
   char *header_host ;
   char *header_user_agent ;
   char *header_referer ;
   char *header_ifrange ;
   char *host ;
   int post_data_fd ;
   char *path_info ;
   char *path_translated ;
   char *script_name ;
   char *query_string ;
   char *content_type ;
   char *content_length ;
   struct mmap_entry *mmap_entry_var ;
   int fd ;
   time_t time_last ;
   char local_ip_addr[20] ;
   char remote_ip_addr[20] ;
   unsigned int remote_port ;
   unsigned int kacount ;
   int client_stream_pos ;
   char buffer[4097] ;
   char request_uri[1025] ;
   char client_stream[8192] ;
   char *cgi_env[104] ;
   struct request *next ;
   struct request *prev ;
};
#line 200 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
typedef struct request request;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 694 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
struct dbg {
   int level ;
   char const   *mesg ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 84 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
enum ALIAS {
    ALIAS = 0,
    SCRIPTALIAS = 1,
    REDIRECT = 2
} ;
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
struct alias {
   char *fakename ;
   char *realname ;
   enum ALIAS type ;
   unsigned int fake_len ;
   unsigned int real_len ;
   struct alias *next ;
};
#line 37 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
typedef struct alias alias;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 88 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
struct ccommand {
   char const   *name ;
   int const   type ;
   void (*action)(char * , char * , void * ) ;
   void *object ;
};
#line 95 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
typedef struct ccommand Command;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 45 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
struct _hash_struct_ {
   char *key ;
   char *value ;
   struct _hash_struct_ *next ;
};
#line 51 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
typedef struct _hash_struct_ hash_struct;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 38 "/home/june/collector/temp/boa-0.94.14rc21/src/sublog.c"
int open_pipe_fd(char const   *command ) ;
#line 39
int open_net_fd(char const   *spec ) ;
#line 40
int open_gen_fd(char const   *spec ) ;
#line 43 "/home/june/collector/temp/boa-0.94.14rc21/src/sublog.c"
int open_pipe_fd(char const   *command ) 
{ 
  int pipe_fds[2] ;
  int pid ;
  int tmp ;

  {
  {
#line 49
  tmp = pipe((int *)(pipe_fds));
  }
#line 49
  if (tmp == -1) {
#line 50
    return (-1);
  }
  {
#line 51
  pid = fork();
  }
#line 52
  if (pid == 0) {
    {
#line 53
    close(pipe_fds[1]);
    }
#line 54
    if (pipe_fds[0] != 0) {
      {
#line 55
      dup2(pipe_fds[0], 0);
#line 56
      close(pipe_fds[0]);
      }
    }
    {
#line 58
    execl("/bin/sh", "sh", "-c", command, (char *)0);
#line 59
    exit(1);
    }
  }
  {
#line 61
  close(pipe_fds[0]);
  }
#line 62
  if (pid < 0) {
    {
#line 63
    close(pipe_fds[1]);
    }
#line 64
    return (-1);
  }
#line 66
  return (pipe_fds[1]);
}
}
#line 69 "/home/june/collector/temp/boa-0.94.14rc21/src/sublog.c"
int open_net_fd(char const   *spec ) 
{ 
  char *p ;
  int fd ;
  int port ;
  struct sockaddr_in sa ;
  struct hostent *he ;
  char *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  p = strchr(spec, ':');
  }
#line 76
  if (! p) {
#line 77
    return (-1);
  }
  {
#line 78
  tmp = p;
#line 78
  p ++;
#line 78
  *tmp = (char )'\000';
#line 79
  tmp___0 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)((void *)0),
                   10);
#line 79
  port = (int )tmp___0;
#line 81
  sa.sin_family = (sa_family_t )2;
#line 82
  sa.sin_port = htons((uint16_t )port);
#line 83
  he = gethostbyname(spec);
  }
#line 84
  if (! he) {
    {
#line 86
    herror("open_net_fd");
    }
#line 88
    return (-1);
  }
  {
#line 90
  memcpy((void */* __restrict  */)(& sa.sin_addr), (void const   */* __restrict  */)*(he->h_addr_list + 0),
         (size_t )he->h_length);
#line 92
  fd = socket(2, 1, 6);
  }
#line 93
  if (fd < 0) {
#line 94
    return (fd);
  }
  {
#line 95
  tmp___1 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 95
  if (tmp___1 < 0) {
#line 96
    return (-1);
  }
#line 97
  return (fd);
}
}
#line 100 "/home/june/collector/temp/boa-0.94.14rc21/src/sublog.c"
int open_gen_fd(char const   *spec ) 
{ 
  int fd ;

  {
#line 103
  if ((int const   )*spec == 124) {
    {
#line 104
    fd = open_pipe_fd(spec + 1);
    }
  } else
#line 105
  if ((int const   )*spec == 58) {
    {
#line 106
    fd = open_net_fd(spec + 1);
    }
  } else {
    {
#line 108
    fd = open(spec, 1089, (384 | ((256 >> 3) >> 3)) | (256 >> 3));
    }
  }
#line 112
  return (fd);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 232 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
unsigned int server_port ;
#line 85 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void log_error_time(void) ;
#line 196
void timestamp(void) ;
#line 25 "/home/june/collector/temp/boa-0.94.14rc21/src/timestamp.c"
void timestamp(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 27
  log_error_time();
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"boa: server version %s\n",
          "Boa/0.94.14rc21");
#line 29
  log_error_time();
#line 30
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"boa: server built Mar  2 2016 at 13:13:39.\n");
#line 31
  log_error_time();
#line 32
  tmp = getpid();
#line 32
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"boa: starting server pid=%d, port %d\n",
          tmp, server_port);
  }
#line 34
  return;
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 207 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct status status ;
#line 236
char *server_root ;
#line 237
char *server_name ;
#line 250
char const   *tempdir ;
#line 261
int sighup_flag ;
#line 262
int sigchld_flag ;
#line 263
int sigalrm_flag ;
#line 264
int sigterm_flag ;
#line 265
time_t start_time ;
#line 270
int verbose_cgi_logs ;
#line 273
time_t current_time ;
#line 282 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
sigjmp_buf env  ;
#line 283 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int handle_sigbus  ;
#line 58 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void dump_alias(void) ;
#line 61
void read_config_files(void) ;
#line 75
void dump_mime(void) ;
#line 76
void dump_passwd(void) ;
#line 77
void hash_show_stats(void) ;
#line 115
void free_requests(void) ;
#line 153
void clear_common_env(void) ;
#line 158
void init_signals(void) ;
#line 159
void reset_signals(void) ;
#line 160
void sighup_run(void) ;
#line 161
void sigchld_run(void) ;
#line 162
void sigalrm_run(void) ;
#line 163
void sigterm_stage1_run(void) ;
#line 164
void sigterm_stage2_run(void) ;
#line 226
void range_pool_empty(void) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 35 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigsegv(int dummy ) ;
#line 36
void sigbus(int dummy ) ;
#line 37
void sigterm(int dummy ) ;
#line 38
void sighup(int dummy ) ;
#line 39
void sigint(int dummy ) ;
#line 40
void sigchld(int dummy ) ;
#line 41
void sigalrm(int dummy ) ;
#line 48 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void init_signals(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 52
  sa.sa_flags = 0;
#line 54
  sigemptyset(& sa.sa_mask);
#line 55
  sigaddset(& sa.sa_mask, 11);
#line 56
  sigaddset(& sa.sa_mask, 7);
#line 57
  sigaddset(& sa.sa_mask, 15);
#line 58
  sigaddset(& sa.sa_mask, 1);
#line 59
  sigaddset(& sa.sa_mask, 2);
#line 60
  sigaddset(& sa.sa_mask, 13);
#line 61
  sigaddset(& sa.sa_mask, 17);
#line 62
  sigaddset(& sa.sa_mask, 14);
#line 63
  sigaddset(& sa.sa_mask, 10);
#line 64
  sigaddset(& sa.sa_mask, 12);
#line 66
  sa.__sigaction_handler.sa_handler = & sigsegv;
#line 67
  sigaction(11, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 69
  sa.__sigaction_handler.sa_handler = & sigbus;
#line 70
  sigaction(7, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 72
  sa.__sigaction_handler.sa_handler = & sigterm;
#line 73
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 75
  sa.__sigaction_handler.sa_handler = & sighup;
#line 76
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 78
  sa.__sigaction_handler.sa_handler = & sigint;
#line 79
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 81
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 82
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 84
  sa.__sigaction_handler.sa_handler = & sigchld;
#line 85
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 87
  sa.__sigaction_handler.sa_handler = & sigalrm;
#line 88
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 90
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 91
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 93
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 94
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 95
  return;
}
}
#line 97 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void reset_signals(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 101
  sa.sa_flags = 0;
#line 102
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 104
  sigemptyset(& sa.sa_mask);
#line 105
  sigaddset(& sa.sa_mask, 11);
#line 106
  sigaddset(& sa.sa_mask, 7);
#line 107
  sigaddset(& sa.sa_mask, 15);
#line 108
  sigaddset(& sa.sa_mask, 1);
#line 109
  sigaddset(& sa.sa_mask, 2);
#line 110
  sigaddset(& sa.sa_mask, 13);
#line 111
  sigaddset(& sa.sa_mask, 17);
#line 112
  sigaddset(& sa.sa_mask, 14);
#line 113
  sigaddset(& sa.sa_mask, 10);
#line 114
  sigaddset(& sa.sa_mask, 12);
#line 116
  sigaction(11, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 117
  sigaction(7, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 118
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 119
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 120
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 121
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 122
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 123
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 124
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 125
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 126
  return;
}
}
#line 128 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigsegv(int dummy ) 
{ 


  {
  {
#line 130
  time(& current_time);
#line 131
  log_error_time();
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"caught SIGSEGV, dumping core in %s\n",
          tempdir);
#line 133
  chdir(tempdir);
#line 134
  abort();
  }
}
}
#line 140 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigbus(int dummy ) 
{ 


  {
#line 142
  if (handle_sigbus) {
    {
#line 143
    longjmp((struct __jmp_buf_tag *)(env), dummy);
    }
  }
  {
#line 145
  time(& current_time);
#line 146
  log_error_time();
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"caught SIGBUS, dumping core in %s\n",
          tempdir);
#line 148
  chdir(tempdir);
#line 149
  abort();
  }
}
}
#line 152 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigterm(int dummy ) 
{ 


  {
#line 154
  if (! sigterm_flag) {
#line 155
    sigterm_flag = 1;
  }
#line 156
  return;
}
}
#line 158 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigterm_stage1_run(void) 
{ 


  {
  {
#line 160
  time(& current_time);
#line 161
  log_error_time();
#line 162
  fputs((char const   */* __restrict  */)"caught SIGTERM, starting shutdown\n", (FILE */* __restrict  */)stderr);
#line 163
  sigterm_flag = 2;
  }
#line 164
  return;
}
}
#line 166 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigterm_stage2_run(void) 
{ 


  {
  {
#line 168
  log_error_time();
#line 169
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting Boa normally (uptime %d seconds)\n",
          (int )(current_time - start_time));
#line 172
  chdir(tempdir);
#line 173
  clear_common_env();
#line 174
  dump_mime();
#line 175
  dump_passwd();
#line 176
  dump_alias();
#line 177
  free_requests();
#line 178
  range_pool_empty();
#line 179
  free((void *)server_root);
#line 180
  free((void *)server_name);
#line 181
  server_root = (char *)((void *)0);
#line 182
  exit(0);
  }
}
}
#line 186 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sighup(int dummy ) 
{ 


  {
#line 188
  sighup_flag = 1;
#line 189
  return;
}
}
#line 191 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sighup_run(void) 
{ 


  {
  {
#line 193
  sighup_flag = 0;
#line 194
  time(& current_time);
#line 195
  log_error_time();
#line 196
  fputs((char const   */* __restrict  */)"caught SIGHUP, restarting\n", (FILE */* __restrict  */)stderr);
#line 208
  dump_mime();
#line 209
  dump_passwd();
#line 210
  dump_alias();
#line 211
  free_requests();
#line 212
  range_pool_empty();
#line 214
  log_error_time();
#line 215
  fputs((char const   */* __restrict  */)"re-reading configuration files\n", (FILE */* __restrict  */)stderr);
#line 216
  read_config_files();
#line 218
  log_error_time();
#line 219
  fputs((char const   */* __restrict  */)"successful restart\n", (FILE */* __restrict  */)stderr);
  }
#line 220
  return;
}
}
#line 222 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigint(int dummy ) 
{ 


  {
  {
#line 224
  time(& current_time);
#line 225
  log_error_time();
#line 226
  fputs((char const   */* __restrict  */)"caught SIGINT: shutting down\n", (FILE */* __restrict  */)stderr);
#line 227
  chdir(tempdir);
#line 228
  exit(1);
  }
}
}
#line 231 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigchld(int dummy ) 
{ 


  {
#line 233
  sigchld_flag = 1;
#line 234
  return;
}
}
#line 236 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigchld_run(void) 
{ 
  int child_status ;
  pid_t pid ;

  {
#line 241
  sigchld_flag = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    pid = waitpid(-1, & child_status, 1);
    }
#line 243
    if (! (pid > 0)) {
#line 243
      goto while_break;
    }
#line 244
    if (verbose_cgi_logs) {
      {
#line 245
      time(& current_time);
#line 246
      log_error_time();
#line 247
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reaping child %d: status %d\n",
              pid, child_status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return;
}
}
#line 253 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigalrm(int dummy ) 
{ 


  {
#line 255
  sigalrm_flag = 1;
#line 256
  return;
}
}
#line 258 "/home/june/collector/temp/boa-0.94.14rc21/src/signals.c"
void sigalrm_run(void) 
{ 


  {
  {
#line 260
  time(& current_time);
#line 261
  log_error_time();
#line 262
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld requests, %ld errors\n",
          status.requests, status.errors);
#line 264
  hash_show_stats();
#line 265
  sigalrm_flag = 0;
  }
#line 266
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 94
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 131 "/home/june/collector/temp/boa-0.94.14rc21/src/defines.h"
int debug_level ;
#line 199 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
struct mmap_entry *find_mmap(int data_fd , struct stat *s ) ;
#line 200
void release_mmap(struct mmap_entry *e ) ;
#line 26 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
static int mmap_list_entries_used  =    0;
#line 27 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
static int mmap_list_total_requests  =    0;
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
static int mmap_list_hash_bounces  =    0;
#line 34 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
static struct mmap_entry mmap_list[256]  ;
#line 36 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
struct mmap_entry *find_mmap(int data_fd , struct stat *s ) 
{ 
  void *m ;
  int i ;
  int start ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int mret ;
  int saved_errno___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 40
  mmap_list_total_requests ++;
#line 41
  start = (int )(s->st_ino & 255UL);
#line 41
  i = start;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! mmap_list[i].use_count) {
#line 42
      goto while_break;
    }
#line 43
    if (mmap_list[i].dev == s->st_dev) {
#line 43
      if (mmap_list[i].ino == s->st_ino) {
#line 43
        if (mmap_list[i].len == s->st_size) {
#line 46
          (mmap_list[i].use_count) ++;
#line 47
          if (debug_level & (1 << 11)) {
            {
#line 48
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Old mmap_list entry %d use_count now %d (hash was %d)\n",
                    i, mmap_list[i].use_count, start);
            }
          }
#line 52
          return (mmap_list + i);
        }
      }
    }
#line 54
    mmap_list_hash_bounces ++;
#line 55
    i = (i + 1) & 255;
#line 56
    if (i == start) {
#line 68
      return ((struct mmap_entry *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if (mmap_list_entries_used > 128) {
#line 78
    return ((struct mmap_entry *)((void *)0));
  }
  {
#line 81
  m = mmap((void *)0, (size_t )s->st_size, 1, 2, data_fd, (__off64_t )0);
  }
#line 83
  if ((long )m == -1L) {
    {
#line 84
    tmp = __errno_location();
#line 84
    saved_errno = *tmp;
#line 85
    log_error_time();
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to mmap file: ");
#line 87
    tmp___0 = __errno_location();
#line 87
    *tmp___0 = saved_errno;
#line 88
    perror("mmap");
    }
#line 89
    return ((struct mmap_entry *)((void *)0));
  }
  {
#line 96
  mret = madvise(m, (size_t )s->st_size, 2);
  }
#line 97
  if (mret == -1) {
    {
#line 98
    tmp___1 = __errno_location();
#line 98
    saved_errno___0 = *tmp___1;
#line 99
    log_error_time();
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to madvise file: ");
#line 101
    tmp___2 = __errno_location();
#line 101
    *tmp___2 = saved_errno___0;
#line 102
    perror("madvise");
#line 103
    munmap(m, (size_t )s->st_size);
    }
#line 104
    return ((struct mmap_entry *)((void *)0));
  }
#line 109
  if (debug_level & (1 << 11)) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"New mmap_list entry %d (hash was %d)\n",
            i, start);
    }
  }
#line 112
  mmap_list_entries_used ++;
#line 113
  mmap_list[i].dev = s->st_dev;
#line 114
  mmap_list[i].ino = s->st_ino;
#line 115
  mmap_list[i].len = s->st_size;
#line 116
  mmap_list[i].mmap = (char *)m;
#line 117
  mmap_list[i].use_count = 1;
#line 118
  return (mmap_list + i);
}
}
#line 121 "/home/june/collector/temp/boa-0.94.14rc21/src/mmap_cache.c"
void release_mmap(struct mmap_entry *e ) 
{ 


  {
#line 123
  if (! e) {
#line 124
    return;
  }
#line 125
  if (! e->use_count) {
#line 126
    if (debug_level & (1 << 11)) {
      {
#line 127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mmap_list(%p)->use_count already zero!\n",
              (void *)e);
      }
    }
#line 129
    return;
  }
#line 131
  (e->use_count) --;
#line 131
  if (! e->use_count) {
    {
#line 132
    munmap((void *)e->mmap, (size_t )e->len);
#line 133
    mmap_list_entries_used --;
    }
  }
#line 135
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 83 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void log_error_doc(request *req ) ;
#line 89
void log_error_mesg_fatal(char const   *file , int line , char const   *func , char const   *mesg ) ;
#line 143
void send_r_invalid_range(request *req ) ;
#line 224
void ranges_reset(request *req ) ;
#line 225
Range *range_pool_pop(void) ;
#line 227
void range_pool_push(Range *r ) ;
#line 228
int ranges_fixup(request *req ) ;
#line 229
int range_parse(request *req , char const   *str ) ;
#line 29 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
static void range_abort(request *req ) ;
#line 30
static void range_add(request *req , unsigned long start , unsigned long stop ) ;
#line 31 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
static Range *range_pool  =    (Range *)((void *)0);
#line 33 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
void ranges_reset(request *req ) 
{ 
  Range *r ;
  Range *bob ;

  {
#line 35
  r = req->ranges;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! r) {
#line 37
      goto while_break;
    }
    {
#line 40
    bob = r->next;
#line 41
    range_pool_push(r);
#line 42
    r = bob;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  req->ranges = (Range *)((void *)0);
#line 45
  return;
}
}
#line 47 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
Range *range_pool_pop(void) 
{ 
  Range *r ;
  void *tmp ;

  {
#line 51
  r = range_pool;
#line 52
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 53
    range_pool = range_pool->next;
  } else {
    {
#line 56
    tmp = malloc(sizeof(Range ));
#line 56
    r = (Range *)tmp;
    }
#line 57
    if ((unsigned long )r == (unsigned long )((void *)0)) {
      {
#line 58
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/range.c",
                           58, "range_pool_pop", "ran out of memory for new Range...");
      }
    }
  }
#line 60
  r->start = 0UL;
#line 61
  r->stop = 0UL;
#line 62
  r->next = (struct range *)((void *)0);
#line 63
  return (r);
}
}
#line 66 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
void range_pool_empty(void) 
{ 
  Range *r ;
  Range *tmp ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )range_pool != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp = range_pool_pop();
#line 69
    r = tmp;
#line 70
    free((void *)r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
void range_pool_push(Range *r ) 
{ 


  {
#line 76
  r->next = range_pool;
#line 77
  range_pool = r;
#line 78
  return;
}
}
#line 80 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
static void range_abort(request *req ) 
{ 


  {
  {
#line 83
  ranges_reset(req);
#line 86
  req->ranges = range_pool_pop();
#line 87
  (req->ranges)->stop = 0xffffffffffffffffUL;
  }
#line 88
  return;
}
}
#line 90 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
static void range_add(request *req , unsigned long start , unsigned long stop ) 
{ 
  Range *prev ;
  Range *r ;
  Range *tmp ;

  {
  {
#line 93
  tmp = range_pool_pop();
#line 93
  r = tmp;
  }
#line 95
  if (debug_level & (1 << 7)) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"range.c, range_add: got: %lu-%lu\n",
            start, stop);
    }
  }
#line 99
  prev = req->ranges;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! prev) {
#line 99
      goto while_break;
    }
#line 100
    if ((unsigned long )prev->next == (unsigned long )((void *)0)) {
#line 101
      goto while_break;
    }
#line 99
    prev = prev->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (prev) {
#line 105
    prev->next = r;
  } else {
#line 107
    req->ranges = r;
  }
#line 110
  r->start = start;
#line 111
  r->stop = stop;
#line 112
  (req->numranges) ++;
#line 113
  return;
}
}
#line 119 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
int ranges_fixup(request *req ) 
{ 
  Range *prev ;
  Range *r ;
  Range *temp ;
  Range *temp___0 ;

  {
#line 127
  prev = (Range *)((void *)0);
#line 128
  r = req->ranges;
#line 129
  req->ranges = (Range *)((void *)0);
#line 131
  if (req->filesize == 0L) {
    {
#line 134
    while (1) {
      while_continue: /* CIL Label */ ;
#line 134
      if (! r) {
#line 134
        goto while_break;
      }
      {
#line 135
      temp = r;
#line 136
      r = r->next;
#line 137
      range_pool_push(temp);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! r) {
#line 141
      goto while_break___0;
    }
#line 149
    if (debug_level & (1 << 7)) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"range.c: ranges_fixup: %lu - %lu\n",
              r->start, r->stop);
      }
    }
#line 156
    if (r->stop == 4294967295UL) {
#line 158
      r->stop = (unsigned long )(req->filesize - 1L);
    } else
#line 156
    if (r->stop >= (unsigned long )req->filesize) {
#line 158
      r->stop = (unsigned long )(req->filesize - 1L);
    }
#line 171
    if ((long )r->start == -1L) {
#line 178
      r->start = (unsigned long )req->filesize - r->stop;
#line 179
      r->stop = (unsigned long )(req->filesize - 1L);
    }
#line 191
    if ((long )r->start < 0L) {
#line 191
      goto _L;
    } else
#line 191
    if (r->start > r->stop) {
      _L: /* CIL Label */ 
#line 194
      temp___0 = r;
#line 195
      if (prev) {
#line 196
        prev->next = r->next;
      }
      {
#line 197
      r = r->next;
#line 198
      range_pool_push(temp___0);
      }
#line 199
      if (debug_level & (1 << 7)) {
        {
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"start or end of range is invalid. skipping.\n");
        }
      }
#line 202
      goto while_continue___0;
    }
#line 208
    if (debug_level & (1 << 7)) {
      {
#line 209
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ending with start: %lu\tstop: %lu\n",
              r->start, r->stop);
      }
    }
#line 212
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 213
      req->ranges = r;
    }
#line 215
    prev = r;
#line 216
    r = r->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  if ((unsigned long )req->ranges == (unsigned long )((void *)0)) {
    {
#line 221
    send_r_invalid_range(req);
    }
#line 222
    return (0);
  }
#line 225
  if (debug_level & (1 << 7)) {
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ranges_fixup returning 1\n");
    }
  }
#line 228
  return (1);
}
}
#line 241 "/home/june/collector/temp/boa-0.94.14rc21/src/range.c"
int range_parse(request *req , char const   *str ) 
{ 
  char const   *initial_str ;
  int tmp ;
  int mode ;
  int ccode ;
  unsigned long start ;
  unsigned long stop ;
  int stable[30] ;
  int c ;
  int fcode ;
  char const   *tmp___0 ;

  {
  {
#line 243
  initial_str = str;
#line 249
  tmp = strncasecmp(str, "bytes=", (size_t )6);
  }
#line 249
  if (tmp) {
    {
#line 251
    log_error_doc(req);
#line 252
    log_error_time();
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"range \"%s\" doesn\'t start with \"bytes=\"\n",
            str);
    }
#line 255
    return (0);
  }
#line 261
  str += 6;
#line 270
  mode = 0;
#line 280
  start = 0UL;
#line 280
  stop = 0UL;
#line 291
  stable[0] = 33;
#line 291
  stable[1] = 0;
#line 291
  stable[2] = 0;
#line 291
  stable[3] = 99;
#line 291
  stable[4] = 0;
#line 291
  stable[5] = 16;
#line 291
  stable[6] = 33;
#line 291
  stable[7] = 2;
#line 291
  stable[8] = 16;
#line 291
  stable[9] = 3;
#line 291
  stable[10] = 16;
#line 291
  stable[11] = 16;
#line 291
  stable[12] = 16;
#line 291
  stable[13] = 2;
#line 291
  stable[14] = 16;
#line 291
  stable[15] = 3;
#line 291
  stable[16] = 16;
#line 291
  stable[17] = 16;
#line 291
  stable[18] = 68;
#line 291
  stable[19] = 3;
#line 291
  stable[20] = 152;
#line 291
  stable[21] = 16;
#line 291
  stable[22] = 152;
#line 291
  stable[23] = 16;
#line 291
  stable[24] = 68;
#line 291
  stable[25] = 24;
#line 291
  stable[26] = 24;
#line 291
  stable[27] = 16;
#line 291
  stable[28] = 24;
#line 291
  stable[29] = 16;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    tmp___0 = str;
#line 304
    str ++;
#line 304
    c = (int )*tmp___0;
    {
#line 318
    if (c == 57) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 56) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 55) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 54) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 53) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 52) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 51) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 50) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 49) {
#line 318
      goto case_57;
    }
#line 318
    if (c == 48) {
#line 318
      goto case_57;
    }
#line 326
    if (c == 11) {
#line 326
      goto case_11;
    }
#line 326
    if (c == 9) {
#line 326
      goto case_11;
    }
#line 326
    if (c == 13) {
#line 326
      goto case_11;
    }
#line 326
    if (c == 10) {
#line 326
      goto case_11;
    }
#line 326
    if (c == 12) {
#line 326
      goto case_11;
    }
#line 326
    if (c == 32) {
#line 326
      goto case_11;
    }
#line 329
    if (c == 44) {
#line 329
      goto case_44;
    }
#line 332
    if (c == 45) {
#line 332
      goto case_45;
    }
#line 335
    if (c == 0) {
#line 335
      goto case_0;
    }
#line 338
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 319
    ccode = 0;
#line 320
    goto switch_break;
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 327
    ccode = 1;
#line 328
    goto switch_break;
    case_44: /* CIL Label */ 
#line 330
    ccode = 2;
#line 331
    goto switch_break;
    case_45: /* CIL Label */ 
#line 333
    ccode = 3;
#line 334
    goto switch_break;
    case_0: /* CIL Label */ 
#line 336
    ccode = 4;
#line 337
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 339
    ccode = 5;
    switch_break: /* CIL Label */ ;
    }
#line 342
    fcode = stable[mode * 6 + ccode];
#line 343
    if ((fcode & 224) == 32) {
#line 344
      start = start * 10UL + (unsigned long )(c - 48);
    } else
#line 345
    if ((fcode & 224) == 96) {
#line 346
      start = 0xffffffffffffffffUL;
    } else
#line 347
    if ((fcode & 224) == 64) {
#line 348
      stop = stop * 10UL + (unsigned long )(c - 48);
    } else
#line 349
    if ((fcode & 224) == 128) {
#line 350
      stop = 0xffffffffffffffffUL;
    }
#line 351
    if ((fcode & 24) == 16) {
      {
#line 352
      log_error_doc(req);
#line 353
      log_error_time();
#line 354
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid range request \"%s\".\n",
              initial_str);
#line 355
      range_abort(req);
      }
#line 356
      return (0);
    } else
#line 357
    if ((fcode & 24) == 24) {
#line 358
      if (start == stop) {
#line 358
        if (start == 4294967295UL) {
          {
#line 360
          log_error_doc(req);
#line 361
          log_error_time();
#line 362
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid range request (neither start nor stop were specified).\n");
#line 363
          range_abort(req);
          }
#line 364
          return (0);
        }
      }
      {
#line 366
      range_add(req, start, stop);
#line 367
      start = 0UL;
#line 368
      stop = 0UL;
      }
    }
#line 370
    if (ccode == 4) {
#line 371
      return (1);
    }
#line 372
    mode = fcode & 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (1);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 293 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 944 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 233 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
uid_t server_uid ;
#line 234
gid_t server_gid ;
#line 238
char *server_ip ;
#line 247
char *pid_file ;
#line 265 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
time_t start_time  ;
#line 267
int pending_requests ;
#line 272
int backlog ;
#line 273 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
time_t current_time  ;
#line 49 "/home/june/collector/temp/boa-0.94.14rc21/src/escape.h"
void build_needs_escape(void) ;
#line 81 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void open_logs(void) ;
#line 151
void create_common_env(void) ;
#line 182
void parse_debug(char *foo ) ;
#line 183
void print_debug_usage(void) ;
#line 216
int bind_server(int sock , char *ip , unsigned int port ) ;
#line 221
void loop(int server_s ) ;
#line 29 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int backlog  =    250;
#line 32 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int debug_level  =    0;
#line 33 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int sighup_flag  =    0;
#line 34 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int sigchld_flag  =    0;
#line 35 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int sigalrm_flag  =    0;
#line 36 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int sigterm_flag  =    0;
#line 38 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int pending_requests  =    0;
#line 40
char const   *config_file_name ;
#line 43
static void usage(char const   *programname ) ;
#line 44
static void parse_commandline(int argc , char **argv ) ;
#line 45
static void fixup_server_root(void) ;
#line 46
static int create_server_socket(void) ;
#line 47
static void drop_privs(void) ;
#line 49 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static int sock_opt  =    1;
#line 50 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static int do_fork  =    1;
#line 52 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
int main(int argc , char **argv ) 
{ 
  int server_s ;
  pid_t pid ;
  int devnullfd ;
  int tmp ;
  FILE *PID_FILE ;
  FILE *tmp___0 ;

  {
  {
#line 59
  umask((__mode_t )63);
#line 62
  time(& current_time);
#line 65
  tzset();
#line 68
  devnullfd = -1;
#line 69
  devnullfd = open("/dev/null", 0);
  }
#line 72
  if (devnullfd == -1) {
    {
#line 73
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 73,
                         "main", "can\'t open /dev/null");
    }
  }
  {
#line 76
  tmp = dup2(devnullfd, 0);
  }
#line 76
  if (tmp == -1) {
    {
#line 77
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 77,
                         "main", "can\'t dup2 /dev/null to STDIN_FILENO");
    }
  }
  {
#line 80
  close(devnullfd);
#line 83
  parse_commandline(argc, argv);
#line 84
  fixup_server_root();
#line 85
  read_config_files();
#line 86
  create_common_env();
#line 87
  open_logs();
#line 88
  server_s = create_server_socket();
#line 89
  init_signals();
#line 90
  build_needs_escape();
  }
#line 93
  if (do_fork) {
    {
#line 94
    pid = fork();
    }
  } else {
    {
#line 96
    pid = getpid();
    }
  }
  {
#line 100
  if (pid == -1) {
#line 100
    goto case_neg_1;
  }
#line 104
  if (pid == 0) {
#line 104
    goto case_0;
  }
#line 107
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 102
  perror("fork/getpid");
#line 103
  exit(1);
  }
  case_0: /* CIL Label */ 
#line 106
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 109
  if ((unsigned long )pid_file != (unsigned long )((void *)0)) {
    {
#line 110
    tmp___0 = fopen((char const   */* __restrict  */)pid_file, (char const   */* __restrict  */)"w");
#line 110
    PID_FILE = tmp___0;
    }
#line 111
    if ((unsigned long )PID_FILE != (unsigned long )((void *)0)) {
      {
#line 112
      fprintf((FILE */* __restrict  */)PID_FILE, (char const   */* __restrict  */)"%d",
              pid);
#line 113
      fclose(PID_FILE);
      }
    } else {
      {
#line 115
      perror("fopen pid file");
      }
    }
  }
#line 119
  if (do_fork) {
    {
#line 120
    exit(0);
    }
  }
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 124
  drop_privs();
#line 126
  timestamp();
#line 128
  status.requests = 0L;
#line 129
  status.errors = 0L;
#line 131
  start_time = current_time;
#line 132
  loop(server_s);
  }
#line 133
  return (0);
}
}
#line 136 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static void usage(char const   *programname ) 
{ 


  {
  {
#line 138
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-c serverroot] [-d] [-f configfile] [-r chroot]%s\n",
          programname, " [-l debug_level]");
#line 148
  print_debug_usage();
#line 150
  exit(1);
  }
}
}
#line 154 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static void parse_commandline(int argc , char **argv ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 158
    c = getopt(argc, (char * const  *)argv, "c:dl:f:r:");
    }
#line 158
    if (! (c != -1)) {
#line 158
      goto while_break;
    }
    {
#line 160
    if (c == 99) {
#line 160
      goto case_99;
    }
#line 169
    if (c == 100) {
#line 169
      goto case_100;
    }
#line 172
    if (c == 102) {
#line 172
      goto case_102;
    }
#line 175
    if (c == 114) {
#line 175
      goto case_114;
    }
#line 193
    if (c == 108) {
#line 193
      goto case_108;
    }
#line 197
    goto switch_default;
    case_99: /* CIL Label */ 
#line 161
    if (server_root) {
      {
#line 162
      free((void *)server_root);
      }
    }
    {
#line 163
    server_root = strdup((char const   *)optarg);
    }
#line 164
    if (! server_root) {
      {
#line 165
      perror("strdup (for server_root)");
#line 166
      exit(1);
      }
    }
#line 168
    goto switch_break;
    case_100: /* CIL Label */ 
#line 170
    do_fork = 0;
#line 171
    goto switch_break;
    case_102: /* CIL Label */ 
#line 173
    config_file_name = (char const   *)optarg;
#line 174
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 176
    tmp = chdir((char const   *)optarg);
    }
#line 176
    if (tmp == -1) {
      {
#line 177
      log_error_time();
#line 178
      perror("chdir (to chroot)");
#line 179
      exit(1);
      }
    }
    {
#line 181
    tmp___0 = chroot((char const   *)optarg);
    }
#line 181
    if (tmp___0 == -1) {
      {
#line 182
      log_error_time();
#line 183
      perror("chroot");
#line 184
      exit(1);
      }
    }
    {
#line 186
    tmp___1 = chdir("/");
    }
#line 186
    if (tmp___1 == -1) {
      {
#line 187
      log_error_time();
#line 188
      perror("chdir (after chroot)");
#line 189
      exit(1);
      }
    }
#line 191
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 194
    parse_debug(optarg);
    }
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 198
    usage((char const   *)*(argv + 0));
#line 199
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static int create_server_socket(void) 
{ 
  int server_s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 208
  server_s = socket(2, 1, 6);
  }
#line 209
  if (server_s == -1) {
    {
#line 210
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 210,
                         "create_server_socket", "unable to create socket");
    }
  }
  {
#line 214
  tmp = fcntl(server_s, 4, 2048);
  }
#line 214
  if (tmp == -1) {
    {
#line 215
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 215,
                         "create_server_socket", "fcntl: unable to set server socket to nonblocking");
    }
  }
  {
#line 219
  tmp___0 = fcntl(server_s, 2, 1);
  }
#line 219
  if (tmp___0 == -1) {
    {
#line 220
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 220,
                         "create_server_socket", "can\'t set close-on-exec on server socket!");
    }
  }
  {
#line 224
  tmp___1 = setsockopt(server_s, 1, 2, (void const   *)((void *)(& sock_opt)), (socklen_t )sizeof(sock_opt));
  }
#line 224
  if (tmp___1 == -1) {
    {
#line 226
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 226,
                         "create_server_socket", "setsockopt");
    }
  }
  {
#line 230
  tmp___2 = bind_server(server_s, server_ip, server_port);
  }
#line 230
  if (tmp___2 == -1) {
    {
#line 231
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 231,
                         "create_server_socket", "unable to bind");
    }
  }
  {
#line 235
  tmp___3 = listen(server_s, backlog);
  }
#line 235
  if (tmp___3 == -1) {
    {
#line 236
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c", 236,
                         "create_server_socket", "unable to listen");
    }
  }
#line 238
  return (server_s);
}
}
#line 241 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static void drop_privs(void) 
{ 
  struct passwd *passwdbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;

  {
  {
#line 244
  tmp___3 = getuid();
  }
#line 244
  if (tmp___3 == 0U) {
    {
#line 246
    passwdbuf = getpwuid(server_uid);
    }
#line 247
    if ((unsigned long )passwdbuf == (unsigned long )((void *)0)) {
      {
#line 248
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c",
                           248, "drop_privs", "getpwuid");
      }
    }
    {
#line 250
    tmp = initgroups((char const   *)passwdbuf->pw_name, passwdbuf->pw_gid);
    }
#line 250
    if (tmp == -1) {
      {
#line 251
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c",
                           251, "drop_privs", "initgroups");
      }
    }
    {
#line 253
    tmp___0 = setgid(server_gid);
    }
#line 253
    if (tmp___0 == -1) {
      {
#line 254
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c",
                           254, "drop_privs", "setgid");
      }
    }
    {
#line 256
    tmp___1 = setuid(server_uid);
    }
#line 256
    if (tmp___1 == -1) {
      {
#line 257
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c",
                           257, "drop_privs", "setuid");
      }
    }
#line 262
    if (server_uid != 0U) {
      {
#line 262
      tmp___2 = setuid((__uid_t )0);
      }
#line 262
      if (tmp___2 != -1) {
        {
#line 263
        log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/boa.c",
                             263, "drop_privs", "icky Linux kernel bug!");
        }
      }
    }
  } else {
#line 266
    if (server_gid) {
      {
#line 267
      log_error_time();
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Not running as root: no attempt to change to uid %u gid %u\n",
              server_uid, server_gid);
      }
    } else
#line 266
    if (server_uid) {
      {
#line 267
      log_error_time();
#line 268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Not running as root: no attempt to change to uid %u gid %u\n",
              server_uid, server_gid);
      }
    }
    {
#line 272
    server_gid = getgid();
#line 273
    server_uid = getuid();
    }
  }
#line 275
  return;
}
}
#line 284 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.c"
static void fixup_server_root(void) 
{ 
  int tmp ;

  {
#line 286
  if (! server_root) {
    {
#line 288
    server_root = strdup("/etc/boa");
    }
#line 289
    if (! server_root) {
      {
#line 290
      perror("strdup (SERVER_ROOT)");
#line 291
      exit(1);
      }
    }
  }
  {
#line 302
  tmp = chdir((char const   *)server_root);
  }
#line 302
  if (tmp == -1) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not chdir to \"%s\": aborting\n",
            server_root);
#line 305
    exit(1);
    }
  }
#line 307
  return;
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 46 "/home/june/collector/temp/boa-0.94.14rc21/src/escape.h"
unsigned long _needs_escape[((128 + (1 << 5)) - 1) / (1 << 5)] ;
#line 187 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
int req_write(request *req , char const   *msg___4 ) ;
#line 188
void reset_output_buffer(request *req ) ;
#line 189
int req_write_escape_http(request *req , char const   *msg___4 ) ;
#line 190
int req_write_escape_html(request *req , char const   *msg___4 ) ;
#line 191
int req_flush(request *req ) ;
#line 193
char *escape_string(char const   *inp , char *buf___0 ) ;
#line 35 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
int req_write(request *req , char const   *msg___4 ) 
{ 
  unsigned int msg_len ;
  size_t tmp ;

  {
  {
#line 39
  tmp = strlen(msg___4);
#line 39
  msg_len = (unsigned int )tmp;
  }
#line 41
  if (! msg_len) {
#line 42
    return (req->buffer_end);
  } else
#line 41
  if ((unsigned int )req->status > 10U) {
#line 42
    return (req->buffer_end);
  }
#line 44
  if ((unsigned int )req->buffer_end + msg_len > 4096U) {
    {
#line 45
    log_error_doc(req);
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"There is not enough room in the buffer to copy %u bytes (%d available). Shutting down connection.\n",
            msg_len, 4096 - req->buffer_end);
#line 55
    req->status = (enum REQ_STATUS )12;
    }
#line 56
    return (-1);
  }
  {
#line 58
  memcpy((void */* __restrict  */)(req->buffer + req->buffer_end), (void const   */* __restrict  */)msg___4,
         (size_t )msg_len);
#line 59
  req->buffer_end = (int )((unsigned int )req->buffer_end + msg_len);
  }
#line 60
  return (req->buffer_end);
}
}
#line 63 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
void reset_output_buffer(request *req ) 
{ 


  {
#line 65
  req->buffer_end = 0;
#line 66
  return;
}
}
#line 75 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
int req_write_escape_http(request *req , char const   *msg___4 ) 
{ 
  char c ;
  char *dest ;
  char const   *inp ;
  int skip ;
  int left ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 80
  skip = 0;
#line 82
  inp = msg___4;
#line 83
  dest = req->buffer + req->buffer_end;
#line 86
  left = 4096 - req->buffer_end;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    tmp___3 = inp;
#line 87
    inp ++;
#line 87
    c = (char )*tmp___3;
#line 87
    if (c) {
#line 87
      if (! (left >= 3)) {
#line 87
        goto while_break;
      }
    } else {
#line 87
      goto while_break;
    }
#line 89
    if (skip) {
#line 89
      skip --;
    }
#line 91
    if ((int )c == 37) {
#line 91
      skip = 2;
    }
#line 93
    if (! skip) {
#line 93
      if ((unsigned int )c >= 128U) {
#line 93
        goto _L;
      } else
#line 93
      if (_needs_escape[(unsigned int )c >> 5] & (unsigned long )(1 << ((unsigned int )c & (unsigned int )((1 << 5) - 1)))) {
        _L: /* CIL Label */ 
#line 94
        tmp = dest;
#line 94
        dest ++;
#line 94
        *tmp = (char )'%';
#line 95
        tmp___0 = dest;
#line 95
        dest ++;
#line 95
        if ((((int )c >> 4) & 15) > 9) {
#line 95
          *tmp___0 = (char )(87 + (((int )c >> 4) & 15));
        } else {
#line 95
          *tmp___0 = (char )(48 + (((int )c >> 4) & 15));
        }
#line 96
        tmp___1 = dest;
#line 96
        dest ++;
#line 96
        if (((int )c & 15) > 9) {
#line 96
          *tmp___1 = (char )(87 + ((int )c & 15));
        } else {
#line 96
          *tmp___1 = (char )(48 + ((int )c & 15));
        }
#line 97
        left -= 3;
      } else {
#line 99
        tmp___2 = dest;
#line 99
        dest ++;
#line 99
        *tmp___2 = c;
#line 100
        left --;
      }
    } else {
#line 99
      tmp___2 = dest;
#line 99
      dest ++;
#line 99
      *tmp___2 = c;
#line 100
      left --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  inp --;
#line 104
  req->buffer_end = (int )(dest - req->buffer);
#line 115
  if ((int const   )*inp != 0) {
    {
#line 116
    log_error_doc(req);
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of Buffer space! [req_write_escape_http]\n");
#line 118
    req->status = (enum REQ_STATUS )12;
    }
#line 119
    return (-1);
  }
#line 121
  return (req->buffer_end);
}
}
#line 131 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
int req_write_escape_html(request *req , char const   *msg___4 ) 
{ 
  char c ;
  char *dest ;
  char const   *inp ;
  int left ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;

  {
#line 137
  inp = msg___4;
#line 138
  dest = req->buffer + req->buffer_end;
#line 142
  left = 4096 - req->buffer_end;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    tmp___19 = inp;
#line 143
    inp ++;
#line 143
    c = (char )*tmp___19;
#line 143
    if (c) {
#line 143
      if (! (left >= 6)) {
#line 143
        goto while_break;
      }
    } else {
#line 143
      goto while_break;
    }
    {
#line 145
    if ((int )c == 62) {
#line 145
      goto case_62;
    }
#line 152
    if ((int )c == 60) {
#line 152
      goto case_60;
    }
#line 159
    if ((int )c == 38) {
#line 159
      goto case_38;
    }
#line 167
    if ((int )c == 34) {
#line 167
      goto case_34;
    }
#line 176
    goto switch_default;
    case_62: /* CIL Label */ 
#line 146
    tmp = dest;
#line 146
    dest ++;
#line 146
    *tmp = (char )'&';
#line 147
    tmp___0 = dest;
#line 147
    dest ++;
#line 147
    *tmp___0 = (char )'g';
#line 148
    tmp___1 = dest;
#line 148
    dest ++;
#line 148
    *tmp___1 = (char )'t';
#line 149
    tmp___2 = dest;
#line 149
    dest ++;
#line 149
    *tmp___2 = (char )';';
#line 150
    left -= 4;
#line 151
    goto switch_break;
    case_60: /* CIL Label */ 
#line 153
    tmp___3 = dest;
#line 153
    dest ++;
#line 153
    *tmp___3 = (char )'&';
#line 154
    tmp___4 = dest;
#line 154
    dest ++;
#line 154
    *tmp___4 = (char )'l';
#line 155
    tmp___5 = dest;
#line 155
    dest ++;
#line 155
    *tmp___5 = (char )'t';
#line 156
    tmp___6 = dest;
#line 156
    dest ++;
#line 156
    *tmp___6 = (char )';';
#line 157
    left -= 4;
#line 158
    goto switch_break;
    case_38: /* CIL Label */ 
#line 160
    tmp___7 = dest;
#line 160
    dest ++;
#line 160
    *tmp___7 = (char )'&';
#line 161
    tmp___8 = dest;
#line 161
    dest ++;
#line 161
    *tmp___8 = (char )'a';
#line 162
    tmp___9 = dest;
#line 162
    dest ++;
#line 162
    *tmp___9 = (char )'m';
#line 163
    tmp___10 = dest;
#line 163
    dest ++;
#line 163
    *tmp___10 = (char )'p';
#line 164
    tmp___11 = dest;
#line 164
    dest ++;
#line 164
    *tmp___11 = (char )';';
#line 165
    left -= 5;
#line 166
    goto switch_break;
    case_34: /* CIL Label */ 
#line 168
    tmp___12 = dest;
#line 168
    dest ++;
#line 168
    *tmp___12 = (char )'&';
#line 169
    tmp___13 = dest;
#line 169
    dest ++;
#line 169
    *tmp___13 = (char )'q';
#line 170
    tmp___14 = dest;
#line 170
    dest ++;
#line 170
    *tmp___14 = (char )'u';
#line 171
    tmp___15 = dest;
#line 171
    dest ++;
#line 171
    *tmp___15 = (char )'o';
#line 172
    tmp___16 = dest;
#line 172
    dest ++;
#line 172
    *tmp___16 = (char )'t';
#line 173
    tmp___17 = dest;
#line 173
    dest ++;
#line 173
    *tmp___17 = (char )';';
#line 174
    left -= 6;
#line 175
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 177
    tmp___18 = dest;
#line 177
    dest ++;
#line 177
    *tmp___18 = c;
#line 178
    left --;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  inp --;
#line 182
  req->buffer_end = (int )(dest - req->buffer);
#line 193
  if ((int const   )*inp != 0) {
    {
#line 194
    log_error_doc(req);
#line 195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of Buffer space (%d chars left)! [req_write_escape_html]\n",
            left);
#line 197
    req->status = (enum REQ_STATUS )12;
    }
#line 198
    return (-1);
  }
#line 200
  return (req->buffer_end);
}
}
#line 212 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
int req_flush(request *req ) 
{ 
  unsigned int bytes_to_write ;
  off_t bytes_written ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 216
  bytes_to_write = (unsigned int )(req->buffer_end - req->buffer_start);
#line 217
  if ((unsigned int )req->status > 10U) {
#line 218
    return (-2);
  }
#line 220
  if (bytes_to_write) {
    {
#line 223
    bytes_written = write(req->fd, (void const   *)(req->buffer + req->buffer_start),
                          (size_t )bytes_to_write);
    }
#line 226
    if (bytes_written < 0L) {
      {
#line 227
      tmp___0 = __errno_location();
      }
#line 227
      if (*tmp___0 == 11) {
#line 228
        return (-1);
      } else {
        {
#line 227
        tmp___1 = __errno_location();
        }
#line 227
        if (*tmp___1 == 11) {
#line 228
          return (-1);
        } else {
          {
#line 230
          tmp = 0;
#line 230
          req->buffer_end = tmp;
#line 230
          req->buffer_start = tmp;
#line 236
          log_error_doc(req);
#line 237
          perror("buffer flush");
#line 239
          req->status = (enum REQ_STATUS )12;
#line 240
          req->buffer_end = 0;
          }
#line 241
          return (-2);
        }
      }
    }
#line 251
    req->buffer_start = (int )((off_t )req->buffer_start + bytes_written);
  }
#line 253
  if (req->buffer_start == req->buffer_end) {
#line 254
    tmp___2 = 0;
#line 254
    req->buffer_end = tmp___2;
#line 254
    req->buffer_start = tmp___2;
  }
#line 255
  return (req->buffer_end);
}
}
#line 277 "/home/june/collector/temp/boa-0.94.14rc21/src/buffer.c"
char *escape_string(char const   *inp , char *buf___0 ) 
{ 
  int max ;
  char *ix ;
  unsigned char c ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 283
  tmp = strlen(inp);
#line 283
  max = (int )(tmp * 3UL);
  }
#line 285
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 285
    if (max) {
      {
#line 286
      tmp___0 = malloc(sizeof(char ) * (unsigned long )(max + 1));
#line 286
      buf___0 = (char *)tmp___0;
      }
    }
  }
#line 288
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
    {
#line 289
    log_error_time();
#line 290
    perror("malloc");
    }
#line 291
    return ((char *)((void *)0));
  }
#line 294
  ix = buf___0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    tmp___5 = inp;
#line 295
    inp ++;
#line 295
    c = (unsigned char )*tmp___5;
#line 295
    if (c) {
#line 295
      if (! (max > 0)) {
#line 295
        goto while_break;
      }
    } else {
#line 295
      goto while_break;
    }
#line 296
    if ((unsigned int )c >= 128U) {
#line 296
      goto _L;
    } else
#line 296
    if (_needs_escape[(unsigned int )c >> 5] & (unsigned long )(1 << ((unsigned int )c & (unsigned int )((1 << 5) - 1)))) {
      _L: /* CIL Label */ 
#line 297
      tmp___1 = ix;
#line 297
      ix ++;
#line 297
      *tmp___1 = (char )'%';
#line 298
      tmp___2 = ix;
#line 298
      ix ++;
#line 298
      if ((((int )c >> 4) & 15) > 9) {
#line 298
        *tmp___2 = (char )(87 + (((int )c >> 4) & 15));
      } else {
#line 298
        *tmp___2 = (char )(48 + (((int )c >> 4) & 15));
      }
#line 299
      tmp___3 = ix;
#line 299
      ix ++;
#line 299
      if (((int )c & 15) > 9) {
#line 299
        *tmp___3 = (char )(87 + ((int )c & 15));
      } else {
#line 299
        *tmp___3 = (char )(48 + ((int )c & 15));
      }
    } else {
#line 301
      tmp___4 = ix;
#line 301
      ix ++;
#line 301
      *tmp___4 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  *ix = (char )'\000';
#line 304
  return (buf___0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 623
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template )  __asm__("mkstemp64")  ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 230 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int use_localtime ;
#line 167 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void clean_pathname(char *pathname___0 ) ;
#line 168
char *get_commonlog_time(void) ;
#line 169
void rfc822_time_buf(char *buf___0 , time_t s ) ;
#line 170
char *simple_itoa(uint64_t i ) ;
#line 171
int boa_atoi(char const   *s ) ;
#line 172
int month2int(char const   *monthname ) ;
#line 173
int modified_since(time_t *mtime , char const   *if_modified_since ) ;
#line 174
int unescape_uri(char *uri , char **query_string ) ;
#line 175
int create_temporary_file(short want_unlink , char *storage , unsigned int size ) ;
#line 176
int real_set_block_fd(int fd ) ;
#line 177
int real_set_nonblock_fd(int fd ) ;
#line 178
char *to_upper(char *str ) ;
#line 179
void strlower(char *s ) ;
#line 180
int check_host(char const   *r ) ;
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static int date_to_tm(struct tm *parsed_gmt , char const   *cmtime ) ;
#line 31 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static char const   month_tab[48]  = 
#line 31
  {      (char const   )'J',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'F',      (char const   )'e',      (char const   )'b',      (char const   )' ', 
        (char const   )'M',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'A',      (char const   )'p',      (char const   )'r',      (char const   )' ', 
        (char const   )'M',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'J',      (char const   )'u',      (char const   )'n',      (char const   )' ', 
        (char const   )'J',      (char const   )'u',      (char const   )'l',      (char const   )' ', 
        (char const   )'A',      (char const   )'u',      (char const   )'g',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'p',      (char const   )' ', 
        (char const   )'O',      (char const   )'c',      (char const   )'t',      (char const   )' ', 
        (char const   )'N',      (char const   )'o',      (char const   )'v',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'c',      (char const   )' '};
#line 33 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static char const   day_tab[28]  = 
#line 33
  {      (char const   )'S',      (char const   )'u',      (char const   )'n',      (char const   )',', 
        (char const   )'M',      (char const   )'o',      (char const   )'n',      (char const   )',', 
        (char const   )'T',      (char const   )'u',      (char const   )'e',      (char const   )',', 
        (char const   )'W',      (char const   )'e',      (char const   )'d',      (char const   )',', 
        (char const   )'T',      (char const   )'h',      (char const   )'u',      (char const   )',', 
        (char const   )'F',      (char const   )'r',      (char const   )'i',      (char const   )',', 
        (char const   )'S',      (char const   )'a',      (char const   )'t',      (char const   )','};
#line 45 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
void clean_pathname(char *pathname___0 ) 
{ 
  char *cleanpath ;
  char c ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 49
  cleanpath = pathname___0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    tmp___0 = pathname___0;
#line 50
    pathname___0 ++;
#line 50
    c = *tmp___0;
#line 50
    if (! c) {
#line 50
      goto while_break;
    }
#line 51
    if ((int )c == 47) {
      {
#line 52
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 53
        if ((int )*pathname___0 == 47) {
#line 54
          pathname___0 ++;
        } else
#line 55
        if ((int )*pathname___0 == 46) {
#line 55
          if ((int )*(pathname___0 + 1) == 47) {
#line 56
            pathname___0 += 2;
          } else {
#line 55
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 57
        if ((int )*pathname___0 == 46) {
#line 57
          if ((int )*(pathname___0 + 1) == 46) {
#line 57
            if ((int )*(pathname___0 + 2) == 47) {
#line 59
              pathname___0 += 3;
            } else {
#line 61
              goto while_break___0;
            }
          } else {
#line 61
            goto while_break___0;
          }
        } else {
#line 61
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 63
      c = (char )'/';
    }
#line 65
    tmp = cleanpath;
#line 65
    cleanpath ++;
#line 65
    *tmp = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  *cleanpath = (char )'\000';
#line 69
  return;
}
}
#line 151 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static char buf[30]  ;
#line 146 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
char *get_commonlog_time(void) 
{ 
  struct tm *t ;
  char *p ;
  unsigned int a ;
  int time_offset ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 154
  if (use_localtime) {
    {
#line 155
    t = localtime((time_t const   *)(& current_time));
#line 156
    time_offset = (int )t->tm_gmtoff;
    }
  } else {
    {
#line 158
    t = gmtime((time_t const   *)(& current_time));
#line 159
    time_offset = 0;
    }
  }
  {
#line 162
  p = buf + 29;
#line 163
  tmp = p;
#line 163
  p --;
#line 163
  *tmp = (char )'\000';
#line 164
  tmp___0 = p;
#line 164
  p --;
#line 164
  *tmp___0 = (char )' ';
#line 165
  tmp___1 = p;
#line 165
  p --;
#line 165
  *tmp___1 = (char )']';
#line 166
  tmp___2 = abs(time_offset / 60);
#line 166
  a = (unsigned int )tmp___2;
#line 167
  tmp___3 = p;
#line 167
  p --;
#line 167
  *tmp___3 = (char )(48U + a % 10U);
#line 168
  a /= 10U;
#line 169
  tmp___4 = p;
#line 169
  p --;
#line 169
  *tmp___4 = (char )(48U + a % 6U);
#line 170
  a /= 6U;
#line 171
  tmp___5 = p;
#line 171
  p --;
#line 171
  *tmp___5 = (char )(48U + a % 10U);
#line 172
  tmp___6 = p;
#line 172
  p --;
#line 172
  *tmp___6 = (char )(48U + a / 10U);
#line 173
  tmp___7 = p;
#line 173
  p --;
  }
#line 173
  if (time_offset >= 0) {
#line 173
    *tmp___7 = (char )'+';
  } else {
#line 173
    *tmp___7 = (char )'-';
  }
#line 174
  tmp___8 = p;
#line 174
  p --;
#line 174
  *tmp___8 = (char )' ';
#line 176
  a = (unsigned int )t->tm_sec;
#line 177
  tmp___9 = p;
#line 177
  p --;
#line 177
  *tmp___9 = (char )(48U + a % 10U);
#line 178
  tmp___10 = p;
#line 178
  p --;
#line 178
  *tmp___10 = (char )(48U + a / 10U);
#line 179
  tmp___11 = p;
#line 179
  p --;
#line 179
  *tmp___11 = (char )':';
#line 180
  a = (unsigned int )t->tm_min;
#line 181
  tmp___12 = p;
#line 181
  p --;
#line 181
  *tmp___12 = (char )(48U + a % 10U);
#line 182
  tmp___13 = p;
#line 182
  p --;
#line 182
  *tmp___13 = (char )(48U + a / 10U);
#line 183
  tmp___14 = p;
#line 183
  p --;
#line 183
  *tmp___14 = (char )':';
#line 184
  a = (unsigned int )t->tm_hour;
#line 185
  tmp___15 = p;
#line 185
  p --;
#line 185
  *tmp___15 = (char )(48U + a % 10U);
#line 186
  tmp___16 = p;
#line 186
  p --;
#line 186
  *tmp___16 = (char )(48U + a / 10U);
#line 187
  tmp___17 = p;
#line 187
  p --;
#line 187
  *tmp___17 = (char )':';
#line 188
  a = (unsigned int )(1900 + t->tm_year);
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! a) {
#line 189
      goto while_break;
    }
#line 190
    tmp___18 = p;
#line 190
    p --;
#line 190
    *tmp___18 = (char )(48U + a % 10U);
#line 191
    a /= 10U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  tmp___19 = p;
#line 194
  p --;
#line 194
  *tmp___19 = (char )'/';
#line 195
  p -= 2;
#line 196
  tmp___20 = p;
#line 196
  p --;
#line 196
  memcpy((void */* __restrict  */)tmp___20, (void const   */* __restrict  */)(month_tab + 4 * t->tm_mon),
         (size_t )3);
#line 197
  tmp___21 = p;
#line 197
  p --;
#line 197
  *tmp___21 = (char )'/';
#line 198
  a = (unsigned int )t->tm_mday;
#line 199
  tmp___22 = p;
#line 199
  p --;
#line 199
  *tmp___22 = (char )(48U + a % 10U);
#line 200
  tmp___23 = p;
#line 200
  p --;
#line 200
  *tmp___23 = (char )(48U + a / 10U);
#line 201
  *p = (char )'[';
  }
#line 202
  return (p);
}
}
#line 213 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int month2int(char const   *monthname ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 216
  if ((int const   )*monthname == 65) {
#line 216
    goto case_65;
  }
#line 218
  if ((int const   )*monthname == 68) {
#line 218
    goto case_68;
  }
#line 220
  if ((int const   )*monthname == 70) {
#line 220
    goto case_70;
  }
#line 222
  if ((int const   )*monthname == 74) {
#line 222
    goto case_74;
  }
#line 226
  if ((int const   )*monthname == 77) {
#line 226
    goto case_77;
  }
#line 228
  if ((int const   )*monthname == 78) {
#line 228
    goto case_78;
  }
#line 230
  if ((int const   )*monthname == 79) {
#line 230
    goto case_79;
  }
#line 232
  if ((int const   )*monthname == 83) {
#line 232
    goto case_83;
  }
#line 234
  goto switch_default;
  case_65: /* CIL Label */ 
#line 217
  monthname ++;
#line 217
  if ((int const   )*monthname == 112) {
#line 217
    tmp = 3;
  } else {
#line 217
    tmp = 7;
  }
#line 217
  return (tmp);
  case_68: /* CIL Label */ 
#line 219
  return (11);
  case_70: /* CIL Label */ 
#line 221
  return (1);
  case_74: /* CIL Label */ 
#line 223
  monthname ++;
#line 223
  if ((int const   )*monthname == 97) {
#line 224
    return (0);
  }
#line 225
  monthname ++;
#line 225
  if ((int const   )*monthname == 110) {
#line 225
    tmp___0 = 5;
  } else {
#line 225
    tmp___0 = 6;
  }
#line 225
  return (tmp___0);
  case_77: /* CIL Label */ 
#line 227
  if ((int const   )*(monthname + 2) == 114) {
#line 227
    tmp___1 = 2;
  } else {
#line 227
    tmp___1 = 4;
  }
#line 227
  return (tmp___1);
  case_78: /* CIL Label */ 
#line 229
  return (10);
  case_79: /* CIL Label */ 
#line 231
  return (9);
  case_83: /* CIL Label */ 
#line 233
  return (8);
  switch_default: /* CIL Label */ 
#line 235
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 253 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static int date_to_tm(struct tm *parsed_gmt , char const   *cmtime ) 
{ 
  char monthname[11] ;
  char const   *cmtime_start ;
  int day ;
  int year ;
  int hour ;
  int minute ;
  int second ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 256
  cmtime_start = cmtime;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if ((int const   )*cmtime != 32) {
#line 260
      if (! ((int const   )*cmtime != 0)) {
#line 260
        goto while_break;
      }
    } else {
#line 260
      goto while_break;
    }
#line 261
    cmtime ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if ((int const   )*cmtime != 32) {
#line 264
    return (-1);
  }
  {
#line 266
  tmp___2 = sscanf((char const   */* __restrict  */)cmtime, (char const   */* __restrict  */)"%d %3s %d %d:%d:%d GMT",
                   & day, monthname, & year, & hour, & minute, & second);
  }
#line 266
  if (! (tmp___2 == 6)) {
    {
#line 268
    tmp___1 = sscanf((char const   */* __restrict  */)cmtime, (char const   */* __restrict  */)"%d-%3s-%d %d:%d:%d GMT",
                     & day, monthname, & year, & hour, & minute, & second);
    }
#line 268
    if (! (tmp___1 == 6)) {
      {
#line 270
      tmp___0 = sscanf((char const   */* __restrict  */)cmtime, (char const   */* __restrict  */)"%3s %d %d:%d:%d %d",
                       monthname, & day, & hour, & minute, & second, & year);
      }
#line 270
      if (! (tmp___0 == 6)) {
        {
#line 277
        tmp = sscanf((char const   */* __restrict  */)cmtime_start, (char const   */* __restrict  */)"%d %10s %d %d:%d:%d GMT",
                     & day, monthname, & year, & hour, & minute, & second);
        }
#line 277
        if (! (tmp == 6)) {
          {
#line 280
          log_error_time();
#line 281
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in %s, line %d: Unable to sscanf \"%s\"\n",
                  "/home/june/collector/temp/boa-0.94.14rc21/src/util.c", 283, cmtime);
          }
#line 284
          return (-1);
        }
      }
    }
  }
#line 287
  if (year < 70) {
#line 288
    year += 100;
  }
#line 289
  if (year > 1900) {
#line 290
    year -= 1900;
  }
  {
#line 292
  parsed_gmt->tm_sec = second;
#line 293
  parsed_gmt->tm_min = minute;
#line 294
  parsed_gmt->tm_hour = hour;
#line 295
  parsed_gmt->tm_mday = day;
#line 296
  parsed_gmt->tm_mon = month2int((char const   *)(monthname));
#line 297
  parsed_gmt->tm_year = year;
#line 298
  parsed_gmt->tm_wday = 0;
#line 299
  parsed_gmt->tm_yday = 0;
#line 300
  parsed_gmt->tm_isdst = 0;
  }
#line 302
  if (parsed_gmt->tm_mon == -1) {
    {
#line 303
    log_error_time();
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid month name: \"%s\"\n",
            monthname);
    }
#line 305
    return (-1);
  }
#line 309
  if (parsed_gmt->tm_sec < 0) {
#line 310
    return (-1);
  } else
#line 309
  if (parsed_gmt->tm_sec > 59) {
#line 310
    return (-1);
  }
#line 311
  if (parsed_gmt->tm_min < 0) {
#line 312
    return (-1);
  } else
#line 311
  if (parsed_gmt->tm_min > 59) {
#line 312
    return (-1);
  }
#line 313
  if (parsed_gmt->tm_hour < 0) {
#line 314
    return (-1);
  } else
#line 313
  if (parsed_gmt->tm_hour > 23) {
#line 314
    return (-1);
  }
#line 315
  if (parsed_gmt->tm_mday < 1) {
#line 316
    return (-1);
  } else
#line 315
  if (parsed_gmt->tm_mday > 31) {
#line 316
    return (-1);
  }
#line 317
  if (parsed_gmt->tm_mon < 0) {
#line 318
    return (-1);
  } else
#line 317
  if (parsed_gmt->tm_mon > 11) {
#line 318
    return (-1);
  }
#line 319
  if (parsed_gmt->tm_year < 70) {
#line 320
    return (-1);
  } else
#line 319
  if (parsed_gmt->tm_year > 120) {
#line 320
    return (-1);
  }
#line 322
  return (0);
}
}
#line 337 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int modified_since(time_t *mtime , char const   *if_modified_since ) 
{ 
  struct tm *file_gmt ;
  struct tm parsed_gmt ;
  int comp ;
  int tmp ;

  {
  {
#line 343
  tmp = date_to_tm(& parsed_gmt, if_modified_since);
  }
#line 343
  if (tmp != 0) {
#line 344
    return (-1);
  }
  {
#line 347
  file_gmt = gmtime((time_t const   *)mtime);
#line 351
  comp = file_gmt->tm_year - parsed_gmt.tm_year;
  }
#line 351
  if (comp) {
#line 352
    return (comp > 0);
  }
#line 353
  comp = file_gmt->tm_mon - parsed_gmt.tm_mon;
#line 353
  if (comp) {
#line 354
    return (comp > 0);
  }
#line 355
  comp = file_gmt->tm_mday - parsed_gmt.tm_mday;
#line 355
  if (comp) {
#line 356
    return (comp > 0);
  }
#line 357
  comp = file_gmt->tm_hour - parsed_gmt.tm_hour;
#line 357
  if (comp) {
#line 358
    return (comp > 0);
  }
#line 359
  comp = file_gmt->tm_min - parsed_gmt.tm_min;
#line 359
  if (comp) {
#line 360
    return (comp > 0);
  }
#line 361
  comp = file_gmt->tm_sec - parsed_gmt.tm_sec;
#line 361
  if (comp) {
#line 362
    return (comp > 0);
  }
#line 365
  return (0);
}
}
#line 375 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
char *to_upper(char *str ) 
{ 
  char *start ;
  int tmp ;

  {
#line 377
  start = str;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! *str) {
#line 379
      goto while_break;
    }
#line 380
    if ((int )*str == 45) {
#line 381
      *str = (char )'_';
    } else {
      {
#line 383
      tmp = toupper((int )*str);
#line 383
      *str = (char )tmp;
      }
    }
#line 384
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  return (start);
}
}
#line 401 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int unescape_uri(char *uri , char **query_string ) 
{ 
  char c ;
  char d ;
  char *uri_old ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 406
  uri_old = uri;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    c = *uri_old;
#line 408
    if (! c) {
#line 408
      goto while_break;
    }
#line 409
    if ((int )c == 37) {
#line 410
      uri_old ++;
#line 411
      tmp___1 = uri_old;
#line 411
      uri_old ++;
#line 411
      c = *tmp___1;
#line 411
      if (c) {
#line 411
        tmp___2 = uri_old;
#line 411
        uri_old ++;
#line 411
        d = *tmp___2;
#line 411
        if (d) {
#line 412
          if ((int )c >= 65) {
#line 412
            tmp = (((int )c & 223) - 65) + 10;
          } else {
#line 412
            tmp = (int )c - 48;
          }
#line 412
          if ((int )d >= 65) {
#line 412
            tmp___0 = (((int )d & 223) - 65) + 10;
          } else {
#line 412
            tmp___0 = (int )d - 48;
          }
#line 412
          *uri = (char )(tmp * 16 + tmp___0);
        } else {
#line 414
          *uri = (char )'\000';
#line 415
          return (0);
        }
      } else {
#line 414
        *uri = (char )'\000';
#line 415
        return (0);
      }
#line 417
      uri ++;
    } else
#line 418
    if ((int )c == 63) {
#line 419
      if (query_string) {
#line 420
        uri_old ++;
#line 420
        *query_string = uri_old;
      }
#line 422
      *uri = (char )'\000';
#line 423
      return (1);
    } else
#line 424
    if ((int )c == 35) {
#line 427
      if (query_string) {
#line 428
        uri_old ++;
        {
#line 429
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 429
          c = *uri_old;
#line 429
          if (! c) {
#line 429
            goto while_break___0;
          }
#line 430
          if ((int )c == 63) {
#line 431
            uri_old ++;
#line 431
            *query_string = uri_old;
#line 432
            goto while_break___0;
          }
#line 434
          uri_old ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 437
      goto while_break;
    } else {
#line 439
      tmp___3 = uri;
#line 439
      uri ++;
#line 439
      *tmp___3 = c;
#line 440
      uri_old ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  *uri = (char )'\000';
#line 445
  return (1);
}
}
#line 452 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
void rfc822_time_buf(char *buf___0 , time_t s ) 
{ 
  struct tm *t ;
  char *p ;
  unsigned int a ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 458
  if (! s) {
    {
#line 459
    t = gmtime((time_t const   *)(& current_time));
    }
  } else {
    {
#line 461
    t = gmtime((time_t const   *)(& s));
    }
  }
  {
#line 463
  p = buf___0 + 28;
#line 466
  p -= 3;
#line 468
  tmp = p;
#line 468
  p --;
#line 468
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)" GMT", (size_t )4);
#line 470
  a = (unsigned int )t->tm_sec;
#line 471
  tmp___0 = p;
#line 471
  p --;
#line 471
  *tmp___0 = (char )(48U + a % 10U);
#line 472
  tmp___1 = p;
#line 472
  p --;
#line 472
  *tmp___1 = (char )(48U + a / 10U);
#line 473
  tmp___2 = p;
#line 473
  p --;
#line 473
  *tmp___2 = (char )':';
#line 474
  a = (unsigned int )t->tm_min;
#line 475
  tmp___3 = p;
#line 475
  p --;
#line 475
  *tmp___3 = (char )(48U + a % 10U);
#line 476
  tmp___4 = p;
#line 476
  p --;
#line 476
  *tmp___4 = (char )(48U + a / 10U);
#line 477
  tmp___5 = p;
#line 477
  p --;
#line 477
  *tmp___5 = (char )':';
#line 478
  a = (unsigned int )t->tm_hour;
#line 479
  tmp___6 = p;
#line 479
  p --;
#line 479
  *tmp___6 = (char )(48U + a % 10U);
#line 480
  tmp___7 = p;
#line 480
  p --;
#line 480
  *tmp___7 = (char )(48U + a / 10U);
#line 481
  tmp___8 = p;
#line 481
  p --;
#line 481
  *tmp___8 = (char )' ';
#line 482
  a = (unsigned int )(1900 + t->tm_year);
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! a) {
#line 483
      goto while_break;
    }
#line 484
    tmp___9 = p;
#line 484
    p --;
#line 484
    *tmp___9 = (char )(48U + a % 10U);
#line 485
    a /= 10U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 488
  p -= 3;
#line 490
  tmp___10 = p;
#line 490
  p --;
#line 490
  memcpy((void */* __restrict  */)tmp___10, (void const   */* __restrict  */)(month_tab + 4 * t->tm_mon),
         (size_t )4);
#line 491
  tmp___11 = p;
#line 491
  p --;
#line 491
  *tmp___11 = (char )' ';
#line 492
  a = (unsigned int )t->tm_mday;
#line 493
  tmp___12 = p;
#line 493
  p --;
#line 493
  *tmp___12 = (char )(48U + a % 10U);
#line 494
  tmp___13 = p;
#line 494
  p --;
#line 494
  *tmp___13 = (char )(48U + a / 10U);
#line 495
  tmp___14 = p;
#line 495
  p --;
#line 495
  *tmp___14 = (char )' ';
#line 496
  p -= 3;
#line 497
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(day_tab + t->tm_wday * 4),
         (size_t )4);
  }
#line 498
  return;
}
}
#line 508 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static char local[22]  ;
#line 500 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
char *simple_itoa(uint64_t i ) 
{ 
  char *p ;

  {
#line 509
  p = & local[21];
#line 510
  *p = (char )'\000';
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    p --;
#line 512
    *p = (char )(48UL + i % 10UL);
#line 513
    i /= 10UL;
#line 511
    if (! (i != 0UL)) {
#line 511
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return (p);
}
}
#line 522 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int boa_atoi(char const   *s ) 
{ 
  int retval ;
  char *reconv ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 527
  tmp = __ctype_b_loc();
  }
#line 527
  if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 528
    return (-1);
  }
  {
#line 530
  retval = atoi(s);
  }
#line 531
  if (retval < 0) {
#line 532
    return (-1);
  }
  {
#line 534
  reconv = simple_itoa((uint64_t )((unsigned int )retval));
#line 535
  tmp___0 = strlen(s);
#line 535
  tmp___1 = memcmp((void const   *)s, (void const   *)reconv, tmp___0);
  }
#line 535
  if (tmp___1 != 0) {
#line 536
    return (-1);
  }
#line 538
  return (retval);
}
}
#line 543 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static char boa_tempfile[4097]  ;
#line 541 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int create_temporary_file(short want_unlink , char *storage , unsigned int size ) 
{ 
  int fd ;
  unsigned int len___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 546
  snprintf((char */* __restrict  */)(boa_tempfile), (size_t )4096, (char const   */* __restrict  */)"%s/boa-temp.XXXXXX",
           tempdir);
#line 549
  fd = mkstemp(boa_tempfile);
  }
#line 550
  if (fd == -1) {
    {
#line 551
    log_error_time();
#line 552
    perror("mkstemp");
    }
#line 553
    return (0);
  }
#line 556
  if ((unsigned long )storage != (unsigned long )((void *)0)) {
    {
#line 557
    tmp = strlen((char const   *)(boa_tempfile));
#line 557
    len___0 = (unsigned int )tmp;
    }
#line 559
    if (len___0 < size) {
      {
#line 560
      memcpy((void */* __restrict  */)storage, (void const   */* __restrict  */)(boa_tempfile),
             (size_t )(len___0 + 1U));
      }
    } else {
      {
#line 562
      close(fd);
#line 563
      fd = 0;
#line 564
      log_error_time();
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not enough memory for memcpy in storage\n");
#line 566
      want_unlink = (short)1;
      }
    }
  }
#line 570
  if (want_unlink) {
    {
#line 571
    tmp___0 = unlink((char const   *)(boa_tempfile));
    }
#line 571
    if (tmp___0 == -1) {
      {
#line 572
      close(fd);
#line 573
      fd = 0;
#line 574
      log_error_time();
#line 575
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unlink temp file\n");
      }
    }
  }
#line 579
  return (fd);
}
}
#line 582 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int real_set_block_fd(int fd ) 
{ 
  int flags ;

  {
  {
#line 586
  flags = fcntl(fd, 3);
  }
#line 587
  if (flags == -1) {
#line 588
    return (-1);
  }
  {
#line 590
  flags &= -2049;
#line 591
  flags = fcntl(fd, 4, flags);
  }
#line 592
  return (flags);
}
}
#line 595 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int real_set_nonblock_fd(int fd ) 
{ 
  int flags ;

  {
  {
#line 599
  flags = fcntl(fd, 3);
  }
#line 600
  if (flags == -1) {
#line 601
    return (-1);
  }
  {
#line 603
  flags |= 2048;
#line 604
  flags = fcntl(fd, 4, flags);
  }
#line 605
  return (flags);
}
}
#line 636 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
int check_host(char const   *r ) 
{ 
  char const   *c ;
  short period_ok ;
  short len___0 ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 650
  period_ok = (short)0;
#line 651
  len___0 = (short)0;
#line 653
  c = r;
#line 654
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 655
    return (-1);
  }
  {
#line 659
  tmp = __ctype_b_loc();
  }
#line 659
  if (! ((int const   )*(*tmp + (int )*c) & 8)) {
#line 660
    return (-1);
  }
  {
#line 662
  tmp___0 = strlen(c);
  }
#line 662
  if (tmp___0 > 63UL) {
#line 663
    return (-1);
  }
#line 665
  len___0 = (short)1;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    c ++;
#line 666
    if (! ((int const   )*c != 0)) {
#line 666
      goto while_break;
    }
    {
#line 669
    tmp___1 = __ctype_b_loc();
    }
#line 669
    if ((int const   )*(*tmp___1 + (int )*c) & 8) {
#line 670
      period_ok = (short)1;
    } else
#line 669
    if ((int const   )*c == 45) {
#line 670
      period_ok = (short)1;
    } else
#line 671
    if ((int const   )*c == 46) {
#line 671
      if (period_ok) {
#line 672
        period_ok = (short)0;
      } else {
#line 674
        return (-1);
      }
    } else {
#line 674
      return (-1);
    }
#line 675
    len___0 = (short )((int )len___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 678
  c --;
#line 680
  tmp___2 = __ctype_b_loc();
  }
#line 680
  if (! ((int const   )*(*tmp___2 + (int )*c) & 8)) {
#line 681
    return (-1);
  }
#line 682
  return ((int )len___0);
}
}
#line 685 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
void strlower(char *s ) 
{ 
  int tmp ;

  {
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! ((int )*s != 0)) {
#line 687
      goto while_break;
    }
    {
#line 688
    tmp = tolower((int )*s);
#line 688
    *s = (char )tmp;
#line 689
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 691
  return;
}
}
#line 699 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
static struct dbg debug_level_table[14]  = 
#line 699
  {      {1, "Alias"}, 
        {1 << 1, "CGI Output"}, 
        {1 << 2, "CGI Input"}, 
        {1 << 3, "CGI Environment"}, 
        {1 << 4, "Header Read State"}, 
        {1 << 5, "Pipeline"}, 
        {1 << 6, "Plugin Error"}, 
        {1 << 7, "Range related"}, 
        {1 << 8, "Configuration"}, 
        {1 << 9, "Buffer I/O"}, 
        {1 << 10, "Body Read State"}, 
        {1 << 11, "mmap Cache"}, 
        {1 << 12, "Generic Request"}, 
        {1 << 13, "hash table"}};
#line 717 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
void print_debug_usage(void) 
{ 
  struct dbg *p ;

  {
  {
#line 721
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  To calculate the debug level, logically \'or\'\n  some of the following values together to get a debug level:\n");
#line 724
  p = debug_level_table;
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! ((unsigned long )p < (unsigned long )(debug_level_table + sizeof(debug_level_table) / sizeof(struct dbg )))) {
#line 724
      goto while_break;
    }
    {
#line 728
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%d:\t%s\n",
            p->level, p->mesg);
#line 724
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 730
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 731
  return;
}
}
#line 733 "/home/june/collector/temp/boa-0.94.14rc21/src/util.c"
void parse_debug(char *foo ) 
{ 
  int i ;
  struct dbg *p ;

  {
#line 738
  if (! foo) {
#line 739
    return;
  }
  {
#line 741
  log_error_time();
#line 742
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Before parse_debug, debug_level is: %d\n",
          debug_level);
  }
#line 744
  if ((int )*(foo + 0) == 45) {
    {
#line 745
    i = boa_atoi((char const   *)(foo + 1));
    }
#line 746
    if (i == -1) {
      {
#line 748
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid level specified.\n");
#line 749
      exit(1);
      }
    }
#line 751
    i = - i;
  } else {
    {
#line 753
    i = boa_atoi((char const   *)foo);
    }
#line 754
    if (i == -1) {
      {
#line 756
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid level specified.\n");
#line 757
      exit(1);
      }
    }
  }
#line 760
  p = debug_level_table;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! ((unsigned long )p < (unsigned long )(debug_level_table + sizeof(debug_level_table) / sizeof(struct dbg )))) {
#line 760
      goto while_break;
    }
#line 764
    if (i > 0) {
#line 765
      if (i & p->level) {
        {
#line 766
        log_error_time();
#line 767
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Enabling %s debug level.\n",
                p->mesg);
#line 769
        debug_level |= p->level;
        }
      }
    } else
#line 772
    if (- i & p->level) {
      {
#line 773
      log_error_time();
#line 774
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Disabling %s debug level.\n",
              p->mesg);
#line 776
      debug_level &= ~ p->level;
      }
    }
#line 760
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 780
  log_error_time();
#line 781
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"After parse_debug, debug_level is: %d\n",
          debug_level);
  }
#line 783
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 46 "/home/june/collector/temp/boa-0.94.14rc21/src/escape.h"
unsigned long _needs_escape[((128 + (1 << 5)) - 1) / (1 << 5)]  ;
#line 46 "/home/june/collector/temp/boa-0.94.14rc21/src/escape.c"
void build_needs_escape(void) 
{ 
  unsigned int a ;
  unsigned int b ;
  unsigned char special[81] ;
  unsigned short i ;
  unsigned short j ;

  {
#line 49
  special[0] = (unsigned char )'A';
#line 49
  special[1] = (unsigned char )'B';
#line 49
  special[2] = (unsigned char )'C';
#line 49
  special[3] = (unsigned char )'D';
#line 49
  special[4] = (unsigned char )'E';
#line 49
  special[5] = (unsigned char )'F';
#line 49
  special[6] = (unsigned char )'G';
#line 49
  special[7] = (unsigned char )'H';
#line 49
  special[8] = (unsigned char )'I';
#line 49
  special[9] = (unsigned char )'J';
#line 49
  special[10] = (unsigned char )'K';
#line 49
  special[11] = (unsigned char )'L';
#line 49
  special[12] = (unsigned char )'M';
#line 49
  special[13] = (unsigned char )'N';
#line 49
  special[14] = (unsigned char )'O';
#line 49
  special[15] = (unsigned char )'P';
#line 49
  special[16] = (unsigned char )'Q';
#line 49
  special[17] = (unsigned char )'R';
#line 49
  special[18] = (unsigned char )'S';
#line 49
  special[19] = (unsigned char )'T';
#line 49
  special[20] = (unsigned char )'U';
#line 49
  special[21] = (unsigned char )'V';
#line 49
  special[22] = (unsigned char )'W';
#line 49
  special[23] = (unsigned char )'X';
#line 49
  special[24] = (unsigned char )'Y';
#line 49
  special[25] = (unsigned char )'Z';
#line 49
  special[26] = (unsigned char )'a';
#line 49
  special[27] = (unsigned char )'b';
#line 49
  special[28] = (unsigned char )'c';
#line 49
  special[29] = (unsigned char )'d';
#line 49
  special[30] = (unsigned char )'e';
#line 49
  special[31] = (unsigned char )'f';
#line 49
  special[32] = (unsigned char )'g';
#line 49
  special[33] = (unsigned char )'h';
#line 49
  special[34] = (unsigned char )'i';
#line 49
  special[35] = (unsigned char )'j';
#line 49
  special[36] = (unsigned char )'k';
#line 49
  special[37] = (unsigned char )'l';
#line 49
  special[38] = (unsigned char )'m';
#line 49
  special[39] = (unsigned char )'n';
#line 49
  special[40] = (unsigned char )'o';
#line 49
  special[41] = (unsigned char )'p';
#line 49
  special[42] = (unsigned char )'q';
#line 49
  special[43] = (unsigned char )'r';
#line 49
  special[44] = (unsigned char )'s';
#line 49
  special[45] = (unsigned char )'t';
#line 49
  special[46] = (unsigned char )'u';
#line 49
  special[47] = (unsigned char )'v';
#line 49
  special[48] = (unsigned char )'w';
#line 49
  special[49] = (unsigned char )'x';
#line 49
  special[50] = (unsigned char )'y';
#line 49
  special[51] = (unsigned char )'z';
#line 49
  special[52] = (unsigned char )'0';
#line 49
  special[53] = (unsigned char )'1';
#line 49
  special[54] = (unsigned char )'2';
#line 49
  special[55] = (unsigned char )'3';
#line 49
  special[56] = (unsigned char )'4';
#line 49
  special[57] = (unsigned char )'5';
#line 49
  special[58] = (unsigned char )'6';
#line 49
  special[59] = (unsigned char )'7';
#line 49
  special[60] = (unsigned char )'8';
#line 49
  special[61] = (unsigned char )'9';
#line 49
  special[62] = (unsigned char )'-';
#line 49
  special[63] = (unsigned char )'_';
#line 49
  special[64] = (unsigned char )'.';
#line 49
  special[65] = (unsigned char )'!';
#line 49
  special[66] = (unsigned char )'~';
#line 49
  special[67] = (unsigned char )'*';
#line 49
  special[68] = (unsigned char )'\'';
#line 49
  special[69] = (unsigned char )'(';
#line 49
  special[70] = (unsigned char )')';
#line 49
  special[71] = (unsigned char )':';
#line 49
  special[72] = (unsigned char )'@';
#line 49
  special[73] = (unsigned char )'&';
#line 49
  special[74] = (unsigned char )'=';
#line 49
  special[75] = (unsigned char )'+';
#line 49
  special[76] = (unsigned char )'$';
#line 49
  special[77] = (unsigned char )',';
#line 49
  special[78] = (unsigned char )'/';
#line 49
  special[79] = (unsigned char )'?';
#line 49
  special[80] = (unsigned char )'\000';
#line 57
  b = 1U;
#line 58
  a = 0U;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (b != 0U)) {
#line 58
      goto while_break;
    }
#line 59
    b <<= 1;
#line 58
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if (a < (unsigned int )(1 << 5)) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NEEDS_ESCAPE_SHIFT configuration error -- %d should be <= log2(%d)\n",
            5, a);
#line 65
    exit(1);
    }
  }
  {
#line 71
  memset((void *)(_needs_escape), ~ 0, sizeof(_needs_escape));
#line 72
  i = (unsigned short)0;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )i < sizeof(special) - 1UL)) {
#line 72
      goto while_break___0;
    }
#line 73
    j = (unsigned short )special[i];
#line 74
    if (! ((int )j >= 128)) {
#line 77
      _needs_escape[(int )j >> 5] &= (unsigned long )(~ (1 << ((int )j & ((1 << 5) - 1))));
    }
#line 72
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 229 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int cgi_log_fd ;
#line 235
char *server_admin ;
#line 243
char *default_type ;
#line 245
char *dirmaker ;
#line 252
char *cgi_path ;
#line 253
short common_cgi_env_count ;
#line 284
unsigned int cgi_umask ;
#line 84 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void boa_perror(request *req , char const   *message ) ;
#line 118
char const   *http_ver_string(enum HTTP_VERSION ver ) ;
#line 152
void add_to_common_env(char *key , char *value ) ;
#line 154
int add_cgi_env(request *req , char const   *key , char const   *value , int http_prefix ) ;
#line 155
int init_cgi(request *req ) ;
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
static char *env_gen_extra(char const   *key , char const   *value , unsigned int extra ) ;
#line 30
static void create_argv(request *req , char **aargv ) ;
#line 31
static int complete_env(request *req ) ;
#line 33 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
int verbose_cgi_logs  =    0;
#line 35 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
static char **common_cgi_env  =    (char **)((void *)0);
#line 36 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
short common_cgi_env_count  =    (short)0;
#line 45 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
void create_common_env(void) 
{ 
  int i ;
  void *tmp ;
  short tmp___0 ;
  char const   *tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;
  char *tmp___6 ;
  short tmp___7 ;

  {
  {
#line 48
  tmp = calloc((size_t )7, sizeof(char *));
#line 48
  common_cgi_env = (char **)tmp;
#line 49
  common_cgi_env_count = (short)0;
  }
#line 51
  if ((unsigned long )common_cgi_env == (unsigned long )((void *)0)) {
    {
#line 52
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c", 52,
                         "create_common_env", "unable to allocate memory for common_cgi_env");
    }
  }
#line 69
  tmp___0 = common_cgi_env_count;
#line 69
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 69
  if ((unsigned long )cgi_path != (unsigned long )((void *)0)) {
#line 69
    tmp___1 = (char const   *)cgi_path;
  } else {
#line 69
    tmp___1 = "/bin:/usr/bin:/usr/local/bin";
  }
  {
#line 69
  *(common_cgi_env + tmp___0) = env_gen_extra("PATH", tmp___1, 0U);
#line 73
  tmp___2 = common_cgi_env_count;
#line 73
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 73
  *(common_cgi_env + tmp___2) = env_gen_extra("SERVER_SOFTWARE", "Boa/0.94.14rc21",
                                              0U);
#line 75
  tmp___3 = common_cgi_env_count;
#line 75
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 75
  *(common_cgi_env + tmp___3) = env_gen_extra("SERVER_NAME", (char const   *)server_name,
                                              0U);
#line 76
  tmp___4 = common_cgi_env_count;
#line 76
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 76
  *(common_cgi_env + tmp___4) = env_gen_extra("GATEWAY_INTERFACE", "CGI/1.1", 0U);
#line 79
  tmp___5 = common_cgi_env_count;
#line 79
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 79
  tmp___6 = simple_itoa((uint64_t )server_port);
#line 79
  *(common_cgi_env + tmp___5) = env_gen_extra("SERVER_PORT", (char const   *)tmp___6,
                                              0U);
#line 92
  tmp___7 = common_cgi_env_count;
#line 92
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 92
  *(common_cgi_env + tmp___7) = env_gen_extra("SERVER_ADMIN", (char const   *)server_admin,
                                              0U);
#line 93
  *(common_cgi_env + common_cgi_env_count) = (char *)((void *)0);
  }
#line 96
  if ((int )common_cgi_env_count != 6) {
    {
#line 97
    log_error_time();
#line 98
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"COMMON_CGI_COUNT not high enough.\n");
#line 99
    exit(1);
    }
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < (int )common_cgi_env_count)) {
#line 102
      goto while_break;
    }
#line 103
    if ((unsigned long )*(common_cgi_env + i) == (unsigned long )((void *)0)) {
      {
#line 104
      log_error_time();
#line 105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate a component of common_cgi_env - out of memory.\n");
#line 107
      exit(1);
      }
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
void add_to_common_env(char *key , char *value ) 
{ 
  void *tmp ;

  {
  {
#line 114
  tmp = realloc((void *)common_cgi_env, (unsigned long )((int )common_cgi_env_count + 2) * sizeof(char *));
#line 114
  common_cgi_env = (char **)tmp;
  }
#line 115
  if ((unsigned long )common_cgi_env == (unsigned long )((void *)0)) {
    {
#line 116
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c", 116,
                         "add_to_common_env", "Unable to allocate memory for common CGI environment variable.");
    }
  }
  {
#line 118
  *(common_cgi_env + common_cgi_env_count) = env_gen_extra((char const   *)key, (char const   *)value,
                                                           0U);
  }
#line 119
  if ((unsigned long )*(common_cgi_env + common_cgi_env_count) == (unsigned long )((void *)0)) {
    {
#line 121
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c", 121,
                         "add_to_common_env", "memory allocation failure in add_to_common_env");
    }
  }
#line 123
  common_cgi_env_count = (short )((int )common_cgi_env_count + 1);
#line 123
  *(common_cgi_env + common_cgi_env_count) = (char *)((void *)0);
#line 128
  if ((int )common_cgi_env_count > 100) {
    {
#line 129
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c", 129,
                         "add_to_common_env", "far too many common CGI environment variables added.");
    }
  }
#line 131
  return;
}
}
#line 133 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
void clear_common_env(void) 
{ 
  int i ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i <= 6)) {
#line 137
      goto while_break;
    }
#line 138
    if ((unsigned long )*(common_cgi_env + i) != (unsigned long )((void *)0)) {
      {
#line 139
      free((void *)*(common_cgi_env + i));
#line 140
      *(common_cgi_env + i) = (char *)((void *)0);
      }
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 150 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
static char *env_gen_extra(char const   *key , char const   *value , unsigned int extra ) 
{ 
  char *result ;
  unsigned int key_len ;
  unsigned int value_len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 156
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 157
    value = "";
  }
  {
#line 158
  tmp = strlen(key);
#line 158
  key_len = (unsigned int )tmp;
#line 159
  tmp___0 = strlen(value);
#line 159
  value_len = (unsigned int )tmp___0;
#line 161
  tmp___1 = malloc((size_t )(((extra + key_len) + value_len) + 2U));
#line 161
  result = (char *)tmp___1;
  }
#line 162
  if (result) {
    {
#line 163
    memcpy((void */* __restrict  */)(result + extra), (void const   */* __restrict  */)key,
           (size_t )key_len);
#line 164
    *((result + extra) + key_len) = (char )'=';
#line 165
    memcpy((void */* __restrict  */)(((result + extra) + key_len) + 1), (void const   */* __restrict  */)value,
           (size_t )value_len);
#line 166
    *((((result + extra) + key_len) + value_len) + 1) = (char )'\000';
    }
  } else {
    {
#line 168
    log_error_time();
#line 169
    perror("malloc");
#line 170
    log_error_time();
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tried to allocate (key=value) extra=%u: %s=%s\n",
            extra, key, value);
    }
  }
#line 174
  return (result);
}
}
#line 184 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
int add_cgi_env(request *req , char const   *key , char const   *value , int http_prefix ) 
{ 
  char *p ;
  unsigned int prefix_len ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 190
  if (http_prefix) {
#line 191
    prefix_len = 5U;
  } else {
#line 193
    prefix_len = 0U;
  }
#line 196
  if (req->cgi_env_index < 100) {
    {
#line 197
    p = env_gen_extra(key, value, prefix_len);
    }
#line 198
    if (! p) {
      {
#line 199
      log_error_doc(req);
#line 200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to generate additional CGI environment variable -- ran out of memory!\n");
      }
#line 203
      return (0);
    }
#line 205
    if (prefix_len) {
      {
#line 206
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"HTTP_",
             (size_t )5);
      }
    }
#line 207
    tmp = req->cgi_env_index;
#line 207
    (req->cgi_env_index) ++;
#line 207
    req->cgi_env[tmp] = p;
#line 208
    return (1);
  }
  {
#line 210
  log_error_doc(req);
  }
#line 211
  if (prefix_len) {
#line 211
    tmp___0 = "HTTP_";
  } else {
#line 211
    tmp___0 = "";
  }
  {
#line 211
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to generate additional CGI Environment variable \"%s%s=%s\" -- not enough space!\n",
          tmp___0, key, value);
  }
#line 214
  return (0);
}
}
#line 229 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
static int complete_env(request *req ) 
{ 
  int i ;
  char const   *w ;
  int ok ;
  int tmp ;
  int ok___0 ;
  int tmp___0 ;
  int ok___1 ;
  int tmp___1 ;
  int ok___2 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int ok___3 ;
  int tmp___4 ;
  int ok___4 ;
  int tmp___5 ;
  int ok___5 ;
  int tmp___6 ;
  int ok___6 ;
  int tmp___7 ;
  int ok___7 ;
  int tmp___8 ;
  int ok___8 ;
  int tmp___9 ;
  int ok___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int ok___10 ;
  int tmp___12 ;
  int ok___11 ;
  int tmp___13 ;
  int ok___12 ;
  int tmp___14 ;

  {
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! *(common_cgi_env + i)) {
#line 233
      goto while_break;
    }
#line 234
    req->cgi_env[i] = *(common_cgi_env + i);
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  if ((unsigned int )req->method == 4U) {
#line 239
    goto case_4;
  }
#line 242
  if ((unsigned int )req->method == 2U) {
#line 242
    goto case_2;
  }
#line 245
  if ((unsigned int )req->method == 1U) {
#line 245
    goto case_1;
  }
#line 248
  goto switch_default;
  case_4: /* CIL Label */ 
#line 240
  w = "POST";
#line 241
  goto switch_break;
  case_2: /* CIL Label */ 
#line 243
  w = "HEAD";
#line 244
  goto switch_break;
  case_1: /* CIL Label */ 
#line 246
  w = "GET";
#line 247
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 249
  w = "UNKNOWN";
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 252
  tmp = add_cgi_env(req, "REQUEST_METHOD", w, 0);
#line 252
  ok = tmp;
  }
#line 252
  if (! ok) {
#line 252
    return (0);
  }
#line 255
  if (req->header_host) {
    {
#line 256
    tmp___0 = add_cgi_env(req, "HTTP_HOST", (char const   *)req->header_host, 0);
#line 256
    ok___0 = tmp___0;
    }
#line 256
    if (! ok___0) {
#line 256
      return (0);
    }
  }
  {
#line 257
  tmp___1 = add_cgi_env(req, "SERVER_ADDR", (char const   *)(req->local_ip_addr),
                        0);
#line 257
  ok___1 = tmp___1;
  }
#line 257
  if (! ok___1) {
#line 257
    return (0);
  }
  {
#line 258
  tmp___2 = http_ver_string(req->http_version);
#line 258
  tmp___3 = add_cgi_env(req, "SERVER_PROTOCOL", tmp___2, 0);
#line 258
  ok___2 = tmp___3;
  }
#line 258
  if (! ok___2) {
#line 258
    return (0);
  }
  {
#line 260
  tmp___4 = add_cgi_env(req, "REQUEST_URI", (char const   *)(req->request_uri), 0);
#line 260
  ok___3 = tmp___4;
  }
#line 260
  if (! ok___3) {
#line 260
    return (0);
  }
#line 262
  if (req->path_info) {
    {
#line 263
    tmp___5 = add_cgi_env(req, "PATH_INFO", (char const   *)req->path_info, 0);
#line 263
    ok___4 = tmp___5;
    }
#line 263
    if (! ok___4) {
#line 263
      return (0);
    }
  }
#line 265
  if (req->path_translated) {
    {
#line 270
    tmp___6 = add_cgi_env(req, "PATH_TRANSLATED", (char const   *)req->path_translated,
                          0);
#line 270
    ok___5 = tmp___6;
    }
#line 270
    if (! ok___5) {
#line 270
      return (0);
    }
  }
  {
#line 272
  tmp___7 = add_cgi_env(req, "SCRIPT_NAME", (char const   *)req->script_name, 0);
#line 272
  ok___6 = tmp___7;
  }
#line 272
  if (! ok___6) {
#line 272
    return (0);
  }
#line 274
  if (req->query_string) {
    {
#line 275
    tmp___8 = add_cgi_env(req, "QUERY_STRING", (char const   *)req->query_string,
                          0);
#line 275
    ok___7 = tmp___8;
    }
#line 275
    if (! ok___7) {
#line 275
      return (0);
    }
  }
  {
#line 276
  tmp___9 = add_cgi_env(req, "REMOTE_ADDR", (char const   *)(req->remote_ip_addr),
                        0);
#line 276
  ok___8 = tmp___9;
  }
#line 276
  if (! ok___8) {
#line 276
    return (0);
  }
  {
#line 277
  tmp___10 = simple_itoa((uint64_t )req->remote_port);
#line 277
  tmp___11 = add_cgi_env(req, "REMOTE_PORT", (char const   *)tmp___10, 0);
#line 277
  ok___9 = tmp___11;
  }
#line 277
  if (! ok___9) {
#line 277
    return (0);
  }
#line 279
  if ((unsigned int )req->method == 4U) {
#line 280
    if (req->content_type) {
      {
#line 281
      tmp___12 = add_cgi_env(req, "CONTENT_TYPE", (char const   *)req->content_type,
                             0);
#line 281
      ok___10 = tmp___12;
      }
#line 281
      if (! ok___10) {
#line 281
        return (0);
      }
    } else {
      {
#line 283
      tmp___13 = add_cgi_env(req, "CONTENT_TYPE", (char const   *)default_type, 0);
#line 283
      ok___11 = tmp___13;
      }
#line 283
      if (! ok___11) {
#line 283
        return (0);
      }
    }
#line 285
    if (req->content_length) {
      {
#line 286
      tmp___14 = add_cgi_env(req, "CONTENT_LENGTH", (char const   *)req->content_length,
                             0);
#line 286
      ok___12 = tmp___14;
      }
#line 286
      if (! ok___12) {
#line 286
        return (0);
      }
    }
  }
#line 294
  if (req->cgi_env_index < 101) {
#line 295
    req->cgi_env[req->cgi_env_index] = (char *)((void *)0);
#line 296
    return (1);
  }
  {
#line 298
  log_error_doc(req);
#line 299
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough space in CGI environment for remainder of variables.\n");
  }
#line 301
  return (0);
}
}
#line 311 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
static void create_argv(request *req , char **aargv ) 
{ 
  char *p ;
  char *q ;
  char *r ;
  int aargc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 316
  q = req->query_string;
#line 317
  *(aargv + 0) = req->pathname;
#line 362
  if (q) {
    {
#line 362
    tmp___1 = strchr((char const   *)q, '=');
    }
#line 362
    if (tmp___1) {
#line 388
      *(aargv + 1) = (char *)((void *)0);
    } else {
      {
#line 364
      q = strdup((char const   *)q);
      }
#line 365
      if (! q) {
        {
#line 366
        log_error_doc(req);
#line 367
        fputs((char const   */* __restrict  */)"unable to strdup \'q\' in create_argv!\n",
              (FILE */* __restrict  */)stderr);
#line 368
        _exit(1);
        }
      }
#line 370
      aargc = 1;
      {
#line 370
      while (1) {
        while_continue: /* CIL Label */ ;
#line 370
        if (q) {
#line 370
          if (! (aargc < 128)) {
#line 370
            goto while_break;
          }
        } else {
#line 370
          goto while_break;
        }
        {
#line 371
        r = q;
#line 375
        p = strchr((char const   *)q, '+');
        }
#line 375
        if (p) {
#line 376
          *p = (char )'\000';
#line 377
          q = p + 1;
        } else {
#line 379
          q = (char *)((void *)0);
        }
        {
#line 381
        tmp___0 = unescape_uri(r, (char **)((void *)0));
        }
#line 381
        if (tmp___0) {
#line 383
          tmp = aargc;
#line 383
          aargc ++;
#line 383
          *(aargv + tmp) = r;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 386
      *(aargv + aargc) = (char *)((void *)0);
    }
  } else {
#line 388
    *(aargv + 1) = (char *)((void *)0);
  }
#line 390
  return;
}
}
#line 405 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c"
int init_cgi(request *req ) 
{ 
  int child_pid ;
  int pipes[2] ;
  int use_pipes ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *c ;
  unsigned int l ;
  char *newpath ;
  char *oldpath ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *aargv[129] ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 409
  use_pipes = 0;
#line 411
  req->keepalive = (enum KA_STATUS )2;
#line 413
  if (req->cgi_type) {
    {
#line 414
    tmp = complete_env(req);
    }
#line 414
    if (tmp == 0) {
#line 415
      return (0);
    }
  }
#line 418
  if (debug_level & (1 << 3)) {
#line 420
    i = 0;
    {
#line 420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 420
      if (! (i < req->cgi_env_index)) {
#line 420
        goto while_break;
      }
      {
#line 421
      log_error_time();
#line 420
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - environment variable for cgi: \"%s\"\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/cgi.c", req->cgi_env[i]);
    }
  }
#line 428
  if ((unsigned int )req->cgi_type == 2U) {
#line 428
    goto _L;
  } else
#line 428
  if (! req->cgi_type) {
    {
#line 428
    tmp___2 = strlen((char const   *)req->pathname);
    }
#line 428
    if ((int )*(req->pathname + (tmp___2 - 1UL)) == 47) {
      _L: /* CIL Label */ 
      {
#line 431
      use_pipes = 1;
#line 432
      tmp___0 = pipe((int *)(pipes));
      }
#line 432
      if (tmp___0 == -1) {
        {
#line 433
        log_error_doc(req);
#line 434
        perror("pipe");
        }
#line 435
        return (0);
      }
      {
#line 439
      tmp___1 = fcntl(pipes[0], 4, 2048);
      }
#line 439
      if (tmp___1 == -1) {
        {
#line 440
        log_error_doc(req);
#line 441
        perror("cgi-fcntl");
#line 442
        close(pipes[0]);
#line 443
        close(pipes[1]);
        }
#line 444
        return (0);
      }
    }
  }
  {
#line 448
  child_pid = fork();
  }
  {
#line 450
  if (child_pid == -1) {
#line 450
    goto case_neg_1;
  }
#line 463
  if (child_pid == 0) {
#line 463
    goto case_0;
  }
#line 646
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 456
  boa_perror(req, "fork failed");
  }
#line 457
  if (use_pipes) {
    {
#line 458
    close(pipes[0]);
#line 459
    close(pipes[1]);
    }
  }
#line 461
  return (0);
#line 462
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 465
  reset_signals();
  }
#line 467
  if ((unsigned int )req->cgi_type == 2U) {
#line 467
    goto _L___0;
  } else
#line 467
  if ((unsigned int )req->cgi_type == 1U) {
    _L___0: /* CIL Label */ 
    {
#line 472
    c = strrchr((char const   *)req->pathname, '/');
    }
#line 473
    if (! c) {
      {
#line 475
      log_error_doc(req);
#line 476
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to find \'/\' in req->pathname: \"%s\"\n",
              req->pathname);
      }
#line 479
      if (use_pipes) {
        {
#line 480
        close(pipes[1]);
        }
      }
      {
#line 481
      _exit(1);
      }
    }
    {
#line 484
    *c = (char )'\000';
#line 486
    tmp___5 = chdir((char const   *)req->pathname);
    }
#line 486
    if (tmp___5 != 0) {
      {
#line 487
      tmp___3 = __errno_location();
#line 487
      saved_errno = *tmp___3;
#line 488
      log_error_doc(req);
#line 489
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not chdir to \"%s\":",
              req->pathname);
#line 491
      tmp___4 = __errno_location();
#line 491
      *tmp___4 = saved_errno;
#line 492
      perror("chdir");
      }
#line 493
      if (use_pipes) {
        {
#line 494
        close(pipes[1]);
        }
      }
      {
#line 495
      _exit(1);
      }
    }
    {
#line 498
    oldpath = req->pathname;
#line 499
    c ++;
#line 499
    req->pathname = c;
#line 500
    tmp___6 = strlen((char const   *)req->pathname);
#line 500
    l = (unsigned int )(tmp___6 + 3UL);
#line 502
    tmp___7 = malloc(sizeof(char ) * (unsigned long )l);
#line 502
    newpath = (char *)tmp___7;
    }
#line 503
    if (! newpath) {
      {
#line 505
      log_error_doc(req);
#line 506
      perror("unable to malloc for newpath");
      }
#line 507
      if (use_pipes) {
        {
#line 508
        close(pipes[1]);
        }
      }
      {
#line 509
      _exit(1);
      }
    }
    {
#line 511
    *(newpath + 0) = (char )'.';
#line 512
    *(newpath + 1) = (char )'/';
#line 513
    memcpy((void */* __restrict  */)(newpath + 2), (void const   */* __restrict  */)req->pathname,
           (size_t )(l - 2U));
#line 514
    free((void *)oldpath);
#line 515
    req->pathname = newpath;
    }
  }
#line 517
  if (use_pipes) {
    {
#line 519
    close(pipes[0]);
#line 521
    tmp___8 = dup2(pipes[1], 1);
    }
#line 521
    if (tmp___8 == -1) {
      {
#line 522
      log_error_doc(req);
#line 523
      perror("dup2 - pipes");
#line 524
      _exit(1);
      }
    }
    {
#line 526
    close(pipes[1]);
    }
  } else {
    {
#line 529
    tmp___9 = dup2(req->fd, 1);
    }
#line 529
    if (tmp___9 == -1) {
      {
#line 530
      log_error_doc(req);
#line 531
      perror("dup2 - fd");
#line 532
      _exit(1);
      }
    }
    {
#line 534
    close(req->fd);
    }
  }
  {
#line 537
  tmp___10 = fcntl(1, 4, 0);
  }
#line 537
  if (tmp___10 == -1) {
    {
#line 538
    log_error_doc(req);
#line 539
    perror("cgi-fcntl");
#line 540
    _exit(1);
    }
  }
#line 543
  if ((unsigned int )req->method == 4U) {
    {
#line 544
    lseek(req->post_data_fd, (__off64_t )0, 0);
#line 545
    dup2(req->post_data_fd, 0);
#line 546
    close(req->post_data_fd);
    }
  }
  {
#line 609
  umask(cgi_umask);
  }
#line 620
  if (cgi_log_fd) {
    {
#line 621
    dup2(cgi_log_fd, 2);
    }
  }
#line 624
  if (req->cgi_type) {
    {
#line 626
    create_argv(req, aargv);
#line 627
    execve((char const   *)req->pathname, (char * const  *)(aargv), (char * const  *)(req->cgi_env));
    }
  } else {
    {
#line 629
    tmp___11 = strlen((char const   *)req->pathname);
    }
#line 629
    if ((int )*(req->pathname + (tmp___11 - 1UL)) == 47) {
      {
#line 630
      execl((char const   *)dirmaker, (char const   *)dirmaker, req->pathname, req->request_uri,
            (void *)0);
      }
    } else {
      {
#line 634
      execl("/bin/gunzip", "/bin/gunzip", "--stdout", "--decompress", req->pathname,
            (void *)0);
      }
    }
  }
  {
#line 639
  log_error_doc(req);
#line 640
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to execve/execl pathname: \"%s\"",
          req->pathname);
#line 642
  perror("");
#line 643
  _exit(1);
  }
#line 644
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 649
  if (verbose_cgi_logs) {
    {
#line 650
    log_error_time();
#line 651
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forked child \"%s\" pid %d\n",
            req->pathname, child_pid);
    }
  }
#line 655
  if ((unsigned int )req->method == 4U) {
    {
#line 656
    close(req->post_data_fd);
#line 657
    req->post_data_fd = 0;
    }
  }
#line 661
  if (! use_pipes) {
#line 662
    return (0);
  }
  {
#line 664
  close(pipes[1]);
#line 665
  req->data_fd = pipes[0];
#line 667
  req->status = (enum REQ_STATUS )7;
  }
#line 668
  if ((unsigned int )req->cgi_type == 2U) {
#line 669
    req->cgi_status = (enum CGI_STATUS )0;
#line 671
    tmp___12 = req->buffer + 2048;
#line 671
    req->header_end = tmp___12;
#line 671
    req->header_line = tmp___12;
  } else {
#line 674
    req->cgi_status = (enum CGI_STATUS )1;
#line 676
    tmp___13 = req->buffer;
#line 676
    req->header_end = tmp___13;
#line 676
    req->header_line = tmp___13;
  }
#line 681
  req->filepos = (off_t )0;
#line 682
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 685
  return (1);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 226 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *access_log_name ;
#line 227
char *error_log_name ;
#line 228
char *cgi_log_name ;
#line 229 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int cgi_log_fd  ;
#line 275
int virtualhost ;
#line 276
char *vhost_root ;
#line 82 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void log_access(request *req ) ;
#line 86
void log_error(char const   *mesg ) ;
#line 88
void log_error_mesg(char const   *file , int line , char const   *func , char const   *mesg ) ;
#line 144
void send_r_error(request *req ) ;
#line 40 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void open_logs(void) 
{ 
  int access_log ;
  int error_log ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 47
  if (error_log_name) {
    {
#line 51
    error_log = open_gen_fd(error_log_name);
    }
#line 52
    if (error_log < 0) {
      {
#line 53
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/log.c",
                           53, "open_logs", "unable to open error log");
      }
    }
    {
#line 57
    tmp = dup2(error_log, 2);
    }
#line 57
    if (tmp == -1) {
      {
#line 58
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/log.c",
                           58, "open_logs", "unable to dup2 the error log");
      }
    }
    {
#line 60
    close(error_log);
    }
  }
#line 63
  if (access_log_name) {
    {
#line 64
    access_log = open_gen_fd(access_log_name);
    }
  } else {
    {
#line 66
    access_log = open("/dev/null", 0);
    }
  }
#line 68
  if (access_log < 0) {
    {
#line 69
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/log.c", 69,
                         "open_logs", "unable to open access log");
    }
  }
  {
#line 72
  tmp___0 = dup2(access_log, 1);
  }
#line 72
  if (tmp___0 == -1) {
    {
#line 73
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/log.c", 73,
                         "open_logs", "can\'t dup2 /dev/null to STDOUT_FILENO");
    }
  }
  {
#line 75
  tmp___1 = fcntl(access_log, 2, 1);
  }
#line 75
  if (tmp___1 == -1) {
    {
#line 76
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/log.c", 76,
                         "open_logs", "unable to set close-on-exec flag for access_log");
    }
  }
  {
#line 79
  close(access_log);
  }
#line 81
  if (cgi_log_name) {
    {
#line 82
    cgi_log_fd = open_gen_fd(cgi_log_name);
    }
#line 83
    if (cgi_log_fd == -1) {
      {
#line 84
      log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/log.c", 84, "open_logs",
                     "open cgi_log");
#line 85
      free((void *)cgi_log_name);
#line 86
      cgi_log_name = (char *)((void *)0);
#line 87
      cgi_log_fd = 0;
      }
    } else {
      {
#line 89
      tmp___2 = fcntl(cgi_log_fd, 2, 1);
      }
#line 89
      if (tmp___2 == -1) {
        {
#line 90
        log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/log.c", 90,
                       "open_logs", "unable to set close-on-exec flag for cgi_log");
#line 91
        free((void *)cgi_log_name);
#line 92
        cgi_log_name = (char *)((void *)0);
#line 93
        close(cgi_log_fd);
#line 94
        cgi_log_fd = 0;
        }
      }
    }
  }
  {
#line 102
  setvbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((char *)((void *)0)),
          2, (size_t )0);
#line 103
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((char *)((void *)0)),
          1, (size_t )0);
  }
#line 105
  return;
}
}
#line 139 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_access(request *req ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 141
  if (! access_log_name) {
#line 142
    return;
  }
#line 144
  if (virtualhost) {
    {
#line 145
    printf((char const   */* __restrict  */)"%s ", req->local_ip_addr);
    }
  } else
#line 146
  if (vhost_root) {
#line 147
    if (req->host) {
#line 147
      tmp = (char const   *)req->host;
    } else {
#line 147
      tmp = "(null)";
    }
    {
#line 147
    printf((char const   */* __restrict  */)"%s ", tmp);
    }
  }
#line 149
  if (req->header_user_agent) {
#line 149
    tmp___0 = (char const   *)req->header_user_agent;
  } else {
#line 149
    tmp___0 = "-";
  }
#line 149
  if (req->header_referer) {
#line 149
    tmp___1 = (char const   *)req->header_referer;
  } else {
#line 149
    tmp___1 = "-";
  }
#line 149
  if (req->logline) {
#line 149
    tmp___2 = (char const   *)req->logline;
  } else {
#line 149
    tmp___2 = "-";
  }
  {
#line 149
  tmp___3 = get_commonlog_time();
#line 149
  printf((char const   */* __restrict  */)"%s - - %s\"%s\" %d %zu \"%s\" \"%s\"\n",
         req->remote_ip_addr, tmp___3, tmp___2, (unsigned int )req->response_status,
         req->bytes_written, tmp___1, tmp___0);
  }
#line 157
  return;
}
}
#line 159 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
static char *escape_pathname(char const   *inp ) 
{ 
  char *escaped ;
  char *c ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 163
  if (! inp) {
#line 164
    return ((char *)((void *)0));
  }
  {
#line 166
  tmp = strlen(inp);
#line 166
  tmp___0 = malloc(1UL + tmp * 4UL);
#line 166
  escaped = (char *)tmp___0;
  }
#line 167
  if ((unsigned long )escaped == (unsigned long )((void *)0)) {
    {
#line 168
    perror("malloc");
    }
#line 169
    return ((char *)((void *)0));
  }
#line 171
  c = escaped;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! *inp) {
#line 171
      goto while_break;
    }
#line 172
    if ((unsigned int )*inp >= 128U) {
      {
#line 173
      tmp___1 = sprintf((char */* __restrict  */)c, (char const   */* __restrict  */)"\\x%02x",
                        (unsigned int )*inp);
#line 173
      c += tmp___1;
      }
    } else
#line 172
    if (_needs_escape[(unsigned int )*inp >> 5] & (unsigned long )(1 << ((unsigned int )*inp & (unsigned int )((1 << 5) - 1)))) {
      {
#line 173
      tmp___1 = sprintf((char */* __restrict  */)c, (char const   */* __restrict  */)"\\x%02x",
                        (unsigned int )*inp);
#line 173
      c += tmp___1;
      }
    } else {
#line 175
      tmp___2 = c;
#line 175
      c ++;
#line 175
      *tmp___2 = (char )*inp;
    }
#line 171
    inp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  tmp___3 = c;
#line 178
  c ++;
#line 178
  *tmp___3 = (char )'\000';
#line 179
  return (escaped);
}
}
#line 196 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_error_doc(request *req ) 
{ 
  int errno_save ;
  int *tmp ;
  char *escaped_pathname ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 198
  tmp = __errno_location();
#line 198
  errno_save = *tmp;
  }
#line 201
  if (virtualhost) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
            req->local_ip_addr);
    }
  } else
#line 203
  if (vhost_root) {
#line 204
    if (req->host) {
#line 204
      tmp___0 = (char const   *)req->host;
    } else {
#line 204
      tmp___0 = "(null)";
    }
    {
#line 204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
            tmp___0);
    }
  }
  {
#line 206
  escaped_pathname = escape_pathname((char const   *)req->pathname);
  }
#line 207
  if (vhost_root) {
#line 208
    if (escaped_pathname) {
#line 208
      tmp___1 = (char const   *)escaped_pathname;
    } else {
#line 208
      tmp___1 = "(null)";
    }
#line 208
    if (req->logline) {
#line 208
      tmp___2 = (char const   *)req->logline;
    } else {
#line 208
      tmp___2 = "(null)";
    }
#line 208
    if (req->header_host) {
#line 208
      tmp___3 = (char const   *)req->header_host;
    } else {
#line 208
      tmp___3 = "(null)";
    }
    {
#line 208
    tmp___4 = get_commonlog_time();
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - - %srequest [%s] \"%s\" (\"%s\"): ",
            req->remote_ip_addr, tmp___4, tmp___3, tmp___2, tmp___1);
    }
  } else {
#line 215
    if (escaped_pathname) {
#line 215
      tmp___5 = (char const   *)escaped_pathname;
    } else {
#line 215
      tmp___5 = "(null)";
    }
#line 215
    if (req->logline) {
#line 215
      tmp___6 = (char const   *)req->logline;
    } else {
#line 215
      tmp___6 = "(null)";
    }
    {
#line 215
    tmp___7 = get_commonlog_time();
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - - %srequest \"%s\" (\"%s\"): ",
            req->remote_ip_addr, tmp___7, tmp___6, tmp___5);
    }
  }
  {
#line 221
  free((void *)escaped_pathname);
#line 223
  tmp___8 = __errno_location();
#line 223
  *tmp___8 = errno_save;
  }
#line 224
  return;
}
}
#line 232 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void boa_perror(request *req , char const   *message ) 
{ 


  {
  {
#line 234
  log_error_doc(req);
#line 235
  perror(message);
#line 236
  send_r_error(req);
  }
#line 237
  return;
}
}
#line 246 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_error_time(void) 
{ 
  int errno_save ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 248
  tmp = __errno_location();
#line 248
  errno_save = *tmp;
#line 249
  tmp___0 = get_commonlog_time();
#line 249
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 250
  tmp___1 = __errno_location();
#line 250
  *tmp___1 = errno_save;
  }
#line 251
  return;
}
}
#line 260 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_error(char const   *mesg ) 
{ 
  char *tmp ;

  {
  {
#line 262
  tmp = get_commonlog_time();
#line 262
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s",
          tmp, mesg);
  }
#line 263
  return;
}
}
#line 274 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_error_mesg(char const   *file , int line , char const   *func , char const   *mesg ) 
{ 
  int errno_save ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 276
  tmp = __errno_location();
#line 276
  errno_save = *tmp;
#line 277
  tmp___0 = get_commonlog_time();
#line 277
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:%d (%s) - ",
          tmp___0, file, line, func);
#line 278
  tmp___1 = __errno_location();
#line 278
  *tmp___1 = errno_save;
#line 279
  perror(mesg);
#line 280
  tmp___2 = __errno_location();
#line 280
  *tmp___2 = errno_save;
  }
#line 281
  return;
}
}
#line 283 "/home/june/collector/temp/boa-0.94.14rc21/src/log.c"
void log_error_mesg_fatal(char const   *file , int line , char const   *func , char const   *mesg ) 
{ 
  int errno_save ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 285
  tmp = __errno_location();
#line 285
  errno_save = *tmp;
#line 286
  tmp___0 = get_commonlog_time();
#line 286
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:%d (%s) - ",
          tmp___0, file, line, func);
#line 287
  tmp___1 = __errno_location();
#line 287
  *tmp___1 = errno_save;
#line 288
  perror(mesg);
#line 289
  exit(1);
  }
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 242 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *directory_index ;
#line 248
char *cachedir ;
#line 280
unsigned int system_bufsize ;
#line 67 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
int init_get(request *req ) ;
#line 68
int process_get(request *req ) ;
#line 69
int get_dir(request *req , struct stat *statbuf ) ;
#line 73
char *get_mime_type(char const   *filename ) ;
#line 120
void print_content_type(request *req ) ;
#line 122
void print_last_modified(request *req ) ;
#line 123
void print_http_headers(request *req ) ;
#line 127
int complete_response(request *req ) ;
#line 130
void send_r_request_ok(request *req ) ;
#line 131
void send_r_no_content(request *req ) ;
#line 132
void send_r_partial_content(request *req ) ;
#line 133
void send_r_moved_perm(request *req , char const   *url ) ;
#line 135
void send_r_not_modified(request *req ) ;
#line 136
void send_r_bad_request(request *req ) ;
#line 138
void send_r_forbidden(request *req ) ;
#line 139
void send_r_not_found(request *req ) ;
#line 43 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
static int get_cachedir_file(request *req , struct stat *statbuf ) ;
#line 44
static int index_directory___0(request *req , char *dest_filename ) ;
#line 156 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
static unsigned int l3  =    0U;
#line 157 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
static unsigned int l4  =    0U;
#line 55 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
int init_get(request *req ) 
{ 
  int data_fd ;
  int saved_errno ;
  struct stat statbuf ;
  off_t volatile   bytes_free ;
  int *tmp ;
  char gzip_pathname[4096] ;
  unsigned int len___0 ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char buffer___1[12416] ;
  unsigned int len___1 ;
  char *host ;
  unsigned int l2 ;
  char *port ;
  char const   *prefix ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int want ;
  Range *r ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 61
  data_fd = open((char const   *)req->pathname, 0);
#line 62
  tmp = __errno_location();
#line 62
  saved_errno = *tmp;
  }
#line 65
  if (data_fd == -1) {
    {
#line 65
    tmp___3 = __errno_location();
    }
#line 65
    if (*tmp___3 == 2) {
      {
#line 71
      tmp___0 = strlen((char const   *)req->pathname);
#line 71
      len___0 = (unsigned int )tmp___0;
      }
#line 73
      if ((unsigned long )(len___0 + 4U) > sizeof(gzip_pathname)) {
        {
#line 74
        log_error_doc(req);
#line 75
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pathname + .gz too long! (%s)\n",
                req->pathname);
#line 76
        send_r_bad_request(req);
        }
#line 77
        return (0);
      }
      {
#line 80
      memcpy((void */* __restrict  */)(gzip_pathname), (void const   */* __restrict  */)req->pathname,
             (size_t )len___0);
#line 81
      memcpy((void */* __restrict  */)(gzip_pathname + len___0), (void const   */* __restrict  */)".gz",
             (size_t )3);
#line 82
      gzip_pathname[len___0 + 3U] = (char )'\000';
#line 83
      data_fd = open((char const   *)(gzip_pathname), 0);
      }
#line 84
      if (data_fd != -1) {
        {
#line 85
        close(data_fd);
#line 87
        req->response_status = (enum RESPONSE_CODE )200;
        }
#line 88
        if (req->pathname) {
          {
#line 89
          free((void *)req->pathname);
          }
        }
        {
#line 90
        req->pathname = strdup((char const   *)(gzip_pathname));
        }
#line 91
        if (! req->pathname) {
          {
#line 92
          boa_perror(req, "strdup req->pathname for gzipped filename /home/june/collector/temp/boa-0.94.14rc21/src/get.c:92");
          }
#line 93
          return (0);
        }
#line 95
        if ((unsigned int )req->http_version != 1U) {
          {
#line 96
          tmp___1 = http_ver_string(req->http_version);
#line 96
          req_write(req, tmp___1);
#line 97
          req_write(req, " 200 OK-GUNZIP\r\n");
#line 98
          print_http_headers(req);
#line 99
          print_content_type(req);
#line 100
          print_last_modified(req);
#line 101
          req_write(req, "\r\n");
#line 102
          req_flush(req);
          }
        }
#line 104
        if ((unsigned int )req->method == 2U) {
#line 105
          return (0);
        }
        {
#line 107
        tmp___2 = init_cgi(req);
        }
#line 107
        return (tmp___2);
      }
    }
  }
#line 112
  if (data_fd == -1) {
    {
#line 113
    log_error_doc(req);
#line 114
    tmp___4 = __errno_location();
#line 114
    *tmp___4 = saved_errno;
#line 115
    perror("document open");
    }
#line 117
    if (saved_errno == 2) {
      {
#line 118
      send_r_not_found(req);
      }
    } else
#line 119
    if (saved_errno == 13) {
      {
#line 120
      send_r_forbidden(req);
      }
    } else {
      {
#line 122
      send_r_bad_request(req);
      }
    }
#line 123
    return (0);
  }
  {
#line 133
  fstat(data_fd, & statbuf);
  }
#line 135
  if ((statbuf.st_mode & 61440U) == 16384U) {
    {
#line 136
    close(data_fd);
#line 138
    tmp___13 = strlen((char const   *)req->pathname);
    }
#line 138
    if ((int )*(req->pathname + (tmp___13 - 1UL)) != 47) {
#line 152
      host = server_name;
#line 154
      port = (char *)((void *)0);
#line 155
      prefix = "http://";
#line 159
      if (l4 == 0U) {
        {
#line 160
        tmp___5 = strlen(prefix);
#line 160
        l4 = (unsigned int )tmp___5;
        }
      }
      {
#line 162
      tmp___6 = strlen((char const   *)(req->request_uri));
#line 162
      len___1 = (unsigned int )tmp___6;
      }
#line 163
      if (! port) {
#line 163
        if (server_port != 80U) {
          {
#line 164
          tmp___7 = simple_itoa((uint64_t )server_port);
#line 164
          port = strdup((char const   *)tmp___7);
          }
#line 165
          if ((unsigned long )port == (unsigned long )((void *)0)) {
            {
#line 166
            tmp___8 = __errno_location();
#line 166
            *tmp___8 = 12;
#line 167
            boa_perror(req, "Unable to perform simple_itoa conversion on server port!");
            }
#line 168
            return (0);
          }
          {
#line 170
          tmp___9 = strlen((char const   *)port);
#line 170
          l3 = (unsigned int )tmp___9;
          }
        }
      }
#line 174
      if (req->host) {
#line 180
        host = req->host;
      }
      {
#line 182
      tmp___10 = strlen((char const   *)host);
#line 182
      l2 = (unsigned int )tmp___10;
      }
#line 184
      if (server_port != 80U) {
#line 185
        if ((unsigned long )(((((l4 + l2) + 1U) + l3) + len___1) + 1U) > sizeof(buffer___1)) {
          {
#line 186
          tmp___11 = __errno_location();
#line 186
          *tmp___11 = 12;
#line 187
          boa_perror(req, "buffer not large enough for directory redirect");
          }
#line 188
          return (0);
        }
        {
#line 190
        memcpy((void */* __restrict  */)(buffer___1), (void const   */* __restrict  */)prefix,
               (size_t )l4);
#line 191
        memcpy((void */* __restrict  */)(buffer___1 + l4), (void const   */* __restrict  */)host,
               (size_t )l2);
#line 192
        buffer___1[l4 + l2] = (char )':';
#line 193
        memcpy((void */* __restrict  */)(((buffer___1 + l4) + l2) + 1), (void const   */* __restrict  */)port,
               (size_t )l3);
#line 194
        memcpy((void */* __restrict  */)((((buffer___1 + l4) + l2) + 1) + l3), (void const   */* __restrict  */)(req->request_uri),
               (size_t )len___1);
#line 195
        buffer___1[(((l4 + l2) + 1U) + l3) + len___1] = (char )'/';
#line 196
        buffer___1[((((l4 + l2) + 1U) + l3) + len___1) + 1U] = (char )'\000';
        }
      } else {
#line 198
        if ((unsigned long )(((l4 + l2) + len___1) + 1U) > sizeof(buffer___1)) {
          {
#line 199
          tmp___12 = __errno_location();
#line 199
          *tmp___12 = 12;
#line 200
          boa_perror(req, "buffer not large enough for directory redirect");
          }
#line 201
          return (0);
        }
        {
#line 203
        memcpy((void */* __restrict  */)(buffer___1), (void const   */* __restrict  */)prefix,
               (size_t )l4);
#line 204
        memcpy((void */* __restrict  */)(buffer___1 + l4), (void const   */* __restrict  */)host,
               (size_t )l2);
#line 205
        memcpy((void */* __restrict  */)((buffer___1 + l4) + l2), (void const   */* __restrict  */)(req->request_uri),
               (size_t )len___1);
#line 206
        buffer___1[(l4 + l2) + len___1] = (char )'/';
#line 207
        buffer___1[((l4 + l2) + len___1) + 1U] = (char )'\000';
        }
      }
      {
#line 210
      send_r_moved_perm(req, (char const   *)(buffer___1));
      }
#line 211
      return (0);
    }
    {
#line 213
    data_fd = get_dir(req, & statbuf);
    }
#line 215
    if (data_fd < 0) {
#line 216
      return (0);
    } else
#line 217
    if (data_fd == 0) {
#line 218
      return (data_fd);
    } else
#line 217
    if (data_fd == 1) {
#line 218
      return (data_fd);
    }
  }
#line 222
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 223
    log_error_doc(req);
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resulting file is not a regular file.\n");
#line 225
    send_r_bad_request(req);
#line 226
    close(data_fd);
    }
#line 227
    return (0);
  }
#line 251
  if (req->if_modified_since) {
    {
#line 251
    tmp___14 = modified_since(& statbuf.st_mtim.tv_sec, (char const   *)req->if_modified_since);
    }
#line 251
    if (! tmp___14) {
      {
#line 253
      send_r_not_modified(req);
#line 254
      close(data_fd);
      }
#line 255
      return (0);
    }
  }
#line 258
  req->filesize = statbuf.st_size;
#line 259
  req->last_modified = statbuf.st_mtim.tv_sec;
#line 262
  if (req->header_ifrange) {
#line 262
    if (! req->ranges) {
#line 263
      req->header_ifrange = (char *)((void *)0);
    }
  }
#line 266
  req->header_ifrange = (char *)((void *)0);
#line 275
  if (req->filesize == 0L) {
#line 276
    if ((unsigned int )req->http_version < 3U) {
      {
#line 277
      send_r_request_ok(req);
#line 278
      close(data_fd);
      }
#line 279
      return (0);
    }
    {
#line 281
    send_r_no_content(req);
#line 282
    close(data_fd);
    }
#line 283
    return (0);
  }
#line 286
  if (req->ranges) {
    {
#line 286
    tmp___15 = ranges_fixup(req);
    }
#line 286
    if (! tmp___15) {
      {
#line 287
      close(data_fd);
      }
#line 288
      return (0);
    }
  }
#line 312
  if (req->filesize > 102400L) {
#line 313
    req->data_fd = data_fd;
#line 314
    req->status = (enum REQ_STATUS )9;
  } else {
    {
#line 324
    req->mmap_entry_var = find_mmap(data_fd, & statbuf);
    }
#line 325
    if ((unsigned long )req->mmap_entry_var == (unsigned long )((void *)0)) {
#line 326
      req->data_fd = data_fd;
#line 327
      req->status = (enum REQ_STATUS )9;
    } else {
      {
#line 329
      req->data_mem = (req->mmap_entry_var)->mmap;
#line 330
      close(data_fd);
      }
    }
  }
#line 334
  if (! req->ranges) {
    {
#line 335
    req->ranges = range_pool_pop();
#line 336
    (req->ranges)->start = 0UL;
#line 337
    (req->ranges)->stop = 0xffffffffffffffffUL;
#line 338
    tmp___16 = ranges_fixup(req);
    }
#line 338
    if (! tmp___16) {
#line 339
      return (0);
    }
    {
#line 341
    send_r_request_ok(req);
    }
  } else
#line 349
  if (! req->header_ifrange) {
    {
#line 350
    send_r_partial_content(req);
    }
  } else {
    {
#line 353
    ranges_reset(req);
#line 354
    req->ranges = range_pool_pop();
#line 355
    (req->ranges)->start = 0UL;
#line 356
    (req->ranges)->stop = 0xffffffffffffffffUL;
#line 357
    tmp___17 = ranges_fixup(req);
    }
#line 357
    if (! tmp___17) {
#line 358
      return (0);
    }
    {
#line 360
    send_r_request_ok(req);
    }
  }
#line 364
  if ((unsigned int )req->method == 2U) {
    {
#line 365
    tmp___18 = complete_response(req);
    }
#line 365
    return (tmp___18);
  }
#line 368
  bytes_free = (off_t volatile   )0;
#line 369
  if (req->data_mem) {
#line 375
    bytes_free = (off_t volatile   )(4096 - req->buffer_end);
  }
#line 383
  if (req->data_mem) {
#line 383
    if (bytes_free > (off_t volatile   )256) {
#line 387
      r = req->ranges;
#line 389
      want = (unsigned int )((r->stop - r->start) + 1UL);
#line 391
      if (bytes_free > (off_t volatile   )want) {
#line 392
        bytes_free = (off_t volatile   )want;
      }
      {
#line 398
      tmp___19 = _setjmp((struct __jmp_buf_tag *)(env));
      }
#line 398
      if (tmp___19 == 0) {
        {
#line 399
        handle_sigbus = 1;
#line 400
        memcpy((void */* __restrict  */)(req->buffer + req->buffer_end), (void const   */* __restrict  */)(req->data_mem + r->start),
               (size_t )bytes_free);
#line 402
        handle_sigbus = 0;
        }
      } else {
        {
#line 406
        log_error_doc(req);
#line 407
        reset_output_buffer(req);
#line 408
        send_r_error(req);
#line 409
        log_error("Got SIGBUS in memcpy\n");
        }
#line 410
        return (0);
      }
#line 412
      req->buffer_end = (int )((off_t volatile   )req->buffer_end + bytes_free);
#line 413
      req->bytes_written += (size_t )bytes_free;
#line 414
      r->start += (unsigned long )bytes_free;
#line 415
      if (bytes_free == (off_t volatile   )want) {
        {
#line 417
        tmp___20 = complete_response(req);
        }
#line 417
        return (tmp___20);
      }
    }
  }
#line 422
  return (1);
}
}
#line 435 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
int process_get(request *req ) 
{ 
  off_t bytes_written ;
  off_t volatile   bytes_to_write ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 440
  if ((unsigned int )req->method == 2U) {
    {
#line 441
    tmp = complete_response(req);
    }
#line 441
    return (tmp);
  }
#line 444
  bytes_to_write = (off_t volatile   )(((req->ranges)->stop - (req->ranges)->start) + 1UL);
#line 446
  if (bytes_to_write > (off_t volatile   )system_bufsize) {
#line 447
    bytes_to_write = (off_t volatile   )system_bufsize;
  }
  {
#line 449
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(env));
  }
#line 449
  if (tmp___1 == 0) {
    {
#line 450
    handle_sigbus = 1;
#line 451
    bytes_written = write(req->fd, (void const   *)(req->data_mem + (req->ranges)->start),
                          (size_t )bytes_to_write);
#line 453
    handle_sigbus = 0;
    }
  } else {
    {
#line 457
    req->status = (enum REQ_STATUS )12;
#line 458
    log_error_doc(req);
#line 459
    tmp___0 = get_commonlog_time();
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sGot SIGBUS in write(2)!\n",
            tmp___0);
    }
#line 469
    return (0);
  }
#line 472
  if (bytes_written < 0L) {
    {
#line 473
    tmp___2 = __errno_location();
    }
#line 473
    if (*tmp___2 == 11) {
#line 474
      return (-1);
    } else {
      {
#line 473
      tmp___3 = __errno_location();
      }
#line 473
      if (*tmp___3 == 11) {
#line 474
        return (-1);
      } else {
        {
#line 482
        log_error_doc(req);
#line 484
        perror("write");
#line 487
        req->status = (enum REQ_STATUS )12;
        }
#line 488
        return (0);
      }
    }
  }
#line 492
  req->bytes_written += (size_t )bytes_written;
#line 493
  (req->ranges)->start += (unsigned long )bytes_written;
#line 495
  if (((req->ranges)->stop + 1UL) - (req->ranges)->start == 0UL) {
    {
#line 496
    tmp___4 = complete_response(req);
    }
#line 496
    return (tmp___4);
  }
#line 499
  return (1);
}
}
#line 514 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
int get_dir(request *req , struct stat *statbuf ) 
{ 
  char pathname_with_index[4096] ;
  int data_fd ;
  unsigned int l1 ;
  unsigned int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 520
  if (directory_index) {
    {
#line 523
    tmp = strlen((char const   *)req->pathname);
#line 523
    l1 = (unsigned int )tmp;
#line 524
    tmp___0 = strlen((char const   *)directory_index);
#line 524
    l2 = (unsigned int )tmp___0;
    }
#line 526
    if ((unsigned long )(((l1 + l2) + 3U) + 1U) > sizeof(pathname_with_index)) {
      {
#line 531
      tmp___1 = __errno_location();
#line 531
      *tmp___1 = 12;
#line 532
      boa_perror(req, "pathname_with_index not large enough for pathname + index");
      }
#line 533
      return (-1);
    }
    {
#line 535
    memcpy((void */* __restrict  */)(pathname_with_index), (void const   */* __restrict  */)req->pathname,
           (size_t )l1);
#line 536
    memcpy((void */* __restrict  */)(pathname_with_index + l1), (void const   */* __restrict  */)directory_index,
           (size_t )(l2 + 1U));
#line 538
    data_fd = open((char const   *)(pathname_with_index), 0);
    }
#line 540
    if (data_fd != -1) {
      {
#line 545
      memcpy((void */* __restrict  */)(req->request_uri), (void const   */* __restrict  */)directory_index,
             (size_t )(l2 + 1U));
#line 546
      fstat(data_fd, statbuf);
      }
#line 547
      return (data_fd);
    }
    {
#line 549
    tmp___3 = __errno_location();
    }
#line 549
    if (*tmp___3 == 13) {
      {
#line 550
      send_r_forbidden(req);
      }
#line 551
      return (-1);
    } else {
      {
#line 552
      tmp___2 = __errno_location();
      }
#line 552
      if (*tmp___2 != 2) {
        {
#line 554
        send_r_not_found(req);
        }
#line 555
        return (-1);
      }
    }
    {
#line 561
    strcat((char */* __restrict  */)(pathname_with_index), (char const   */* __restrict  */)".gz");
#line 562
    data_fd = open((char const   *)(pathname_with_index), 0);
    }
#line 563
    if (data_fd != -1) {
      {
#line 564
      close(data_fd);
#line 566
      req->response_status = (enum RESPONSE_CODE )200;
#line 567
      req->keepalive = (enum KA_STATUS )2;
      }
#line 568
      if (req->pathname) {
        {
#line 569
        free((void *)req->pathname);
        }
      }
      {
#line 570
      req->pathname = strdup((char const   *)(pathname_with_index));
      }
#line 571
      if (! req->pathname) {
        {
#line 572
        boa_perror(req, "strdup of pathname_with_index for .gz files /home/june/collector/temp/boa-0.94.14rc21/src/get.c:572");
        }
#line 573
        return (0);
      }
#line 575
      if ((unsigned int )req->http_version != 1U) {
        {
#line 576
        tmp___4 = http_ver_string(req->http_version);
#line 576
        req_write(req, tmp___4);
#line 577
        req_write(req, " 200 OK-GUNZIP\r\n");
#line 578
        print_http_headers(req);
#line 579
        print_last_modified(req);
#line 580
        req_write(req, "Content-Type: ");
#line 581
        tmp___5 = get_mime_type((char const   *)directory_index);
#line 581
        req_write(req, (char const   *)tmp___5);
#line 582
        req_write(req, "\r\n\r\n");
#line 583
        req_flush(req);
        }
      }
#line 585
      if ((unsigned int )req->method == 2U) {
#line 586
        return (0);
      }
      {
#line 587
      tmp___6 = init_cgi(req);
      }
#line 587
      return (tmp___6);
    }
  }
#line 593
  if ((unsigned long )dirmaker != (unsigned long )((void *)0)) {
#line 594
    req->response_status = (enum RESPONSE_CODE )200;
#line 595
    req->keepalive = (enum KA_STATUS )2;
#line 598
    if ((unsigned int )req->http_version != 1U) {
      {
#line 599
      tmp___7 = http_ver_string(req->http_version);
#line 599
      req_write(req, tmp___7);
#line 600
      req_write(req, " 200 OK\r\n");
#line 601
      print_http_headers(req);
#line 602
      print_last_modified(req);
#line 603
      req_write(req, "Content-Type: text/html\r\n\r\n");
#line 604
      req_flush(req);
      }
    }
#line 606
    if ((unsigned int )req->method == 2U) {
#line 607
      return (0);
    }
    {
#line 609
    tmp___8 = init_cgi(req);
    }
#line 609
    return (tmp___8);
  } else
#line 611
  if (cachedir) {
    {
#line 612
    tmp___9 = get_cachedir_file(req, statbuf);
    }
#line 612
    return (tmp___9);
  } else {
    {
#line 614
    send_r_forbidden(req);
    }
#line 615
    return (-1);
  }
}
}
#line 619 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
static int get_cachedir_file(request *req , struct stat *statbuf ) 
{ 
  char pathname_with_index[4096] ;
  int data_fd ;
  time_t real_dir_mtime ;
  int tmp ;

  {
  {
#line 626
  real_dir_mtime = statbuf->st_mtim.tv_sec;
#line 630
  snprintf((char */* __restrict  */)(pathname_with_index), sizeof(pathname_with_index),
           (char const   */* __restrict  */)"%s/dir.%d.%ld", cachedir, (int )statbuf->st_dev,
           statbuf->st_ino);
#line 633
  data_fd = open((char const   *)(pathname_with_index), 0);
  }
#line 635
  if (data_fd != -1) {
    {
#line 637
    fstat(data_fd, statbuf);
    }
#line 638
    if (statbuf->st_mtim.tv_sec > real_dir_mtime) {
      {
#line 639
      statbuf->st_mtim.tv_sec = real_dir_mtime;
#line 640
      strcpy((char */* __restrict  */)(req->request_uri), (char const   */* __restrict  */)directory_index);
      }
#line 641
      return (data_fd);
    }
    {
#line 643
    close(data_fd);
#line 644
    unlink((char const   *)(pathname_with_index));
    }
  }
  {
#line 646
  tmp = index_directory___0(req, pathname_with_index);
  }
#line 646
  if (tmp == -1) {
#line 647
    return (-1);
  }
  {
#line 649
  data_fd = open((char const   *)(pathname_with_index), 0);
  }
#line 650
  if (data_fd != -1) {
    {
#line 651
    strcpy((char */* __restrict  */)(req->request_uri), (char const   */* __restrict  */)directory_index);
#line 652
    fstat(data_fd, statbuf);
#line 653
    statbuf->st_mtim.tv_sec = real_dir_mtime;
    }
#line 654
    return (data_fd);
  }
  {
#line 657
  boa_perror(req, "re-opening dircache");
  }
#line 658
  return (-1);
}
}
#line 673 "/home/june/collector/temp/boa-0.94.14rc21/src/get.c"
static int index_directory___0(request *req , char *dest_filename ) 
{ 
  DIR *request_dir ;
  FILE *fdstream ;
  struct dirent *dirbuf ;
  off_t bytes ;
  char *escname ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int errno_save ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 678
  bytes = (off_t )0;
#line 679
  escname = (char *)((void *)0);
#line 681
  tmp___1 = chdir((char const   *)req->pathname);
  }
#line 681
  if (tmp___1 == -1) {
    {
#line 682
    tmp = __errno_location();
    }
#line 682
    if (*tmp == 13) {
      {
#line 683
      send_r_forbidden(req);
      }
    } else {
      {
#line 682
      tmp___0 = __errno_location();
      }
#line 682
      if (*tmp___0 == 1) {
        {
#line 683
        send_r_forbidden(req);
        }
      } else {
        {
#line 685
        log_error_doc(req);
#line 686
        perror("chdir");
#line 687
        send_r_bad_request(req);
        }
      }
    }
#line 689
    return (-1);
  }
  {
#line 692
  request_dir = opendir(".");
  }
#line 693
  if ((unsigned long )request_dir == (unsigned long )((void *)0)) {
    {
#line 694
    tmp___2 = __errno_location();
#line 694
    errno_save = *tmp___2;
#line 695
    send_r_error(req);
#line 696
    log_error_doc(req);
#line 697
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opendir failed on directory \"%s\": ",
            req->pathname);
#line 698
    tmp___3 = __errno_location();
#line 698
    *tmp___3 = errno_save;
#line 699
    perror("opendir");
    }
#line 700
    return (-1);
  }
  {
#line 703
  fdstream = fopen((char const   */* __restrict  */)dest_filename, (char const   */* __restrict  */)"w");
  }
#line 704
  if ((unsigned long )fdstream == (unsigned long )((void *)0)) {
    {
#line 705
    boa_perror(req, "dircache fopen");
#line 706
    closedir(request_dir);
    }
#line 707
    return (-1);
  }
  {
#line 710
  tmp___4 = fprintf((FILE */* __restrict  */)fdstream, (char const   */* __restrict  */)"<HTML><HEAD>\n<TITLE>Index of %s</TITLE>\n</HEAD>\n\n",
                    req->request_uri);
#line 710
  bytes += (off_t )tmp___4;
#line 713
  tmp___5 = fprintf((FILE */* __restrict  */)fdstream, (char const   */* __restrict  */)"<BODY>\n\n<H2>Index of %s</H2>\n\n<PRE>\n",
                    req->request_uri);
#line 713
  bytes += (off_t )tmp___5;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 716
    dirbuf = readdir(request_dir);
    }
#line 716
    if (! dirbuf) {
#line 716
      goto while_break;
    }
    {
#line 717
    tmp___6 = strcmp((char const   *)(dirbuf->d_name), ".");
    }
#line 717
    if (! tmp___6) {
#line 718
      goto while_continue;
    }
    {
#line 720
    tmp___8 = strcmp((char const   *)(dirbuf->d_name), "..");
    }
#line 720
    if (! tmp___8) {
      {
#line 721
      tmp___7 = fprintf((FILE */* __restrict  */)fdstream, (char const   */* __restrict  */)" [DIR] <A HREF=\"../\">Parent Directory</A>\n");
#line 721
      bytes += (off_t )tmp___7;
      }
#line 723
      goto while_continue;
    }
    {
#line 727
    escname = escape_string((char const   *)(dirbuf->d_name), (char *)((void *)0));
    }
#line 728
    if ((unsigned long )escname != (unsigned long )((void *)0)) {
      {
#line 729
      tmp___9 = fprintf((FILE */* __restrict  */)fdstream, (char const   */* __restrict  */)" <A HREF=\"%s\">%s</A>\n",
                        escname, dirbuf->d_name);
#line 729
      bytes += (off_t )tmp___9;
#line 731
      free((void *)escname);
#line 732
      escname = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 735
  closedir(request_dir);
#line 736
  tmp___10 = fprintf((FILE */* __restrict  */)fdstream, (char const   */* __restrict  */)"</PRE>\n\n</BODY>\n</HTML>\n");
#line 736
  bytes += (off_t )tmp___10;
#line 738
  fclose(fdstream);
#line 740
  chdir((char const   *)server_root);
#line 742
  req->filesize = bytes;
  }
#line 743
  return (0);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 254 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int single_post_limit ;
#line 259
unsigned int ka_max ;
#line 102 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
int read_header(request *req ) ;
#line 103
int read_body(request *req ) ;
#line 104
int write_body(request *req ) ;
#line 110
int process_header_end(request *req ) ;
#line 112
int process_logline(request *req ) ;
#line 113
int process_option_line(request *req ) ;
#line 39 "/home/june/collector/temp/boa-0.94.14rc21/src/read.c"
int read_header(request *req ) 
{ 
  off_t bytes ;
  char *check ;
  char *buffer___1 ;
  unsigned char uc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int retval ;
  int tmp___2 ;
  off_t content_length ;
  int tmp___3 ;
  off_t buf_bytes_left ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 45
  check = req->client_stream + req->parse_pos;
#line 46
  buffer___1 = req->client_stream;
#line 47
  bytes = (off_t )req->client_stream_pos;
#line 49
  if (debug_level & (1 << 4)) {
#line 50
    if ((unsigned long )check < (unsigned long )(buffer___1 + bytes)) {
      {
#line 51
      *(buffer___1 + bytes) = (char )'\000';
#line 52
      log_error_time();
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - Parsing headers (\"%s\")\n",
              "/home/june/collector/temp/boa-0.94.14rc21/src/read.c", 54, check);
      }
    }
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )check < (unsigned long )(buffer___1 + bytes))) {
#line 57
      goto while_break;
    }
#line 62
    uc = (unsigned char )*check;
#line 63
    if ((int )uc != 13) {
#line 63
      if ((int )uc != 10) {
#line 63
        if ((int )uc != 9) {
#line 63
          if ((int )uc < 32) {
            {
#line 65
            log_error_doc(req);
#line 66
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal character (%d) in stream.\n",
                    (unsigned int )uc);
#line 67
            send_r_bad_request(req);
            }
#line 68
            return (0);
          } else
#line 63
          if ((int )uc > 127) {
            {
#line 65
            log_error_doc(req);
#line 66
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal character (%d) in stream.\n",
                    (unsigned int )uc);
#line 67
            send_r_bad_request(req);
            }
#line 68
            return (0);
          }
        }
      }
    }
    {
#line 71
    if ((unsigned int )req->status == 0U) {
#line 71
      goto case_0;
    }
#line 81
    if ((unsigned int )req->status == 1U) {
#line 81
      goto case_1;
    }
#line 88
    if ((unsigned int )req->status == 2U) {
#line 88
      goto case_2;
    }
#line 98
    if ((unsigned int )req->status == 3U) {
#line 98
      goto case_3;
    }
#line 105
    goto switch_default;
    case_0: /* CIL Label */ 
#line 72
    if ((int )uc == 13) {
#line 73
      req->status = (enum REQ_STATUS )1;
#line 74
      req->header_end = check;
    } else
#line 75
    if ((int )uc == 10) {
#line 76
      req->status = (enum REQ_STATUS )2;
#line 77
      req->header_end = check;
    }
#line 79
    goto switch_break;
    case_1: /* CIL Label */ 
#line 82
    if ((int )uc == 10) {
#line 83
      req->status = (enum REQ_STATUS )2;
    } else
#line 84
    if ((int )uc != 13) {
#line 85
      req->status = (enum REQ_STATUS )0;
    }
#line 86
    goto switch_break;
    case_2: /* CIL Label */ 
#line 90
    if ((int )uc == 13) {
#line 91
      req->status = (enum REQ_STATUS )3;
    } else
#line 92
    if ((int )uc == 10) {
#line 93
      req->status = (enum REQ_STATUS )4;
    } else {
#line 95
      req->status = (enum REQ_STATUS )0;
    }
#line 96
    goto switch_break;
    case_3: /* CIL Label */ 
#line 99
    if ((int )uc == 10) {
#line 100
      req->status = (enum REQ_STATUS )4;
    } else
#line 101
    if ((int )uc != 13) {
#line 102
      req->status = (enum REQ_STATUS )0;
    }
#line 103
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 106
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 114
    (req->parse_pos) ++;
#line 115
    check ++;
#line 117
    if ((unsigned int )req->status == 2U) {
#line 118
      *(req->header_end) = (char )'\000';
#line 120
      if (req->header_end - req->header_line >= 1024L) {
        {
#line 121
        log_error_doc(req);
#line 122
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header too long at %lu bytes: \"%s\"\n",
                (unsigned long )(req->header_end - req->header_line), req->header_line);
#line 125
        send_r_bad_request(req);
        }
#line 126
        return (0);
      }
#line 131
      if (req->logline) {
        {
#line 132
        tmp = process_option_line(req);
        }
#line 132
        if (tmp == 0) {
#line 134
          return (0);
        }
      } else {
        {
#line 137
        tmp___0 = process_logline(req);
        }
#line 137
        if (tmp___0 == 0) {
#line 139
          return (0);
        }
#line 140
        if ((unsigned int )req->http_version == 1U) {
          {
#line 141
          tmp___1 = process_header_end(req);
          }
#line 141
          return (tmp___1);
        }
      }
#line 144
      req->header_line = check;
    } else
#line 145
    if ((unsigned int )req->status == 4U) {
      {
#line 153
      tmp___2 = process_header_end(req);
#line 153
      retval = tmp___2;
      }
#line 157
      if (retval) {
#line 157
        if ((unsigned int )req->method == 4U) {
#line 160
          req->header_line = check;
#line 161
          req->header_end = req->client_stream + req->client_stream_pos;
#line 164
          req->status = (enum REQ_STATUS )5;
#line 181
          if (req->content_length) {
            {
#line 184
            tmp___3 = boa_atoi((char const   *)req->content_length);
#line 184
            content_length = (off_t )tmp___3;
            }
#line 186
            if (content_length < 0L) {
              {
#line 187
              log_error_doc(req);
#line 188
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid Content-Length [%s] on POST!\n",
                      req->content_length);
#line 191
              send_r_bad_request(req);
              }
#line 192
              return (0);
            }
#line 194
            if (single_post_limit) {
#line 194
              if (content_length > (off_t )single_post_limit) {
                {
#line 196
                log_error_doc(req);
#line 197
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Content-Length [%ld] > SinglePostLimit [%d] on POST!\n",
                        content_length, single_post_limit);
#line 200
                send_r_bad_request(req);
                }
#line 201
                return (0);
              }
            }
#line 203
            req->filesize = content_length;
#line 204
            req->filepos = (off_t )0;
#line 205
            if ((off_t )((unsigned int )(req->header_end - req->header_line)) > req->filesize) {
#line 206
              req->header_end = req->header_line + req->filesize;
            }
          } else {
            {
#line 209
            log_error_doc(req);
#line 210
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown Content-Length POST!\n");
#line 211
            send_r_bad_request(req);
            }
#line 212
            return (0);
          }
        }
      }
#line 215
      return (retval);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if ((unsigned int )req->status < 4U) {
#line 229
    buf_bytes_left = (off_t )(8192 - req->client_stream_pos);
#line 230
    if (buf_bytes_left < 1L) {
      {
#line 231
      log_error_doc(req);
#line 232
      fputs((char const   */* __restrict  */)"No space left in client stream buffer, closing\n",
            (FILE */* __restrict  */)stderr);
#line 234
      req->response_status = (enum RESPONSE_CODE )400;
#line 235
      req->status = (enum REQ_STATUS )12;
      }
#line 236
      return (0);
    } else
#line 230
    if (buf_bytes_left > 8192L) {
      {
#line 231
      log_error_doc(req);
#line 232
      fputs((char const   */* __restrict  */)"No space left in client stream buffer, closing\n",
            (FILE */* __restrict  */)stderr);
#line 234
      req->response_status = (enum RESPONSE_CODE )400;
#line 235
      req->status = (enum REQ_STATUS )12;
      }
#line 236
      return (0);
    }
    {
#line 239
    bytes = read(req->fd, (void *)(buffer___1 + req->client_stream_pos), (size_t )buf_bytes_left);
    }
#line 242
    if (bytes < 0L) {
      {
#line 243
      tmp___6 = __errno_location();
      }
#line 243
      if (*tmp___6 == 4) {
#line 244
        return (1);
      } else {
        {
#line 245
        tmp___4 = __errno_location();
        }
#line 245
        if (*tmp___4 == 11) {
#line 246
          return (-1);
        } else {
          {
#line 245
          tmp___5 = __errno_location();
          }
#line 245
          if (*tmp___5 == 11) {
#line 246
            return (-1);
          }
        }
      }
      {
#line 247
      log_error_doc(req);
#line 248
      perror("header read");
#line 249
      req->response_status = (enum RESPONSE_CODE )400;
      }
#line 250
      return (0);
    } else
#line 251
    if (bytes == 0L) {
#line 252
      if (req->kacount < ka_max) {
#line 252
        if (! req->logline) {
#line 252
          if (! (req->client_stream_pos == 0)) {
            {
#line 262
            log_error_doc(req);
#line 263
            fputs((char const   */* __restrict  */)"client unexpectedly closed connection.\n",
                  (FILE */* __restrict  */)stderr);
            }
          }
        } else {
          {
#line 262
          log_error_doc(req);
#line 263
          fputs((char const   */* __restrict  */)"client unexpectedly closed connection.\n",
                (FILE */* __restrict  */)stderr);
          }
        }
      } else {
        {
#line 262
        log_error_doc(req);
#line 263
        fputs((char const   */* __restrict  */)"client unexpectedly closed connection.\n",
              (FILE */* __restrict  */)stderr);
        }
      }
#line 266
      req->response_status = (enum RESPONSE_CODE )400;
#line 267
      return (0);
    }
#line 271
    req->client_stream_pos = (int )((off_t )req->client_stream_pos + bytes);
#line 273
    if (debug_level & (1 << 4)) {
      {
#line 274
      log_error_time();
#line 275
      req->client_stream[req->client_stream_pos] = (char )'\000';
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d -- We read %ld bytes: \"%s\"\n",
              "/home/june/collector/temp/boa-0.94.14rc21/src/read.c", 277, bytes,
              "");
      }
    }
#line 286
    return (1);
  }
#line 288
  return (1);
}
}
#line 310 "/home/june/collector/temp/boa-0.94.14rc21/src/read.c"
int read_body(request *req ) 
{ 
  off_t bytes_read ;
  off_t bytes_to_read ;
  off_t bytes_free ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 315
  bytes_free = 4096L - (req->header_end - req->header_line);
#line 316
  bytes_to_read = req->filesize - req->filepos;
#line 318
  if (bytes_to_read > bytes_free) {
#line 319
    bytes_to_read = bytes_free;
  }
#line 321
  if (bytes_to_read <= 0L) {
#line 322
    req->status = (enum REQ_STATUS )5;
#line 323
    return (1);
  }
  {
#line 326
  bytes_read = read(req->fd, (void *)req->header_end, (size_t )bytes_to_read);
  }
#line 328
  if (bytes_read == -1L) {
    {
#line 329
    tmp = __errno_location();
    }
#line 329
    if (*tmp == 11) {
#line 330
      return (-1);
    } else {
      {
#line 329
      tmp___0 = __errno_location();
      }
#line 329
      if (*tmp___0 == 11) {
#line 330
        return (-1);
      } else {
        {
#line 332
        boa_perror(req, "read body");
#line 333
        req->response_status = (enum RESPONSE_CODE )400;
        }
#line 334
        return (0);
      }
    }
  } else
#line 336
  if (bytes_read == 0L) {
    {
#line 338
    log_error_doc(req);
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - Premature end of body!!\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/read.c", 340);
#line 341
    send_r_bad_request(req);
    }
#line 342
    return (0);
  }
#line 345
  req->status = (enum REQ_STATUS )5;
#line 353
  req->header_end += bytes_read;
#line 355
  return (1);
}
}
#line 368 "/home/june/collector/temp/boa-0.94.14rc21/src/read.c"
int write_body(request *req ) 
{ 
  off_t bytes_written ;
  off_t bytes_to_write ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char c ;

  {
#line 371
  bytes_to_write = req->header_end - req->header_line;
#line 373
  if (req->filepos + bytes_to_write > req->filesize) {
#line 374
    bytes_to_write = req->filesize - req->filepos;
  }
#line 376
  if (bytes_to_write == 0L) {
#line 377
    tmp = req->buffer;
#line 377
    req->header_end = tmp;
#line 377
    req->header_line = tmp;
#line 378
    if (req->filepos >= req->filesize) {
      {
#line 379
      tmp___0 = init_cgi(req);
      }
#line 379
      return (tmp___0);
    }
#line 381
    req->status = (enum REQ_STATUS )4;
#line 382
    return (1);
  }
  {
#line 384
  bytes_written = write(req->post_data_fd, (void const   *)req->header_line, (size_t )bytes_to_write);
  }
#line 387
  if (bytes_written < 0L) {
    {
#line 388
    tmp___3 = __errno_location();
    }
#line 388
    if (*tmp___3 == 11) {
#line 389
      return (-1);
    } else {
      {
#line 388
      tmp___4 = __errno_location();
      }
#line 388
      if (*tmp___4 == 11) {
#line 389
        return (-1);
      } else {
        {
#line 390
        tmp___2 = __errno_location();
        }
#line 390
        if (*tmp___2 == 4) {
#line 391
          return (1);
        } else {
          {
#line 392
          tmp___1 = __errno_location();
          }
#line 392
          if (*tmp___1 == 28) {
            {
#line 396
            boa_perror(req, "write body");
            }
#line 397
            return (0);
          } else {
            {
#line 399
            boa_perror(req, "write body");
            }
#line 400
            return (0);
          }
        }
      }
    }
  }
#line 403
  if (debug_level & (1 << 4)) {
    {
#line 404
    log_error_time();
#line 405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - wrote %ld bytes of CGI body. %ld of %ld\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/read.c", 406, bytes_written,
            req->filepos, req->filesize);
    }
  }
#line 410
  req->filepos += bytes_written;
#line 411
  req->header_line += bytes_written;
#line 413
  if (debug_level & (1 << 2)) {
    {
#line 414
    log_error_time();
#line 416
    c = *(req->header_line + bytes_written);
#line 418
    *(req->header_line + bytes_written) = (char )'\000';
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - wrote %ld bytes (%s). %ld of %ld\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/read.c", 421, bytes_written,
            req->header_line, req->filepos, req->filesize);
#line 423
    *(req->header_line + bytes_written) = c;
    }
  }
#line 427
  return (1);
}
}
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 240 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *document_root ;
#line 241
char *user_dir ;
#line 56 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void add_alias(char const   *fakename , char const   *realname , enum ALIAS type ) ;
#line 57
int translate_uri(request *req ) ;
#line 74
char *get_home_dir(char const   *name ) ;
#line 134
void send_r_moved_temp(request *req , char const   *url , char const   *more_hdr ) ;
#line 39 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static alias *alias_hashtable[17]  ;
#line 40
static alias *find_alias(char *uri , unsigned int urilen ) ;
#line 41
static int init_script_alias(request *req , alias *current1 , unsigned int uri_len ) ;
#line 43
static unsigned int get_alias_hash_value(char const   *file ) ;
#line 53 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static unsigned int get_alias_hash_value(char const   *file ) 
{ 
  unsigned int hash ;
  unsigned int i ;
  char c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 55
  hash = 0U;
#line 56
  i = 0U;
#line 59
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 60
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 60, "get_alias_hash_value",
                   "file sent to get_alias_hash_value is NULL");
    }
#line 61
    return (0U);
  } else
#line 62
  if ((int const   )*(file + 0) == 0) {
    {
#line 63
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 63, "get_alias_hash_value",
                   "file sent to get_alias_hash_value is empty");
    }
#line 64
    return (0U);
  }
#line 67
  tmp = i;
#line 67
  i ++;
#line 67
  hash = (unsigned int )*(file + tmp);
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    tmp___0 = i;
#line 68
    i ++;
#line 68
    c = (char )*(file + tmp___0);
#line 68
    if (c) {
#line 68
      if (! ((int )c != 47)) {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
#line 69
    hash += (unsigned int )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (hash % 17U);
}
}
#line 81 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
void add_alias(char const   *fakename , char const   *realname , enum ALIAS type ) 
{ 
  unsigned int hash ;
  alias *old ;
  alias *new ;
  unsigned int fakelen ;
  unsigned int reallen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 88
  if ((unsigned long )fakename == (unsigned long )((void *)0)) {
    {
#line 89
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         89, "add_alias", "NULL values sent to add_alias");
    }
  } else
#line 88
  if ((unsigned long )realname == (unsigned long )((void *)0)) {
    {
#line 89
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         89, "add_alias", "NULL values sent to add_alias");
    }
  }
  {
#line 92
  tmp = strlen(fakename);
#line 92
  fakelen = (unsigned int )tmp;
#line 93
  tmp___0 = strlen(realname);
#line 93
  reallen = (unsigned int )tmp___0;
  }
#line 94
  if (fakelen == 0U) {
    {
#line 95
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         95, "add_alias", "empty values sent to add_alias");
    }
  } else
#line 94
  if (reallen == 0U) {
    {
#line 95
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         95, "add_alias", "empty values sent to add_alias");
    }
  }
  {
#line 98
  hash = get_alias_hash_value(fakename);
  }
#line 100
  if (debug_level & 1) {
    {
#line 101
    log_error_time();
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - Going to add alias: \"%s\" -=> \"%s\" (hash: %u)\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 103, fakename,
            realname, hash);
    }
  }
#line 106
  old = alias_hashtable[hash];
#line 108
  if (old) {
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! old->next) {
#line 109
        goto while_break;
      }
      {
#line 110
      tmp___1 = strcmp(fakename, (char const   *)old->fakename);
      }
#line 110
      if (! tmp___1) {
#line 111
        return;
      }
#line 112
      old = old->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 116
  tmp___2 = malloc(sizeof(alias ));
#line 116
  new = (alias *)tmp___2;
  }
#line 117
  if (! new) {
    {
#line 118
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         118, "add_alias", "out of memory adding alias to hash");
    }
  }
#line 121
  if (old) {
#line 122
    old->next = new;
  } else {
#line 124
    alias_hashtable[hash] = new;
  }
  {
#line 126
  new->fakename = strdup(fakename);
  }
#line 127
  if (! new->fakename) {
    {
#line 128
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         128, "add_alias", "failed strdup");
    }
  }
  {
#line 130
  new->fake_len = fakelen;
#line 132
  new->realname = strdup(realname);
  }
#line 133
  if (! new->realname) {
    {
#line 134
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c",
                         134, "add_alias", "strdup of realname failed");
    }
  }
#line 136
  new->real_len = reallen;
#line 138
  new->type = type;
#line 139
  new->next = (struct alias *)((void *)0);
#line 141
  if (debug_level & 1) {
    {
#line 142
    log_error_time();
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - ADDED alias: \"%s\" -=> \"%s\" hash: %u\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 145, fakename,
            realname, hash);
    }
  }
#line 147
  return;
}
}
#line 159 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static alias *find_alias(char *uri , unsigned int urilen ) 
{ 
  alias *current ;
  unsigned int hash ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 166
  if (urilen == 0U) {
    {
#line 167
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 167, "find_alias",
                   "uri len is 0!");
#line 168
    tmp = strlen((char const   *)uri);
#line 168
    urilen = (unsigned int )tmp;
    }
  }
  {
#line 171
  hash = get_alias_hash_value((char const   *)uri);
  }
#line 173
  if (debug_level & 1) {
    {
#line 174
    log_error_time();
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - looking for \"%s\" (hash=%u,len=%u)...\n",
            "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 177, uri, hash,
            urilen);
    }
  }
#line 180
  current = alias_hashtable[hash];
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! current) {
#line 181
      goto while_break;
    }
#line 182
    if (debug_level & 1) {
      {
#line 183
      log_error_time();
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d - comparing \"%s\" (request) to \"%s\" (alias): ",
              "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c", 186, uri, current->fakename);
      }
    }
#line 198
    if (current->fake_len <= urilen) {
      {
#line 198
      tmp___0 = memcmp((void const   *)uri, (void const   *)current->fakename, (size_t )current->fake_len);
      }
#line 198
      if (tmp___0) {
#line 198
        goto _L___2;
      } else
#line 198
      if ((int )*(current->fakename + (current->fake_len - 1U)) == 47) {
#line 198
        goto _L___1;
      } else
#line 198
      if ((int )*(current->fakename + (current->fake_len - 1U)) != 47) {
#line 198
        if ((int )*(uri + current->fake_len) == 0) {
#line 198
          goto _L___1;
        } else
#line 198
        if ((int )*(uri + current->fake_len) == 47) {
          _L___1: /* CIL Label */ 
#line 204
          if (debug_level & 1) {
            {
#line 205
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Got it! (%s)\n",
                    current->realname);
            }
          }
#line 207
          return (current);
        } else {
#line 198
          goto _L___2;
        }
      } else {
#line 198
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 209
    if (debug_level & 1) {
      {
#line 210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Don\'t Got it!\n");
      }
    }
#line 213
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (current);
}
}
#line 237 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static char buffer[1025]  ;
#line 235 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
int translate_uri(request *req ) 
{ 
  alias *current ;
  char *p ;
  unsigned int uri_len ;
  size_t tmp ;
  int tmp___0 ;
  char *user_homedir ;
  char *req_urip ;
  void *tmp___1 ;
  unsigned int l1 ;
  size_t tmp___2 ;
  unsigned int l2 ;
  size_t tmp___3 ;
  unsigned int l3___0 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned int l1___0 ;
  unsigned int l2___0 ;
  unsigned int l3___1 ;
  unsigned int l4___0 ;
  unsigned int l5 ;
  char *ap ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned int l1___1 ;
  unsigned int l2___1 ;
  unsigned int l3___2 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 242
  if ((int )req->request_uri[0] != 47) {
    {
#line 243
    send_r_bad_request(req);
    }
#line 244
    return (0);
  }
  {
#line 247
  tmp = strlen((char const   *)(req->request_uri));
#line 247
  uri_len = (unsigned int )tmp;
#line 248
  current = find_alias(req->request_uri, uri_len);
  }
#line 249
  if (current) {
#line 250
    if ((unsigned int )current->type == 1U) {
      {
#line 251
      tmp___0 = init_script_alias(req, current, uri_len);
      }
#line 251
      return (tmp___0);
    }
#line 254
    if ((unsigned long )(((current->real_len + uri_len) - current->fake_len) + 1U) > sizeof(buffer)) {
      {
#line 255
      log_error_doc(req);
#line 256
      fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 257
      send_r_bad_request(req);
      }
#line 258
      return (0);
    }
    {
#line 260
    memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)current->realname,
           (size_t )current->real_len);
#line 261
    memcpy((void */* __restrict  */)(buffer + current->real_len), (void const   */* __restrict  */)(req->request_uri + current->fake_len),
           (size_t )((uri_len - current->fake_len) + 1U));
    }
#line 265
    if ((unsigned int )current->type == 2U) {
#line 266
      if ((unsigned int )req->method == 4U) {
        {
#line 268
        log_error_doc(req);
#line 269
        fputs((char const   */* __restrict  */)"POST to non-script is disallowed.\n",
              (FILE */* __restrict  */)stderr);
#line 270
        send_r_bad_request(req);
        }
#line 271
        return (0);
      }
      {
#line 273
      send_r_moved_temp(req, (char const   *)(buffer), "");
      }
#line 274
      return (0);
    } else {
      {
#line 276
      req->pathname = strdup((char const   *)(buffer));
      }
#line 277
      if (! req->pathname) {
        {
#line 278
        boa_perror(req, "unable to strdup buffer onto req->pathname");
        }
#line 279
        return (0);
      }
#line 281
      return (1);
    }
  }
#line 290
  if (user_dir) {
#line 290
    if ((int )req->request_uri[1] == 126) {
#line 294
      if ((int )req->request_uri[2] == 0) {
        {
#line 295
        log_error_doc(req);
#line 296
        fputs((char const   */* __restrict  */)"Empty user-dir in URI\n", (FILE */* __restrict  */)stderr);
#line 297
        send_r_bad_request(req);
        }
#line 298
        return (0);
      }
      {
#line 301
      req_urip = req->request_uri + 2;
#line 304
      tmp___1 = memchr((void const   *)req_urip, '/', (size_t )(uri_len - 2U));
#line 304
      p = (char *)tmp___1;
      }
#line 305
      if (p) {
#line 306
        *p = (char )'\000';
      }
      {
#line 308
      user_homedir = get_home_dir((char const   *)req_urip);
      }
#line 309
      if (p) {
#line 310
        *p = (char )'/';
      }
#line 312
      if (! user_homedir) {
        {
#line 313
        send_r_not_found(req);
        }
#line 314
        return (0);
      } else {
        {
#line 316
        tmp___2 = strlen((char const   *)user_homedir);
#line 316
        l1 = (unsigned int )tmp___2;
#line 317
        tmp___3 = strlen((char const   *)user_dir);
#line 317
        l2 = (unsigned int )tmp___3;
        }
#line 318
        if (p) {
          {
#line 318
          tmp___4 = strlen((char const   *)p);
#line 318
          tmp___5 = tmp___4;
          }
        } else {
#line 318
          tmp___5 = (size_t )0;
        }
#line 318
        l3___0 = (unsigned int )tmp___5;
#line 321
        if ((unsigned long )((((l1 + 1U) + l2) + l3___0) + 1U) > sizeof(buffer)) {
          {
#line 322
          log_error_doc(req);
#line 323
          fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 324
          send_r_bad_request(req);
          }
#line 325
          return (0);
        }
        {
#line 328
        memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)user_homedir,
               (size_t )l1);
#line 329
        buffer[l1] = (char )'/';
#line 331
        memcpy((void */* __restrict  */)((buffer + l1) + 1), (void const   */* __restrict  */)user_dir,
               (size_t )(l2 + 1U));
        }
#line 332
        if (p) {
          {
#line 333
          memcpy((void */* __restrict  */)(((buffer + l1) + 1) + l2), (void const   */* __restrict  */)p,
                 (size_t )(l3___0 + 1U));
          }
        }
      }
    } else {
#line 290
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 335
  if (vhost_root) {
    {
#line 338
    ap = (char *)((void *)0);
#line 344
    tmp___6 = strlen((char const   *)vhost_root);
#line 344
    l1___0 = (unsigned int )tmp___6;
#line 345
    tmp___7 = strlen((char const   *)(req->local_ip_addr));
#line 345
    l2___0 = (unsigned int )tmp___7;
#line 346
    ap = req->host;
#line 347
    tmp___8 = strlen((char const   *)ap);
#line 347
    l3___1 = (unsigned int )tmp___8;
#line 348
    tmp___9 = strlen("htdocs");
#line 348
    l4___0 = (unsigned int )tmp___9;
#line 349
    tmp___10 = strlen((char const   *)(req->request_uri));
#line 349
    l5 = (unsigned int )tmp___10;
    }
#line 351
    if ((unsigned long )((((((((l1___0 + 1U) + l2___0) + 1U) + l3___1) + 1U) + l4___0) + l5) + 1U) > sizeof(buffer)) {
      {
#line 352
      log_error_doc(req);
#line 353
      fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 354
      send_r_bad_request(req);
      }
#line 355
      return (0);
    }
    {
#line 358
    memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)vhost_root,
           (size_t )l1___0);
#line 359
    buffer[l1___0] = (char )'/';
#line 360
    memcpy((void */* __restrict  */)((buffer + l1___0) + 1), (void const   */* __restrict  */)(req->local_ip_addr),
           (size_t )l2___0);
#line 361
    buffer[(l1___0 + 1U) + l2___0] = (char )'/';
#line 362
    memcpy((void */* __restrict  */)((((buffer + l1___0) + 1) + l2___0) + 1), (void const   */* __restrict  */)ap,
           (size_t )l3___1);
#line 363
    buffer[(((l1___0 + 1U) + l2___0) + 1U) + l3___1] = (char )'/';
#line 364
    memcpy((void */* __restrict  */)((((((buffer + l1___0) + 1) + l2___0) + 1) + l3___1) + 1),
           (void const   */* __restrict  */)"htdocs", (size_t )l4___0);
#line 366
    memcpy((void */* __restrict  */)(((((((buffer + l1___0) + 1) + l2___0) + 1) + l3___1) + 1) + l4___0),
           (void const   */* __restrict  */)(req->request_uri), (size_t )(l5 + 1U));
    }
  } else
#line 368
  if (document_root) {
    {
#line 372
    tmp___11 = strlen((char const   *)document_root);
#line 372
    l1___1 = (unsigned int )tmp___11;
#line 373
    tmp___12 = strlen((char const   *)(req->request_uri));
#line 373
    l2___1 = (unsigned int )tmp___12;
    }
#line 374
    if (virtualhost) {
      {
#line 375
      tmp___13 = strlen((char const   *)(req->local_ip_addr));
#line 375
      l3___2 = (unsigned int )tmp___13;
      }
    } else {
#line 377
      l3___2 = 0U;
    }
#line 379
    if ((unsigned long )((((l1___1 + 1U) + l2___1) + l3___2) + 1U) > sizeof(buffer)) {
      {
#line 380
      log_error_doc(req);
#line 381
      fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 382
      send_r_bad_request(req);
      }
#line 383
      return (0);
    }
    {
#line 387
    memcpy((void */* __restrict  */)(buffer), (void const   */* __restrict  */)document_root,
           (size_t )l1___1);
    }
#line 388
    if (virtualhost) {
      {
#line 389
      buffer[l1___1] = (char )'/';
#line 390
      memcpy((void */* __restrict  */)((buffer + l1___1) + 1), (void const   */* __restrict  */)(req->local_ip_addr),
             (size_t )l3___2);
#line 391
      memcpy((void */* __restrict  */)(((buffer + l1___1) + 1) + l3___2), (void const   */* __restrict  */)(req->request_uri),
             (size_t )(l2___1 + 1U));
      }
    } else {
      {
#line 393
      memcpy((void */* __restrict  */)(buffer + l1___1), (void const   */* __restrict  */)(req->request_uri),
             (size_t )(l2___1 + 1U));
      }
    }
  } else {
    {
#line 396
    send_r_not_found(req);
    }
#line 397
    return (0);
  }
  {
#line 406
  req->pathname = strdup((char const   *)(buffer));
  }
#line 407
  if (! req->pathname) {
    {
#line 408
    boa_perror(req, "Could not strdup buffer for req->pathname!");
    }
#line 409
    return (0);
  }
  {
#line 422
  tmp___14 = get_mime_type((char const   *)req->pathname);
#line 422
  tmp___15 = strcmp("application/x-httpd-cgi", (char const   *)tmp___14);
  }
#line 422
  if (tmp___15 == 0) {
    {
#line 425
    req->script_name = strdup((char const   *)(req->request_uri));
    }
#line 426
    if (! req->script_name) {
      {
#line 427
      boa_perror(req, "Could not strdup req->request_uri for req->script_name.");
      }
#line 428
      return (0);
    }
#line 430
    if ((unsigned int )req->http_version == 1U) {
#line 431
      req->cgi_type = (enum CGI_TYPE )1;
    } else {
#line 433
      req->cgi_type = (enum CGI_TYPE )2;
    }
#line 434
    return (1);
  } else
#line 435
  if ((unsigned int )req->method == 4U) {
    {
#line 437
    log_error_doc(req);
#line 438
    fputs((char const   */* __restrict  */)"POST to non-script disallowed.\n", (FILE */* __restrict  */)stderr);
#line 439
    send_r_bad_request(req);
    }
#line 440
    return (0);
  } else {
#line 442
    return (1);
  }
}
}
#line 459 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static char pathname[1025]  ;
#line 619 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static char buffer___0[1025]  ;
#line 457 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
static int init_script_alias(request *req , alias *current1 , unsigned int uri_len ) 
{ 
  struct stat statbuf ;
  int i ;
  char c ;
  int err ;
  unsigned int l1 ;
  unsigned int l2 ;
  unsigned int l3___0 ;
  char *ap ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int hash ;
  alias *current ;
  int path_len ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *user_homedir ;
  char *p ;
  unsigned int l1___0 ;
  size_t tmp___8 ;
  unsigned int l2___0 ;
  size_t tmp___9 ;
  unsigned int l3___1 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  unsigned int l1___1 ;
  unsigned int l2___1 ;
  size_t tmp___12 ;
  void *tmp___13 ;

  {
#line 462
  i = 0;
#line 470
  if (vhost_root) {
    {
#line 475
    tmp = strlen((char const   *)vhost_root);
#line 475
    l1 = (unsigned int )tmp;
#line 476
    tmp___0 = strlen((char const   *)(req->local_ip_addr));
#line 476
    l2 = (unsigned int )tmp___0;
#line 477
    ap = req->host;
#line 478
    tmp___1 = strlen((char const   *)ap);
#line 478
    l3___0 = (unsigned int )tmp___1;
    }
#line 480
    if ((unsigned long )((((((((l1 + 1U) + l2) + 1U) + l3___0) + 1U) + current1->real_len) + (uri_len - current1->fake_len)) + 1U) > sizeof(pathname)) {
      {
#line 482
      log_error_doc(req);
#line 483
      fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 484
      send_r_bad_request(req);
      }
#line 485
      return (0);
    }
    {
#line 487
    memcpy((void */* __restrict  */)(pathname), (void const   */* __restrict  */)vhost_root,
           (size_t )l1);
#line 488
    pathname[l1] = (char )'/';
#line 489
    memcpy((void */* __restrict  */)((pathname + l1) + 1), (void const   */* __restrict  */)(req->local_ip_addr),
           (size_t )l2);
#line 490
    pathname[(l1 + 1U) + l2] = (char )'/';
#line 491
    memcpy((void */* __restrict  */)((((pathname + l1) + 1) + l2) + 1), (void const   */* __restrict  */)ap,
           (size_t )l3___0);
#line 492
    pathname[(((l1 + 1U) + l2) + 1U) + l3___0] = (char )'/';
#line 493
    memcpy((void */* __restrict  */)((((((pathname + l1) + 1) + l2) + 1) + l3___0) + 1),
           (void const   */* __restrict  */)current1->realname, (size_t )current1->real_len);
#line 495
    memcpy((void */* __restrict  */)(((((((pathname + l1) + 1) + l2) + 1) + l3___0) + 1) + current1->real_len),
           (void const   */* __restrict  */)(& req->request_uri[current1->fake_len]),
           (size_t )((uri_len - current1->fake_len) + 1U));
    }
  } else {
#line 499
    if ((unsigned long )(((current1->real_len + uri_len) - current1->fake_len) + 1U) > sizeof(pathname)) {
      {
#line 501
      log_error_doc(req);
#line 502
      fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 503
      send_r_bad_request(req);
      }
#line 504
      return (0);
    }
    {
#line 506
    memcpy((void */* __restrict  */)(pathname), (void const   */* __restrict  */)current1->realname,
           (size_t )current1->real_len);
#line 507
    memcpy((void */* __restrict  */)(pathname + current1->real_len), (void const   */* __restrict  */)(& req->request_uri[current1->fake_len]),
           (size_t )((uri_len - current1->fake_len) + 1U));
    }
  }
  {
#line 517
  tmp___2 = strncmp("nph-", (char const   *)(pathname + current1->real_len), (size_t )4);
  }
#line 517
  if (tmp___2 == 0) {
#line 519
    req->cgi_type = (enum CGI_TYPE )1;
  } else
#line 517
  if ((unsigned int )req->http_version == 1U) {
#line 519
    req->cgi_type = (enum CGI_TYPE )1;
  } else {
#line 521
    req->cgi_type = (enum CGI_TYPE )2;
  }
#line 525
  i = (int )current1->real_len;
#line 526
  c = (char )'\000';
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    i ++;
#line 533
    c = pathname[i];
#line 534
    if ((int )c == 47) {
      {
#line 535
      pathname[i] = (char )'\000';
#line 536
      err = stat((char const   */* __restrict  */)(pathname), (struct stat */* __restrict  */)(& statbuf));
      }
#line 537
      if (err == -1) {
        {
#line 538
        send_r_not_found(req);
        }
#line 539
        return (0);
      }
#line 543
      if (! ((statbuf.st_mode & 61440U) == 16384U)) {
#line 548
        if (! ((statbuf.st_mode & 61440U) == 32768U)) {
          {
#line 549
          send_r_forbidden(req);
          }
#line 550
          return (0);
        } else {
          {
#line 548
          tmp___3 = access((char const   *)(pathname), 5);
          }
#line 548
          if (tmp___3) {
            {
#line 549
            send_r_forbidden(req);
            }
#line 550
            return (0);
          }
        }
#line 552
        pathname[i] = (char )'/';
#line 554
        goto while_break;
      }
#line 557
      pathname[i] = (char )'/';
    }
#line 532
    if (! ((int )c != 0)) {
#line 532
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  req->script_name = strdup((char const   *)(req->request_uri));
  }
#line 562
  if (! req->script_name) {
    {
#line 563
    boa_perror(req, "unable to strdup req->request_uri for req->script_name");
    }
#line 564
    return (0);
  }
#line 567
  if ((int )c == 0) {
    {
#line 568
    err = stat((char const   */* __restrict  */)(pathname), (struct stat */* __restrict  */)(& statbuf));
    }
#line 569
    if (err == -1) {
      {
#line 570
      send_r_not_found(req);
      }
#line 571
      return (0);
    }
#line 575
    if (! ((statbuf.st_mode & 61440U) == 16384U)) {
#line 580
      if (! ((statbuf.st_mode & 61440U) == 32768U)) {
        {
#line 581
        send_r_forbidden(req);
        }
#line 582
        return (0);
      } else {
        {
#line 580
        tmp___4 = access((char const   *)(pathname), 5);
        }
#line 580
        if (tmp___4) {
          {
#line 581
          send_r_forbidden(req);
          }
#line 582
          return (0);
        }
      }
    } else {
      {
#line 586
      send_r_forbidden(req);
      }
#line 587
      return (0);
    }
  } else
#line 592
  if ((int )c == 47) {
    {
#line 597
    req->path_info = strdup((char const   *)(pathname + i));
    }
#line 598
    if (! req->path_info) {
      {
#line 599
      boa_perror(req, "unable to strdup pathname + index for req->path_info");
      }
#line 600
      return (0);
    }
    {
#line 602
    pathname[i] = (char )'\000';
#line 603
    tmp___5 = strlen((char const   *)req->path_info);
#line 603
    path_len = (int )tmp___5;
#line 609
    tmp___6 = strlen((char const   *)req->script_name);
#line 609
    *(req->script_name + (tmp___6 - (size_t )path_len)) = (char )'\000';
#line 614
    hash = get_alias_hash_value((char const   *)req->path_info);
#line 615
    current = alias_hashtable[hash];
    }
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 616
      if (current) {
#line 616
        if (! (! req->path_translated)) {
#line 616
          goto while_break___0;
        }
      } else {
#line 616
        goto while_break___0;
      }
      {
#line 617
      tmp___7 = strncmp((char const   *)req->path_info, (char const   *)current->fakename,
                        (size_t )current->fake_len);
      }
#line 617
      if (! tmp___7) {
#line 621
        if ((unsigned long )(((current->real_len + (unsigned int )path_len) - current->fake_len) + 1U) > sizeof(buffer___0)) {
          {
#line 623
          log_error_doc(req);
#line 624
          fputs((char const   */* __restrict  */)"uri too long!\n", (FILE */* __restrict  */)stderr);
#line 625
          send_r_bad_request(req);
          }
#line 626
          return (0);
        }
        {
#line 629
        memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)current->realname,
               (size_t )current->real_len);
#line 634
        memcpy((void */* __restrict  */)(buffer___0 + current->real_len), (void const   */* __restrict  */)(req->path_info + current->fake_len),
               (size_t )(((unsigned int )path_len - current->fake_len) + 1U));
#line 637
        req->path_translated = strdup((char const   *)(buffer___0));
        }
#line 638
        if (! req->path_translated) {
          {
#line 639
          boa_perror(req, "unable to strdup buffer for req->path_translated");
          }
#line 640
          return (0);
        }
      }
#line 643
      current = current->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 646
    if (! req->path_translated) {
#line 646
      if (user_dir) {
#line 646
        if ((int )*(req->path_info + 1) == 126) {
          {
#line 650
          p = strchr((char const   *)((pathname + i) + 1), '/');
          }
#line 651
          if (p) {
#line 652
            *p = (char )'\000';
          }
          {
#line 654
          user_homedir = get_home_dir((char const   *)((pathname + i) + 2));
          }
#line 655
          if (p) {
#line 656
            *p = (char )'/';
          }
#line 658
          if (! user_homedir) {
            {
#line 659
            send_r_not_found(req);
            }
#line 660
            return (0);
          }
          {
#line 663
          tmp___8 = strlen((char const   *)user_homedir);
#line 663
          l1___0 = (unsigned int )tmp___8;
#line 664
          tmp___9 = strlen((char const   *)user_dir);
#line 664
          l2___0 = (unsigned int )tmp___9;
#line 665
          l3___1 = 0U;
          }
#line 666
          if (p) {
            {
#line 667
            tmp___10 = strlen((char const   *)p);
#line 667
            l3___1 = (unsigned int )tmp___10;
            }
          }
          {
#line 669
          tmp___11 = malloc((size_t )((((l1___0 + 1U) + l2___0) + l3___1) + 1U));
#line 669
          req->path_translated = (char *)tmp___11;
          }
#line 670
          if ((unsigned long )req->path_translated == (unsigned long )((void *)0)) {
            {
#line 671
            boa_perror(req, "unable to malloc memory for req->path_translated");
            }
#line 672
            return (0);
          }
          {
#line 674
          memcpy((void */* __restrict  */)req->path_translated, (void const   */* __restrict  */)user_homedir,
                 (size_t )l1___0);
#line 675
          *(req->path_translated + l1___0) = (char )'/';
#line 676
          memcpy((void */* __restrict  */)((req->path_translated + l1___0) + 1), (void const   */* __restrict  */)user_dir,
                 (size_t )(l2___0 + 1U));
          }
#line 677
          if (p) {
            {
#line 678
            memcpy((void */* __restrict  */)(((req->path_translated + l1___0) + 1) + l2___0),
                   (void const   */* __restrict  */)p, (size_t )(l3___1 + 1U));
            }
          }
        } else {
#line 646
          goto _L___0;
        }
      } else {
#line 646
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 680
    if (! req->path_translated) {
#line 680
      if (document_root) {
        {
#line 683
        tmp___12 = strlen((char const   *)document_root);
#line 683
        l1___1 = (unsigned int )tmp___12;
#line 684
        l2___1 = (unsigned int )path_len;
#line 686
        tmp___13 = malloc((size_t )((l1___1 + l2___1) + 1U));
#line 686
        req->path_translated = (char *)tmp___13;
        }
#line 687
        if ((unsigned long )req->path_translated == (unsigned long )((void *)0)) {
          {
#line 688
          boa_perror(req, "unable to malloc memory for req->path_translated");
          }
#line 689
          return (0);
        }
        {
#line 691
        memcpy((void */* __restrict  */)req->path_translated, (void const   */* __restrict  */)document_root,
               (size_t )l1___1);
#line 692
        memcpy((void */* __restrict  */)(req->path_translated + l1___1), (void const   */* __restrict  */)req->path_info,
               (size_t )(l2___1 + 1U));
        }
      }
    }
  }
  {
#line 696
  req->pathname = strdup((char const   *)(pathname));
  }
#line 697
  if (! req->pathname) {
    {
#line 698
    boa_perror(req, "unable to strdup pathname for req->pathname");
    }
#line 699
    return (0);
  }
#line 702
  return (1);
}
}
#line 709 "/home/june/collector/temp/boa-0.94.14rc21/src/alias.c"
void dump_alias(void) 
{ 
  int i ;
  alias *temp ;
  alias *temp_next ;

  {
#line 714
  i = 0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i < 17)) {
#line 714
      goto while_break;
    }
#line 715
    if (alias_hashtable[i]) {
#line 716
      temp = alias_hashtable[i];
      {
#line 717
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 717
        if (! temp) {
#line 717
          goto while_break___0;
        }
#line 720
        if (temp->fakename) {
          {
#line 721
          free((void *)temp->fakename);
          }
        }
#line 722
        if (temp->realname) {
          {
#line 723
          free((void *)temp->realname);
          }
        }
        {
#line 724
        temp_next = temp->next;
#line 725
        free((void *)temp);
#line 726
        temp = temp_next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 728
      alias_hashtable[i] = (alias *)((void *)0);
    }
#line 714
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 146 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void send_r_bad_gateway(request *req ) ;
#line 204
int process_cgi_header(request *req ) ;
#line 51 "/home/june/collector/temp/boa-0.94.14rc21/src/cgi_header.c"
int process_cgi_header(request *req ) 
{ 
  char *buf___0 ;
  char *c ;
  char *c2 ;
  char *tmp ;
  char *dest ;
  unsigned int howmuch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  if ((unsigned int )req->cgi_status != 2U) {
#line 57
    req->cgi_status = (enum CGI_STATUS )1;
  }
  {
#line 59
  buf___0 = req->header_line;
#line 61
  c = strstr((char const   *)buf___0, "\n\r\n");
  }
#line 62
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 63
    c = strstr((char const   *)buf___0, "\n\n");
    }
#line 64
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 65
      log_error_doc(req);
#line 66
      fputs((char const   */* __restrict  */)"cgi_header: unable to find LFLF\n",
            (FILE */* __restrict  */)stderr);
#line 71
      send_r_bad_gateway(req);
      }
#line 72
      return (0);
    }
  }
#line 75
  if ((unsigned int )req->http_version == 1U) {
#line 76
    if ((int )*(c + 1) == 13) {
#line 77
      req->header_line = c + 2;
    } else {
#line 79
      req->header_line = c + 1;
    }
#line 80
    return (1);
  }
  {
#line 82
  tmp___2 = strncasecmp((char const   *)buf___0, "Status: ", (size_t )8);
  }
#line 82
  if (tmp___2) {
    {
#line 85
    tmp___1 = strncasecmp((char const   *)buf___0, "Location: ", (size_t )10);
    }
#line 85
    if (tmp___1) {
      {
#line 139
      send_r_request_ok(req);
#line 146
      dest = req->buffer + req->buffer_end;
      }
#line 147
      if ((unsigned int )req->method == 2U) {
#line 148
        if ((int )*(c + 1) == 13) {
#line 149
          req->header_end = c + 2;
        } else {
#line 151
          req->header_end = c + 1;
        }
#line 152
        req->cgi_status = (enum CGI_STATUS )2;
      }
#line 154
      howmuch = (unsigned int )(req->header_end - req->header_line);
#line 156
      if ((unsigned long )(dest + howmuch) > (unsigned long )(req->buffer + 4096)) {
        {
#line 158
        log_error_doc(req);
#line 159
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too much data to move! Aborting! %s %d\n",
                "/home/june/collector/temp/boa-0.94.14rc21/src/cgi_header.c", 160);
#line 163
        tmp___0 = 0;
#line 163
        req->buffer_end = tmp___0;
#line 163
        req->buffer_start = tmp___0;
#line 164
        send_r_error(req);
        }
#line 165
        return (0);
      }
      {
#line 167
      memmove((void *)dest, (void const   *)req->header_line, (size_t )howmuch);
#line 168
      req->buffer_end = (int )((unsigned int )req->buffer_end + howmuch);
#line 169
      req->header_line = req->buffer + req->buffer_end;
#line 170
      req->header_end = req->header_line;
#line 171
      req_flush(req);
      }
#line 172
      if ((unsigned int )req->method == 2U) {
#line 173
        return (0);
      }
    } else {
#line 94
      if ((int )*(buf___0 + 10) == 47) {
        {
#line 95
        log_error_doc(req);
#line 96
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server does not support internal redirection: \"%s\"\n",
                buf___0 + 10);
#line 99
        send_r_bad_request(req);
        }
      } else {
        {
#line 116
        c2 = strchr((char const   *)(buf___0 + 10), '\n');
#line 119
        c2 --;
        }
        {
#line 120
        while (1) {
          while_continue: /* CIL Label */ ;
#line 120
          if (! ((int )*c2 == 13)) {
#line 120
            goto while_break;
          }
#line 121
          c2 --;
        }
        while_break: /* CIL Label */ ;
        }
#line 122
        c2 ++;
#line 124
        tmp = c2;
#line 124
        c2 ++;
#line 124
        *tmp = (char )'\000';
        {
#line 127
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 127
          if ((int )*c2 == 10) {
#line 127
            goto _L;
          } else
#line 127
          if ((int )*c2 == 13) {
            _L: /* CIL Label */ 
#line 127
            if (! ((unsigned long )c2 < (unsigned long )req->header_end)) {
#line 127
              goto while_break___0;
            }
          } else {
#line 127
            goto while_break___0;
          }
#line 128
          c2 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 129
        if ((unsigned long )c2 == (unsigned long )req->header_end) {
          {
#line 130
          send_r_moved_temp(req, (char const   *)(buf___0 + 10), "");
          }
        } else {
          {
#line 132
          send_r_moved_temp(req, (char const   *)(buf___0 + 10), (char const   *)c2);
          }
        }
      }
#line 134
      req->status = (enum REQ_STATUS )10;
#line 135
      return (1);
    }
  } else {
    {
#line 83
    (req->header_line) --;
#line 84
    memcpy((void */* __restrict  */)req->header_line, (void const   */* __restrict  */)"HTTP/1.0 ",
           (size_t )9);
    }
  }
#line 175
  return (1);
}
}
#line 207 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
int read_from_pipe(request *req ) ;
#line 208
int write_from_pipe(request *req ) ;
#line 209
int io_shuffle(request *req ) ;
#line 37 "/usr/include/x86_64-linux-gnu/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) sendfile)(int __out_fd ,
                                                                                   int __in_fd ,
                                                                                   __off64_t *__offset ,
                                                                                   size_t __count )  __asm__("sendfile64")  ;
#line 212 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
int io_shuffle_sendfile(request *req ) ;
#line 38 "/home/june/collector/temp/boa-0.94.14rc21/src/pipe.c"
int read_from_pipe(request *req ) 
{ 
  off_t bytes_read ;
  off_t bytes_to_read ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *c ;
  char *buf___0 ;
  int tmp___5 ;

  {
#line 43
  bytes_to_read = 4096L - ((req->header_end - req->buffer) - 1L);
#line 45
  if (bytes_to_read == 0L) {
#line 46
    if ((unsigned int )req->cgi_status == 0U) {
      {
#line 47
      req->cgi_status = (enum CGI_STATUS )1;
#line 48
      *(req->header_end) = (char )'\000';
#line 53
      tmp = process_cgi_header(req);
      }
#line 53
      return (tmp);
    }
#line 55
    req->status = (enum REQ_STATUS )8;
#line 56
    return (1);
  }
  {
#line 59
  bytes_read = read(req->data_fd, (void *)req->header_end, (size_t )bytes_to_read);
  }
#line 71
  if (bytes_read == -1L) {
    {
#line 72
    tmp___2 = __errno_location();
    }
#line 72
    if (*tmp___2 == 4) {
#line 73
      return (1);
    } else {
      {
#line 74
      tmp___0 = __errno_location();
      }
#line 74
      if (*tmp___0 == 11) {
#line 75
        return (-1);
      } else {
        {
#line 74
        tmp___1 = __errno_location();
        }
#line 74
        if (*tmp___1 == 11) {
#line 75
          return (-1);
        } else {
          {
#line 77
          req->status = (enum REQ_STATUS )12;
#line 78
          log_error_doc(req);
#line 79
          perror("pipe read");
          }
#line 80
          return (0);
        }
      }
    }
  }
#line 83
  *(req->header_end + bytes_read) = (char )'\000';
#line 85
  if (bytes_read == 0L) {
#line 86
    req->status = (enum REQ_STATUS )8;
#line 87
    if ((unsigned int )req->cgi_status == 0U) {
      {
#line 88
      req->cgi_status = (enum CGI_STATUS )2;
#line 89
      *(req->header_end) = (char )'\000';
#line 90
      tmp___3 = process_cgi_header(req);
      }
#line 90
      return (tmp___3);
    }
#line 92
    req->cgi_status = (enum CGI_STATUS )2;
#line 93
    return (1);
  }
#line 96
  req->header_end += bytes_read;
#line 98
  if ((unsigned int )req->cgi_status != 0U) {
    {
#line 99
    tmp___4 = write_from_pipe(req);
    }
#line 99
    return (tmp___4);
  } else {
    {
#line 103
    buf___0 = req->header_line;
#line 105
    c = strstr((char const   *)buf___0, "\n\r\n");
    }
#line 106
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 107
      c = strstr((char const   *)buf___0, "\n\n");
      }
#line 108
      if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 109
        return (1);
      }
    }
    {
#line 112
    req->cgi_status = (enum CGI_STATUS )2;
#line 113
    *(req->header_end) = (char )'\000';
#line 114
    tmp___5 = process_cgi_header(req);
    }
#line 114
    return (tmp___5);
  }
#line 116
  return (1);
}
}
#line 129 "/home/june/collector/temp/boa-0.94.14rc21/src/pipe.c"
int write_from_pipe(request *req ) 
{ 
  off_t bytes_written ;
  off_t bytes_to_write ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  bytes_to_write = req->header_end - req->header_line;
#line 134
  if (bytes_to_write == 0L) {
#line 135
    if ((unsigned int )req->cgi_status == 2U) {
#line 136
      return (0);
    }
#line 138
    req->status = (enum REQ_STATUS )7;
#line 139
    tmp = req->buffer;
#line 139
    req->header_line = tmp;
#line 139
    req->header_end = tmp;
#line 140
    return (1);
  }
  {
#line 143
  bytes_written = write(req->fd, (void const   *)req->header_line, (size_t )bytes_to_write);
  }
#line 145
  if (bytes_written == -1L) {
    {
#line 146
    tmp___1 = __errno_location();
    }
#line 146
    if (*tmp___1 == 11) {
#line 147
      return (-1);
    } else {
      {
#line 146
      tmp___2 = __errno_location();
      }
#line 146
      if (*tmp___2 == 11) {
#line 147
        return (-1);
      } else {
        {
#line 148
        tmp___0 = __errno_location();
        }
#line 148
        if (*tmp___0 == 4) {
#line 149
          return (1);
        } else {
          {
#line 151
          req->status = (enum REQ_STATUS )12;
#line 152
          log_error_doc(req);
#line 153
          perror("pipe write");
          }
#line 154
          return (0);
        }
      }
    }
  }
#line 158
  req->header_line += bytes_written;
#line 159
  req->bytes_written += (size_t )bytes_written;
#line 162
  if ((off_t )((unsigned int )bytes_written) == bytes_to_write) {
#line 163
    req->status = (enum REQ_STATUS )7;
#line 164
    tmp___3 = req->buffer;
#line 164
    req->header_line = tmp___3;
#line 164
    req->header_end = tmp___3;
  }
#line 167
  return (1);
}
}
#line 171 "/home/june/collector/temp/boa-0.94.14rc21/src/pipe.c"
int io_shuffle_sendfile(request *req ) 
{ 
  off_t sendfile_offset ;
  off_t bytes_written ;
  off_t bytes_to_write ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 177
  if ((unsigned int )req->method == 2U) {
    {
#line 178
    tmp = complete_response(req);
    }
#line 178
    return (tmp);
  }
#line 182
  bytes_to_write = (off_t )(((req->ranges)->stop - (req->ranges)->start) + 1UL);
#line 184
  if (bytes_to_write > (off_t )system_bufsize) {
#line 185
    bytes_to_write = (off_t )system_bufsize;
  }
  retrysendfile: 
#line 188
  if (bytes_to_write == 0L) {
#line 190
    bytes_written = (off_t )0;
  } else {
#line 197
    sendfile_offset = (off_t )(req->ranges)->start;
#line 198
    if (sendfile_offset < 0L) {
      {
#line 199
      req->status = (enum REQ_STATUS )12;
#line 200
      log_error_doc(req);
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"impossible offset (%lu) requested of sendfile\n",
              (req->ranges)->start);
      }
#line 203
      return (0);
    }
    {
#line 205
    bytes_written = sendfile(req->fd, req->data_fd, & sendfile_offset, (size_t )bytes_to_write);
    }
#line 208
    if (sendfile_offset < 0L) {
      {
#line 209
      req->status = (enum REQ_STATUS )12;
#line 210
      log_error_doc(req);
#line 211
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad craziness in sendfile offset, returned %ld\n",
              sendfile_offset);
      }
#line 214
      return (0);
    }
#line 216
    (req->ranges)->start = (unsigned long )sendfile_offset;
#line 217
    if (bytes_written < 0L) {
      {
#line 218
      tmp___6 = __errno_location();
      }
#line 218
      if (*tmp___6 == 38) {
        {
#line 219
        tmp___0 = io_shuffle(req);
        }
#line 219
        return (tmp___0);
      } else {
        {
#line 220
        tmp___4 = __errno_location();
        }
#line 220
        if (*tmp___4 == 11) {
#line 221
          return (-1);
        } else {
          {
#line 220
          tmp___5 = __errno_location();
          }
#line 220
          if (*tmp___5 == 11) {
#line 221
            return (-1);
          } else {
            {
#line 222
            tmp___3 = __errno_location();
            }
#line 222
            if (*tmp___3 == 4) {
#line 223
              goto retrysendfile;
            } else {
              {
#line 225
              req->status = (enum REQ_STATUS )12;
#line 229
              tmp___1 = __errno_location();
              }
#line 229
              if (*tmp___1 != 32) {
                {
#line 229
                tmp___2 = __errno_location();
                }
#line 229
                if (*tmp___2 != 104) {
                  {
#line 232
                  log_error_doc(req);
#line 233
                  perror("sendfile write");
                  }
                }
              }
            }
          }
        }
      }
#line 236
      return (0);
    } else
#line 237
    if (bytes_written == 0L) {
#line 241
      return (-1);
    }
  }
#line 249
  req->bytes_written += (size_t )bytes_written;
#line 251
  if ((req->ranges)->stop + 1UL <= (req->ranges)->start) {
    {
#line 252
    tmp___7 = complete_response(req);
    }
#line 252
    return (tmp___7);
  }
#line 254
  return (1);
}
}
#line 267 "/home/june/collector/temp/boa-0.94.14rc21/src/pipe.c"
int io_shuffle(request *req ) 
{ 
  off_t bytes_to_read ;
  off_t bytes_written ;
  off_t bytes_to_write ;
  int tmp ;
  off_t bytes_read ;
  off_t temp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 272
  if ((unsigned int )req->method == 2U) {
    {
#line 273
    tmp = complete_response(req);
    }
#line 273
    return (tmp);
  }
#line 282
  bytes_to_read = (off_t )((4096 - req->buffer_end) - 256);
#line 284
  bytes_to_write = (off_t )(((req->ranges)->stop - (req->ranges)->start) + 1UL);
#line 286
  if (bytes_to_read > bytes_to_write) {
#line 287
    bytes_to_read = bytes_to_write;
  }
#line 289
  if (bytes_to_read > 0L) {
#line 289
    if (req->data_fd) {
      {
#line 293
      temp = lseek(req->data_fd, (__off64_t )(req->ranges)->start, 0);
      }
#line 294
      if (temp < 0L) {
        {
#line 295
        req->status = (enum REQ_STATUS )12;
#line 296
        log_error_doc(req);
#line 297
        perror("ioshuffle lseek");
        }
#line 298
        return (0);
      }
      restartread: 
      {
#line 302
      bytes_read = read(req->data_fd, (void *)(req->buffer + req->buffer_end), (size_t )bytes_to_read);
      }
#line 306
      if (bytes_read == -1L) {
        {
#line 307
        tmp___2 = __errno_location();
        }
#line 307
        if (*tmp___2 == 4) {
#line 308
          goto restartread;
        } else {
          {
#line 309
          tmp___0 = __errno_location();
          }
#line 309
          if (*tmp___0 == 11) {
#line 309
            goto _L;
          } else {
            {
#line 309
            tmp___1 = __errno_location();
            }
#line 309
            if (*tmp___1 == 11) {
              _L: /* CIL Label */ 
#line 312
              if (req->buffer_end - req->buffer_start == 0) {
#line 313
                return (-1);
              }
            } else {
              {
#line 315
              req->status = (enum REQ_STATUS )12;
#line 316
              log_error_doc(req);
#line 317
              perror("ioshuffle read");
              }
#line 318
              return (0);
            }
          }
        }
      } else
#line 320
      if (bytes_read == 0L) {
        {
#line 321
        close(req->data_fd);
#line 322
        req->data_fd = 0;
        }
      } else {
#line 324
        req->buffer_end = (int )((off_t )req->buffer_end + bytes_read);
#line 326
        (req->ranges)->start += (unsigned long )bytes_read;
#line 328
        if (((req->ranges)->stop + 1UL) - (req->ranges)->start == 0UL) {
          {
#line 329
          tmp___3 = complete_response(req);
          }
#line 329
          return (tmp___3);
        }
      }
    }
  }
#line 334
  bytes_to_write = (off_t )(req->buffer_end - req->buffer_start);
#line 335
  if (bytes_to_write == 0L) {
#line 336
    if (req->data_fd == 0) {
#line 337
      return (0);
    }
#line 338
    tmp___4 = 0;
#line 338
    req->buffer_start = tmp___4;
#line 338
    req->buffer_end = tmp___4;
#line 339
    return (1);
  }
  restartwrite: 
  {
#line 343
  bytes_written = write(req->fd, (void const   *)(req->buffer + req->buffer_start),
                        (size_t )bytes_to_write);
  }
#line 346
  if (bytes_written == -1L) {
    {
#line 347
    tmp___6 = __errno_location();
    }
#line 347
    if (*tmp___6 == 11) {
#line 348
      return (-1);
    } else {
      {
#line 347
      tmp___7 = __errno_location();
      }
#line 347
      if (*tmp___7 == 11) {
#line 348
        return (-1);
      } else {
        {
#line 349
        tmp___5 = __errno_location();
        }
#line 349
        if (*tmp___5 == 4) {
#line 350
          goto restartwrite;
        } else {
          {
#line 352
          req->status = (enum REQ_STATUS )12;
#line 353
          log_error_doc(req);
#line 354
          perror("ioshuffle write");
          }
#line 355
          return (0);
        }
      }
    }
  }
#line 360
  req->buffer_start = (int )((off_t )req->buffer_start + bytes_written);
#line 361
  req->bytes_written += (size_t )bytes_written;
#line 363
  if (bytes_to_write == bytes_written) {
#line 364
    tmp___8 = 0;
#line 364
    req->buffer_start = tmp___8;
#line 364
    req->buffer_end = tmp___8;
  }
#line 367
  return (1);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 226 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *access_log_name  ;
#line 227 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *error_log_name  ;
#line 228 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *cgi_log_name  ;
#line 230 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int use_localtime  ;
#line 232 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
unsigned int server_port  ;
#line 233 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
uid_t server_uid  ;
#line 234 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
gid_t server_gid  ;
#line 235 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *server_admin  ;
#line 236 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *server_root  ;
#line 237 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *server_name  ;
#line 238 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *server_ip  ;
#line 240 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *document_root  ;
#line 241 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *user_dir  ;
#line 242 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *directory_index  ;
#line 243 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *default_type  ;
#line 244 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *default_charset  ;
#line 245 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *dirmaker  ;
#line 247 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *pid_file  ;
#line 248 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *cachedir  ;
#line 250 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char const   *tempdir  ;
#line 252 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *cgi_path  ;
#line 255
int conceal_server_identity ;
#line 257 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int ka_timeout  ;
#line 258 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
unsigned int default_timeout  ;
#line 259 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
unsigned int ka_max  ;
#line 268 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
unsigned int max_connections  ;
#line 275 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
int virtualhost  ;
#line 276 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char *vhost_root  ;
#line 277 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
char const   *default_vhost  ;
#line 78 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void add_mime_type(char const   *extension , char const   *type ) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
char const   *config_file_name  ;
#line 52 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
unsigned int cgi_umask  =    23U;
#line 56 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
int single_post_limit  =    1048576;
#line 57 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
int conceal_server_identity  =    0;
#line 77
static void c_add_cgi_env(char *v1 , char *v2 , void *t ) ;
#line 78
static void c_set_user(char *v1 , char *v2 , void *t ) ;
#line 79
static void c_set_group(char *v1 , char *v2 , void *t ) ;
#line 80
static void c_set_string(char *v1 , char *v2 , void *t ) ;
#line 81
static void c_set_int(char *v1 , char *v2 , void *t ) ;
#line 82
static void c_set_unity(char *v1 , char *v2 , void *t ) ;
#line 83
static void c_add_mime_types_file(char *v1 , char *v2 , void *t ) ;
#line 84
static void c_add_mime_type(char *v1 , char *v2 , void *t ) ;
#line 85
static void c_add_alias(char *v1 , char *v2 , void *t ) ;
#line 86
static void c_add_access(char *v1 , char *v2 , void *t ) ;
#line 97
static void apply_command(Command *p , char *args ) ;
#line 98
static void trim(char *s ) ;
#line 99
static void parse(FILE *f ) ;
#line 103 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static enum ALIAS script_number  =    (enum ALIAS )1;
#line 104 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static enum ALIAS redirect_number  =    (enum ALIAS )2;
#line 105 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static enum ALIAS alias_number  =    (enum ALIAS )0;
#line 106 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static int access_allow_number  =    1;
#line 107 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static int access_deny_number  =    0;
#line 108 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static uid_t current_uid  =    (uid_t )0;
#line 120
struct ccommand *lookup_keyword(char *c ) ;
#line 122 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
struct ccommand clist[40]  = 
#line 122
  {      {"Port", (int const   )2, & c_set_int, (void *)(& server_port)}, 
        {"Listen", (int const   )2, & c_set_string, (void *)(& server_ip)}, 
        {"BackLog", (int const   )2, & c_set_int, (void *)(& backlog)}, 
        {"User", (int const   )2, & c_set_user, (void *)0}, 
        {"Group", (int const   )2, & c_set_group, (void *)0}, 
        {"ServerAdmin", (int const   )2, & c_set_string, (void *)(& server_admin)}, 
        {"ServerRoot", (int const   )2, & c_set_string, (void *)(& server_root)}, 
        {"UseLocaltime", (int const   )1, & c_set_unity, (void *)(& use_localtime)}, 
        {"ErrorLog", (int const   )2, & c_set_string, (void *)(& error_log_name)}, 
        {"AccessLog", (int const   )2, & c_set_string, (void *)(& access_log_name)}, 
        {"CgiLog", (int const   )2, & c_set_string, (void *)(& cgi_log_name)}, 
        {"CGILog", (int const   )2, & c_set_string, (void *)(& cgi_log_name)}, 
        {"VerboseCGILogs", (int const   )1, & c_set_unity, (void *)(& verbose_cgi_logs)}, 
        {"ServerName",
      (int const   )2, & c_set_string, (void *)(& server_name)}, 
        {"VirtualHost", (int const   )1, & c_set_unity, (void *)(& virtualhost)}, 
        {"VHostRoot", (int const   )2, & c_set_string, (void *)(& vhost_root)}, 
        {"DefaultVHost", (int const   )2, & c_set_string, (void *)(& default_vhost)}, 
        {"DocumentRoot",
      (int const   )2, & c_set_string, (void *)(& document_root)}, 
        {"UserDir", (int const   )2, & c_set_string, (void *)(& user_dir)}, 
        {"DirectoryIndex", (int const   )2, & c_set_string, (void *)(& directory_index)}, 
        {"DirectoryMaker",
      (int const   )2, & c_set_string, (void *)(& dirmaker)}, 
        {"DirectoryCache", (int const   )2, & c_set_string, (void *)(& cachedir)}, 
        {"PidFile", (int const   )2, & c_set_string, (void *)(& pid_file)}, 
        {"KeepAliveMax", (int const   )2, & c_set_int, (void *)(& ka_max)}, 
        {"KeepAliveTimeout", (int const   )2, & c_set_int, (void *)(& ka_timeout)}, 
        {"MimeTypes", (int const   )2, & c_add_mime_types_file, (void *)0}, 
        {"DefaultType", (int const   )2, & c_set_string, (void *)(& default_type)}, 
        {"DefaultCharset", (int const   )2, & c_set_string, (void *)(& default_charset)}, 
        {"AddType",
      (int const   )3, & c_add_mime_type, (void *)0}, 
        {"ScriptAlias", (int const   )3, & c_add_alias, (void *)(& script_number)}, 
        {"Redirect", (int const   )3, & c_add_alias, (void *)(& redirect_number)}, 
        {"Alias", (int const   )3, & c_add_alias, (void *)(& alias_number)}, 
        {"SinglePostLimit", (int const   )2, & c_set_int, (void *)(& single_post_limit)}, 
        {"CGIPath",
      (int const   )2, & c_set_string, (void *)(& cgi_path)}, 
        {"CGIumask", (int const   )2, & c_set_int, (void *)(& cgi_umask)}, 
        {"MaxConnections", (int const   )2, & c_set_int, (void *)(& max_connections)}, 
        {"ConcealServerIdentity",
      (int const   )1, & c_set_unity, (void *)(& conceal_server_identity)}, 
        {"Allow", (int const   )2, & c_add_access, (void *)(& access_allow_number)}, 
        {"Deny", (int const   )2, & c_add_access, (void *)(& access_deny_number)}, 
        {"CGIEnv", (int const   )3, & c_add_cgi_env, (void *)0}};
#line 170 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_add_cgi_env(char *v1 , char *v2 , void *t ) 
{ 


  {
  {
#line 172
  add_to_common_env(v1, v2);
  }
#line 173
  return;
}
}
#line 175 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_set_user(char *v1 , char *v2 , void *t ) 
{ 
  struct passwd *passwdbuf ;
  char *endptr ;
  int i ;
  long tmp ;

  {
#line 181
  if (debug_level & (1 << 8)) {
    {
#line 182
    log_error_time();
#line 183
    printf((char const   */* __restrict  */)"User %s = ", v1);
    }
  }
  {
#line 185
  tmp = strtol((char const   */* __restrict  */)v1, (char **/* __restrict  */)(& endptr),
               0);
#line 185
  i = (int )tmp;
  }
#line 186
  if ((int )*v1 != 0) {
#line 186
    if ((int )*endptr == 0) {
#line 187
      server_uid = (uid_t )i;
    } else {
#line 186
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 189
    passwdbuf = getpwnam((char const   *)v1);
    }
#line 190
    if (! passwdbuf) {
      {
#line 191
      log_error_time();
#line 192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No such user: %s\n",
              v1);
      }
#line 193
      if (current_uid) {
#line 194
        return;
      }
      {
#line 195
      exit(1);
      }
    }
#line 197
    server_uid = passwdbuf->pw_uid;
  }
#line 199
  if (debug_level & (1 << 8)) {
    {
#line 200
    printf((char const   */* __restrict  */)"%d\n", server_uid);
    }
  }
#line 202
  return;
}
}
#line 204 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_set_group(char *v1 , char *v2 , void *t ) 
{ 
  struct group *groupbuf ;
  char *endptr ;
  int i ;
  long tmp ;

  {
#line 209
  if (debug_level & (1 << 8)) {
    {
#line 210
    log_error_time();
#line 211
    printf((char const   */* __restrict  */)"Group %s = ", v1);
    }
  }
  {
#line 213
  tmp = strtol((char const   */* __restrict  */)v1, (char **/* __restrict  */)(& endptr),
               0);
#line 213
  i = (int )tmp;
  }
#line 214
  if ((int )*v1 != 0) {
#line 214
    if ((int )*endptr == 0) {
#line 215
      server_gid = (gid_t )i;
    } else {
#line 214
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 217
    groupbuf = getgrnam((char const   *)v1);
    }
#line 218
    if (! groupbuf) {
      {
#line 219
      log_error_time();
#line 220
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No such group: %s\n",
              v1);
      }
#line 221
      if (current_uid) {
#line 222
        return;
      }
      {
#line 223
      exit(1);
      }
    }
#line 225
    server_gid = groupbuf->gr_gid;
  }
#line 227
  if (debug_level & (1 << 8)) {
    {
#line 228
    printf((char const   */* __restrict  */)"%d\n", server_gid);
    }
  }
#line 230
  return;
}
}
#line 232 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_set_string(char *v1 , char *v2 , void *t ) 
{ 


  {
#line 234
  if (debug_level & (1 << 8)) {
    {
#line 235
    log_error_time();
#line 236
    printf((char const   */* __restrict  */)"Setting pointer %p to string %s ..",
           t, v1);
    }
  }
#line 238
  if (t) {
#line 239
    if ((unsigned long )*((char **)t) != (unsigned long )((void *)0)) {
      {
#line 240
      free((void *)*((char **)t));
      }
    }
    {
#line 241
    *((char **)t) = strdup((char const   *)v1);
    }
#line 242
    if (! *((char **)t)) {
      {
#line 243
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/config.c",
                           243, "c_set_string", "Unable to strdup in c_set_string");
      }
    }
#line 245
    if (debug_level & (1 << 8)) {
      {
#line 246
      printf((char const   */* __restrict  */)"done.\n");
      }
    }
  } else
#line 249
  if (debug_level & (1 << 8)) {
    {
#line 250
    printf((char const   */* __restrict  */)"skipped.\n");
    }
  }
#line 253
  return;
}
}
#line 255 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_set_int(char *v1 , char *v2 , void *t ) 
{ 
  char *endptr ;
  int i ;
  long tmp ;

  {
#line 259
  if (debug_level & (1 << 8)) {
    {
#line 260
    log_error_time();
#line 261
    printf((char const   */* __restrict  */)"Setting pointer %p to integer string %s ..",
           t, v1);
    }
  }
#line 263
  if (t) {
    {
#line 264
    tmp = strtol((char const   */* __restrict  */)v1, (char **/* __restrict  */)(& endptr),
                 0);
#line 264
    i = (int )tmp;
    }
#line 265
    if ((int )*v1 != 0) {
#line 265
      if ((int )*endptr == 0) {
#line 266
        *((int *)t) = i;
#line 267
        if (debug_level & (1 << 8)) {
          {
#line 268
          printf((char const   */* __restrict  */)" Integer converted as %d, done\n",
                 i);
          }
        }
      } else {
        {
#line 272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s found where integer expected\n",
                v1);
        }
      }
    } else {
      {
#line 272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s found where integer expected\n",
              v1);
      }
    }
  } else
#line 276
  if (debug_level & (1 << 8)) {
    {
#line 277
    printf((char const   */* __restrict  */)"skipped.\n");
    }
  }
#line 280
  return;
}
}
#line 282 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_set_unity(char *v1 , char *v2 , void *t ) 
{ 


  {
#line 284
  if (debug_level & (1 << 8)) {
    {
#line 285
    log_error_time();
#line 286
    printf((char const   */* __restrict  */)"Setting pointer %p to unity\n", t);
    }
  }
#line 288
  if (t) {
#line 289
    *((int *)t) = 1;
  }
#line 290
  return;
}
}
#line 292 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_add_mime_type(char *v1 , char *v2 , void *t ) 
{ 


  {
  {
#line 294
  add_mime_type((char const   *)v2, (char const   *)v1);
  }
#line 295
  return;
}
}
#line 297 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_add_mime_types_file(char *v1 , char *v2 , void *t ) 
{ 
  FILE *f ;
  char buf___0[256] ;
  char *p ;
  char *type ;
  char *extension ;
  char *c2 ;
  int len___0 ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 305
  f = fopen((char const   */* __restrict  */)v1, (char const   */* __restrict  */)"r");
  }
#line 306
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 307
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/config.c",
                         307, "c_add_mime_types_file", "Can\'t open mime-types file");
    }
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 308
    tmp___4 = fgets((char */* __restrict  */)(buf___0), 255, (FILE */* __restrict  */)f);
    }
#line 308
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 308
      goto while_break;
    }
#line 309
    if ((int )buf___0[0] == 0) {
#line 310
      goto while_continue;
    } else
#line 309
    if ((int )buf___0[0] == 35) {
#line 310
      goto while_continue;
    } else
#line 309
    if ((int )buf___0[0] == 10) {
#line 310
      goto while_continue;
    }
    {
#line 312
    c2 = strchr((char const   *)(buf___0), '\n');
    }
#line 313
    if (c2) {
#line 314
      *c2 = (char )'\000';
    }
    {
#line 316
    tmp = strcspn((char const   *)(buf___0), "\t ");
#line 316
    len___0 = (int )tmp;
    }
#line 317
    if (! len___0) {
#line 318
      if (debug_level & (1 << 8)) {
        {
#line 319
        log_error_time();
#line 320
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Improperly formatted mime-type: \"%s\"\n",
                buf___0);
        }
      }
#line 323
      goto while_continue;
    }
#line 326
    buf___0[len___0] = (char )'\000';
#line 327
    type = buf___0;
#line 328
    p = (buf___0 + len___0) + 1;
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! *p) {
#line 328
        goto while_break___0;
      }
      {
#line 329
      tmp___0 = __ctype_b_loc();
      }
#line 329
      if ((int const   )*(*tmp___0 + (int )*p) & 8) {
#line 330
        goto while_break___0;
      }
#line 328
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 333
    tmp___1 = strcspn((char const   *)p, "\t ");
#line 333
    len___0 = (int )tmp___1;
    }
    {
#line 333
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 333
      if (! len___0) {
#line 333
        goto while_break___1;
      }
      {
#line 334
      *(p + len___0) = (char )'\000';
#line 335
      extension = p;
#line 336
      add_mime_type((char const   *)extension, (char const   *)type);
#line 338
      p = (p + len___0) + 1;
      }
      {
#line 338
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 338
        if (! *p) {
#line 338
          goto while_break___2;
        }
        {
#line 339
        tmp___3 = __ctype_b_loc();
        }
#line 339
        if ((int const   )*(*tmp___3 + (int )*p) & 8) {
#line 340
          goto while_break___2;
        }
#line 338
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 333
      tmp___2 = strcspn((char const   *)p, "\t ");
#line 333
      len___0 = (int )tmp___2;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  fclose(f);
  }
#line 345
  return;
}
}
#line 349 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_add_alias(char *v1 , char *v2 , void *t ) 
{ 


  {
#line 351
  if (debug_level & (1 << 8)) {
    {
#line 352
    log_error_time();
#line 353
    printf((char const   */* __restrict  */)"Calling add_alias with args \"%s\", \"%s\", and %d\n",
           v1, v2, *((int *)t));
    }
  }
  {
#line 356
  add_alias((char const   *)v1, (char const   *)v2, *((enum ALIAS *)t));
  }
#line 357
  return;
}
}
#line 359 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void c_add_access(char *v1 , char *v2 , void *t ) 
{ 


  {
  {
#line 364
  log_error_time();
#line 365
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This version of Boa doesn\'t support access controls.\nPlease recompile with --enable-access-control.\n");
  }
#line 369
  return;
}
}
#line 371 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
struct ccommand *lookup_keyword(char *c ) 
{ 
  struct ccommand *p ;
  int tmp ;

  {
#line 374
  if (debug_level & (1 << 8)) {
    {
#line 375
    log_error_time();
#line 376
    printf((char const   */* __restrict  */)"Checking string \'%s\' against keyword list\n",
           c);
    }
  }
#line 378
  p = clist;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )p < (unsigned long )(clist + sizeof(clist) / sizeof(struct ccommand )))) {
#line 378
      goto while_break;
    }
    {
#line 380
    tmp = strcasecmp((char const   *)c, p->name);
    }
#line 380
    if (tmp == 0) {
#line 381
      return (p);
    }
#line 378
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return ((struct ccommand *)((void *)0));
}
}
#line 386 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void apply_command(Command *p , char *args ) 
{ 
  char *second ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 391
  if (p->type == 1) {
#line 391
    goto case_1;
  }
#line 394
  if (p->type == 2) {
#line 394
    goto case_2;
  }
#line 397
  if (p->type == 3) {
#line 397
    goto case_3;
  }
#line 425
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 392
  (*(p->action))((char *)((void *)0), (char *)((void *)0), p->object);
  }
#line 393
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 395
  (*(p->action))(args, (char *)((void *)0), p->object);
  }
#line 396
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp = __ctype_b_loc();
    }
#line 399
    if (! ((int const   )*(*tmp + (int )*args) & 8192)) {
#line 399
      goto while_break;
    }
#line 400
    args ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  if ((int )*args == 0) {
    {
#line 402
    log_error_time();
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected at least 1 arg! (%s)\n",
            p->name);
#line 404
    exit(1);
    }
  }
#line 407
  second = args;
  {
#line 408
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 408
    tmp___0 = __ctype_b_loc();
    }
#line 408
    if ((int const   )*(*tmp___0 + (int )*second) & 8192) {
#line 408
      goto while_break___0;
    }
#line 409
    second ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 410
  if ((int )*second == 0) {
#line 412
    second = (char *)((void *)0);
  } else {
#line 414
    *second = (char )'\000';
#line 415
    second ++;
    {
#line 416
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 416
      tmp___1 = __ctype_b_loc();
      }
#line 416
      if (! ((int const   )*(*tmp___1 + (int )*second) & 8192)) {
#line 416
        goto while_break___1;
      }
#line 417
      second ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 418
    if ((int )*second == 0) {
#line 419
      second = (char *)((void *)0);
    }
  }
  {
#line 423
  (*(p->action))(args, second, p->object);
  }
#line 424
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 426
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 428
  return;
}
}
#line 430 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void trim(char *s ) 
{ 
  char *c ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 432
  tmp = strlen((char const   *)s);
#line 432
  c = (s + tmp) - 1;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 434
    tmp___0 = __ctype_b_loc();
    }
#line 434
    if ((int const   )*(*tmp___0 + (int )*c) & 8192) {
#line 434
      if (! ((unsigned long )c > (unsigned long )s)) {
#line 434
        goto while_break;
      }
    } else {
#line 434
      goto while_break;
    }
#line 435
    *c = (char )'\000';
#line 436
    c --;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  return;
}
}
#line 440 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
static void parse(FILE *f ) 
{ 
  char buf___0[1025] ;
  char *c ;
  Command *p ;
  int line ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 444
  line = 0;
#line 446
  current_uid = getuid();
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    tmp___0 = fgets((char */* __restrict  */)(buf___0), 1024, (FILE */* __restrict  */)f);
    }
#line 447
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 447
      goto while_break;
    }
#line 448
    line ++;
#line 449
    if ((int )buf___0[0] == 0) {
#line 450
      goto while_continue;
    } else
#line 449
    if ((int )buf___0[0] == 35) {
#line 450
      goto while_continue;
    } else
#line 449
    if ((int )buf___0[0] == 10) {
#line 450
      goto while_continue;
    }
    {
#line 453
    trim(buf___0);
    }
#line 454
    if ((int )buf___0[0] == 0) {
#line 455
      goto while_continue;
    }
#line 458
    c = buf___0;
    {
#line 459
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 459
      tmp = __ctype_b_loc();
      }
#line 459
      if ((int const   )*(*tmp + (int )*c) & 8192) {
#line 459
        goto while_break___0;
      }
#line 460
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 462
    if ((int )*c == 0) {
#line 464
      c = (char *)((void *)0);
    } else {
#line 467
      *c = (char )'\000';
#line 468
      c ++;
    }
    {
#line 471
    p = lookup_keyword(buf___0);
    }
#line 473
    if (! p) {
      {
#line 474
      log_error_time();
#line 475
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Line %d: Did not find keyword \"%s\"\n",
              line, buf___0);
#line 477
      exit(1);
      }
    } else {
#line 479
      if (debug_level & (1 << 8)) {
        {
#line 480
        log_error_time();
#line 481
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found keyword %s in \"%s\" (%s)!\n",
                p->name, buf___0, c);
        }
      }
      {
#line 485
      apply_command(p, c);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  return;
}
}
#line 496 "/home/june/collector/temp/boa-0.94.14rc21/src/config.c"
void read_config_files(void) 
{ 
  FILE *config ;
  struct hostent *he ;
  char temp_name[100] ;
  int tmp ;
  char *tmp___0 ;
  struct rlimit rl ;
  int c ;

  {
  {
#line 500
  current_uid = getuid();
  }
#line 502
  if (! config_file_name) {
#line 503
    config_file_name = "boa.conf";
  }
  {
#line 509
  config = fopen((char const   */* __restrict  */)config_file_name, (char const   */* __restrict  */)"r");
  }
#line 510
  if (! config) {
    {
#line 511
    fputs((char const   */* __restrict  */)"Could not open boa.conf for reading.\n",
          (FILE */* __restrict  */)stderr);
#line 512
    exit(1);
    }
  }
  {
#line 514
  parse(config);
#line 515
  fclose(config);
  }
#line 517
  if (! server_name) {
    {
#line 521
    tmp = gethostname(temp_name, (size_t )100);
    }
#line 521
    if (tmp == -1) {
      {
#line 522
      perror("gethostname:");
#line 523
      exit(1);
      }
    }
    {
#line 526
    he = gethostbyname((char const   *)(temp_name));
    }
#line 527
    if ((unsigned long )he == (unsigned long )((void *)0)) {
      {
#line 528
      perror("gethostbyname:");
#line 529
      exit(1);
      }
    }
    {
#line 532
    server_name = strdup((char const   *)he->h_name);
    }
#line 533
    if ((unsigned long )server_name == (unsigned long )((void *)0)) {
      {
#line 534
      perror("strdup:");
#line 535
      exit(1);
      }
    }
  }
  {
#line 538
  tmp___0 = getenv("TMP");
#line 538
  tempdir = (char const   *)tmp___0;
  }
#line 539
  if ((unsigned long )tempdir == (unsigned long )((void *)0)) {
#line 540
    tempdir = "/tmp";
  }
#line 542
  if (single_post_limit < 0) {
    {
#line 543
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid value for single_post_limit: %d\n",
            single_post_limit);
#line 545
    exit(1);
    }
  }
#line 548
  if (vhost_root) {
#line 548
    if (virtualhost) {
      {
#line 549
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Both VHostRoot and VirtualHost were enabled, and they are mutually exclusive.\n");
#line 551
      exit(1);
      }
    }
  }
#line 554
  if (vhost_root) {
#line 554
    if (document_root) {
      {
#line 555
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Both VHostRoot and DocumentRoot were enabled, and they are mutually exclusive.\n");
#line 558
      exit(1);
      }
    }
  }
#line 561
  if (! default_vhost) {
#line 562
    default_vhost = "default";
  }
#line 576
  if (max_connections < 1U) {
    {
#line 581
    c = getrlimit(7, & rl);
    }
#line 582
    if (c < 0) {
      {
#line 583
      log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/config.c",
                           583, "read_config_files", "getrlimit");
      }
    }
#line 585
    max_connections = (unsigned int )rl.rlim_cur;
  }
#line 587
  if (max_connections > 1004U) {
#line 588
    max_connections = 1004U;
  }
#line 590
  if (ka_timeout < 0) {
#line 590
    ka_timeout = 0;
  }
#line 592
  if (ka_timeout) {
#line 592
    default_timeout = (unsigned int )ka_timeout;
  } else {
#line 592
    default_timeout = 60U;
  }
#line 597
  if ((unsigned long )default_type == (unsigned long )((void *)0)) {
    {
#line 598
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/config.c",
                         598, "read_config_files", "DefaultType *must* be set!");
    }
  }
#line 600
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 211 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
request *request_ready ;
#line 212
request *request_block ;
#line 219 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
fd_set block_read_fdset  ;
#line 220 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
fd_set block_write_fdset  ;
#line 221
int max_fd ;
#line 279
unsigned int total_connections ;
#line 97 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void ready_request(request *req ) ;
#line 109
void process_requests(int server_sock ) ;
#line 41 "/home/june/collector/temp/boa-0.94.14rc21/src/select.c"
static void fdset_update(void) ;
#line 44 "/home/june/collector/temp/boa-0.94.14rc21/src/select.c"
int max_fd  =    0;
#line 46 "/home/june/collector/temp/boa-0.94.14rc21/src/select.c"
void loop(int server_s ) 
{ 
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  struct timeval req_timeout ;
  int *tmp ;
  int *tmp___0 ;
  struct timeval *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& block_read_fdset.__fds_bits[0]): "memory");
#line 48
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 49
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& block_write_fdset.__fds_bits[0]): "memory");
#line 49
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 51
  max_fd = -1;
  {
#line 53
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 55
    if (sighup_flag) {
      {
#line 56
      sighup_run();
      }
    }
#line 57
    if (sigchld_flag) {
      {
#line 58
      sigchld_run();
      }
    }
#line 59
    if (sigalrm_flag) {
      {
#line 60
      sigalrm_run();
      }
    }
#line 62
    if (sigterm_flag) {
#line 67
      if (sigterm_flag == 1) {
        {
#line 68
        sigterm_stage1_run();
#line 69
        block_read_fdset.__fds_bits[server_s / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << server_s % (8 * (int )sizeof(__fd_mask )));
#line 70
        close(server_s);
#line 72
        server_s = -1;
        }
      }
#line 74
      if (sigterm_flag == 2) {
#line 74
        if (! request_ready) {
#line 74
          if (! request_block) {
            {
#line 75
            sigterm_stage2_run();
            }
          }
        }
      }
    } else
#line 78
    if (total_connections > max_connections) {
#line 80
      block_read_fdset.__fds_bits[server_s / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << server_s % (8 * (int )sizeof(__fd_mask )));
    } else {
#line 82
      block_read_fdset.__fds_bits[server_s / (8 * (int )sizeof(__fd_mask ))] |= 1L << server_s % (8 * (int )sizeof(__fd_mask ));
#line 82
      if (server_s > max_fd) {
#line 82
        max_fd = server_s;
      }
    }
#line 86
    pending_requests = 0;
#line 89
    if (max_fd) {
#line 92
      if (request_ready) {
#line 92
        req_timeout.tv_sec = (__time_t )0;
      } else {
#line 92
        req_timeout.tv_sec = (__time_t )default_timeout;
      }
#line 93
      req_timeout.tv_usec = 0L;
#line 95
      if (request_ready) {
#line 95
        tmp___1 = & req_timeout;
      } else
#line 95
      if (request_block) {
#line 95
        tmp___1 = & req_timeout;
      } else {
#line 95
        tmp___1 = (struct timeval *)((void *)0);
      }
      {
#line 95
      tmp___2 = select(max_fd + 1, (fd_set */* __restrict  */)(& block_read_fdset),
                       (fd_set */* __restrict  */)(& block_write_fdset), (fd_set */* __restrict  */)((void *)0),
                       (struct timeval */* __restrict  */)tmp___1);
      }
#line 95
      if (tmp___2 == -1) {
        {
#line 100
        tmp___0 = __errno_location();
        }
#line 100
        if (*tmp___0 == 4) {
#line 101
          goto while_continue___1;
        } else {
          {
#line 102
          tmp = __errno_location();
          }
#line 102
          if (*tmp != 9) {
            {
#line 103
            log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/select.c",
                                 103, "loop", "select");
            }
          }
        }
      }
#line 110
      if (! sigterm_flag) {
#line 110
        if ((block_read_fdset.__fds_bits[server_s / (8 * (int )sizeof(__fd_mask ))] & (1L << server_s % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 111
          pending_requests = 1;
        }
      }
      {
#line 113
      time(& current_time);
      }
    }
#line 122
    max_fd = -1;
#line 124
    if (request_block) {
      {
#line 126
      fdset_update();
      }
    }
#line 130
    if (pending_requests) {
      {
#line 131
      process_requests(server_s);
      }
    } else
#line 130
    if (request_ready) {
      {
#line 131
      process_requests(server_s);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 152 "/home/june/collector/temp/boa-0.94.14rc21/src/select.c"
static void fdset_update(void) 
{ 
  request *current ;
  request *next ;
  time_t time_since ;

  {
  {
#line 156
  time(& current_time);
#line 157
  current = request_block;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! current) {
#line 157
      goto while_break;
    }
#line 158
    time_since = current_time - current->time_last;
#line 159
    next = current->next;
#line 164
    if (current->kacount < ka_max) {
#line 164
      if (time_since >= (time_t )ka_timeout) {
#line 164
        if (! current->logline) {
          {
#line 167
          log_error_doc(current);
#line 168
          fputs((char const   */* __restrict  */)"connection timed out\n", (FILE */* __restrict  */)stderr);
#line 169
          current->status = (enum REQ_STATUS )11;
          }
        } else {
#line 164
          goto _L___0;
        }
      } else {
#line 164
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 170
    if (time_since > 60L) {
      {
#line 171
      log_error_doc(current);
#line 172
      fputs((char const   */* __restrict  */)"connection timed out\n", (FILE */* __restrict  */)stderr);
#line 173
      current->status = (enum REQ_STATUS )11;
      }
    }
#line 175
    if (current->buffer_end) {
#line 175
      if ((unsigned int )current->status < 10U) {
#line 177
        if ((block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 178
          ready_request(current);
          }
        } else {
#line 180
          block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->fd % (8 * (int )sizeof(__fd_mask ));
#line 180
          if (current->fd > max_fd) {
#line 180
            max_fd = current->fd;
          }
        }
      } else {
#line 175
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 193
      if ((unsigned int )current->status == 8U) {
#line 193
        goto case_8;
      }
#line 193
      if ((unsigned int )current->status == 6U) {
#line 193
        goto case_8;
      }
#line 193
      if ((unsigned int )current->status == 9U) {
#line 193
        goto case_8;
      }
#line 200
      if ((unsigned int )current->status == 5U) {
#line 200
        goto case_5;
      }
#line 208
      if ((unsigned int )current->status == 7U) {
#line 208
        goto case_7;
      }
#line 216
      if ((unsigned int )current->status == 10U) {
#line 216
        goto case_10;
      }
#line 224
      if ((unsigned int )current->status == 12U) {
#line 224
        goto case_12;
      }
#line 224
      if ((unsigned int )current->status == 11U) {
#line 224
        goto case_12;
      }
#line 227
      goto switch_default;
      case_8: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 194
      if ((block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 195
        ready_request(current);
        }
      } else {
#line 197
        block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->fd % (8 * (int )sizeof(__fd_mask ));
#line 197
        if (current->fd > max_fd) {
#line 197
          max_fd = current->fd;
        }
      }
#line 199
      goto switch_break;
      case_5: /* CIL Label */ 
#line 201
      if ((block_write_fdset.__fds_bits[current->post_data_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->post_data_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 202
        ready_request(current);
        }
      } else {
#line 204
        block_write_fdset.__fds_bits[current->post_data_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->post_data_fd % (8 * (int )sizeof(__fd_mask ));
#line 204
        if (current->post_data_fd > max_fd) {
#line 204
          max_fd = current->post_data_fd;
        }
      }
#line 207
      goto switch_break;
      case_7: /* CIL Label */ 
#line 209
      if ((block_read_fdset.__fds_bits[current->data_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->data_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 210
        ready_request(current);
        }
      } else {
#line 212
        block_read_fdset.__fds_bits[current->data_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->data_fd % (8 * (int )sizeof(__fd_mask ));
#line 212
        if (current->data_fd > max_fd) {
#line 212
          max_fd = current->data_fd;
        }
      }
#line 215
      goto switch_break;
      case_10: /* CIL Label */ 
#line 217
      if ((block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 218
        ready_request(current);
        }
      } else {
#line 220
        block_write_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->fd % (8 * (int )sizeof(__fd_mask ));
#line 220
        if (current->fd > max_fd) {
#line 220
          max_fd = current->fd;
        }
      }
#line 222
      goto switch_break;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      {
#line 225
      ready_request(current);
      }
#line 226
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 228
      if ((block_read_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << current->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 229
        ready_request(current);
        }
      } else {
#line 231
        block_read_fdset.__fds_bits[current->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << current->fd % (8 * (int )sizeof(__fd_mask ));
#line 231
        if (current->fd > max_fd) {
#line 231
          max_fd = current->fd;
        }
      }
#line 233
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 236
    current = next;
#line 157
    current = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 213 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
request *request_free ;
#line 96 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void block_request(request *req ) ;
#line 98
void dequeue(request **head , request *req ) ;
#line 99
void enqueue(request **head , request *req ) ;
#line 26 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
request *request_ready  =    (request *)((void *)0);
#line 27 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
request *request_block  =    (request *)((void *)0);
#line 28 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
request *request_free  =    (request *)((void *)0);
#line 36 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
void block_request(request *req ) 
{ 


  {
  {
#line 38
  dequeue(& request_ready, req);
#line 39
  enqueue(& request_block, req);
  }
#line 41
  if (req->buffer_end) {
#line 42
    block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->fd % (8 * (int )sizeof(__fd_mask ));
#line 42
    if (req->fd > max_fd) {
#line 42
      max_fd = req->fd;
    }
  } else {
    {
#line 54
    if ((unsigned int )req->status == 10U) {
#line 54
      goto case_10;
    }
#line 54
    if ((unsigned int )req->status == 8U) {
#line 54
      goto case_10;
    }
#line 54
    if ((unsigned int )req->status == 6U) {
#line 54
      goto case_10;
    }
#line 54
    if ((unsigned int )req->status == 9U) {
#line 54
      goto case_10;
    }
#line 57
    if ((unsigned int )req->status == 7U) {
#line 57
      goto case_7;
    }
#line 60
    if ((unsigned int )req->status == 5U) {
#line 60
      goto case_5;
    }
#line 63
    goto switch_default;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 55
    block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->fd % (8 * (int )sizeof(__fd_mask ));
#line 55
    if (req->fd > max_fd) {
#line 55
      max_fd = req->fd;
    }
#line 56
    goto switch_break;
    case_7: /* CIL Label */ 
#line 58
    block_read_fdset.__fds_bits[req->data_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->data_fd % (8 * (int )sizeof(__fd_mask ));
#line 58
    if (req->data_fd > max_fd) {
#line 58
      max_fd = req->data_fd;
    }
#line 59
    goto switch_break;
    case_5: /* CIL Label */ 
#line 61
    block_write_fdset.__fds_bits[req->post_data_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->post_data_fd % (8 * (int )sizeof(__fd_mask ));
#line 61
    if (req->post_data_fd > max_fd) {
#line 61
      max_fd = req->post_data_fd;
    }
#line 62
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 64
    block_read_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->fd % (8 * (int )sizeof(__fd_mask ));
#line 64
    if (req->fd > max_fd) {
#line 64
      max_fd = req->fd;
    }
#line 65
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 68
  return;
}
}
#line 76 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
void ready_request(request *req ) 
{ 


  {
  {
#line 78
  dequeue(& request_block, req);
#line 79
  enqueue(& request_ready, req);
  }
#line 81
  if (req->buffer_end) {
#line 82
    block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
  } else {
    {
#line 94
    if ((unsigned int )req->status == 10U) {
#line 94
      goto case_10;
    }
#line 94
    if ((unsigned int )req->status == 8U) {
#line 94
      goto case_10;
    }
#line 94
    if ((unsigned int )req->status == 6U) {
#line 94
      goto case_10;
    }
#line 94
    if ((unsigned int )req->status == 9U) {
#line 94
      goto case_10;
    }
#line 97
    if ((unsigned int )req->status == 7U) {
#line 97
      goto case_7;
    }
#line 100
    if ((unsigned int )req->status == 5U) {
#line 100
      goto case_5;
    }
#line 103
    goto switch_default;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 95
    block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
#line 96
    goto switch_break;
    case_7: /* CIL Label */ 
#line 98
    block_read_fdset.__fds_bits[req->data_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->data_fd % (8 * (int )sizeof(__fd_mask )));
#line 99
    goto switch_break;
    case_5: /* CIL Label */ 
#line 101
    block_write_fdset.__fds_bits[req->post_data_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->post_data_fd % (8 * (int )sizeof(__fd_mask )));
#line 102
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 104
    block_read_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
    switch_break: /* CIL Label */ ;
    }
  }
#line 107
  return;
}
}
#line 116 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
void dequeue(request **head , request *req ) 
{ 


  {
#line 118
  if ((unsigned long )*head == (unsigned long )req) {
#line 119
    *head = req->next;
  }
#line 121
  if (req->prev) {
#line 122
    (req->prev)->next = req->next;
  }
#line 123
  if (req->next) {
#line 124
    (req->next)->prev = req->prev;
  }
#line 126
  req->next = (struct request *)((void *)0);
#line 127
  req->prev = (struct request *)((void *)0);
#line 128
  return;
}
}
#line 136 "/home/june/collector/temp/boa-0.94.14rc21/src/queue.c"
void enqueue(request **head , request *req ) 
{ 


  {
#line 138
  if (*head) {
#line 139
    (*head)->prev = req;
  }
#line 141
  req->next = *head;
#line 142
  req->prev = (struct request *)((void *)0);
#line 144
  *head = req;
#line 145
  return;
}
}
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 207 "/home/june/collector/temp/boa-0.94.14rc21/src/globals.h"
struct status status  ;
#line 107 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
request *new_request(void) ;
#line 108
void get_request(int server_sock ) ;
#line 145
void send_r_not_implemented(request *req ) ;
#line 147
void send_r_service_unavailable(request *req ) ;
#line 217
char *ascii_sockaddr(struct sockaddr_in *s , char *dest , unsigned int len___0 ) ;
#line 218
int net_port(struct sockaddr_in *s ) ;
#line 35 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
unsigned int total_connections  =    0U;
#line 36 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
unsigned int system_bufsize  =    0U;
#line 39 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
static unsigned int sockbufsize  =    32768U;
#line 42
static void free_request(request *req ) ;
#line 43
static void sanitize_request(request *req , int new_req ) ;
#line 53 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
request *new_request(void) 
{ 
  request *req ;
  void *tmp ;

  {
#line 57
  if (request_free) {
    {
#line 58
    req = request_free;
#line 59
    dequeue(& request_free, request_free);
    }
  } else {
    {
#line 61
    tmp = malloc(sizeof(request ));
#line 61
    req = (request *)tmp;
    }
#line 62
    if (! req) {
      {
#line 63
      log_error_time();
#line 64
      perror("malloc for new request");
      }
#line 65
      return ((request *)((void *)0));
    }
  }
  {
#line 69
  sanitize_request(req, 1);
  }
#line 71
  return (req);
}
}
#line 81 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
void get_request(int server_sock ) 
{ 
  int fd ;
  struct sockaddr_in remote_addr ;
  struct sockaddr_in salocal ;
  unsigned int remote_addrlen ;
  request *conn ;
  socklen_t len___0 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 86
  remote_addrlen = (unsigned int )sizeof(struct sockaddr_in );
#line 91
  remote_addr.sin_family = (sa_family_t )57005;
#line 93
  fd = accept(server_sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& remote_addr)),
              (socklen_t */* __restrict  */)(& remote_addrlen));
  }
#line 96
  if (fd == -1) {
    {
#line 97
    tmp = __errno_location();
    }
#line 97
    if (*tmp != 11) {
      {
#line 97
      tmp___0 = __errno_location();
      }
#line 97
      if (*tmp___0 != 11) {
        {
#line 99
        log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c",
                       99, "get_request", "accept");
        }
      }
    }
#line 103
    pending_requests = 0;
#line 104
    return;
  }
#line 106
  if (fd >= 1024) {
    {
#line 107
    log_error("Got fd >= FD_SETSIZE.");
#line 108
    close(fd);
    }
#line 109
    return;
  }
  {
#line 145
  len___0 = (socklen_t )sizeof(salocal);
#line 147
  tmp___1 = getsockname(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& salocal)),
                        (socklen_t */* __restrict  */)(& len___0));
  }
#line 147
  if (tmp___1 != 0) {
    {
#line 148
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 148,
                   "get_request", "getsockname");
#line 149
    close(fd);
    }
#line 150
    return;
  }
  {
#line 153
  conn = new_request();
  }
#line 154
  if (! conn) {
    {
#line 155
    close(fd);
    }
#line 156
    return;
  }
  {
#line 158
  conn->fd = fd;
#line 159
  conn->status = (enum REQ_STATUS )0;
#line 160
  conn->header_line = conn->client_stream;
#line 161
  conn->time_last = current_time;
#line 162
  conn->kacount = ka_max;
#line 164
  tmp___2 = ascii_sockaddr(& salocal, conn->local_ip_addr, (unsigned int )sizeof(conn->local_ip_addr));
  }
#line 164
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 167
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 167,
                   "get_request", "ascii_sockaddr failed");
#line 168
    close(fd);
#line 169
    enqueue(& request_free, conn);
    }
#line 170
    return;
  }
  {
#line 174
  tmp___3 = fcntl(conn->fd, 4, 2048);
  }
#line 174
  if (tmp___3 == -1) {
    {
#line 175
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 175,
                   "get_request", "fcntl: unable to set new socket to non-block");
#line 176
    close(fd);
#line 177
    enqueue(& request_free, conn);
    }
#line 178
    return;
  }
  {
#line 182
  tmp___4 = fcntl(conn->fd, 2, 1);
  }
#line 182
  if (tmp___4 == -1) {
    {
#line 183
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 183,
                   "get_request", "fctnl: unable to set close-on-exec for new socket");
#line 184
    close(fd);
#line 185
    enqueue(& request_free, conn);
    }
#line 186
    return;
  }
#line 194
  if (system_bufsize == 0U) {
    {
#line 195
    len___0 = (socklen_t )sizeof(system_bufsize);
#line 196
    tmp___5 = getsockopt(conn->fd, 1, 7, (void */* __restrict  */)(& system_bufsize),
                         (socklen_t */* __restrict  */)(& len___0));
    }
#line 196
    if (tmp___5 == 0) {
#line 196
      if (! ((unsigned long )len___0 == sizeof(system_bufsize))) {
        {
#line 201
        log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c",
                       201, "get_request", "getsockopt(SNDBUF)");
#line 202
        system_bufsize = 1U;
        }
      }
    } else {
      {
#line 201
      log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 201,
                     "get_request", "getsockopt(SNDBUF)");
#line 202
      system_bufsize = 1U;
      }
    }
  }
#line 205
  if (system_bufsize < sockbufsize) {
    {
#line 206
    tmp___6 = setsockopt(conn->fd, 1, 7, (void const   *)((void *)(& sockbufsize)),
                         (socklen_t )sizeof(sockbufsize));
    }
#line 206
    if (tmp___6 == -1) {
      {
#line 209
      log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 209,
                     "get_request", "setsockopt: unable to set socket buffer size");
      }
    }
  }
  {
#line 218
  tmp___7 = ascii_sockaddr(& remote_addr, conn->remote_ip_addr, (unsigned int )sizeof(conn->remote_ip_addr));
  }
#line 218
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    {
#line 221
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/request.c", 221,
                   "get_request", "ascii_sockaddr failed");
#line 222
    close(fd);
#line 223
    enqueue(& request_free, conn);
    }
#line 224
    return;
  }
  {
#line 228
  tmp___8 = net_port(& remote_addr);
#line 228
  conn->remote_port = (unsigned int )tmp___8;
#line 230
  (status.requests) ++;
#line 244
  total_connections ++;
  }
#line 246
  if (total_connections > max_connections) {
    {
#line 247
    pending_requests = 0;
#line 250
    conn->http_version = (enum HTTP_VERSION )2;
#line 251
    conn->method = (enum HTTP_METHOD )1;
#line 252
    send_r_service_unavailable(conn);
#line 253
    conn->status = (enum REQ_STATUS )10;
    }
  }
  {
#line 257
  enqueue(& request_ready, conn);
  }
#line 258
  return;
}
}
#line 262 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
static off_t bytes_to_zero  =    (off_t )((unsigned long )(& ((request *)0)->fd));
#line 260 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
static void sanitize_request(request *req , int new_req ) 
{ 
  off_t bytes_to_move ;

  {
#line 264
  if (new_req) {
#line 265
    req->kacount = ka_max;
#line 266
    req->time_last = current_time;
#line 267
    req->client_stream_pos = 0;
  } else {
#line 269
    bytes_to_move = (off_t )(req->client_stream_pos - req->parse_pos);
#line 272
    if (bytes_to_move) {
      {
#line 273
      memmove((void *)(req->client_stream), (void const   *)(req->client_stream + req->parse_pos),
              (size_t )bytes_to_move);
      }
    }
#line 276
    req->client_stream_pos = (int )bytes_to_move;
  }
#line 283
  if (debug_level & (1 << 12)) {
    {
#line 284
    log_error_time();
#line 285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"req: %p, offset: %ld\n",
            (void *)req, bytes_to_zero);
    }
  }
  {
#line 289
  memset((void *)req, 0, (size_t )bytes_to_zero);
#line 291
  req->status = (enum REQ_STATUS )0;
#line 292
  req->header_line = req->client_stream;
  }
#line 293
  return;
}
}
#line 302 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
static void free_request(request *req ) 
{ 
  int i ;
  char buf___0[32768] ;

  {
#line 308
  if (req->buffer_end) {
#line 308
    if ((unsigned int )req->status < 11U) {
      {
#line 312
      req->status = (enum REQ_STATUS )10;
#line 317
      i = req_flush(req);
      }
#line 321
      if (i == -2) {
#line 322
        req->status = (enum REQ_STATUS )12;
      } else
#line 323
      if (i > 0) {
#line 324
        return;
      }
    }
  }
  {
#line 328
  dequeue(& request_ready, req);
  }
#line 331
  if ((unsigned int )req->status == 11U) {
#line 331
    if ((unsigned int )req->response_status == 0U) {
#line 332
      req->response_status = (enum RESPONSE_CODE )408;
    }
  }
#line 334
  if (req->kacount < ka_max) {
#line 334
    if (! req->logline) {
#line 334
      if (! (req->client_stream_pos == 0)) {
        {
#line 343
        log_access(req);
        }
      }
    } else {
      {
#line 343
      log_access(req);
      }
    }
  } else {
    {
#line 343
    log_access(req);
    }
  }
#line 346
  if (req->mmap_entry_var) {
    {
#line 347
    release_mmap(req->mmap_entry_var);
    }
  } else
#line 348
  if (req->data_mem) {
    {
#line 349
    munmap((void *)req->data_mem, (size_t )req->filesize);
    }
  }
#line 351
  if (req->data_fd) {
    {
#line 352
    close(req->data_fd);
#line 353
    block_read_fdset.__fds_bits[req->data_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->data_fd % (8 * (int )sizeof(__fd_mask )));
    }
  }
#line 356
  if (req->post_data_fd) {
    {
#line 357
    close(req->post_data_fd);
#line 358
    block_write_fdset.__fds_bits[req->post_data_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->post_data_fd % (8 * (int )sizeof(__fd_mask )));
    }
  }
#line 361
  if ((unsigned int )req->response_status >= 400U) {
#line 362
    (status.errors) ++;
  }
#line 364
  i = (int )common_cgi_env_count;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < req->cgi_env_index)) {
#line 364
      goto while_break;
    }
#line 365
    if (req->cgi_env[i]) {
      {
#line 366
      free((void *)req->cgi_env[i]);
      }
    } else {
      {
#line 368
      log_error_time();
#line 369
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: CGI Environment contains NULL value(index %d of %d).\n",
              i, req->cgi_env_index);
      }
    }
#line 364
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  if (req->pathname) {
    {
#line 375
    free((void *)req->pathname);
    }
  }
#line 376
  if (req->path_info) {
    {
#line 377
    free((void *)req->path_info);
    }
  }
#line 378
  if (req->path_translated) {
    {
#line 379
    free((void *)req->path_translated);
    }
  }
#line 380
  if (req->script_name) {
    {
#line 381
    free((void *)req->script_name);
    }
  }
#line 382
  if (req->host) {
    {
#line 383
    free((void *)req->host);
    }
  }
#line 384
  if (req->ranges) {
    {
#line 385
    ranges_reset(req);
    }
  }
#line 387
  if ((unsigned int )req->status < 11U) {
#line 387
    if ((unsigned int )req->keepalive == 1U) {
#line 387
      if ((unsigned int )req->response_status < 500U) {
#line 387
        if ((unsigned int )req->response_status != 0U) {
#line 387
          if (req->kacount > 0U) {
            {
#line 389
            sanitize_request(req, 0);
#line 391
            (req->kacount) --;
#line 393
            (status.requests) ++;
#line 394
            enqueue(& request_block, req);
#line 395
            block_read_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << req->fd % (8 * (int )sizeof(__fd_mask ));
            }
#line 395
            if (req->fd > max_fd) {
#line 395
              max_fd = req->fd;
            }
#line 396
            block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
#line 397
            return;
          }
        }
      }
    }
  }
#line 432
  if ((unsigned int )req->method == 4U) {
    {
#line 434
    read(req->fd, (void *)(buf___0), sizeof(buf___0));
    }
  }
  {
#line 436
  close(req->fd);
#line 437
  block_read_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
#line 438
  block_write_fdset.__fds_bits[req->fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << req->fd % (8 * (int )sizeof(__fd_mask )));
#line 439
  total_connections --;
#line 441
  enqueue(& request_free, req);
  }
#line 443
  return;
}
}
#line 456 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
void process_requests(int server_sock ) 
{ 
  int retval ;
  request *current ;
  request *trailer ;

  {
#line 458
  retval = 0;
#line 461
  if (pending_requests) {
    {
#line 462
    get_request(server_sock);
    }
  }
#line 468
  current = request_ready;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! current) {
#line 470
      goto while_break;
    }
    {
#line 471
    time(& current_time);
#line 472
    retval = 1;
    }
#line 474
    if (current->buffer_end) {
#line 474
      if ((unsigned int )current->status < 11U) {
        {
#line 476
        retval = req_flush(current);
        }
#line 480
        if (retval == -2) {
#line 481
          current->status = (enum REQ_STATUS )12;
#line 482
          retval = 0;
        } else
#line 483
        if (retval >= 0) {
#line 488
          retval = 1;
        }
      }
    }
#line 492
    if (retval == 1) {
      {
#line 497
      if ((unsigned int )current->status == 3U) {
#line 497
        goto case_3;
      }
#line 497
      if ((unsigned int )current->status == 2U) {
#line 497
        goto case_3;
      }
#line 497
      if ((unsigned int )current->status == 1U) {
#line 497
        goto case_3;
      }
#line 497
      if ((unsigned int )current->status == 0U) {
#line 497
        goto case_3;
      }
#line 500
      if ((unsigned int )current->status == 4U) {
#line 500
        goto case_4;
      }
#line 503
      if ((unsigned int )current->status == 5U) {
#line 503
        goto case_5;
      }
#line 506
      if ((unsigned int )current->status == 6U) {
#line 506
        goto case_6;
      }
#line 509
      if ((unsigned int )current->status == 7U) {
#line 509
        goto case_7;
      }
#line 512
      if ((unsigned int )current->status == 8U) {
#line 512
        goto case_8;
      }
#line 515
      if ((unsigned int )current->status == 9U) {
#line 515
        goto case_9;
      }
#line 522
      if ((unsigned int )current->status == 10U) {
#line 522
        goto case_10;
      }
#line 536
      if ((unsigned int )current->status == 12U) {
#line 536
        goto case_12;
      }
#line 536
      if ((unsigned int )current->status == 11U) {
#line 536
        goto case_12;
      }
#line 541
      goto switch_default;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 498
      retval = read_header(current);
      }
#line 499
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 501
      retval = read_body(current);
      }
#line 502
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 504
      retval = write_body(current);
      }
#line 505
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 507
      retval = process_get(current);
      }
#line 508
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 510
      retval = read_from_pipe(current);
      }
#line 511
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 513
      retval = write_from_pipe(current);
      }
#line 514
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 517
      retval = io_shuffle_sendfile(current);
      }
#line 521
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 524
      retval = req_flush(current);
      }
#line 528
      if (retval == -2) {
#line 529
        current->status = (enum REQ_STATUS )12;
#line 530
        retval = 0;
      } else
#line 531
      if (retval > 0) {
#line 532
        retval = 1;
      }
#line 534
      goto switch_break;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 537
      retval = 0;
#line 538
      current->buffer_end = 0;
#line 539
      current->keepalive = (enum KA_STATUS )2;
#line 540
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 542
      retval = 0;
#line 543
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown status (%d), closing!\n",
              (unsigned int )current->status);
#line 545
      current->status = (enum REQ_STATUS )12;
      }
#line 546
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 551
    if (sigterm_flag) {
#line 552
      current->keepalive = (enum KA_STATUS )2;
    }
#line 558
    if (pending_requests) {
      {
#line 559
      get_request(server_sock);
      }
    }
    {
#line 562
    if (retval == -1) {
#line 562
      goto case_neg_1;
    }
#line 567
    if (retval == 0) {
#line 567
      goto case_0___0;
    }
#line 573
    if (retval == 1) {
#line 573
      goto case_1___0;
    }
#line 577
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 563
    trailer = current;
#line 564
    current = current->next;
#line 565
    block_request(trailer);
    }
#line 566
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 568
    current->time_last = current_time;
#line 569
    trailer = current;
#line 570
    current = current->next;
#line 571
    free_request(trailer);
    }
#line 572
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 574
    current->time_last = current_time;
#line 575
    current = current->next;
#line 576
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 578
    log_error_doc(current);
#line 579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown retval in process.c - Status: %d, retval: %d\n",
            (unsigned int )current->status, retval);
#line 581
    current->status = (enum REQ_STATUS )12;
#line 582
    current = current->next;
    }
#line 583
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return;
}
}
#line 598 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
int process_logline(request *req ) 
{ 
  char *stop ;
  char *stop2 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *host ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  unsigned int p1 ;
  unsigned int p2 ;
  int tmp___8 ;

  {
  {
#line 602
  req->logline = req->client_stream;
#line 604
  tmp = strlen((char const   *)req->logline);
  }
#line 604
  if (tmp < 5UL) {
    {
#line 606
    log_error_doc(req);
#line 607
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Request too short: \"%s\"\n",
            req->logline);
#line 608
    send_r_bad_request(req);
    }
#line 609
    return (0);
  }
  {
#line 612
  tmp___2 = memcmp((void const   *)req->logline, (void const   *)"GET ", (size_t )4);
  }
#line 612
  if (tmp___2) {
    {
#line 614
    tmp___1 = memcmp((void const   *)req->logline, (void const   *)"HEAD ", (size_t )5);
    }
#line 614
    if (tmp___1) {
      {
#line 617
      tmp___0 = memcmp((void const   *)req->logline, (void const   *)"POST ", (size_t )5);
      }
#line 617
      if (tmp___0) {
        {
#line 620
        log_error_doc(req);
#line 621
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malformed request: \"%s\"\n",
                req->logline);
#line 622
        send_r_not_implemented(req);
        }
#line 623
        return (0);
      } else {
#line 618
        req->method = (enum HTTP_METHOD )4;
      }
    } else {
#line 616
      req->method = (enum HTTP_METHOD )2;
    }
  } else {
#line 613
    req->method = (enum HTTP_METHOD )1;
  }
#line 626
  req->http_version = (enum HTTP_VERSION )2;
#line 629
  stop = req->logline + 3;
#line 630
  if ((int )*stop != 32) {
#line 631
    stop ++;
  }
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    stop ++;
#line 634
    if (! ((int )*stop == 32)) {
#line 634
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  stop2 = stop;
  {
#line 639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 639
    if ((int )*stop2 != 0) {
#line 639
      if (! ((int )*stop2 != 32)) {
#line 639
        goto while_break___0;
      }
    } else {
#line 639
      goto while_break___0;
    }
#line 640
    stop2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 642
  if (stop2 - stop > 1024L) {
    {
#line 643
    log_error_doc(req);
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"URI too long %d: \"%s\"\n",
            1024, req->logline);
#line 646
    send_r_bad_request(req);
    }
#line 647
    return (0);
  }
  {
#line 651
  tmp___4 = strlen("http");
#line 651
  tmp___5 = memcmp((void const   *)stop, (void const   *)"http", tmp___4);
  }
#line 651
  if (tmp___5) {
    {
#line 720
    memcpy((void */* __restrict  */)(req->request_uri), (void const   */* __restrict  */)stop,
           (size_t )(stop2 - stop));
    }
  } else {
    {
#line 651
    tmp___6 = strlen("http");
#line 651
    tmp___7 = memcmp((void const   *)(stop + tmp___6), (void const   *)"://", (size_t )3);
    }
#line 651
    if (tmp___7) {
      {
#line 720
      memcpy((void */* __restrict  */)(req->request_uri), (void const   */* __restrict  */)stop,
             (size_t )(stop2 - stop));
      }
    } else {
      {
#line 658
      tmp___3 = strlen("http");
#line 658
      stop += tmp___3 + 3UL;
#line 659
      host = stop;
      }
#line 664
      if ((int )*host == 47) {
        {
#line 667
        log_error_doc(req);
#line 669
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bogus absolute URI\n");
#line 670
        send_r_bad_request(req);
        }
#line 671
        return (0);
      } else
#line 664
      if ((int )*host == 32) {
        {
#line 667
        log_error_doc(req);
#line 669
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bogus absolute URI\n");
#line 670
        send_r_bad_request(req);
        }
#line 671
        return (0);
      } else
#line 664
      if ((int )*host == 0) {
        {
#line 667
        log_error_doc(req);
#line 669
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bogus absolute URI\n");
#line 670
        send_r_bad_request(req);
        }
#line 671
        return (0);
      }
      {
#line 677
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 677
        if ((int )*stop != 0) {
#line 677
          if ((int )*stop != 47) {
#line 677
            if (! ((int )*stop != 32)) {
#line 677
              goto while_break___1;
            }
          } else {
#line 677
            goto while_break___1;
          }
        } else {
#line 677
          goto while_break___1;
        }
#line 678
        stop ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 680
      if ((int )*stop != 47) {
        {
#line 682
        log_error_doc(req);
#line 683
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no URL in absolute URI: \"%s\"\n",
                req->logline);
#line 685
        send_r_bad_request(req);
        }
#line 686
        return (0);
      }
#line 692
      if ((unsigned long )stop2 < (unsigned long )stop) {
        {
#line 695
        log_error_doc(req);
#line 696
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: corruption in absolute URI:\"%s\".  This should not happen.\n",
                req->logline);
#line 698
        send_r_bad_request(req);
        }
#line 699
        return (0);
      }
      {
#line 703
      memcpy((void */* __restrict  */)(req->request_uri), (void const   */* __restrict  */)stop,
             (size_t )(stop2 - stop));
#line 705
      *stop = (char )'\000';
#line 717
      req->header_host = host;
      }
    }
  }
#line 723
  req->request_uri[stop2 - stop] = (char )'\000';
#line 726
  if ((int )*stop2 == 0) {
#line 727
    req->http_version = (enum HTTP_VERSION )1;
  } else
#line 728
  if ((int )*stop2 == 32) {
#line 733
    stop2 ++;
    {
#line 734
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 734
      if ((int )*stop2 == 32) {
#line 734
        if (! ((int )*stop2 != 0)) {
#line 734
          goto while_break___2;
        }
      } else {
#line 734
        goto while_break___2;
      }
#line 735
      stop2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 737
    if ((int )*stop2 == 0) {
#line 738
      req->http_version = (enum HTTP_VERSION )1;
    } else {
      {
#line 741
      tmp___8 = sscanf((char const   */* __restrict  */)stop2, (char const   */* __restrict  */)"HTTP/%u.%u",
                       & p1, & p2);
      }
#line 741
      if (tmp___8 == 2) {
#line 743
        if (p1 == 0U) {
#line 743
          if (p2 == 9U) {
#line 744
            req->http_version = (enum HTTP_VERSION )1;
          } else {
#line 743
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 745
        if (p1 == 1U) {
#line 745
          if (p2 == 0U) {
#line 746
            req->http_version = (enum HTTP_VERSION )2;
          } else {
#line 745
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 747
        if (p1 == 1U) {
#line 747
          if (p2 == 1U) {
#line 748
            req->http_version = (enum HTTP_VERSION )3;
#line 749
            req->keepalive = (enum KA_STATUS )1;
          } else {
#line 762
            goto BAD_VERSION;
          }
        } else {
#line 762
          goto BAD_VERSION;
        }
      } else {
#line 765
        goto BAD_VERSION;
      }
    }
  }
#line 770
  if ((unsigned int )req->method == 2U) {
#line 770
    if ((unsigned int )req->http_version == 1U) {
      {
#line 771
      log_error("method is HEAD but version is HTTP/0.9");
#line 772
      send_r_bad_request(req);
      }
#line 773
      return (0);
    }
  }
#line 775
  req->cgi_env_index = (int )common_cgi_env_count;
#line 777
  return (1);
  BAD_VERSION: 
  {
#line 780
  log_error_doc(req);
#line 781
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bogus HTTP version: \"%s\"\n",
          stop2);
#line 782
  send_r_bad_request(req);
  }
#line 783
  return (0);
}
}
#line 794 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
int process_header_end(request *req ) 
{ 
  int tmp ;
  char *c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 796
  if (! req->logline) {
    {
#line 797
    log_error_doc(req);
#line 798
    fputs((char const   */* __restrict  */)"No logline in process_header_end\n", (FILE */* __restrict  */)stderr);
#line 799
    send_r_error(req);
    }
#line 800
    return (0);
  }
  {
#line 804
  tmp = unescape_uri(req->request_uri, & req->query_string);
  }
#line 804
  if (tmp == 0) {
    {
#line 805
    log_error_doc(req);
#line 806
    fputs((char const   */* __restrict  */)"URI contains bogus characters\n", (FILE */* __restrict  */)stderr);
#line 807
    send_r_bad_request(req);
    }
#line 808
    return (0);
  }
  {
#line 812
  clean_pathname(req->request_uri);
  }
#line 814
  if ((int )req->request_uri[0] != 47) {
    {
#line 815
    log_error("URI does not begin with \'/\'\n");
#line 816
    send_r_bad_request(req);
    }
#line 817
    return (0);
  }
#line 820
  if (vhost_root) {
#line 822
    if (! req->header_host) {
      {
#line 823
      req->host = strdup(default_vhost);
      }
    } else {
      {
#line 825
      req->host = strdup((char const   *)req->header_host);
      }
    }
#line 827
    if (! req->host) {
      {
#line 828
      log_error_doc(req);
#line 829
      fputs((char const   */* __restrict  */)"unable to strdup default_vhost/req->header_host\n",
            (FILE */* __restrict  */)stderr);
#line 830
      send_r_error(req);
      }
#line 831
      return (0);
    }
    {
#line 833
    strlower(req->host);
#line 839
    c = strchr((char const   *)req->host, ':');
    }
#line 840
    if (c) {
#line 841
      *c = (char )'\000';
    }
    {
#line 843
    tmp___0 = check_host((char const   *)req->host);
    }
#line 843
    if (tmp___0 < 1) {
      {
#line 844
      log_error_doc(req);
#line 845
      fputs((char const   */* __restrict  */)"host invalid!\n", (FILE */* __restrict  */)stderr);
#line 846
      send_r_bad_request(req);
      }
#line 847
      return (0);
    }
  }
  {
#line 851
  tmp___1 = translate_uri(req);
  }
#line 851
  if (tmp___1 == 0) {
#line 853
    req->keepalive = (enum KA_STATUS )2;
#line 854
    return (0);
  }
#line 857
  if ((unsigned int )req->method == 4U) {
    {
#line 858
    req->post_data_fd = create_temporary_file((short)1, (char *)((void *)0), 0U);
    }
#line 859
    if (req->post_data_fd == 0) {
      {
#line 861
      send_r_error(req);
      }
#line 862
      return (0);
    }
    {
#line 864
    tmp___2 = fcntl(req->post_data_fd, 2, 1);
    }
#line 864
    if (tmp___2 == -1) {
      {
#line 865
      boa_perror(req, "unable to set close-on-exec for req->post_data_fd!");
#line 866
      close(req->post_data_fd);
#line 867
      req->post_data_fd = 0;
      }
#line 868
      return (0);
    }
#line 870
    return (1);
  }
#line 873
  if (req->cgi_type) {
    {
#line 874
    tmp___3 = init_cgi(req);
    }
#line 874
    return (tmp___3);
  }
  {
#line 877
  req->status = (enum REQ_STATUS )6;
#line 879
  tmp___4 = init_get(req);
  }
#line 879
  return (tmp___4);
}
}
#line 889 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
int process_option_line(request *req ) 
{ 
  char c ;
  char *value ;
  char *line ;
  char *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 891
  line = req->header_line;
#line 900
  value = strchr((char const   *)line, ':');
  }
#line 901
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 902
    log_error_doc(req);
#line 903
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"header \"%s\" does not contain \':\'\n",
            line);
    }
#line 904
    return (0);
  }
  {
#line 906
  tmp = value;
#line 906
  value ++;
#line 906
  *tmp = (char )'\000';
#line 907
  to_upper(line);
  }
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    c = *value;
#line 910
    if (c) {
#line 910
      if (! ((int )c == 32)) {
#line 910
        if (! ((int )c == 9)) {
#line 910
          goto while_break;
        }
      }
    } else {
#line 910
      goto while_break;
    }
#line 911
    value ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  if ((int )c == 0) {
#line 916
    return (1);
  }
  {
#line 920
  if ((int )*(line + 0) == 65) {
#line 920
    goto case_65;
  }
#line 928
  if ((int )*(line + 0) == 67) {
#line 928
    goto case_67;
  }
#line 943
  if ((int )*(line + 0) == 72) {
#line 943
    goto case_72;
  }
#line 949
  if ((int )*(line + 0) == 73) {
#line 949
    goto case_73;
  }
#line 956
  if ((int )*(line + 0) == 82) {
#line 956
    goto case_82;
  }
#line 975
  if ((int )*(line + 0) == 85) {
#line 975
    goto case_85;
  }
#line 985
  goto switch_default;
  case_65: /* CIL Label */ 
  {
#line 921
  tmp___0 = memcmp((void const   *)line, (void const   *)"ACCEPT", (size_t )7);
  }
#line 921
  if (! tmp___0) {
#line 925
    return (1);
  }
#line 927
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 929
  tmp___5 = memcmp((void const   *)line, (void const   *)"CONTENT_TYPE", (size_t )13);
  }
#line 929
  if (tmp___5) {
    _L___0: /* CIL Label */ 
    {
#line 932
    tmp___4 = memcmp((void const   *)line, (void const   *)"CONTENT_LENGTH", (size_t )15);
    }
#line 932
    if (tmp___4) {
      _L: /* CIL Label */ 
      {
#line 936
      tmp___3 = memcmp((void const   *)line, (void const   *)"CONNECTION", (size_t )11);
      }
#line 936
      if (! tmp___3) {
#line 936
        if (ka_max) {
#line 936
          if ((unsigned int )req->keepalive != 2U) {
            {
#line 938
            tmp___2 = strncasecmp((char const   *)value, "Keep-Alive", (size_t )10);
            }
#line 938
            if (tmp___2) {
#line 938
              req->keepalive = (enum KA_STATUS )2;
            } else {
#line 938
              req->keepalive = (enum KA_STATUS )1;
            }
#line 940
            return (1);
          }
        }
      }
    } else
#line 932
    if (! req->content_length) {
#line 934
      req->content_length = value;
#line 935
      return (1);
    } else {
#line 932
      goto _L;
    }
  } else
#line 929
  if (! req->content_type) {
#line 930
    req->content_type = value;
#line 931
    return (1);
  } else {
#line 929
    goto _L___0;
  }
#line 942
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 944
  tmp___6 = memcmp((void const   *)line, (void const   *)"HOST", (size_t )5);
  }
#line 944
  if (! tmp___6) {
#line 944
    if (! req->header_host) {
#line 945
      req->header_host = value;
#line 946
      return (1);
    }
  }
#line 948
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 950
  tmp___7 = memcmp((void const   *)line, (void const   *)"IF_MODIFIED_SINCE", (size_t )18);
  }
#line 950
  if (! tmp___7) {
#line 950
    if (! req->if_modified_since) {
#line 952
      req->if_modified_since = value;
#line 953
      return (1);
    }
  }
#line 955
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 958
  tmp___11 = memcmp((void const   *)line, (void const   *)"REFERER", (size_t )8);
  }
#line 958
  if (tmp___11) {
    {
#line 964
    tmp___10 = memcmp((void const   *)line, (void const   *)"RANGE", (size_t )6);
    }
#line 964
    if (! tmp___10) {
#line 965
      if (req->ranges) {
#line 965
        if ((req->ranges)->stop == 2147483647UL) {
#line 967
          return (1);
        } else {
#line 965
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 968
        tmp___9 = range_parse(req, (char const   *)value);
        }
#line 968
        if (! tmp___9) {
          {
#line 970
          send_r_invalid_range(req);
          }
#line 971
          return (0);
        }
      }
    }
  } else {
    {
#line 959
    req->header_referer = value;
#line 960
    tmp___8 = add_cgi_env(req, "REFERER", (char const   *)value, 1);
    }
#line 960
    if (! tmp___8) {
#line 962
      return (0);
    }
  }
#line 974
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 976
  tmp___13 = memcmp((void const   *)line, (void const   *)"USER_AGENT", (size_t )11);
  }
#line 976
  if (! tmp___13) {
    {
#line 977
    req->header_user_agent = value;
#line 978
    tmp___12 = add_cgi_env(req, "USER_AGENT", (char const   *)value, 1);
    }
#line 978
    if (! tmp___12) {
#line 980
      return (0);
    }
#line 982
    return (1);
  }
#line 984
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 986
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 989
  tmp___14 = add_cgi_env(req, (char const   *)line, (char const   *)value, 1);
  }
#line 989
  return (tmp___14);
}
}
#line 1019 "/home/june/collector/temp/boa-0.94.14rc21/src/request.c"
void free_requests(void) 
{ 
  request *ptr ;
  request *next ;

  {
#line 1022
  ptr = request_free;
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 1023
      goto while_break;
    }
    {
#line 1024
    next = ptr->next;
#line 1025
    free((void *)ptr);
#line 1026
    ptr = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  request_free = (request *)((void *)0);
#line 1029
  return;
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 51 "/home/june/collector/temp/boa-0.94.14rc21/src/ip.c"
int bind_server(int sock , char *ip , unsigned int port ) 
{ 
  struct sockaddr_in server_sockaddr ;
  int tmp ;

  {
  {
#line 60
  memset((void *)(& server_sockaddr), 0, sizeof(server_sockaddr));
#line 64
  server_sockaddr.sin_family = (sa_family_t )2;
  }
#line 65
  if ((unsigned long )ip != (unsigned long )((void *)0)) {
    {
#line 67
    inet_aton((char const   *)ip, & server_sockaddr.sin_addr);
    }
  } else {
    {
#line 74
    server_sockaddr.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 76
  server_sockaddr.sin_port = htons((uint16_t )port);
#line 79
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& server_sockaddr)),
             (socklen_t )sizeof(server_sockaddr));
  }
#line 79
  return (tmp);
}
}
#line 83 "/home/june/collector/temp/boa-0.94.14rc21/src/ip.c"
char *ascii_sockaddr(struct sockaddr_in *s , char *dest , unsigned int len___0 ) 
{ 
  unsigned int newlen ;
  char *buf___0 ;
  size_t tmp ;

  {
  {
#line 106
  buf___0 = inet_ntoa(s->sin_addr);
#line 107
  tmp = strlen((char const   *)buf___0);
#line 107
  newlen = (unsigned int )tmp;
  }
#line 113
  if (newlen + 1U > len___0) {
#line 114
    return ((char *)((void *)0));
  }
  {
#line 116
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)buf___0,
         (size_t )newlen);
#line 117
  *(dest + newlen) = (char )'\000';
  }
#line 119
  return (dest);
}
}
#line 122 "/home/june/collector/temp/boa-0.94.14rc21/src/ip.c"
int net_port(struct sockaddr_in *s ) 
{ 
  int p ;
  uint16_t tmp ;

  {
  {
#line 124
  p = -1;
#line 136
  tmp = ntohs(s->sin_port);
#line 136
  p = (int )tmp;
  }
#line 138
  return (p);
}
}
#line 119 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
void print_ka_phrase(request *req ) ;
#line 121
void print_content_length(request *req ) ;
#line 124
void print_content_range(request *req ) ;
#line 125
void print_partial_content_continue(request *req ) ;
#line 126
void print_partial_content_done(request *req ) ;
#line 129
void send_r_continue(request *req ) ;
#line 137
void send_r_unauthorized(request *req , char const   *realm_name ) ;
#line 140
void send_r_length_required(request *req ) ;
#line 141
void send_r_precondition_failed(request *req ) ;
#line 142
void send_r_request_uri_too_long(request *req ) ;
#line 148
void send_r_bad_version(request *req , char const   *version ) ;
#line 29 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
char const   *http_ver_string(enum HTTP_VERSION ver ) 
{ 


  {
  {
#line 32
  if ((unsigned int )ver == 1U) {
#line 32
    goto case_1;
  }
#line 35
  if ((unsigned int )ver == 2U) {
#line 35
    goto case_2;
  }
#line 38
  if ((unsigned int )ver == 3U) {
#line 38
    goto case_3;
  }
#line 41
  goto switch_default;
  case_1: /* CIL Label */ 
#line 33
  return ("HTTP/0.9");
#line 34
  goto switch_break;
  case_2: /* CIL Label */ 
#line 36
  return ("HTTP/1.0");
#line 37
  goto switch_break;
  case_3: /* CIL Label */ 
#line 39
  return ("HTTP/1.1");
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 42
  return ("HTTP/1.0");
  switch_break: /* CIL Label */ ;
  }
#line 44
  return ((char const   *)((void *)0));
}
}
#line 47 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_content_type(request *req ) 
{ 
  char *mime_type ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = get_mime_type((char const   *)(req->request_uri));
#line 49
  mime_type = tmp;
  }
#line 51
  if ((unsigned long )mime_type != (unsigned long )((void *)0)) {
    {
#line 52
    req_write(req, "Content-Type: ");
#line 53
    req_write(req, (char const   *)mime_type);
    }
#line 54
    if ((unsigned long )default_charset != (unsigned long )((void *)0)) {
      {
#line 54
      tmp___0 = strncasecmp((char const   *)mime_type, "text", (size_t )4);
      }
#line 54
      if (tmp___0 == 0) {
        {
#line 58
        req_write(req, "; charset=");
#line 59
        req_write(req, (char const   *)default_charset);
        }
      }
    }
    {
#line 61
    req_write(req, "\r\n");
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_content_length(request *req ) 
{ 
  char *tmp ;

  {
  {
#line 67
  req_write(req, "Content-Length: ");
#line 68
  tmp = simple_itoa((uint64_t )req->filesize);
#line 68
  req_write(req, (char const   *)tmp);
#line 69
  req_write(req, "\r\n");
  }
#line 70
  return;
}
}
#line 74 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char lm[47]  = 
#line 74
  {      (char )'L',      (char )'a',      (char )'s',      (char )'t', 
        (char )'-',      (char )'M',      (char )'o',      (char )'d', 
        (char )'i',      (char )'f',      (char )'i',      (char )'e', 
        (char )'d',      (char )':',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 72 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_last_modified(request *req ) 
{ 


  {
  {
#line 76
  rfc822_time_buf(lm + 15, req->last_modified);
#line 77
  req_write(req, (char const   *)(lm));
  }
#line 78
  return;
}
}
#line 80 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_ka_phrase(request *req ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  if (req->kacount > 0U) {
#line 82
    if ((unsigned int )req->keepalive == 1U) {
#line 82
      if ((unsigned int )req->response_status < 500U) {
        {
#line 87
        req_write(req, "Connection: Keep-Alive\r\nKeep-Alive: timeout=");
#line 88
        tmp = simple_itoa((uint64_t )ka_timeout);
#line 88
        req_write(req, (char const   *)tmp);
#line 89
        req_write(req, ", max=");
#line 90
        tmp___0 = simple_itoa((uint64_t )req->kacount);
#line 90
        req_write(req, (char const   *)tmp___0);
#line 91
        req_write(req, "\r\n");
        }
      } else {
        {
#line 93
        req_write(req, "Connection: close\r\n");
        }
      }
    } else {
      {
#line 93
      req_write(req, "Connection: close\r\n");
      }
    }
  } else {
    {
#line 93
    req_write(req, "Connection: close\r\n");
    }
  }
#line 94
  return;
}
}
#line 98 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char date_header[38]  = 
#line 98
  {      (char )'D',      (char )'a',      (char )'t',      (char )'e', 
        (char )':',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 100 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char server_header[26]  = 
#line 100
  {      (char )'S',      (char )'e',      (char )'r',      (char )'v', 
        (char )'e',      (char )'r',      (char )':',      (char )' ', 
        (char )'B',      (char )'o',      (char )'a',      (char )'/', 
        (char )'0',      (char )'.',      (char )'9',      (char )'4', 
        (char )'.',      (char )'1',      (char )'4',      (char )'r', 
        (char )'c',      (char )'2',      (char )'1',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 96 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_http_headers(request *req ) 
{ 


  {
  {
#line 102
  rfc822_time_buf(date_header + 6, (time_t )0);
#line 103
  req_write(req, (char const   *)(date_header));
  }
#line 104
  if (! conceal_server_identity) {
    {
#line 105
    req_write(req, (char const   *)(server_header));
    }
  }
  {
#line 106
  req_write(req, "Accept-Ranges: bytes\r\n");
#line 107
  print_ka_phrase(req);
  }
#line 108
  return;
}
}
#line 110 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_content_range(request *req ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 112
  req_write(req, "Content-Range: bytes ");
#line 113
  tmp = simple_itoa((req->ranges)->start);
#line 113
  req_write(req, (char const   *)tmp);
#line 114
  req_write(req, "-");
#line 115
  tmp___0 = simple_itoa((req->ranges)->stop);
#line 115
  req_write(req, (char const   *)tmp___0);
#line 116
  req_write(req, "/");
#line 117
  tmp___1 = simple_itoa((uint64_t )req->filesize);
#line 117
  req_write(req, (char const   *)tmp___1);
#line 118
  req_write(req, "\r\n");
  }
#line 119
  return;
}
}
#line 123 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg[28]  = 
#line 123
  {      (char )'\r',      (char )'\n',      (char )'-',      (char )'-', 
        (char )'T',      (char )'H',      (char )'I',      (char )'S', 
        (char )'_',      (char )'S',      (char )'T',      (char )'R', 
        (char )'I',      (char )'N',      (char )'G',      (char )'_', 
        (char )'S',      (char )'E',      (char )'P',      (char )'A', 
        (char )'R',      (char )'A',      (char )'T',      (char )'E', 
        (char )'S',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 121 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_partial_content_continue(request *req ) 
{ 


  {
#line 125
  if (req->numranges > 1) {
    {
#line 126
    req_write(req, (char const   *)(msg));
    }
  }
  {
#line 128
  print_content_type(req);
#line 129
  print_content_range(req);
  }
#line 130
  return;
}
}
#line 134 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg___0[30]  = 
#line 134
  {      (char )'\r',      (char )'\n',      (char )'-',      (char )'-', 
        (char )'T',      (char )'H',      (char )'I',      (char )'S', 
        (char )'_',      (char )'S',      (char )'T',      (char )'R', 
        (char )'I',      (char )'N',      (char )'G',      (char )'_', 
        (char )'S',      (char )'E',      (char )'P',      (char )'A', 
        (char )'R',      (char )'A',      (char )'T',      (char )'E', 
        (char )'S',      (char )'-',      (char )'-',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 132 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void print_partial_content_done(request *req ) 
{ 


  {
  {
#line 136
  req_write(req, (char const   *)(msg___0));
  }
#line 137
  return;
}
}
#line 143 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
int complete_response(request *req ) 
{ 
  Range *r ;

  {
  {
#line 148
  r = req->ranges;
#line 149
  req->ranges = (req->ranges)->next;
#line 150
  range_pool_push(r);
  }
#line 153
  if ((unsigned int )req->response_status == 206U) {
#line 153
    if (req->numranges > 1) {
#line 154
      if ((unsigned long )req->ranges != (unsigned long )((void *)0)) {
        {
#line 155
        print_partial_content_continue(req);
#line 156
        req_write(req, "\r\n");
        }
      } else {
        {
#line 158
        print_partial_content_done(req);
#line 159
        req->status = (enum REQ_STATUS )10;
#line 160
        req_flush(req);
        }
      }
    } else {
#line 163
      req->status = (enum REQ_STATUS )10;
#line 164
      return (0);
    }
  } else {
#line 163
    req->status = (enum REQ_STATUS )10;
#line 164
    return (0);
  }
#line 166
  return (1);
}
}
#line 172 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg___1[18]  = 
#line 172
  {      (char )' ',      (char )'1',      (char )'0',      (char )'0', 
        (char )' ',      (char )'C',      (char )'o',      (char )'n', 
        (char )'t',      (char )'i',      (char )'n',      (char )'u', 
        (char )'e',      (char )'\r',      (char )'\n',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 170 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_continue(request *req ) 
{ 
  char const   *tmp ;

  {
#line 175
  if ((unsigned int )req->http_version != 3U) {
#line 176
    return;
  }
  {
#line 178
  req->response_status = (enum RESPONSE_CODE )100;
#line 180
  tmp = http_ver_string(req->http_version);
#line 180
  req_write(req, tmp);
#line 181
  req_write(req, (char const   *)(msg___1));
  }
#line 182
  return;
}
}
#line 185 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_request_ok(request *req ) 
{ 
  char const   *tmp ;

  {
#line 187
  req->response_status = (enum RESPONSE_CODE )200;
#line 188
  if ((unsigned int )req->http_version == 1U) {
#line 189
    return;
  }
  {
#line 191
  tmp = http_ver_string(req->http_version);
#line 191
  req_write(req, tmp);
#line 192
  req_write(req, " 200 OK\r\n");
#line 193
  print_http_headers(req);
  }
#line 195
  if (! req->cgi_type) {
    {
#line 196
    print_content_length(req);
#line 197
    print_last_modified(req);
#line 198
    print_content_type(req);
#line 199
    req_write(req, "\r\n");
    }
  }
#line 201
  return;
}
}
#line 206 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg___2[18]  = 
#line 206
  {      (char )' ',      (char )'2',      (char )'0',      (char )'4', 
        (char )' ',      (char )'N',      (char )'O',      (char )' ', 
        (char )'C',      (char )'O',      (char )'N',      (char )'T', 
        (char )'E',      (char )'N',      (char )'T',      (char )'\r', 
        (char )'\n',      (char )'\000'};
#line 204 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_no_content(request *req ) 
{ 
  char const   *tmp ;

  {
#line 208
  req->response_status = (enum RESPONSE_CODE )204;
#line 209
  if ((unsigned int )req->http_version == 1U) {
#line 210
    return;
  }
  {
#line 212
  tmp = http_ver_string(req->http_version);
#line 212
  req_write(req, tmp);
#line 213
  req_write(req, (char const   *)(msg___2));
#line 214
  print_http_headers(req);
  }
#line 217
  if (! req->cgi_type) {
    {
#line 218
    req_write(req, "\r\n");
    }
  }
#line 220
  return;
}
}
#line 225 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg___3[23]  = 
#line 225
  {      (char )' ',      (char )'2',      (char )'0',      (char )'6', 
        (char )' ',      (char )'P',      (char )'a',      (char )'r', 
        (char )'t',      (char )'i',      (char )'a',      (char )'l', 
        (char )' ',      (char )'C',      (char )'o',      (char )'n', 
        (char )'t',      (char )'e',      (char )'n',      (char )'t', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 226 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char msg2[69]  = 
#line 226
  {      (char )'C',      (char )'o',      (char )'n',      (char )'t', 
        (char )'e',      (char )'n',      (char )'t',      (char )'-', 
        (char )'T',      (char )'y',      (char )'p',      (char )'e', 
        (char )':',      (char )' ',      (char )'m',      (char )'u', 
        (char )'l',      (char )'t',      (char )'i',      (char )'p', 
        (char )'a',      (char )'r',      (char )'t',      (char )'/', 
        (char )'b',      (char )'y',      (char )'t',      (char )'e', 
        (char )'r',      (char )'a',      (char )'n',      (char )'g', 
        (char )'e',      (char )'s',      (char )';',      (char )' ', 
        (char )'b',      (char )'o',      (char )'u',      (char )'n', 
        (char )'d',      (char )'a',      (char )'r',      (char )'y', 
        (char )'=',      (char )'T',      (char )'H',      (char )'I', 
        (char )'S',      (char )'_',      (char )'S',      (char )'T', 
        (char )'R',      (char )'I',      (char )'N',      (char )'G', 
        (char )'_',      (char )'S',      (char )'E',      (char )'P', 
        (char )'A',      (char )'R',      (char )'A',      (char )'T', 
        (char )'E',      (char )'S',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 223 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_partial_content(request *req ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
#line 229
  req->response_status = (enum RESPONSE_CODE )206;
#line 238
  tmp = http_ver_string(req->http_version);
#line 238
  req_write(req, tmp);
#line 239
  req_write(req, (char const   *)(msg___3));
#line 240
  print_http_headers(req);
#line 241
  print_last_modified(req);
  }
#line 242
  if (req->numranges > 1) {
    {
#line 243
    req_write(req, (char const   *)(msg2));
#line 244
    req_write(req, "\r\n");
    }
  } else {
    {
#line 246
    req_write(req, "Content-Length: ");
#line 247
    tmp___0 = simple_itoa(((req->ranges)->stop - (req->ranges)->start) + 1UL);
#line 247
    req_write(req, (char const   *)tmp___0);
#line 248
    req_write(req, "\r\n");
    }
  }
  {
#line 250
  print_partial_content_continue(req);
#line 251
  req_write(req, "\r\n");
  }
#line 252
  return;
}
}
#line 256 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_moved_perm(request *req , char const   *url ) 
{ 
  char const   *tmp ;

  {
#line 258
  req->keepalive = (enum KA_STATUS )2;
#line 259
  req->response_status = (enum RESPONSE_CODE )301;
#line 260
  if ((unsigned int )req->http_version != 1U) {
    {
#line 261
    tmp = http_ver_string(req->http_version);
#line 261
    req_write(req, tmp);
#line 262
    req_write(req, " 301 Moved Permanently\r\n");
#line 263
    print_http_headers(req);
#line 264
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n");
#line 266
    req_write(req, "Location: ");
#line 267
    req_write_escape_http(req, url);
#line 268
    req_write(req, "\r\n\r\n");
    }
  }
#line 270
  if ((unsigned int )req->method != 2U) {
    {
#line 271
    req_write(req, "<HTML><HEAD><TITLE>301 Moved Permanently</TITLE></HEAD>\n<BODY>\n<H1>301 Moved</H1>The document has moved\n<A HREF=\"");
#line 275
    req_write_escape_html(req, url);
#line 276
    req_write(req, "\">here</A>.\n</BODY></HTML>\n");
    }
  }
  {
#line 278
  req_flush(req);
  }
#line 279
  return;
}
}
#line 282 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_moved_temp(request *req , char const   *url , char const   *more_hdr ) 
{ 
  char const   *tmp ;

  {
#line 284
  req->keepalive = (enum KA_STATUS )2;
#line 285
  req->response_status = (enum RESPONSE_CODE )302;
#line 286
  if ((unsigned int )req->http_version != 1U) {
    {
#line 287
    tmp = http_ver_string(req->http_version);
#line 287
    req_write(req, tmp);
#line 288
    req_write(req, " 302 Moved Temporarily\r\n");
#line 289
    print_http_headers(req);
#line 290
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n");
#line 292
    req_write(req, "Location: ");
#line 293
    req_write_escape_http(req, url);
#line 294
    req_write(req, "\r\n");
#line 295
    req_write(req, more_hdr);
#line 296
    req_write(req, "\r\n\r\n");
    }
  }
#line 298
  if ((unsigned int )req->method != 2U) {
    {
#line 299
    req_write(req, "<HTML><HEAD><TITLE>302 Moved Temporarily</TITLE></HEAD>\n<BODY>\n<H1>302 Moved</H1>The document has moved\n<A HREF=\"");
#line 303
    req_write_escape_html(req, url);
#line 304
    req_write(req, "\">here</A>.\n</BODY></HTML>\n");
    }
  }
  {
#line 306
  req_flush(req);
  }
#line 307
  return;
}
}
#line 310 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_not_modified(request *req ) 
{ 
  char const   *tmp ;

  {
  {
#line 312
  req->keepalive = (enum KA_STATUS )2;
#line 313
  req->response_status = (enum RESPONSE_CODE )304;
#line 314
  tmp = http_ver_string(req->http_version);
#line 314
  req_write(req, tmp);
#line 315
  req_write(req, " 304 Not Modified\r\n");
#line 316
  print_http_headers(req);
#line 317
  print_content_type(req);
#line 318
  req_write(req, "\r\n");
#line 319
  req_flush(req);
  }
#line 320
  return;
}
}
#line 323 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_bad_request(request *req ) 
{ 
  char const   *tmp ;

  {
#line 325
  req->keepalive = (enum KA_STATUS )2;
#line 326
  req->response_status = (enum RESPONSE_CODE )400;
#line 327
  if ((unsigned int )req->http_version != 1U) {
    {
#line 328
    tmp = http_ver_string(req->http_version);
#line 328
    req_write(req, tmp);
#line 329
    req_write(req, " 400 Bad Request\r\n");
#line 330
    print_http_headers(req);
#line 331
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 333
  if ((unsigned int )req->method != 2U) {
    {
#line 334
    req_write(req, "<HTML><HEAD><TITLE>400 Bad Request</TITLE></HEAD>\n<BODY><H1>400 Bad Request</H1>\nYour client has issued a malformed or illegal request.\n</BODY></HTML>\n");
    }
  }
  {
#line 338
  req_flush(req);
  }
#line 339
  return;
}
}
#line 342 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_unauthorized(request *req , char const   *realm_name ) 
{ 
  char const   *tmp ;

  {
#line 344
  req->keepalive = (enum KA_STATUS )2;
#line 345
  req->response_status = (enum RESPONSE_CODE )401;
#line 346
  if ((unsigned int )req->http_version != 1U) {
    {
#line 347
    tmp = http_ver_string(req->http_version);
#line 347
    req_write(req, tmp);
#line 348
    req_write(req, " 401 Unauthorized\r\n");
#line 349
    print_http_headers(req);
#line 350
    req_write(req, "WWW-Authenticate: Basic realm=\"");
#line 351
    req_write(req, realm_name);
#line 352
    req_write(req, "\r\n");
#line 353
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 355
  if ((unsigned int )req->method != 2U) {
    {
#line 356
    req_write(req, "<HTML><HEAD><TITLE>401 Unauthorized</TITLE></HEAD>\n<BODY><H1>401 Unauthorized</H1>\nYour client does not have permission to get URL ");
#line 360
    req_write_escape_html(req, (char const   *)(req->request_uri));
#line 361
    req_write(req, " from this server.\n</BODY></HTML>\n");
    }
  }
  {
#line 363
  req_flush(req);
  }
#line 364
  return;
}
}
#line 367 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_forbidden(request *req ) 
{ 
  char const   *tmp ;

  {
#line 369
  req->keepalive = (enum KA_STATUS )2;
#line 370
  req->response_status = (enum RESPONSE_CODE )403;
#line 371
  if ((unsigned int )req->http_version != 1U) {
    {
#line 372
    tmp = http_ver_string(req->http_version);
#line 372
    req_write(req, tmp);
#line 373
    req_write(req, " 403 Forbidden\r\n");
#line 374
    print_http_headers(req);
#line 375
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 377
  if ((unsigned int )req->method != 2U) {
    {
#line 378
    req_write(req, "<HTML><HEAD><TITLE>403 Forbidden</TITLE></HEAD>\n<BODY><H1>403 Forbidden</H1>\nYour client does not have permission to get URL ");
#line 381
    req_write_escape_html(req, (char const   *)(req->request_uri));
#line 382
    req_write(req, " from this server.\n</BODY></HTML>\n");
    }
  }
  {
#line 384
  req_flush(req);
  }
#line 385
  return;
}
}
#line 388 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_not_found(request *req ) 
{ 
  char const   *tmp ;

  {
#line 390
  req->keepalive = (enum KA_STATUS )2;
#line 391
  req->response_status = (enum RESPONSE_CODE )404;
#line 392
  if ((unsigned int )req->http_version != 1U) {
    {
#line 393
    tmp = http_ver_string(req->http_version);
#line 393
    req_write(req, tmp);
#line 394
    req_write(req, " 404 Not Found\r\n");
#line 395
    print_http_headers(req);
#line 396
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 398
  if ((unsigned int )req->method != 2U) {
    {
#line 399
    req_write(req, "<HTML><HEAD><TITLE>404 Not Found</TITLE></HEAD>\n<BODY><H1>404 Not Found</H1>\nThe requested URL ");
#line 401
    req_write_escape_html(req, (char const   *)(req->request_uri));
#line 402
    req_write(req, " was not found on this server.\n</BODY></HTML>\n");
    }
  }
  {
#line 404
  req_flush(req);
  }
#line 405
  return;
}
}
#line 409 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_length_required(request *req ) 
{ 
  char const   *tmp ;

  {
#line 411
  req->keepalive = (enum KA_STATUS )2;
#line 412
  req->response_status = (enum RESPONSE_CODE )411;
#line 413
  if ((unsigned int )req->http_version != 1U) {
    {
#line 414
    tmp = http_ver_string(req->http_version);
#line 414
    req_write(req, tmp);
#line 415
    req_write(req, " 411 Length Required\r\n");
#line 416
    print_http_headers(req);
#line 417
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n");
#line 418
    print_last_modified(req);
#line 419
    print_content_type(req);
#line 420
    req_write(req, "\r\n");
    }
  }
#line 422
  if ((unsigned int )req->method != 2U) {
    {
#line 423
    req_write(req, "<HTML><HEAD><TITLE>411 Length Required</TITLE></HEAD>\n<BODY><H1>411 Length Required</H1>\nThe requested URL ");
#line 426
    req_write_escape_html(req, (char const   *)(req->request_uri));
#line 427
    req_write(req, " requires that a valid Content-Length header be sent with it.\n</BODY></HTML>\n");
    }
  }
  {
#line 431
  req_flush(req);
  }
#line 432
  return;
}
}
#line 435 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_precondition_failed(request *req ) 
{ 
  char const   *tmp ;

  {
#line 437
  req->keepalive = (enum KA_STATUS )2;
#line 438
  req->response_status = (enum RESPONSE_CODE )412;
#line 439
  if ((unsigned int )req->http_version != 1U) {
    {
#line 440
    tmp = http_ver_string(req->http_version);
#line 440
    req_write(req, tmp);
#line 441
    req_write(req, " 412 Precondition Failed\r\n");
#line 442
    print_http_headers(req);
#line 443
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 445
  if ((unsigned int )req->method != 2U) {
    {
#line 446
    req_write(req, "<HTML><HEAD><TITLE>412 Precondition Failed</TITLE></HEAD>\n<BODY><H1>412 Precondition Failed</H1>\n</BODY></HTML>\n");
    }
  }
  {
#line 450
  req_flush(req);
  }
#line 451
  return;
}
}
#line 460 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static unsigned int len  =    0U;
#line 454 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_request_uri_too_long(request *req ) 
{ 
  char body___1[170] ;
  char const   *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 456
  body___1[0] = (char )'<';
#line 456
  body___1[1] = (char )'H';
#line 456
  body___1[2] = (char )'T';
#line 456
  body___1[3] = (char )'M';
#line 456
  body___1[4] = (char )'L';
#line 456
  body___1[5] = (char )'>';
#line 456
  body___1[6] = (char )'<';
#line 456
  body___1[7] = (char )'H';
#line 456
  body___1[8] = (char )'E';
#line 456
  body___1[9] = (char )'A';
#line 456
  body___1[10] = (char )'D';
#line 456
  body___1[11] = (char )'>';
#line 456
  body___1[12] = (char )'<';
#line 456
  body___1[13] = (char )'T';
#line 456
  body___1[14] = (char )'I';
#line 456
  body___1[15] = (char )'T';
#line 456
  body___1[16] = (char )'L';
#line 456
  body___1[17] = (char )'E';
#line 456
  body___1[18] = (char )'>';
#line 456
  body___1[19] = (char )'4';
#line 456
  body___1[20] = (char )'1';
#line 456
  body___1[21] = (char )'4';
#line 456
  body___1[22] = (char )' ';
#line 456
  body___1[23] = (char )'R';
#line 456
  body___1[24] = (char )'e';
#line 456
  body___1[25] = (char )'q';
#line 456
  body___1[26] = (char )'u';
#line 456
  body___1[27] = (char )'e';
#line 456
  body___1[28] = (char )'s';
#line 456
  body___1[29] = (char )'t';
#line 456
  body___1[30] = (char )' ';
#line 456
  body___1[31] = (char )'U';
#line 456
  body___1[32] = (char )'R';
#line 456
  body___1[33] = (char )'I';
#line 456
  body___1[34] = (char )' ';
#line 456
  body___1[35] = (char )'T';
#line 456
  body___1[36] = (char )'o';
#line 456
  body___1[37] = (char )'o';
#line 456
  body___1[38] = (char )' ';
#line 456
  body___1[39] = (char )'L';
#line 456
  body___1[40] = (char )'o';
#line 456
  body___1[41] = (char )'n';
#line 456
  body___1[42] = (char )'g';
#line 456
  body___1[43] = (char )'<';
#line 456
  body___1[44] = (char )'/';
#line 456
  body___1[45] = (char )'T';
#line 456
  body___1[46] = (char )'I';
#line 456
  body___1[47] = (char )'T';
#line 456
  body___1[48] = (char )'L';
#line 456
  body___1[49] = (char )'E';
#line 456
  body___1[50] = (char )'>';
#line 456
  body___1[51] = (char )'<';
#line 456
  body___1[52] = (char )'/';
#line 456
  body___1[53] = (char )'H';
#line 456
  body___1[54] = (char )'E';
#line 456
  body___1[55] = (char )'A';
#line 456
  body___1[56] = (char )'D';
#line 456
  body___1[57] = (char )'>';
#line 456
  body___1[58] = (char )'\n';
#line 456
  body___1[59] = (char )'<';
#line 456
  body___1[60] = (char )'B';
#line 456
  body___1[61] = (char )'O';
#line 456
  body___1[62] = (char )'D';
#line 456
  body___1[63] = (char )'Y';
#line 456
  body___1[64] = (char )'>';
#line 456
  body___1[65] = (char )'<';
#line 456
  body___1[66] = (char )'H';
#line 456
  body___1[67] = (char )'1';
#line 456
  body___1[68] = (char )'>';
#line 456
  body___1[69] = (char )'4';
#line 456
  body___1[70] = (char )'1';
#line 456
  body___1[71] = (char )'4';
#line 456
  body___1[72] = (char )' ';
#line 456
  body___1[73] = (char )'R';
#line 456
  body___1[74] = (char )'e';
#line 456
  body___1[75] = (char )'q';
#line 456
  body___1[76] = (char )'u';
#line 456
  body___1[77] = (char )'e';
#line 456
  body___1[78] = (char )'s';
#line 456
  body___1[79] = (char )'t';
#line 456
  body___1[80] = (char )' ';
#line 456
  body___1[81] = (char )'U';
#line 456
  body___1[82] = (char )'R';
#line 456
  body___1[83] = (char )'I';
#line 456
  body___1[84] = (char )' ';
#line 456
  body___1[85] = (char )'T';
#line 456
  body___1[86] = (char )'o';
#line 456
  body___1[87] = (char )'o';
#line 456
  body___1[88] = (char )' ';
#line 456
  body___1[89] = (char )'L';
#line 456
  body___1[90] = (char )'o';
#line 456
  body___1[91] = (char )'n';
#line 456
  body___1[92] = (char )'g';
#line 456
  body___1[93] = (char )'<';
#line 456
  body___1[94] = (char )'/';
#line 456
  body___1[95] = (char )'H';
#line 456
  body___1[96] = (char )'1';
#line 456
  body___1[97] = (char )'>';
#line 456
  body___1[98] = (char )'\n';
#line 456
  body___1[99] = (char )'Y';
#line 456
  body___1[100] = (char )'o';
#line 456
  body___1[101] = (char )'u';
#line 456
  body___1[102] = (char )'r';
#line 456
  body___1[103] = (char )' ';
#line 456
  body___1[104] = (char )'c';
#line 456
  body___1[105] = (char )'l';
#line 456
  body___1[106] = (char )'i';
#line 456
  body___1[107] = (char )'e';
#line 456
  body___1[108] = (char )'n';
#line 456
  body___1[109] = (char )'t';
#line 456
  body___1[110] = (char )' ';
#line 456
  body___1[111] = (char )'h';
#line 456
  body___1[112] = (char )'a';
#line 456
  body___1[113] = (char )'s';
#line 456
  body___1[114] = (char )' ';
#line 456
  body___1[115] = (char )'i';
#line 456
  body___1[116] = (char )'s';
#line 456
  body___1[117] = (char )'s';
#line 456
  body___1[118] = (char )'u';
#line 456
  body___1[119] = (char )'e';
#line 456
  body___1[120] = (char )'d';
#line 456
  body___1[121] = (char )' ';
#line 456
  body___1[122] = (char )'a';
#line 456
  body___1[123] = (char )' ';
#line 456
  body___1[124] = (char )'m';
#line 456
  body___1[125] = (char )'a';
#line 456
  body___1[126] = (char )'l';
#line 456
  body___1[127] = (char )'f';
#line 456
  body___1[128] = (char )'o';
#line 456
  body___1[129] = (char )'r';
#line 456
  body___1[130] = (char )'m';
#line 456
  body___1[131] = (char )'e';
#line 456
  body___1[132] = (char )'d';
#line 456
  body___1[133] = (char )' ';
#line 456
  body___1[134] = (char )'o';
#line 456
  body___1[135] = (char )'r';
#line 456
  body___1[136] = (char )' ';
#line 456
  body___1[137] = (char )'i';
#line 456
  body___1[138] = (char )'l';
#line 456
  body___1[139] = (char )'l';
#line 456
  body___1[140] = (char )'e';
#line 456
  body___1[141] = (char )'g';
#line 456
  body___1[142] = (char )'a';
#line 456
  body___1[143] = (char )'l';
#line 456
  body___1[144] = (char )' ';
#line 456
  body___1[145] = (char )'r';
#line 456
  body___1[146] = (char )'e';
#line 456
  body___1[147] = (char )'q';
#line 456
  body___1[148] = (char )'u';
#line 456
  body___1[149] = (char )'e';
#line 456
  body___1[150] = (char )'s';
#line 456
  body___1[151] = (char )'t';
#line 456
  body___1[152] = (char )'.';
#line 456
  body___1[153] = (char )'\n';
#line 456
  body___1[154] = (char )'<';
#line 456
  body___1[155] = (char )'/';
#line 456
  body___1[156] = (char )'B';
#line 456
  body___1[157] = (char )'O';
#line 456
  body___1[158] = (char )'D';
#line 456
  body___1[159] = (char )'Y';
#line 456
  body___1[160] = (char )'>';
#line 456
  body___1[161] = (char )'<';
#line 456
  body___1[162] = (char )'/';
#line 456
  body___1[163] = (char )'H';
#line 456
  body___1[164] = (char )'T';
#line 456
  body___1[165] = (char )'M';
#line 456
  body___1[166] = (char )'L';
#line 456
  body___1[167] = (char )'>';
#line 456
  body___1[168] = (char )'\n';
#line 456
  body___1[169] = (char )'\000';
#line 462
  req->response_status = (enum RESPONSE_CODE )414;
#line 463
  if ((unsigned int )req->http_version != 1U) {
    {
#line 464
    tmp = http_ver_string(req->http_version);
#line 464
    req_write(req, tmp);
#line 465
    req_write(req, " 414 Request URI Too Long\r\n");
#line 466
    print_http_headers(req);
#line 467
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n");
#line 468
    req_write(req, "Content-Length: ");
    }
#line 469
    if (! len) {
      {
#line 470
      tmp___0 = strlen((char const   *)(body___1));
#line 470
      len = (unsigned int )tmp___0;
      }
    }
    {
#line 471
    tmp___1 = simple_itoa((uint64_t )len);
#line 471
    req_write(req, (char const   *)tmp___1);
#line 472
    req_write(req, "\r\n\r\n");
    }
  }
#line 474
  if ((unsigned int )req->method != 2U) {
    {
#line 475
    req_write(req, (char const   *)(body___1));
    }
  }
  {
#line 476
  req_flush(req);
  }
#line 477
  return;
}
}
#line 482 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char body[101]  = 
#line 482
  {      (char )'<',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )'>',      (char )'<',      (char )'H', 
        (char )'E',      (char )'A',      (char )'D',      (char )'>', 
        (char )'<',      (char )'T',      (char )'I',      (char )'T', 
        (char )'L',      (char )'E',      (char )'>',      (char )'4', 
        (char )'1',      (char )'6',      (char )' ',      (char )'I', 
        (char )'n',      (char )'v',      (char )'a',      (char )'l', 
        (char )'i',      (char )'d',      (char )' ',      (char )'R', 
        (char )'a',      (char )'n',      (char )'g',      (char )'e', 
        (char )'<',      (char )'/',      (char )'T',      (char )'I', 
        (char )'T',      (char )'L',      (char )'E',      (char )'>', 
        (char )'<',      (char )'/',      (char )'H',      (char )'E', 
        (char )'A',      (char )'D',      (char )'>',      (char )'\n', 
        (char )'<',      (char )'B',      (char )'O',      (char )'D', 
        (char )'Y',      (char )'>',      (char )'<',      (char )'H', 
        (char )'1',      (char )'>',      (char )'4',      (char )'1', 
        (char )'6',      (char )' ',      (char )'I',      (char )'n', 
        (char )'v',      (char )'a',      (char )'l',      (char )'i', 
        (char )'d',      (char )' ',      (char )'R',      (char )'a', 
        (char )'n',      (char )'g',      (char )'e',      (char )'<', 
        (char )'/',      (char )'H',      (char )'1',      (char )'>', 
        (char )'\n',      (char )'<',      (char )'/',      (char )'B', 
        (char )'O',      (char )'D',      (char )'Y',      (char )'>', 
        (char )'<',      (char )'/',      (char )'H',      (char )'T', 
        (char )'M',      (char )'L',      (char )'>',      (char )'\n', 
        (char )'\000'};
#line 485 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static unsigned int body_len  =    0U;
#line 480 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_invalid_range(request *req ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 487
  req->keepalive = (enum KA_STATUS )2;
#line 488
  req->response_status = (enum RESPONSE_CODE )416;
#line 489
  if ((unsigned int )req->http_version != 1U) {
    {
#line 490
    tmp = http_ver_string(req->http_version);
#line 490
    req_write(req, tmp);
#line 491
    req_write(req, " 416 Invalid Range\r\n");
#line 492
    print_http_headers(req);
    }
#line 493
    if (! body_len) {
      {
#line 494
      tmp___0 = strlen((char const   *)(body));
#line 494
      body_len = (unsigned int )tmp___0;
      }
    }
    {
#line 495
    req_write(req, "Content-Length: ");
#line 496
    tmp___1 = simple_itoa((uint64_t )body_len);
#line 496
    req_write(req, (char const   *)tmp___1);
#line 497
    req_write(req, "\r\nContent-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 499
  if ((unsigned int )req->method != 2U) {
    {
#line 500
    req_write(req, (char const   *)(body));
    }
  }
  {
#line 502
  req_flush(req);
  }
#line 503
  return;
}
}
#line 506 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_error(request *req ) 
{ 
  char const   *tmp ;

  {
#line 508
  req->keepalive = (enum KA_STATUS )2;
#line 509
  req->response_status = (enum RESPONSE_CODE )500;
#line 510
  if ((unsigned int )req->http_version != 1U) {
    {
#line 511
    tmp = http_ver_string(req->http_version);
#line 511
    req_write(req, tmp);
#line 512
    req_write(req, " 500 Server Error\r\n");
#line 513
    print_http_headers(req);
#line 514
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 516
  if ((unsigned int )req->method != 2U) {
    {
#line 517
    req_write(req, "<HTML><HEAD><TITLE>500 Server Error</TITLE></HEAD>\n<BODY><H1>500 Server Error</H1>\nThe server encountered an internal error and could not complete your request.\n</BODY></HTML>\n");
    }
  }
  {
#line 523
  req_flush(req);
  }
#line 524
  return;
}
}
#line 527 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_not_implemented(request *req ) 
{ 
  char const   *tmp ;

  {
#line 529
  req->keepalive = (enum KA_STATUS )2;
#line 530
  req->response_status = (enum RESPONSE_CODE )501;
#line 531
  if ((unsigned int )req->http_version != 1U) {
    {
#line 532
    tmp = http_ver_string(req->http_version);
#line 532
    req_write(req, tmp);
#line 533
    req_write(req, " 501 Not Implemented\r\n");
#line 534
    print_http_headers(req);
#line 535
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
  {
#line 540
  req_write(req, "<HTML><HEAD><TITLE>501 Not Implemented</TITLE></HEAD>\n<BODY><H1>501 Not Implemented</H1>\nPOST to non-script is not supported in Boa.\n</BODY></HTML>\n");
#line 544
  req_flush(req);
  }
#line 545
  return;
}
}
#line 548 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_bad_gateway(request *req ) 
{ 
  char const   *tmp ;

  {
#line 550
  req->keepalive = (enum KA_STATUS )2;
#line 551
  req->response_status = (enum RESPONSE_CODE )502;
#line 552
  if ((unsigned int )req->http_version != 1U) {
    {
#line 553
    tmp = http_ver_string(req->http_version);
#line 553
    req_write(req, tmp);
#line 554
    req_write(req, " 502 Bad Gateway\r\n");
#line 555
    print_http_headers(req);
#line 556
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 558
  if ((unsigned int )req->method != 2U) {
    {
#line 559
    req_write(req, "<HTML><HEAD><TITLE>502 Bad Gateway</TITLE></HEAD>\n<BODY><H1>502 Bad Gateway</H1>\nThe CGI was not CGI/1.1 compliant.\n</BODY></HTML>\n");
    }
  }
  {
#line 564
  req_flush(req);
  }
#line 565
  return;
}
}
#line 570 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char body___0[186]  = 
#line 570
  {      (char )'<',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )'>',      (char )'<',      (char )'H', 
        (char )'E',      (char )'A',      (char )'D',      (char )'>', 
        (char )'<',      (char )'T',      (char )'I',      (char )'T', 
        (char )'L',      (char )'E',      (char )'>',      (char )'5', 
        (char )'0',      (char )'3',      (char )' ',      (char )'S', 
        (char )'e',      (char )'r',      (char )'v',      (char )'i', 
        (char )'c',      (char )'e',      (char )' ',      (char )'U', 
        (char )'n',      (char )'a',      (char )'v',      (char )'a', 
        (char )'i',      (char )'l',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'<',      (char )'/', 
        (char )'T',      (char )'I',      (char )'T',      (char )'L', 
        (char )'E',      (char )'>',      (char )'<',      (char )'/', 
        (char )'H',      (char )'E',      (char )'A',      (char )'D', 
        (char )'>',      (char )'\n',      (char )'<',      (char )'B', 
        (char )'O',      (char )'D',      (char )'Y',      (char )'>', 
        (char )'<',      (char )'H',      (char )'1',      (char )'>', 
        (char )'5',      (char )'0',      (char )'3',      (char )' ', 
        (char )'S',      (char )'e',      (char )'r',      (char )'v', 
        (char )'i',      (char )'c',      (char )'e',      (char )' ', 
        (char )'U',      (char )'n',      (char )'a',      (char )'v', 
        (char )'a',      (char )'i',      (char )'l',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'<', 
        (char )'/',      (char )'H',      (char )'1',      (char )'>', 
        (char )'\n',      (char )'T',      (char )'h',      (char )'e', 
        (char )'r',      (char )'e',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'t', 
        (char )'o',      (char )'o',      (char )' ',      (char )'m', 
        (char )'a',      (char )'n',      (char )'y',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'n', 
        (char )'e',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )' ', 
        (char )'i',      (char )'n',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )' ',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )' ',      (char )'n',      (char )'o',      (char )'w', 
        (char )'.',      (char )'\n',      (char )'P',      (char )'l', 
        (char )'e',      (char )'a',      (char )'s',      (char )'e', 
        (char )' ',      (char )'t',      (char )'r',      (char )'y', 
        (char )' ',      (char )'a',      (char )'g',      (char )'a', 
        (char )'i',      (char )'n',      (char )' ',      (char )'l', 
        (char )'a',      (char )'t',      (char )'e',      (char )'r', 
        (char )'.',      (char )'\n',      (char )'<',      (char )'/', 
        (char )'B',      (char )'O',      (char )'D',      (char )'Y', 
        (char )'>',      (char )'<',      (char )'/',      (char )'H', 
        (char )'T',      (char )'M',      (char )'L',      (char )'>', 
        (char )'\n',      (char )'\000'};
#line 576 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static unsigned int _body_len  ;
#line 577 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
static char *body_len___0  ;
#line 568 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_service_unavailable(request *req ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 579
  if (! _body_len) {
    {
#line 580
    tmp = strlen((char const   *)(body___0));
#line 580
    _body_len = (unsigned int )tmp;
    }
  }
#line 581
  if (! body_len___0) {
    {
#line 582
    tmp___0 = simple_itoa((uint64_t )_body_len);
#line 582
    body_len___0 = strdup((char const   *)tmp___0);
    }
  }
#line 583
  if (! body_len___0) {
    {
#line 584
    log_error_time();
#line 585
    perror("strdup of _body_len from simple_itoa");
    }
  }
#line 589
  req->keepalive = (enum KA_STATUS )2;
#line 590
  req->response_status = (enum RESPONSE_CODE )503;
#line 591
  if ((unsigned int )req->http_version != 1U) {
    {
#line 592
    tmp___1 = http_ver_string(req->http_version);
#line 592
    req_write(req, tmp___1);
#line 593
    req_write(req, " 503 Service Unavailable\r\n");
#line 594
    print_http_headers(req);
    }
#line 595
    if (body_len___0) {
      {
#line 596
      req_write(req, "Content-Length: ");
#line 597
      req_write(req, (char const   *)body_len___0);
#line 598
      req_write(req, "\r\n");
      }
    }
    {
#line 600
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 602
  if ((unsigned int )req->method != 2U) {
    {
#line 603
    req_write(req, (char const   *)(body___0));
    }
  }
  {
#line 605
  req_flush(req);
  }
#line 606
  return;
}
}
#line 610 "/home/june/collector/temp/boa-0.94.14rc21/src/response.c"
void send_r_bad_version(request *req , char const   *version ) 
{ 
  char const   *tmp ;

  {
#line 612
  req->keepalive = (enum KA_STATUS )2;
#line 613
  req->response_status = (enum RESPONSE_CODE )505;
#line 614
  if ((unsigned int )req->http_version != 1U) {
    {
#line 615
    tmp = http_ver_string(req->http_version);
#line 615
    req_write(req, tmp);
#line 616
    req_write(req, " 505 HTTP Version Not Supported\r\n");
#line 617
    print_http_headers(req);
#line 618
    req_write(req, "Content-Type: text/html; charset=ISO-8859-1\r\n\r\n");
    }
  }
#line 620
  if ((unsigned int )req->method != 2U) {
    {
#line 621
    req_write(req, "<HTML><HEAD><TITLE>505 HTTP Version Not Supported</TITLE></HEAD>\n<BODY><H1>505 HTTP Version Not Supported</H1>\nHTTP versions other than 0.9 and 1.0 are not supported in Boa.\n<p><p>Version encountered: ");
#line 626
    req_write(req, version);
#line 627
    req_write(req, "<p><p></BODY></HTML>\n");
    }
  }
  {
#line 629
  req_flush(req);
  }
#line 630
  return;
}
}
#line 72 "/home/june/collector/temp/boa-0.94.14rc21/src/boa.h"
unsigned int get_mime_hash_value(char const   *extension ) ;
#line 53 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static hash_struct *mime_hashtable[47]  ;
#line 54 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static hash_struct *passwd_hashtable[47]  ;
#line 56
static unsigned int get_homedir_hash_value(char const   *name ) ;
#line 70
static unsigned int fnv1a_hash(char const   *str ) ;
#line 76 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static unsigned int boa_hash(char const   *str ) 
{ 
  unsigned int tmp ;

  {
#line 78
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 79
    log_error_time();
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash NULL or empty string! [boa_hash]!\n");
    }
#line 82
    return (0U);
  } else
#line 78
  if ((int const   )*(str + 0) == 0) {
    {
#line 79
    log_error_time();
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash NULL or empty string! [boa_hash]!\n");
    }
#line 82
    return (0U);
  }
  {
#line 84
  tmp = fnv1a_hash(str);
  }
#line 84
  return (tmp);
}
}
#line 163 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static unsigned int fnv1a_hash(char const   *str ) 
{ 
  unsigned int hash ;
  short count ;
  char const   *tmp ;
  short tmp___0 ;

  {
#line 165
  hash = 2166136261U;
#line 166
  count = (short)4;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    tmp = str;
#line 172
    str ++;
#line 172
    hash ^= (unsigned int )*tmp;
#line 173
    hash *= 16777619U;
#line 171
    if ((int const   )*str != 0) {
#line 171
      tmp___0 = count;
#line 171
      count = (short )((int )count - 1);
#line 171
      if (! tmp___0) {
#line 171
        goto while_break;
      }
    } else {
#line 171
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (hash);
}
}
#line 188 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static hash_struct *hash_insert(hash_struct **table , unsigned int const   hash ,
                                char const   *key , char const   *value ) 
{ 
  hash_struct *current ;
  hash_struct *trailer ;
  int tmp ;
  void *tmp___0 ;
  int errno_save ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 194
  if (! key) {
    {
#line 195
    log_error_time();
#line 196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Yipes! Null value sent as key! [hash_insert]!\n");
    }
#line 197
    return ((hash_struct *)((void *)0));
  } else
#line 198
  if ((int const   )*(key + 0) == 0) {
    {
#line 199
    log_error_time();
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash NULL or empty key! [hash_insert]!\n");
    }
#line 202
    return ((hash_struct *)((void *)0));
  }
#line 205
  if (! value) {
    {
#line 206
    log_error_time();
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Yipes! Null value sent as value! [hash_insert]!\n");
    }
#line 208
    return ((hash_struct *)((void *)0));
  } else
#line 209
  if ((int const   )*(value + 0) == 0) {
    {
#line 210
    log_error_time();
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash NULL or empty value! [hash_insert]!\n");
    }
#line 213
    return ((hash_struct *)((void *)0));
  }
#line 218
  if (debug_level & (1 << 13)) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Adding key \"%s\" for value \"%s\" (hash=%u)\n",
            key, value, hash);
    }
  }
#line 224
  current = *(table + hash);
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! current) {
#line 225
      goto while_break;
    }
    {
#line 226
    tmp = strcmp((char const   *)current->key, key);
    }
#line 226
    if (! tmp) {
#line 227
      return (current);
    }
#line 228
    if (current->next) {
#line 229
      current = current->next;
    } else {
#line 231
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp___0 = malloc(sizeof(hash_struct ));
#line 235
  trailer = (hash_struct *)tmp___0;
  }
#line 236
  if ((unsigned long )trailer == (unsigned long )((void *)0)) {
    {
#line 237
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/hash.c", 237, "hash_insert",
                   "unable to allocate memory for hash_insert");
    }
#line 238
    return ((hash_struct *)((void *)0));
  }
  {
#line 241
  trailer->key = strdup(key);
#line 242
  trailer->value = strdup(value);
#line 243
  trailer->next = (struct _hash_struct_ *)((void *)0);
  }
#line 245
  if ((unsigned long )trailer->key == (unsigned long )((void *)0)) {
#line 245
    goto _L;
  } else
#line 245
  if ((unsigned long )trailer->value == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 246
    tmp___1 = __errno_location();
#line 246
    errno_save = *tmp___1;
    }
#line 248
    if (trailer->key) {
      {
#line 249
      free((void *)trailer->key);
      }
    }
#line 250
    if (trailer->value) {
      {
#line 251
      free((void *)trailer->value);
      }
    }
    {
#line 252
    free((void *)trailer);
#line 253
    trailer = (hash_struct *)((void *)0);
#line 254
    tmp___2 = __errno_location();
#line 254
    *tmp___2 = errno_save;
#line 255
    log_error_mesg("/home/june/collector/temp/boa-0.94.14rc21/src/hash.c", 255, "hash_insert",
                   "allocated key or value is NULL");
    }
#line 256
    return ((hash_struct *)((void *)0));
  }
#line 260
  if (! current) {
#line 262
    *(table + hash) = trailer;
  } else {
#line 264
    current->next = trailer;
  }
#line 267
  return (trailer);
}
}
#line 270 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static hash_struct *hash_find(hash_struct **table , char const   *key , unsigned int const   hash ) 
{ 
  hash_struct *current ;
  int tmp ;

  {
#line 276
  current = *(table + hash);
#line 278
  if (! key) {
    {
#line 279
    log_error_time();
#line 280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Yipes! Null value sent as key! [hash_find]!\n");
    }
#line 281
    return ((hash_struct *)((void *)0));
  } else
#line 282
  if ((int const   )*(key + 0) == 0) {
    {
#line 283
    log_error_time();
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to locate empty string in hash! [hash_find]!\n");
    }
#line 286
    return ((hash_struct *)((void *)0));
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! current) {
#line 289
      goto while_break;
    }
    {
#line 290
    tmp = strcmp((char const   *)current->key, key);
    }
#line 290
    if (! tmp) {
#line 291
      return (current);
    }
#line 292
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return ((hash_struct *)((void *)0));
}
}
#line 298 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static void hash_clear(hash_struct **table , int size ) 
{ 
  int i ;
  hash_struct *temp ;
  hash_struct *temp_next ;

  {
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < size)) {
#line 303
      goto while_break;
    }
#line 304
    temp = *(table + i);
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      if (! temp) {
#line 305
        goto while_break___0;
      }
      {
#line 308
      temp_next = temp->next;
#line 309
      free((void *)temp->key);
#line 310
      free((void *)temp->value);
#line 311
      free((void *)temp);
#line 313
      temp = temp_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    *(table + i) = (hash_struct *)((void *)0);
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 319 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
void hash_show_stats(void) 
{ 
  int i ;
  hash_struct *temp ;
  int total ;
  int count ;

  {
#line 323
  total = 0;
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < 47)) {
#line 326
      goto while_break;
    }
#line 327
    if (mime_hashtable[i]) {
#line 328
      count = 0;
#line 329
      temp = mime_hashtable[i];
      {
#line 330
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 330
        if (! temp) {
#line 330
          goto while_break___0;
        }
#line 331
        temp = temp->next;
#line 332
        count ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 339
      total += count;
    }
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  log_error_time();
#line 343
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mime_hashtable has %d total entries\n",
          total);
#line 345
  total = 0;
#line 346
  i = 0;
  }
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 346
    if (! (i < 47)) {
#line 346
      goto while_break___1;
    }
#line 347
    if (passwd_hashtable[i]) {
#line 348
      temp = passwd_hashtable[i];
#line 349
      count = 0;
      {
#line 350
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 350
        if (! temp) {
#line 350
          goto while_break___2;
        }
#line 351
        temp = temp->next;
#line 352
        count ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 359
      total += count;
    }
#line 346
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 363
  log_error_time();
#line 364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"passwd_hashtable has %d total entries\n",
          total);
  }
#line 366
  return;
}
}
#line 380 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
void add_mime_type(char const   *extension , char const   *type ) 
{ 
  unsigned int hash ;
  hash_struct *tmp ;

  {
  {
#line 384
  hash = get_mime_hash_value(extension);
#line 385
  tmp = hash_insert(mime_hashtable, (unsigned int const   )hash, extension, type);
  }
#line 385
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 386
    log_error_mesg_fatal("/home/june/collector/temp/boa-0.94.14rc21/src/hash.c", 386,
                         "add_mime_type", "Failed to hash_insert mime type.");
    }
  }
#line 387
  return;
}
}
#line 396 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
unsigned int get_mime_hash_value(char const   *extension ) 
{ 
  unsigned int tmp ;

  {
  {
#line 398
  tmp = boa_hash(extension);
  }
#line 398
  return (tmp % 47U);
}
}
#line 408 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
char *get_mime_type(char const   *filename ) 
{ 
  char *extension ;
  hash_struct *current ;
  unsigned int hash ;
  char *tmp ;

  {
#line 415
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 416
    log_error_time();
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash NULL string! [get_mime_type]\n");
    }
#line 419
    return (default_type);
  } else
#line 420
  if ((int const   )*(filename + 0) == 0) {
    {
#line 421
    log_error_time();
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to hash empty string! [get_mime_type]\n");
    }
#line 424
    return (default_type);
  }
  {
#line 427
  extension = strrchr(filename, '.');
  }
#line 435
  if (! extension) {
#line 436
    return (default_type);
  } else
#line 435
  if ((int )*(extension + 1) == 0) {
#line 436
    return (default_type);
  }
  {
#line 439
  extension ++;
#line 441
  hash = get_mime_hash_value((char const   *)extension);
#line 442
  current = hash_find(mime_hashtable, (char const   *)extension, (unsigned int const   )hash);
  }
#line 443
  if (current) {
#line 443
    tmp = current->value;
  } else {
#line 443
    tmp = default_type;
  }
#line 443
  return (tmp);
}
}
#line 453 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
static unsigned int get_homedir_hash_value(char const   *name ) 
{ 
  unsigned int tmp ;

  {
  {
#line 455
  tmp = boa_hash(name);
  }
#line 455
  return (tmp % 47U);
}
}
#line 467 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
char *get_home_dir(char const   *name ) 
{ 
  hash_struct *current ;
  unsigned int hash ;
  struct passwd *passwdbuf ;
  char *tmp ;

  {
  {
#line 473
  hash = get_homedir_hash_value(name);
#line 475
  current = hash_find(passwd_hashtable, name, (unsigned int const   )hash);
  }
#line 477
  if (! current) {
    {
#line 481
    passwdbuf = getpwnam(name);
    }
#line 483
    if (! passwdbuf) {
#line 484
      return ((char *)((void *)0));
    }
    {
#line 486
    current = hash_insert(passwd_hashtable, (unsigned int const   )hash, name, (char const   *)passwdbuf->pw_dir);
    }
  }
#line 490
  if (current) {
#line 490
    tmp = current->value;
  } else {
#line 490
    tmp = (char *)((void *)0);
  }
#line 490
  return (tmp);
}
}
#line 493 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
void dump_mime(void) 
{ 


  {
  {
#line 495
  hash_clear(mime_hashtable, 47);
  }
#line 496
  return;
}
}
#line 498 "/home/june/collector/temp/boa-0.94.14rc21/src/hash.c"
void dump_passwd(void) 
{ 


  {
  {
#line 500
  hash_clear(passwd_hashtable, 47);
  }
#line 501
  return;
}
}
#line 261 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 262 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) )  __asm__("scandir64")  ;
#line 329
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __asm__("alphasort64") __attribute__((__pure__)) ;
#line 41 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
char *html_escape_string(char const   *inp , char *dest , unsigned int const   len___0 ) ;
#line 43
char *http_escape_string(char const   *inp , char *buf___0 , unsigned int const   len___0 ) ;
#line 46
int select_files(struct dirent  const  *dirbuf ) ;
#line 47
int index_directory(char *dir , char *title ) ;
#line 48
void send_error(int error ) ;
#line 53 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
char *html_escape_string(char const   *inp , char *dest , unsigned int const   len___0 ) 
{ 
  int max ;
  char *buf___0 ;
  unsigned char c ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;

  {
#line 60
  max = (int )(len___0 * 6U);
#line 62
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 62
    if (max) {
      {
#line 63
      tmp = malloc(sizeof(unsigned char ) * (unsigned long )(max + 1));
#line 63
      dest = (char *)tmp;
      }
    }
  }
#line 65
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 66
    return ((char *)((void *)0));
  }
#line 68
  buf___0 = dest;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    tmp___20 = inp;
#line 69
    inp ++;
#line 69
    c = (unsigned char )*tmp___20;
#line 69
    if (! c) {
#line 69
      goto while_break;
    }
    {
#line 71
    if ((int )c == 62) {
#line 71
      goto case_62;
    }
#line 77
    if ((int )c == 60) {
#line 77
      goto case_60;
    }
#line 83
    if ((int )c == 38) {
#line 83
      goto case_38;
    }
#line 90
    if ((int )c == 34) {
#line 90
      goto case_34;
    }
#line 98
    goto switch_default;
    case_62: /* CIL Label */ 
#line 72
    tmp___0 = dest;
#line 72
    dest ++;
#line 72
    *tmp___0 = (char )'&';
#line 73
    tmp___1 = dest;
#line 73
    dest ++;
#line 73
    *tmp___1 = (char )'g';
#line 74
    tmp___2 = dest;
#line 74
    dest ++;
#line 74
    *tmp___2 = (char )'t';
#line 75
    tmp___3 = dest;
#line 75
    dest ++;
#line 75
    *tmp___3 = (char )';';
#line 76
    goto switch_break;
    case_60: /* CIL Label */ 
#line 78
    tmp___4 = dest;
#line 78
    dest ++;
#line 78
    *tmp___4 = (char )'&';
#line 79
    tmp___5 = dest;
#line 79
    dest ++;
#line 79
    *tmp___5 = (char )'l';
#line 80
    tmp___6 = dest;
#line 80
    dest ++;
#line 80
    *tmp___6 = (char )'t';
#line 81
    tmp___7 = dest;
#line 81
    dest ++;
#line 81
    *tmp___7 = (char )';';
#line 82
    goto switch_break;
    case_38: /* CIL Label */ 
#line 84
    tmp___8 = dest;
#line 84
    dest ++;
#line 84
    *tmp___8 = (char )'&';
#line 85
    tmp___9 = dest;
#line 85
    dest ++;
#line 85
    *tmp___9 = (char )'a';
#line 86
    tmp___10 = dest;
#line 86
    dest ++;
#line 86
    *tmp___10 = (char )'m';
#line 87
    tmp___11 = dest;
#line 87
    dest ++;
#line 87
    *tmp___11 = (char )'p';
#line 88
    tmp___12 = dest;
#line 88
    dest ++;
#line 88
    *tmp___12 = (char )';';
#line 89
    goto switch_break;
    case_34: /* CIL Label */ 
#line 91
    tmp___13 = dest;
#line 91
    dest ++;
#line 91
    *tmp___13 = (char )'&';
#line 92
    tmp___14 = dest;
#line 92
    dest ++;
#line 92
    *tmp___14 = (char )'q';
#line 93
    tmp___15 = dest;
#line 93
    dest ++;
#line 93
    *tmp___15 = (char )'u';
#line 94
    tmp___16 = dest;
#line 94
    dest ++;
#line 94
    *tmp___16 = (char )'o';
#line 95
    tmp___17 = dest;
#line 95
    dest ++;
#line 95
    *tmp___17 = (char )'t';
#line 96
    tmp___18 = dest;
#line 96
    dest ++;
#line 96
    *tmp___18 = (char )';';
#line 97
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 99
    tmp___19 = dest;
#line 99
    dest ++;
#line 99
    *tmp___19 = (char )c;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *dest = (char )'\000';
#line 103
  return (buf___0);
}
}
#line 119 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
char *http_escape_string(char const   *inp , char *buf___0 , unsigned int const   len___0 ) 
{ 
  int max ;
  char *index_c ;
  unsigned char c ;
  int found_a_colon ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 125
  found_a_colon = 0;
#line 127
  max = (int )(len___0 * 3U);
#line 129
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 129
    if (max) {
      {
#line 130
      tmp = malloc(sizeof(unsigned char ) * (unsigned long )(max + 1));
#line 130
      buf___0 = (char *)tmp;
      }
    }
  }
#line 132
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 133
    return ((char *)((void *)0));
  }
#line 135
  index_c = buf___0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp___5 = inp;
#line 136
    inp ++;
#line 136
    c = (unsigned char )*tmp___5;
#line 136
    if (! c) {
#line 136
      goto while_break;
    }
#line 137
    if ((int )c == 58) {
#line 137
      if (! found_a_colon) {
#line 137
        if ((unsigned long )index_c > (unsigned long )buf___0) {
          {
#line 138
          found_a_colon = 1;
#line 139
          memmove((void *)(buf___0 + 2), (void const   *)buf___0, (size_t )(index_c - buf___0));
#line 140
          *buf___0 = (char )'.';
#line 141
          *(buf___0 + 1) = (char )'/';
#line 142
          index_c += 2;
#line 143
          tmp___0 = index_c;
#line 143
          index_c ++;
#line 143
          *tmp___0 = (char )':';
          }
        } else {
#line 137
          goto _L___1;
        }
      } else {
#line 137
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 144
    if ((unsigned int )c >= 128U) {
#line 144
      goto _L;
    } else
#line 144
    if (_needs_escape[(unsigned int )c >> 5] & (unsigned long )(1 << ((unsigned int )c & (unsigned int )((1 << 5) - 1)))) {
#line 144
      goto _L;
    } else
#line 144
    if ((int )c == 63) {
      _L: /* CIL Label */ 
#line 145
      tmp___1 = index_c;
#line 145
      index_c ++;
#line 145
      *tmp___1 = (char )'%';
#line 146
      tmp___2 = index_c;
#line 146
      index_c ++;
#line 146
      if ((((int )c >> 4) & 15) - 10 >= 0) {
#line 146
        *tmp___2 = (char )(65 + ((((int )c >> 4) & 15) - 10));
      } else {
#line 146
        *tmp___2 = (char )(48 + (((int )c >> 4) & 15));
      }
#line 147
      tmp___3 = index_c;
#line 147
      index_c ++;
#line 147
      if (((int )c & 15) - 10 >= 0) {
#line 147
        *tmp___3 = (char )(65 + (((int )c & 15) - 10));
      } else {
#line 147
        *tmp___3 = (char )(48 + ((int )c & 15));
      }
    } else {
#line 149
      tmp___4 = index_c;
#line 149
      index_c ++;
#line 149
      *tmp___4 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  *index_c = (char )'\000';
#line 153
  return (buf___0);
}
}
#line 156 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
void send_error(int error ) 
{ 
  char const   *the_error ;

  {
  {
#line 162
  if (error == 1) {
#line 162
    goto case_1;
  }
#line 165
  if (error == 2) {
#line 165
    goto case_2;
  }
#line 168
  if (error == 3) {
#line 168
    goto case_3;
  }
#line 172
  if (error == 4) {
#line 172
    goto case_4;
  }
#line 174
  if (error == 5) {
#line 174
    goto case_5;
  }
#line 177
  if (error == 6) {
#line 177
    goto case_6;
  }
#line 180
  goto switch_default;
  case_1: /* CIL Label */ 
#line 163
  the_error = "Not enough arguments were passed to the indexer.";
#line 164
  goto switch_break;
  case_2: /* CIL Label */ 
#line 166
  the_error = "The Directory Sorter ran out of Memory";
#line 167
  goto switch_break;
  case_3: /* CIL Label */ 
#line 169
  the_error = "The was a problem changing to the appropriate directory.";
#line 171
  goto switch_break;
  case_4: /* CIL Label */ 
#line 173
  the_error = "There was an error escaping a string.";
  case_5: /* CIL Label */ 
#line 175
  the_error = "Too many arguments were passed to the indexer.";
#line 176
  goto switch_break;
  case_6: /* CIL Label */ 
#line 178
  the_error = "No files in this directory.";
#line 179
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 181
  the_error = "An unknown error occurred producing the directory.";
#line 182
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 184
  printf((char const   */* __restrict  */)"<html>\n<head>\n<title>\n%s\n</title>\n<body>\n%s\n</body>\n</html>\n",
         the_error, the_error);
  }
#line 186
  return;
}
}
#line 188 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
int select_files(struct dirent  const  *dirbuf ) 
{ 


  {
#line 190
  if ((int )dirbuf->d_name[0] == 46) {
#line 191
    return (0);
  } else {
#line 193
    return (1);
  }
}
}
#line 204 "/home/june/collector/temp/boa-0.94.14rc21/src/index_dir.c"
int index_directory(char *dir , char *title ) 
{ 
  struct dirent *dirbuf ;
  int numdir ;
  struct dirent **array ;
  struct stat statbuf ;
  char http_filename[765] ;
  char html_filename[1530] ;
  char escaped_filename[4590] ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int len___0 ;
  int tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;

  {
  {
#line 215
  tmp = chdir((char const   *)dir);
  }
#line 215
  if (tmp == -1) {
    {
#line 216
    send_error(3);
    }
#line 217
    return (-1);
  }
  {
#line 219
  numdir = scandir((char const   */* __restrict  */)".", (struct dirent ***/* __restrict  */)(& array),
                   & select_files, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))(& alphasort));
  }
#line 220
  if (numdir == -1) {
    {
#line 221
    send_error(2);
    }
#line 222
    return (-1);
  } else
#line 223
  if (numdir == -2) {
    {
#line 224
    send_error(6);
    }
#line 225
    return (-1);
  }
  {
#line 228
  tmp___0 = strlen((char const   *)title);
#line 228
  tmp___1 = html_escape_string((char const   *)title, html_filename, (unsigned int const   )tmp___0);
  }
#line 228
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 229
    send_error(4);
    }
#line 230
    return (-1);
  }
  {
#line 233
  tmp___4 = strcmp((char const   *)title, "/");
  }
#line 233
  if (tmp___4 == 0) {
#line 233
    tmp___3 = "";
  } else {
#line 233
    tmp___3 = "<tr><td colspan=3><h3>Directories</h3></td></tr><tr><td colspan=3><a href=\"../\">Parent Directory</a></td></tr>\n";
  }
  {
#line 233
  printf((char const   */* __restrict  */)"<html>\n<head>\n<title>Index of %s</title>\n</head>\n\n<body bgcolor=\"#ffffff\">\n<H2>Index of %s</H2>\n<table>\n%s",
         html_filename, html_filename, tmp___3);
#line 243
  i = 0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < numdir)) {
#line 243
      goto while_break;
    }
    {
#line 244
    dirbuf = *(array + i);
#line 246
    tmp___5 = stat((char const   */* __restrict  */)(dirbuf->d_name), (struct stat */* __restrict  */)(& statbuf));
    }
#line 246
    if (tmp___5 == -1) {
#line 247
      goto __Cont;
    }
#line 249
    if (! ((statbuf.st_mode & 61440U) == 16384U)) {
#line 250
      goto __Cont;
    }
    {
#line 252
    tmp___6 = strlen((char const   *)(dirbuf->d_name));
#line 252
    tmp___7 = html_escape_string((char const   *)(dirbuf->d_name), html_filename,
                                 (unsigned int const   )tmp___6);
    }
#line 252
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 254
      send_error(4);
      }
#line 255
      return (-1);
    }
    {
#line 257
    tmp___8 = strlen((char const   *)(dirbuf->d_name));
#line 257
    tmp___9 = http_escape_string((char const   *)(dirbuf->d_name), http_filename,
                                 (unsigned int const   )tmp___8);
    }
#line 257
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 259
      send_error(4);
      }
#line 260
      return (-1);
    }
    {
#line 262
    tmp___10 = strlen((char const   *)(http_filename));
#line 262
    tmp___11 = html_escape_string((char const   *)(http_filename), escaped_filename,
                                  (unsigned int const   )tmp___10);
    }
#line 262
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      {
#line 264
      send_error(4);
      }
#line 265
      return (-1);
    }
    {
#line 267
    tmp___12 = ctime((time_t const   *)(& statbuf.st_mtim.tv_sec));
#line 267
    printf((char const   */* __restrict  */)"<tr><td width=\"40%%\"><a href=\"%s/\">%s/</a></td><td align=right>%s</td><td align=right>%ld bytes</td></tr>\n",
           escaped_filename, html_filename, tmp___12, statbuf.st_size);
    }
    __Cont: /* CIL Label */ 
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  printf((char const   */* __restrict  */)"<tr><td colspan=3>&nbsp;</td></tr>\n<tr><td colspan=3><h3>Files</h3></td></tr>\n");
#line 281
  i = 0;
  }
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < numdir)) {
#line 281
      goto while_break___0;
    }
    {
#line 283
    dirbuf = *(array + i);
#line 285
    tmp___13 = stat((char const   */* __restrict  */)(dirbuf->d_name), (struct stat */* __restrict  */)(& statbuf));
    }
#line 285
    if (tmp___13 == -1) {
#line 286
      goto __Cont___0;
    }
#line 289
    if ((statbuf.st_mode & 61440U) == 16384U) {
#line 290
      goto __Cont___0;
    }
    {
#line 292
    tmp___14 = strlen((char const   *)(dirbuf->d_name));
#line 292
    tmp___15 = html_escape_string((char const   *)(dirbuf->d_name), html_filename,
                                  (unsigned int const   )tmp___14);
    }
#line 292
    if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
      {
#line 294
      send_error(4);
      }
#line 295
      return (-1);
    }
    {
#line 297
    tmp___16 = strlen((char const   *)(dirbuf->d_name));
#line 297
    tmp___17 = http_escape_string((char const   *)(dirbuf->d_name), http_filename,
                                  (unsigned int const   )tmp___16);
    }
#line 297
    if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
      {
#line 299
      send_error(4);
      }
#line 300
      return (-1);
    }
    {
#line 303
    tmp___18 = strlen((char const   *)(http_filename));
#line 303
    len___0 = (int )tmp___18;
    }
#line 305
    if (len___0 > 3) {
      {
#line 305
      tmp___26 = memcmp((void const   *)((http_filename + len___0) - 3), (void const   *)".gz",
                        (size_t )3);
      }
#line 305
      if (tmp___26) {
#line 305
        goto _L;
      } else {
        {
#line 306
        http_filename[len___0 - 3] = (char )'\000';
#line 307
        tmp___19 = strlen((char const   *)(html_filename));
#line 307
        html_filename[tmp___19 - 3UL] = (char )'\000';
#line 308
        tmp___20 = strlen((char const   *)(http_filename));
#line 308
        tmp___21 = html_escape_string((char const   *)(http_filename), escaped_filename,
                                      (unsigned int const   )tmp___20);
        }
#line 308
        if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
          {
#line 310
          send_error(4);
          }
#line 311
          return (-1);
        }
        {
#line 314
        tmp___22 = ctime((time_t const   *)(& statbuf.st_mtim.tv_sec));
#line 314
        printf((char const   */* __restrict  */)"<tr><td width=\"40%%\"><a href=\"%s\">%s</a> <a href=\"%s.gz\">(.gz)</a></td><td align=right>%s</td><td align=right>%ldbytes</td></tr>\n",
               escaped_filename, html_filename, http_filename, tmp___22, statbuf.st_size);
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 326
      tmp___23 = strlen((char const   *)(http_filename));
#line 326
      tmp___24 = html_escape_string((char const   *)(http_filename), escaped_filename,
                                    (unsigned int const   )tmp___23);
      }
#line 326
      if ((unsigned long )tmp___24 == (unsigned long )((void *)0)) {
        {
#line 328
        send_error(4);
        }
#line 329
        return (-1);
      }
      {
#line 331
      tmp___25 = ctime((time_t const   *)(& statbuf.st_mtim.tv_sec));
#line 331
      printf((char const   */* __restrict  */)"<tr><td width=\"40%%\"><a href=\"%s\">%s</a></td><td align=right>%s</td><td align=right>%ldbytes</td></tr>\n",
             escaped_filename, html_filename, tmp___25, statbuf.st_size);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  i = 0;
  {
#line 348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    if (! (i < numdir)) {
#line 348
      goto while_break___1;
    }
    {
#line 349
    free((void *)*(array + i));
#line 350
    *(array + i) = (struct dirent *)((void *)0);
#line 348
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 352
  free((void *)array);
#line 353
  array = (struct dirent **)((void *)0);
  }
#line 355
  return (0);
}
}
