/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 22 "/usr/include/linux/input.h"
struct input_event {
   struct timeval time ;
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 73 "/home/june/collector/temp/beep-1.3/beep.c"
struct beep_parms_t {
   float freq ;
   int length ;
   int reps ;
   int delay ;
   int end_delay ;
   int stdin_beep ;
   int verbose ;
   struct beep_parms_t *next ;
};
#line 73 "/home/june/collector/temp/beep-1.3/beep.c"
typedef struct beep_parms_t beep_parms_t;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 52 "/home/june/collector/temp/beep-1.3/beep.c"
char *copyright  =    (char *)"Copyright (C) Johnathan Nightingale, 2002.  Use and Distribution subject to GPL.  For information: http://www.gnu.org/copyleft/.";
#line 95 "/home/june/collector/temp/beep-1.3/beep.c"
int console_fd  =    -1;
#line 96 "/home/june/collector/temp/beep-1.3/beep.c"
int console_type  =    0;
#line 97 "/home/june/collector/temp/beep-1.3/beep.c"
char *console_device  =    (char *)((void *)0);
#line 100 "/home/june/collector/temp/beep-1.3/beep.c"
void do_beep(int freq ) 
{ 
  int tmp ;
  int tmp___0 ;
  struct input_event e ;

  {
#line 101
  if (console_type == 0) {
#line 102
    if (freq != 0) {
#line 102
      tmp = 1193180 / freq;
    } else {
#line 102
      tmp = freq;
    }
    {
#line 102
    tmp___0 = ioctl(console_fd, 19247UL, tmp);
    }
#line 102
    if (tmp___0 < 0) {
      {
#line 105
      printf((char const   */* __restrict  */)"\a");
#line 106
      perror("ioctl");
      }
    }
  } else {
    {
#line 112
    e.type = (__u16 )18;
#line 113
    e.code = (__u16 )2;
#line 114
    e.value = freq;
#line 116
    write(console_fd, (void const   *)(& e), sizeof(struct input_event ));
    }
  }
#line 118
  return;
}
}
#line 123 "/home/june/collector/temp/beep-1.3/beep.c"
void handle_signal(int signum ) 
{ 


  {
#line 125
  if (console_device) {
    {
#line 126
    free((void *)console_device);
    }
  }
  {
#line 129
  if (signum == 2) {
#line 129
    goto case_2;
  }
#line 128
  goto switch_break;
  case_2: /* CIL Label */ 
#line 130
  if (console_fd >= 0) {
    {
#line 132
    do_beep(0);
#line 133
    close(console_fd);
#line 134
    exit(signum);
    }
  } else {
    {
#line 137
    exit(signum);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 143 "/home/june/collector/temp/beep-1.3/beep.c"
void usage_bail(char const   *executable_name ) 
{ 


  {
  {
#line 144
  printf((char const   */* __restrict  */)"Usage:\n%s [-f freq] [-l length] [-r reps] [-d delay] [-D delay] [-s] [-c] [--verbose | --debug] [-e device]\n",
         executable_name);
#line 147
  printf((char const   */* __restrict  */)"%s [Options...] [-n] [--new] [Options...] ... \n",
         executable_name);
#line 148
  printf((char const   */* __restrict  */)"%s [-h] [--help]\n", executable_name);
#line 149
  printf((char const   */* __restrict  */)"%s [-v] [-V] [--version]\n", executable_name);
#line 150
  exit(1);
  }
}
}
#line 174 "/home/june/collector/temp/beep-1.3/beep.c"
void parse_command_line(int argc , char **argv , beep_parms_t *result ) 
{ 
  int c ;
  struct option opt_list[7] ;
  int argval ;
  float argfreq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 177
  opt_list[0].name = "help";
#line 177
  opt_list[0].has_arg = 0;
#line 177
  opt_list[0].flag = (int *)((void *)0);
#line 177
  opt_list[0].val = 'h';
#line 177
  opt_list[1].name = "version";
#line 177
  opt_list[1].has_arg = 0;
#line 177
  opt_list[1].flag = (int *)((void *)0);
#line 177
  opt_list[1].val = 'V';
#line 177
  opt_list[2].name = "new";
#line 177
  opt_list[2].has_arg = 0;
#line 177
  opt_list[2].flag = (int *)((void *)0);
#line 177
  opt_list[2].val = 'n';
#line 177
  opt_list[3].name = "verbose";
#line 177
  opt_list[3].has_arg = 0;
#line 177
  opt_list[3].flag = (int *)((void *)0);
#line 177
  opt_list[3].val = 'X';
#line 177
  opt_list[4].name = "debug";
#line 177
  opt_list[4].has_arg = 0;
#line 177
  opt_list[4].flag = (int *)((void *)0);
#line 177
  opt_list[4].val = 'X';
#line 177
  opt_list[5].name = "device";
#line 177
  opt_list[5].has_arg = 1;
#line 177
  opt_list[5].flag = (int *)((void *)0);
#line 177
  opt_list[5].val = 'e';
#line 177
  opt_list[6].name = (char const   *)0;
#line 177
  opt_list[6].has_arg = 0;
#line 177
  opt_list[6].flag = (int *)0;
#line 177
  opt_list[6].val = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    c = getopt_long(argc, (char * const  *)argv, "f:l:r:d:D:schvVne:", (struct option  const  *)(opt_list),
                    (int *)((void *)0));
    }
#line 184
    if (! (c != -1)) {
#line 184
      goto while_break;
    }
#line 186
    argval = -1;
#line 187
    argfreq = (float )-1;
    {
#line 189
    if (c == 102) {
#line 189
      goto case_102;
    }
#line 199
    if (c == 108) {
#line 199
      goto case_108;
    }
#line 205
    if (c == 114) {
#line 205
      goto case_114;
    }
#line 211
    if (c == 100) {
#line 211
      goto case_100;
    }
#line 219
    if (c == 68) {
#line 219
      goto case_68;
    }
#line 227
    if (c == 115) {
#line 227
      goto case_115;
    }
#line 230
    if (c == 99) {
#line 230
      goto case_99;
    }
#line 234
    if (c == 86) {
#line 234
      goto case_86;
    }
#line 234
    if (c == 118) {
#line 234
      goto case_86;
    }
#line 238
    if (c == 110) {
#line 238
      goto case_110;
    }
#line 252
    if (c == 88) {
#line 252
      goto case_88;
    }
#line 255
    if (c == 101) {
#line 255
      goto case_101;
    }
#line 259
    goto switch_default;
    case_102: /* CIL Label */ 
    {
#line 190
    tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%f",
                 & argfreq);
    }
#line 190
    if (tmp) {
#line 190
      if (argfreq >= (float )20000) {
        {
#line 192
        usage_bail((char const   *)*(argv + 0));
        }
      } else
#line 190
      if (argfreq <= (float )0) {
        {
#line 192
        usage_bail((char const   *)*(argv + 0));
        }
      } else
#line 194
      if (result->freq != (float )0) {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: multiple -f values given, only last one is used.\n");
        }
      }
    } else {
      {
#line 192
      usage_bail((char const   *)*(argv + 0));
      }
    }
#line 197
    result->freq = argfreq;
#line 198
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 200
    tmp___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                     & argval);
    }
#line 200
    if (tmp___0) {
#line 200
      if (argval < 0) {
        {
#line 201
        usage_bail((char const   *)*(argv + 0));
        }
      } else {
#line 203
        result->length = argval;
      }
    } else {
      {
#line 201
      usage_bail((char const   *)*(argv + 0));
      }
    }
#line 204
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 206
    tmp___1 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                     & argval);
    }
#line 206
    if (tmp___1) {
#line 206
      if (argval < 0) {
        {
#line 207
        usage_bail((char const   *)*(argv + 0));
        }
      } else {
#line 209
        result->reps = argval;
      }
    } else {
      {
#line 207
      usage_bail((char const   *)*(argv + 0));
      }
    }
#line 210
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 212
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                     & argval);
    }
#line 212
    if (tmp___2) {
#line 212
      if (argval < 0) {
        {
#line 213
        usage_bail((char const   *)*(argv + 0));
        }
      } else {
#line 215
        result->delay = argval;
#line 216
        result->end_delay = 0;
      }
    } else {
      {
#line 213
      usage_bail((char const   *)*(argv + 0));
      }
    }
#line 218
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 220
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d",
                     & argval);
    }
#line 220
    if (tmp___3) {
#line 220
      if (argval < 0) {
        {
#line 221
        usage_bail((char const   *)*(argv + 0));
        }
      } else {
#line 223
        result->delay = argval;
#line 224
        result->end_delay = 1;
      }
    } else {
      {
#line 221
      usage_bail((char const   *)*(argv + 0));
      }
    }
#line 226
    goto switch_break;
    case_115: /* CIL Label */ 
#line 228
    result->stdin_beep = 1;
#line 229
    goto switch_break;
    case_99: /* CIL Label */ 
#line 231
    result->stdin_beep = 2;
#line 232
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 235
    printf((char const   */* __restrict  */)"%s\n", "beep-1.3");
#line 236
    exit(0);
    }
#line 237
    goto switch_break;
    case_110: /* CIL Label */ 
#line 239
    if (result->freq == (float )0) {
#line 240
      result->freq = (float )440.0;
    }
    {
#line 241
    tmp___4 = malloc(sizeof(beep_parms_t ));
#line 241
    result->next = (beep_parms_t *)tmp___4;
#line 242
    (result->next)->freq = (float )0;
#line 243
    (result->next)->length = 200;
#line 244
    (result->next)->reps = 1;
#line 245
    (result->next)->delay = 100;
#line 246
    (result->next)->end_delay = 0;
#line 247
    (result->next)->stdin_beep = 0;
#line 248
    (result->next)->verbose = result->verbose;
#line 249
    (result->next)->next = (struct beep_parms_t *)((void *)0);
#line 250
    result = result->next;
    }
#line 251
    goto switch_break;
    case_88: /* CIL Label */ 
#line 253
    result->verbose = 1;
#line 254
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 256
    console_device = strdup((char const   *)optarg);
    }
#line 257
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 260
    usage_bail((char const   *)*(argv + 0));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (result->freq == (float )0) {
#line 264
    result->freq = (float )440.0;
  }
#line 265
  return;
}
}
#line 267 "/home/june/collector/temp/beep-1.3/beep.c"
void play_beep(beep_parms_t parms ) 
{ 
  int i ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 270
  if (parms.verbose == 1) {
    {
#line 271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[DEBUG] %d times %d ms beeps (%d delay between, %d delay after) @ %.2f Hz\n",
            parms.reps, parms.length, parms.delay, parms.end_delay, (double )parms.freq);
    }
  }
#line 276
  if (console_device) {
    {
#line 277
    console_fd = open((char const   *)console_device, 1);
    }
  } else {
    {
#line 279
    console_fd = open("/dev/tty0", 1);
    }
#line 279
    if (console_fd == -1) {
      {
#line 280
      console_fd = open("/dev/vc/0", 1);
      }
    }
  }
#line 282
  if (console_fd == -1) {
#line 283
    if ((unsigned long )console_device != (unsigned long )((void *)0)) {
#line 283
      tmp = (char const   *)console_device;
    } else {
#line 283
      tmp = "/dev/tty0 or /dev/vc/0";
    }
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open %s for writing\n",
            tmp);
#line 285
    printf((char const   */* __restrict  */)"\a");
#line 286
    perror("open");
#line 287
    exit(1);
    }
  }
  {
#line 290
  tmp___0 = ioctl(console_fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 26U));
  }
#line 290
  if (tmp___0 != -1) {
#line 291
    console_type = 1;
  } else {
#line 293
    console_type = 0;
  }
#line 296
  i = 0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < parms.reps)) {
#line 296
      goto while_break;
    }
    {
#line 297
    do_beep((int )parms.freq);
#line 299
    usleep((__useconds_t )(1000 * parms.length));
#line 300
    do_beep(0);
    }
#line 301
    if (parms.end_delay) {
      {
#line 302
      usleep((__useconds_t )(1000 * parms.delay));
      }
    } else
#line 301
    if (i + 1 < parms.reps) {
      {
#line 302
      usleep((__useconds_t )(1000 * parms.delay));
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  close(console_fd);
  }
#line 306
  return;
}
}
#line 310 "/home/june/collector/temp/beep-1.3/beep.c"
int main(int argc , char **argv ) 
{ 
  char sin[4096] ;
  char *ptr ;
  beep_parms_t *parms ;
  void *tmp ;
  beep_parms_t *next ;
  char *tmp___0 ;

  {
  {
#line 313
  tmp = malloc(sizeof(beep_parms_t ));
#line 313
  parms = (beep_parms_t *)tmp;
#line 314
  parms->freq = (float )0;
#line 315
  parms->length = 200;
#line 316
  parms->reps = 1;
#line 317
  parms->delay = 100;
#line 318
  parms->end_delay = 0;
#line 319
  parms->stdin_beep = 0;
#line 320
  parms->verbose = 0;
#line 321
  parms->next = (struct beep_parms_t *)((void *)0);
#line 323
  signal(2, & handle_signal);
#line 324
  parse_command_line(argc, argv, parms);
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! parms) {
#line 329
      goto while_break;
    }
#line 330
    next = parms->next;
#line 332
    if (parms->stdin_beep) {
      {
#line 340
      setvbuf((FILE */* __restrict  */)stdin, (char */* __restrict  */)((void *)0),
              2, (size_t )0);
#line 341
      setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0),
              2, (size_t )0);
      }
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 342
        tmp___0 = fgets((char */* __restrict  */)(sin), 4096, (FILE */* __restrict  */)stdin);
        }
#line 342
        if (! tmp___0) {
#line 342
          goto while_break___0;
        }
#line 343
        if (parms->stdin_beep == 2) {
#line 344
          ptr = sin;
          {
#line 344
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 344
            if (! *ptr) {
#line 344
              goto while_break___1;
            }
            {
#line 345
            putchar((int )*ptr);
#line 346
            fflush(stdout);
#line 347
            play_beep(*parms);
#line 344
            ptr ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 350
          fputs((char const   */* __restrict  */)(sin), (FILE */* __restrict  */)stdout);
#line 351
          play_beep(*parms);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 355
      play_beep(*parms);
      }
    }
    {
#line 359
    free((void *)parms);
#line 360
    parms = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  if (console_device) {
    {
#line 364
    free((void *)console_device);
    }
  }
#line 366
  return (0);
}
}
