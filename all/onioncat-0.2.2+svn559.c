/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_72 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_72 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_75 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_76 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_75 ifr_ifrn ;
   union __anonunion_ifr_ifru_76 ifr_ifru ;
};
#line 272 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
union __anonunion____missing_field_name_87 {
   struct sockaddr_in *socks_dst ;
   struct sockaddr_in6 *socks_dst6 ;
};
#line 272 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct OcatSetup {
   uint32_t fhd_key[2] ;
   int fhd_key_len ;
   uint16_t ocat_dest_port ;
   uint16_t ocat_ctrl_port ;
   int tunfd[2] ;
   int debug_level ;
   char *usrname ;
   char onion_url[256] ;
   struct in6_addr ocat_addr ;
   int create_clog ;
   int runasroot ;
   int controller ;
   char *ocat_dir ;
   char *tun_dev ;
   char tunname[256] ;
   int ipv4_enable ;
   struct in_addr ocat_addr4 ;
   int ocat_addr4_mask ;
   char *config_file ;
   int config_read ;
   int config_failed ;
   int use_tap ;
   uint8_t ocat_hwaddr[6] ;
   char *pid_file ;
   int create_pid_file ;
   char *logfn ;
   FILE *logf ;
   int use_syslog ;
   int daemon ;
   time_t uptime ;
   char *frandn ;
   union __anonunion____missing_field_name_87 __annonCompField5 ;
   struct sockaddr **oc_listen ;
   int *oc_listen_fd ;
   int oc_listen_cnt ;
   int rand_addr ;
   char version[256] ;
   int sizeof_setup ;
   int sig_term ;
   int term_req ;
   pthread_mutex_t mutex ;
   struct sockaddr **ctrl_listen ;
   int *ctrl_listen_fd ;
   int ctrl_listen_cnt ;
   int socksfd[2] ;
   int net_type ;
   int max_ctrl ;
   int ctrl_active ;
   int pid_fd[2] ;
   int sig_usr1 ;
   int clear_stats ;
   int unidirectional ;
   int hosts_lookup ;
   struct in6_addr oc_vdns ;
};
#line 27 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat_netdesc.h"
struct NetDesc {
   struct in6_addr prefix ;
   int prefix_len ;
   struct in_addr prefix4 ;
   int addr4_mask ;
   int name_size ;
   char *domain ;
   short listen_port ;
   short ctrl_port ;
   short vdest_port ;
   short socks_port ;
   char *clog_file ;
   char *pid_file ;
   char *config_file ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 410 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct OcatThread {
   struct OcatThread *next ;
   pthread_t handle ;
   pthread_attr_t attr ;
   int detached ;
   int id ;
   char name[11] ;
   void *(*entry)(void * ) ;
   void *parm ;
};
#line 410 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct OcatThread OcatThread_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 32 "/usr/include/net/ethernet.h"
struct ether_addr {
   u_int8_t ether_addr_octet[6] ;
} __attribute__((__packed__)) ;
#line 486 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct sockaddr_str {
   sa_family_t sstr_family ;
   uint16_t sstr_port ;
   char sstr_addr[46] ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
#line 387 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct OcatPeer {
   struct OcatPeer *next ;
   struct in6_addr addr ;
   int tcpfd ;
   time_t time ;
   time_t sdelay ;
   time_t otime ;
   int state ;
   int dir ;
   unsigned long out ;
   unsigned long in ;
   uint32_t *tunhdr ;
   char *fragbuf ;
   char _fragbuf[65580] ;
   int fraglen ;
   pthread_mutex_t mutex ;
   int perm ;
   time_t last_io ;
   unsigned int inm ;
   unsigned int outm ;
};
#line 387 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct OcatPeer OcatPeer_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 37 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.h"
struct hosts_ent {
   struct in6_addr addr ;
   char name[1025] ;
};
#line 43 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.h"
struct hosts_info {
   struct timespec hosts_ts ;
   int hosts_fd ;
   struct hosts_ent *hosts_ent ;
   int hosts_ent_cnt ;
   char const   *hdom ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 44 "/usr/include/netinet/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   u_int8_t tos ;
   u_int16_t tot_len ;
   u_int16_t id ;
   u_int16_t frag_off ;
   u_int8_t ttl ;
   u_int8_t protocol ;
   u_int16_t check ;
   u_int32_t saddr ;
   u_int32_t daddr ;
};
#line 38 "/usr/include/net/ethernet.h"
struct ether_header {
   u_int8_t ether_dhost[6] ;
   u_int8_t ether_shost[6] ;
   u_int16_t ether_type ;
} __attribute__((__packed__)) ;
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdrctl {
   uint32_t ip6_un1_flow ;
   uint16_t ip6_un1_plen ;
   uint8_t ip6_un1_nxt ;
   uint8_t ip6_un1_hlim ;
};
#line 24 "/usr/include/netinet/ip6.h"
union __anonunion_ip6_ctlun_82 {
   struct ip6_hdrctl ip6_un1 ;
   uint8_t ip6_un2_vfc ;
};
#line 24 "/usr/include/netinet/ip6.h"
struct ip6_hdr {
   union __anonunion_ip6_ctlun_82 ip6_ctlun ;
   struct in6_addr ip6_src ;
   struct in6_addr ip6_dst ;
};
#line 422 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct SocksQueue {
   struct SocksQueue *next ;
   struct in6_addr addr ;
   int state ;
   int perm ;
   int fd ;
   time_t restart_time ;
   time_t connect_time ;
   int retry ;
};
#line 422 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct SocksQueue SocksQueue_t;
#line 370 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct SocksHdr {
   char ver ;
   char cmd ;
   uint16_t port ;
   struct in_addr addr ;
} __attribute__((__packed__)) ;
#line 370 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct SocksHdr SocksHdr_t;
#line 444 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct IPv6Route {
   struct in6_addr dest ;
   int prefixlen ;
   struct in6_addr gw ;
};
#line 444 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct IPv6Route IPv6Route_t;
#line 38 "/usr/include/netinet/icmp6.h"
union __anonunion_icmp6_dataun_79 {
   uint32_t icmp6_un_data32[1] ;
   uint16_t icmp6_un_data16[2] ;
   uint8_t icmp6_un_data8[4] ;
};
#line 38 "/usr/include/netinet/icmp6.h"
struct icmp6_hdr {
   uint8_t icmp6_type ;
   uint8_t icmp6_code ;
   uint16_t icmp6_cksum ;
   union __anonunion_icmp6_dataun_79 icmp6_dataun ;
};
#line 140 "/usr/include/netinet/icmp6.h"
struct nd_neighbor_solicit {
   struct icmp6_hdr nd_ns_hdr ;
   struct in6_addr nd_ns_target ;
};
#line 152 "/usr/include/netinet/icmp6.h"
struct nd_neighbor_advert {
   struct icmp6_hdr nd_na_hdr ;
   struct in6_addr nd_na_target ;
};
#line 186 "/usr/include/netinet/icmp6.h"
struct nd_opt_hdr {
   uint8_t nd_opt_type ;
   uint8_t nd_opt_len ;
};
#line 452 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct ip6_psh {
   struct in6_addr src ;
   struct in6_addr dst ;
   uint32_t len ;
   char _pad[3] ;
   uint8_t nxt ;
} __attribute__((__packed__)) ;
#line 461 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
union __anonunion____missing_field_name_88 {
   struct in6_addr in6addr ;
   struct in_addr inaddr ;
};
#line 461 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct MACTable {
   uint16_t family ;
   union __anonunion____missing_field_name_88 __annonCompField6 ;
   uint8_t hwaddr[6] ;
   time_t age ;
};
#line 461 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct MACTable MACTable_t;
#line 473 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
union __anonunion____missing_field_name_89 {
   struct icmp6_hdr icmp6 ;
   struct nd_neighbor_solicit ndp_sol ;
   struct nd_neighbor_advert ndp_adv ;
};
#line 473 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct ndp6 {
   struct ether_header eth ;
   struct ip6_hdr ip6 ;
   union __anonunion____missing_field_name_89 __annonCompField7 ;
} __attribute__((__packed__)) ;
#line 473 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct ndp6 ndp6_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_43 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_44 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_47 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_48 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_49 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_42 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_43 _kill ;
   struct __anonstruct__timer_44 _timer ;
   struct __anonstruct__rt_45 _rt ;
   struct __anonstruct__sigchld_46 _sigchld ;
   struct __anonstruct__sigfault_47 _sigfault ;
   struct __anonstruct__sigpoll_48 _sigpoll ;
   struct __anonstruct__sigsys_49 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_41 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_42 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_41 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_61 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_61 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 435 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
struct IPv4Route {
   struct IPv4Route *next[2] ;
   uint32_t dest ;
   uint32_t netmask ;
   struct in6_addr gw ;
};
#line 435 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
typedef struct IPv4Route IPv4Route_t;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 44 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ 
  register char *d ;
  register char const   *s ;
  register size_t n ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 47
  d = dst;
#line 48
  s = src;
#line 49
  n = siz;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    tmp = n;
#line 53
    n --;
#line 53
    if (tmp != 0UL) {
#line 53
      if (! ((int )*d != 0)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
#line 54
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  dlen = (size_t )(d - dst);
#line 56
  n = siz - dlen;
#line 58
  if (n == 0UL) {
    {
#line 59
    tmp___0 = strlen(s);
    }
#line 59
    return (dlen + tmp___0);
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! ((int const   )*s != 0)) {
#line 60
      goto while_break___0;
    }
#line 61
    if (n != 1UL) {
#line 62
      tmp___1 = d;
#line 62
      d ++;
#line 62
      *tmp___1 = (char )*s;
#line 63
      n --;
    }
#line 65
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 67
  *d = (char )'\000';
#line 69
  return (dlen + (size_t )(s - src));
}
}
#line 43 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  register char *d ;
  register char const   *s ;
  register size_t n ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 45
  d = dst;
#line 46
  s = src;
#line 47
  n = siz;
#line 49
  if (n == 0UL) {
    {
#line 50
    tmp = strlen(s);
    }
#line 50
    return (tmp);
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((int const   )*s != 0)) {
#line 51
      goto while_break;
    }
#line 52
    if (n != 1UL) {
#line 53
      tmp___0 = d;
#line 53
      d ++;
#line 53
      *tmp___0 = (char )*s;
#line 54
      n --;
    }
#line 56
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  *d = (char )'\000';
#line 60
  return ((size_t )(s - src));
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 526 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
char *tun_dev_ ;
#line 539
void log_msg(int lf , char const   *fmt  , ...) ;
#line 560
int tun_alloc(char *dev , int dev_s , struct in6_addr addr ) ;
#line 615
struct OcatSetup setup_ ;
#line 44 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat_netdesc.h"
struct NetDesc  const  netdesc_[2] ;
#line 32 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocattun.c"
char *tun_dev_  =    (char *)"/dev/net/tun";
#line 37 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocattun.c"
void system_w(char const   *s ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  e = system(s);
  }
#line 42
  if (e == -1) {
    {
#line 43
    tmp = __errno_location();
#line 43
    tmp___0 = strerror(*tmp);
#line 43
    log_msg(3, "could not exec \"%s\": \"%s\"", s, tmp___0);
    }
  }
#line 45
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocattun.c"
int tun_alloc(char *dev , int dev_s , struct in6_addr addr ) 
{ 
  struct ifreq ifr ;
  int fd ;
  char astr[46] ;
  char astr4[16] ;
  char buf[1024] ;
  struct in_addr netmask ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 62
  memcpy((void */* __restrict  */)(& netmask), (void const   */* __restrict  */)(& setup_.ocat_addr4_mask),
         sizeof(netmask));
#line 63
  inet_ntop(10, (void const   */* __restrict  */)(& addr), (char */* __restrict  */)(astr),
            (socklen_t )46);
#line 64
  inet_ntop(2, (void const   */* __restrict  */)(& setup_.ocat_addr4), (char */* __restrict  */)(astr4),
            (socklen_t )16);
#line 85
  fd = open((char const   *)tun_dev_, 2);
  }
#line 85
  if (fd < 0) {
    {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    log_msg(0, "could not open tundev %s: %s", tun_dev_, tmp___0);
    }
#line 88
    return (-1);
  }
  {
#line 93
  memset((void *)(& ifr), 0, sizeof(ifr));
  }
#line 94
  if (setup_.use_tap) {
#line 95
    ifr.ifr_ifru.ifru_flags = (short)2;
  } else {
#line 97
    ifr.ifr_ifru.ifru_flags = (short)1;
  }
#line 99
  if (*dev) {
    {
#line 100
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
            (size_t )16);
    }
  }
  {
#line 102
  tmp___3 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
                  (void *)(& ifr));
  }
#line 102
  if (tmp___3 < 0) {
    {
#line 103
    tmp___1 = __errno_location();
#line 103
    tmp___2 = strerror(*tmp___1);
#line 103
    log_msg(0, "could not set TUNSETIFF: %s", tmp___2);
#line 103
    exit(1);
    }
  }
  {
#line 104
  strlcpy(dev, (char const   *)(ifr.ifr_ifrn.ifrn_name), (size_t )16);
  }
#line 105
  if (! setup_.use_tap) {
    {
#line 107
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"ifconfig %s add %s/%d up",
             dev, astr, netdesc_[setup_.net_type].prefix_len);
#line 108
    system_w((char const   *)(buf));
    }
  }
#line 207
  if (setup_.ipv4_enable) {
#line 207
    if (! setup_.use_tap) {
      {
#line 209
      tmp___4 = inet_ntoa(netmask);
#line 209
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"ifconfig %s %s netmask %s",
               dev, astr4, tmp___4);
#line 210
      system_w((char const   *)(buf));
      }
    }
  }
#line 214
  if (setup_.use_tap) {
    {
#line 216
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"ifconfig %s up",
             dev);
#line 217
    system_w((char const   *)(buf));
    }
  }
#line 220
  return (fd);
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 282
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) ;
#line 286
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                                                size_t __stacksize ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 531 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
pthread_mutex_t thread_mutex_ ;
#line 532
OcatThread_t *octh_ ;
#line 584
OcatThread_t const   *init_ocat_thread(char const   *name ) ;
#line 585
int run_ocat_thread(char const   *name , void *(*thfunc)(void * ) , void *parm ) ;
#line 586
OcatThread_t const   *get_thread(void) ;
#line 587
int set_thread_name(char const   *n ) ;
#line 588
int join_threads(void) ;
#line 589
void detach_thread(void) ;
#line 590
void print_threads(FILE *f ) ;
#line 591
int term_req(void) ;
#line 592
void set_term_req(void) ;
#line 619
void lock_setup(void) ;
#line 620
void unlock_setup(void) ;
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
static int thread_id_  =    0;
#line 32 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
static int exit_cnt_  =    0;
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
pthread_mutex_t thread_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 34 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
OcatThread_t *octh_  =    (OcatThread_t *)((void *)0);
#line 37 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
void init_ocat_thread_struct(OcatThread_t *th ) 
{ 
  int tmp ;

  {
  {
#line 40
  th->handle = pthread_self();
#line 41
  pthread_mutex_lock(& thread_mutex_);
#line 42
  tmp = thread_id_;
#line 42
  thread_id_ ++;
#line 42
  th->id = tmp;
#line 43
  th->next = octh_;
#line 44
  octh_ = th;
#line 45
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 47
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
OcatThread_t const   *init_ocat_thread(char const   *name ) 
{ 
  OcatThread_t *th ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 55
  tmp___1 = calloc((size_t )1, sizeof(OcatThread_t ));
#line 55
  th = (OcatThread_t *)tmp___1;
  }
#line 55
  if (! th) {
    {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    log_msg(3, "could not get memory for thread struct: \"%s\"", tmp___0);
    }
#line 58
    return ((OcatThread_t const   *)((void *)0));
  }
  {
#line 61
  strlcpy(th->name, name, (size_t )11);
#line 62
  init_ocat_thread_struct(th);
  }
#line 64
  return ((OcatThread_t const   *)th);
}
}
#line 68 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
void *thread_run(void *p ) 
{ 
  OcatThread_t **tl ;
  void *r ;
  sigset_t ss ;
  int ecnt ;
  int icnt ;

  {
  {
#line 76
  sigfillset(& ss);
#line 77
  pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& ss), (__sigset_t */* __restrict  */)((void *)0));
#line 80
  init_ocat_thread_struct((OcatThread_t *)p);
#line 84
  r = (*(((OcatThread_t *)p)->entry))(((OcatThread_t *)p)->parm);
#line 88
  pthread_mutex_lock(& thread_mutex_);
#line 89
  tl = & octh_;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! *tl) {
#line 89
      goto while_break;
    }
#line 90
    if ((*tl)->handle == ((OcatThread_t *)p)->handle) {
#line 91
      goto while_break;
    }
#line 89
    tl = & (*tl)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  p = (void *)*tl;
#line 93
  if (p) {
    {
#line 95
    *tl = (*tl)->next;
#line 96
    free(p);
    }
  }
  {
#line 98
  exit_cnt_ ++;
#line 98
  ecnt = exit_cnt_;
#line 99
  icnt = thread_id_;
#line 100
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 103
  return (r);
}
}
#line 107 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
int run_ocat_thread(char const   *name , void *(*thfunc)(void * ) , void *parm ) 
{ 
  int rc ;
  OcatThread_t *th ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 116
  tmp___2 = calloc((size_t )1, sizeof(OcatThread_t ));
#line 116
  th = (OcatThread_t *)tmp___2;
  }
#line 116
  if (! th) {
    {
#line 118
    tmp = __errno_location();
#line 118
    rc = *tmp;
#line 119
    tmp___0 = __errno_location();
#line 119
    tmp___1 = strerror(*tmp___0);
#line 119
    log_msg(0, "could not create thread %s: \"%s\"", name, tmp___1);
    }
#line 120
    return (rc);
  }
  {
#line 123
  strlcpy(th->name, name, (size_t )11);
#line 124
  th->entry = thfunc;
#line 125
  th->parm = parm;
#line 127
  rc = pthread_attr_init(& th->attr);
  }
#line 127
  if (rc) {
    {
#line 129
    tmp___3 = strerror(rc);
#line 129
    log_msg(3, "could not init pthread attr: \"%s\"", tmp___3);
    }
#line 130
    return (rc);
  }
  {
#line 141
  tmp___5 = pthread_attr_setstacksize(& th->attr, (size_t )262144);
  }
#line 141
  if (rc - tmp___5) {
    {
#line 143
    tmp___4 = strerror(rc);
#line 143
    log_msg(0, "could not init thread stack size attr - system may be unstable: \"%s\"",
            tmp___4);
    }
#line 144
    return (rc);
  }
  {
#line 148
  rc = pthread_create((pthread_t */* __restrict  */)(& th->handle), (pthread_attr_t const   */* __restrict  */)(& th->attr),
                      & thread_run, (void */* __restrict  */)th);
  }
#line 148
  if (rc) {
    {
#line 150
    tmp___6 = strerror(rc);
#line 150
    log_msg(0, "could not start thread %s: \"%s\"", name, tmp___6);
#line 151
    free((void *)th);
    }
  }
#line 154
  return (rc);
}
}
#line 158 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
OcatThread_t const   *get_thread(void) 
{ 
  OcatThread_t *th ;
  pthread_t thread ;
  pthread_t tmp ;

  {
  {
#line 161
  tmp = pthread_self();
#line 161
  thread = tmp;
#line 163
  pthread_mutex_lock(& thread_mutex_);
#line 164
  th = octh_;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! th) {
#line 164
      goto while_break;
    }
#line 165
    if (th->handle == thread) {
#line 166
      goto while_break;
    }
#line 164
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 169
  return ((OcatThread_t const   *)th);
}
}
#line 173 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
int set_thread_name(char const   *n ) 
{ 
  int e ;
  OcatThread_t *th ;
  pthread_t thread ;
  pthread_t tmp ;

  {
  {
#line 175
  e = -1;
#line 177
  tmp = pthread_self();
#line 177
  thread = tmp;
#line 179
  pthread_mutex_lock(& thread_mutex_);
#line 180
  th = octh_;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! th) {
#line 180
      goto while_break;
    }
#line 181
    if (th->handle == thread) {
      {
#line 183
      strlcpy(th->name, n, (size_t )11);
#line 184
      e = 0;
      }
#line 185
      goto while_break;
    }
#line 180
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 189
  return (e);
}
}
#line 193 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
void print_threads(FILE *f ) 
{ 
  OcatThread_t *th ;

  {
  {
#line 197
  pthread_mutex_lock(& thread_mutex_);
#line 198
  th = octh_;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! th) {
#line 198
      goto while_break;
    }
    {
#line 200
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"[%s] handle = 0x%08lx, id = %d, entry = %p, parm = %p, detached = %d\n",
            th->name, (long )th->handle, th->id, th->entry, th->parm, th->detached);
#line 198
    th = th->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 209
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
int join_threads(void) 
{ 
  OcatThread_t *th ;
  OcatThread_t thb ;
  void *ret ;
  int rc ;
  char *tmp ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    pthread_mutex_lock(& thread_mutex_);
#line 221
    th = octh_;
#line 221
    rc = 0;
    }
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 221
      if (th) {
#line 221
        if (! th->detached) {
#line 221
          goto while_break___0;
        }
      } else {
#line 221
        goto while_break___0;
      }
#line 221
      th = th->next;
#line 221
      rc ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    if (! th) {
      {
#line 224
      pthread_mutex_unlock(& thread_mutex_);
      }
#line 225
      goto while_break;
    }
    {
#line 227
    memcpy((void */* __restrict  */)(& thb), (void const   */* __restrict  */)th,
           sizeof(OcatThread_t ));
#line 228
    pthread_mutex_unlock(& thread_mutex_);
#line 231
    rc = pthread_join(thb.handle, & ret);
    }
#line 231
    if (rc) {
      {
#line 232
      tmp = strerror(rc);
#line 232
      log_msg(3, "error joining thread: \"%s\"", tmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (rc);
}
}
#line 240 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
void detach_thread(void) 
{ 
  OcatThread_t *th ;
  pthread_t thread ;
  pthread_t tmp ;
  int rc ;
  char *tmp___0 ;

  {
  {
#line 243
  tmp = pthread_self();
#line 243
  thread = tmp;
#line 244
  rc = 0;
#line 246
  pthread_mutex_lock(& thread_mutex_);
#line 247
  th = octh_;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! th) {
#line 247
      goto while_break;
    }
#line 248
    if (th->handle == thread) {
#line 249
      goto while_break;
    }
#line 247
    th = th->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  if (th) {
    {
#line 250
    rc = pthread_detach(thread);
    }
#line 250
    if (! rc) {
#line 251
      th->detached = 1;
    }
  }
  {
#line 252
  pthread_mutex_unlock(& thread_mutex_);
  }
#line 254
  if (! th) {
    {
#line 255
    log_msg(0, "thread tries to detach but is not in list");
    }
  } else
#line 256
  if (rc) {
    {
#line 257
    tmp___0 = strerror(rc);
#line 257
    log_msg(3, "could not detach thread: \"%s\"", tmp___0);
    }
  }
#line 260
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
int term_req(void) 
{ 
  int trq ;

  {
  {
#line 270
  lock_setup();
#line 271
  trq = setup_.term_req;
#line 272
  unlock_setup();
  }
#line 274
  return (trq);
}
}
#line 279 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatthread.c"
void set_term_req(void) 
{ 


  {
  {
#line 281
  lock_setup();
#line 282
  setup_.term_req = 1;
#line 283
  unlock_setup();
  }
#line 284
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 228 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_loopback ;
#line 374
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 31 "/usr/include/netinet/ether.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ether_ntoa_r)(struct ether_addr  const  *__addr ,
                                                                                     char *__buf ) ;
#line 552 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
char const   *inet_ntops(struct sockaddr  const  *saddr , struct sockaddr_str *sas ) ;
#line 616
void print_setup_struct(FILE *f ) ;
#line 617
void init_setup(void) ;
#line 618
void post_init_setup(void) ;
#line 54 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.h"
void hosts_init(char const   *dom ) ;
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
static struct sockaddr_in6 socks_dst6_  ;
#line 32 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
static struct sockaddr_in ctrl_listen_  ;
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
static struct sockaddr_in6 ctrl_listen6_  ;
#line 34 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
static struct sockaddr *ctrl_listen_ptr_[3]  = {      (struct sockaddr *)(& ctrl_listen_),      (struct sockaddr *)(& ctrl_listen6_),      (struct sockaddr *)((void *)0)};
#line 41 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
static int ctrl_fd_[2]  = {      -1,      -1};
#line 43 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
struct OcatSetup setup_  = 
#line 43
     {{(uint32_t )0, (uint32_t )0}, (int )sizeof(uint32_t ), (uint16_t )0, (uint16_t )0,
    {0, 1}, 7, (char *)"tor", {(char)0}, {{{(uint8_t )0}}}, 0, 0, 1, (char *)".ocat",
    (char *)"/dev/net/tun", {(char )'\000'}, 0, {(in_addr_t )0}, 0, (char *)((void *)0),
    0, 0, 0, {(uint8_t )0, (uint8_t )0, (uint8_t )108, (uint8_t )0, (uint8_t )0, (uint8_t )0},
    (char *)"/var/run/ocat.pid", 0, (char *)((void *)0), (FILE *)((void *)0), 0, 1,
    (time_t )0, (char *)"/dev/urandom", {(struct sockaddr_in *)(& socks_dst6_)}, (struct sockaddr **)((void *)0),
    (int *)((void *)0), 0, 0, {(char)0}, (int )sizeof(struct OcatSetup ), 0, 0, {{0,
                                                                                  0U,
                                                                                  0,
                                                                                  0U,
                                                                                  0,
                                                                                  (short)0,
                                                                                  (short)0,
                                                                                  {(struct __pthread_internal_list *)0,
                                                                                   (struct __pthread_internal_list *)0}}},
    ctrl_listen_ptr_, ctrl_fd_, 2, {-1, -1}, 0, 5, 0, {-1, -1}, 0, 0, 1, 1, {{{(unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0}}}};
#line 135 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
void init_setup(void) 
{ 
  struct timeval tv ;
  uint32_t loop_ ;
  uint32_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 138
  tmp = htonl((in_addr_t )2130706433);
#line 138
  loop_ = tmp;
#line 141
  tmp___2 = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 141
  if (tmp___2 == -1) {
    {
#line 142
    tmp___0 = __errno_location();
#line 142
    tmp___1 = strerror(*tmp___0);
#line 142
    log_msg(4, "could gettimeofday(): \"%s\"", tmp___1);
    }
  }
  {
#line 143
  srand((unsigned int )(tv.tv_sec ^ tv.tv_usec));
#line 146
  setup_.uptime = time((time_t *)((void *)0));
#line 147
  memset((void *)(& socks_dst6_), 0, sizeof(socks_dst6_));
#line 148
  (setup_.__annonCompField5.socks_dst)->sin_family = (sa_family_t )2;
#line 150
  memcpy((void */* __restrict  */)(& (setup_.__annonCompField5.socks_dst)->sin_addr),
         (void const   */* __restrict  */)(& loop_), sizeof((setup_.__annonCompField5.socks_dst)->sin_addr));
#line 155
  memset((void *)(& ctrl_listen_), 0, sizeof(ctrl_listen_));
#line 156
  memset((void *)(& ctrl_listen6_), 0, sizeof(ctrl_listen6_));
#line 158
  hosts_init(".b32.i2p");
#line 161
  setup_.fhd_key[1] = htonl((uint32_t )34525);
#line 162
  setup_.fhd_key[0] = htonl((uint32_t )2048);
  }
#line 167
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
void post_init_setup(void) 
{ 
  size_t l ;
  uint32_t loop_ ;
  uint32_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 173
  tmp = htonl((in_addr_t )2130706433);
#line 173
  loop_ = tmp;
#line 175
  setup_.ocat_addr4 = (struct in_addr )netdesc_[setup_.net_type].prefix4;
#line 176
  setup_.ocat_addr4_mask = (int )netdesc_[setup_.net_type].addr4_mask;
#line 177
  setup_.ocat_dest_port = (uint16_t )netdesc_[setup_.net_type].vdest_port;
#line 178
  setup_.ocat_ctrl_port = (uint16_t )netdesc_[setup_.net_type].ctrl_port;
#line 180
  tmp___0 = strlen("/usr/local/etc");
#line 180
  tmp___1 = strlen((char const   *)netdesc_[setup_.net_type].config_file);
#line 180
  l = (tmp___0 + tmp___1) + 2UL;
#line 181
  tmp___4 = malloc(l);
#line 181
  setup_.config_file = (char *)tmp___4;
  }
#line 181
  if ((unsigned long )setup_.config_file != (unsigned long )((void *)0)) {
    {
#line 182
    snprintf((char */* __restrict  */)setup_.config_file, l, (char const   */* __restrict  */)"%s/%s",
             "/usr/local/etc", netdesc_[setup_.net_type].config_file);
    }
  } else {
    {
#line 184
    tmp___2 = __errno_location();
#line 184
    tmp___3 = strerror(*tmp___2);
#line 184
    log_msg(4, "could not get memory for config file string: \"%s\"", tmp___3);
    }
  }
#line 186
  if (! (setup_.__annonCompField5.socks_dst)->sin_port) {
    {
#line 187
    (setup_.__annonCompField5.socks_dst)->sin_port = htons((uint16_t )netdesc_[setup_.net_type].socks_port);
    }
  }
  {
#line 189
  ctrl_listen_.sin_family = (sa_family_t )2;
#line 190
  ctrl_listen_.sin_port = htons(setup_.ocat_ctrl_port);
#line 192
  memcpy((void */* __restrict  */)(& ctrl_listen_.sin_addr), (void const   */* __restrict  */)(& loop_),
         sizeof(ctrl_listen_.sin_addr));
#line 197
  ctrl_listen6_.sin6_family = (sa_family_t )10;
#line 198
  ctrl_listen6_.sin6_port = htons(setup_.ocat_ctrl_port);
#line 199
  ctrl_listen6_.sin6_addr = (struct in6_addr )in6addr_loopback;
  }
#line 204
  if (setup_.net_type == 0) {
#line 204
    tmp___6 = "OnionCat";
  } else {
#line 204
    if (setup_.net_type == 1) {
#line 204
      tmp___5 = "GarliCat";
    } else {
#line 204
      tmp___5 = "unknown";
    }
#line 204
    tmp___6 = tmp___5;
  }
  {
#line 204
  snprintf((char */* __restrict  */)(setup_.version), (size_t )256, (char const   */* __restrict  */)"%s (c) %s (%s mode)",
           "onioncat 0.2.2.r559", "Bernhard R. Fischer", tmp___6);
#line 208
  setup_.pid_file = (char *)netdesc_[setup_.net_type].pid_file;
#line 209
  setup_.oc_vdns = (struct in6_addr )netdesc_[setup_.net_type].prefix;
#line 210
  setup_.oc_vdns.__in6_u.__u6_addr8[15] = (uint8_t )1;
  }
#line 211
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
void print_setup_struct(FILE *f ) 
{ 
  char *c ;
  char ip[100] ;
  char nm[100] ;
  char ip6[100] ;
  char logf[100] ;
  char hw[100] ;
  int i ;
  int t ;
  struct sockaddr_str sas ;
  time_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  uint16_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  uint16_t tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
  {
#line 223
  inet_ntop(2, (void const   */* __restrict  */)(& setup_.ocat_addr4), (char */* __restrict  */)(ip),
            (socklen_t )100);
#line 224
  inet_ntop(2, (void const   */* __restrict  */)(& setup_.ocat_addr4_mask), (char */* __restrict  */)(nm),
            (socklen_t )100);
#line 225
  inet_ntop(10, (void const   */* __restrict  */)(& setup_.ocat_addr), (char */* __restrict  */)(ip6),
            (socklen_t )100);
#line 226
  ether_ntoa_r((struct ether_addr  const  *)((struct ether_addr *)(setup_.ocat_hwaddr)),
               hw);
  }
#line 228
  if ((unsigned long )setup_.logf == (unsigned long )stderr) {
    {
#line 229
    strlcpy(logf, "stderr", sizeof(logf));
    }
  } else {
    {
#line 231
    snprintf((char */* __restrict  */)(logf), sizeof(logf), (char const   */* __restrict  */)"%p",
             setup_.logf);
    }
  }
  {
#line 233
  tmp = time((time_t *)((void *)0));
#line 233
  t = (int )(tmp - setup_.uptime);
  }
#line 236
  if (setup_.net_type == 0) {
#line 236
    tmp___1 = "NTYPE_TOR";
  } else {
#line 236
    if (setup_.net_type == 1) {
#line 236
      tmp___0 = "NTYPE_I2P";
    } else {
#line 236
      tmp___0 = "unknown";
    }
#line 236
    tmp___1 = tmp___0;
  }
  {
#line 236
  tmp___2 = strlen((char const   *)(setup_.version));
  }
#line 236
  if ((unsigned long )setup_.logfn != (unsigned long )((void *)0)) {
#line 236
    tmp___3 = (char const   *)setup_.logfn;
  } else {
#line 236
    tmp___3 = "(nil)";
  }
  {
#line 236
  tmp___4 = ntohl(setup_.fhd_key[1]);
#line 236
  tmp___5 = ntohl(setup_.fhd_key[0]);
#line 236
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"fhd_key[IPV4(%d)]       = 0x%04x\nfhd_key[IPV6(%d)]       = 0x%04x\nfhd_key_len            = %d\nocat_dest_port         = %d\nocat_ctrl_port         = %d\ntunfd[0]               = %d\ntunfd[1]               = %d\ndebug_level            = %d\nusrname                = \"%s\"\nonion_url              = \"%s\"\nocat_addr              = %s\ncreate_clog            = %d\nrunasroot              = %d\ncontroller             = %d\nocat_dir               = \"%s\"\ntun_dev                = \"%s\"\ntunname                = \"%s\"\nipv4_enable            = %d\nocat_addr4             = %s\nocat_addr4_mask        = %s\nconfig_file            = \"%s\"\nconfig_read            = %d\nuse_tap                = %d\nocat_hwaddr            = %s\npid_file               = \"%s\"\nlogfn                  = \"%s\"\nlogf                   = %s\ndaemon                 = %d\nuptime                 = %d days, %d:%02d\nversion[%3d+1/%3d]     = \"%s\"\nsizeof_setup           = %d\nterm_req               = %d\nnet_type               = %d (%s)\nmax_ctrl               = %d\nctrl_active            = %d\npid_fd[2]              = {%d, %d}\nclear_stats            = %d\nctrl_listen_cnt        = %d\nunidirectional         = %d\nhosts_lookup           = %d\n",
          0, tmp___5, 1, tmp___4, setup_.fhd_key_len, (int )setup_.ocat_dest_port,
          (int )setup_.ocat_ctrl_port, setup_.tunfd[0], setup_.tunfd[1], setup_.debug_level,
          setup_.usrname, setup_.onion_url, ip6, setup_.create_clog, setup_.runasroot,
          setup_.controller, setup_.ocat_dir, setup_.tun_dev, setup_.tunname, setup_.ipv4_enable,
          ip, nm, setup_.config_file, setup_.config_read, setup_.use_tap, hw, setup_.pid_file,
          tmp___3, logf, setup_.daemon, t / 86400, (t / 3600) % 24, (t / 60) % 60,
          (int )tmp___2, 256, setup_.version, setup_.sizeof_setup, setup_.term_req,
          setup_.net_type, tmp___1, setup_.max_ctrl, setup_.ctrl_active, setup_.pid_fd[0],
          setup_.pid_fd[1], setup_.clear_stats, setup_.ctrl_listen_cnt, setup_.unidirectional,
          setup_.hosts_lookup);
#line 327
  tmp___9 = inet_ntops((struct sockaddr  const  *)((struct sockaddr *)setup_.__annonCompField5.socks_dst),
                       & sas);
  }
#line 327
  if (tmp___9) {
#line 329
    if ((int )sas.sstr_family == 10) {
#line 329
      c = (char *)"6";
    } else {
#line 329
      c = (char *)"";
    }
    {
#line 330
    tmp___6 = ntohs(sas.sstr_port);
#line 330
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"socks_dst%s.sin_family   = 0x%04x\nsocks_dst%s.sin_port     = %d\nsocks_dst%s.sin_addr     = %s\n",
            c, (int )sas.sstr_family, c, (int )tmp___6, c, sas.sstr_addr);
    }
  } else {
    {
#line 339
    tmp___7 = __errno_location();
#line 339
    tmp___8 = strerror(*tmp___7);
#line 339
    log_msg(4, "could not convert struct sockaddr: \"%s\"", tmp___8);
    }
  }
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < setup_.oc_listen_cnt)) {
#line 341
      goto while_break;
    }
    {
#line 343
    tmp___13 = inet_ntops((struct sockaddr  const  *)*(setup_.oc_listen + i), & sas);
    }
#line 343
    if (tmp___13) {
      {
#line 344
      tmp___10 = ntohs(sas.sstr_port);
#line 344
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"oc_listen[%d]           = %s:%d\n",
              i, sas.sstr_addr, (int )tmp___10);
      }
    } else {
      {
#line 346
      tmp___11 = __errno_location();
#line 346
      tmp___12 = strerror(*tmp___11);
#line 346
      log_msg(4, "could not convert struct sockaddr: \"%s\"", tmp___12);
      }
    }
    {
#line 347
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"oc_listen_fd[%d]        = %d\n",
            i, *(setup_.oc_listen_fd + i));
#line 341
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  i = 0;
  {
#line 350
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 350
    if (! (i < setup_.ctrl_listen_cnt)) {
#line 350
      goto while_break___0;
    }
    {
#line 352
    tmp___17 = inet_ntops((struct sockaddr  const  *)ctrl_listen_ptr_[i], & sas);
    }
#line 352
    if (tmp___17) {
      {
#line 353
      tmp___14 = ntohs(sas.sstr_port);
#line 353
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"ctrl_listen_ptr_[%d]    = %s:%d (0x%04x)\n",
              i, sas.sstr_addr, (int )tmp___14, (int )sas.sstr_family);
      }
    } else {
      {
#line 355
      tmp___15 = __errno_location();
#line 355
      tmp___16 = strerror(*tmp___15);
#line 355
      log_msg(4, "could not convert struct sockaddr: \"%s\"", tmp___16);
      }
    }
#line 350
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 358
  inet_ntop(10, (void const   */* __restrict  */)(& setup_.oc_vdns), (char */* __restrict  */)(ip6),
            (socklen_t )100);
#line 359
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"oc_vdns                = %s\n",
          ip6);
  }
#line 360
  return;
}
}
#line 363 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
void lock_setup(void) 
{ 


  {
  {
#line 365
  pthread_mutex_lock(& setup_.mutex);
  }
#line 366
  return;
}
}
#line 369 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsetup.c"
void unlock_setup(void) 
{ 


  {
  {
#line 371
  pthread_mutex_unlock(& setup_.mutex);
  }
#line 372
  return;
}
}
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 603 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
OcatPeer_t *get_first_peer(void) ;
#line 604
OcatPeer_t **get_first_peer_ptr(void) ;
#line 605
int lock_peers(void) ;
#line 606
int unlock_peers(void) ;
#line 607
int lock_peer(OcatPeer_t *peer ) ;
#line 608
int unlock_peer(OcatPeer_t *peer ) ;
#line 609
OcatPeer_t *search_peer(struct in6_addr  const  *addr ) ;
#line 610
OcatPeer_t *get_empty_peer(void) ;
#line 611
void delete_peer(OcatPeer_t *peer ) ;
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
static OcatPeer_t *peer_  =    (OcatPeer_t *)((void *)0);
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
static pthread_mutex_t peer_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 37 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
OcatPeer_t *get_first_peer(void) 
{ 


  {
#line 39
  return (peer_);
}
}
#line 44 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
OcatPeer_t **get_first_peer_ptr(void) 
{ 


  {
#line 46
  return (& peer_);
}
}
#line 51 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
int lock_peers(void) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = pthread_mutex_lock(& peer_mutex_);
  }
#line 53
  return (tmp);
}
}
#line 58 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
int unlock_peers(void) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = pthread_mutex_unlock(& peer_mutex_);
  }
#line 60
  return (tmp);
}
}
#line 66 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
int lock_peer(OcatPeer_t *peer ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = pthread_mutex_lock(& peer->mutex);
  }
#line 68
  return (tmp);
}
}
#line 74 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
int unlock_peer(OcatPeer_t *peer ) 
{ 
  int tmp ;

  {
  {
#line 76
  tmp = pthread_mutex_unlock(& peer->mutex);
  }
#line 76
  return (tmp);
}
}
#line 82 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
OcatPeer_t *search_peer(struct in6_addr  const  *addr ) 
{ 
  OcatPeer_t *peer ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
#line 86
  peer = peer_;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! peer) {
#line 86
      goto while_break;
    }
#line 88
    __a = addr;
#line 88
    __b = (struct in6_addr  const  *)(& peer->addr);
#line 88
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 88
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 88
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 88
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 88
            tmp = 1;
          } else {
#line 88
            tmp = 0;
          }
        } else {
#line 88
          tmp = 0;
        }
      } else {
#line 88
        tmp = 0;
      }
    } else {
#line 88
      tmp = 0;
    }
#line 88
    if (tmp) {
#line 89
      return (peer);
    }
#line 86
    peer = peer->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return ((OcatPeer_t *)((void *)0));
}
}
#line 96 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
OcatPeer_t *get_empty_peer(void) 
{ 
  int rc ;
  OcatPeer_t *peer ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 101
  tmp___1 = calloc((size_t )1, sizeof(OcatPeer_t ));
#line 101
  peer = (OcatPeer_t *)tmp___1;
  }
#line 101
  if (! peer) {
    {
#line 103
    tmp = __errno_location();
#line 103
    tmp___0 = strerror(*tmp);
#line 103
    log_msg(3, "cannot get memory for new peer: \"%s\"", tmp___0);
    }
#line 104
    return ((OcatPeer_t *)((void *)0));
  }
  {
#line 107
  peer->tunhdr = (uint32_t *)(peer->_fragbuf);
#line 108
  peer->fragbuf = & peer->_fragbuf[setup_.fhd_key_len];
#line 109
  rc = pthread_mutex_init(& peer->mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 109
  if (rc) {
    {
#line 111
    tmp___2 = strerror(rc);
#line 111
    log_msg(0, "cannot init new peer mutex: \"%s\"", tmp___2);
#line 112
    free((void *)peer);
    }
#line 113
    return ((OcatPeer_t *)((void *)0));
  }
#line 116
  peer->next = peer_;
#line 117
  peer_ = peer;
#line 119
  return (peer);
}
}
#line 126 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatpeer.c"
void delete_peer(OcatPeer_t *peer ) 
{ 
  int rc ;
  OcatPeer_t **p ;
  char *tmp ;

  {
#line 131
  p = & peer_;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! *p) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned long )*p == (unsigned long )peer) {
      {
#line 136
      lock_peer(peer);
#line 137
      *p = peer->next;
#line 138
      unlock_peer(peer);
#line 141
      rc = pthread_mutex_destroy(& peer->mutex);
      }
#line 141
      if (rc) {
        {
#line 142
        tmp = strerror(rc);
#line 142
        log_msg(0, "cannot destroy mutex: \"%s\"", tmp);
        }
      }
      {
#line 143
      free((void *)peer);
      }
#line 144
      return;
    }
#line 131
    p = & (*p)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 52 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.h"
int hosts_check(void) ;
#line 53
int hosts_get_name(struct in6_addr  const  *addr , char *buf , int s ) ;
#line 63 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
static struct hosts_info hosts_  =    {{(__time_t )0, (__syscall_slong_t )0}, -1, (struct hosts_ent *)((void *)0), 0,
    ""};
#line 64 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
static char *path_hosts_  =    (char *)((void *)0);
#line 65 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
static pthread_mutex_t hosts_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
int hosts_file_modified_r(struct timespec *ts ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 80
  tmp = stat((char const   */* __restrict  */)path_hosts_, (struct stat */* __restrict  */)(& st));
  }
#line 80
  if (tmp == -1) {
#line 83
    return (-1);
  }
#line 87
  if (st.st_mtim.tv_sec == ts->tv_sec) {
#line 87
    if (st.st_mtim.tv_nsec == ts->tv_nsec) {
#line 93
      return (0);
    }
  }
#line 97
  *ts = st.st_mtim;
#line 103
  return (1);
}
}
#line 107 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
int hosts_read(struct hosts_ent **hent ) 
{ 
  int e ;
  int n ;
  int c ;
  char buf[1025] ;
  char *s ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct hosts_ent *h ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  struct hosts_ent *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 109
  n = 0;
#line 115
  f = fopen((char const   */* __restrict  */)path_hosts_, (char const   */* __restrict  */)"r");
  }
#line 115
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 118
    return (-1);
  }
  {
#line 121
  pthread_mutex_lock(& hosts_mutex_);
  }
#line 122
  if (*hent) {
    {
#line 124
    free((void *)*hent);
#line 125
    *hent = (struct hosts_ent *)((void *)0);
    }
  }
  {
#line 128
  memset((void *)(& hints), 0, sizeof(hints));
#line 129
  hints.ai_family = 10;
#line 130
  hints.ai_flags = 4;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp___8 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)f);
    }
#line 131
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 131
      goto while_break;
    }
    {
#line 133
    s = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)" \t\r\n");
    }
#line 133
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 134
      goto while_continue;
    }
#line 137
    if ((int )*(s + 0) == 35) {
#line 138
      goto while_continue;
    }
    {
#line 140
    e = getaddrinfo((char const   */* __restrict  */)s, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
    }
#line 140
    if (e != 0) {
#line 143
      goto while_continue;
    }
#line 147
    if (res->ai_family != 10) {
      {
#line 151
      freeaddrinfo(res);
      }
#line 152
      goto while_continue;
    }
#line 156
    c = 0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 156
      s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
      }
#line 156
      if (! s) {
#line 156
        goto while_break___0;
      }
      {
#line 159
      tmp___3 = strlen((char const   *)s);
#line 159
      tmp___4 = strlen(hosts_.hdom);
      }
#line 159
      if (tmp___3 > tmp___4) {
        {
#line 159
        tmp___5 = strlen((char const   *)s);
#line 159
        tmp___6 = strlen(hosts_.hdom);
#line 159
        tmp___7 = strcasecmp((char const   *)(s + (tmp___5 - tmp___6)), hosts_.hdom);
        }
#line 159
        if (! tmp___7) {
          {
#line 161
          n ++;
#line 161
          tmp___2 = realloc((void *)*hent, (unsigned long )n * sizeof(struct hosts_ent ));
#line 161
          tmp___1 = (struct hosts_ent *)tmp___2;
#line 161
          *hent = tmp___1;
          }
#line 161
          if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
            {
#line 163
            tmp = __errno_location();
#line 163
            tmp___0 = strerror(*tmp);
#line 163
            log_msg(3, "realloc failed: \"%s\"", tmp___0);
#line 164
            n --;
            }
#line 165
            goto while_break___0;
          }
          {
#line 168
          h = (*hent + n) - 1;
#line 169
          h->addr = ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
#line 170
          strlcpy(h->name, (char const   *)s, (size_t )1025);
          }
#line 171
          goto while_break___0;
        }
      }
#line 156
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    freeaddrinfo(res);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  pthread_mutex_unlock(& hosts_mutex_);
#line 178
  fclose(f);
  }
#line 182
  return (n);
}
}
#line 189 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
int hosts_check(void) 
{ 
  int tmp ;

  {
#line 196
  if ((unsigned long )path_hosts_ == (unsigned long )((void *)0)) {
#line 205
    path_hosts_ = (char *)"/etc/hosts";
  }
  {
#line 209
  tmp = hosts_file_modified_r(& hosts_.hosts_ts);
  }
#line 209
  if (tmp) {
    {
#line 210
    hosts_.hosts_ent_cnt = hosts_read(& hosts_.hosts_ent);
    }
  }
#line 212
  return (0);
}
}
#line 219 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
int hosts_get_name(struct in6_addr  const  *addr , char *buf , int s ) 
{ 
  int i ;
  struct hosts_ent *h ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
  {
#line 225
  pthread_mutex_lock(& hosts_mutex_);
#line 226
  i = hosts_.hosts_ent_cnt - 1;
#line 226
  h = hosts_.hosts_ent;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i >= 0)) {
#line 226
      goto while_break;
    }
#line 227
    __a = addr;
#line 227
    __b = (struct in6_addr  const  *)(& h->addr);
#line 227
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 227
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 227
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 227
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 227
            tmp = 1;
          } else {
#line 227
            tmp = 0;
          }
        } else {
#line 227
          tmp = 0;
        }
      } else {
#line 227
        tmp = 0;
      }
    } else {
#line 227
      tmp = 0;
    }
#line 227
    if (tmp) {
      {
#line 229
      strlcpy(buf, (char const   *)(h->name), (size_t )s);
      }
#line 231
      goto while_break;
    }
#line 226
    i --;
#line 226
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  pthread_mutex_unlock(& hosts_mutex_);
  }
#line 235
  if (i < 0) {
#line 236
    return (-1);
  }
#line 238
  return (0);
}
}
#line 242 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocathosts.c"
void hosts_init(char const   *dom ) 
{ 


  {
#line 244
  hosts_.hdom = dom;
#line 245
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 550 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
int has_tor_prefix(struct in6_addr  const  *addr ) ;
#line 566
void *socket_receiver(void *p ) ;
#line 567
void packet_forwarder(void) ;
#line 571
void *socket_acceptor(void *p ) ;
#line 572
void *socket_cleaner(void *ptr ) ;
#line 575
int insert_peer(int fd , SocksQueue_t const   *sq , time_t dly ) ;
#line 576
int run_listeners(struct sockaddr **addr , int *sockfd , int cnt , int (*action_accept)(int  ) ) ;
#line 577
int send_keepalive(OcatPeer_t *peer ) ;
#line 578
void set_select_timeout(struct timeval *tv ) ;
#line 579
void set_nonblock(int fd ) ;
#line 580
void set_tunheader(char *buf , uint32_t tunhdr ) ;
#line 581
uint32_t get_tunheader(char *buf ) ;
#line 623
struct in6_addr *ipv4_lookup_route(uint32_t ip ) ;
#line 628
int eth_check(char *buf , int len ) ;
#line 629
int mac_set(struct in6_addr  const  *in6 , uint8_t *hwaddr ) ;
#line 631
void mac_cleanup(void) ;
#line 633
int ndp_solicit(struct in6_addr  const  *src , struct in6_addr  const  *dst ) ;
#line 642
void socks_queue(struct in6_addr addr , int perm ) ;
#line 648
void oe_close(int fd ) ;
#line 657
struct in6_addr *ipv6_lookup_route(struct in6_addr  const  *dest ) ;
#line 39 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
static int lpfd_[2]  ;
#line 50 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int forward_packet(struct in6_addr  const  *addr , char const   *buf , int buflen ) 
{ 
  OcatPeer_t *peer ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 55
  lock_peers();
#line 56
  peer = search_peer(addr);
  }
#line 56
  if (peer) {
    {
#line 57
    lock_peer(peer);
    }
  }
  {
#line 58
  unlock_peers();
  }
#line 60
  if (! peer) {
#line 63
    return (-1);
  }
  {
#line 68
  tmp___1 = send(peer->tcpfd, (void const   *)buf, (size_t )buflen, 64);
#line 68
  len = (int )tmp___1;
  }
#line 68
  if (len == -1) {
    {
#line 70
    tmp = __errno_location();
#line 70
    tmp___0 = strerror(*tmp);
#line 70
    log_msg(3, "could not write %d bytes to peer %d: \"%s\", dropping", buflen, peer->tcpfd,
            tmp___0);
    }
  } else {
#line 74
    if (len != buflen) {
      {
#line 77
      log_msg(3, "could not write %d bytes to peer %d, %d bytes written", buflen,
              peer->tcpfd, len);
      }
    }
    {
#line 79
    peer->time = time((time_t *)((void *)0));
#line 80
    peer->out += (unsigned long )len;
    }
  }
  {
#line 82
  unlock_peer(peer);
  }
#line 84
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int check_tor_prefix(struct ip6_hdr  const  *ihd ) 
{ 
  char buf[46] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 185
  tmp___0 = has_tor_prefix(& ihd->ip6_dst);
  }
#line 185
  if (! tmp___0) {
    {
#line 187
    tmp = inet_ntop(10, (void const   */* __restrict  */)(& ihd->ip6_dst), (char */* __restrict  */)(buf),
                    (socklen_t )46);
#line 187
    log_msg(3, "destination %s unreachable", tmp);
    }
#line 188
    return (0);
  }
  {
#line 190
  tmp___1 = has_tor_prefix(& ihd->ip6_src);
  }
#line 190
  if (! tmp___1) {
    {
#line 192
    log_msg(3, "source address invalid. Remote ocat could not reply");
    }
#line 193
    return (0);
  }
  {
#line 195
  tmp___2 = ntohs((uint16_t )ihd->ip6_ctlun.ip6_un1.ip6_un1_plen);
  }
#line 195
  return ((int )tmp___2);
}
}
#line 199 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void cleanup_socket(int fd , OcatPeer_t *peer ) 
{ 


  {
  {
#line 201
  log_msg(1030, "fd %d reached EOF, closing.", fd);
#line 202
  oe_close(fd);
#line 203
  lock_peers();
#line 204
  delete_peer(peer);
#line 205
  unlock_peers();
  }
#line 206
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int set_peer_dest(struct in6_addr *dest , struct in6_addr  const  *addr ) 
{ 
  int tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___0 ;

  {
  {
#line 241
  tmp = has_tor_prefix(addr);
  }
#line 241
  if (! tmp) {
#line 244
    return (-1);
  }
#line 247
  __a = addr;
#line 247
  __b = (struct in6_addr  const  *)(& setup_.ocat_addr);
#line 247
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 247
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 247
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 247
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 247
          tmp___0 = 1;
        } else {
#line 247
          tmp___0 = 0;
        }
      } else {
#line 247
        tmp___0 = 0;
      }
    } else {
#line 247
      tmp___0 = 0;
    }
  } else {
#line 247
    tmp___0 = 0;
  }
#line 247
  if (tmp___0) {
#line 250
    return (-1);
  }
#line 253
  *dest = (struct in6_addr )*addr;
#line 254
  return (0);
}
}
#line 259 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void set_select_timeout(struct timeval *tv ) 
{ 
  int tmp ;

  {
  {
#line 261
  tmp = rand();
#line 261
  tv->tv_usec = (__suseconds_t )(tmp % 1000000);
#line 262
  tv->tv_sec = 10L + (tv->tv_usec & 1L);
  }
#line 264
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void set_tunheader(char *buf , uint32_t tunhdr ) 
{ 
  uint32_t *ibuf ;

  {
#line 269
  ibuf = (uint32_t *)buf;
#line 270
  *ibuf = tunhdr;
#line 271
  return;
}
}
#line 274 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
uint32_t get_tunheader(char *buf ) 
{ 
  uint32_t *ibuf ;

  {
#line 276
  ibuf = (uint32_t *)buf;
#line 277
  return (*ibuf);
}
}
#line 281 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void *socket_receiver(void *p ) 
{ 
  int maxfd ;
  int len ;
  char buf[65580] ;
  char addr[46] ;
  fd_set rset ;
  OcatPeer_t *peer ;
  struct in6_addr *in6 ;
  int drop ;
  struct ether_header *eh ;
  struct timeval tv ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __d0 ;
  int __d1 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  uint16_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  uint32_t tmp___12 ;
  char const   *tmp___13 ;
  struct in6_addr  const  *__a ;
  int tmp___14 ;
  ssize_t tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;

  {
  {
#line 289
  drop = 0;
#line 290
  eh = (struct ether_header *)(buf + 4);
#line 293
  tmp___1 = pipe((int *)(lpfd_));
  }
#line 293
  if (tmp___1 < 0) {
    {
#line 294
    tmp = __errno_location();
#line 294
    tmp___0 = strerror(*tmp);
#line 294
    log_msg(0, "could not create pipe for socket_receiver: \"%s\"", tmp___0);
#line 294
    exit(1);
    }
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp___2 = term_req();
    }
#line 299
    if (tmp___2) {
#line 300
      goto while_break;
    }
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.__fds_bits[0]): "memory");
#line 302
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 303
    rset.__fds_bits[lpfd_[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << lpfd_[0] % (8 * (int )sizeof(__fd_mask ));
#line 304
    maxfd = lpfd_[0];
#line 307
    lock_peers();
#line 308
    peer = get_first_peer();
    }
    {
#line 308
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 308
      if (! peer) {
#line 308
        goto while_break___1;
      }
      {
#line 310
      lock_peer(peer);
      }
#line 312
      if (peer->state != 1) {
        {
#line 314
        unlock_peer(peer);
        }
#line 315
        goto __Cont;
      }
#line 318
      if (peer->tcpfd >= 1024) {
        {
#line 319
        log_msg(0, "%d >= FD_SETIZE(%d)", peer->tcpfd, 1024);
#line 319
        exit(1);
        }
      }
#line 321
      rset.__fds_bits[peer->tcpfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << peer->tcpfd % (8 * (int )sizeof(__fd_mask ));
#line 322
      if (peer->tcpfd > maxfd) {
#line 323
        maxfd = peer->tcpfd;
      }
      {
#line 324
      unlock_peer(peer);
      }
      __Cont: /* CIL Label */ 
#line 308
      peer = peer->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 326
    unlock_peers();
#line 328
    set_select_timeout(& tv);
#line 330
    maxfd = select(maxfd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 330
    if (maxfd == -1) {
      {
#line 332
      tmp___3 = __errno_location();
#line 332
      tmp___4 = strerror(*tmp___3);
#line 332
      log_msg(3, "select encountered error: \"%s\", restarting", tmp___4);
      }
#line 333
      goto __Cont___0;
    }
#line 337
    if ((rset.__fds_bits[lpfd_[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << lpfd_[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 339
      read(lpfd_[0], (void *)(buf), (size_t )65576);
#line 340
      maxfd --;
      }
    }
#line 343
    peer = (OcatPeer_t *)((void *)0);
    {
#line 344
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 344
      if (! maxfd) {
#line 344
        goto while_break___2;
      }
      {
#line 348
      lock_peers();
      }
#line 349
      if (! peer) {
        {
#line 350
        peer = get_first_peer();
        }
      } else {
#line 351
        peer = peer->next;
#line 351
        if (! peer) {
          {
#line 353
          log_msg(0, "fd %d ready but no peer found");
#line 354
          unlock_peers();
          }
#line 355
          goto while_break___2;
        }
      }
      {
#line 357
      lock_peer(peer);
#line 358
      unlock_peers();
      }
#line 360
      if (peer->state != 1) {
        {
#line 362
        unlock_peer(peer);
        }
#line 363
        goto while_continue___2;
      }
#line 366
      if (! ((rset.__fds_bits[peer->tcpfd / (8 * (int )sizeof(__fd_mask ))] & (1L << peer->tcpfd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
        {
#line 368
        unlock_peer(peer);
        }
#line 369
        goto while_continue___2;
      }
      {
#line 372
      maxfd --;
#line 376
      tmp___5 = read(peer->tcpfd, (void *)(peer->fragbuf + peer->fraglen), (size_t )(65576 - peer->fraglen));
#line 376
      len = (int )tmp___5;
      }
#line 376
      if (len == -1) {
        {
#line 380
        unlock_peer(peer);
        }
#line 381
        goto while_continue___2;
      }
#line 386
      if (! len) {
        {
#line 388
        log_msg(1030, "fd %d reached EOF, closing.", peer->tcpfd);
#line 389
        oe_close(peer->tcpfd);
        }
#line 391
        if (peer->perm) {
          {
#line 394
          socks_queue(peer->addr, 1);
          }
        }
        {
#line 396
        unlock_peer(peer);
#line 400
        lock_peers();
#line 401
        delete_peer(peer);
#line 402
        unlock_peers();
        }
#line 404
        goto while_continue___2;
      }
      {
#line 407
      peer->fraglen += len;
#line 409
      peer->time = time((time_t *)((void *)0));
#line 410
      peer->in += (unsigned long )len;
      }
      {
#line 412
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 412
        if (! peer->fraglen) {
#line 412
          goto while_break___3;
        }
#line 415
        if (((int )*(peer->fragbuf + 0) & 240) == 96) {
#line 418
          if ((unsigned long )peer->fraglen < sizeof(struct ip6_hdr )) {
#line 421
            goto while_break___3;
          } else {
            {
#line 418
            tmp___6 = ntohs(((struct ip6_hdr *)peer->fragbuf)->ip6_ctlun.ip6_un1.ip6_un1_plen);
            }
#line 418
            if ((unsigned long )peer->fraglen < (unsigned long )tmp___6 + sizeof(struct ip6_hdr )) {
#line 421
              goto while_break___3;
            }
          }
          {
#line 424
          tmp___7 = ntohs(((struct ip6_hdr *)peer->fragbuf)->ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 424
          len = (int )((unsigned long )tmp___7 + sizeof(struct ip6_hdr ));
#line 425
          *(peer->tunhdr) = setup_.fhd_key[1];
          }
        } else
#line 428
        if (((int )*(peer->fragbuf + 0) & 240) == 64) {
#line 430
          if (((int )*(peer->fragbuf + 0) & 15) < 5) {
#line 433
            peer->fraglen = 0;
#line 434
            goto while_break___3;
          }
#line 450
          if ((unsigned long )peer->fraglen < sizeof(struct iphdr )) {
#line 453
            goto while_break___3;
          } else {
            {
#line 450
            tmp___8 = ntohs(((struct iphdr *)peer->fragbuf)->tot_len);
            }
#line 450
            if (peer->fraglen < (int )tmp___8) {
#line 453
              goto while_break___3;
            }
          }
          {
#line 456
          tmp___9 = ntohs(((struct iphdr *)peer->fragbuf)->tot_len);
#line 456
          len = (int )tmp___9;
#line 457
          *(peer->tunhdr) = setup_.fhd_key[0];
          }
        } else {
#line 466
          len = 1;
#line 467
          drop = 1;
#line 468
          goto while_break___3;
        }
#line 472
        if (! setup_.unidirectional) {
#line 472
          if (! drop) {
#line 472
            __a = (struct in6_addr  const  *)(& peer->addr);
#line 472
            if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 472
              if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 472
                if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 472
                  if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 472
                    tmp___14 = 1;
                  } else {
#line 472
                    tmp___14 = 0;
                  }
                } else {
#line 472
                  tmp___14 = 0;
                }
              } else {
#line 472
                tmp___14 = 0;
              }
            } else {
#line 472
              tmp___14 = 0;
            }
#line 472
            if (tmp___14) {
#line 474
              if (*(peer->tunhdr) == setup_.fhd_key[1]) {
                {
#line 477
                tmp___10 = set_peer_dest(& peer->addr, (struct in6_addr  const  *)(& ((struct ip6_hdr *)peer->fragbuf)->ip6_src));
                }
#line 477
                if (tmp___10) {
#line 478
                  drop = 1;
                }
              } else
#line 480
              if (*(peer->tunhdr) == setup_.fhd_key[0]) {
                {
#line 484
                tmp___12 = ntohl(((struct iphdr *)peer->fragbuf)->saddr);
#line 484
                in6 = ipv4_lookup_route(tmp___12);
                }
#line 484
                if (in6) {
                  {
#line 495
                  tmp___11 = set_peer_dest(& peer->addr, (struct in6_addr  const  *)in6);
                  }
#line 495
                  if (tmp___11) {
#line 496
                    drop = 1;
                  }
                } else {
#line 489
                  drop = 1;
                }
              }
#line 500
              if (! drop) {
                {
#line 501
                tmp___13 = inet_ntop(10, (void const   */* __restrict  */)(& peer->addr),
                                     (char */* __restrict  */)(addr), (socklen_t )46);
#line 501
                log_msg(1030, "incoming connection on %d from %s is now identified",
                        peer->tcpfd, tmp___13);
                }
              }
            }
          }
        }
#line 505
        if (! drop) {
#line 508
          if (! setup_.use_tap) {
            {
#line 511
            tmp___15 = write(setup_.tunfd[1], (void const   *)((char *)peer->tunhdr + 0),
                             (size_t )(len + 4));
            }
#line 511
            if (tmp___15 != (ssize_t )(len + 4)) {
              {
#line 512
              log_msg(3, "could not write %d bytes to tunnel %d", len + 4, setup_.tunfd[1]);
              }
            }
          } else
#line 515
          if (*(peer->tunhdr) == setup_.fhd_key[1]) {
            {
#line 520
            memset((void *)(eh->ether_dhost), 0, (size_t )6);
#line 521
            tmp___17 = mac_set((struct in6_addr  const  *)(& ((struct ip6_hdr *)peer->fragbuf)->ip6_dst),
                               eh->ether_dhost);
            }
#line 521
            if (tmp___17 == -1) {
              {
#line 524
              ndp_solicit((struct in6_addr  const  *)(& ((struct ip6_hdr *)peer->fragbuf)->ip6_src),
                          (struct in6_addr  const  *)(& ((struct ip6_hdr *)peer->fragbuf)->ip6_dst));
              }
            } else {
              {
#line 528
              set_tunheader(buf, *(peer->tunhdr));
#line 529
              memcpy((void */* __restrict  */)((buf + 4) + sizeof(struct ether_header )),
                     (void const   */* __restrict  */)peer->fragbuf, (size_t )len);
#line 530
              memcpy((void */* __restrict  */)(eh->ether_shost), (void const   */* __restrict  */)(setup_.ocat_hwaddr),
                     (size_t )6);
              }
#line 532
              if (*(peer->tunhdr) == setup_.fhd_key[1]) {
                {
#line 533
                eh->ether_type = htons((uint16_t )34525);
                }
              } else
#line 534
              if (*(peer->tunhdr) == setup_.fhd_key[0]) {
                {
#line 535
                eh->ether_type = htons((uint16_t )2048);
                }
              }
              {
#line 537
              tmp___16 = write(setup_.tunfd[1], (void const   *)(buf + 0), (unsigned long )(len + 4) + sizeof(struct ether_header ));
              }
#line 537
              if ((unsigned long )tmp___16 != (unsigned long )(len + 4) + sizeof(struct ether_header )) {
                {
#line 538
                log_msg(3, "could not write %d bytes to tunnel %d", (unsigned long )(len + 4) + sizeof(struct ether_header ),
                        setup_.tunfd[1]);
                }
              }
            }
          }
        } else {
          {
#line 548
          log_msg(3, "dropping packet with %d bytes", len);
#line 549
          drop = 0;
          }
        }
#line 552
        peer->fraglen -= len;
#line 553
        if (peer->fraglen) {
          {
#line 556
          memmove((void *)peer->fragbuf, (void const   *)(peer->fragbuf + len), (size_t )(65576 - len));
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 563
      unlock_peer(peer);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 568
  oe_close(lpfd_[0]);
#line 569
  oe_close(lpfd_[1]);
  }
#line 571
  return ((void *)0);
}
}
#line 575 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void set_nonblock(int fd ) 
{ 
  long flags ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 579
  tmp___1 = fcntl(fd, 3, 0);
#line 579
  flags = (long )tmp___1;
  }
#line 579
  if (flags == -1L) {
    {
#line 581
    tmp = __errno_location();
#line 581
    tmp___0 = strerror(*tmp);
#line 581
    log_msg(3, "could not get socket flags for %d: \"%s\"", fd, tmp___0);
#line 582
    flags = 0L;
    }
  }
  {
#line 586
  tmp___4 = fcntl(fd, 4, flags | 2048L);
  }
#line 586
  if (tmp___4 == -1) {
    {
#line 587
    tmp___2 = __errno_location();
#line 587
    tmp___3 = strerror(*tmp___2);
#line 587
    log_msg(3, "could not set O_NONBLOCK for %d: \"%s\"", fd, tmp___3);
    }
  }
#line 588
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int insert_peer(int fd , SocksQueue_t const   *sq , time_t dly ) 
{ 
  OcatPeer_t *peer ;
  time_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 595
  log_msg(1030, "inserting peer fd %d to active peer list", fd);
#line 597
  set_nonblock(fd);
#line 599
  lock_peers();
#line 600
  peer = get_empty_peer();
  }
#line 600
  if (! peer) {
    {
#line 602
    unlock_peers();
#line 603
    log_msg(3, "could not get new empty peer");
    }
#line 604
    return (0);
  }
  {
#line 606
  lock_peer(peer);
#line 607
  unlock_peers();
#line 609
  peer->tcpfd = fd;
#line 610
  peer->state = 1;
#line 611
  tmp = time((time_t *)((void *)0));
#line 611
  peer->time = tmp;
#line 611
  peer->otime = tmp;
#line 612
  peer->sdelay = dly;
  }
#line 613
  if (sq) {
#line 616
    peer->addr = *((struct in6_addr *)(& sq->addr));
#line 617
    peer->dir = 1;
#line 618
    peer->perm = (int )sq->perm;
  } else {
#line 621
    peer->dir = 0;
  }
  {
#line 622
  unlock_peer(peer);
#line 626
  tmp___2 = write(lpfd_[1], (void const   *)(& fd), (size_t )1);
  }
#line 626
  if (tmp___2 != 1L) {
    {
#line 627
    tmp___0 = __errno_location();
#line 627
    tmp___1 = strerror(*tmp___0);
#line 627
    log_msg(0, "couldn\'t write to socket_receiver pipe: \"%s\"", tmp___1);
    }
  }
#line 629
  return (1);
}
}
#line 633 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int insert_anon_peer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 635
  tmp = insert_peer(fd, (SocksQueue_t const   *)((void *)0), (time_t )0);
  }
#line 635
  return (tmp);
}
}
#line 639 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int create_listener(struct sockaddr *addr , int sock_len ) 
{ 
  int family ;
  int fd ;
  int so ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 646
  if ((int )addr->sa_family == 2) {
#line 646
    goto case_2;
  }
#line 649
  if ((int )addr->sa_family == 10) {
#line 649
    goto case_10;
  }
#line 652
  goto switch_default;
  case_2: /* CIL Label */ 
#line 647
  family = 2;
#line 648
  goto switch_break;
  case_10: /* CIL Label */ 
#line 650
  family = 10;
#line 651
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 653
  log_msg(0, "unknown address family %d", (int )addr->sa_family);
  }
#line 654
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 657
  fd = socket(family, 1, 0);
  }
#line 657
  if (fd < 0) {
    {
#line 659
    tmp = __errno_location();
#line 659
    tmp___0 = strerror(*tmp);
#line 659
    log_msg(0, "could not create listener socker: \"%s\"", tmp___0);
    }
#line 660
    return (-1);
  }
  {
#line 663
  so = 1;
#line 664
  tmp___3 = setsockopt(fd, 1, 2, (void const   *)(& so), (socklen_t )sizeof(so));
  }
#line 664
  if (tmp___3 == -1) {
    {
#line 665
    tmp___1 = __errno_location();
#line 665
    tmp___2 = strerror(*tmp___1);
#line 665
    log_msg(4, "could not set socket %d to SO_REUSEADDR: \"%s\"", fd, tmp___2);
    }
  }
  {
#line 666
  tmp___6 = bind(fd, (struct sockaddr  const  *)addr, (socklen_t )sock_len);
  }
#line 666
  if (tmp___6 == -1) {
    {
#line 668
    tmp___4 = __errno_location();
#line 668
    tmp___5 = strerror(*tmp___4);
#line 668
    log_msg(0, "could not bind listener %d: \"%s\"", fd, tmp___5);
#line 669
    oe_close(fd);
    }
#line 670
    return (-1);
  }
  {
#line 673
  tmp___9 = listen(fd, 32);
  }
#line 673
  if (tmp___9 < 0) {
    {
#line 675
    tmp___7 = __errno_location();
#line 675
    tmp___8 = strerror(*tmp___7);
#line 675
    log_msg(0, "could not bring listener %d to listening state: \"%s\"", fd, tmp___8);
#line 676
    oe_close(fd);
    }
#line 677
    return (-1);
  }
#line 681
  return (fd);
}
}
#line 697 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int run_listeners(struct sockaddr **addr , int *sockfd , int cnt , int (*action_accept)(int  ) ) 
{ 
  int fd ;
  struct sockaddr_in6 in6 ;
  fd_set rset ;
  int maxfd ;
  int i ;
  socklen_t alen ;
  char iabuf[46] ;
  struct timeval tv ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int __d0 ;
  int __d1 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct in6_addr *tmp___5 ;
  uint16_t tmp___6 ;

  {
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (i < cnt)) {
#line 707
      goto while_break;
    }
#line 710
    if ((int )(*(addr + i))->sa_family == 2) {
#line 710
      tmp___1 = sizeof(struct sockaddr_in );
    } else {
#line 710
      if ((int )(*(addr + i))->sa_family == 10) {
#line 710
        tmp___0 = sizeof(struct sockaddr_in6 );
      } else {
#line 710
        tmp___0 = 0UL;
      }
#line 710
      tmp___1 = tmp___0;
    }
    {
#line 710
    tmp = create_listener(*(addr + i), (int )tmp___1);
#line 710
    *(sockfd + i) = tmp;
    }
#line 710
    if (tmp == -1) {
      {
#line 711
      log_msg(0, "exiting");
#line 711
      exit(1);
      }
    }
#line 707
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 714
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 717
    tmp___2 = term_req();
    }
#line 717
    if (tmp___2) {
#line 718
      goto while_break___0;
    }
    {
#line 721
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 721
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.__fds_bits[0]): "memory");
#line 721
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 722
    maxfd = -1;
#line 723
    i = 0;
    {
#line 723
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 723
      if (! (i < cnt)) {
#line 723
        goto while_break___2;
      }
#line 725
      if (*(sockfd + i) == -1) {
#line 726
        goto __Cont;
      }
#line 728
      rset.__fds_bits[*(sockfd + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(sockfd + i) % (8 * (int )sizeof(__fd_mask ));
#line 729
      if (*(sockfd + i) > maxfd) {
#line 730
        maxfd = *(sockfd + i);
      }
      __Cont: /* CIL Label */ 
#line 723
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 733
    if (maxfd == -1) {
#line 736
      goto while_break___0;
    }
    {
#line 739
    set_select_timeout(& tv);
#line 741
    maxfd = select(maxfd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 741
    if (maxfd == -1) {
#line 744
      goto __Cont___0;
    }
#line 748
    i = 0;
    {
#line 748
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 748
      if (maxfd) {
#line 748
        if (! (i < cnt)) {
#line 748
          goto while_break___3;
        }
      } else {
#line 748
        goto while_break___3;
      }
#line 751
      if (! ((rset.__fds_bits[*(sockfd + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(sockfd + i) % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 752
        goto __Cont___1;
      }
      {
#line 753
      maxfd --;
#line 754
      alen = (socklen_t )sizeof(in6);
#line 756
      fd = accept(*(sockfd + i), (struct sockaddr */* __restrict  */)((struct sockaddr *)(& in6)),
                  (socklen_t */* __restrict  */)(& alen));
      }
#line 756
      if (fd < 0) {
        {
#line 758
        tmp___3 = __errno_location();
#line 758
        tmp___4 = strerror(*tmp___3);
#line 758
        log_msg(3, "error accepting connection on %d: \"%s\"", *(sockfd + i), tmp___4);
        }
#line 760
        goto __Cont___1;
      }
#line 763
      if ((int )in6.sin6_family == 10) {
#line 763
        tmp___5 = & in6.sin6_addr;
      } else {
#line 763
        tmp___5 = (struct in6_addr *)((void *)(& ((struct sockaddr_in *)(& in6))->sin_addr));
      }
      {
#line 763
      inet_ntop((int )in6.sin6_family, (void const   */* __restrict  */)tmp___5, (char */* __restrict  */)(iabuf),
                (socklen_t )46);
#line 767
      tmp___6 = ntohs(in6.sin6_port);
#line 767
      log_msg(1030, "connection %d [%d] accepted on listener %d from %s port %d",
              fd, i, *(sockfd + i), iabuf, (int )tmp___6);
#line 768
      (*action_accept)(fd);
      }
      __Cont___1: /* CIL Label */ 
#line 748
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 773
  i = 0;
  {
#line 773
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 773
    if (! (i < cnt)) {
#line 773
      goto while_break___4;
    }
    {
#line 774
    oe_close(*(sockfd + i));
#line 773
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 777
  return (0);
}
}
#line 781 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void *socket_acceptor(void *p ) 
{ 


  {
  {
#line 783
  run_listeners(setup_.oc_listen, setup_.oc_listen_fd, setup_.oc_listen_cnt, & insert_anon_peer);
  }
#line 784
  return ((void *)0);
}
}
#line 788 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void packet_forwarder(void) 
{ 
  char buf[65580] ;
  int rlen ;
  struct in6_addr *dest ;
  struct in_addr in ;
  struct ether_header *eh ;
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  int tmp___10 ;

  {
#line 794
  eh = (struct ether_header *)(& buf[4]);
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 806
    tmp = term_req();
    }
#line 806
    if (tmp) {
#line 807
      goto while_break;
    }
    {
#line 814
    tmp___1 = read(setup_.tunfd[0], (void *)(buf + 0), (size_t )65580);
#line 814
    rlen = (int )tmp___1;
    }
#line 814
    if (rlen == -1) {
      {
#line 816
      tmp___0 = __errno_location();
#line 816
      rlen = *tmp___0;
      }
#line 818
      if (rlen == 4) {
#line 821
        if (setup_.sig_term) {
          {
#line 823
          log_msg(5, "caught termination request");
#line 825
          set_term_req();
          }
        }
#line 827
        if (setup_.sig_usr1) {
          {
#line 829
          lock_setup();
#line 830
          setup_.clear_stats = 1;
#line 831
          unlock_setup();
#line 832
          log_msg(5, "stats will be cleared after next stats output");
          }
        }
      }
#line 836
      goto __Cont;
    }
#line 838
    rlen = rlen;
#line 848
    if (! setup_.use_tap) {
#line 848
      if (rlen < 4) {
        {
#line 850
        log_msg(3, "frame effectively too short (rlen = %d)", rlen);
        }
#line 851
        goto __Cont;
      } else {
#line 848
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 848
    if (setup_.use_tap) {
#line 848
      if ((unsigned long )rlen < 4UL + sizeof(struct ether_header )) {
        {
#line 850
        log_msg(3, "frame effectively too short (rlen = %d)", rlen);
        }
#line 851
        goto __Cont;
      }
    }
#line 855
    if (setup_.use_tap) {
      {
#line 857
      tmp___2 = eth_check(buf, rlen);
      }
#line 857
      if (tmp___2) {
#line 858
        goto __Cont;
      }
      {
#line 862
      rlen = (int )((unsigned long )rlen - sizeof(struct ether_header ));
#line 863
      memmove((void *)eh, (void const   *)(eh + 1), (size_t )(rlen - 4));
      }
    }
    {
#line 877
    tmp___9 = get_tunheader(buf);
    }
#line 877
    if (tmp___9 == setup_.fhd_key[1]) {
#line 879
      if ((unsigned long )(rlen - 4) < sizeof(struct ip6_hdr )) {
#line 882
        goto __Cont;
      }
      {
#line 886
      tmp___3 = check_tor_prefix((struct ip6_hdr  const  *)((struct ip6_hdr *)(& buf[4])));
      }
#line 886
      if (! tmp___3) {
        {
#line 888
        log_msg(3, "dropping frame");
        }
#line 889
        goto __Cont;
      }
      {
#line 893
      dest = ipv6_lookup_route((struct in6_addr  const  *)(& ((struct ip6_hdr *)(& buf[4]))->ip6_dst));
      }
#line 893
      if (! dest) {
#line 894
        dest = & ((struct ip6_hdr *)(& buf[4]))->ip6_dst;
      }
    } else {
      {
#line 896
      tmp___8 = get_tunheader(buf);
      }
#line 896
      if (tmp___8 == setup_.fhd_key[0]) {
#line 898
        if ((unsigned long )(rlen - 4) < sizeof(struct iphdr )) {
#line 901
          goto __Cont;
        }
        {
#line 905
        in.s_addr = ((struct iphdr *)(& buf[4]))->daddr;
#line 909
        tmp___5 = ntohl(in.s_addr);
#line 909
        dest = ipv4_lookup_route(tmp___5);
        }
#line 909
        if (! dest) {
          {
#line 911
          tmp___4 = inet_ntoa(in);
#line 911
          log_msg(3, "no route to destination %s, dropping frame.", tmp___4);
          }
#line 912
          goto __Cont;
        }
      } else {
        {
#line 917
        tmp___6 = get_tunheader(buf);
#line 917
        tmp___7 = ntohl(tmp___6);
#line 917
        log_msg(3, "protocol 0x%08x not supported. dropping frame.", tmp___7);
        }
#line 918
        goto __Cont;
      }
    }
    {
#line 922
    tmp___10 = forward_packet((struct in6_addr  const  *)dest, (char const   *)(buf + 4),
                              rlen - 4);
    }
#line 922
    if (tmp___10 == -1) {
      {
#line 925
      socks_queue(*dest, 0);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return;
}
}
#line 935 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
int send_keepalive(OcatPeer_t *peer ) 
{ 
  struct ip6_hdr hdr ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 940
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 942
  hdr.ip6_dst = peer->addr;
#line 944
  hdr.ip6_src = setup_.ocat_addr;
#line 945
  hdr.ip6_ctlun.ip6_un2_vfc = (uint8_t )96;
#line 946
  hdr.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )59;
#line 947
  hdr.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )1;
#line 951
  tmp___1 = send(peer->tcpfd, (void const   *)(& hdr), sizeof(hdr), 64);
#line 951
  len = (int )tmp___1;
  }
#line 951
  if (len == -1) {
    {
#line 953
    tmp = __errno_location();
#line 953
    tmp___0 = strerror(*tmp);
#line 953
    log_msg(3, "could not send keepalive: %s", tmp___0);
    }
#line 954
    return (-1);
  }
#line 956
  peer->out += (unsigned long )len;
#line 957
  if ((unsigned long )len != sizeof(hdr)) {
    {
#line 959
    log_msg(3, "sending of %d bytes keepalive truncated to %d", sizeof(hdr), len);
    }
#line 960
    return (-1);
  }
#line 962
  return (0);
}
}
#line 966 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatroute.c"
void *socket_cleaner(void *ptr ) 
{ 
  OcatPeer_t *peer ;
  OcatPeer_t **p ;
  int stat_wup ;
  time_t act_time ;
  int tmp ;

  {
#line 969
  stat_wup = 0;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 975
    tmp = term_req();
    }
#line 975
    if (tmp) {
#line 976
      goto while_break;
    }
    {
#line 978
    sleep(10U);
#line 981
    act_time = time((time_t *)((void *)0));
    }
#line 984
    if (act_time - (time_t )stat_wup >= 600L) {
      {
#line 986
      stat_wup = (int )act_time;
#line 989
      lock_setup();
      }
#line 990
      if (setup_.clear_stats) {
#line 992
        setup_.clear_stats = 0;
      }
      {
#line 996
      unlock_setup();
      }
    }
    {
#line 1000
    mac_cleanup();
#line 1003
    lock_peers();
#line 1004
    p = get_first_peer_ptr();
    }
    {
#line 1004
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1004
      if (! *p) {
#line 1004
        goto while_break___0;
      }
      {
#line 1006
      lock_peer(*p);
      }
#line 1009
      if ((*p)->perm) {
#line 1012
        if (act_time - (*p)->time >= 60L) {
          {
#line 1014
          send_keepalive(*p);
#line 1015
          (*p)->time = act_time;
          }
        }
        {
#line 1017
        unlock_peer(*p);
        }
      } else
#line 1020
      if ((*p)->state) {
#line 1020
        if (act_time - (*p)->time >= 180L) {
          {
#line 1022
          peer = *p;
#line 1023
          *p = peer->next;
#line 1024
          log_msg(1030, "peer %d timed out, closing.", peer->tcpfd);
#line 1025
          oe_close(peer->tcpfd);
#line 1026
          unlock_peer(peer);
#line 1027
          delete_peer(peer);
          }
#line 1028
          if (! *p) {
#line 1031
            goto while_break___0;
          }
        } else {
          {
#line 1035
          unlock_peer(*p);
          }
        }
      } else {
        {
#line 1035
        unlock_peer(*p);
        }
      }
#line 1004
      p = & (*p)->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1037
    unlock_peers();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  return ((void *)0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 547 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
char *ipv6tonion(struct in6_addr  const  *ip6 , char *onion ) ;
#line 643
void print_socks_queue(FILE *f ) ;
#line 644
void sig_socks_connector(void) ;
#line 645
void *socks_connector_sel(void *p ) ;
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
static SocksQueue_t *socks_queue_  =    (SocksQueue_t *)((void *)0);
#line 39 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
int socks_send_request(SocksQueue_t const   *sq ) 
{ 
  int len ;
  int ret ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___3 ;
  char onion[1025] ;
  SocksHdr_t *shdr ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  ssize_t tmp___14 ;

  {
  {
#line 41
  ret = -1;
#line 42
  tmp___2 = strlen((char const   *)setup_.usrname);
  }
#line 42
  if (((8UL + (unsigned long )netdesc_[setup_.net_type].name_size) + tmp___2) + 2UL < 46UL) {
#line 42
    tmp___1 = 46UL;
  } else {
    {
#line 42
    tmp___0 = strlen((char const   *)setup_.usrname);
#line 42
    tmp___1 = ((sizeof(SocksHdr_t ) + (unsigned long )netdesc_[setup_.net_type].name_size) + tmp___0) + 2UL;
    }
  }
  {
#line 42
  __lengthofbuf = tmp___1;
#line 42
  tmp___3 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 42
  buf = (char *)tmp___3;
#line 43
  shdr = (SocksHdr_t *)buf;
  }
#line 48
  if (setup_.net_type == 1) {
#line 48
    if (setup_.hosts_lookup) {
      {
#line 50
      hosts_check();
#line 51
      ret = hosts_get_name(& sq->addr, onion, (int )sizeof(onion));
      }
    }
  }
#line 56
  if (ret == -1) {
    {
#line 58
    ipv6tonion(& sq->addr, onion);
#line 59
    strlcat(onion, (char const   *)netdesc_[setup_.net_type].domain, sizeof(onion));
    }
  }
  {
#line 63
  tmp___6 = inet_ntop(10, (void const   */* __restrict  */)(& sq->addr), (char */* __restrict  */)buf,
                      (socklen_t )(sizeof(*buf) * __lengthofbuf));
  }
#line 63
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
    {
#line 65
    tmp___4 = __errno_location();
#line 65
    tmp___5 = strerror(*tmp___4);
#line 65
    log_msg(4, "inet_ntop failed: \"%s\"", tmp___5);
#line 66
    *(buf + 0) = (char )'\000';
    }
  }
  {
#line 68
  log_msg(6, "trying to connect to \"%s\" [%s] on %d", onion, buf, sq->fd);
#line 71
  shdr->ver = (char)4;
#line 72
  shdr->cmd = (char)1;
#line 73
  shdr->port = htons(setup_.ocat_dest_port);
#line 74
  shdr->addr.s_addr = htonl((uint32_t )1);
#line 75
  tmp___7 = strlen((char const   *)setup_.usrname);
#line 75
  memcpy((void */* __restrict  */)(buf + sizeof(SocksHdr_t )), (void const   */* __restrict  */)setup_.usrname,
         tmp___7 + 1UL);
#line 76
  tmp___8 = strlen((char const   *)(onion));
#line 76
  tmp___9 = strlen((char const   *)setup_.usrname);
#line 76
  memcpy((void */* __restrict  */)(((buf + sizeof(SocksHdr_t )) + tmp___9) + 1), (void const   */* __restrict  */)(onion),
         tmp___8 + 1UL);
#line 77
  tmp___10 = strlen((char const   *)setup_.usrname);
#line 77
  tmp___11 = strlen((char const   *)(onion));
#line 77
  len = (int )(((sizeof(SocksHdr_t ) + tmp___10) + tmp___11) + 2UL);
#line 78
  tmp___14 = write((int )sq->fd, (void const   *)shdr, (size_t )len);
#line 78
  ret = (int )tmp___14;
  }
#line 78
  if (ret == -1) {
    {
#line 80
    tmp___12 = __errno_location();
#line 80
    tmp___13 = strerror(*tmp___12);
#line 80
    log_msg(3, "error writing %d bytes to fd %d: \"%s\"", len, sq->fd, tmp___13);
    }
#line 81
    return (-1);
  }
#line 83
  if (ret < len) {
    {
#line 85
    log_msg(3, "SOCKS request truncated to %d of %d bytes", ret, len);
    }
#line 86
    return (-1);
  }
#line 89
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
int socks_rec_response(SocksQueue_t *sq ) 
{ 
  SocksHdr_t shdr ;
  int ret ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 98
  len = (int )sizeof(SocksHdr_t );
#line 99
  tmp___1 = read(sq->fd, (void *)(& shdr), (size_t )len);
#line 99
  ret = (int )tmp___1;
  }
#line 99
  if (ret == -1) {
    {
#line 101
    tmp = __errno_location();
#line 101
    tmp___0 = strerror(*tmp);
#line 101
    log_msg(3, "reading SOCKS response on fd %d failed: \"%s\"", sq->fd, tmp___0);
    }
#line 102
    return (-1);
  }
#line 104
  if (ret < len) {
    {
#line 106
    log_msg(3, "SOCKS response truncated to %d of %d bytes", ret, len);
    }
#line 107
    return (-1);
  }
#line 111
  if (shdr.ver) {
    {
#line 113
    log_msg(3, "SOCKS request failed, reason = %d", (int )shdr.cmd);
    }
#line 114
    return (-1);
  } else
#line 111
  if ((int )shdr.cmd != 90) {
    {
#line 113
    log_msg(3, "SOCKS request failed, reason = %d", (int )shdr.cmd);
    }
#line 114
    return (-1);
  }
  {
#line 117
  log_msg(1030, "SOCKS connection successfully opened on fd %d", sq->fd);
  }
#line 118
  return (0);
}
}
#line 122 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
int socks_activate_peer(SocksQueue_t *sq ) 
{ 
  OcatPeer_t *peer ;
  time_t tmp ;

  {
  {
#line 126
  tmp = time((time_t *)((void *)0));
#line 126
  insert_peer(sq->fd, (SocksQueue_t const   *)sq, tmp - sq->connect_time);
#line 129
  lock_peers();
#line 130
  peer = search_peer((struct in6_addr  const  *)(& sq->addr));
  }
#line 130
  if (peer) {
    {
#line 131
    lock_peer(peer);
    }
  } else {
    {
#line 133
    log_msg(0, "newly inserted peer not found, fd = %d", sq->fd);
    }
  }
  {
#line 134
  unlock_peers();
  }
#line 135
  if (peer) {
    {
#line 137
    send_keepalive(peer);
#line 138
    unlock_peer(peer);
    }
  }
#line 141
  return (0);
}
}
#line 145 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_pipe_request(SocksQueue_t const   *sq ) 
{ 
  fd_set wset ;
  int maxfd ;
  int len ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 149
  len = (int )sizeof(*sq);
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& wset.__fds_bits[0]): "memory");
#line 151
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  wset.__fds_bits[setup_.socksfd[1] / (8 * (int )sizeof(__fd_mask ))] |= 1L << setup_.socksfd[1] % (8 * (int )sizeof(__fd_mask ));
#line 153
  maxfd = setup_.socksfd[1];
#line 158
  maxfd = select(maxfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& wset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
  }
#line 158
  if (maxfd == -1) {
    {
#line 160
    tmp = __errno_location();
#line 160
    tmp___0 = strerror(*tmp);
#line 160
    log_msg(0, "select encountered error: \"%s\", restarting", tmp___0);
    }
#line 161
    return;
  }
#line 166
  if (maxfd) {
#line 166
    if ((wset.__fds_bits[setup_.socksfd[1] / (8 * (int )sizeof(__fd_mask ))] & (1L << setup_.socksfd[1] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 170
      tmp___3 = write(setup_.socksfd[1], (void const   *)sq, (size_t )len);
#line 170
      ret = (int )tmp___3;
      }
#line 170
      if (ret == -1) {
        {
#line 172
        tmp___1 = __errno_location();
#line 172
        tmp___2 = strerror(*tmp___1);
#line 172
        log_msg(4, "error writing to SOCKS request pipe fd %d: \"%s\"", setup_.socksfd[1],
                tmp___2);
        }
      } else
#line 174
      if (ret < len) {
        {
#line 176
        log_msg(4, "write to SOCKS request pipe fd %d truncated to %d bytes of %d",
                setup_.socksfd[1], ret, len);
        }
      }
    } else {
      {
#line 184
      log_msg(4, "fd %d not in write set", setup_.socksfd[1]);
      }
    }
  } else {
    {
#line 184
    log_msg(4, "fd %d not in write set", setup_.socksfd[1]);
    }
  }
#line 185
  return;
}
}
#line 188 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void sig_socks_connector(void) 
{ 
  SocksQueue_t sq ;

  {
  {
#line 192
  memset((void *)(& sq), 0, sizeof(sq));
#line 193
  socks_pipe_request((SocksQueue_t const   *)(& sq));
  }
#line 194
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_enqueue(SocksQueue_t const   *sq ) 
{ 
  SocksQueue_t *squeue ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 205
  tmp___1 = malloc(sizeof(SocksQueue_t ));
#line 205
  squeue = (SocksQueue_t *)tmp___1;
  }
#line 205
  if (! squeue) {
    {
#line 206
    tmp = __errno_location();
#line 206
    tmp___0 = strerror(*tmp);
#line 206
    log_msg(0, "could not get memory for SocksQueue entry: \"%s\"", tmp___0);
#line 206
    exit(1);
    }
  }
  {
#line 207
  memcpy((void */* __restrict  */)squeue, (void const   */* __restrict  */)sq, sizeof(*squeue));
#line 209
  squeue->next = socks_queue_;
#line 210
  socks_queue_ = squeue;
  }
#line 211
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_queue(struct in6_addr addr , int perm ) 
{ 
  SocksQueue_t *squeue ;
  SocksQueue_t sq ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
#line 224
  if (! (setup_.__annonCompField5.socks_dst)->sin_family) {
#line 225
    return;
  }
#line 227
  squeue = socks_queue_;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! squeue) {
#line 227
      goto while_break;
    }
#line 228
    __a = (struct in6_addr  const  *)(& squeue->addr);
#line 228
    __b = (struct in6_addr  const  *)(& addr);
#line 228
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 228
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 228
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 228
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 228
            tmp = 1;
          } else {
#line 228
            tmp = 0;
          }
        } else {
#line 228
          tmp = 0;
        }
      } else {
#line 228
        tmp = 0;
      }
    } else {
#line 228
      tmp = 0;
    }
#line 228
    if (tmp) {
#line 229
      goto while_break;
    }
#line 227
    squeue = squeue->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (! squeue) {
    {
#line 234
    memset((void *)(& sq), 0, sizeof(sq));
#line 235
    sq.addr = addr;
#line 236
    sq.perm = perm;
#line 238
    socks_pipe_request((SocksQueue_t const   *)(& sq));
    }
  }
#line 242
  return;
}
}
#line 248 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_unqueue(SocksQueue_t *squeue ) 
{ 
  SocksQueue_t **sq ;

  {
#line 252
  sq = & socks_queue_;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! *sq) {
#line 252
      goto while_break;
    }
#line 253
    if ((unsigned long )*sq == (unsigned long )squeue) {
      {
#line 255
      *sq = (*sq)->next;
#line 257
      free((void *)squeue);
      }
#line 258
      goto while_break;
    }
#line 252
    sq = & (*sq)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void print_socks_queue(FILE *f ) 
{ 
  SocksQueue_t sq ;

  {
  {
#line 267
  memset((void *)(& sq), 0, sizeof(sq));
#line 268
  sq.next = (SocksQueue_t *)f;
#line 269
  socks_pipe_request((SocksQueue_t const   *)(& sq));
  }
#line 270
  return;
}
}
#line 273 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_output_queue(FILE *f ) 
{ 
  int i ;
  char addrstr[46] ;
  char *onstr ;
  unsigned long __lengthofonstr ;
  void *tmp ;
  char buf[1024] ;
  SocksQueue_t *squeue ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 276
  __lengthofonstr = (unsigned long )netdesc_[setup_.net_type].name_size;
#line 276
  tmp = __builtin_alloca(sizeof(*onstr) * __lengthofonstr);
#line 276
  onstr = (char *)tmp;
#line 279
  squeue = socks_queue_;
#line 279
  i = 0;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! squeue) {
#line 279
      goto while_break;
    }
    {
#line 281
    tmp___2 = inet_ntop(10, (void const   */* __restrict  */)(& squeue->addr), (char */* __restrict  */)(addrstr),
                        (socklen_t )46);
    }
#line 281
    if (! tmp___2) {
      {
#line 283
      tmp___0 = __errno_location();
#line 283
      tmp___1 = strerror(*tmp___0);
#line 283
      log_msg(3, "inet_ntop returned NULL pointer: \"%s\"", tmp___1);
#line 284
      strlcpy(addrstr, "ERROR", (size_t )46);
      }
    }
#line 287
    if (squeue->perm) {
#line 287
      tmp___3 = "PERMANENT";
    } else {
#line 287
      tmp___3 = "TEMPORARY";
    }
    {
#line 287
    tmp___4 = ipv6tonion((struct in6_addr  const  *)(& squeue->addr), onstr);
#line 287
    snprintf((char */* __restrict  */)(buf), (size_t )1024, (char const   */* __restrict  */)"%d: %39s, %s%s, state = %d, %s(%d), retry = %d, connect_time = %d, restart_time = %d",
             i, addrstr, tmp___4, netdesc_[setup_.net_type].domain, squeue->state,
             tmp___3, squeue->perm, squeue->retry, (int )squeue->connect_time, (int )squeue->restart_time);
#line 300
    tmp___5 = strlen((char const   *)(buf));
#line 300
    write((int )((long )f), (void const   *)(buf), tmp___5);
#line 301
    write((int )((long )f), (void const   *)"\n", (size_t )1);
#line 279
    squeue = squeue->next;
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  write((int )((long )f), (void const   *)"\000", (size_t )1);
  }
#line 305
  return;
}
}
#line 335 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
int socks_tcp_connect(int fd , struct sockaddr *addr , int len ) 
{ 
  char astr[46] ;
  int *tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 338
  tmp___5 = connect(fd, (struct sockaddr  const  *)addr, (socklen_t )len);
  }
#line 338
  if (tmp___5 == -1) {
    {
#line 340
    tmp___4 = __errno_location();
    }
#line 340
    if (*tmp___4 != 115) {
      {
#line 342
      tmp = __errno_location();
#line 342
      tmp___0 = strerror(*tmp);
#line 342
      tmp___1 = ntohs((setup_.__annonCompField5.socks_dst)->sin_port);
      }
#line 342
      if ((int )(setup_.__annonCompField5.socks_dst)->sin_family == 2) {
#line 342
        tmp___2 = (char *)(& (setup_.__annonCompField5.socks_dst)->sin_addr);
      } else {
#line 342
        tmp___2 = (char *)(& (setup_.__annonCompField5.socks_dst6)->sin6_addr);
      }
      {
#line 342
      tmp___3 = inet_ntop((int )(setup_.__annonCompField5.socks_dst)->sin_family,
                          (void const   */* __restrict  */)tmp___2, (char */* __restrict  */)(astr),
                          (socklen_t )sizeof(astr));
#line 342
      log_msg(3, "connect() to SOCKS port %s:%d failed: \"%s\". Sleeping for %d seconds.",
              tmp___3, (int )tmp___1, tmp___0, 30);
      }
#line 346
      return (-1);
    }
  }
#line 353
  return (0);
}
}
#line 357 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void socks_reschedule(SocksQueue_t *squeue ) 
{ 
  time_t tmp ;

  {
  {
#line 359
  log_msg(3, "rescheduling SOCKS request");
  }
#line 360
  if (squeue->fd > 0) {
    {
#line 362
    oe_close(squeue->fd);
#line 363
    squeue->fd = 0;
    }
  }
  {
#line 365
  tmp = time((time_t *)((void *)0));
#line 365
  squeue->restart_time = tmp + 30L;
#line 366
  squeue->state = 0;
  }
#line 367
  return;
}
}
#line 370 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatsocks.c"
void *socks_connector_sel(void *p ) 
{ 
  fd_set rset ;
  fd_set wset ;
  int maxfd ;
  int len ;
  int so_err ;
  SocksQueue_t *squeue ;
  SocksQueue_t sq ;
  time_t t ;
  struct timeval tv ;
  socklen_t err_len ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  ssize_t tmp___11 ;
  struct in6_addr  const  *__a ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 373
  maxfd = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    tmp = term_req();
    }
#line 381
    if (tmp) {
#line 382
      return ((void *)0);
    }
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 384
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.__fds_bits[0]): "memory");
#line 384
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 385
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wset.__fds_bits[0]): "memory");
#line 385
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 386
    rset.__fds_bits[setup_.socksfd[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << setup_.socksfd[0] % (8 * (int )sizeof(__fd_mask ));
#line 386
    if (setup_.socksfd[0] > maxfd) {
#line 386
      maxfd = setup_.socksfd[0];
    } else {
#line 386
      maxfd = maxfd;
    }
    {
#line 387
    t = time((time_t *)((void *)0));
#line 389
    squeue = socks_queue_;
    }
    {
#line 389
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 389
      if (! squeue) {
#line 389
        goto while_break___2;
      }
      {
#line 393
      if (squeue->state == 0) {
#line 393
        goto case_0;
      }
#line 437
      if (squeue->state == 2) {
#line 437
        goto case_2;
      }
#line 391
      goto switch_break;
      case_0: /* CIL Label */ 
#line 401
      if (t < squeue->restart_time) {
#line 404
        goto __Cont;
      }
#line 408
      (squeue->retry) ++;
#line 409
      if (! squeue->perm) {
#line 409
        if (squeue->retry > 3) {
          {
#line 411
          log_msg(5, "temporary request failed %d times and will be removed", squeue->retry - 1);
#line 412
          squeue->state = 127;
          }
#line 413
          goto __Cont;
        }
      }
#line 417
      if ((int )(setup_.__annonCompField5.socks_dst)->sin_family == 2) {
#line 417
        tmp___3 = 2;
      } else {
#line 417
        tmp___3 = 10;
      }
      {
#line 417
      tmp___2 = socket(tmp___3, 1, 0);
#line 417
      squeue->fd = tmp___2;
      }
#line 417
      if (tmp___2 == -1) {
        {
#line 419
        tmp___0 = __errno_location();
#line 419
        tmp___1 = strerror(*tmp___0);
#line 419
        log_msg(3, "cannot create socket for new SOCKS request: \"%s\"", tmp___1);
        }
#line 420
        goto __Cont;
      }
      {
#line 423
      set_nonblock(squeue->fd);
#line 425
      squeue->connect_time = t;
      }
#line 426
      if ((int )((struct sockaddr *)setup_.__annonCompField5.socks_dst)->sa_family == 2) {
#line 426
        tmp___5 = sizeof(struct sockaddr_in );
      } else {
#line 426
        if ((int )((struct sockaddr *)setup_.__annonCompField5.socks_dst)->sa_family == 10) {
#line 426
          tmp___4 = sizeof(struct sockaddr_in6 );
        } else {
#line 426
          tmp___4 = 0UL;
        }
#line 426
        tmp___5 = tmp___4;
      }
      {
#line 426
      tmp___6 = socks_tcp_connect(squeue->fd, (struct sockaddr *)setup_.__annonCompField5.socks_dst,
                                  (int )tmp___5);
      }
#line 426
      if (tmp___6 == -1) {
        {
#line 428
        socks_reschedule(squeue);
        }
#line 429
        goto __Cont;
      }
#line 432
      squeue->state = 1;
#line 433
      wset.__fds_bits[squeue->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << squeue->fd % (8 * (int )sizeof(__fd_mask ));
#line 433
      if (squeue->fd > maxfd) {
#line 433
        maxfd = squeue->fd;
      } else {
#line 433
        maxfd = maxfd;
      }
#line 435
      goto switch_break;
      case_2: /* CIL Label */ 
#line 438
      rset.__fds_bits[squeue->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << squeue->fd % (8 * (int )sizeof(__fd_mask ));
#line 438
      if (squeue->fd > maxfd) {
#line 438
        maxfd = squeue->fd;
      } else {
#line 438
        maxfd = maxfd;
      }
#line 439
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 389
      squeue = squeue->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 444
    set_select_timeout(& tv);
#line 446
    maxfd = select(maxfd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)(& wset),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 446
    if (maxfd == -1) {
      {
#line 448
      tmp___7 = __errno_location();
#line 448
      tmp___8 = strerror(*tmp___7);
#line 448
      log_msg(0, "select encountered error: \"%s\", restarting", tmp___8);
      }
#line 449
      goto __Cont___0;
    }
#line 454
    if ((rset.__fds_bits[setup_.socksfd[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << setup_.socksfd[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 456
      maxfd --;
#line 457
      tmp___11 = read(setup_.socksfd[0], (void *)(& sq), sizeof(sq));
#line 457
      len = (int )tmp___11;
      }
#line 457
      if (len == -1) {
        {
#line 458
        tmp___9 = __errno_location();
#line 458
        tmp___10 = strerror(*tmp___9);
#line 458
        log_msg(3, "failed to read from SOCKS request pipe, fd = %d: \"%s\"", setup_.socksfd[0],
                tmp___10);
        }
      }
#line 460
      if ((unsigned long )len < sizeof(sq)) {
        {
#line 461
        log_msg(3, "read from SOCKS request pipe truncated to %d of %d bytes, ignoring.",
                len, sizeof(sq));
        }
      } else
#line 466
      if (sq.next) {
        {
#line 469
        socks_output_queue((FILE *)sq.next);
        }
      } else {
#line 471
        __a = (struct in6_addr  const  *)(& sq.addr);
#line 471
        if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 471
          if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 471
            if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 471
              if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 471
                tmp___12 = 1;
              } else {
#line 471
                tmp___12 = 0;
              }
            } else {
#line 471
              tmp___12 = 0;
            }
          } else {
#line 471
            tmp___12 = 0;
          }
        } else {
#line 471
          tmp___12 = 0;
        }
#line 471
        if (! tmp___12) {
          {
#line 478
          socks_enqueue((SocksQueue_t const   *)(& sq));
          }
        }
      }
    }
    {
#line 484
    t = time((time_t *)((void *)0));
#line 485
    squeue = socks_queue_;
    }
    {
#line 485
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 485
      if (maxfd) {
#line 485
        if (! squeue) {
#line 485
          goto while_break___3;
        }
      } else {
#line 485
        goto while_break___3;
      }
#line 488
      if ((wset.__fds_bits[squeue->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << squeue->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 490
        maxfd --;
#line 491
        if (squeue->state == 1) {
          {
#line 495
          err_len = (socklen_t )sizeof(so_err);
#line 496
          tmp___15 = getsockopt(squeue->fd, 1, 4, (void */* __restrict  */)(& so_err),
                                (socklen_t */* __restrict  */)(& err_len));
          }
#line 496
          if (tmp___15 == -1) {
            {
#line 498
            tmp___13 = __errno_location();
#line 498
            tmp___14 = strerror(*tmp___13);
#line 498
            log_msg(3, "getsockopt failed: \"%s\", rescheduling request", tmp___14);
#line 499
            socks_reschedule(squeue);
            }
#line 500
            goto __Cont___1;
          }
#line 502
          if (so_err) {
            {
#line 504
            tmp___16 = strerror(so_err);
#line 504
            log_msg(3, "getsockopt returned %d (\"%s\")", so_err, tmp___16);
#line 505
            socks_reschedule(squeue);
            }
#line 506
            goto __Cont___1;
          }
          {
#line 509
          tmp___17 = socks_send_request((SocksQueue_t const   *)squeue);
          }
#line 509
          if (tmp___17 == -1) {
            {
#line 511
            log_msg(3, "SOCKS request failed");
#line 512
            socks_reschedule(squeue);
            }
#line 513
            goto __Cont___1;
          }
#line 516
          squeue->state = 2;
        }
      }
#line 523
      if ((rset.__fds_bits[squeue->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << squeue->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 525
        maxfd --;
#line 526
        if (squeue->state == 2) {
          {
#line 528
          tmp___18 = socks_rec_response(squeue);
          }
#line 528
          if (tmp___18 == -1) {
            {
#line 530
            socks_reschedule(squeue);
            }
#line 531
            goto __Cont___1;
          }
          {
#line 535
          socks_activate_peer(squeue);
#line 536
          squeue->state = 127;
          }
        }
      }
      __Cont___1: /* CIL Label */ 
#line 485
      squeue = squeue->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 544
    squeue = socks_queue_;
    {
#line 544
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 544
      if (! squeue) {
#line 544
        goto while_break___4;
      }
#line 545
      if (squeue->state == 127) {
        {
#line 547
        socks_unqueue(squeue);
#line 549
        squeue = socks_queue_;
        }
#line 550
        if (! squeue) {
#line 553
          goto while_break___4;
        }
      }
#line 544
      squeue = squeue->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 359 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 658 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
void ipv6_print_routes(FILE *f ) ;
#line 659
int ipv6_parse_route(char const   *rs ) ;
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
static IPv6Route_t *v6route_  =    (IPv6Route_t *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
static int v6route_cnt_  =    0;
#line 35 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
static pthread_mutex_t v6route_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 42 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
void ipv6_reduce(struct in6_addr *net , int prefixlen ) 
{ 
  int i ;
  char m ;

  {
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < (128 - prefixlen) >> 3)) {
#line 47
      goto while_break;
    }
#line 48
    net->__in6_u.__u6_addr8[15 - i] = (uint8_t )0;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  m = (char )(255 << (8 - prefixlen % 8));
#line 51
  net->__in6_u.__u6_addr8[prefixlen >> 3] = (uint8_t )((int )net->__in6_u.__u6_addr8[prefixlen >> 3] & (int )m);
#line 53
  return;
}
}
#line 58 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
struct in6_addr *ipv6_lookup_route(struct in6_addr  const  *dest ) 
{ 
  struct in6_addr addr ;
  int i ;
  int n ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;
  struct in6_addr *tmp___0 ;

  {
  {
#line 63
  pthread_mutex_lock(& v6route_mutex_);
#line 64
  n = v6route_cnt_;
#line 65
  i = 0;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < n)) {
#line 65
      goto while_break;
    }
    {
#line 67
    addr = (struct in6_addr )*dest;
#line 68
    ipv6_reduce(& addr, (v6route_ + i)->prefixlen);
#line 69
    __a = (struct in6_addr  const  *)(& (v6route_ + i)->dest);
#line 69
    __b = (struct in6_addr  const  *)(& addr);
    }
#line 69
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 69
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 69
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 69
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 69
            tmp = 1;
          } else {
#line 69
            tmp = 0;
          }
        } else {
#line 69
          tmp = 0;
        }
      } else {
#line 69
        tmp = 0;
      }
    } else {
#line 69
      tmp = 0;
    }
#line 69
    if (tmp) {
#line 72
      goto while_break;
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  pthread_mutex_unlock(& v6route_mutex_);
  }
#line 76
  if (i < n) {
#line 76
    tmp___0 = & (v6route_ + i)->gw;
  } else {
#line 76
    tmp___0 = (struct in6_addr *)((void *)0);
  }
#line 76
  return (tmp___0);
}
}
#line 83 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
int ipv6_add_route(IPv6Route_t const   *route ) 
{ 
  int r ;
  IPv6Route_t *rt ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 85
  r = -1;
#line 88
  pthread_mutex_lock(& v6route_mutex_);
#line 89
  tmp___0 = realloc((void *)v6route_, sizeof(IPv6Route_t ) * (unsigned long )(v6route_cnt_ + 1));
#line 89
  rt = (IPv6Route_t *)tmp___0;
  }
#line 89
  if (rt) {
    {
#line 91
    v6route_ = rt;
#line 92
    r = v6route_cnt_;
#line 93
    tmp = v6route_cnt_;
#line 93
    v6route_cnt_ ++;
#line 93
    memcpy((void */* __restrict  */)(v6route_ + tmp), (void const   */* __restrict  */)route,
           sizeof(IPv6Route_t ));
    }
  }
  {
#line 95
  pthread_mutex_unlock(& v6route_mutex_);
  }
#line 96
  return (r);
}
}
#line 100 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
void ipv6_print(IPv6Route_t *route , void *f ) 
{ 
  char addr[46] ;

  {
  {
#line 104
  inet_ntop(10, (void const   */* __restrict  */)(& route->dest), (char */* __restrict  */)(addr),
            (socklen_t )46);
#line 105
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"IN6 %s %3d ",
          addr, route->prefixlen);
#line 106
  inet_ntop(10, (void const   */* __restrict  */)(& route->gw), (char */* __restrict  */)(addr),
            (socklen_t )46);
#line 107
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s %p\n",
          addr, route);
  }
#line 108
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
void ipv6_print_routes(FILE *f ) 
{ 
  int i ;

  {
  {
#line 115
  pthread_mutex_lock(& v6route_mutex_);
#line 116
  i = 0;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < v6route_cnt_)) {
#line 116
      goto while_break;
    }
    {
#line 117
    ipv6_print(v6route_ + i, (void *)f);
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  pthread_mutex_unlock(& v6route_mutex_);
  }
#line 119
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv6route.c"
int ipv6_parse_route(char const   *rs ) 
{ 
  size_t tmp ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___0 ;
  char *s ;
  char *b ;
  IPv6Route_t route6 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  long tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___8 ;
  struct in6_addr *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 127
  tmp = strlen(rs);
#line 127
  __lengthofbuf = tmp + 1UL;
#line 127
  tmp___0 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 127
  buf = (char *)tmp___0;
  }
#line 130
  if (! rs) {
#line 131
    return (-5);
  }
  {
#line 135
  tmp___1 = strlen(rs);
#line 135
  strlcpy(buf, rs, tmp___1 + 1UL);
#line 136
  s = strtok_r((char */* __restrict  */)buf, (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 136
  if (! s) {
#line 137
    return (-4);
  }
  {
#line 139
  tmp___2 = inet_pton(10, (char const   */* __restrict  */)s, (void */* __restrict  */)(& route6.dest));
  }
#line 139
  if (tmp___2 != 1) {
#line 140
    return (-4);
  }
  {
#line 142
  s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 142
  if (! s) {
#line 143
    return (-4);
  }
  {
#line 145
  tmp___3 = __errno_location();
#line 145
  *tmp___3 = 0;
#line 146
  tmp___4 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                   10);
#line 146
  route6.prefixlen = (int )tmp___4;
#line 147
  tmp___5 = __errno_location();
  }
#line 147
  if (*tmp___5) {
#line 148
    return (-4);
  }
#line 149
  if (route6.prefixlen < 0) {
#line 150
    return (-3);
  } else
#line 149
  if (route6.prefixlen > 128) {
#line 150
    return (-3);
  }
  {
#line 152
  s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 152
  if (! s) {
#line 153
    return (-4);
  }
  {
#line 155
  tmp___6 = inet_pton(10, (char const   */* __restrict  */)s, (void */* __restrict  */)(& route6.gw));
  }
#line 155
  if (tmp___6 != 1) {
#line 156
    return (-4);
  }
  {
#line 158
  tmp___7 = has_tor_prefix((struct in6_addr  const  *)(& route6.gw));
  }
#line 158
  if (! tmp___7) {
#line 159
    return (-6);
  }
#line 161
  __a = (struct in6_addr  const  *)(& route6.gw);
#line 161
  __b = (struct in6_addr  const  *)(& setup_.ocat_addr);
#line 161
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 161
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 161
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 161
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 161
          tmp___8 = 1;
        } else {
#line 161
          tmp___8 = 0;
        }
      } else {
#line 161
        tmp___8 = 0;
      }
    } else {
#line 161
      tmp___8 = 0;
    }
  } else {
#line 161
    tmp___8 = 0;
  }
#line 161
  if (tmp___8) {
#line 162
    return (-7);
  }
  {
#line 164
  ipv6_reduce(& route6.dest, route6.prefixlen);
#line 165
  tmp___9 = ipv6_lookup_route((struct in6_addr  const  *)(& route6.dest));
  }
#line 165
  if (tmp___9) {
#line 166
    return (-2);
  }
  {
#line 168
  tmp___10 = ipv6_add_route((IPv6Route_t const   *)(& route6));
  }
#line 168
  return (tmp___10);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 630 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
void print_mac_tbl(FILE *f ) ;
#line 637
uint16_t checksum(uint16_t const   *buf , int len ) ;
#line 638
void free_ckbuf(uint16_t *buf ) ;
#line 639
uint16_t *malloc_ckbuf(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                       uint16_t plen , uint8_t proto , void const   *payload ) ;
#line 29 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
static MACTable_t mac_tbl_[128]  ;
#line 30 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
static int mac_cnt_  =    0;
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
static pthread_mutex_t mac_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 48 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
void print_mac_tbl(FILE *f ) 
{ 
  int i ;
  char buf[46] ;
  char *tmp ;
  time_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 54
  pthread_mutex_lock(& mac_mutex_);
#line 56
  i = 0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < mac_cnt_)) {
#line 56
      goto while_break;
    }
    {
#line 58
    tmp = ether_ntoa_r((struct ether_addr  const  *)((struct ether_addr *)(mac_tbl_[i].hwaddr)),
                       buf);
#line 58
    tmp___0 = time((time_t *)((void *)0));
#line 58
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%3d %3d %s ",
            i, (int )(tmp___0 - mac_tbl_[i].age), tmp);
    }
#line 59
    if ((int )mac_tbl_[i].family == 10) {
#line 59
      tmp___1 = "IN6";
    } else {
#line 59
      tmp___1 = "IN ";
    }
    {
#line 59
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s ", tmp___1);
#line 60
    inet_ntop((int )mac_tbl_[i].family, (void const   */* __restrict  */)(& mac_tbl_[i].__annonCompField6.in6addr),
              (char */* __restrict  */)(buf), (socklen_t )46);
#line 61
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n", buf);
#line 56
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  pthread_mutex_unlock(& mac_mutex_);
  }
#line 65
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
void mac_cleanup(void) 
{ 
  int i ;
  time_t tmp ;

  {
  {
#line 77
  pthread_mutex_lock(& mac_mutex_);
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < mac_cnt_)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = time((time_t *)((void *)0));
    }
#line 80
    if (mac_tbl_[i].age + 120L < tmp) {
      {
#line 83
      memmove((void *)(& mac_tbl_[i]), (void const   *)(& mac_tbl_[i + 1]), sizeof(MACTable_t ) * (unsigned long )(128 - i));
#line 84
      mac_cnt_ --;
#line 85
      i --;
      }
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  pthread_mutex_unlock(& mac_mutex_);
  }
#line 89
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int mac_set(struct in6_addr  const  *in6 , uint8_t *hwaddr ) 
{ 
  int i ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;

  {
  {
#line 101
  pthread_mutex_lock(& mac_mutex_);
#line 103
  i = mac_cnt_ - 1;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i >= 0)) {
#line 103
      goto while_break;
    }
#line 104
    __a = in6;
#line 104
    __b = (struct in6_addr  const  *)(& mac_tbl_[i].__annonCompField6.in6addr);
#line 104
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 104
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 104
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 104
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 104
            tmp = 1;
          } else {
#line 104
            tmp = 0;
          }
        } else {
#line 104
          tmp = 0;
        }
      } else {
#line 104
        tmp = 0;
      }
    } else {
#line 104
      tmp = 0;
    }
#line 104
    if (tmp) {
#line 106
      if (hwaddr) {
#line 108
        if (! *(hwaddr + 0)) {
#line 108
          if (! *(hwaddr + 1)) {
#line 108
            if (! *(hwaddr + 2)) {
#line 108
              if (! *(hwaddr + 3)) {
#line 108
                if (! *(hwaddr + 4)) {
#line 108
                  if (! *(hwaddr + 5)) {
                    {
#line 109
                    memcpy((void */* __restrict  */)hwaddr, (void const   */* __restrict  */)(& mac_tbl_[i].hwaddr),
                           (size_t )6);
                    }
                  } else {
                    {
#line 111
                    memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                           (size_t )6);
                    }
                  }
                } else {
                  {
#line 111
                  memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                         (size_t )6);
                  }
                }
              } else {
                {
#line 111
                memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                       (size_t )6);
                }
              }
            } else {
              {
#line 111
              memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                     (size_t )6);
              }
            }
          } else {
            {
#line 111
            memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                   (size_t )6);
            }
          }
        } else {
          {
#line 111
          memcpy((void */* __restrict  */)(& mac_tbl_[i].hwaddr), (void const   */* __restrict  */)hwaddr,
                 (size_t )6);
          }
        }
      }
      {
#line 113
      mac_tbl_[i].age = time((time_t *)((void *)0));
      }
#line 114
      goto while_break;
    }
#line 103
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  pthread_mutex_unlock(& mac_mutex_);
  }
#line 119
  return (i);
}
}
#line 128 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int mac_add_entry(uint8_t const   *hwaddr , struct in6_addr  const  *in6 ) 
{ 
  int e ;
  int tmp ;

  {
  {
#line 130
  e = -1;
#line 132
  pthread_mutex_lock(& mac_mutex_);
  }
#line 134
  if (mac_cnt_ < 128) {
    {
#line 137
    memcpy((void */* __restrict  */)(& mac_tbl_[mac_cnt_].hwaddr), (void const   */* __restrict  */)hwaddr,
           (size_t )6);
#line 138
    memcpy((void */* __restrict  */)(& mac_tbl_[mac_cnt_].__annonCompField6.in6addr),
           (void const   */* __restrict  */)in6, sizeof(struct in6_addr ));
#line 139
    mac_tbl_[mac_cnt_].age = time((time_t *)((void *)0));
#line 140
    mac_tbl_[mac_cnt_].family = (uint16_t )10;
#line 141
    tmp = mac_cnt_;
#line 141
    mac_cnt_ ++;
#line 141
    e = tmp;
    }
  }
  {
#line 144
  pthread_mutex_unlock(& mac_mutex_);
  }
#line 146
  return (e);
}
}
#line 156 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int mac_get_ip(uint8_t const   *hwaddr , struct in6_addr *in6 ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 160
  pthread_mutex_lock(& mac_mutex_);
#line 162
  i = mac_cnt_ - 1;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i >= 0)) {
#line 162
      goto while_break;
    }
    {
#line 163
    tmp = memcmp((void const   *)hwaddr, (void const   *)(& mac_tbl_[i].hwaddr), (size_t )6);
    }
#line 163
    if (! tmp) {
#line 165
      if (in6) {
        {
#line 166
        memcpy((void */* __restrict  */)in6, (void const   */* __restrict  */)(& mac_tbl_[i].__annonCompField6.in6addr),
               sizeof(struct in6_addr ));
        }
      }
      {
#line 167
      mac_tbl_[i].age = time((time_t *)((void *)0));
      }
#line 168
      goto while_break;
    }
#line 162
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  pthread_mutex_unlock(& mac_mutex_);
  }
#line 173
  return (i);
}
}
#line 182 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
uint16_t checksum(uint16_t const   *buf , int len ) 
{ 
  uint32_t sum ;

  {
#line 184
  sum = (uint32_t )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (len > 1)) {
#line 188
      goto while_break;
    }
#line 189
    sum += (uint32_t )*buf;
#line 188
    len -= 2;
#line 188
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (len) {
#line 193
    sum += (uint32_t )*((uint8_t *)buf);
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if (! (sum >> 16)) {
#line 196
      goto while_break___0;
    }
#line 197
    sum = (sum & 65535U) + (sum >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  return ((uint16_t )(~ sum));
}
}
#line 206 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
void free_ckbuf(uint16_t *buf ) 
{ 


  {
  {
#line 208
  free((void *)buf);
  }
#line 209
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
uint16_t *malloc_ckbuf(struct in6_addr  const  *src , struct in6_addr  const  *dst ,
                       uint16_t plen , uint8_t proto , void const   *payload ) 
{ 
  struct ip6_psh *psh ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 218
  tmp___1 = calloc((size_t )1, sizeof(struct ip6_psh ) + (unsigned long )plen);
#line 218
  psh = (struct ip6_psh *)tmp___1;
  }
#line 218
  if (! psh) {
    {
#line 220
    tmp = __errno_location();
#line 220
    tmp___0 = strerror(*tmp);
#line 220
    log_msg(0, "error creating checksum buffer: %s", tmp___0);
#line 222
    exit(1);
    }
  }
  {
#line 225
  psh->src = (struct in6_addr )*src;
#line 226
  psh->dst = (struct in6_addr )*dst;
#line 227
  tmp___2 = htons(plen);
#line 227
  psh->len = (uint32_t )tmp___2;
#line 228
  psh->nxt = proto;
#line 229
  memcpy((void */* __restrict  */)(psh + 1), (void const   */* __restrict  */)payload,
         (size_t )plen);
  }
#line 231
  return ((uint16_t *)psh);
}
}
#line 240 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int ndp_solicit(struct in6_addr  const  *src , struct in6_addr  const  *dst ) 
{ 
  char buf[((sizeof(ndp6_t ) + sizeof(struct nd_opt_hdr )) + 4UL) + 6UL] ;
  ndp6_t *ndp6 ;
  struct nd_opt_hdr *ohd ;
  uint16_t *ckb ;
  struct in6_addr mcastd ;
  uint32_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 243
  ndp6 = (ndp6_t *)(buf + 4);
#line 244
  ohd = (struct nd_opt_hdr *)(ndp6 + 1);
#line 246
  mcastd.__in6_u.__u6_addr8[0] = (uint8_t )255;
#line 246
  mcastd.__in6_u.__u6_addr8[1] = (uint8_t )2;
#line 246
  mcastd.__in6_u.__u6_addr8[2] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[3] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[4] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[5] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[6] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[7] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[8] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[9] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[10] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[11] = (uint8_t )1;
#line 246
  mcastd.__in6_u.__u6_addr8[12] = (uint8_t )255;
#line 246
  mcastd.__in6_u.__u6_addr8[13] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[14] = (uint8_t )0;
#line 246
  mcastd.__in6_u.__u6_addr8[15] = (uint8_t )0;
#line 249
  memset((void *)(buf), 0, sizeof(buf));
#line 250
  memcpy((void */* __restrict  */)((char *)(& mcastd) + 13), (void const   */* __restrict  */)((char *)dst + 13),
         (size_t )3);
#line 253
  tmp = htonl(setup_.fhd_key[1]);
#line 253
  set_tunheader(buf, tmp);
#line 256
  ndp6->eth.ether_dhost[0] = (u_int8_t )51;
#line 257
  ndp6->eth.ether_dhost[1] = (u_int8_t )51;
#line 258
  memcpy((void */* __restrict  */)(& ndp6->eth.ether_dhost[2]), (void const   */* __restrict  */)((char *)(& mcastd) + 12),
         (size_t )4);
#line 259
  memcpy((void */* __restrict  */)(ndp6->eth.ether_shost), (void const   */* __restrict  */)(setup_.ocat_hwaddr),
         (size_t )6);
#line 260
  ndp6->eth.ether_type = htons((uint16_t )34525);
#line 263
  ndp6->ip6.ip6_ctlun.ip6_un2_vfc = (uint8_t )96;
#line 264
  ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen = htons((uint16_t )((sizeof(struct nd_neighbor_advert ) + sizeof(struct nd_opt_hdr )) + 6UL));
#line 265
  ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (uint8_t )58;
#line 266
  ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (uint8_t )255;
#line 267
  memcpy((void */* __restrict  */)(& ndp6->ip6.ip6_src), (void const   */* __restrict  */)src,
         sizeof(struct in6_addr ));
#line 268
  memcpy((void */* __restrict  */)(& ndp6->ip6.ip6_dst), (void const   */* __restrict  */)(& mcastd),
         sizeof(struct in6_addr ));
#line 271
  ndp6->__annonCompField7.icmp6.icmp6_type = (uint8_t )135;
#line 274
  memcpy((void */* __restrict  */)(& ndp6->__annonCompField7.ndp_sol.nd_ns_target),
         (void const   */* __restrict  */)dst, sizeof(struct in6_addr ));
#line 277
  ohd->nd_opt_type = (uint8_t )1;
#line 278
  ohd->nd_opt_len = (uint8_t )1;
#line 279
  memcpy((void */* __restrict  */)(ohd + 1), (void const   */* __restrict  */)(ndp6->eth.ether_shost),
         (size_t )6);
#line 282
  tmp___0 = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 282
  ckb = malloc_ckbuf((struct in6_addr  const  *)(& ndp6->ip6.ip6_src), (struct in6_addr  const  *)(& ndp6->ip6.ip6_dst),
                     tmp___0, (uint8_t )58, (void const   *)(& ndp6->__annonCompField7.icmp6));
#line 283
  tmp___1 = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 283
  ndp6->__annonCompField7.icmp6.icmp6_cksum = checksum((uint16_t const   *)ckb, (int )((unsigned long )tmp___1 + sizeof(struct ip6_psh )));
#line 284
  free_ckbuf(ckb);
#line 292
  tmp___2 = write(setup_.tunfd[1], (void const   *)(buf), sizeof(buf));
  }
#line 292
  if ((unsigned long )tmp___2 < sizeof(buf)) {
    {
#line 293
    log_msg(3, "short write to tun fd %d", setup_.tunfd[1]);
    }
  }
#line 296
  return (0);
}
}
#line 305 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int ndp_soladv(char *buf , int rlen ) 
{ 
  ndp6_t *ndp6 ;
  struct nd_opt_hdr *ohd ;
  uint16_t *ckb ;
  uint16_t cksum ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  struct in6_addr  const  *__a ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  ssize_t tmp___7 ;

  {
#line 307
  ndp6 = (ndp6_t *)(buf + 4);
#line 308
  ohd = (struct nd_opt_hdr *)(ndp6 + 1);
#line 314
  if ((int )ndp6->eth.ether_dhost[0] & 1) {
#line 317
    if ((int )ndp6->eth.ether_dhost[2] != 255) {
#line 320
      return (-1);
    }
#line 324
    if (! ((int const   )*((uint8_t const   *)(& ndp6->ip6.ip6_dst) + 0) == 255)) {
#line 327
      return (-1);
    } else
#line 324
    if ((int const   )*((uint8_t const   *)(& ndp6->ip6.ip6_dst) + 0) == 255) {
#line 324
      if (! (((int const   )*((uint8_t const   *)(& ndp6->ip6.ip6_dst) + 1) & 15) == 2)) {
#line 327
        return (-1);
      }
    } else {
#line 327
      return (-1);
    }
  }
  {
#line 331
  tmp = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 331
  ckb = malloc_ckbuf((struct in6_addr  const  *)(& ndp6->ip6.ip6_src), (struct in6_addr  const  *)(& ndp6->ip6.ip6_dst),
                     tmp, (uint8_t )58, (void const   *)(& ndp6->__annonCompField7.icmp6));
#line 332
  tmp___0 = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 332
  cksum = checksum((uint16_t const   *)ckb, (int )((unsigned long )tmp___0 + sizeof(struct ip6_psh )));
#line 333
  free_ckbuf(ckb);
  }
#line 335
  if (cksum) {
    {
#line 337
    log_msg(3, "icmpv6 checksum wrong");
    }
#line 338
    return (-1);
  }
#line 342
  __a = (struct in6_addr  const  *)(& ndp6->ip6.ip6_src);
#line 342
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 342
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 342
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 342
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 342
          tmp___1 = 1;
        } else {
#line 342
          tmp___1 = 0;
        }
      } else {
#line 342
        tmp___1 = 0;
      }
    } else {
#line 342
      tmp___1 = 0;
    }
  } else {
#line 342
    tmp___1 = 0;
  }
#line 342
  if (tmp___1) {
#line 346
    return (-1);
  }
  {
#line 349
  tmp___2 = has_tor_prefix((struct in6_addr  const  *)(& ndp6->__annonCompField7.ndp_sol.nd_ns_target));
  }
#line 349
  if (! tmp___2) {
#line 353
    return (-1);
  }
  {
#line 358
  tmp___4 = mac_set((struct in6_addr  const  *)(& ndp6->ip6.ip6_src), ndp6->eth.ether_shost);
  }
#line 358
  if (tmp___4 == -1) {
    {
#line 359
    tmp___3 = mac_add_entry((uint8_t const   *)(ndp6->eth.ether_shost), (struct in6_addr  const  *)(& ndp6->ip6.ip6_src));
    }
#line 359
    if (tmp___3 == -1) {
      {
#line 361
      log_msg(3, "MAC table full");
      }
#line 362
      return (-1);
    }
  }
  {
#line 366
  memcpy((void */* __restrict  */)(ndp6->eth.ether_dhost), (void const   */* __restrict  */)(ndp6->eth.ether_shost),
         (size_t )6);
#line 367
  memcpy((void */* __restrict  */)(ndp6->eth.ether_shost), (void const   */* __restrict  */)(setup_.ocat_hwaddr),
         (size_t )6);
#line 370
  memcpy((void */* __restrict  */)(& ndp6->ip6.ip6_dst), (void const   */* __restrict  */)(& ndp6->ip6.ip6_src),
         sizeof(struct in6_addr ));
#line 371
  memcpy((void */* __restrict  */)(& ndp6->ip6.ip6_src), (void const   */* __restrict  */)(& ndp6->__annonCompField7.ndp_sol.nd_ns_target),
         sizeof(struct in6_addr ));
#line 374
  ndp6->__annonCompField7.ndp_adv.nd_na_hdr.icmp6_type = (uint8_t )136;
#line 375
  ndp6->__annonCompField7.ndp_adv.nd_na_hdr.icmp6_code = (uint8_t )0;
#line 376
  ndp6->__annonCompField7.ndp_adv.nd_na_hdr.icmp6_cksum = (uint16_t )0;
#line 377
  ndp6->__annonCompField7.ndp_adv.nd_na_hdr.icmp6_dataun.icmp6_un_data32[0] = (uint32_t )64;
#line 380
  ohd->nd_opt_type = (uint8_t )2;
#line 381
  memcpy((void */* __restrict  */)(ohd + 1), (void const   */* __restrict  */)(setup_.ocat_hwaddr),
         (size_t )6);
#line 383
  tmp___5 = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 383
  ckb = malloc_ckbuf((struct in6_addr  const  *)(& ndp6->ip6.ip6_src), (struct in6_addr  const  *)(& ndp6->ip6.ip6_dst),
                     tmp___5, (uint8_t )58, (void const   *)(& ndp6->__annonCompField7.icmp6));
#line 384
  tmp___6 = ntohs(ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_plen);
#line 384
  ndp6->__annonCompField7.ndp_adv.nd_na_hdr.icmp6_cksum = checksum((uint16_t const   *)ckb,
                                                                   (int )((unsigned long )tmp___6 + sizeof(struct ip6_psh )));
#line 385
  free_ckbuf(ckb);
#line 393
  tmp___7 = write(setup_.tunfd[1], (void const   *)buf, (size_t )rlen);
  }
#line 393
  if (tmp___7 < (ssize_t )rlen) {
    {
#line 394
    log_msg(3, "short write");
    }
  }
#line 397
  return (0);
}
}
#line 404 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int ndp_recadv(char *buf , int len ) 
{ 
  ndp6_t *ndp6 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 406
  ndp6 = (ndp6_t *)(buf + 4);
#line 409
  tmp___0 = mac_set((struct in6_addr  const  *)(& ndp6->ip6.ip6_src), ndp6->eth.ether_shost);
  }
#line 409
  if (tmp___0 == -1) {
    {
#line 410
    tmp = mac_add_entry((uint8_t const   *)(ndp6->eth.ether_shost), (struct in6_addr  const  *)(& ndp6->ip6.ip6_src));
    }
#line 410
    if (tmp == -1) {
      {
#line 412
      log_msg(3, "MAC table full");
      }
#line 413
      return (-1);
    }
  }
#line 415
  return (0);
}
}
#line 419 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int eth_ndp(char *buf , int len , int ndp_type ) 
{ 


  {
  {
#line 423
  if (ndp_type == 135) {
#line 423
    goto case_135;
  }
#line 428
  if (ndp_type == 136) {
#line 428
    goto case_136;
  }
#line 421
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 425
  ndp_soladv(buf, len);
  }
#line 426
  return (0);
  case_136: /* CIL Label */ 
  {
#line 430
  ndp_recadv(buf, len);
  }
#line 431
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 433
  return (-1);
}
}
#line 441 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocateth.c"
int eth_check(char *buf , int len ) 
{ 
  ndp6_t *ndp6 ;
  int tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;

  {
#line 443
  ndp6 = (ndp6_t *)(buf + 4);
#line 446
  if ((unsigned long )len < sizeof(struct ether_header ) + 4UL) {
    {
#line 448
    log_msg(3, "frame too short, len = %d < 4 + %d", len, sizeof(struct ether_header ));
    }
#line 449
    return (-8);
  }
#line 453
  if ((int )ndp6->eth.ether_dhost[0] != 51) {
#line 453
    if ((int )ndp6->eth.ether_dhost[1] != 51) {
      {
#line 453
      tmp = memcmp((void const   *)(ndp6->eth.ether_dhost), (void const   *)(setup_.ocat_hwaddr),
                   (size_t )6);
      }
#line 453
      if (tmp) {
#line 456
        return (-9);
      }
    }
  }
  {
#line 460
  tmp___1 = htons((uint16_t )34525);
  }
#line 460
  if ((int )ndp6->eth.ether_type != (int )tmp___1) {
    {
#line 462
    tmp___0 = ntohs(ndp6->eth.ether_type);
#line 462
    log_msg(3, "L3 protocol not implemented 0x%04x", (int )tmp___0);
    }
#line 463
    return (-10);
  }
#line 467
  if ((unsigned long )len >= sizeof(ndp6_t ) + 4UL) {
#line 467
    if ((int )ndp6->ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) {
      {
#line 470
      tmp___2 = eth_ndp(buf, len, (int )ndp6->__annonCompField7.icmp6.icmp6_type);
      }
#line 470
      if (tmp___2 != -1) {
#line 471
        return (-11);
      }
    }
  }
#line 475
  return (0);
}
}
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 649 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
int oe_remtr(char *s ) ;
#line 650
int strsockaddr(char const   *src , struct sockaddr *addr ) ;
#line 652
void add_listener(char const   *buf ) ;
#line 653
void delete_listeners(struct sockaddr **addr , int *fd , int cnt ) ;
#line 654
int fdprintf(int fd , char const   *fmt , va_list ap ) ;
#line 32 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
void oe_close(int fd ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    tmp___2 = close(fd);
    }
#line 37
    if (! (tmp___2 == -1)) {
#line 37
      goto while_break;
    }
    {
#line 39
    tmp = __errno_location();
#line 39
    r = *tmp;
#line 40
    tmp___0 = strerror(r);
#line 40
    log_msg(2, "close(%d) failed: \"%s\"", fd, tmp___0);
    }
#line 41
    if (r == 4) {
      {
#line 43
      tmp___1 = strerror(r);
#line 43
      log_msg(3, "close(%d) failed: \"%s\". restarting...", fd, tmp___1);
      }
#line 44
      goto while_continue;
    }
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
int oe_remtr(char *s ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 57
  if (! *(s + 0)) {
#line 58
    return (0);
  }
#line 59
  if (*(s + 0)) {
    {
#line 59
    tmp___0 = strlen((char const   *)s);
    }
#line 59
    if ((int )*(s + (tmp___0 - 1UL)) == 10) {
      {
#line 60
      tmp = strlen((char const   *)s);
#line 60
      *(s + (tmp - 1UL)) = (char )'\000';
      }
    }
  }
#line 61
  if (*(s + 0)) {
    {
#line 61
    tmp___2 = strlen((char const   *)s);
    }
#line 61
    if ((int )*(s + (tmp___2 - 1UL)) == 13) {
      {
#line 62
      tmp___1 = strlen((char const   *)s);
#line 62
      *(s + (tmp___1 - 1UL)) = (char )'\000';
      }
    }
  }
  {
#line 63
  tmp___3 = strlen((char const   *)s);
  }
#line 63
  return ((int )tmp___3);
}
}
#line 74 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
int strsockaddr(char const   *src , struct sockaddr *addr ) 
{ 
  char *s ;
  char buf[100] ;
  int p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 79
  strlcpy(buf, src, (size_t )100);
#line 80
  s = strchr((char const   *)(buf), '[');
  }
#line 80
  if (s) {
    {
#line 82
    s ++;
#line 83
    ((struct sockaddr_in6 *)addr)->sin6_family = (sa_family_t )10;
#line 84
    s = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)"]");
#line 85
    tmp = inet_pton(10, (char const   */* __restrict  */)s, (void */* __restrict  */)(& ((struct sockaddr_in6 *)addr)->sin6_addr));
    }
#line 85
    if (! tmp) {
      {
#line 87
      log_msg(1, "\"%s\" contains no valid IPv6 address", s);
      }
#line 88
      return (-1);
    }
    {
#line 90
    s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 90
    if (s) {
#line 92
      if ((int )*s == 58) {
        {
#line 94
        s ++;
#line 95
        p = atoi((char const   *)s);
        }
#line 95
        if (p > 0) {
          {
#line 96
          ((struct sockaddr_in6 *)addr)->sin6_port = htons((uint16_t )p);
          }
        }
      }
    }
#line 102
    return (10);
  }
  {
#line 105
  tmp___1 = strchr((char const   *)(buf), '.');
  }
#line 105
  if (tmp___1) {
    {
#line 107
    ((struct sockaddr_in *)addr)->sin_family = (sa_family_t )2;
#line 108
    s = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)":");
#line 109
    tmp___0 = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& ((struct sockaddr_in *)addr)->sin_addr));
    }
#line 109
    if (! tmp___0) {
      {
#line 111
      log_msg(1, "\"%s\" is not a valid IPv4 address", s);
      }
#line 112
      return (-1);
    }
    {
#line 114
    s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
    }
#line 115
    if (s) {
      {
#line 116
      p = atoi((char const   *)s);
      }
#line 116
      if (p > 0) {
        {
#line 117
        ((struct sockaddr_in *)addr)->sin_port = htons((uint16_t )p);
        }
      }
    }
#line 121
    return (2);
  }
  {
#line 124
  p = atoi((char const   *)(buf));
  }
#line 124
  if (p > 0) {
    {
#line 128
    if ((int )((struct sockaddr_in *)addr)->sin_family == 2) {
#line 128
      goto case_2;
    }
#line 132
    if ((int )((struct sockaddr_in *)addr)->sin_family == 10) {
#line 132
      goto case_10;
    }
#line 136
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 129
    ((struct sockaddr_in *)addr)->sin_port = htons((uint16_t )p);
    }
#line 130
    return (2);
    case_10: /* CIL Label */ 
    {
#line 133
    ((struct sockaddr_in6 *)addr)->sin6_port = htons((uint16_t )p);
    }
#line 134
    return (2);
    switch_default: /* CIL Label */ ;
#line 138
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 142
  return (-1);
}
}
#line 146 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
void add_listener(char const   *buf ) 
{ 
  struct sockaddr_in6 saddr ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  struct sockaddr *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 150
  memset((void *)(& saddr), 0, sizeof(saddr));
#line 151
  tmp = strsockaddr(buf, (struct sockaddr *)(& saddr));
  }
#line 151
  if (tmp == -1) {
    {
#line 152
    log_msg(0, "could not convert address string \'%s\'", buf);
#line 152
    exit(1);
    }
  }
  {
#line 154
  (setup_.oc_listen_cnt) ++;
#line 156
  tmp___2 = realloc((void *)setup_.oc_listen, sizeof(struct sockaddr *) * (unsigned long )setup_.oc_listen_cnt);
#line 156
  setup_.oc_listen = (struct sockaddr **)tmp___2;
  }
#line 156
  if (! setup_.oc_listen) {
    {
#line 157
    tmp___0 = __errno_location();
#line 157
    tmp___1 = strerror(*tmp___0);
#line 157
    log_msg(3, "could not get memory for listener list: \"%s\"", tmp___1);
#line 157
    exit(1);
    }
  }
  {
#line 158
  tmp___5 = realloc((void *)setup_.oc_listen_fd, sizeof(int ) * (unsigned long )setup_.oc_listen_cnt);
#line 158
  setup_.oc_listen_fd = (int *)tmp___5;
  }
#line 158
  if (! setup_.oc_listen_fd) {
    {
#line 159
    tmp___3 = __errno_location();
#line 159
    tmp___4 = strerror(*tmp___3);
#line 159
    log_msg(3, "could not get memory for listener fds: \"%s\"", tmp___4);
#line 159
    exit(1);
    }
  }
  {
#line 162
  tmp___9 = calloc((size_t )1, sizeof(struct sockaddr_in6 ));
#line 162
  tmp___8 = (struct sockaddr *)tmp___9;
#line 162
  *(setup_.oc_listen + (setup_.oc_listen_cnt - 1)) = tmp___8;
  }
#line 162
  if (! tmp___8) {
    {
#line 163
    tmp___6 = __errno_location();
#line 163
    tmp___7 = strerror(*tmp___6);
#line 163
    log_msg(3, "could not get memory for listener : \"%s\"", tmp___7);
#line 163
    exit(1);
    }
  }
  {
#line 165
  *(setup_.oc_listen_fd + (setup_.oc_listen_cnt - 1)) = -1;
#line 166
  memcpy((void */* __restrict  */)*(setup_.oc_listen + (setup_.oc_listen_cnt - 1)),
         (void const   */* __restrict  */)(& saddr), sizeof(saddr));
  }
#line 167
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
void delete_listeners(struct sockaddr **addr , int *fd , int cnt ) 
{ 


  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! cnt) {
#line 173
      goto while_break;
    }
    {
#line 174
    free((void *)*(addr + (cnt - 1)));
#line 173
    cnt --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  free((void *)addr);
#line 177
  free((void *)fd);
  }
#line 178
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
int fdaprintf(int fd , int bsiz , char const   *fmt , va_list ap ) 
{ 
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  int s ;
  int e ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 183
  __lengthofbuf = (unsigned long )bsiz;
#line 183
  tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 183
  buf = (char *)tmp;
#line 186
  s = vsnprintf((char */* __restrict  */)buf, (size_t )bsiz, (char const   */* __restrict  */)fmt,
                ap);
  }
#line 186
  if (s >= bsiz) {
    {
#line 188
    tmp___0 = fdaprintf(fd, s + 1, fmt, ap);
    }
#line 188
    return (tmp___0);
  } else
#line 190
  if (s == -1) {
    {
#line 192
    tmp___1 = __errno_location();
#line 192
    e = *tmp___1;
#line 193
    tmp___2 = strerror(e);
#line 193
    log_msg(4, "vnsprintf failed: \"%s\"", tmp___2);
#line 194
    tmp___3 = __errno_location();
#line 194
    *tmp___3 = e;
    }
#line 195
    return (-1);
  }
  {
#line 198
  tmp___7 = write(fd, (void const   *)buf, (size_t )s);
#line 198
  s = (int )tmp___7;
  }
#line 198
  if (s == -1) {
    {
#line 200
    tmp___4 = __errno_location();
#line 200
    e = *tmp___4;
#line 201
    tmp___5 = strerror(e);
#line 201
    log_msg(4, "write failed: \"%s\"", tmp___5);
#line 202
    tmp___6 = __errno_location();
#line 202
    *tmp___6 = e;
    }
#line 203
    return (-1);
  }
#line 205
  return (s);
}
}
#line 216 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlibe.c"
int fdprintf(int fd , char const   *fmt , va_list ap ) 
{ 
  int tmp ;

  {
  {
#line 218
  tmp = fdaprintf(fd, 256, fmt, ap);
  }
#line 218
  return (tmp);
}
}
#line 22 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat_netdesc.c"
struct NetDesc  const  netdesc_[2]  = {      {{{{(uint8_t )253, (uint8_t )135, (uint8_t )216, (uint8_t )126, (uint8_t )235,
         (uint8_t )67, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
         (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0}}}, 48, {(in_addr_t )10},
      255, 23, (char *)".onion", (short)8060, (short)8066, (short)8060, (short)9050,
      (char *)"ocat_connect_log", (char *)"/var/run/ocat.pid", (char *)"ocat.conf"}, 
        {{{{(uint8_t )253,
         (uint8_t )96, (uint8_t )219, (uint8_t )77, (uint8_t )221, (uint8_t )181,
         (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0,
         (uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0}}}, 48, {(in_addr_t )10},
      255, 28, (char *)".oc.b32.i2p", (short)8061, (short)8067, (short)8061, (short)9051,
      (char *)"gcat_connect_log", (char *)"/var/run/gcat.pid", (char *)"gcat.conf"}};
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 548 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
int oniontipv6(char const   *onion , struct in6_addr *ip6 ) ;
#line 573
void *ocat_controller(void *p ) ;
#line 574
void *ctrl_handler(void *p ) ;
#line 624
int parse_route(char const   *rs ) ;
#line 625
void print_routes(FILE *f ) ;
#line 36 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatctrl.c"
void *ctrl_handler(void *p ) 
{ 
  int fd ;
  int c ;
  FILE *ff ;
  FILE *fo ;
  char buf[65580] ;
  char addrstr[46] ;
  char *onionstr ;
  unsigned long __lengthofonionstr ;
  void *tmp ;
  char timestr[32] ;
  char *s ;
  char *tokbuf ;
  char *bufp ;
  int rlen ;
  int cfd ;
  struct tm *tm ;
  OcatPeer_t *peer ;
  struct in6_addr in6 ;
  int pfd[2] ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  time_t tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  struct in6_addr  const  *__a___0 ;
  int tmp___21 ;
  __pid_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;

  {
  {
#line 40
  __lengthofonionstr = (unsigned long )netdesc_[setup_.net_type].name_size;
#line 40
  tmp = __builtin_alloca(sizeof(*onionstr) * __lengthofonionstr);
#line 40
  onionstr = (char *)tmp;
#line 47
  detach_thread();
#line 49
  tmp___2 = pipe((int *)(pfd));
  }
#line 49
  if (tmp___2 == -1) {
    {
#line 50
    tmp___0 = __errno_location();
#line 50
    tmp___1 = strerror(*tmp___0);
#line 50
    log_msg(0, "couldn\'t create pipe: \"%s\"", tmp___1);
#line 50
    exit(1);
    }
  }
#line 52
  fd = (int )((long )p);
#line 53
  if (setup_.config_read) {
    {
#line 55
    ff = fdopen(fd, "r+");
    }
#line 55
    if (! ff) {
      {
#line 57
      tmp___3 = __errno_location();
#line 57
      tmp___4 = strerror(*tmp___3);
#line 57
      log_msg(3, "could not open %d for writing: %s", fd, tmp___4);
#line 58
      oe_close(pfd[0]);
#line 59
      oe_close(pfd[1]);
      }
#line 60
      return ((void *)0);
    }
    {
#line 63
    fo = ff;
#line 64
    tmp___7 = setvbuf((FILE */* __restrict  */)ff, (char */* __restrict  */)((void *)0),
                      2, (size_t )0);
    }
#line 64
    if (tmp___7) {
      {
#line 65
      tmp___5 = __errno_location();
#line 65
      tmp___6 = strerror(*tmp___5);
#line 65
      log_msg(3, "could not setup line buffering: %s", tmp___6);
      }
    }
  } else {
    {
#line 69
    ff = fdopen(fd, "r");
    }
#line 69
    if (! ff) {
      {
#line 71
      tmp___8 = __errno_location();
#line 71
      tmp___9 = strerror(*tmp___8);
#line 71
      log_msg(3, "could not open %d for reading: %s", fd, tmp___9);
#line 72
      setup_.config_read = 1;
#line 73
      oe_close(pfd[0]);
#line 74
      oe_close(pfd[1]);
      }
#line 75
      return ((void *)0);
    }
#line 78
    if (setup_.logf) {
#line 78
      fo = setup_.logf;
    } else {
#line 78
      fo = stderr;
    }
  }
  {
#line 82
  lock_setup();
#line 83
  (setup_.ctrl_active) ++;
#line 84
  unlock_setup();
#line 86
  fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s\n", setup_.version);
#line 87
  fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"*** ATTENTION! Controller interface not thread-safe yet! Usage could cause deadlocks. ***\n");
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (setup_.config_read) {
      {
#line 92
      fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s> ",
              setup_.onion_url);
      }
    }
    {
#line 94
    c = _IO_getc(ff);
    }
#line 95
    if (c == -1) {
#line 98
      goto while_break;
    } else
#line 100
    if (c == 4) {
#line 103
      goto while_break;
    } else
#line 105
    if (c == 27) {
      {
#line 108
      tmp___10 = ungetc(c, ff);
      }
#line 108
      if (tmp___10 == -1) {
#line 111
        goto while_break;
      }
    } else {
      {
#line 116
      tmp___11 = ungetc(c, ff);
      }
#line 116
      if (tmp___11 == -1) {
#line 119
        goto while_break;
      }
    }
    {
#line 123
    tmp___13 = fgets((char */* __restrict  */)(buf), 65580, (FILE */* __restrict  */)ff);
    }
#line 123
    if (! tmp___13) {
      {
#line 125
      tmp___12 = feof(ff);
      }
#line 125
      if (! tmp___12) {
        {
#line 126
        log_msg(3, "error reading from %d");
        }
      }
#line 127
      goto while_break;
    }
    {
#line 136
    rlen = oe_remtr(buf);
    }
#line 136
    if (! rlen) {
#line 137
      goto __Cont;
    }
    {
#line 139
    bufp = strtok_r((char */* __restrict  */)(buf), (char const   */* __restrict  */)" \t\r\n",
                    (char **/* __restrict  */)(& tokbuf));
    }
#line 139
    if (! bufp) {
#line 140
      goto __Cont;
    }
    {
#line 143
    tmp___38 = strncmp((char const   *)bufp, "exit", (size_t )4);
    }
#line 143
    if (tmp___38) {
      {
#line 143
      tmp___39 = strncmp((char const   *)bufp, "quit", (size_t )4);
      }
#line 143
      if (tmp___39) {
        {
#line 146
        tmp___37 = strcmp((char const   *)bufp, "status");
        }
#line 146
        if (tmp___37) {
          {
#line 165
          tmp___36 = strcmp((char const   *)bufp, "close");
          }
#line 165
          if (tmp___36) {
            {
#line 184
            tmp___35 = strcmp((char const   *)bufp, "threads");
            }
#line 184
            if (tmp___35) {
              {
#line 188
              tmp___34 = strcmp((char const   *)bufp, "terminate");
              }
#line 188
              if (tmp___34) {
                {
#line 193
                tmp___33 = strcmp((char const   *)bufp, "route");
                }
#line 193
                if (tmp___33) {
                  {
#line 230
                  tmp___32 = strcmp((char const   *)bufp, "connect");
                  }
#line 230
                  if (tmp___32) {
                    {
#line 249
                    tmp___31 = strcmp((char const   *)bufp, "macs");
                    }
#line 249
                    if (tmp___31) {
                      {
#line 253
                      tmp___30 = strcmp((char const   *)bufp, "queue");
                      }
#line 253
                      if (tmp___30) {
                        {
#line 264
                        tmp___29 = strcmp((char const   *)bufp, "setup");
                        }
#line 264
                        if (tmp___29) {
                          {
#line 268
                          tmp___28 = strcmp((char const   *)bufp, "version");
                          }
#line 268
                          if (tmp___28) {
                            {
#line 272
                            tmp___26 = strcmp((char const   *)bufp, "help");
                            }
#line 272
                            if (tmp___26) {
                              {
#line 272
                              tmp___27 = strcmp((char const   *)bufp, "?");
                              }
#line 272
                              if (tmp___27) {
                                {
#line 295
                                fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"ERR unknown command: \"%s\"\n",
                                        buf);
                                }
                              } else {
                                {
#line 274
                                fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"commands:\nexit | quit .... exit from control interface\nterminate ...... terminate OnionCat\nclose <n> ...... close file descriptor <n> of a peer\nstatus ......... list peer status\nthreads ........ show active threads\nroute .......... show routing table\nroute <dst IP> <netmask> <IPv6 gw>\n   ............. add route to routing table\nconnect <.onion-URL> [\"perm\"]\n   ............. connect to a hidden service. if \"perm\" is set,\n   ............. connection will stay open forever\nmacs ........... show MAC address table\nqueue .......... list pending SOCKS connections\nsetup .......... show internal setup struct\nversion ........ show version\n");
                                }
                              }
                            } else {
                              {
#line 274
                              fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"commands:\nexit | quit .... exit from control interface\nterminate ...... terminate OnionCat\nclose <n> ...... close file descriptor <n> of a peer\nstatus ......... list peer status\nthreads ........ show active threads\nroute .......... show routing table\nroute <dst IP> <netmask> <IPv6 gw>\n   ............. add route to routing table\nconnect <.onion-URL> [\"perm\"]\n   ............. connect to a hidden service. if \"perm\" is set,\n   ............. connection will stay open forever\nmacs ........... show MAC address table\nqueue .......... list pending SOCKS connections\nsetup .......... show internal setup struct\nversion ........ show version\n");
                              }
                            }
                          } else {
                            {
#line 270
                            fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"%s\n",
                                    setup_.version);
                            }
                          }
                        } else {
                          {
#line 266
                          print_setup_struct(ff);
                          }
                        }
                      } else {
                        {
#line 255
                        print_socks_queue((FILE *)((long )pfd[1]));
                        }
                        {
#line 256
                        while (1) {
                          while_continue___0: /* CIL Label */ ;
                          {
#line 258
                          read(pfd[0], (void *)(buf), (size_t )1);
                          }
#line 259
                          if (! buf[0]) {
#line 260
                            goto while_break___0;
                          }
                          {
#line 261
                          fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"%c",
                                  (int )buf[0]);
                          }
                        }
                        while_break___0: /* CIL Label */ ;
                        }
                      }
                    } else {
                      {
#line 251
                      print_mac_tbl(ff);
                      }
                    }
                  } else {
                    {
#line 232
                    s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n",
                                 (char **/* __restrict  */)(& tokbuf));
                    }
#line 232
                    if (s) {
                      {
#line 234
                      tmp___24 = strlen((char const   *)s);
                      }
#line 234
                      if (tmp___24 != 16UL) {
                        {
#line 235
                        fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"ERR \"%s\" not valid .onion-URL\n",
                                bufp + 8);
                        }
                      } else {
                        {
#line 234
                        tmp___25 = oniontipv6((char const   *)s, & in6);
                        }
#line 234
                        if (tmp___25 == -1) {
                          {
#line 235
                          fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"ERR \"%s\" not valid .onion-URL\n",
                                  bufp + 8);
                          }
                        } else {
                          {
#line 238
                          s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n",
                                       (char **/* __restrict  */)(& tokbuf));
                          }
#line 238
                          if (s) {
                            {
#line 240
                            tmp___23 = strcmp((char const   *)s, "perm");
                            }
#line 240
                            if (tmp___23) {
                              {
#line 243
                              fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"ERR unknown param \"%s\"\n",
                                      s);
                              }
                            } else {
                              {
#line 241
                              socks_queue(in6, 1);
                              }
                            }
                          } else {
                            {
#line 239
                            socks_queue(in6, 0);
                            }
                          }
                        }
                      }
                    } else {
                      {
#line 247
                      fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"ERR missing args\n");
                      }
                    }
                  }
                } else
#line 195
                if (rlen > 6) {
                  {
#line 197
                  c = parse_route((char const   *)(bufp + 6));
                  }
#line 197
                  if (c == -4) {
                    {
#line 198
                    c = ipv6_parse_route((char const   *)(bufp + 6));
                    }
#line 198
                    if (c > 0) {
#line 199
                      c = 0;
                    }
                  }
                  {
#line 202
                  if (c == -6) {
#line 202
                    goto case_neg_6;
                  }
#line 206
                  if (c == -3) {
#line 206
                    goto case_neg_3;
                  }
#line 210
                  if (c == -2) {
#line 210
                    goto case_neg_2;
                  }
#line 214
                  if (c == -7) {
#line 214
                    goto case_neg_7;
                  }
#line 218
                  goto switch_default;
                  case_neg_6: /* CIL Label */ 
#line 203
                  s = (char *)"gateway has not TOR prefix";
#line 204
                  goto switch_break;
                  case_neg_3: /* CIL Label */ 
#line 207
                  s = (char *)"illegal netmask or prefix length";
#line 208
                  goto switch_break;
                  case_neg_2: /* CIL Label */ 
#line 211
                  s = (char *)"route already exists";
#line 212
                  goto switch_break;
                  case_neg_7: /* CIL Label */ 
#line 215
                  s = (char *)"gateway points to me";
#line 216
                  goto switch_break;
                  switch_default: /* CIL Label */ 
#line 219
                  s = (char *)"";
                  switch_break: /* CIL Label */ ;
                  }
#line 221
                  if (c) {
                    {
#line 222
                    fprintf((FILE */* __restrict  */)ff, (char const   */* __restrict  */)"ERR %d %s\n",
                            c, s);
                    }
                  }
                } else {
                  {
#line 226
                  print_routes(fo);
#line 227
                  ipv6_print_routes(fo);
                  }
                }
              } else {
                {
#line 190
                log_msg(6, "terminate request from control port");
#line 191
                tmp___22 = getpid();
#line 191
                kill(tmp___22, 2);
                }
              }
            } else {
              {
#line 186
              print_threads(ff);
              }
            }
          } else {
            {
#line 167
            cfd = atoi((char const   *)(bufp + 6));
#line 168
            lock_peers();
#line 169
            peer = get_first_peer();
            }
            {
#line 169
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 169
              if (! peer) {
#line 169
                goto while_break___1;
              }
#line 170
              if (peer->tcpfd == cfd) {
                {
#line 172
                oe_close(cfd);
#line 173
                delete_peer(peer);
#line 174
                log_msg(1030, "%d was successfully closed up on user request", cfd);
                }
#line 175
                goto while_break___1;
              }
#line 169
              peer = peer->next;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 177
            if (! peer) {
              {
#line 179
              log_msg(6, "no peer with fd %d exists\n", cfd);
#line 180
              fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"no peer with fd %d exists\n",
                      cfd);
              }
            }
            {
#line 182
            unlock_peers();
            }
          }
        } else {
          {
#line 148
          lock_peers();
#line 149
          peer = get_first_peer();
          }
          {
#line 149
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 149
            if (! peer) {
#line 149
              goto while_break___2;
            }
#line 151
            if (peer->state == 1) {
              {
#line 153
              tm = localtime((time_t const   *)(& peer->otime));
#line 154
              strftime((char */* __restrict  */)(timestr), (size_t )32, (char const   */* __restrict  */)"%c",
                       (struct tm  const  */* __restrict  */)tm);
              }
#line 155
              if (peer->perm) {
#line 155
                tmp___14 = "PERMANENT";
              } else {
#line 155
                tmp___14 = "TEMPORARY";
              }
              {
#line 155
              tmp___15 = time((time_t *)((void *)0));
              }
#line 155
              if (peer->dir == 0) {
#line 155
                tmp___16 = "IN";
              } else {
#line 155
                tmp___16 = "OUT";
              }
              {
#line 155
              tmp___17 = inet_ntop(10, (void const   */* __restrict  */)(& peer->addr),
                                   (char */* __restrict  */)(addrstr), (socklen_t )46);
#line 156
              __a___0 = (struct in6_addr  const  *)(& peer->addr);
              }
#line 156
              if (__a___0->__in6_u.__u6_addr32[0] == 0U) {
#line 156
                if (__a___0->__in6_u.__u6_addr32[1] == 0U) {
#line 156
                  if (__a___0->__in6_u.__u6_addr32[2] == 0U) {
#line 156
                    if (__a___0->__in6_u.__u6_addr32[3] == 0U) {
#line 156
                      tmp___21 = 1;
                    } else {
#line 156
                      tmp___21 = 0;
                    }
                  } else {
#line 156
                    tmp___21 = 0;
                  }
                } else {
#line 156
                  tmp___21 = 0;
                }
              } else {
#line 156
                tmp___21 = 0;
              }
#line 156
              if (tmp___21) {
#line 156
                tmp___20 = "--unidentified--";
              } else {
                {
#line 156
                tmp___19 = ipv6tonion((struct in6_addr  const  *)(& peer->addr), onionstr);
#line 156
                tmp___20 = (char const   *)tmp___19;
                }
              }
              {
#line 156
              fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"[%s]\n fd = %d\n addr = %s\n dir = \"%s\" (%d)\n idle = %lds\n bytes_in = %ld\n bytes_out = %ld\n setup_delay = %lds\n opening_time = \"%s\"\n conn type = \"%s\" (%d)\n",
                      tmp___20, peer->tcpfd, tmp___17, tmp___16, peer->dir, tmp___15 - peer->time,
                      peer->in, peer->out, peer->sdelay, timestr, tmp___14, peer->perm);
              }
            }
#line 149
            peer = peer->next;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 163
          unlock_peers();
          }
        }
      } else {
#line 144
        goto while_break;
      }
    } else {
#line 144
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if (setup_.config_read) {
    {
#line 300
    fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"Good bye!\n");
    }
  }
  {
#line 301
  log_msg(1030, "closing session %d", fd);
#line 302
  tmp___42 = fclose(ff);
  }
#line 302
  if (tmp___42 == -1) {
    {
#line 303
    tmp___40 = __errno_location();
#line 303
    tmp___41 = strerror(*tmp___40);
#line 303
    log_msg(3, "error closing control stream: \"%s\"", tmp___41);
    }
  }
#line 306
  if (! setup_.config_read) {
#line 307
    setup_.config_read = 1;
  }
  {
#line 310
  oe_close(pfd[0]);
#line 311
  oe_close(pfd[1]);
#line 313
  lock_setup();
#line 314
  (setup_.ctrl_active) --;
#line 315
  unlock_setup();
  }
#line 317
  return ((void *)0);
}
}
#line 321 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatctrl.c"
int run_ctrl_handler(int fd ) 
{ 
  int tmp ;

  {
  {
#line 326
  lock_setup();
  }
#line 327
  if (setup_.ctrl_active >= setup_.max_ctrl) {
    {
#line 329
    log_msg(4, "maximum number of controller sessions reached");
#line 330
    oe_close(fd);
#line 331
    fd = -1;
    }
  }
  {
#line 333
  unlock_setup();
  }
#line 334
  if (fd == -1) {
#line 335
    return (-1);
  }
  {
#line 337
  tmp = run_ocat_thread("ctrl_handler", & ctrl_handler, (void *)((long )fd));
  }
#line 337
  return (tmp);
}
}
#line 341 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatctrl.c"
void *ocat_controller(void *p ) 
{ 


  {
  {
#line 343
  run_listeners(setup_.ctrl_listen, setup_.ctrl_listen_fd, setup_.ctrl_listen_cnt,
                & run_ctrl_handler);
  }
#line 344
  return ((void *)0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 149 "/usr/include/pwd.h"
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 538 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.h"
int open_connect_log(char const   *dir ) ;
#line 549
int oniontipv4(char const   *onion , struct in_addr *ip , int prefix_mask ) ;
#line 551
void rand_onion(char *onion ) ;
#line 23 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void usage(char const   *s ) 
{ 
  uint16_t tmp ;

  {
  {
#line 25
  tmp = ntohs((setup_.__annonCompField5.socks_dst)->sin_port);
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\nusage: %s [OPTIONS] <onion_hostname>\n   -a                    create connect log at \"$HOME/%s/%s\" (default = %d)\n   -b                    daemonize (default = %d)\n   -B                    do not daemonize (default = %d)\n   -h                    display usage message\n   -H                    ignore /etc/hosts while in GarliCat mode\n   -C                    disable local controller interface\n   -d <n>                set debug level to n, default = %d\n   -f <config_file>      read config from config_file (default = %s)\n   -i                    convert onion hostname to IPv6 and exit\n   -I                    GarliCat mode, use I2P instead of Tor\n   -l [<ip>:]<port>      set ocat listen address and port, default = 127.0.0.1:%d\n   -L <log_file>         log output to <log_file> (default = stderr)\n   -o <ipv6_addr>        convert IPv6 address to onion url and exit\n   -p                    use TAP device instead of TUN\n   -P [<pid_file>]       create pid file at location of <pid_file> (default = %s)\n   -r                    run as root, i.e. do not change uid/gid\n   -R                    generate a random local onion URL\n   -s <port>             set hidden service virtual port, default = %d\n   -t [<ip>:]<port>      set Tor SOCKS address and port, default = 127.0.0.1:%d\n   -T <tun_device>       path to tun character device, default = \"%s\"\n   -U                    disable unidirectional mode\n   -u <user>             change UID to user, default = \"%s\"\n   -4                    enable IPv4 support (default = %d)\n",
          setup_.version, s, ".ocat", netdesc_[setup_.net_type].clog_file, setup_.create_clog,
          setup_.daemon, setup_.daemon ^ 1, setup_.debug_level, setup_.config_file,
          (int const   )netdesc_[setup_.net_type].listen_port, setup_.pid_file, (int )setup_.ocat_dest_port,
          (int )tmp, "/dev/net/tun", "tor", setup_.ipv4_enable);
  }
#line 65
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
int open_logfile(void) 
{ 
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 76
  if (setup_.logfn) {
    {
#line 79
    f = fopen((char const   */* __restrict  */)setup_.logfn, (char const   */* __restrict  */)"a");
    }
#line 79
    if (f) {
      {
#line 81
      setup_.logf = f;
#line 83
      tmp___1 = setvbuf((FILE */* __restrict  */)setup_.logf, (char */* __restrict  */)((void *)0),
                        1, (size_t )0);
      }
#line 83
      if (tmp___1) {
        {
#line 84
        tmp = __errno_location();
#line 84
        tmp___0 = strerror(*tmp);
#line 84
        log_msg(3, "could not setup line buffering: %s", tmp___0);
        }
      }
      {
#line 85
      fflush(setup_.logf);
      }
#line 86
      return (0);
    }
    {
#line 89
    tmp___2 = __errno_location();
#line 89
    tmp___3 = strerror(*tmp___2);
#line 89
    log_msg(3, "could not open logfile %s: %s.", setup_.logfn, tmp___3);
    }
  }
#line 91
  return (-1);
}
}
#line 95 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
int mk_pid_file(void) 
{ 
  FILE *f ;
  char c ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 100
  f = fopen((char const   */* __restrict  */)setup_.pid_file, (char const   */* __restrict  */)"w");
  }
#line 100
  if (! f) {
    {
#line 102
    tmp = __errno_location();
#line 102
    tmp___0 = strerror(*tmp);
#line 102
    log_msg(3, "could not create pid_file %s: %s", setup_.pid_file, tmp___0);
    }
#line 103
    return (-1);
  }
  {
#line 106
  tmp___1 = getpid();
#line 106
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d\n", tmp___1);
#line 107
  fclose(f);
#line 110
  tmp___4 = pipe((int *)(setup_.pid_fd));
  }
#line 110
  if (tmp___4 == -1) {
    {
#line 112
    tmp___2 = __errno_location();
#line 112
    tmp___3 = strerror(*tmp___2);
#line 112
    log_msg(4, "could not open pid pipe: \"%s\"", tmp___3);
    }
#line 113
    return (-1);
  }
  {
#line 116
  tmp___5 = fork();
  }
  {
#line 118
  if (tmp___5 == -1) {
#line 118
    goto case_neg_1;
  }
#line 124
  if (tmp___5 == 0) {
#line 124
    goto case_0;
  }
#line 144
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 119
  oe_close(setup_.pid_fd[0]);
#line 120
  oe_close(setup_.pid_fd[1]);
  }
#line 121
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 125
  oe_close(setup_.pid_fd[1]);
#line 128
  oe_close(setup_.tunfd[0]);
  }
#line 129
  if (setup_.tunfd[0] != setup_.tunfd[1]) {
    {
#line 130
    oe_close(setup_.tunfd[1]);
    }
  }
  {
#line 133
  tmp___8 = read(setup_.pid_fd[0], (void *)(& c), (size_t )1);
  }
#line 133
  if (tmp___8 == -1L) {
    {
#line 134
    tmp___6 = __errno_location();
#line 134
    tmp___7 = strerror(*tmp___6);
#line 134
    log_msg(3, "error reading from pid_fd %d: \"%s\"", setup_.pid_fd[0], tmp___7);
#line 134
    exit(1);
    }
  }
  {
#line 137
  tmp___11 = unlink((char const   *)setup_.pid_file);
  }
#line 137
  if (tmp___11 == -1) {
    {
#line 138
    tmp___9 = __errno_location();
#line 138
    tmp___10 = strerror(*tmp___9);
#line 138
    log_msg(4, "error deleting pid ]ile \"%s\": \"%s\"", setup_.pid_file, tmp___10);
#line 138
    exit(1);
    }
  }
  {
#line 140
  log_msg(6, "pid file deleted, exiting.");
#line 141
  exit(0);
  }
  switch_default: /* CIL Label */ 
  {
#line 145
  oe_close(setup_.pid_fd[0]);
  }
  switch_break: /* CIL Label */ ;
  }
#line 149
  return (setup_.pid_fd[1]);
}
}
#line 153 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void background(void) 
{ 
  pid_t pid ;
  pid_t ppid ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  FILE *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  FILE *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  FILE *tmp___16 ;

  {
  {
#line 158
  ppid = getpid();
#line 159
  pid = fork();
  }
  {
#line 162
  if (pid == -1) {
#line 162
    goto case_neg_1;
  }
#line 167
  if (pid == 0) {
#line 167
    goto case_0;
  }
#line 183
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 163
  setup_.daemon = 0;
#line 164
  tmp = __errno_location();
#line 164
  tmp___0 = strerror(*tmp);
#line 164
  log_msg(3, "fork failed: %s. Staying in foreground", tmp___0);
  }
#line 165
  return;
  case_0: /* CIL Label */ 
  {
#line 168
  tmp___1 = getpid();
#line 168
  log_msg(6, "process backgrounded by parent %d, new pid = %d", ppid, tmp___1);
#line 169
  umask((__mode_t )0);
#line 170
  tmp___4 = setsid();
  }
#line 170
  if (tmp___4 == -1) {
    {
#line 171
    tmp___2 = __errno_location();
#line 171
    tmp___3 = strerror(*tmp___2);
#line 171
    log_msg(3, "could not set process group ID: \"%s\"", tmp___3);
    }
  }
  {
#line 172
  tmp___7 = chdir("/");
  }
#line 172
  if (tmp___7 == -1) {
    {
#line 173
    tmp___5 = __errno_location();
#line 173
    tmp___6 = strerror(*tmp___5);
#line 173
    log_msg(3, "could not change directory to /: \"%s\"", tmp___6);
    }
  }
  {
#line 175
  tmp___10 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
                     (FILE */* __restrict  */)stdin);
  }
#line 175
  if (! tmp___10) {
    {
#line 176
    tmp___8 = __errno_location();
#line 176
    tmp___9 = strerror(*tmp___8);
#line 176
    log_msg(3, "could not reconnect stdin to /dev/null: \"%s\"", tmp___9);
    }
  }
  {
#line 177
  tmp___13 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                     (FILE */* __restrict  */)stdout);
  }
#line 177
  if (! tmp___13) {
    {
#line 178
    tmp___11 = __errno_location();
#line 178
    tmp___12 = strerror(*tmp___11);
#line 178
    log_msg(3, "could not reconnect stdout to /dev/null: \"%s\"", tmp___12);
    }
  }
  {
#line 179
  tmp___16 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                     (FILE */* __restrict  */)stderr);
  }
#line 179
  if (! tmp___16) {
    {
#line 180
    tmp___14 = __errno_location();
#line 180
    tmp___15 = strerror(*tmp___14);
#line 180
    log_msg(3, "could not reconnect stderr to /dev/null: \"%s\"", tmp___15);
    }
  }
#line 181
  return;
  switch_default: /* CIL Label */ ;
#line 185
  if (setup_.logf) {
    {
#line 186
    fclose(setup_.logf);
    }
  }
  {
#line 187
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 193 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void sig_handler(int sig ) 
{ 
  int status ;

  {
  {
#line 199
  if (sig == 17) {
#line 199
    goto case_17;
  }
#line 204
  if (sig == 2) {
#line 204
    goto case_2;
  }
#line 204
  if (sig == 15) {
#line 204
    goto case_2;
  }
#line 212
  if (sig == 10) {
#line 212
    goto case_10;
  }
#line 197
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 201
  waitpid(-1, & status, 1);
  }
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 206
  if (setup_.sig_term) {
    {
#line 207
    exit(0);
    }
  }
#line 209
  setup_.sig_term = 1;
#line 210
  goto switch_break;
  case_10: /* CIL Label */ 
#line 213
  setup_.sig_usr1 = 1;
#line 214
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void install_sig(void) 
{ 
  struct sigaction sa ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 223
  memset((void *)(& sa), 0, sizeof(sa));
#line 224
  sa.__sigaction_handler.sa_handler = & sig_handler;
#line 226
  tmp___1 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 226
  if (tmp___1 == -1) {
    {
#line 227
    tmp = __errno_location();
#line 227
    tmp___0 = strerror(*tmp);
#line 227
    log_msg(3, "could not install SIGINT handler: \"%s\"", tmp___0);
#line 227
    exit(1);
    }
  }
  {
#line 228
  tmp___4 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 228
  if (tmp___4 == -1) {
    {
#line 229
    tmp___2 = __errno_location();
#line 229
    tmp___3 = strerror(*tmp___2);
#line 229
    log_msg(3, "could not install SIGINT handler: \"%s\"", tmp___3);
#line 229
    exit(1);
    }
  }
  {
#line 230
  tmp___7 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 230
  if (tmp___7 == -1) {
    {
#line 231
    tmp___5 = __errno_location();
#line 231
    tmp___6 = strerror(*tmp___5);
#line 231
    log_msg(3, "could not install SIGHUP handler: \"%s\"", tmp___6);
#line 231
    exit(1);
    }
  }
  {
#line 232
  tmp___10 = sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 232
  if (tmp___10 == -1) {
    {
#line 233
    tmp___8 = __errno_location();
#line 233
    tmp___9 = strerror(*tmp___8);
#line 233
    log_msg(3, "could not install SIGUSR1 handler: \"%s\"", tmp___9);
#line 233
    exit(1);
    }
  }
  {
#line 234
  tmp___13 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 234
  if (tmp___13 == -1) {
    {
#line 235
    tmp___11 = __errno_location();
#line 235
    tmp___12 = strerror(*tmp___11);
#line 235
    log_msg(3, "could not install SIGCHLD handler: \"%s\"", tmp___12);
#line 235
    exit(1);
    }
  }
#line 237
  return;
}
}
#line 240 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void cleanup_system(void) 
{ 
  OcatPeer_t *peer ;
  OcatPeer_t *next ;
  char c ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 245
  log_msg(5, "waiting for system cleanup...");
#line 251
  oe_close(setup_.tunfd[0]);
  }
#line 252
  if (setup_.tunfd[0] != setup_.tunfd[1]) {
    {
#line 253
    oe_close(setup_.tunfd[1]);
    }
  }
  {
#line 258
  lock_peers();
#line 259
  peer = get_first_peer();
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! peer) {
#line 259
      goto while_break;
    }
    {
#line 261
    lock_peer(peer);
#line 263
    oe_close(peer->tcpfd);
#line 264
    unlock_peer(peer);
#line 266
    next = peer->next;
#line 268
    delete_peer(peer);
#line 259
    peer = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  unlock_peers();
#line 272
  sig_socks_connector();
#line 275
  tmp = join_threads();
  }
#line 275
  if (tmp > 1) {
    {
#line 279
    sleep(10U);
    }
  }
  {
#line 282
  delete_listeners(setup_.oc_listen, setup_.oc_listen_fd, setup_.oc_listen_cnt);
  }
#line 284
  if (setup_.create_pid_file) {
#line 284
    if (setup_.pid_fd[1] != -1) {
      {
#line 286
      tmp___2 = write(setup_.pid_fd[1], (void const   *)(& c), (size_t )1);
      }
#line 286
      if (tmp___2 == -1L) {
        {
#line 287
        tmp___0 = __errno_location();
#line 287
        tmp___1 = strerror(*tmp___0);
#line 287
        log_msg(3, "cout not write to pid fd %d: \"%s\"", setup_.pid_fd[1], tmp___1);
        }
      }
    }
  }
#line 289
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
void parse_opt_early(int argc , char **argv_orig ) 
{ 
  int c ;
  int optf ;
  char **argv ;
  unsigned long __lengthofargv ;
  void *tmp ;

  {
  {
#line 294
  optf = 0;
#line 295
  __lengthofargv = (unsigned long )(argc + 1);
#line 295
  tmp = __builtin_alloca(sizeof(*argv) * __lengthofargv);
#line 295
  argv = (char **)tmp;
#line 300
  memcpy((void */* __restrict  */)(& argv), (void const   */* __restrict  */)argv_orig,
         sizeof(char *) * (unsigned long )(argc + 1));
#line 301
  opterr = 0;
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    c = getopt(argc, (char * const  *)argv, "f:I");
    }
#line 302
    if (! (c != -1)) {
#line 302
      goto while_break;
    }
    {
#line 307
    if (c == 102) {
#line 307
      goto case_102;
    }
#line 318
    if (c == 73) {
#line 318
      goto case_73;
    }
#line 322
    if (c == 63) {
#line 322
      goto case_63;
    }
#line 305
    goto switch_break;
    case_102: /* CIL Label */ 
#line 308
    if (! optf) {
      {
#line 310
      free((void *)setup_.config_file);
#line 311
      setup_.config_file = optarg;
#line 312
      optf ++;
      }
    } else {
      {
#line 315
      log_msg(3, "multiple options -f ignored");
      }
    }
#line 316
    goto switch_break;
    case_73: /* CIL Label */ 
#line 319
    setup_.net_type = 1;
#line 320
    goto switch_break;
    case_63: /* CIL Label */ 
#line 323
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
int parse_opt(int argc , char **argv ) 
{ 
  int c ;
  int urlconv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 331
  urlconv = 0;
#line 334
  opterr = 1;
#line 335
  optind = 1;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 336
    c = getopt(argc, (char * const  *)argv, "f:IabBCd:hHrRiopl:t:T:s:Uu:4L:P:");
    }
#line 336
    if (! (c != -1)) {
#line 336
      goto while_break;
    }
    {
#line 343
    if (c == 73) {
#line 343
      goto case_73;
    }
#line 343
    if (c == 102) {
#line 343
      goto case_73;
    }
#line 346
    if (c == 97) {
#line 346
      goto case_97;
    }
#line 350
    if (c == 98) {
#line 350
      goto case_98;
    }
#line 354
    if (c == 66) {
#line 354
      goto case_66;
    }
#line 358
    if (c == 67) {
#line 358
      goto case_67;
    }
#line 362
    if (c == 100) {
#line 362
      goto case_100;
    }
#line 366
    if (c == 105) {
#line 366
      goto case_105;
    }
#line 370
    if (c == 104) {
#line 370
      goto case_104;
    }
#line 374
    if (c == 72) {
#line 374
      goto case_72;
    }
#line 378
    if (c == 108) {
#line 378
      goto case_108;
    }
#line 387
    if (c == 76) {
#line 387
      goto case_76;
    }
#line 394
    if (c == 111) {
#line 394
      goto case_111;
    }
#line 398
    if (c == 112) {
#line 398
      goto case_112;
    }
#line 402
    if (c == 80) {
#line 402
      goto case_80;
    }
#line 410
    if (c == 114) {
#line 410
      goto case_114;
    }
#line 415
    if (c == 82) {
#line 415
      goto case_82;
    }
#line 419
    if (c == 115) {
#line 419
      goto case_115;
    }
#line 423
    if (c == 116) {
#line 423
      goto case_116;
    }
#line 431
    if (c == 84) {
#line 431
      goto case_84;
    }
#line 436
    if (c == 85) {
#line 436
      goto case_85;
    }
#line 440
    if (c == 117) {
#line 440
      goto case_117;
    }
#line 444
    if (c == 52) {
#line 444
      goto case_52;
    }
#line 448
    goto switch_default;
    case_73: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 344
    goto switch_break;
    case_97: /* CIL Label */ 
#line 347
    setup_.create_clog = 1;
#line 348
    goto switch_break;
    case_98: /* CIL Label */ 
#line 351
    setup_.daemon = 1;
#line 352
    goto switch_break;
    case_66: /* CIL Label */ 
#line 355
    setup_.daemon = 0;
#line 356
    goto switch_break;
    case_67: /* CIL Label */ 
#line 359
    setup_.controller = 0;
#line 360
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 363
    setup_.debug_level = atoi((char const   *)optarg);
    }
#line 364
    goto switch_break;
    case_105: /* CIL Label */ 
#line 367
    urlconv = 1;
#line 368
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 371
    usage((char const   *)*(argv + 0));
#line 372
    exit(1);
    }
    case_72: /* CIL Label */ 
#line 375
    setup_.hosts_lookup = 0;
#line 376
    goto switch_break;
    case_108: /* CIL Label */ 
#line 379
    if (setup_.oc_listen_cnt == -1) {
#line 380
      goto switch_break;
    }
    {
#line 381
    tmp = strcasecmp((char const   *)optarg, "none");
    }
#line 381
    if (tmp) {
      {
#line 384
      add_listener((char const   *)optarg);
      }
    } else {
#line 382
      setup_.oc_listen_cnt = -1;
    }
#line 385
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 388
    tmp___0 = strcmp((char const   *)optarg, "syslog");
    }
#line 388
    if (tmp___0) {
#line 391
      setup_.logfn = optarg;
    } else {
#line 389
      setup_.use_syslog = 1;
    }
#line 392
    goto switch_break;
    case_111: /* CIL Label */ 
#line 395
    urlconv = 2;
#line 396
    goto switch_break;
    case_112: /* CIL Label */ 
#line 399
    setup_.use_tap = 1;
#line 400
    goto switch_break;
    case_80: /* CIL Label */ 
#line 403
    setup_.create_pid_file = 1;
#line 404
    if ((int )*(optarg + 0) == 45) {
#line 405
      optind --;
    } else {
#line 407
      setup_.pid_file = optarg;
    }
#line 408
    goto switch_break;
    case_114: /* CIL Label */ 
#line 411
    setup_.runasroot = 1;
#line 412
    setup_.usrname = (char *)"root";
#line 413
    goto switch_break;
    case_82: /* CIL Label */ 
#line 416
    setup_.rand_addr = 1;
#line 417
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 420
    tmp___1 = atoi((char const   *)optarg);
#line 420
    setup_.ocat_dest_port = (uint16_t )tmp___1;
    }
#line 421
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 424
    tmp___3 = strcasecmp((char const   *)optarg, "none");
    }
#line 424
    if (tmp___3) {
      {
#line 426
      tmp___2 = strsockaddr((char const   *)optarg, (struct sockaddr *)setup_.__annonCompField5.socks_dst);
      }
#line 426
      if (tmp___2 == -1) {
        {
#line 427
        exit(1);
        }
      }
    } else {
#line 425
      (setup_.__annonCompField5.socks_dst)->sin_family = (sa_family_t )0;
    }
#line 428
    goto switch_break;
    case_84: /* CIL Label */ 
#line 432
    tun_dev_ = optarg;
#line 433
    goto switch_break;
    case_85: /* CIL Label */ 
#line 437
    setup_.unidirectional = 0;
#line 438
    goto switch_break;
    case_117: /* CIL Label */ 
#line 441
    setup_.usrname = optarg;
#line 442
    goto switch_break;
    case_52: /* CIL Label */ 
#line 445
    setup_.ipv4_enable = 1;
#line 446
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 449
    usage((char const   *)*(argv + 0));
#line 450
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return (urlconv);
}
}
#line 458 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocat.c"
int main(int argc , char **argv ) 
{ 
  char *s ;
  char ip6addr[46] ;
  char hw[20] ;
  char def[100] ;
  char pwdbuf[1024] ;
  int c ;
  struct passwd *pwd ;
  struct passwd pwdm ;
  int urlconv ;
  int mode_detect ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __uid_t tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  OcatThread_t const   *tmp___27 ;

  {
  {
#line 463
  urlconv = 0;
#line 463
  mode_detect = 0;
#line 465
  init_setup();
#line 469
  tmp = strstr((char const   *)*(argv + 0), "gcat");
  }
#line 469
  if (tmp) {
    {
#line 471
    setup_.net_type = 1;
#line 472
    snprintf((char */* __restrict  */)(def), (size_t )100, (char const   */* __restrict  */)"127.0.0.1:%d",
             (int const   )netdesc_[setup_.net_type].listen_port);
#line 473
    post_init_setup();
#line 474
    mode_detect = 1;
    }
  }
  {
#line 480
  parse_opt_early(argc, argv);
  }
#line 482
  if (! mode_detect) {
    {
#line 484
    snprintf((char */* __restrict  */)(def), (size_t )100, (char const   */* __restrict  */)"127.0.0.1:%d",
             (int const   )netdesc_[setup_.net_type].listen_port);
#line 485
    post_init_setup();
    }
  }
  {
#line 488
  c = open((char const   *)setup_.config_file, 0);
  }
#line 488
  if (c == -1) {
    {
#line 490
    tmp___0 = __errno_location();
#line 490
    setup_.config_failed = *tmp___0;
#line 491
    setup_.config_read = 1;
    }
  } else {
    {
#line 495
    ctrl_handler((void *)((long )c));
    }
  }
  {
#line 500
  urlconv = parse_opt(argc, argv);
  }
#line 503
  if (argc < 2) {
    {
#line 504
    usage((char const   *)*(argv + 0));
#line 504
    exit(1);
    }
  }
#line 506
  if (! setup_.rand_addr) {
#line 506
    if (! *(argv + optind)) {
      {
#line 507
      usage((char const   *)*(argv + 0));
#line 507
      exit(1);
      }
    }
  }
#line 509
  if (urlconv) {
#line 510
    setup_.daemon = 0;
  }
#line 513
  if (! setup_.daemon) {
#line 513
    if (! setup_.use_syslog) {
#line 514
      setup_.logf = stderr;
    }
  }
  {
#line 516
  tmp___1 = open_logfile();
  }
#line 516
  if (tmp___1 == -1) {
#line 516
    if (! setup_.logf) {
      {
#line 517
      openlog("onioncat", 9, 3 << 3);
      }
    }
  }
  {
#line 520
  init_ocat_thread("main");
#line 521
  detach_thread();
  }
#line 523
  if (setup_.config_failed) {
#line 523
    if (setup_.config_failed != 2) {
      {
#line 524
      tmp___2 = strerror(setup_.config_failed);
#line 524
      log_msg(5, "could not open config file %s: %s", setup_.config_file, tmp___2);
      }
    }
  }
#line 526
  if (urlconv == 2) {
    {
#line 528
    c = inet_pton(10, (char const   */* __restrict  */)*(argv + optind), (void */* __restrict  */)(& setup_.ocat_addr));
    }
#line 528
    if (c < 0) {
      {
#line 529
      tmp___3 = __errno_location();
#line 529
      tmp___4 = strerror(*tmp___3);
#line 529
      log_msg(3, "inet_pton failed: %s", tmp___4);
#line 529
      exit(1);
      }
    } else
#line 530
    if (! c) {
      {
#line 531
      log_msg(3, "%s is not a valid IPv6 address", *(argv + optind));
#line 531
      exit(1);
      }
    }
    {
#line 532
    tmp___5 = has_tor_prefix((struct in6_addr  const  *)(& setup_.ocat_addr));
    }
#line 532
    if (! tmp___5) {
      {
#line 533
      log_msg(3, "address does not have TOR prefix");
#line 533
      exit(1);
      }
    }
    {
#line 534
    ipv6tonion((struct in6_addr  const  *)(& setup_.ocat_addr), setup_.onion_url);
#line 535
    printf((char const   */* __restrict  */)"%s%s\n", setup_.onion_url, netdesc_[setup_.net_type].domain);
#line 536
    exit(0);
    }
  }
#line 541
  if (! setup_.rand_addr) {
    {
#line 542
    strncpy((char */* __restrict  */)(setup_.onion_url), (char const   */* __restrict  */)*(argv + optind),
            (size_t )netdesc_[setup_.net_type].name_size);
    }
  } else {
    {
#line 545
    rand_onion(setup_.onion_url);
    }
  }
  {
#line 548
  s = strchr((char const   *)(setup_.onion_url), '.');
  }
#line 548
  if (s) {
#line 549
    *s = (char )'\000';
  }
  {
#line 550
  tmp___6 = strlen((char const   *)(setup_.onion_url));
  }
#line 550
  if (tmp___6 != 16UL) {
    {
#line 551
    log_msg(3, "parameter seems not to be valid onion hostname");
#line 551
    exit(1);
    }
  }
  {
#line 552
  tmp___7 = oniontipv6((char const   *)(setup_.onion_url), & setup_.ocat_addr);
  }
#line 552
  if (tmp___7 == -1) {
    {
#line 553
    log_msg(3, "parameter seems not to be valid onion hostname");
#line 553
    exit(1);
    }
  }
#line 554
  if (setup_.ipv4_enable) {
    {
#line 555
    tmp___8 = ntohl((uint32_t )setup_.ocat_addr4_mask);
#line 555
    oniontipv4((char const   *)(setup_.onion_url), & setup_.ocat_addr4, (int )tmp___8);
    }
  }
  {
#line 557
  tmp___11 = inet_ntop(10, (void const   */* __restrict  */)(& setup_.ocat_addr),
                       (char */* __restrict  */)(ip6addr), (socklen_t )46);
  }
#line 557
  if (! tmp___11) {
    {
#line 558
    tmp___9 = __errno_location();
#line 558
    tmp___10 = strerror(*tmp___9);
#line 558
    log_msg(3, "cannot convert IP address with inet_ntop: \"%s\"", tmp___10);
#line 558
    exit(1);
    }
  }
#line 561
  if (urlconv == 1) {
    {
#line 563
    printf((char const   */* __restrict  */)"%s\n", ip6addr);
    }
#line 564
    if (setup_.ipv4_enable) {
      {
#line 565
      tmp___12 = inet_ntoa(setup_.ocat_addr4);
#line 565
      printf((char const   */* __restrict  */)"%s\n", tmp___12);
      }
    }
    {
#line 566
    exit(0);
    }
  }
  {
#line 569
  log_msg(6, "%s", setup_.version);
#line 571
  memcpy((void */* __restrict  */)(& setup_.ocat_hwaddr[3]), (void const   */* __restrict  */)(& setup_.ocat_addr.__in6_u.__u6_addr8[13]),
         (size_t )3);
  }
#line 572
  if (setup_.use_tap) {
    {
#line 573
    tmp___13 = ether_ntoa_r((struct ether_addr  const  *)((struct ether_addr *)(setup_.ocat_hwaddr)),
                            hw);
#line 573
    log_msg(6, "MAC address %s", tmp___13);
    }
  }
  {
#line 577
  setup_.tunfd[1] = tun_alloc(setup_.tunname, (int )sizeof(setup_.tunname), setup_.ocat_addr);
#line 577
  setup_.tunfd[0] = setup_.tunfd[1];
  }
#line 577
  if (setup_.tunfd[0] == -1) {
    {
#line 579
    log_msg(2, "error opening TUN/TAP device");
#line 580
    exit(1);
    }
  }
  {
#line 584
  log_msg(6, "IPv6 address %s", ip6addr);
#line 585
  log_msg(6, "TUN/TAP device %s", setup_.tunname);
  }
#line 586
  if (setup_.ipv4_enable) {
    {
#line 587
    tmp___14 = inet_ntoa(setup_.ocat_addr4);
#line 587
    log_msg(6, "IP address %s", tmp___14);
    }
  }
#line 592
  if (setup_.daemon) {
    {
#line 593
    background();
    }
  }
#line 596
  if (setup_.create_pid_file) {
    {
#line 597
    mk_pid_file();
    }
  }
#line 599
  if (! setup_.oc_listen_cnt) {
    {
#line 600
    add_listener((char const   *)(def));
    }
  }
  {
#line 603
  run_ocat_thread("receiver", & socket_receiver, (void *)0);
  }
#line 605
  if (setup_.oc_listen_cnt > 0) {
    {
#line 606
    run_ocat_thread("acceptor", & socket_acceptor, (void *)0);
    }
  } else {
    {
#line 608
    log_msg(6, "acceptor not started");
    }
  }
  {
#line 610
  run_ocat_thread("cleaner", & socket_cleaner, (void *)0);
#line 614
  c = getpwnam_r((char const   */* __restrict  */)setup_.usrname, (struct passwd */* __restrict  */)(& pwdm),
                 (char */* __restrict  */)(pwdbuf), (size_t )1024, (struct passwd **/* __restrict  */)(& pwd));
  }
#line 615
  if (! pwd) {
#line 617
    if (c) {
      {
#line 617
      tmp___15 = strerror(c);
#line 617
      tmp___16 = (char const   *)tmp___15;
      }
    } else {
#line 617
      tmp___16 = "user not found";
    }
    {
#line 617
    log_msg(4, "can\'t get information for user \"%s\": \"%s\", defaulting to uid %d",
            setup_.usrname, tmp___16, 65534);
#line 620
    memset((void *)(& pwdm), 0, sizeof(pwdm));
#line 621
    pwd = & pwdm;
#line 622
    pwd->pw_name = (char *)"(unknown)";
#line 623
    pwd->pw_uid = (__uid_t )65534;
#line 624
    pwd->pw_gid = (__gid_t )65534;
#line 625
    setup_.usrname = pwd->pw_name;
#line 626
    log_msg(5, "disabling connect log");
#line 627
    setup_.create_clog = 0;
    }
  }
#line 630
  if (! setup_.runasroot) {
    {
#line 630
    tmp___23 = getuid();
    }
#line 630
    if (! tmp___23) {
      {
#line 632
      log_msg(6, "running as root, changing uid/gid to %s (uid %d/gid %d)", setup_.usrname,
              pwd->pw_uid, pwd->pw_gid);
#line 633
      tmp___19 = setgid(pwd->pw_gid);
      }
#line 633
      if (tmp___19) {
        {
#line 634
        tmp___17 = __errno_location();
#line 634
        tmp___18 = strerror(*tmp___17);
#line 634
        log_msg(3, "could not change gid: \"%s\"", tmp___18);
#line 634
        exit(1);
        }
      }
      {
#line 635
      tmp___22 = setuid(pwd->pw_uid);
      }
#line 635
      if (tmp___22) {
        {
#line 636
        tmp___20 = __errno_location();
#line 636
        tmp___21 = strerror(*tmp___20);
#line 636
        log_msg(3, "could not change uid: \"%d\"", tmp___21);
#line 636
        exit(1);
        }
      }
    }
  }
#line 640
  if (setup_.create_clog) {
    {
#line 641
    open_connect_log((char const   *)pwd->pw_dir);
    }
  }
  {
#line 644
  tmp___26 = pipe((int *)(setup_.socksfd));
  }
#line 644
  if (tmp___26 == -1) {
    {
#line 645
    tmp___24 = __errno_location();
#line 645
    tmp___25 = strerror(*tmp___24);
#line 645
    log_msg(0, "couldn\'t create socks connector pipe: \"%s\"", tmp___25);
#line 645
    exit(1);
    }
  }
#line 646
  if ((setup_.__annonCompField5.socks_dst)->sin_family) {
    {
#line 647
    run_ocat_thread("connector", & socks_connector_sel, (void *)0);
    }
  } else {
    {
#line 649
    log_msg(6, "connector not started");
    }
  }
#line 656
  if (setup_.controller) {
    {
#line 657
    run_ocat_thread("controller", & ocat_controller, (void *)0);
    }
  }
  {
#line 668
  install_sig();
#line 671
  log_msg(6, "starting packet forwarder");
#line 672
  packet_forwarder();
#line 675
  cleanup_system();
#line 677
  log_msg(6, "Thanks for using OnionCat. Good Bye!");
#line 680
  tmp___27 = get_thread();
#line 680
  free((void *)((OcatThread_t *)tmp___27));
  }
#line 681
  return (0);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
static char const   BASE32[33]  = 
#line 31 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'\000'};
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
static char const   deBASE32_[41]  = 
#line 33
  {      (char const   )26,      (char const   )27,      (char const   )28,      (char const   )29, 
        (char const   )30,      (char const   )31,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )-1, 
        (char const   )-1,      (char const   )-1,      (char const   )-1,      (char const   )0, 
        (char const   )1,      (char const   )2,      (char const   )3,      (char const   )4, 
        (char const   )5,      (char const   )6,      (char const   )7,      (char const   )8, 
        (char const   )9,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )16, 
        (char const   )17,      (char const   )18,      (char const   )19,      (char const   )20, 
        (char const   )21,      (char const   )22,      (char const   )23,      (char const   )24, 
        (char const   )25};
#line 45 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
int has_tor_prefix(struct in6_addr  const  *addr ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = memcmp((void const   *)addr, (void const   *)(& netdesc_[setup_.net_type].prefix),
               (size_t )6);
  }
#line 47
  return (tmp == 0);
}
}
#line 51 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
void set_tor_prefix(struct in6_addr *addr ) 
{ 


  {
  {
#line 53
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)(& netdesc_[setup_.net_type].prefix),
         (size_t )6);
  }
#line 54
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
void shl5(char *bin ) 
{ 
  int i ;

  {
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < 15)) {
#line 65
      goto while_break;
    }
#line 67
    *(bin + i) = (char )((int )*(bin + i) << 5);
#line 68
    *(bin + i) = (char )((int )*(bin + i) | (((int )*(bin + (i + 1)) >> 3) & 31));
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  *(bin + i) = (char )((int )*(bin + i) << 5);
#line 71
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
int oniontipv6(char const   *onion , struct in6_addr *ip6 ) 
{ 
  int i ;
  int j ;

  {
  {
#line 78
  memset((void *)ip6, 0, sizeof(struct in6_addr ));
#line 80
  i = 0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < 16)) {
#line 80
      goto while_break;
    }
    {
#line 82
    shl5((char *)ip6);
#line 83
    j = toupper((int )*(onion + i));
    }
#line 84
    if (j < 50) {
#line 85
      return (-1);
    } else
#line 84
    if (j > 90) {
#line 85
      return (-1);
    }
#line 86
    j = (int )deBASE32_[j - 50];
#line 86
    if (j == -1) {
#line 87
      return (-1);
    }
#line 88
    *((char *)ip6 + 15) = (char )((int )*((char *)ip6 + 15) | j);
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  set_tor_prefix(ip6);
  }
#line 91
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
int oniontipv4(char const   *onion , struct in_addr *ip , int prefix_mask ) 
{ 
  struct in6_addr ip6 ;
  uint32_t netmask ;
  uint32_t ip4 ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 99
  netmask = (uint32_t )prefix_mask;
#line 102
  tmp = oniontipv6(onion, & ip6);
  }
#line 102
  if (tmp) {
#line 103
    return (-1);
  }
  {
#line 104
  memcpy((void */* __restrict  */)(& ip4), (void const   */* __restrict  */)(& ip6.__in6_u.__u6_addr8[12]),
         sizeof(ip4));
#line 105
  tmp___0 = htonl(~ netmask);
#line 105
  ip4 &= tmp___0;
#line 106
  ip->s_addr |= ip4;
  }
#line 107
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
char *ipv6tonion(struct in6_addr  const  *ip6 , char *onion ) 
{ 
  int i ;
  char bin[16] ;
  char *r ;

  {
  {
#line 120
  r = onion;
#line 122
  memcpy((void */* __restrict  */)(bin), (void const   */* __restrict  */)((char *)ip6 + 6),
         (size_t )10);
#line 124
  i = 0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 16)) {
#line 124
      goto while_break;
    }
    {
#line 126
    *onion = (char )BASE32[((int )bin[0] >> 3) & 31];
#line 127
    shl5(bin);
#line 124
    i ++;
#line 124
    onion ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  *onion = (char )'\000';
#line 130
  return (r);
}
}
#line 137 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
void rand_onion(char *onion ) 
{ 
  int i ;
  int tmp ;

  {
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < 16)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp = rand();
#line 145
    *onion = (char )BASE32[tmp & 31];
#line 144
    i ++;
#line 144
    onion ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  *onion = (char )'\000';
#line 147
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatv6conv.c"
char const   *inet_ntops(struct sockaddr  const  *saddr , struct sockaddr_str *sas ) 
{ 
  char *src ;
  int *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 164
  if ((int const   )saddr->sa_family == 2) {
#line 164
    goto case_2;
  }
#line 169
  if ((int const   )saddr->sa_family == 10) {
#line 169
    goto case_10;
  }
#line 174
  goto switch_default;
  case_2: /* CIL Label */ 
#line 165
  src = (char *)(& ((struct sockaddr_in *)saddr)->sin_addr);
#line 166
  sas->sstr_port = ((struct sockaddr_in *)saddr)->sin_port;
#line 167
  goto switch_break;
  case_10: /* CIL Label */ 
#line 170
  src = (char *)(& ((struct sockaddr_in6 *)saddr)->sin6_addr);
#line 171
  sas->sstr_port = ((struct sockaddr_in6 *)saddr)->sin6_port;
#line 172
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 175
  tmp = __errno_location();
#line 175
  *tmp = 97;
  }
#line 176
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 179
  sas->sstr_family = (sa_family_t )saddr->sa_family;
#line 180
  tmp___0 = inet_ntop((int )saddr->sa_family, (void const   */* __restrict  */)src,
                      (char */* __restrict  */)(sas->sstr_addr), (socklen_t )sizeof(sas->sstr_addr));
  }
#line 180
  return (tmp___0);
}
}
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 33 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
static IPv4Route_t *rroot_  =    (IPv4Route_t *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
static pthread_mutex_t route_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 40 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
int ipv4_add_route(IPv4Route_t *route , IPv4Route_t **root , uint32_t cur_nm ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  IPv4Route_t *tmp___1 ;
  void *tmp___2 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___3 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 42
  if (! *root) {
    {
#line 44
    tmp___2 = calloc((size_t )1, sizeof(IPv4Route_t ));
#line 44
    tmp___1 = (IPv4Route_t *)tmp___2;
#line 44
    *root = tmp___1;
    }
#line 44
    if (! tmp___1) {
      {
#line 46
      tmp = __errno_location();
#line 46
      tmp___0 = strerror(*tmp);
#line 46
      log_msg(0, "ipv4_add_route: %s", tmp___0);
      }
#line 47
      return (-1);
    }
#line 49
    (*root)->dest = route->dest & cur_nm;
#line 50
    (*root)->netmask = cur_nm;
  }
#line 53
  if (route->netmask == cur_nm) {
#line 55
    __a = (struct in6_addr  const  *)(& (*root)->gw);
#line 55
    __b = & in6addr_any;
#line 55
    if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 55
      if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 55
        if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 55
          if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 55
            tmp___3 = 1;
          } else {
#line 55
            tmp___3 = 0;
          }
        } else {
#line 55
          tmp___3 = 0;
        }
      } else {
#line 55
        tmp___3 = 0;
      }
    } else {
#line 55
      tmp___3 = 0;
    }
#line 55
    if (tmp___3) {
      {
#line 57
      memcpy((void */* __restrict  */)(& (*root)->gw), (void const   */* __restrict  */)(& route->gw),
             sizeof(struct in6_addr ));
      }
#line 58
      return (0);
    }
#line 61
    __a___0 = (struct in6_addr  const  *)(& (*root)->gw);
#line 61
    __b___0 = (struct in6_addr  const  *)(& route->gw);
#line 61
    if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 61
      if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 61
        if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 61
          if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 61
            tmp___4 = 1;
          } else {
#line 61
            tmp___4 = 0;
          }
        } else {
#line 61
          tmp___4 = 0;
        }
      } else {
#line 61
        tmp___4 = 0;
      }
    } else {
#line 61
      tmp___4 = 0;
    }
#line 61
    if (tmp___4) {
#line 62
      return (0);
    }
    {
#line 64
    log_msg(3, "route already exists");
    }
#line 65
    return (-2);
  }
#line 69
  if (cur_nm == 4294967295U) {
    {
#line 71
    log_msg(3, "netmask error in netmask of route: %08x", route->netmask);
    }
#line 72
    return (-3);
  }
  {
#line 76
  cur_nm >>= 1;
#line 77
  cur_nm |= 2147483648U;
#line 79
  tmp___5 = ipv4_add_route(route, & (*root)->next[((route->dest & cur_nm) & ~ (cur_nm << 1)) != 0U],
                           cur_nm);
  }
#line 79
  return (tmp___5);
}
}
#line 83 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
IPv4Route_t *ipv4_lookup_route__(uint32_t ip , IPv4Route_t *route , uint32_t cur_nm ) 
{ 
  IPv4Route_t *tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___0 ;

  {
#line 85
  if (! route) {
#line 88
    return ((IPv4Route_t *)((void *)0));
  }
#line 91
  cur_nm >>= 1;
#line 92
  cur_nm |= 2147483648U;
#line 94
  if (route->next[((ip & cur_nm) & ~ (cur_nm << 1)) != 0U]) {
    {
#line 95
    tmp = ipv4_lookup_route__(ip, route->next[((ip & cur_nm) & ~ (cur_nm << 1)) != 0U],
                              cur_nm);
    }
#line 95
    return (tmp);
  }
#line 98
  __a = (struct in6_addr  const  *)(& route->gw);
#line 98
  __b = & in6addr_any;
#line 98
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 98
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 98
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 98
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 98
          tmp___0 = 1;
        } else {
#line 98
          tmp___0 = 0;
        }
      } else {
#line 98
        tmp___0 = 0;
      }
    } else {
#line 98
      tmp___0 = 0;
    }
  } else {
#line 98
    tmp___0 = 0;
  }
#line 98
  if (! tmp___0) {
#line 99
    return (route);
  }
#line 101
  return ((IPv4Route_t *)((void *)0));
}
}
#line 108 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
struct in6_addr *ipv4_lookup_route(uint32_t ip ) 
{ 
  IPv4Route_t *r ;
  struct in6_addr *tmp ;

  {
  {
#line 112
  pthread_mutex_lock(& route_mutex_);
#line 113
  r = ipv4_lookup_route__(ip, rroot_, (uint32_t )0);
#line 114
  pthread_mutex_unlock(& route_mutex_);
  }
#line 116
  if (r) {
#line 116
    tmp = & r->gw;
  } else {
#line 116
    tmp = (struct in6_addr *)((void *)0);
  }
#line 116
  return (tmp);
}
}
#line 120 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
void ipv4_traverse(IPv4Route_t *route , void (*func)(IPv4Route_t * , void * ) , void *p ) 
{ 


  {
#line 122
  if (! route) {
#line 123
    return;
  }
  {
#line 125
  (*func)(route, p);
#line 126
  ipv4_traverse(route->next[0], func, p);
#line 127
  ipv4_traverse(route->next[1], func, p);
  }
#line 128
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
void ipv4_print(IPv4Route_t *route , void *f ) 
{ 
  char addr[46] ;
  struct in_addr iaddr ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 137
  __a = (struct in6_addr  const  *)(& route->gw);
#line 137
  __b = & in6addr_any;
#line 137
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 137
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 137
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 137
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 137
          tmp = 1;
        } else {
#line 137
          tmp = 0;
        }
      } else {
#line 137
        tmp = 0;
      }
    } else {
#line 137
      tmp = 0;
    }
  } else {
#line 137
    tmp = 0;
  }
#line 137
  if (tmp) {
#line 138
    return;
  }
  {
#line 140
  iaddr.s_addr = htonl(route->dest);
#line 141
  tmp___0 = inet_ntoa(iaddr);
#line 141
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"IN  %s ",
          tmp___0);
#line 142
  iaddr.s_addr = htonl(route->netmask);
#line 143
  tmp___1 = inet_ntoa(iaddr);
#line 143
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s ", tmp___1);
#line 144
  inet_ntop(10, (void const   */* __restrict  */)(& route->gw), (char */* __restrict  */)(addr),
            (socklen_t )46);
#line 145
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s %p\n",
          addr, route);
  }
#line 146
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
void print_routes(FILE *f ) 
{ 


  {
  {
#line 151
  ipv4_traverse(rroot_, & ipv4_print, (void *)f);
  }
#line 152
  return;
}
}
#line 155 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatipv4route.c"
int parse_route(char const   *rs ) 
{ 
  size_t tmp ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___0 ;
  char *s ;
  char *b ;
  IPv4Route_t route ;
  int r ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___6 ;

  {
  {
#line 157
  tmp = strlen(rs);
#line 157
  __lengthofbuf = tmp + 1UL;
#line 157
  tmp___0 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 157
  buf = (char *)tmp___0;
  }
#line 161
  if (! rs) {
#line 162
    return (-5);
  }
  {
#line 166
  tmp___1 = strlen(rs);
#line 166
  strlcpy(buf, rs, tmp___1 + 1UL);
#line 167
  s = strtok_r((char */* __restrict  */)buf, (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 167
  if (! s) {
#line 168
    return (-4);
  }
  {
#line 170
  tmp___2 = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& route.dest));
  }
#line 170
  if (tmp___2 != 1) {
#line 171
    return (-4);
  }
  {
#line 173
  s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 173
  if (! s) {
#line 174
    return (-4);
  }
  {
#line 176
  tmp___3 = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& route.netmask));
  }
#line 176
  if (tmp___3 != 1) {
#line 177
    return (-4);
  }
  {
#line 179
  s = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
               (char **/* __restrict  */)(& b));
  }
#line 179
  if (! s) {
#line 180
    return (-4);
  }
  {
#line 182
  tmp___4 = inet_pton(10, (char const   */* __restrict  */)s, (void */* __restrict  */)(& route.gw));
  }
#line 182
  if (tmp___4 != 1) {
#line 183
    return (-4);
  }
  {
#line 185
  tmp___5 = has_tor_prefix((struct in6_addr  const  *)(& route.gw));
  }
#line 185
  if (! tmp___5) {
#line 186
    return (-6);
  }
#line 188
  __a = (struct in6_addr  const  *)(& route.gw);
#line 188
  __b = (struct in6_addr  const  *)(& setup_.ocat_addr);
#line 188
  if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 188
    if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 188
      if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 188
        if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 188
          tmp___6 = 1;
        } else {
#line 188
          tmp___6 = 0;
        }
      } else {
#line 188
        tmp___6 = 0;
      }
    } else {
#line 188
      tmp___6 = 0;
    }
  } else {
#line 188
    tmp___6 = 0;
  }
#line 188
  if (tmp___6) {
#line 189
    return (-7);
  }
  {
#line 191
  route.netmask = ntohl(route.netmask);
#line 192
  route.dest = ntohl(route.dest);
#line 194
  pthread_mutex_lock(& route_mutex_);
#line 195
  r = ipv4_add_route(& route, & rroot_, (uint32_t )0);
#line 196
  pthread_mutex_unlock(& route_mutex_);
  }
#line 198
  return (r);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 34 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
static pthread_mutex_t log_mutex_  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 35 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
static char const   *flty_[8]  = 
#line 35
  {      "emerg",      "alert",      "crit",      "err", 
        "warning",      "notice",      "info",      "debug"};
#line 37 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
static FILE *clog_  =    (FILE *)((void *)0);
#line 46 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
int open_connect_log(char const   *dir ) 
{ 
  char buf[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 50
  if (clog_) {
#line 51
    return (0);
  }
#line 53
  if (! dir) {
#line 56
    return (-1);
  }
  {
#line 59
  strlcpy(buf, dir, (size_t )1024);
#line 60
  strlcat(buf, "/", (size_t )1024);
#line 61
  strlcat(buf, (char const   *)setup_.ocat_dir, (size_t )1024);
#line 64
  tmp___1 = mkdir((char const   *)(buf), (__mode_t )((448 | (256 >> 3)) | (64 >> 3)));
  }
#line 64
  if (tmp___1) {
    {
#line 64
    tmp___2 = __errno_location();
    }
#line 64
    if (*tmp___2 != 17) {
      {
#line 66
      tmp = __errno_location();
#line 66
      tmp___0 = strerror(*tmp);
#line 66
      log_msg(3, "could not create ocat directory \"%s\": \"%s\"", buf, tmp___0);
      }
#line 67
      return (-1);
    }
  }
  {
#line 70
  strlcat(buf, "/", (size_t )1024);
#line 71
  strlcat(buf, (char const   *)netdesc_[setup_.net_type].clog_file, (size_t )1024);
#line 74
  clog_ = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"a");
  }
#line 74
  if (! clog_) {
    {
#line 76
    tmp___3 = __errno_location();
#line 76
    tmp___4 = strerror(*tmp___3);
#line 76
    log_msg(3, "could not open connect log \"%s\": \"%s\"", buf, tmp___4);
    }
#line 77
    return (-1);
  }
  {
#line 79
  log_msg(1029, "connect log started");
  }
#line 80
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
void vlog_msgf(FILE *out , int lf , char const   *fmt , va_list ap ) 
{ 
  struct timeval tv ;
  struct tm *tm ;
  time_t t ;
  char timestr[64] ;
  unsigned int tmp ;
  char timez[64] ;
  unsigned int tmp___0 ;
  OcatThread_t const   *th ;
  OcatThread_t const   *tmp___1 ;
  OcatThread_t ths ;
  int level ;
  char buf[1024] ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 95
  timestr[0] = (char )'\000';
#line 95
  tmp = 1U;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (tmp >= 64U) {
#line 95
      goto while_break;
    }
#line 95
    timestr[tmp] = (char)0;
#line 95
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  timez[0] = (char )'\000';
#line 95
  tmp___0 = 1U;
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (tmp___0 >= 64U) {
#line 95
      goto while_break___0;
    }
#line 95
    timez[tmp___0] = (char)0;
#line 95
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  tmp___1 = get_thread();
#line 96
  th = tmp___1;
#line 98
  level = lf & 7;
  }
#line 101
  if (setup_.debug_level < level) {
#line 102
    return;
  }
  {
#line 105
  tmp___4 = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 105
  if (tmp___4 == -1) {
    {
#line 106
    tmp___2 = __errno_location();
#line 106
    tmp___3 = strerror(*tmp___2);
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
            "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c", 106,
            tmp___3);
#line 106
    exit(1);
    }
  }
  {
#line 107
  t = tv.tv_sec;
#line 108
  tm = localtime((time_t const   *)(& t));
  }
#line 108
  if (tm) {
    {
#line 110
    strftime((char */* __restrict  */)(timestr), (size_t )64, (char const   */* __restrict  */)"%a, %d %b %Y %H:%M:%S",
             (struct tm  const  */* __restrict  */)tm);
#line 111
    strftime((char */* __restrict  */)(timez), (size_t )64, (char const   */* __restrict  */)"%z",
             (struct tm  const  */* __restrict  */)tm);
    }
  }
#line 115
  if (! th) {
    {
#line 117
    strlcpy(ths.name, "<NEW/DIE>", (size_t )11);
#line 118
    ths.id = -1;
#line 119
    th = (OcatThread_t const   *)(& ths);
    }
  }
  {
#line 122
  pthread_mutex_lock(& log_mutex_);
  }
#line 123
  if (out) {
    {
#line 125
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s.%03d %s [%d:%-*s:%6s] ",
            timestr, (int )(tv.tv_usec / 1000L), timez, th->id, 10, th->name, flty_[level]);
#line 126
    vfprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)fmt, ap);
#line 127
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 133
    vsnprintf((char */* __restrict  */)(buf), (size_t )1024, (char const   */* __restrict  */)fmt,
              ap);
#line 134
    syslog(level | (3 << 3), "[%s] %s", th->name, buf);
    }
  }
  {
#line 137
  pthread_mutex_unlock(& log_mutex_);
  }
#line 138
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/onioncat-0.2.2+svn559/src/ocatlog.c"
void log_msg(int lf , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 151
  __builtin_va_start(ap, fmt);
#line 152
  vlog_msgf(setup_.logf, lf, fmt, ap);
#line 153
  __builtin_va_end(ap);
  }
#line 154
  if (clog_) {
#line 154
    if (lf & 1024) {
      {
#line 156
      __builtin_va_start(ap, fmt);
#line 157
      vlog_msgf(clog_, lf, fmt, ap);
#line 158
      __builtin_va_end(ap);
#line 159
      fflush(clog_);
      }
    }
  }
#line 161
  if (lf & 2048) {
    {
#line 163
    __builtin_va_start(ap, fmt);
#line 164
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
#line 165
    __builtin_va_end(ap);
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 168
  return;
}
}
